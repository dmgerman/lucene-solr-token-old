begin_unit
begin_package
DECL|package|org.apache.lucene.analysis.de
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|de
package|;
end_package
begin_comment
comment|/**  * A stemmer for german words. The algorithm is based on the report  * "A Fast and Simple Stemming Algorithm for German Words" by Jörg  * Caumanns (joerg.caumanns@isst.fhg.de).  *  * @author    Gerhard Schwarz  * @version   $Id$  */
end_comment
begin_class
DECL|class|GermanStemmer
specifier|public
class|class
name|GermanStemmer
block|{
comment|/** 	 * Buffer for the terms while stemming them. 	 */
DECL|field|sb
specifier|private
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
comment|/** 	 * Indicates if a term is handled as a noun. 	 */
DECL|field|uppercase
specifier|private
name|boolean
name|uppercase
init|=
literal|false
decl_stmt|;
comment|/** 	 * Amount of characters that are removed with<tt>substitute()</tt> while stemming. 	 */
DECL|field|substCount
specifier|private
name|int
name|substCount
init|=
literal|0
decl_stmt|;
DECL|method|GermanStemmer
specifier|public
name|GermanStemmer
parameter_list|()
block|{ 	}
comment|/** 	 * Stemms the given term to an unique<tt>discriminator</tt>. 	 * 	 * @param term  The term that should be stemmed. 	 * @return      Discriminator for<tt>term</tt> 	 */
DECL|method|stem
specifier|protected
name|String
name|stem
parameter_list|(
name|String
name|term
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isStemmable
argument_list|(
name|term
argument_list|)
condition|)
block|{
return|return
name|term
return|;
block|}
comment|// Mark a possible noun.
if|if
condition|(
name|Character
operator|.
name|isUpperCase
argument_list|(
name|term
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|uppercase
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|uppercase
operator|=
literal|false
expr_stmt|;
block|}
comment|// Use lowercase for medium stemming.
name|term
operator|=
name|term
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
comment|// Reset the StringBuffer.
name|sb
operator|.
name|delete
argument_list|(
literal|0
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|sb
operator|=
name|substitute
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|// Nouns have only seven possible suffixes.
if|if
condition|(
name|uppercase
operator|&&
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|substring
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
literal|"ern"
argument_list|)
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sb
operator|.
name|substring
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
literal|"en"
argument_list|)
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sb
operator|.
name|substring
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
literal|"er"
argument_list|)
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sb
operator|.
name|substring
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
literal|"es"
argument_list|)
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'e'
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'n'
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'s'
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Additional step for female plurals of professions and inhabitants.
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|5
operator|&&
name|sb
operator|.
name|substring
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|3
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
literal|"erin*"
argument_list|)
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Additional step for irregular plural nouns like "Matrizen -> Matrix".
if|if
condition|(
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
operator|(
literal|'z'
operator|)
condition|)
block|{
name|sb
operator|.
name|setCharAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
literal|'x'
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Strip the 7 "base" suffixes: "e", "s", "n", "t", "em", "er", "nd" from all
comment|// other terms. Adjectives, Verbs and Adverbs have a total of 52 different
comment|// possible suffixes, stripping only the characters from they are build
comment|// does mostly the same
else|else
block|{
comment|// Strip base suffixes as long as enough characters remain.
name|boolean
name|doMore
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|3
operator|&&
name|doMore
condition|)
block|{
if|if
condition|(
operator|(
name|sb
operator|.
name|length
argument_list|()
operator|+
name|substCount
operator|>
literal|5
operator|)
operator|&&
name|sb
operator|.
name|substring
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
literal|"nd"
argument_list|)
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sb
operator|.
name|length
argument_list|()
operator|+
name|substCount
operator|>
literal|4
operator|)
operator|&&
name|sb
operator|.
name|substring
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
literal|"er"
argument_list|)
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sb
operator|.
name|length
argument_list|()
operator|+
name|substCount
operator|>
literal|4
operator|)
operator|&&
name|sb
operator|.
name|substring
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
literal|"em"
argument_list|)
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'t'
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'n'
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'s'
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'e'
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doMore
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
name|sb
operator|=
name|resubstitute
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uppercase
condition|)
block|{
name|sb
operator|=
name|removeParticleDenotion
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** 	 * Removes a particle denotion ("ge") from a term, but only if at least 3 	 * characters will remain. 	 * 	 * @return  The term without particle denotion, if there was one. 	 */
DECL|method|removeParticleDenotion
specifier|private
name|StringBuffer
name|removeParticleDenotion
parameter_list|(
name|StringBuffer
name|buffer
parameter_list|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|buffer
operator|.
name|length
argument_list|()
condition|;
name|c
operator|++
control|)
block|{
comment|// Strip from the beginning of the string to the "ge" inclusive
if|if
condition|(
name|c
operator|<
operator|(
name|buffer
operator|.
name|length
argument_list|()
operator|-
literal|4
operator|)
operator|&&
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'g'
operator|&&
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|+
literal|1
argument_list|)
operator|==
literal|'e'
condition|)
block|{
name|buffer
operator|.
name|delete
argument_list|(
literal|0
argument_list|,
name|c
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
return|;
block|}
comment|/** 	 * Do some substitutions for the term to reduce overstemming: 	 * 	 * - Substitute Umlauts with their corresponding vowel: äöü -> aou, 	 *   "ß" is substituted by "ss" 	 * - Substitute a second char of an pair of equal characters with 	 *   an asterisk: ?? -> ?* 	 * - Substitute some common character combinations with a token: 	 *   sch/ch/ei/ie/ig/st -> $/§/%/&/#/! 	 * 	 * @return  The term with all needed substitutions. 	 */
DECL|method|substitute
specifier|private
name|StringBuffer
name|substitute
parameter_list|(
name|StringBuffer
name|buffer
parameter_list|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|buffer
operator|.
name|length
argument_list|()
condition|;
name|c
operator|++
control|)
block|{
comment|// Replace the second char of a pair of the equal characters with an asterisk
if|if
condition|(
name|c
operator|>
literal|0
operator|&&
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|-
literal|1
argument_list|)
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
block|}
comment|// Substitute Umlauts.
elseif|else
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'ä'
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'a'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'ö'
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'o'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'ü'
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'u'
argument_list|)
expr_stmt|;
block|}
comment|// Take care that at least one character is left left side from the current one
if|if
condition|(
name|c
operator|<
name|buffer
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'ß'
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'s'
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|insert
argument_list|(
name|c
operator|+
literal|1
argument_list|,
literal|'s'
argument_list|)
expr_stmt|;
name|substCount
operator|++
expr_stmt|;
block|}
comment|// Masking several common character combinations with an token
elseif|else
if|if
condition|(
operator|(
name|c
operator|<
name|buffer
operator|.
name|length
argument_list|()
operator|-
literal|2
operator|)
operator|&&
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'s'
operator|&&
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|+
literal|1
argument_list|)
operator|==
literal|'c'
operator|&&
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|+
literal|2
argument_list|)
operator|==
literal|'h'
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'$'
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|delete
argument_list|(
name|c
operator|+
literal|1
argument_list|,
name|c
operator|+
literal|3
argument_list|)
expr_stmt|;
name|substCount
operator|=
operator|+
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'c'
operator|&&
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|+
literal|1
argument_list|)
operator|==
literal|'h'
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'§'
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|deleteCharAt
argument_list|(
name|c
operator|+
literal|1
argument_list|)
expr_stmt|;
name|substCount
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'e'
operator|&&
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|+
literal|1
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|deleteCharAt
argument_list|(
name|c
operator|+
literal|1
argument_list|)
expr_stmt|;
name|substCount
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'i'
operator|&&
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|+
literal|1
argument_list|)
operator|==
literal|'e'
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'&'
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|deleteCharAt
argument_list|(
name|c
operator|+
literal|1
argument_list|)
expr_stmt|;
name|substCount
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'i'
operator|&&
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|+
literal|1
argument_list|)
operator|==
literal|'g'
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|deleteCharAt
argument_list|(
name|c
operator|+
literal|1
argument_list|)
expr_stmt|;
name|substCount
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'s'
operator|&&
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|+
literal|1
argument_list|)
operator|==
literal|'t'
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|deleteCharAt
argument_list|(
name|c
operator|+
literal|1
argument_list|)
expr_stmt|;
name|substCount
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|buffer
return|;
block|}
comment|/** 	 * Checks a term if it can be processed correctly. 	 * 	 * @return  true if, and only if, the given term consists in letters. 	 */
DECL|method|isStemmable
specifier|private
name|boolean
name|isStemmable
parameter_list|(
name|String
name|term
parameter_list|)
block|{
name|boolean
name|upper
init|=
literal|false
decl_stmt|;
name|int
name|first
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|term
operator|.
name|length
argument_list|()
condition|;
name|c
operator|++
control|)
block|{
comment|// Discard terms that contain non-letter characters.
if|if
condition|(
operator|!
name|Character
operator|.
name|isLetter
argument_list|(
name|term
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Discard terms that contain multiple uppercase letters.
if|if
condition|(
name|Character
operator|.
name|isUpperCase
argument_list|(
name|term
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|upper
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// First encountered uppercase letter, set flag and save
comment|// position.
else|else
block|{
name|first
operator|=
name|c
expr_stmt|;
name|upper
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|// Discard the term if it contains a single uppercase letter that
comment|// is not starting the term.
if|if
condition|(
name|first
operator|>
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/** 	 * Undoes the changes made by substitute(). That are character pairs and 	 * character combinations. Umlauts will remain as their corresponding vowel, 	 * as "ß" remains as "ss". 	 * 	 * @return  The term without the not human readable substitutions. 	 */
DECL|method|resubstitute
specifier|private
name|StringBuffer
name|resubstitute
parameter_list|(
name|StringBuffer
name|buffer
parameter_list|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|buffer
operator|.
name|length
argument_list|()
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'*'
condition|)
block|{
name|char
name|x
init|=
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|-
literal|1
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'$'
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'s'
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|insert
argument_list|(
name|c
operator|+
literal|1
argument_list|,
operator|new
name|char
index|[]
block|{
literal|'c'
block|,
literal|'h'
block|}
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'§'
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|insert
argument_list|(
name|c
operator|+
literal|1
argument_list|,
literal|'h'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'%'
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'e'
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|insert
argument_list|(
name|c
operator|+
literal|1
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'&'
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|insert
argument_list|(
name|c
operator|+
literal|1
argument_list|,
literal|'e'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'#'
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|insert
argument_list|(
name|c
operator|+
literal|1
argument_list|,
literal|'g'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
operator|==
literal|'!'
condition|)
block|{
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'s'
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|insert
argument_list|(
name|c
operator|+
literal|1
argument_list|,
literal|'t'
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buffer
return|;
block|}
block|}
end_class
end_unit
