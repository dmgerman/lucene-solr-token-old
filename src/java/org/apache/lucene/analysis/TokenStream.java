begin_unit
begin_package
DECL|package|org.apache.lucene.analysis
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Payload
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Attribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|AttributeSource
import|;
end_import
begin_comment
comment|/** A TokenStream enumerates the sequence of tokens, either from   fields of a document or from query text.<p>   This is an abstract class.  Concrete subclasses are:<ul><li>{@link Tokenizer}, a TokenStream   whose input is a Reader; and<li>{@link TokenFilter}, a TokenStream   whose input is another TokenStream.</ul>   A new TokenStream API is introduced with Lucene 2.9. Since   2.9 Token is deprecated and the preferred way to store   the information of a token is to use {@link Attribute}s.<p>   For that reason TokenStream extends {@link AttributeSource}   now. Note that only one instance per {@link Attribute} is   created and reused for every token. This approach reduces   object creations and allows local caching of references to   the {@link Attribute}s. See {@link #incrementToken()} for further details.<p><b>The workflow of the new TokenStream API is as follows:</b><ol><li>Instantiation of TokenStream/TokenFilters which add/get attributes         to/from the {@link AttributeSource}.<li>The consumer calls {@link TokenStream#reset()}.<li>the consumer retrieves attributes from the         stream and stores local references to all attributes it wants to access<li>The consumer calls {@link #incrementToken()} until it returns false and         consumes the attributes after each call.</ol>   To make sure that filters and consumers know which attributes are available   the attributes must be added in the during instantiation. Filters and    consumers are not required to check for availability of attributes in {@link #incrementToken()}.<p>   Sometimes it is desirable to capture a current state of a   TokenStream, e. g. for buffering purposes (see {@link CachingTokenFilter},   {@link TeeTokenFilter}/{@link SinkTokenizer}). For this usecase   {@link AttributeSource#captureState()} and {@link AttributeSource#restoreState(AttributeSource)} can be used.<p><b>NOTE:</b> In order to enable the new API the method   {@link #useNewAPI()} has to be called with useNewAPI=true.   Otherwise the deprecated method {@link #next(Token)} will    be used by Lucene consumers (indexer and queryparser) to   consume the tokens. {@link #next(Token)} will be removed   in Lucene 3.0.<p>   NOTE: To use the old API subclasses must override {@link #next(Token)}.   It's also OK to instead override {@link #next()} but that   method is slower compared to {@link #next(Token)}.  *<p><font color="#FF0000">  * WARNING: The status of the new TokenStream, AttributeSource and Attributes is experimental.   * The APIs introduced in these classes with Lucene 2.9 might change in the future.   * We will make our best efforts to keep the APIs backwards-compatible.</font>   */
end_comment
begin_class
DECL|class|TokenStream
specifier|public
specifier|abstract
class|class
name|TokenStream
extends|extends
name|AttributeSource
block|{
DECL|field|useNewAPIDefault
specifier|private
specifier|static
name|boolean
name|useNewAPIDefault
init|=
literal|false
decl_stmt|;
DECL|field|useNewAPI
specifier|private
name|boolean
name|useNewAPI
init|=
name|useNewAPIDefault
decl_stmt|;
DECL|method|TokenStream
specifier|protected
name|TokenStream
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
DECL|method|TokenStream
specifier|protected
name|TokenStream
parameter_list|(
name|AttributeSource
name|input
parameter_list|)
block|{
name|super
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns whether or not the new TokenStream APIs are used    * by default.     * (see {@link #incrementToken()}, {@link AttributeSource}).    */
DECL|method|useNewAPIDefault
specifier|public
specifier|static
name|boolean
name|useNewAPIDefault
parameter_list|()
block|{
return|return
name|useNewAPIDefault
return|;
block|}
comment|/**    * Use this API to enable or disable the new TokenStream API.    * by default. Can be overridden by calling {@link #setUseNewAPI(boolean)}.     * (see {@link #incrementToken()}, {@link AttributeSource}).    *<p>    * If set to true, the indexer will call {@link #incrementToken()}     * to consume Tokens from this stream.    *<p>    * If set to false, the indexer will call {@link #next(Token)}    * instead.     */
DECL|method|setUseNewAPIDefault
specifier|public
specifier|static
name|void
name|setUseNewAPIDefault
parameter_list|(
name|boolean
name|use
parameter_list|)
block|{
name|useNewAPIDefault
operator|=
name|use
expr_stmt|;
block|}
comment|/**    * Returns whether or not the new TokenStream APIs are used     * for this stream.    * (see {@link #incrementToken()}, {@link AttributeSource}).    */
DECL|method|useNewAPI
specifier|public
name|boolean
name|useNewAPI
parameter_list|()
block|{
return|return
name|useNewAPI
return|;
block|}
comment|/**    * Use this API to enable or disable the new TokenStream API    * for this stream. Overrides {@link #setUseNewAPIDefault(boolean)}.    * (see {@link #incrementToken()}, {@link AttributeSource}).    *<p>    * If set to true, the indexer will call {@link #incrementToken()}     * to consume Tokens from this stream.    *<p>    * If set to false, the indexer will call {@link #next(Token)}    * instead.     *<p>    *<b>NOTE: All streams and filters in one chain must use the    * same API.</b>    */
DECL|method|setUseNewAPI
specifier|public
name|void
name|setUseNewAPI
parameter_list|(
name|boolean
name|use
parameter_list|)
block|{
name|useNewAPI
operator|=
name|use
expr_stmt|;
block|}
comment|/** 	 * Consumers (e. g. the indexer) use this method to advance the stream  	 * to the next token. Implementing classes must implement this method  	 * and update the appropriate {@link Attribute}s with content of the  	 * next token. 	 *<p> 	 * This method is called for every token of a document, so an efficient 	 * implementation is crucial for good performance. To avoid calls to  	 * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} and 	 * downcasts, references to all {@link Attribute}s that this stream uses  	 * should be retrieved during instantiation.    	 *<p> 	 * To make sure that filters and consumers know which attributes are available    * the attributes must be added during instantiation. Filters and     * consumers are not required to check for availability of attributes in {@link #incrementToken()}. 	 *  	 * @return false for end of stream; true otherwise 	 * 	 *<p> 	 *<b>Note that this method will be defined abstract in Lucene 3.0.<b> 	 */
DECL|method|incrementToken
specifier|public
name|boolean
name|incrementToken
parameter_list|()
throws|throws
name|IOException
block|{
comment|// subclasses must implement this method; will be made abstract in Lucene 3.0
return|return
literal|false
return|;
block|}
comment|/** Returns the next token in the stream, or null at EOS.    *  @deprecated The returned Token is a "full private copy" (not    *  re-used across calls to next()) but will be slower    *  than calling {@link #next(Token)} instead.. */
DECL|method|next
specifier|public
name|Token
name|next
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|Token
name|reusableToken
init|=
operator|new
name|Token
argument_list|()
decl_stmt|;
name|Token
name|nextToken
init|=
name|next
argument_list|(
name|reusableToken
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextToken
operator|!=
literal|null
condition|)
block|{
name|Payload
name|p
init|=
name|nextToken
operator|.
name|getPayload
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|nextToken
operator|.
name|setPayload
argument_list|(
operator|(
name|Payload
operator|)
name|p
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nextToken
return|;
block|}
comment|/** Returns the next token in the stream, or null at EOS.    *  When possible, the input Token should be used as the    *  returned Token (this gives fastest tokenization    *  performance), but this is not required and a new Token    *  may be returned. Callers may re-use a single Token    *  instance for successive calls to this method.    *<p>    *  This implicitly defines a "contract" between     *  consumers (callers of this method) and     *  producers (implementations of this method     *  that are the source for tokens):    *<ul>    *<li>A consumer must fully consume the previously     *       returned Token before calling this method again.</li>    *<li>A producer must call {@link Token#clear()}    *       before setting the fields in it& returning it</li>    *</ul>    *  Also, the producer must make no assumptions about a    *  Token after it has been returned: the caller may    *  arbitrarily change it.  If the producer needs to hold    *  onto the token for subsequent calls, it must clone()    *  it before storing it.    *  Note that a {@link TokenFilter} is considered a consumer.    *  @param reusableToken a Token that may or may not be used to    *  return; this parameter should never be null (the callee    *  is not required to check for null before using it, but it is a    *  good idea to assert that it is not null.)    *  @return next token in the stream or null if end-of-stream was hit    *  @deprecated The new {@link #incrementToken()} and {@link AttributeSource}    *  APIs should be used instead. See also {@link #useNewAPI()}.    */
DECL|method|next
specifier|public
name|Token
name|next
parameter_list|(
specifier|final
name|Token
name|reusableToken
parameter_list|)
throws|throws
name|IOException
block|{
comment|// We don't actually use inputToken, but still add this assert
assert|assert
name|reusableToken
operator|!=
literal|null
assert|;
return|return
name|next
argument_list|()
return|;
block|}
comment|/** Resets this stream to the beginning. This is an    *  optional operation, so subclasses may or may not    *  implement this method. Reset() is not needed for    *  the standard indexing process. However, if the Tokens     *  of a TokenStream are intended to be consumed more than     *  once, it is necessary to implement reset().  Note that    *  if your TokenStream caches tokens and feeds them back    *  again after a reset, it is imperative that you    *  clone the tokens when you store them away (on the    *  first pass) as well as when you return them (on future    *  passes after reset()).    */
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{}
comment|/** Releases resources associated with this stream. */
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasAttributes
argument_list|()
condition|)
block|{
comment|// TODO Java 1.5
comment|//Iterator<Attribute> it = attributes.values().iterator();
name|Iterator
name|it
init|=
name|getAttributesIterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|it
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|it
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class
end_unit
