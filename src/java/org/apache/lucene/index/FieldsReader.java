begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|BufferedIndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CloseableThreadLocal
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_comment
comment|/**  * Class responsible for access to stored document fields.  *<p/>  * It uses&lt;segment&gt;.fdt and&lt;segment&gt;.fdx; files.  */
end_comment
begin_class
DECL|class|FieldsReader
specifier|final
class|class
name|FieldsReader
implements|implements
name|Cloneable
block|{
DECL|field|fieldInfos
specifier|private
specifier|final
name|FieldInfos
name|fieldInfos
decl_stmt|;
comment|// The main fieldStream, used only for cloning.
DECL|field|cloneableFieldsStream
specifier|private
specifier|final
name|IndexInput
name|cloneableFieldsStream
decl_stmt|;
comment|// This is a clone of cloneableFieldsStream used for reading documents.
comment|// It should not be cloned outside of a synchronized context.
DECL|field|fieldsStream
specifier|private
specifier|final
name|IndexInput
name|fieldsStream
decl_stmt|;
DECL|field|cloneableIndexStream
specifier|private
specifier|final
name|IndexInput
name|cloneableIndexStream
decl_stmt|;
DECL|field|indexStream
specifier|private
specifier|final
name|IndexInput
name|indexStream
decl_stmt|;
DECL|field|numTotalDocs
specifier|private
name|int
name|numTotalDocs
decl_stmt|;
DECL|field|size
specifier|private
name|int
name|size
decl_stmt|;
DECL|field|closed
specifier|private
name|boolean
name|closed
decl_stmt|;
DECL|field|format
specifier|private
specifier|final
name|int
name|format
decl_stmt|;
DECL|field|formatSize
specifier|private
specifier|final
name|int
name|formatSize
decl_stmt|;
comment|// The docID offset where our docs begin in the index
comment|// file.  This will be 0 if we have our own private file.
DECL|field|docStoreOffset
specifier|private
name|int
name|docStoreOffset
decl_stmt|;
DECL|field|fieldsStreamTL
specifier|private
name|CloseableThreadLocal
name|fieldsStreamTL
init|=
operator|new
name|CloseableThreadLocal
argument_list|()
decl_stmt|;
DECL|field|isOriginal
specifier|private
name|boolean
name|isOriginal
init|=
literal|false
decl_stmt|;
comment|/** Returns a cloned FieldsReader that shares open    *  IndexInputs with the original one.  It is the caller's    *  job not to close the original FieldsReader until all    *  clones are called (eg, currently SegmentReader manages    *  this logic). */
DECL|method|clone
specifier|public
name|Object
name|clone
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
operator|new
name|FieldsReader
argument_list|(
name|fieldInfos
argument_list|,
name|numTotalDocs
argument_list|,
name|size
argument_list|,
name|format
argument_list|,
name|formatSize
argument_list|,
name|docStoreOffset
argument_list|,
name|cloneableFieldsStream
argument_list|,
name|cloneableIndexStream
argument_list|)
return|;
block|}
comment|// Used only by clone
DECL|method|FieldsReader
specifier|private
name|FieldsReader
parameter_list|(
name|FieldInfos
name|fieldInfos
parameter_list|,
name|int
name|numTotalDocs
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|formatSize
parameter_list|,
name|int
name|docStoreOffset
parameter_list|,
name|IndexInput
name|cloneableFieldsStream
parameter_list|,
name|IndexInput
name|cloneableIndexStream
parameter_list|)
block|{
name|this
operator|.
name|fieldInfos
operator|=
name|fieldInfos
expr_stmt|;
name|this
operator|.
name|numTotalDocs
operator|=
name|numTotalDocs
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|this
operator|.
name|format
operator|=
name|format
expr_stmt|;
name|this
operator|.
name|formatSize
operator|=
name|formatSize
expr_stmt|;
name|this
operator|.
name|docStoreOffset
operator|=
name|docStoreOffset
expr_stmt|;
name|this
operator|.
name|cloneableFieldsStream
operator|=
name|cloneableFieldsStream
expr_stmt|;
name|this
operator|.
name|cloneableIndexStream
operator|=
name|cloneableIndexStream
expr_stmt|;
name|fieldsStream
operator|=
operator|(
name|IndexInput
operator|)
name|cloneableFieldsStream
operator|.
name|clone
argument_list|()
expr_stmt|;
name|indexStream
operator|=
operator|(
name|IndexInput
operator|)
name|cloneableIndexStream
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
DECL|method|FieldsReader
name|FieldsReader
parameter_list|(
name|Directory
name|d
parameter_list|,
name|String
name|segment
parameter_list|,
name|FieldInfos
name|fn
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|d
argument_list|,
name|segment
argument_list|,
name|fn
argument_list|,
name|BufferedIndexInput
operator|.
name|BUFFER_SIZE
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|FieldsReader
name|FieldsReader
parameter_list|(
name|Directory
name|d
parameter_list|,
name|String
name|segment
parameter_list|,
name|FieldInfos
name|fn
parameter_list|,
name|int
name|readBufferSize
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|d
argument_list|,
name|segment
argument_list|,
name|fn
argument_list|,
name|readBufferSize
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|FieldsReader
name|FieldsReader
parameter_list|(
name|Directory
name|d
parameter_list|,
name|String
name|segment
parameter_list|,
name|FieldInfos
name|fn
parameter_list|,
name|int
name|readBufferSize
parameter_list|,
name|int
name|docStoreOffset
parameter_list|,
name|int
name|size
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|isOriginal
operator|=
literal|true
expr_stmt|;
try|try
block|{
name|fieldInfos
operator|=
name|fn
expr_stmt|;
name|cloneableFieldsStream
operator|=
name|d
operator|.
name|openInput
argument_list|(
name|segment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|FIELDS_EXTENSION
argument_list|,
name|readBufferSize
argument_list|)
expr_stmt|;
name|cloneableIndexStream
operator|=
name|d
operator|.
name|openInput
argument_list|(
name|segment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|FIELDS_INDEX_EXTENSION
argument_list|,
name|readBufferSize
argument_list|)
expr_stmt|;
comment|// First version of fdx did not include a format
comment|// header, but, the first int will always be 0 in that
comment|// case
name|int
name|firstInt
init|=
name|cloneableIndexStream
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|firstInt
operator|==
literal|0
condition|)
name|format
operator|=
literal|0
expr_stmt|;
else|else
name|format
operator|=
name|firstInt
expr_stmt|;
if|if
condition|(
name|format
operator|>
name|FieldsWriter
operator|.
name|FORMAT_CURRENT
condition|)
throw|throw
operator|new
name|CorruptIndexException
argument_list|(
literal|"Incompatible format version: "
operator|+
name|format
operator|+
literal|" expected "
operator|+
name|FieldsWriter
operator|.
name|FORMAT_CURRENT
operator|+
literal|" or lower"
argument_list|)
throw|;
if|if
condition|(
name|format
operator|>
name|FieldsWriter
operator|.
name|FORMAT
condition|)
name|formatSize
operator|=
literal|4
expr_stmt|;
else|else
name|formatSize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|format
operator|<
name|FieldsWriter
operator|.
name|FORMAT_VERSION_UTF8_LENGTH_IN_BYTES
condition|)
name|cloneableFieldsStream
operator|.
name|setModifiedUTF8StringsMode
argument_list|()
expr_stmt|;
name|fieldsStream
operator|=
operator|(
name|IndexInput
operator|)
name|cloneableFieldsStream
operator|.
name|clone
argument_list|()
expr_stmt|;
specifier|final
name|long
name|indexSize
init|=
name|cloneableIndexStream
operator|.
name|length
argument_list|()
operator|-
name|formatSize
decl_stmt|;
if|if
condition|(
name|docStoreOffset
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// We read only a slice out of this shared fields file
name|this
operator|.
name|docStoreOffset
operator|=
name|docStoreOffset
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
comment|// Verify the file is long enough to hold all of our
comment|// docs
assert|assert
operator|(
call|(
name|int
call|)
argument_list|(
name|indexSize
operator|/
literal|8
argument_list|)
operator|)
operator|>=
name|size
operator|+
name|this
operator|.
name|docStoreOffset
operator|:
literal|"indexSize="
operator|+
name|indexSize
operator|+
literal|" size="
operator|+
name|size
operator|+
literal|" docStoreOffset="
operator|+
name|docStoreOffset
assert|;
block|}
else|else
block|{
name|this
operator|.
name|docStoreOffset
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|size
operator|=
call|(
name|int
call|)
argument_list|(
name|indexSize
operator|>>
literal|3
argument_list|)
expr_stmt|;
block|}
name|indexStream
operator|=
operator|(
name|IndexInput
operator|)
name|cloneableIndexStream
operator|.
name|clone
argument_list|()
expr_stmt|;
name|numTotalDocs
operator|=
call|(
name|int
call|)
argument_list|(
name|indexSize
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
comment|// With lock-less commits, it's entirely possible (and
comment|// fine) to hit a FileNotFound exception above. In
comment|// this case, we want to explicitly close any subset
comment|// of things that were opened so that we don't have to
comment|// wait for a GC to do so.
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * @throws AlreadyClosedException if this FieldsReader is closed    */
DECL|method|ensureOpen
specifier|protected
specifier|final
name|void
name|ensureOpen
parameter_list|()
throws|throws
name|AlreadyClosedException
block|{
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|AlreadyClosedException
argument_list|(
literal|"this FieldsReader is closed"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Closes the underlying {@link org.apache.lucene.store.IndexInput} streams, including any ones associated with a    * lazy implementation of a Field.  This means that the Fields values will not be accessible.    *    * @throws IOException    */
DECL|method|close
specifier|final
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
if|if
condition|(
name|fieldsStream
operator|!=
literal|null
condition|)
block|{
name|fieldsStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isOriginal
condition|)
block|{
if|if
condition|(
name|cloneableFieldsStream
operator|!=
literal|null
condition|)
block|{
name|cloneableFieldsStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cloneableIndexStream
operator|!=
literal|null
condition|)
block|{
name|cloneableIndexStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|indexStream
operator|!=
literal|null
condition|)
block|{
name|indexStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|fieldsStreamTL
operator|.
name|close
argument_list|()
expr_stmt|;
name|closed
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|method|size
specifier|final
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
DECL|method|seekIndex
specifier|private
specifier|final
name|void
name|seekIndex
parameter_list|(
name|int
name|docID
parameter_list|)
throws|throws
name|IOException
block|{
name|indexStream
operator|.
name|seek
argument_list|(
name|formatSize
operator|+
operator|(
name|docID
operator|+
name|docStoreOffset
operator|)
operator|*
literal|8L
argument_list|)
expr_stmt|;
block|}
DECL|method|canReadRawDocs
name|boolean
name|canReadRawDocs
parameter_list|()
block|{
return|return
name|format
operator|>=
name|FieldsWriter
operator|.
name|FORMAT_VERSION_UTF8_LENGTH_IN_BYTES
return|;
block|}
DECL|method|doc
specifier|final
name|Document
name|doc
parameter_list|(
name|int
name|n
parameter_list|,
name|FieldSelector
name|fieldSelector
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|seekIndex
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|long
name|position
init|=
name|indexStream
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|fieldsStream
operator|.
name|seek
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|int
name|numFields
init|=
name|fieldsStream
operator|.
name|readVInt
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
name|i
operator|++
control|)
block|{
name|int
name|fieldNumber
init|=
name|fieldsStream
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|FieldInfo
name|fi
init|=
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|fieldNumber
argument_list|)
decl_stmt|;
name|FieldSelectorResult
name|acceptField
init|=
name|fieldSelector
operator|==
literal|null
condition|?
name|FieldSelectorResult
operator|.
name|LOAD
else|:
name|fieldSelector
operator|.
name|accept
argument_list|(
name|fi
operator|.
name|name
argument_list|)
decl_stmt|;
name|byte
name|bits
init|=
name|fieldsStream
operator|.
name|readByte
argument_list|()
decl_stmt|;
assert|assert
name|bits
operator|<=
name|FieldsWriter
operator|.
name|FIELD_IS_TOKENIZED
operator|+
name|FieldsWriter
operator|.
name|FIELD_IS_BINARY
assert|;
name|boolean
name|tokenize
init|=
operator|(
name|bits
operator|&
name|FieldsWriter
operator|.
name|FIELD_IS_TOKENIZED
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|binary
init|=
operator|(
name|bits
operator|&
name|FieldsWriter
operator|.
name|FIELD_IS_BINARY
operator|)
operator|!=
literal|0
decl_stmt|;
comment|//TODO: Find an alternative approach here if this list continues to grow beyond the
comment|//list of 5 or 6 currently here.  See Lucene 762 for discussion
if|if
condition|(
name|acceptField
operator|.
name|equals
argument_list|(
name|FieldSelectorResult
operator|.
name|LOAD
argument_list|)
condition|)
block|{
name|addField
argument_list|(
name|doc
argument_list|,
name|fi
argument_list|,
name|binary
argument_list|,
name|tokenize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|acceptField
operator|.
name|equals
argument_list|(
name|FieldSelectorResult
operator|.
name|LOAD_AND_BREAK
argument_list|)
condition|)
block|{
name|addField
argument_list|(
name|doc
argument_list|,
name|fi
argument_list|,
name|binary
argument_list|,
name|tokenize
argument_list|)
expr_stmt|;
break|break;
comment|//Get out of this loop
block|}
elseif|else
if|if
condition|(
name|acceptField
operator|.
name|equals
argument_list|(
name|FieldSelectorResult
operator|.
name|LAZY_LOAD
argument_list|)
condition|)
block|{
name|addFieldLazy
argument_list|(
name|doc
argument_list|,
name|fi
argument_list|,
name|binary
argument_list|,
name|tokenize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|acceptField
operator|.
name|equals
argument_list|(
name|FieldSelectorResult
operator|.
name|SIZE
argument_list|)
condition|)
block|{
name|skipField
argument_list|(
name|binary
argument_list|,
name|addFieldSize
argument_list|(
name|doc
argument_list|,
name|fi
argument_list|,
name|binary
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|acceptField
operator|.
name|equals
argument_list|(
name|FieldSelectorResult
operator|.
name|SIZE_AND_BREAK
argument_list|)
condition|)
block|{
name|addFieldSize
argument_list|(
name|doc
argument_list|,
name|fi
argument_list|,
name|binary
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|skipField
argument_list|(
name|binary
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|doc
return|;
block|}
comment|/** Returns the length in bytes of each raw document in a    *  contiguous range of length numDocs starting with    *  startDocID.  Returns the IndexInput (the fieldStream),    *  already seeked to the starting point for startDocID.*/
DECL|method|rawDocs
specifier|final
name|IndexInput
name|rawDocs
parameter_list|(
name|int
index|[]
name|lengths
parameter_list|,
name|int
name|startDocID
parameter_list|,
name|int
name|numDocs
parameter_list|)
throws|throws
name|IOException
block|{
name|seekIndex
argument_list|(
name|startDocID
argument_list|)
expr_stmt|;
name|long
name|startOffset
init|=
name|indexStream
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|long
name|lastOffset
init|=
name|startOffset
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|count
operator|<
name|numDocs
condition|)
block|{
specifier|final
name|long
name|offset
decl_stmt|;
specifier|final
name|int
name|docID
init|=
name|docStoreOffset
operator|+
name|startDocID
operator|+
name|count
operator|+
literal|1
decl_stmt|;
assert|assert
name|docID
operator|<=
name|numTotalDocs
assert|;
if|if
condition|(
name|docID
operator|<
name|numTotalDocs
condition|)
name|offset
operator|=
name|indexStream
operator|.
name|readLong
argument_list|()
expr_stmt|;
else|else
name|offset
operator|=
name|fieldsStream
operator|.
name|length
argument_list|()
expr_stmt|;
name|lengths
index|[
name|count
operator|++
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|offset
operator|-
name|lastOffset
argument_list|)
expr_stmt|;
name|lastOffset
operator|=
name|offset
expr_stmt|;
block|}
name|fieldsStream
operator|.
name|seek
argument_list|(
name|startOffset
argument_list|)
expr_stmt|;
return|return
name|fieldsStream
return|;
block|}
comment|/**    * Skip the field.  We still have to read some of the information about the field, but can skip past the actual content.    * This will have the most payoff on large fields.    */
DECL|method|skipField
specifier|private
name|void
name|skipField
parameter_list|(
name|boolean
name|binary
parameter_list|)
throws|throws
name|IOException
block|{
name|skipField
argument_list|(
name|binary
argument_list|,
name|fieldsStream
operator|.
name|readVInt
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|skipField
specifier|private
name|void
name|skipField
parameter_list|(
name|boolean
name|binary
parameter_list|,
name|int
name|toRead
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|format
operator|>=
name|FieldsWriter
operator|.
name|FORMAT_VERSION_UTF8_LENGTH_IN_BYTES
operator|||
name|binary
condition|)
block|{
name|fieldsStream
operator|.
name|seek
argument_list|(
name|fieldsStream
operator|.
name|getFilePointer
argument_list|()
operator|+
name|toRead
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We need to skip chars.  This will slow us down, but still better
name|fieldsStream
operator|.
name|skipChars
argument_list|(
name|toRead
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addFieldLazy
specifier|private
name|void
name|addFieldLazy
parameter_list|(
name|Document
name|doc
parameter_list|,
name|FieldInfo
name|fi
parameter_list|,
name|boolean
name|binary
parameter_list|,
name|boolean
name|tokenize
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|binary
condition|)
block|{
name|int
name|toRead
init|=
name|fieldsStream
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|long
name|pointer
init|=
name|fieldsStream
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
comment|//was: doc.add(new Fieldable(fi.name, b, Fieldable.Store.YES));
name|doc
operator|.
name|add
argument_list|(
operator|new
name|LazyField
argument_list|(
name|fi
operator|.
name|name
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|,
name|toRead
argument_list|,
name|pointer
argument_list|,
name|binary
argument_list|)
argument_list|)
expr_stmt|;
comment|//Need to move the pointer ahead by toRead positions
name|fieldsStream
operator|.
name|seek
argument_list|(
name|pointer
operator|+
name|toRead
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Field
operator|.
name|Store
name|store
init|=
name|Field
operator|.
name|Store
operator|.
name|YES
decl_stmt|;
name|Field
operator|.
name|Index
name|index
init|=
name|getIndexType
argument_list|(
name|fi
argument_list|,
name|tokenize
argument_list|)
decl_stmt|;
name|Field
operator|.
name|TermVector
name|termVector
init|=
name|getTermVectorType
argument_list|(
name|fi
argument_list|)
decl_stmt|;
name|AbstractField
name|f
decl_stmt|;
name|int
name|length
init|=
name|fieldsStream
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|long
name|pointer
init|=
name|fieldsStream
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
comment|//Skip ahead of where we are by the length of what is stored
if|if
condition|(
name|format
operator|>=
name|FieldsWriter
operator|.
name|FORMAT_VERSION_UTF8_LENGTH_IN_BYTES
condition|)
name|fieldsStream
operator|.
name|seek
argument_list|(
name|pointer
operator|+
name|length
argument_list|)
expr_stmt|;
else|else
name|fieldsStream
operator|.
name|skipChars
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|f
operator|=
operator|new
name|LazyField
argument_list|(
name|fi
operator|.
name|name
argument_list|,
name|store
argument_list|,
name|index
argument_list|,
name|termVector
argument_list|,
name|length
argument_list|,
name|pointer
argument_list|,
name|binary
argument_list|)
expr_stmt|;
name|f
operator|.
name|setOmitNorms
argument_list|(
name|fi
operator|.
name|omitNorms
argument_list|)
expr_stmt|;
name|f
operator|.
name|setOmitTermFreqAndPositions
argument_list|(
name|fi
operator|.
name|omitTermFreqAndPositions
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addField
specifier|private
name|void
name|addField
parameter_list|(
name|Document
name|doc
parameter_list|,
name|FieldInfo
name|fi
parameter_list|,
name|boolean
name|binary
parameter_list|,
name|boolean
name|tokenize
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
comment|//we have a binary stored field, and it may be compressed
if|if
condition|(
name|binary
condition|)
block|{
name|int
name|toRead
init|=
name|fieldsStream
operator|.
name|readVInt
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|toRead
index|]
decl_stmt|;
name|fieldsStream
operator|.
name|readBytes
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|fi
operator|.
name|name
argument_list|,
name|b
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Field
operator|.
name|Store
name|store
init|=
name|Field
operator|.
name|Store
operator|.
name|YES
decl_stmt|;
name|Field
operator|.
name|Index
name|index
init|=
name|getIndexType
argument_list|(
name|fi
argument_list|,
name|tokenize
argument_list|)
decl_stmt|;
name|Field
operator|.
name|TermVector
name|termVector
init|=
name|getTermVectorType
argument_list|(
name|fi
argument_list|)
decl_stmt|;
name|AbstractField
name|f
decl_stmt|;
name|f
operator|=
operator|new
name|Field
argument_list|(
name|fi
operator|.
name|name
argument_list|,
comment|// name
literal|false
argument_list|,
name|fieldsStream
operator|.
name|readString
argument_list|()
argument_list|,
comment|// read value
name|store
argument_list|,
name|index
argument_list|,
name|termVector
argument_list|)
expr_stmt|;
name|f
operator|.
name|setOmitTermFreqAndPositions
argument_list|(
name|fi
operator|.
name|omitTermFreqAndPositions
argument_list|)
expr_stmt|;
name|f
operator|.
name|setOmitNorms
argument_list|(
name|fi
operator|.
name|omitNorms
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add the size of field as a byte[] containing the 4 bytes of the integer byte size (high order byte first; char = 2 bytes)
comment|// Read just the size -- caller must skip the field content to continue reading fields
comment|// Return the size in bytes or chars, depending on field type
DECL|method|addFieldSize
specifier|private
name|int
name|addFieldSize
parameter_list|(
name|Document
name|doc
parameter_list|,
name|FieldInfo
name|fi
parameter_list|,
name|boolean
name|binary
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|size
init|=
name|fieldsStream
operator|.
name|readVInt
argument_list|()
decl_stmt|,
name|bytesize
init|=
name|binary
condition|?
name|size
else|:
literal|2
operator|*
name|size
decl_stmt|;
name|byte
index|[]
name|sizebytes
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|sizebytes
index|[
literal|0
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|bytesize
operator|>>>
literal|24
argument_list|)
expr_stmt|;
name|sizebytes
index|[
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|bytesize
operator|>>>
literal|16
argument_list|)
expr_stmt|;
name|sizebytes
index|[
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|bytesize
operator|>>>
literal|8
argument_list|)
expr_stmt|;
name|sizebytes
index|[
literal|3
index|]
operator|=
operator|(
name|byte
operator|)
name|bytesize
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|fi
operator|.
name|name
argument_list|,
name|sizebytes
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
DECL|method|getTermVectorType
specifier|private
name|Field
operator|.
name|TermVector
name|getTermVectorType
parameter_list|(
name|FieldInfo
name|fi
parameter_list|)
block|{
name|Field
operator|.
name|TermVector
name|termVector
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|storeTermVector
condition|)
block|{
if|if
condition|(
name|fi
operator|.
name|storeOffsetWithTermVector
condition|)
block|{
if|if
condition|(
name|fi
operator|.
name|storePositionWithTermVector
condition|)
block|{
name|termVector
operator|=
name|Field
operator|.
name|TermVector
operator|.
name|WITH_POSITIONS_OFFSETS
expr_stmt|;
block|}
else|else
block|{
name|termVector
operator|=
name|Field
operator|.
name|TermVector
operator|.
name|WITH_OFFSETS
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fi
operator|.
name|storePositionWithTermVector
condition|)
block|{
name|termVector
operator|=
name|Field
operator|.
name|TermVector
operator|.
name|WITH_POSITIONS
expr_stmt|;
block|}
else|else
block|{
name|termVector
operator|=
name|Field
operator|.
name|TermVector
operator|.
name|YES
expr_stmt|;
block|}
block|}
else|else
block|{
name|termVector
operator|=
name|Field
operator|.
name|TermVector
operator|.
name|NO
expr_stmt|;
block|}
return|return
name|termVector
return|;
block|}
DECL|method|getIndexType
specifier|private
name|Field
operator|.
name|Index
name|getIndexType
parameter_list|(
name|FieldInfo
name|fi
parameter_list|,
name|boolean
name|tokenize
parameter_list|)
block|{
name|Field
operator|.
name|Index
name|index
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|isIndexed
operator|&&
name|tokenize
condition|)
name|index
operator|=
name|Field
operator|.
name|Index
operator|.
name|ANALYZED
expr_stmt|;
elseif|else
if|if
condition|(
name|fi
operator|.
name|isIndexed
operator|&&
operator|!
name|tokenize
condition|)
name|index
operator|=
name|Field
operator|.
name|Index
operator|.
name|NOT_ANALYZED
expr_stmt|;
else|else
name|index
operator|=
name|Field
operator|.
name|Index
operator|.
name|NO
expr_stmt|;
return|return
name|index
return|;
block|}
comment|/**    * A Lazy implementation of Fieldable that differs loading of fields until asked for, instead of when the Document is    * loaded.    */
DECL|class|LazyField
specifier|private
class|class
name|LazyField
extends|extends
name|AbstractField
implements|implements
name|Fieldable
block|{
DECL|field|toRead
specifier|private
name|int
name|toRead
decl_stmt|;
DECL|field|pointer
specifier|private
name|long
name|pointer
decl_stmt|;
DECL|method|LazyField
specifier|public
name|LazyField
parameter_list|(
name|String
name|name
parameter_list|,
name|Field
operator|.
name|Store
name|store
parameter_list|,
name|int
name|toRead
parameter_list|,
name|long
name|pointer
parameter_list|,
name|boolean
name|isBinary
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|,
name|store
argument_list|,
name|Field
operator|.
name|Index
operator|.
name|NO
argument_list|,
name|Field
operator|.
name|TermVector
operator|.
name|NO
argument_list|)
expr_stmt|;
name|this
operator|.
name|toRead
operator|=
name|toRead
expr_stmt|;
name|this
operator|.
name|pointer
operator|=
name|pointer
expr_stmt|;
name|this
operator|.
name|isBinary
operator|=
name|isBinary
expr_stmt|;
if|if
condition|(
name|isBinary
condition|)
name|binaryLength
operator|=
name|toRead
expr_stmt|;
name|lazy
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|LazyField
specifier|public
name|LazyField
parameter_list|(
name|String
name|name
parameter_list|,
name|Field
operator|.
name|Store
name|store
parameter_list|,
name|Field
operator|.
name|Index
name|index
parameter_list|,
name|Field
operator|.
name|TermVector
name|termVector
parameter_list|,
name|int
name|toRead
parameter_list|,
name|long
name|pointer
parameter_list|,
name|boolean
name|isBinary
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|,
name|store
argument_list|,
name|index
argument_list|,
name|termVector
argument_list|)
expr_stmt|;
name|this
operator|.
name|toRead
operator|=
name|toRead
expr_stmt|;
name|this
operator|.
name|pointer
operator|=
name|pointer
expr_stmt|;
name|this
operator|.
name|isBinary
operator|=
name|isBinary
expr_stmt|;
if|if
condition|(
name|isBinary
condition|)
name|binaryLength
operator|=
name|toRead
expr_stmt|;
name|lazy
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|getFieldStream
specifier|private
name|IndexInput
name|getFieldStream
parameter_list|()
block|{
name|IndexInput
name|localFieldsStream
init|=
operator|(
name|IndexInput
operator|)
name|fieldsStreamTL
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|localFieldsStream
operator|==
literal|null
condition|)
block|{
name|localFieldsStream
operator|=
operator|(
name|IndexInput
operator|)
name|cloneableFieldsStream
operator|.
name|clone
argument_list|()
expr_stmt|;
name|fieldsStreamTL
operator|.
name|set
argument_list|(
name|localFieldsStream
argument_list|)
expr_stmt|;
block|}
return|return
name|localFieldsStream
return|;
block|}
comment|/** The value of the field in Binary, or null.  If null, the Reader value,      * String value, or TokenStream value is used. Exactly one of stringValue(),       * readerValue(), binaryValue(), and tokenStreamValue() must be set. */
DECL|method|binaryValue
specifier|public
name|byte
index|[]
name|binaryValue
parameter_list|()
block|{
return|return
name|getBinaryValue
argument_list|(
literal|null
argument_list|)
return|;
block|}
comment|/** The value of the field as a Reader, or null.  If null, the String value,      * binary value, or TokenStream value is used.  Exactly one of stringValue(),       * readerValue(), binaryValue(), and tokenStreamValue() must be set. */
DECL|method|readerValue
specifier|public
name|Reader
name|readerValue
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/** The value of the field as a TokenStream, or null.  If null, the Reader value,      * String value, or binary value is used. Exactly one of stringValue(),       * readerValue(), binaryValue(), and tokenStreamValue() must be set. */
DECL|method|tokenStreamValue
specifier|public
name|TokenStream
name|tokenStreamValue
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/** The value of the field as a String, or null.  If null, the Reader value,      * binary value, or TokenStream value is used.  Exactly one of stringValue(),       * readerValue(), binaryValue(), and tokenStreamValue() must be set. */
DECL|method|stringValue
specifier|public
name|String
name|stringValue
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|isBinary
condition|)
return|return
literal|null
return|;
else|else
block|{
if|if
condition|(
name|fieldsData
operator|==
literal|null
condition|)
block|{
name|IndexInput
name|localFieldsStream
init|=
name|getFieldStream
argument_list|()
decl_stmt|;
try|try
block|{
name|localFieldsStream
operator|.
name|seek
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|>=
name|FieldsWriter
operator|.
name|FORMAT_VERSION_UTF8_LENGTH_IN_BYTES
condition|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|toRead
index|]
decl_stmt|;
name|localFieldsStream
operator|.
name|readBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|toRead
argument_list|)
expr_stmt|;
name|fieldsData
operator|=
operator|new
name|String
argument_list|(
name|bytes
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//read in chars b/c we already know the length we need to read
name|char
index|[]
name|chars
init|=
operator|new
name|char
index|[
name|toRead
index|]
decl_stmt|;
name|localFieldsStream
operator|.
name|readChars
argument_list|(
name|chars
argument_list|,
literal|0
argument_list|,
name|toRead
argument_list|)
expr_stmt|;
name|fieldsData
operator|=
operator|new
name|String
argument_list|(
name|chars
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|FieldReaderException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
return|return
operator|(
name|String
operator|)
name|fieldsData
return|;
block|}
block|}
DECL|method|getPointer
specifier|public
name|long
name|getPointer
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|pointer
return|;
block|}
DECL|method|setPointer
specifier|public
name|void
name|setPointer
parameter_list|(
name|long
name|pointer
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|pointer
operator|=
name|pointer
expr_stmt|;
block|}
DECL|method|getToRead
specifier|public
name|int
name|getToRead
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|toRead
return|;
block|}
DECL|method|setToRead
specifier|public
name|void
name|setToRead
parameter_list|(
name|int
name|toRead
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|toRead
operator|=
name|toRead
expr_stmt|;
block|}
DECL|method|getBinaryValue
specifier|public
name|byte
index|[]
name|getBinaryValue
parameter_list|(
name|byte
index|[]
name|result
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|isBinary
condition|)
block|{
if|if
condition|(
name|fieldsData
operator|==
literal|null
condition|)
block|{
comment|// Allocate new buffer if result is null or too small
specifier|final
name|byte
index|[]
name|b
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
operator|||
name|result
operator|.
name|length
operator|<
name|toRead
condition|)
name|b
operator|=
operator|new
name|byte
index|[
name|toRead
index|]
expr_stmt|;
else|else
name|b
operator|=
name|result
expr_stmt|;
name|IndexInput
name|localFieldsStream
init|=
name|getFieldStream
argument_list|()
decl_stmt|;
comment|// Throw this IOException since IndexReader.document does so anyway, so probably not that big of a change for people
comment|// since they are already handling this exception when getting the document
try|try
block|{
name|localFieldsStream
operator|.
name|seek
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|localFieldsStream
operator|.
name|readBytes
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|toRead
argument_list|)
expr_stmt|;
name|fieldsData
operator|=
name|b
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|FieldReaderException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|binaryOffset
operator|=
literal|0
expr_stmt|;
name|binaryLength
operator|=
name|toRead
expr_stmt|;
block|}
return|return
operator|(
name|byte
index|[]
operator|)
name|fieldsData
return|;
block|}
else|else
return|return
literal|null
return|;
block|}
block|}
block|}
end_class
end_unit
