begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Lock
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|LockObtainFailedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import
begin_comment
comment|/**   An<code>IndexWriter</code> creates and maintains an index.<p>The<code>create</code> argument to the<a href="#IndexWriter(org.apache.lucene.store.Directory, org.apache.lucene.analysis.Analyzer, boolean)"><b>constructor</b></a>   determines whether a new index is created, or whether an existing index is   opened.  Note that you   can open an index with<code>create=true</code> even while readers are   using the index.  The old readers will continue to search   the "point in time" snapshot they had opened, and won't   see the newly created index until they re-open.  There are   also<a href="#IndexWriter(org.apache.lucene.store.Directory, org.apache.lucene.analysis.Analyzer)"><b>constructors</b></a>   with no<code>create</code> argument which   will create a new index if there is not already an index at the   provided path and otherwise open the existing index.</p><p>In either case, documents are added with<a   href="#addDocument(org.apache.lucene.document.Document)"><b>addDocument</b></a>   and removed with<a   href="#deleteDocuments(org.apache.lucene.index.Term)"><b>deleteDocuments</b></a>.   A document can be updated with<a href="#updateDocument(org.apache.lucene.index.Term, org.apache.lucene.document.Document)"><b>updateDocument</b></a>    (which just deletes and then adds the entire document).   When finished adding, deleting and updating documents,<a href="#close()"><b>close</b></a> should be called.</p><p>These changes are buffered in memory and periodically   flushed to the {@link Directory} (during the above method   calls).  A flush is triggered when there are enough   buffered deletes (see {@link #setMaxBufferedDeleteTerms})   or enough added documents since the last flush, whichever   is sooner.  For the added documents, flushing is triggered   either by RAM usage of the documents (see {@link   #setRAMBufferSizeMB}) or the number of added documents   (this is the default; see {@link #setMaxBufferedDocs}).   For best indexing speed you should flush by RAM usage with   a large RAM buffer.  You can also force a flush by calling   {@link #flush}.  When a flush occurs, both pending deletes   and added documents are flushed to the index.  A flush may   also trigger one or more segment merges.</p><a name="autoCommit"></a><p>The optional<code>autoCommit</code> argument to the<a href="#IndexWriter(org.apache.lucene.store.Directory, boolean, org.apache.lucene.analysis.Analyzer)"><b>constructors</b></a>   controls visibility of the changes to {@link IndexReader} instances reading the same index.   When this is<code>false</code>, changes are not   visible until {@link #close()} is called.   Note that changes will still be flushed to the   {@link org.apache.lucene.store.Directory} as new files,   but are not committed (no new<code>segments_N</code> file   is written referencing the new files) until {@link #close} is   called.  If something goes terribly wrong (for example the   JVM crashes) before {@link #close()}, then   the index will reflect none of the changes made (it will   remain in its starting state).   You can also call {@link #abort()}, which closes the writer without committing any   changes, and removes any index   files that had been flushed but are now unreferenced.   This mode is useful for preventing readers from refreshing   at a bad time (for example after you've done all your   deletes but before you've done your adds).   It can also be used to implement simple single-writer   transactional semantics ("all or none").</p><p>When<code>autoCommit</code> is<code>true</code> then   every flush is also a commit ({@link IndexReader}   instances will see each flush as changes to the index).   This is the default, to match the behavior before 2.2.   When running in this mode, be careful not to refresh your   readers while optimize or segment merges are taking place   as this can tie up substantial disk space.</p><p>Regardless of<code>autoCommit</code>, an {@link   IndexReader} or {@link org.apache.lucene.search.IndexSearcher} will only see the   index as of the "point in time" that it was opened.  Any   changes committed to the index after the reader was opened   are not visible until the reader is re-opened.</p><p>If an index will not have more documents added for a while and optimal search   performance is desired, then the<a href="#optimize()"><b>optimize</b></a>   method should be called before the index is closed.</p><p>Opening an<code>IndexWriter</code> creates a lock file for the directory in use. Trying to open   another<code>IndexWriter</code> on the same directory will lead to a   {@link LockObtainFailedException}. The {@link LockObtainFailedException}   is also thrown if an IndexReader on the same directory is used to delete documents   from the index.</p><a name="deletionPolicy"></a><p>Expert:<code>IndexWriter</code> allows an optional   {@link IndexDeletionPolicy} implementation to be   specified.  You can use this to control when prior commits   are deleted from the index.  The default policy is {@link   KeepOnlyLastCommitDeletionPolicy} which removes all prior   commits as soon as a new commit is done (this matches   behavior before 2.2).  Creating your own policy can allow   you to explicitly keep previous "point in time" commits   alive in the index for some time, to allow readers to   refresh to the new commit without having the old commit   deleted out from under them.  This is necessary on   filesystems like NFS that do not support "delete on last   close" semantics, which Lucene's "point in time" search   normally relies on.</p>   */
end_comment
begin_comment
comment|/*  * Clarification: Check Points (and commits)  * Being able to set autoCommit=false allows IndexWriter to flush and   * write new index files to the directory without writing a new segments_N  * file which references these new files. It also means that the state of   * the in memory SegmentInfos object is different than the most recent  * segments_N file written to the directory.  *   * Each time the SegmentInfos is changed, and matches the (possibly   * modified) directory files, we have a new "check point".   * If the modified/new SegmentInfos is written to disk - as a new   * (generation of) segments_N file - this check point is also an   * IndexCommitPoint.  *   * With autoCommit=true, every checkPoint is also a CommitPoint.  * With autoCommit=false, some checkPoints may not be commits.  *   * A new checkpoint always replaces the previous checkpoint and   * becomes the new "front" of the index. This allows the IndexFileDeleter   * to delete files that are referenced only by stale checkpoints.  * (files that were created since the last commit, but are no longer  * referenced by the "front" of the index). For this, IndexFileDeleter   * keeps track of the last non commit checkpoint.  */
end_comment
begin_class
DECL|class|IndexWriter
specifier|public
class|class
name|IndexWriter
block|{
comment|/**    * Default value for the write lock timeout (1,000).    * @see #setDefaultWriteLockTimeout    */
DECL|field|WRITE_LOCK_TIMEOUT
specifier|public
specifier|static
name|long
name|WRITE_LOCK_TIMEOUT
init|=
literal|1000
decl_stmt|;
DECL|field|writeLockTimeout
specifier|private
name|long
name|writeLockTimeout
init|=
name|WRITE_LOCK_TIMEOUT
decl_stmt|;
comment|/**    * Name of the write lock in the index.    */
DECL|field|WRITE_LOCK_NAME
specifier|public
specifier|static
specifier|final
name|String
name|WRITE_LOCK_NAME
init|=
literal|"write.lock"
decl_stmt|;
comment|/**    * Default value is 10. Change using {@link #setMergeFactor(int)}.    */
DECL|field|DEFAULT_MERGE_FACTOR
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MERGE_FACTOR
init|=
literal|10
decl_stmt|;
comment|/**    * Default value is 10. Change using {@link #setMaxBufferedDocs(int)}.    */
DECL|field|DEFAULT_MAX_BUFFERED_DOCS
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_BUFFERED_DOCS
init|=
literal|10
decl_stmt|;
comment|/* new merge policy   public final static int DEFAULT_MAX_BUFFERED_DOCS = 0;   */
comment|/**    * Default value is 0 MB (which means flush only by doc    * count).  Change using {@link #setRAMBufferSizeMB}.    */
DECL|field|DEFAULT_RAM_BUFFER_SIZE_MB
specifier|public
specifier|final
specifier|static
name|double
name|DEFAULT_RAM_BUFFER_SIZE_MB
init|=
literal|0.0
decl_stmt|;
comment|/* new merge policy   public final static double DEFAULT_RAM_BUFFER_SIZE_MB = 16.0;   */
comment|/**    * Default value is 1000. Change using {@link #setMaxBufferedDeleteTerms(int)}.    */
DECL|field|DEFAULT_MAX_BUFFERED_DELETE_TERMS
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_BUFFERED_DELETE_TERMS
init|=
literal|1000
decl_stmt|;
comment|/**    * Default value is {@link Integer#MAX_VALUE}. Change using {@link #setMaxMergeDocs(int)}.    */
DECL|field|DEFAULT_MAX_MERGE_DOCS
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_MERGE_DOCS
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
comment|/**    * Default value is 10,000. Change using {@link #setMaxFieldLength(int)}.    */
DECL|field|DEFAULT_MAX_FIELD_LENGTH
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_FIELD_LENGTH
init|=
literal|10000
decl_stmt|;
comment|/**    * Default value is 128. Change using {@link #setTermIndexInterval(int)}.    */
DECL|field|DEFAULT_TERM_INDEX_INTERVAL
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_TERM_INDEX_INTERVAL
init|=
literal|128
decl_stmt|;
comment|// The normal read buffer size defaults to 1024, but
comment|// increasing this during merging seems to yield
comment|// performance gains.  However we don't want to increase
comment|// it too much because there are quite a few
comment|// BufferedIndexInputs created during merging.  See
comment|// LUCENE-888 for details.
DECL|field|MERGE_READ_BUFFER_SIZE
specifier|private
specifier|final
specifier|static
name|int
name|MERGE_READ_BUFFER_SIZE
init|=
literal|4096
decl_stmt|;
DECL|field|directory
specifier|private
name|Directory
name|directory
decl_stmt|;
comment|// where this index resides
DECL|field|analyzer
specifier|private
name|Analyzer
name|analyzer
decl_stmt|;
comment|// how to analyze text
DECL|field|similarity
specifier|private
name|Similarity
name|similarity
init|=
name|Similarity
operator|.
name|getDefault
argument_list|()
decl_stmt|;
comment|// how to normalize
DECL|field|commitPending
specifier|private
name|boolean
name|commitPending
decl_stmt|;
comment|// true if segmentInfos has changes not yet committed
DECL|field|rollbackSegmentInfos
specifier|private
name|SegmentInfos
name|rollbackSegmentInfos
decl_stmt|;
comment|// segmentInfos we will fallback to if the commit fails
DECL|field|localRollbackSegmentInfos
specifier|private
name|SegmentInfos
name|localRollbackSegmentInfos
decl_stmt|;
comment|// segmentInfos we will fallback to if the commit fails
DECL|field|localAutoCommit
specifier|private
name|boolean
name|localAutoCommit
decl_stmt|;
comment|// saved autoCommit during local transaction
DECL|field|autoCommit
specifier|private
name|boolean
name|autoCommit
init|=
literal|true
decl_stmt|;
comment|// false if we should commit only on close
DECL|field|segmentInfos
name|SegmentInfos
name|segmentInfos
init|=
operator|new
name|SegmentInfos
argument_list|()
decl_stmt|;
comment|// the segments
DECL|field|docWriter
specifier|private
name|DocumentsWriter
name|docWriter
decl_stmt|;
DECL|field|deleter
specifier|private
name|IndexFileDeleter
name|deleter
decl_stmt|;
DECL|field|writeLock
specifier|private
name|Lock
name|writeLock
decl_stmt|;
DECL|field|termIndexInterval
specifier|private
name|int
name|termIndexInterval
init|=
name|DEFAULT_TERM_INDEX_INTERVAL
decl_stmt|;
comment|// The max number of delete terms that can be buffered before
comment|// they must be flushed to disk.
DECL|field|maxBufferedDeleteTerms
specifier|private
name|int
name|maxBufferedDeleteTerms
init|=
name|DEFAULT_MAX_BUFFERED_DELETE_TERMS
decl_stmt|;
comment|// This Hashmap buffers delete terms in ram before they are applied.
comment|// The key is delete term; the value is number of ram
comment|// segments the term applies to.
DECL|field|bufferedDeleteTerms
specifier|private
name|HashMap
name|bufferedDeleteTerms
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
DECL|field|numBufferedDeleteTerms
specifier|private
name|int
name|numBufferedDeleteTerms
init|=
literal|0
decl_stmt|;
comment|/** Use compound file setting. Defaults to true, minimizing the number of    * files used.  Setting this to false may improve indexing performance, but    * may also cause file handle problems.    */
DECL|field|useCompoundFile
specifier|private
name|boolean
name|useCompoundFile
init|=
literal|true
decl_stmt|;
DECL|field|closeDir
specifier|private
name|boolean
name|closeDir
decl_stmt|;
DECL|field|closed
specifier|private
name|boolean
name|closed
decl_stmt|;
comment|/**    * Used internally to throw an {@link    * AlreadyClosedException} if this IndexWriter has been    * closed.    * @throws AlreadyClosedException if this IndexWriter is    */
DECL|method|ensureOpen
specifier|protected
specifier|final
name|void
name|ensureOpen
parameter_list|()
throws|throws
name|AlreadyClosedException
block|{
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|AlreadyClosedException
argument_list|(
literal|"this IndexWriter is closed"
argument_list|)
throw|;
block|}
block|}
comment|/** Get the current setting of whether to use the compound file format.    *  Note that this just returns the value you set with setUseCompoundFile(boolean)    *  or the default. You cannot use this to query the status of an existing index.    *  @see #setUseCompoundFile(boolean)    */
DECL|method|getUseCompoundFile
specifier|public
name|boolean
name|getUseCompoundFile
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|useCompoundFile
return|;
block|}
comment|/** Setting to turn on usage of a compound file. When on, multiple files    *  for each segment are merged into a single file once the segment creation    *  is finished. This is done regardless of what directory is in use.    */
DECL|method|setUseCompoundFile
specifier|public
name|void
name|setUseCompoundFile
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|useCompoundFile
operator|=
name|value
expr_stmt|;
block|}
comment|/** Expert: Set the Similarity implementation used by this IndexWriter.    *    * @see Similarity#setDefault(Similarity)    */
DECL|method|setSimilarity
specifier|public
name|void
name|setSimilarity
parameter_list|(
name|Similarity
name|similarity
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|similarity
operator|=
name|similarity
expr_stmt|;
block|}
comment|/** Expert: Return the Similarity implementation used by this IndexWriter.    *    *<p>This defaults to the current value of {@link Similarity#getDefault()}.    */
DECL|method|getSimilarity
specifier|public
name|Similarity
name|getSimilarity
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|this
operator|.
name|similarity
return|;
block|}
comment|/** Expert: Set the interval between indexed terms.  Large values cause less    * memory to be used by IndexReader, but slow random-access to terms.  Small    * values cause more memory to be used by an IndexReader, and speed    * random-access to terms.    *    * This parameter determines the amount of computation required per query    * term, regardless of the number of documents that contain that term.  In    * particular, it is the maximum number of other terms that must be    * scanned before a term is located and its frequency and position information    * may be processed.  In a large index with user-entered query terms, query    * processing time is likely to be dominated not by term lookup but rather    * by the processing of frequency and positional data.  In a small index    * or when many uncommon query terms are generated (e.g., by wildcard    * queries) term lookup may become a dominant cost.    *    * In particular,<code>numUniqueTerms/interval</code> terms are read into    * memory by an IndexReader, and, on average,<code>interval/2</code> terms    * must be scanned for each random term access.    *    * @see #DEFAULT_TERM_INDEX_INTERVAL    */
DECL|method|setTermIndexInterval
specifier|public
name|void
name|setTermIndexInterval
parameter_list|(
name|int
name|interval
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|termIndexInterval
operator|=
name|interval
expr_stmt|;
block|}
comment|/** Expert: Return the interval between indexed terms.    *    * @see #setTermIndexInterval(int)    */
DECL|method|getTermIndexInterval
specifier|public
name|int
name|getTermIndexInterval
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|termIndexInterval
return|;
block|}
comment|/**    * Constructs an IndexWriter for the index in<code>path</code>.    * Text will be analyzed with<code>a</code>.  If<code>create</code>    * is true, then a new, empty index will be created in    *<code>path</code>, replacing the index already there, if any.    *    * @param path the path to the index directory    * @param a the analyzer to use    * @param create<code>true</code> to create the index or overwrite    *  the existing one;<code>false</code> to append to the existing    *  index    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if the directory cannot be read/written to, or    *  if it does not exist and<code>create</code> is    *<code>false</code> or if there is any other low-level    *  IO error    */
DECL|method|IndexWriter
specifier|public
name|IndexWriter
parameter_list|(
name|String
name|path
parameter_list|,
name|Analyzer
name|a
parameter_list|,
name|boolean
name|create
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|init
argument_list|(
name|FSDirectory
operator|.
name|getDirectory
argument_list|(
name|path
argument_list|)
argument_list|,
name|a
argument_list|,
name|create
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs an IndexWriter for the index in<code>path</code>.    * Text will be analyzed with<code>a</code>.  If<code>create</code>    * is true, then a new, empty index will be created in    *<code>path</code>, replacing the index already there, if any.    *    * @param path the path to the index directory    * @param a the analyzer to use    * @param create<code>true</code> to create the index or overwrite    *  the existing one;<code>false</code> to append to the existing    *  index    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if the directory cannot be read/written to, or    *  if it does not exist and<code>create</code> is    *<code>false</code> or if there is any other low-level    *  IO error    */
DECL|method|IndexWriter
specifier|public
name|IndexWriter
parameter_list|(
name|File
name|path
parameter_list|,
name|Analyzer
name|a
parameter_list|,
name|boolean
name|create
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|init
argument_list|(
name|FSDirectory
operator|.
name|getDirectory
argument_list|(
name|path
argument_list|)
argument_list|,
name|a
argument_list|,
name|create
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs an IndexWriter for the index in<code>d</code>.    * Text will be analyzed with<code>a</code>.  If<code>create</code>    * is true, then a new, empty index will be created in    *<code>d</code>, replacing the index already there, if any.    *    * @param d the index directory    * @param a the analyzer to use    * @param create<code>true</code> to create the index or overwrite    *  the existing one;<code>false</code> to append to the existing    *  index    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if the directory cannot be read/written to, or    *  if it does not exist and<code>create</code> is    *<code>false</code> or if there is any other low-level    *  IO error    */
DECL|method|IndexWriter
specifier|public
name|IndexWriter
parameter_list|(
name|Directory
name|d
parameter_list|,
name|Analyzer
name|a
parameter_list|,
name|boolean
name|create
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|init
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|create
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs an IndexWriter for the index in    *<code>path</code>, first creating it if it does not    * already exist.  Text will be analyzed with    *<code>a</code>.    *    * @param path the path to the index directory    * @param a the analyzer to use    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if the directory cannot be    *  read/written to or if there is any other low-level    *  IO error    */
DECL|method|IndexWriter
specifier|public
name|IndexWriter
parameter_list|(
name|String
name|path
parameter_list|,
name|Analyzer
name|a
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|init
argument_list|(
name|FSDirectory
operator|.
name|getDirectory
argument_list|(
name|path
argument_list|)
argument_list|,
name|a
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs an IndexWriter for the index in    *<code>path</code>, first creating it if it does not    * already exist.  Text will be analyzed with    *<code>a</code>.    *    * @param path the path to the index directory    * @param a the analyzer to use    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if the directory cannot be    *  read/written to or if there is any other low-level    *  IO error    */
DECL|method|IndexWriter
specifier|public
name|IndexWriter
parameter_list|(
name|File
name|path
parameter_list|,
name|Analyzer
name|a
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|init
argument_list|(
name|FSDirectory
operator|.
name|getDirectory
argument_list|(
name|path
argument_list|)
argument_list|,
name|a
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs an IndexWriter for the index in    *<code>d</code>, first creating it if it does not    * already exist.  Text will be analyzed with    *<code>a</code>.    *    * @param d the index directory    * @param a the analyzer to use    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if the directory cannot be    *  read/written to or if there is any other low-level    *  IO error    */
DECL|method|IndexWriter
specifier|public
name|IndexWriter
parameter_list|(
name|Directory
name|d
parameter_list|,
name|Analyzer
name|a
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|init
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs an IndexWriter for the index in    *<code>d</code>, first creating it if it does not    * already exist.  Text will be analyzed with    *<code>a</code>.    *    * @param d the index directory    * @param autoCommit see<a href="#autoCommit">above</a>    * @param a the analyzer to use    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if the directory cannot be    *  read/written to or if there is any other low-level    *  IO error    */
DECL|method|IndexWriter
specifier|public
name|IndexWriter
parameter_list|(
name|Directory
name|d
parameter_list|,
name|boolean
name|autoCommit
parameter_list|,
name|Analyzer
name|a
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|init
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|autoCommit
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs an IndexWriter for the index in<code>d</code>.    * Text will be analyzed with<code>a</code>.  If<code>create</code>    * is true, then a new, empty index will be created in    *<code>d</code>, replacing the index already there, if any.    *    * @param d the index directory    * @param autoCommit see<a href="#autoCommit">above</a>    * @param a the analyzer to use    * @param create<code>true</code> to create the index or overwrite    *  the existing one;<code>false</code> to append to the existing    *  index    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if the directory cannot be read/written to, or    *  if it does not exist and<code>create</code> is    *<code>false</code> or if there is any other low-level    *  IO error    */
DECL|method|IndexWriter
specifier|public
name|IndexWriter
parameter_list|(
name|Directory
name|d
parameter_list|,
name|boolean
name|autoCommit
parameter_list|,
name|Analyzer
name|a
parameter_list|,
name|boolean
name|create
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|init
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|create
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|autoCommit
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expert: constructs an IndexWriter with a custom {@link    * IndexDeletionPolicy}, for the index in<code>d</code>,    * first creating it if it does not already exist.  Text    * will be analyzed with<code>a</code>.    *    * @param d the index directory    * @param autoCommit see<a href="#autoCommit">above</a>    * @param a the analyzer to use    * @param deletionPolicy see<a href="#deletionPolicy">above</a>    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if the directory cannot be    *  read/written to or if there is any other low-level    *  IO error    */
DECL|method|IndexWriter
specifier|public
name|IndexWriter
parameter_list|(
name|Directory
name|d
parameter_list|,
name|boolean
name|autoCommit
parameter_list|,
name|Analyzer
name|a
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|init
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
literal|false
argument_list|,
name|deletionPolicy
argument_list|,
name|autoCommit
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expert: constructs an IndexWriter with a custom {@link    * IndexDeletionPolicy}, for the index in<code>d</code>.    * Text will be analyzed with<code>a</code>.  If    *<code>create</code> is true, then a new, empty index    * will be created in<code>d</code>, replacing the index    * already there, if any.    *    * @param d the index directory    * @param autoCommit see<a href="#autoCommit">above</a>    * @param a the analyzer to use    * @param create<code>true</code> to create the index or overwrite    *  the existing one;<code>false</code> to append to the existing    *  index    * @param deletionPolicy see<a href="#deletionPolicy">above</a>    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if the directory cannot be read/written to, or    *  if it does not exist and<code>create</code> is    *<code>false</code> or if there is any other low-level    *  IO error    */
DECL|method|IndexWriter
specifier|public
name|IndexWriter
parameter_list|(
name|Directory
name|d
parameter_list|,
name|boolean
name|autoCommit
parameter_list|,
name|Analyzer
name|a
parameter_list|,
name|boolean
name|create
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|init
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|create
argument_list|,
literal|false
argument_list|,
name|deletionPolicy
argument_list|,
name|autoCommit
argument_list|)
expr_stmt|;
block|}
DECL|method|init
specifier|private
name|void
name|init
parameter_list|(
name|Directory
name|d
parameter_list|,
name|Analyzer
name|a
parameter_list|,
name|boolean
name|closeDir
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|,
name|boolean
name|autoCommit
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
if|if
condition|(
name|IndexReader
operator|.
name|indexExists
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|init
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
literal|false
argument_list|,
name|closeDir
argument_list|,
name|deletionPolicy
argument_list|,
name|autoCommit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|init
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
literal|true
argument_list|,
name|closeDir
argument_list|,
name|deletionPolicy
argument_list|,
name|autoCommit
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|init
specifier|private
name|void
name|init
parameter_list|(
name|Directory
name|d
parameter_list|,
name|Analyzer
name|a
parameter_list|,
specifier|final
name|boolean
name|create
parameter_list|,
name|boolean
name|closeDir
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|,
name|boolean
name|autoCommit
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|this
operator|.
name|closeDir
operator|=
name|closeDir
expr_stmt|;
name|directory
operator|=
name|d
expr_stmt|;
name|analyzer
operator|=
name|a
expr_stmt|;
name|this
operator|.
name|infoStream
operator|=
name|defaultInfoStream
expr_stmt|;
if|if
condition|(
name|create
condition|)
block|{
comment|// Clear the write lock in case it's leftover:
name|directory
operator|.
name|clearLock
argument_list|(
name|IndexWriter
operator|.
name|WRITE_LOCK_NAME
argument_list|)
expr_stmt|;
block|}
name|Lock
name|writeLock
init|=
name|directory
operator|.
name|makeLock
argument_list|(
name|IndexWriter
operator|.
name|WRITE_LOCK_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|writeLock
operator|.
name|obtain
argument_list|(
name|writeLockTimeout
argument_list|)
condition|)
comment|// obtain write lock
throw|throw
operator|new
name|LockObtainFailedException
argument_list|(
literal|"Index locked for write: "
operator|+
name|writeLock
argument_list|)
throw|;
name|this
operator|.
name|writeLock
operator|=
name|writeLock
expr_stmt|;
comment|// save it
try|try
block|{
if|if
condition|(
name|create
condition|)
block|{
comment|// Try to read first.  This is to allow create
comment|// against an index that's currently open for
comment|// searching.  In this case we write the next
comment|// segments_N file with no segments:
try|try
block|{
name|segmentInfos
operator|.
name|read
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|segmentInfos
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Likely this means it's a fresh directory
block|}
name|segmentInfos
operator|.
name|write
argument_list|(
name|directory
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|segmentInfos
operator|.
name|read
argument_list|(
name|directory
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|autoCommit
operator|=
name|autoCommit
expr_stmt|;
if|if
condition|(
operator|!
name|autoCommit
condition|)
block|{
name|rollbackSegmentInfos
operator|=
operator|(
name|SegmentInfos
operator|)
name|segmentInfos
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
name|docWriter
operator|=
operator|new
name|DocumentsWriter
argument_list|(
name|directory
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|docWriter
operator|.
name|setInfoStream
argument_list|(
name|infoStream
argument_list|)
expr_stmt|;
comment|// Default deleter (for backwards compatibility) is
comment|// KeepOnlyLastCommitDeleter:
name|deleter
operator|=
operator|new
name|IndexFileDeleter
argument_list|(
name|directory
argument_list|,
name|deletionPolicy
operator|==
literal|null
condition|?
operator|new
name|KeepOnlyLastCommitDeletionPolicy
argument_list|()
else|:
name|deletionPolicy
argument_list|,
name|segmentInfos
argument_list|,
name|infoStream
argument_list|,
name|docWriter
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|this
operator|.
name|writeLock
operator|.
name|release
argument_list|()
expr_stmt|;
name|this
operator|.
name|writeLock
operator|=
literal|null
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** Determines the largest number of documents ever merged by addDocument().    * Small values (e.g., less than 10,000) are best for interactive indexing,    * as this limits the length of pauses while indexing to a few seconds.    * Larger values are best for batched indexing and speedier searches.    *    *<p>The default value is {@link Integer#MAX_VALUE}.    */
DECL|method|setMaxMergeDocs
specifier|public
name|void
name|setMaxMergeDocs
parameter_list|(
name|int
name|maxMergeDocs
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxMergeDocs
operator|=
name|maxMergeDocs
expr_stmt|;
block|}
comment|/**    * Returns the largest number of documents allowed in a    * single segment.    * @see #setMaxMergeDocs    */
DECL|method|getMaxMergeDocs
specifier|public
name|int
name|getMaxMergeDocs
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|maxMergeDocs
return|;
block|}
comment|/**    * The maximum number of terms that will be indexed for a single field in a    * document.  This limits the amount of memory required for indexing, so that    * collections with very large files will not crash the indexing process by    * running out of memory.  This setting refers to the number of running terms,    * not to the number of different terms.<p/>    *<strong>Note:</strong> this silently truncates large documents, excluding from the    * index all terms that occur further in the document.  If you know your source    * documents are large, be sure to set this value high enough to accomodate    * the expected size.  If you set it to Integer.MAX_VALUE, then the only limit    * is your memory, but you should anticipate an OutOfMemoryError.<p/>    * By default, no more than 10,000 terms will be indexed for a field.    */
DECL|method|setMaxFieldLength
specifier|public
name|void
name|setMaxFieldLength
parameter_list|(
name|int
name|maxFieldLength
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxFieldLength
operator|=
name|maxFieldLength
expr_stmt|;
block|}
comment|/**    * Returns the maximum number of terms that will be    * indexed for a single field in a document.    * @see #setMaxFieldLength    */
DECL|method|getMaxFieldLength
specifier|public
name|int
name|getMaxFieldLength
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|maxFieldLength
return|;
block|}
comment|/** Determines the minimal number of documents required    * before the buffered in-memory documents are flushed as    * a new Segment.  Large values generally gives faster    * indexing.    *    *<p>When this is set, the writer will flush every    * maxBufferedDocs added documents and never flush by RAM    * usage.</p>    *    *<p> The default value is 0 (writer flushes by RAM    * usage).</p>    *    * @throws IllegalArgumentException if maxBufferedDocs is    * smaller than 2    * @see #setRAMBufferSizeMB    */
DECL|method|setMaxBufferedDocs
specifier|public
name|void
name|setMaxBufferedDocs
parameter_list|(
name|int
name|maxBufferedDocs
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|maxBufferedDocs
operator|<
literal|2
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxBufferedDocs must at least be 2"
argument_list|)
throw|;
name|docWriter
operator|.
name|setMaxBufferedDocs
argument_list|(
name|maxBufferedDocs
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns 0 if this writer is flushing by RAM usage, else    * returns the number of buffered added documents that will    * trigger a flush.    * @see #setMaxBufferedDocs    */
DECL|method|getMaxBufferedDocs
specifier|public
name|int
name|getMaxBufferedDocs
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|docWriter
operator|.
name|getMaxBufferedDocs
argument_list|()
return|;
block|}
comment|/** Determines the amount of RAM that may be used for    * buffering added documents before they are flushed as a    * new Segment.  Generally for faster indexing performance    * it's best to flush by RAM usage instead of document    * count and use as large a RAM buffer as you can.    *    *<p>When this is set, the writer will flush whenever    * buffered documents use this much RAM.</p>    *    *<p> The default value is {@link #DEFAULT_RAM_BUFFER_SIZE_MB}.</p>    */
DECL|method|setRAMBufferSizeMB
specifier|public
name|void
name|setRAMBufferSizeMB
parameter_list|(
name|double
name|mb
parameter_list|)
block|{
if|if
condition|(
name|mb
operator|<=
literal|0.0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ramBufferSize should be> 0.0 MB"
argument_list|)
throw|;
name|docWriter
operator|.
name|setRAMBufferSizeMB
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns 0.0 if this writer is flushing by document    * count, else returns the value set by {@link    * #setRAMBufferSizeMB}.    */
DECL|method|getRAMBufferSizeMB
specifier|public
name|double
name|getRAMBufferSizeMB
parameter_list|()
block|{
return|return
name|docWriter
operator|.
name|getRAMBufferSizeMB
argument_list|()
return|;
block|}
comment|/**    *<p>Determines the minimal number of delete terms required before the buffered    * in-memory delete terms are applied and flushed. If there are documents    * buffered in memory at the time, they are merged and a new segment is    * created.</p>     *<p>The default value is {@link #DEFAULT_MAX_BUFFERED_DELETE_TERMS}.    * @throws IllegalArgumentException if maxBufferedDeleteTerms is smaller than 1</p>    */
DECL|method|setMaxBufferedDeleteTerms
specifier|public
name|void
name|setMaxBufferedDeleteTerms
parameter_list|(
name|int
name|maxBufferedDeleteTerms
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|maxBufferedDeleteTerms
operator|<
literal|1
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxBufferedDeleteTerms must at least be 1"
argument_list|)
throw|;
name|this
operator|.
name|maxBufferedDeleteTerms
operator|=
name|maxBufferedDeleteTerms
expr_stmt|;
block|}
comment|/**    * Returns the number of buffered deleted terms that will    * trigger a flush.    * @see #setMaxBufferedDeleteTerms    */
DECL|method|getMaxBufferedDeleteTerms
specifier|public
name|int
name|getMaxBufferedDeleteTerms
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|maxBufferedDeleteTerms
return|;
block|}
comment|/** Determines how often segment indices are merged by addDocument().  With    * smaller values, less RAM is used while indexing, and searches on    * unoptimized indices are faster, but indexing speed is slower.  With larger    * values, more RAM is used during indexing, and while searches on unoptimized    * indices are slower, indexing is faster.  Thus larger values (> 10) are best    * for batch index creation, and smaller values (< 10) for indices that are    * interactively maintained.    *    *<p>This must never be less than 2.  The default value is 10.    */
DECL|method|setMergeFactor
specifier|public
name|void
name|setMergeFactor
parameter_list|(
name|int
name|mergeFactor
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|mergeFactor
operator|<
literal|2
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"mergeFactor cannot be less than 2"
argument_list|)
throw|;
name|this
operator|.
name|mergeFactor
operator|=
name|mergeFactor
expr_stmt|;
block|}
comment|/**    * Returns the number of segments that are merged at once    * and also controls the total number of segments allowed    * to accumulate in the index.    * @see #setMergeFactor    */
DECL|method|getMergeFactor
specifier|public
name|int
name|getMergeFactor
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|mergeFactor
return|;
block|}
comment|/** If non-null, this will be the default infoStream used    * by a newly instantiated IndexWriter.    * @see #setInfoStream    */
DECL|method|setDefaultInfoStream
specifier|public
specifier|static
name|void
name|setDefaultInfoStream
parameter_list|(
name|PrintStream
name|infoStream
parameter_list|)
block|{
name|IndexWriter
operator|.
name|defaultInfoStream
operator|=
name|infoStream
expr_stmt|;
block|}
comment|/**    * Returns the current default infoStream for newly    * instantiated IndexWriters.    * @see #setDefaultInfoStream    */
DECL|method|getDefaultInfoStream
specifier|public
specifier|static
name|PrintStream
name|getDefaultInfoStream
parameter_list|()
block|{
return|return
name|IndexWriter
operator|.
name|defaultInfoStream
return|;
block|}
comment|/** If non-null, information about merges, deletes and a    * message when maxFieldLength is reached will be printed    * to this.    */
DECL|method|setInfoStream
specifier|public
name|void
name|setInfoStream
parameter_list|(
name|PrintStream
name|infoStream
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|infoStream
operator|=
name|infoStream
expr_stmt|;
name|docWriter
operator|.
name|setInfoStream
argument_list|(
name|infoStream
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|setInfoStream
argument_list|(
name|infoStream
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the current infoStream in use by this writer.    * @see #setInfoStream    */
DECL|method|getInfoStream
specifier|public
name|PrintStream
name|getInfoStream
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|infoStream
return|;
block|}
comment|/**    * Sets the maximum time to wait for a write lock (in milliseconds) for this instance of IndexWriter.  @see    * @see #setDefaultWriteLockTimeout to change the default value for all instances of IndexWriter.    */
DECL|method|setWriteLockTimeout
specifier|public
name|void
name|setWriteLockTimeout
parameter_list|(
name|long
name|writeLockTimeout
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|writeLockTimeout
operator|=
name|writeLockTimeout
expr_stmt|;
block|}
comment|/**    * Returns allowed timeout when acquiring the write lock.    * @see #setWriteLockTimeout    */
DECL|method|getWriteLockTimeout
specifier|public
name|long
name|getWriteLockTimeout
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|writeLockTimeout
return|;
block|}
comment|/**    * Sets the default (for any instance of IndexWriter) maximum time to wait for a write lock (in    * milliseconds).    */
DECL|method|setDefaultWriteLockTimeout
specifier|public
specifier|static
name|void
name|setDefaultWriteLockTimeout
parameter_list|(
name|long
name|writeLockTimeout
parameter_list|)
block|{
name|IndexWriter
operator|.
name|WRITE_LOCK_TIMEOUT
operator|=
name|writeLockTimeout
expr_stmt|;
block|}
comment|/**    * Returns default write lock timeout for newly    * instantiated IndexWriters.    * @see #setDefaultWriteLockTimeout    */
DECL|method|getDefaultWriteLockTimeout
specifier|public
specifier|static
name|long
name|getDefaultWriteLockTimeout
parameter_list|()
block|{
return|return
name|IndexWriter
operator|.
name|WRITE_LOCK_TIMEOUT
return|;
block|}
comment|/**    * Flushes all changes to an index and closes all    * associated files.    *    *<p> If an Exception is hit during close, eg due to disk    * full or some other reason, then both the on-disk index    * and the internal state of the IndexWriter instance will    * be consistent.  However, the close will not be complete    * even though part of it (flushing buffered documents)    * may have succeeded, so the write lock will still be    * held.</p>    *     *<p> If you can correct the underlying cause (eg free up    * some disk space) then you can call close() again.    * Failing that, if you want to force the write lock to be    * released (dangerous, because you may then lose buffered    * docs in the IndexWriter instance) then you can do    * something like this:</p>    *    *<pre>    * try {    *   writer.close();    * } finally {    *   if (IndexReader.isLocked(directory)) {    *     IndexReader.unlock(directory);    *   }    * }    *</pre>    *    * after which, you must be certain not to use the writer    * instance anymore.</p>    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|close
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
name|flush
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|commitPending
condition|)
block|{
name|segmentInfos
operator|.
name|write
argument_list|(
name|directory
argument_list|)
expr_stmt|;
comment|// now commit changes
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"close: wrote segments file \""
operator|+
name|segmentInfos
operator|.
name|getCurrentSegmentFileName
argument_list|()
operator|+
literal|"\""
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|commitPending
operator|=
literal|false
expr_stmt|;
name|rollbackSegmentInfos
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|writeLock
operator|!=
literal|null
condition|)
block|{
name|writeLock
operator|.
name|release
argument_list|()
expr_stmt|;
comment|// release write lock
name|writeLock
operator|=
literal|null
expr_stmt|;
block|}
name|closed
operator|=
literal|true
expr_stmt|;
name|docWriter
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|closeDir
condition|)
name|directory
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Tells the docWriter to close its currently open shared    *  doc stores (stored fields& vectors files). */
DECL|method|flushDocStores
specifier|private
name|void
name|flushDocStores
parameter_list|()
throws|throws
name|IOException
block|{
name|List
name|files
init|=
name|docWriter
operator|.
name|files
argument_list|()
decl_stmt|;
if|if
condition|(
name|files
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
name|docStoreSegment
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|docStoreSegment
operator|=
name|docWriter
operator|.
name|closeDocStore
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
name|docWriter
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|useCompoundFile
operator|&&
name|docStoreSegment
operator|!=
literal|null
condition|)
block|{
comment|// Now build compound doc store file
name|checkpoint
argument_list|()
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
specifier|final
name|int
name|numSegments
init|=
name|segmentInfos
operator|.
name|size
argument_list|()
decl_stmt|;
try|try
block|{
name|CompoundFileWriter
name|cfsWriter
init|=
operator|new
name|CompoundFileWriter
argument_list|(
name|directory
argument_list|,
name|docStoreSegment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|COMPOUND_FILE_STORE_EXTENSION
argument_list|)
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|files
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|cfsWriter
operator|.
name|addFile
argument_list|(
operator|(
name|String
operator|)
name|files
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// Perform the merge
name|cfsWriter
operator|.
name|close
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
condition|;
name|i
operator|++
control|)
block|{
name|SegmentInfo
name|si
init|=
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|si
operator|.
name|getDocStoreOffset
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|si
operator|.
name|getDocStoreSegment
argument_list|()
operator|.
name|equals
argument_list|(
name|docStoreSegment
argument_list|)
condition|)
name|si
operator|.
name|setDocStoreIsCompoundFile
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|checkpoint
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// Rollback to no compound file
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
condition|;
name|i
operator|++
control|)
block|{
name|SegmentInfo
name|si
init|=
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|si
operator|.
name|getDocStoreOffset
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|si
operator|.
name|getDocStoreSegment
argument_list|()
operator|.
name|equals
argument_list|(
name|docStoreSegment
argument_list|)
condition|)
name|si
operator|.
name|setDocStoreIsCompoundFile
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|deleter
operator|.
name|refresh
argument_list|()
expr_stmt|;
block|}
block|}
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Release the write lock, if needed. */
DECL|method|finalize
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
try|try
block|{
if|if
condition|(
name|writeLock
operator|!=
literal|null
condition|)
block|{
name|writeLock
operator|.
name|release
argument_list|()
expr_stmt|;
comment|// release write lock
name|writeLock
operator|=
literal|null
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Returns the Directory used by this index. */
DECL|method|getDirectory
specifier|public
name|Directory
name|getDirectory
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|directory
return|;
block|}
comment|/** Returns the analyzer used by this index. */
DECL|method|getAnalyzer
specifier|public
name|Analyzer
name|getAnalyzer
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|analyzer
return|;
block|}
comment|/** Returns the number of documents currently in this index. */
DECL|method|docCount
specifier|public
specifier|synchronized
name|int
name|docCount
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|int
name|count
init|=
name|docWriter
operator|.
name|getNumDocsInRAM
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segmentInfos
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SegmentInfo
name|si
init|=
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|count
operator|+=
name|si
operator|.
name|docCount
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**    * The maximum number of terms that will be indexed for a single field in a    * document.  This limits the amount of memory required for indexing, so that    * collections with very large files will not crash the indexing process by    * running out of memory.<p/>    * Note that this effectively truncates large documents, excluding from the    * index terms that occur further in the document.  If you know your source    * documents are large, be sure to set this value high enough to accomodate    * the expected size.  If you set it to Integer.MAX_VALUE, then the only limit    * is your memory, but you should anticipate an OutOfMemoryError.<p/>    * By default, no more than 10,000 terms will be indexed for a field.    *    */
DECL|field|maxFieldLength
specifier|private
name|int
name|maxFieldLength
init|=
name|DEFAULT_MAX_FIELD_LENGTH
decl_stmt|;
comment|/**    * Adds a document to this index.  If the document contains more than    * {@link #setMaxFieldLength(int)} terms for a given field, the remainder are    * discarded.    *    *<p> Note that if an Exception is hit (for example disk full)    * then the index will be consistent, but this document    * may not have been added.  Furthermore, it's possible    * the index will have one segment in non-compound format    * even when using compound files (when a merge has    * partially succeeded).</p>    *    *<p> This method periodically flushes pending documents    * to the Directory (every {@link #setMaxBufferedDocs}),    * and also periodically merges segments in the index    * (every {@link #setMergeFactor} flushes).  When this    * occurs, the method will take more time to run (possibly    * a long time if the index is large), and will require    * free temporary space in the Directory to do the    * merging.</p>    *    *<p>The amount of free space required when a merge is    * triggered is up to 1X the size of all segments being    * merged, when no readers/searchers are open against the    * index, and up to 2X the size of all segments being    * merged when readers/searchers are open against the    * index (see {@link #optimize()} for details).  Most    * merges are small (merging the smallest segments    * together), but whenever a full merge occurs (all    * segments in the index, which is the worst case for    * temporary space usage) then the maximum free disk space    * required is the same as {@link #optimize}.</p>    *    *<p>Note that each term in the document can be no longer    * than 16383 characters, otherwise an    * IllegalArgumentException will be thrown.</p>    *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|addDocument
specifier|public
name|void
name|addDocument
parameter_list|(
name|Document
name|doc
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|addDocument
argument_list|(
name|doc
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds a document to this index, using the provided analyzer instead of the    * value of {@link #getAnalyzer()}.  If the document contains more than    * {@link #setMaxFieldLength(int)} terms for a given field, the remainder are    * discarded.    *    *<p>See {@link #addDocument(Document)} for details on    * index and IndexWriter state after an Exception, and    * flushing/merging temporary free space requirements.</p>    *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|addDocument
specifier|public
name|void
name|addDocument
parameter_list|(
name|Document
name|doc
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|success
operator|=
name|docWriter
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|deleter
operator|.
name|refresh
argument_list|()
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
if|if
condition|(
name|success
condition|)
name|flush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Deletes the document(s) containing<code>term</code>.    * @param term the term to identify the documents to be deleted    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|deleteDocuments
specifier|public
specifier|synchronized
name|void
name|deleteDocuments
parameter_list|(
name|Term
name|term
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|bufferDeleteTerm
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|maybeFlush
argument_list|()
expr_stmt|;
block|}
comment|/**    * Deletes the document(s) containing any of the    * terms. All deletes are flushed at the same time.    * @param terms array of terms to identify the documents    * to be deleted    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|deleteDocuments
specifier|public
specifier|synchronized
name|void
name|deleteDocuments
parameter_list|(
name|Term
index|[]
name|terms
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|terms
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|bufferDeleteTerm
argument_list|(
name|terms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|maybeFlush
argument_list|()
expr_stmt|;
block|}
comment|/**    * Updates a document by first deleting the document(s)    * containing<code>term</code> and then adding the new    * document.  The delete and then add are atomic as seen    * by a reader on the same index (flush may happen only after    * the add).    * @param term the term to identify the document(s) to be    * deleted    * @param doc the document to be added    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|updateDocument
specifier|public
name|void
name|updateDocument
parameter_list|(
name|Term
name|term
parameter_list|,
name|Document
name|doc
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|updateDocument
argument_list|(
name|term
argument_list|,
name|doc
argument_list|,
name|getAnalyzer
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Updates a document by first deleting the document(s)    * containing<code>term</code> and then adding the new    * document.  The delete and then add are atomic as seen    * by a reader on the same index (flush may happen only after    * the add).    * @param term the term to identify the document(s) to be    * deleted    * @param doc the document to be added    * @param analyzer the analyzer to use when analyzing the document    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|updateDocument
specifier|public
name|void
name|updateDocument
parameter_list|(
name|Term
name|term
parameter_list|,
name|Document
name|doc
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|bufferDeleteTerm
argument_list|(
name|term
argument_list|)
expr_stmt|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|success
operator|=
name|docWriter
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|deleter
operator|.
name|refresh
argument_list|()
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
if|if
condition|(
name|success
condition|)
name|flush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
else|else
name|maybeFlush
argument_list|()
expr_stmt|;
block|}
comment|// for test purpose
DECL|method|getSegmentCount
specifier|final
specifier|synchronized
name|int
name|getSegmentCount
parameter_list|()
block|{
return|return
name|segmentInfos
operator|.
name|size
argument_list|()
return|;
block|}
comment|// for test purpose
DECL|method|getNumBufferedDocuments
specifier|final
specifier|synchronized
name|int
name|getNumBufferedDocuments
parameter_list|()
block|{
return|return
name|docWriter
operator|.
name|getNumDocsInRAM
argument_list|()
return|;
block|}
comment|// for test purpose
DECL|method|getDocCount
specifier|final
specifier|synchronized
name|int
name|getDocCount
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|segmentInfos
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
operator|.
name|docCount
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
DECL|method|newSegmentName
specifier|final
name|String
name|newSegmentName
parameter_list|()
block|{
return|return
literal|"_"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|segmentInfos
operator|.
name|counter
operator|++
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
return|;
block|}
comment|/** Determines how often segment indices are merged by addDocument().  With    * smaller values, less RAM is used while indexing, and searches on    * unoptimized indices are faster, but indexing speed is slower.  With larger    * values, more RAM is used during indexing, and while searches on unoptimized    * indices are slower, indexing is faster.  Thus larger values (> 10) are best    * for batch index creation, and smaller values (< 10) for indices that are    * interactively maintained.    *    *<p>This must never be less than 2.  The default value is {@link #DEFAULT_MERGE_FACTOR}.     */
DECL|field|mergeFactor
specifier|private
name|int
name|mergeFactor
init|=
name|DEFAULT_MERGE_FACTOR
decl_stmt|;
comment|/** Determines amount of RAM usage by the buffered docs at    * which point we trigger a flush to the index.    */
DECL|field|ramBufferSize
specifier|private
name|double
name|ramBufferSize
init|=
name|DEFAULT_RAM_BUFFER_SIZE_MB
operator|*
literal|1024F
operator|*
literal|1024F
decl_stmt|;
comment|/** Determines the largest number of documents ever merged by addDocument().    * Small values (e.g., less than 10,000) are best for interactive indexing,    * as this limits the length of pauses while indexing to a few seconds.    * Larger values are best for batched indexing and speedier searches.    *    *<p>The default value is {@link #DEFAULT_MAX_MERGE_DOCS}.     */
DECL|field|maxMergeDocs
specifier|private
name|int
name|maxMergeDocs
init|=
name|DEFAULT_MAX_MERGE_DOCS
decl_stmt|;
comment|/** If non-null, information about merges will be printed to this.     */
DECL|field|infoStream
specifier|private
name|PrintStream
name|infoStream
init|=
literal|null
decl_stmt|;
DECL|field|defaultInfoStream
specifier|private
specifier|static
name|PrintStream
name|defaultInfoStream
init|=
literal|null
decl_stmt|;
comment|/** Merges all segments together into a single segment,    * optimizing an index for search.    *    *<p>It is recommended that this method be called upon completion of indexing.  In    * environments with frequent updates, optimize is best done during low volume times, if at all.     *     *</p>    *<p>See http://www.gossamer-threads.com/lists/lucene/java-dev/47895 for more discussion.</p>    *    *<p>Note that this requires substantial temporary free    * space in the Directory (see<a target="_top"    * href="http://issues.apache.org/jira/browse/LUCENE-764">LUCENE-764</a>    * for details):</p>    *    *<ul>    *<li>    *     *<p>If no readers/searchers are open against the index,    * then free space required is up to 1X the total size of    * the starting index.  For example, if the starting    * index is 10 GB, then you must have up to 10 GB of free    * space before calling optimize.</p>    *    *<li>    *     *<p>If readers/searchers are using the index, then free    * space required is up to 2X the size of the starting    * index.  This is because in addition to the 1X used by    * optimize, the original 1X of the starting index is    * still consuming space in the Directory as the readers    * are holding the segments files open.  Even on Unix,    * where it will appear as if the files are gone ("ls"    * won't list them), they still consume storage due to    * "delete on last close" semantics.</p>    *     *<p>Furthermore, if some but not all readers re-open    * while the optimize is underway, this will cause> 2X    * temporary space to be consumed as those new readers    * will then hold open the partially optimized segments at    * that time.  It is best not to re-open readers while    * optimize is running.</p>    *    *</ul>    *    *<p>The actual temporary usage could be much less than    * these figures (it depends on many factors).</p>    *    *<p>Once the optimize completes, the total size of the    * index will be less than the size of the starting index.    * It could be quite a bit smaller (if there were many    * pending deletes) or just slightly smaller.</p>    *    *<p>If an Exception is hit during optimize(), for example    * due to disk full, the index will not be corrupt and no    * documents will have been lost.  However, it may have    * been partially optimized (some segments were merged but    * not all), and it's possible that one of the segments in    * the index will be in non-compound format even when    * using compound file format.  This will occur when the    * Exception is hit during conversion of the segment into    * compound format.</p>    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error   */
DECL|method|optimize
specifier|public
specifier|synchronized
name|void
name|optimize
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
while|while
condition|(
name|segmentInfos
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
operator|(
name|segmentInfos
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|(
name|SegmentReader
operator|.
name|hasDeletions
argument_list|(
name|segmentInfos
operator|.
name|info
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|||
name|SegmentReader
operator|.
name|hasSeparateNorms
argument_list|(
name|segmentInfos
operator|.
name|info
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|||
name|segmentInfos
operator|.
name|info
argument_list|(
literal|0
argument_list|)
operator|.
name|dir
operator|!=
name|directory
operator|||
operator|(
name|useCompoundFile
operator|&&
operator|!
name|segmentInfos
operator|.
name|info
argument_list|(
literal|0
argument_list|)
operator|.
name|getUseCompoundFile
argument_list|()
operator|)
operator|)
operator|)
condition|)
block|{
name|int
name|minSegment
init|=
name|segmentInfos
operator|.
name|size
argument_list|()
operator|-
name|mergeFactor
decl_stmt|;
name|mergeSegments
argument_list|(
name|minSegment
operator|<
literal|0
condition|?
literal|0
else|:
name|minSegment
argument_list|,
name|segmentInfos
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Begin a transaction.  During a transaction, any segment    * merges that happen (or ram segments flushed) will not    * write a new segments file and will not remove any files    * that were present at the start of the transaction.  You    * must make a matched (try/finally) call to    * commitTransaction() or rollbackTransaction() to finish    * the transaction.    *    * Note that buffered documents and delete terms are not handled    * within the transactions, so they must be flushed before the    * transaction is started.    */
DECL|method|startTransaction
specifier|private
name|void
name|startTransaction
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|numBufferedDeleteTerms
operator|==
literal|0
operator|:
literal|"calling startTransaction with buffered delete terms not supported"
assert|;
assert|assert
name|docWriter
operator|.
name|getNumDocsInRAM
argument_list|()
operator|==
literal|0
operator|:
literal|"calling startTransaction with buffered documents not supported"
assert|;
name|localRollbackSegmentInfos
operator|=
operator|(
name|SegmentInfos
operator|)
name|segmentInfos
operator|.
name|clone
argument_list|()
expr_stmt|;
name|localAutoCommit
operator|=
name|autoCommit
expr_stmt|;
if|if
condition|(
name|localAutoCommit
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
comment|// Turn off auto-commit during our local transaction:
name|autoCommit
operator|=
literal|false
expr_stmt|;
block|}
else|else
comment|// We must "protect" our files at this point from
comment|// deletion in case we need to rollback:
name|deleter
operator|.
name|incRef
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/*    * Rolls back the transaction and restores state to where    * we were at the start.    */
DECL|method|rollbackTransaction
specifier|private
name|void
name|rollbackTransaction
parameter_list|()
throws|throws
name|IOException
block|{
comment|// First restore autoCommit in case we hit an exception below:
name|autoCommit
operator|=
name|localAutoCommit
expr_stmt|;
comment|// Keep the same segmentInfos instance but replace all
comment|// of its SegmentInfo instances.  This is so the next
comment|// attempt to commit using this instance of IndexWriter
comment|// will always write to a new generation ("write once").
name|segmentInfos
operator|.
name|clear
argument_list|()
expr_stmt|;
name|segmentInfos
operator|.
name|addAll
argument_list|(
name|localRollbackSegmentInfos
argument_list|)
expr_stmt|;
name|localRollbackSegmentInfos
operator|=
literal|null
expr_stmt|;
comment|// Ask deleter to locate unreferenced files we had
comment|// created& remove them:
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|autoCommit
condition|)
comment|// Remove the incRef we did in startTransaction:
name|deleter
operator|.
name|decRef
argument_list|(
name|segmentInfos
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|refresh
argument_list|()
expr_stmt|;
block|}
comment|/*    * Commits the transaction.  This will write the new    * segments file and remove and pending deletions we have    * accumulated during the transaction    */
DECL|method|commitTransaction
specifier|private
name|void
name|commitTransaction
parameter_list|()
throws|throws
name|IOException
block|{
comment|// First restore autoCommit in case we hit an exception below:
name|autoCommit
operator|=
name|localAutoCommit
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|checkpoint
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|rollbackTransaction
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|autoCommit
condition|)
comment|// Remove the incRef we did in startTransaction.
name|deleter
operator|.
name|decRef
argument_list|(
name|localRollbackSegmentInfos
argument_list|)
expr_stmt|;
name|localRollbackSegmentInfos
operator|=
literal|null
expr_stmt|;
comment|// Give deleter a chance to remove files now:
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
name|autoCommit
argument_list|)
expr_stmt|;
block|}
comment|/**    * Close the<code>IndexWriter</code> without committing    * any of the changes that have occurred since it was    * opened. This removes any temporary files that had been    * created, after which the state of the index will be the    * same as it was when this writer was first opened.  This    * can only be called when this IndexWriter was opened    * with<code>autoCommit=false</code>.    * @throws IllegalStateException if this is called when    *  the writer was opened with<code>autoCommit=true</code>.    * @throws IOException if there is a low-level IO error    */
DECL|method|abort
specifier|public
specifier|synchronized
name|void
name|abort
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|autoCommit
condition|)
block|{
comment|// Keep the same segmentInfos instance but replace all
comment|// of its SegmentInfo instances.  This is so the next
comment|// attempt to commit using this instance of IndexWriter
comment|// will always write to a new generation ("write once").
name|segmentInfos
operator|.
name|clear
argument_list|()
expr_stmt|;
name|segmentInfos
operator|.
name|addAll
argument_list|(
name|rollbackSegmentInfos
argument_list|)
expr_stmt|;
name|docWriter
operator|.
name|abort
argument_list|()
expr_stmt|;
comment|// Ask deleter to locate unreferenced files& remove
comment|// them:
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|refresh
argument_list|()
expr_stmt|;
name|bufferedDeleteTerms
operator|.
name|clear
argument_list|()
expr_stmt|;
name|numBufferedDeleteTerms
operator|=
literal|0
expr_stmt|;
name|commitPending
operator|=
literal|false
expr_stmt|;
name|docWriter
operator|.
name|abort
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"abort() can only be called when IndexWriter was opened with autoCommit=false"
argument_list|)
throw|;
block|}
block|}
comment|/*    * Called whenever the SegmentInfos has been updated and    * the index files referenced exist (correctly) in the    * index directory.  If we are in autoCommit mode, we    * commit the change immediately.  Else, we mark    * commitPending.    */
DECL|method|checkpoint
specifier|private
name|void
name|checkpoint
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|autoCommit
condition|)
block|{
name|segmentInfos
operator|.
name|write
argument_list|(
name|directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"checkpoint: wrote segments file \""
operator|+
name|segmentInfos
operator|.
name|getCurrentSegmentFileName
argument_list|()
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|commitPending
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/** Merges all segments from an array of indexes into this index.    *    *<p>This may be used to parallelize batch indexing.  A large document    * collection can be broken into sub-collections.  Each sub-collection can be    * indexed in parallel, on a different thread, process or machine.  The    * complete index can then be created by merging sub-collection indexes    * with this method.    *    *<p>After this completes, the index is optimized.    *    *<p>This method is transactional in how Exceptions are    * handled: it does not commit a new segments_N file until    * all indexes are added.  This means if an Exception    * occurs (for example disk full), then either no indexes    * will have been added or they all will have been.</p>    *    *<p>If an Exception is hit, it's still possible that all    * indexes were successfully added.  This happens when the    * Exception is hit when trying to build a CFS file.  In    * this case, one segment in the index will be in non-CFS    * format, even when using compound file format.</p>    *    *<p>Also note that on an Exception, the index may still    * have been partially or fully optimized even though none    * of the input indexes were added.</p>    *    *<p>Note that this requires temporary free space in the    * Directory up to 2X the sum of all input indexes    * (including the starting index).  If readers/searchers    * are open against the starting index, then temporary    * free space required will be higher by the size of the    * starting index (see {@link #optimize()} for details).    *</p>    *    *<p>Once this completes, the final size of the index    * will be less than the sum of all input index sizes    * (including the starting index).  It could be quite a    * bit smaller (if there were many pending deletes) or    * just slightly smaller.</p>    *    *<p>See<a target="_top"    * href="http://issues.apache.org/jira/browse/LUCENE-702">LUCENE-702</a>    * for details.</p>    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|addIndexes
specifier|public
specifier|synchronized
name|void
name|addIndexes
parameter_list|(
name|Directory
index|[]
name|dirs
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|optimize
argument_list|()
expr_stmt|;
comment|// start with zero or 1 seg
name|int
name|start
init|=
name|segmentInfos
operator|.
name|size
argument_list|()
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|startTransaction
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|SegmentInfos
name|sis
init|=
operator|new
name|SegmentInfos
argument_list|()
decl_stmt|;
comment|// read infos from dir
name|sis
operator|.
name|read
argument_list|(
name|dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|sis
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|segmentInfos
operator|.
name|addElement
argument_list|(
name|sis
operator|.
name|info
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
comment|// add each info
block|}
block|}
comment|// merge newly added segments in log(n) passes
while|while
condition|(
name|segmentInfos
operator|.
name|size
argument_list|()
operator|>
name|start
operator|+
name|mergeFactor
condition|)
block|{
for|for
control|(
name|int
name|base
init|=
name|start
init|;
name|base
operator|<
name|segmentInfos
operator|.
name|size
argument_list|()
condition|;
name|base
operator|++
control|)
block|{
name|int
name|end
init|=
name|Math
operator|.
name|min
argument_list|(
name|segmentInfos
operator|.
name|size
argument_list|()
argument_list|,
name|base
operator|+
name|mergeFactor
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|-
name|base
operator|>
literal|1
condition|)
block|{
name|mergeSegments
argument_list|(
name|base
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|commitTransaction
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rollbackTransaction
argument_list|()
expr_stmt|;
block|}
block|}
name|optimize
argument_list|()
expr_stmt|;
comment|// final cleanup
block|}
comment|/**    * Merges all segments from an array of indexes into this index.    *<p>    * This is similar to addIndexes(Directory[]). However, no optimize()    * is called either at the beginning or at the end. Instead, merges    * are carried out as necessary.    *<p>    * This requires this index not be among those to be added, and the    * upper bound* of those segment doc counts not exceed maxMergeDocs.    *    *<p>See {@link #addIndexes(Directory[])} for    * details on transactional semantics, temporary free    * space required in the Directory, and non-CFS segments    * on an Exception.</p>    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|addIndexesNoOptimize
specifier|public
specifier|synchronized
name|void
name|addIndexesNoOptimize
parameter_list|(
name|Directory
index|[]
name|dirs
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
comment|// Adding indexes can be viewed as adding a sequence of segments S to
comment|// a sequence of segments T. Segments in T follow the invariants but
comment|// segments in S may not since they could come from multiple indexes.
comment|// Here is the merge algorithm for addIndexesNoOptimize():
comment|//
comment|// 1 Flush ram.
comment|// 2 Consider a combined sequence with segments from T followed
comment|//   by segments from S (same as current addIndexes(Directory[])).
comment|// 3 Assume the highest level for segments in S is h. Call
comment|//   maybeMergeSegments(), but instead of starting w/ lowerBound = -1
comment|//   and upperBound = maxBufferedDocs, start w/ lowerBound = -1 and
comment|//   upperBound = upperBound of level h. After this, the invariants
comment|//   are guaranteed except for the last< M segments whose levels<= h.
comment|// 4 If the invariants hold for the last< M segments whose levels<= h,
comment|//   if some of those< M segments are from S (not merged in step 3),
comment|//   properly copy them over*, otherwise done.
comment|//   Otherwise, simply merge those segments. If the merge results in
comment|//   a segment of level<= h, done. Otherwise, it's of level h+1 and call
comment|//   maybeMergeSegments() starting w/ upperBound = upperBound of level h+1.
comment|//
comment|// * Ideally, we want to simply copy a segment. However, directory does
comment|// not support copy yet. In addition, source may use compound file or not
comment|// and target may use compound file or not. So we use mergeSegments() to
comment|// copy a segment, which may cause doc count to change because deleted
comment|// docs are garbage collected.
comment|// 1 flush ram
name|ensureOpen
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
comment|// 2 copy segment infos and find the highest level from dirs
name|int
name|startUpperBound
init|=
name|docWriter
operator|.
name|getMaxBufferedDocs
argument_list|()
decl_stmt|;
comment|/* new merge policy     if (startUpperBound == 0)       startUpperBound = 10;     */
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|startTransaction
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|directory
operator|==
name|dirs
index|[
name|i
index|]
condition|)
block|{
comment|// cannot add this index: segments may be deleted in merge before added
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot add this index to itself"
argument_list|)
throw|;
block|}
name|SegmentInfos
name|sis
init|=
operator|new
name|SegmentInfos
argument_list|()
decl_stmt|;
comment|// read infos from dir
name|sis
operator|.
name|read
argument_list|(
name|dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|sis
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|SegmentInfo
name|info
init|=
name|sis
operator|.
name|info
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|segmentInfos
operator|.
name|addElement
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|// add each info
while|while
condition|(
name|startUpperBound
operator|<
name|info
operator|.
name|docCount
condition|)
block|{
name|startUpperBound
operator|*=
name|mergeFactor
expr_stmt|;
comment|// find the highest level from dirs
if|if
condition|(
name|startUpperBound
operator|>
name|maxMergeDocs
condition|)
block|{
comment|// upper bound cannot exceed maxMergeDocs
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Upper bound cannot exceed maxMergeDocs"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|// 3 maybe merge segments starting from the highest level from dirs
name|maybeMergeSegments
argument_list|(
name|startUpperBound
argument_list|)
expr_stmt|;
comment|// get the tail segments whose levels<= h
name|int
name|segmentCount
init|=
name|segmentInfos
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|numTailSegments
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|numTailSegments
operator|<
name|segmentCount
operator|&&
name|startUpperBound
operator|>=
name|segmentInfos
operator|.
name|info
argument_list|(
name|segmentCount
operator|-
literal|1
operator|-
name|numTailSegments
argument_list|)
operator|.
name|docCount
condition|)
block|{
name|numTailSegments
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|numTailSegments
operator|==
literal|0
condition|)
block|{
name|success
operator|=
literal|true
expr_stmt|;
return|return;
block|}
comment|// 4 make sure invariants hold for the tail segments whose levels<= h
if|if
condition|(
name|checkNonDecreasingLevels
argument_list|(
name|segmentCount
operator|-
name|numTailSegments
argument_list|)
condition|)
block|{
comment|// identify the segments from S to be copied (not merged in 3)
name|int
name|numSegmentsToCopy
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|numSegmentsToCopy
operator|<
name|segmentCount
operator|&&
name|directory
operator|!=
name|segmentInfos
operator|.
name|info
argument_list|(
name|segmentCount
operator|-
literal|1
operator|-
name|numSegmentsToCopy
argument_list|)
operator|.
name|dir
condition|)
block|{
name|numSegmentsToCopy
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|numSegmentsToCopy
operator|==
literal|0
condition|)
block|{
name|success
operator|=
literal|true
expr_stmt|;
return|return;
block|}
comment|// copy those segments from S
for|for
control|(
name|int
name|i
init|=
name|segmentCount
operator|-
name|numSegmentsToCopy
init|;
name|i
operator|<
name|segmentCount
condition|;
name|i
operator|++
control|)
block|{
name|mergeSegments
argument_list|(
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|checkNonDecreasingLevels
argument_list|(
name|segmentCount
operator|-
name|numSegmentsToCopy
argument_list|)
condition|)
block|{
name|success
operator|=
literal|true
expr_stmt|;
return|return;
block|}
block|}
comment|// invariants do not hold, simply merge those segments
name|mergeSegments
argument_list|(
name|segmentCount
operator|-
name|numTailSegments
argument_list|,
name|segmentCount
argument_list|)
expr_stmt|;
comment|// maybe merge segments again if necessary
if|if
condition|(
name|segmentInfos
operator|.
name|info
argument_list|(
name|segmentInfos
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|docCount
operator|>
name|startUpperBound
condition|)
block|{
name|maybeMergeSegments
argument_list|(
name|startUpperBound
operator|*
name|mergeFactor
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|commitTransaction
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rollbackTransaction
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Merges the provided indexes into this index.    *<p>After this completes, the index is optimized.</p>    *<p>The provided IndexReaders are not closed.</p>     *<p>See {@link #addIndexes(Directory[])} for    * details on transactional semantics, temporary free    * space required in the Directory, and non-CFS segments    * on an Exception.</p>    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|addIndexes
specifier|public
specifier|synchronized
name|void
name|addIndexes
parameter_list|(
name|IndexReader
index|[]
name|readers
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|optimize
argument_list|()
expr_stmt|;
comment|// start with zero or 1 seg
specifier|final
name|String
name|mergedName
init|=
name|newSegmentName
argument_list|()
decl_stmt|;
name|SegmentMerger
name|merger
init|=
operator|new
name|SegmentMerger
argument_list|(
name|this
argument_list|,
name|mergedName
argument_list|)
decl_stmt|;
name|SegmentInfo
name|info
decl_stmt|;
name|IndexReader
name|sReader
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|segmentInfos
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// add existing index, if any
name|sReader
operator|=
name|SegmentReader
operator|.
name|get
argument_list|(
name|segmentInfos
operator|.
name|info
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|merger
operator|.
name|add
argument_list|(
name|sReader
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|readers
operator|.
name|length
condition|;
name|i
operator|++
control|)
comment|// add new indexes
name|merger
operator|.
name|add
argument_list|(
name|readers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|startTransaction
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|docCount
init|=
name|merger
operator|.
name|merge
argument_list|()
decl_stmt|;
comment|// merge 'em
if|if
condition|(
name|sReader
operator|!=
literal|null
condition|)
block|{
name|sReader
operator|.
name|close
argument_list|()
expr_stmt|;
name|sReader
operator|=
literal|null
expr_stmt|;
block|}
name|segmentInfos
operator|.
name|setSize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// pop old infos& add new
name|info
operator|=
operator|new
name|SegmentInfo
argument_list|(
name|mergedName
argument_list|,
name|docCount
argument_list|,
name|directory
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|segmentInfos
operator|.
name|addElement
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|rollbackTransaction
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|commitTransaction
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|sReader
operator|!=
literal|null
condition|)
block|{
name|sReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|useCompoundFile
condition|)
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|startTransaction
argument_list|()
expr_stmt|;
try|try
block|{
name|merger
operator|.
name|createCompoundFile
argument_list|(
name|mergedName
operator|+
literal|".cfs"
argument_list|)
expr_stmt|;
name|info
operator|.
name|setUseCompoundFile
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|rollbackTransaction
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|commitTransaction
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Overview of merge policy:
comment|//
comment|// A flush is triggered either by close() or by the number of ram segments
comment|// reaching maxBufferedDocs. After a disk segment is created by the flush,
comment|// further merges may be triggered.
comment|//
comment|// LowerBound and upperBound set the limits on the doc count of a segment
comment|// which may be merged. Initially, lowerBound is set to 0 and upperBound
comment|// to maxBufferedDocs. Starting from the rightmost* segment whose doc count
comment|//> lowerBound and<= upperBound, count the number of consecutive segments
comment|// whose doc count<= upperBound.
comment|//
comment|// Case 1: number of worthy segments< mergeFactor, no merge, done.
comment|// Case 2: number of worthy segments == mergeFactor, merge these segments.
comment|//         If the doc count of the merged segment<= upperBound, done.
comment|//         Otherwise, set lowerBound to upperBound, and multiply upperBound
comment|//         by mergeFactor, go through the process again.
comment|// Case 3: number of worthy segments> mergeFactor (in the case mergeFactor
comment|//         M changes), merge the leftmost* M segments. If the doc count of
comment|//         the merged segment<= upperBound, consider the merged segment for
comment|//         further merges on this same level. Merge the now leftmost* M
comment|//         segments, and so on, until number of worthy segments< mergeFactor.
comment|//         If the doc count of all the merged segments<= upperBound, done.
comment|//         Otherwise, set lowerBound to upperBound, and multiply upperBound
comment|//         by mergeFactor, go through the process again.
comment|// Note that case 2 can be considerd as a special case of case 3.
comment|//
comment|// This merge policy guarantees two invariants if M does not change and
comment|// segment doc count is not reaching maxMergeDocs:
comment|// B for maxBufferedDocs, f(n) defined as ceil(log_M(ceil(n/B)))
comment|//      1: If i (left*) and i+1 (right*) are two consecutive segments of doc
comment|//         counts x and y, then f(x)>= f(y).
comment|//      2: The number of committed segments on the same level (f(n))<= M.
comment|// This is called after pending added and deleted
comment|// documents have been flushed to the Directory but before
comment|// the change is committed (new segments_N file written).
DECL|method|doAfterFlush
name|void
name|doAfterFlush
parameter_list|()
throws|throws
name|IOException
block|{   }
comment|/**    * Used internally to trigger a flush if the number of    * buffered added documents or buffered deleted terms are    * large enough.    */
DECL|method|maybeFlush
specifier|protected
specifier|final
specifier|synchronized
name|void
name|maybeFlush
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
comment|// We only check for flush due to number of buffered
comment|// delete terms, because triggering of a flush due to
comment|// too many added documents is handled by
comment|// DocumentsWriter
if|if
condition|(
name|numBufferedDeleteTerms
operator|>=
name|maxBufferedDeleteTerms
operator|&&
name|docWriter
operator|.
name|setFlushPending
argument_list|()
condition|)
name|flush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Flush all in-memory buffered updates (adds and deletes)    * to the Directory.     *<p>Note: if<code>autoCommit=false</code>, flushed data would still     * not be visible to readers, until {@link #close} is called.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|flush
specifier|public
specifier|final
specifier|synchronized
name|void
name|flush
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|flush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Flush all in-memory buffered udpates (adds and deletes)    * to the Directory.    * @param triggerMerge if true, we may merge segments (if    *  deletes or docs were flushed) if necessary    * @param flushDocStores if false we are allowed to keep    *  doc stores open to share with the next segment    */
DECL|method|flush
specifier|protected
specifier|final
specifier|synchronized
name|void
name|flush
parameter_list|(
name|boolean
name|triggerMerge
parameter_list|,
name|boolean
name|flushDocStores
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
comment|// Make sure no threads are actively adding a document
name|docWriter
operator|.
name|pauseAllThreads
argument_list|()
expr_stmt|;
try|try
block|{
name|SegmentInfo
name|newSegment
init|=
literal|null
decl_stmt|;
specifier|final
name|int
name|numDocs
init|=
name|docWriter
operator|.
name|getNumDocsInRAM
argument_list|()
decl_stmt|;
comment|// Always flush docs if there are any
name|boolean
name|flushDocs
init|=
name|numDocs
operator|>
literal|0
decl_stmt|;
comment|// With autoCommit=true we always must flush the doc
comment|// stores when we flush
name|flushDocStores
operator||=
name|autoCommit
expr_stmt|;
name|String
name|docStoreSegment
init|=
name|docWriter
operator|.
name|getDocStoreSegment
argument_list|()
decl_stmt|;
if|if
condition|(
name|docStoreSegment
operator|==
literal|null
condition|)
name|flushDocStores
operator|=
literal|false
expr_stmt|;
comment|// Always flush deletes if there are any delete terms.
comment|// TODO: when autoCommit=false we don't have to flush
comment|// deletes with every flushed segment; we can save
comment|// CPU/IO by buffering longer& flushing deletes only
comment|// when they are full or writer is being closed.  We
comment|// have to fix the "applyDeletesSelectively" logic to
comment|// apply to more than just the last flushed segment
name|boolean
name|flushDeletes
init|=
name|bufferedDeleteTerms
operator|.
name|size
argument_list|()
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"  flush: flushDocs="
operator|+
name|flushDocs
operator|+
literal|" flushDeletes="
operator|+
name|flushDeletes
operator|+
literal|" flushDocStores="
operator|+
name|flushDocStores
operator|+
literal|" numDocs="
operator|+
name|numDocs
argument_list|)
expr_stmt|;
name|int
name|docStoreOffset
init|=
name|docWriter
operator|.
name|getDocStoreOffset
argument_list|()
decl_stmt|;
name|boolean
name|docStoreIsCompoundFile
init|=
literal|false
decl_stmt|;
comment|// Check if the doc stores must be separately flushed
comment|// because other segments, besides the one we are about
comment|// to flush, reference it
if|if
condition|(
name|flushDocStores
operator|&&
operator|(
operator|!
name|flushDocs
operator|||
operator|!
name|docWriter
operator|.
name|getSegment
argument_list|()
operator|.
name|equals
argument_list|(
name|docWriter
operator|.
name|getDocStoreSegment
argument_list|()
argument_list|)
operator|)
condition|)
block|{
comment|// We must separately flush the doc store
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"  flush shared docStore segment "
operator|+
name|docStoreSegment
argument_list|)
expr_stmt|;
name|flushDocStores
argument_list|()
expr_stmt|;
name|flushDocStores
operator|=
literal|false
expr_stmt|;
name|docStoreIsCompoundFile
operator|=
name|useCompoundFile
expr_stmt|;
block|}
name|String
name|segment
init|=
name|docWriter
operator|.
name|getSegment
argument_list|()
decl_stmt|;
if|if
condition|(
name|flushDocs
operator|||
name|flushDeletes
condition|)
block|{
name|SegmentInfos
name|rollback
init|=
literal|null
decl_stmt|;
name|HashMap
name|saveBufferedDeleteTerms
init|=
literal|null
decl_stmt|;
name|int
name|saveNumBufferedDeleteTerms
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flushDeletes
condition|)
name|rollback
operator|=
operator|(
name|SegmentInfos
operator|)
name|segmentInfos
operator|.
name|clone
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|flushDocs
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|docStoreOffset
operator|&&
name|flushDocStores
condition|)
block|{
comment|// This means we are flushing private doc stores
comment|// with this segment, so it will not be shared
comment|// with other segments
assert|assert
name|docStoreSegment
operator|!=
literal|null
assert|;
assert|assert
name|docStoreSegment
operator|.
name|equals
argument_list|(
name|segment
argument_list|)
assert|;
name|docStoreOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|docStoreIsCompoundFile
operator|=
literal|false
expr_stmt|;
name|docStoreSegment
operator|=
literal|null
expr_stmt|;
block|}
name|int
name|flushedDocCount
init|=
name|docWriter
operator|.
name|flush
argument_list|(
name|flushDocStores
argument_list|)
decl_stmt|;
name|newSegment
operator|=
operator|new
name|SegmentInfo
argument_list|(
name|segment
argument_list|,
name|flushedDocCount
argument_list|,
name|directory
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
name|docStoreOffset
argument_list|,
name|docStoreSegment
argument_list|,
name|docStoreIsCompoundFile
argument_list|)
expr_stmt|;
name|segmentInfos
operator|.
name|addElement
argument_list|(
name|newSegment
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flushDeletes
condition|)
block|{
comment|// we should be able to change this so we can
comment|// buffer deletes longer and then flush them to
comment|// multiple flushed segments, when
comment|// autoCommit=false
name|saveBufferedDeleteTerms
operator|=
name|bufferedDeleteTerms
expr_stmt|;
name|saveNumBufferedDeleteTerms
operator|=
name|numBufferedDeleteTerms
expr_stmt|;
name|applyDeletes
argument_list|(
name|flushDocs
argument_list|)
expr_stmt|;
name|doAfterFlush
argument_list|()
expr_stmt|;
block|}
name|checkpoint
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|flushDeletes
condition|)
block|{
comment|// Fully replace the segmentInfos since flushed
comment|// deletes could have changed any of the
comment|// SegmentInfo instances:
name|segmentInfos
operator|.
name|clear
argument_list|()
expr_stmt|;
name|segmentInfos
operator|.
name|addAll
argument_list|(
name|rollback
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveBufferedDeleteTerms
operator|!=
literal|null
condition|)
block|{
name|numBufferedDeleteTerms
operator|=
name|saveNumBufferedDeleteTerms
expr_stmt|;
name|bufferedDeleteTerms
operator|=
name|saveBufferedDeleteTerms
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Remove segment we added, if any:
if|if
condition|(
name|newSegment
operator|!=
literal|null
operator|&&
name|segmentInfos
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|segmentInfos
operator|.
name|info
argument_list|(
name|segmentInfos
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
name|newSegment
condition|)
name|segmentInfos
operator|.
name|remove
argument_list|(
name|segmentInfos
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flushDocs
condition|)
name|docWriter
operator|.
name|abort
argument_list|()
expr_stmt|;
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|refresh
argument_list|()
expr_stmt|;
block|}
block|}
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
name|autoCommit
argument_list|)
expr_stmt|;
if|if
condition|(
name|flushDocs
operator|&&
name|useCompoundFile
condition|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|docWriter
operator|.
name|createCompoundFile
argument_list|(
name|segment
argument_list|)
expr_stmt|;
name|newSegment
operator|.
name|setUseCompoundFile
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|checkpoint
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|newSegment
operator|.
name|setUseCompoundFile
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|refresh
argument_list|()
expr_stmt|;
block|}
block|}
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
name|autoCommit
argument_list|)
expr_stmt|;
block|}
comment|/* new merge policy         if (0 == docWriter.getMaxBufferedDocs())           maybeMergeSegments(mergeFactor * numDocs / 2);         else           maybeMergeSegments(docWriter.getMaxBufferedDocs());         */
if|if
condition|(
name|triggerMerge
condition|)
name|maybeMergeSegments
argument_list|(
name|docWriter
operator|.
name|getMaxBufferedDocs
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|docWriter
operator|.
name|clearFlushPending
argument_list|()
expr_stmt|;
name|docWriter
operator|.
name|resumeAllThreads
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Expert:  Return the total size of all index files currently cached in memory.    * Useful for size management with flushRamDocs()    */
DECL|method|ramSizeInBytes
specifier|public
specifier|final
name|long
name|ramSizeInBytes
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|docWriter
operator|.
name|getRAMUsed
argument_list|()
return|;
block|}
comment|/** Expert:  Return the number of documents whose segments are currently cached in memory.    * Useful when calling flush()    */
DECL|method|numRamDocs
specifier|public
specifier|final
specifier|synchronized
name|int
name|numRamDocs
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|docWriter
operator|.
name|getNumDocsInRAM
argument_list|()
return|;
block|}
comment|/** Incremental segment merger.  */
DECL|method|maybeMergeSegments
specifier|private
specifier|final
name|void
name|maybeMergeSegments
parameter_list|(
name|int
name|startUpperBound
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|long
name|lowerBound
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|upperBound
init|=
name|startUpperBound
decl_stmt|;
comment|/* new merge policy     if (upperBound == 0) upperBound = 10;     */
while|while
condition|(
name|upperBound
operator|<
name|maxMergeDocs
condition|)
block|{
name|int
name|minSegment
init|=
name|segmentInfos
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|maxSegment
init|=
operator|-
literal|1
decl_stmt|;
comment|// find merge-worthy segments
while|while
condition|(
operator|--
name|minSegment
operator|>=
literal|0
condition|)
block|{
name|SegmentInfo
name|si
init|=
name|segmentInfos
operator|.
name|info
argument_list|(
name|minSegment
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxSegment
operator|==
operator|-
literal|1
operator|&&
name|si
operator|.
name|docCount
operator|>
name|lowerBound
operator|&&
name|si
operator|.
name|docCount
operator|<=
name|upperBound
condition|)
block|{
comment|// start from the rightmost* segment whose doc count is in bounds
name|maxSegment
operator|=
name|minSegment
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|si
operator|.
name|docCount
operator|>
name|upperBound
condition|)
block|{
comment|// until the segment whose doc count exceeds upperBound
break|break;
block|}
block|}
name|minSegment
operator|++
expr_stmt|;
name|maxSegment
operator|++
expr_stmt|;
name|int
name|numSegments
init|=
name|maxSegment
operator|-
name|minSegment
decl_stmt|;
if|if
condition|(
name|numSegments
operator|<
name|mergeFactor
condition|)
block|{
break|break;
block|}
else|else
block|{
name|boolean
name|exceedsUpperLimit
init|=
literal|false
decl_stmt|;
comment|// number of merge-worthy segments may exceed mergeFactor when
comment|// mergeFactor and/or maxBufferedDocs change(s)
while|while
condition|(
name|numSegments
operator|>=
name|mergeFactor
condition|)
block|{
comment|// merge the leftmost* mergeFactor segments
name|int
name|docCount
init|=
name|mergeSegments
argument_list|(
name|minSegment
argument_list|,
name|minSegment
operator|+
name|mergeFactor
argument_list|)
decl_stmt|;
name|numSegments
operator|-=
name|mergeFactor
expr_stmt|;
if|if
condition|(
name|docCount
operator|>
name|upperBound
condition|)
block|{
comment|// continue to merge the rest of the worthy segments on this level
name|minSegment
operator|++
expr_stmt|;
name|exceedsUpperLimit
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// if the merged segment does not exceed upperBound, consider
comment|// this segment for further merges on this same level
name|numSegments
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|exceedsUpperLimit
condition|)
block|{
comment|// if none of the merged segments exceed upperBound, done
break|break;
block|}
block|}
name|lowerBound
operator|=
name|upperBound
expr_stmt|;
name|upperBound
operator|*=
name|mergeFactor
expr_stmt|;
block|}
block|}
comment|/**    * Merges the named range of segments, replacing them in the stack with a    * single segment.    */
DECL|method|mergeSegments
specifier|private
specifier|final
name|int
name|mergeSegments
parameter_list|(
name|int
name|minSegment
parameter_list|,
name|int
name|end
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
specifier|final
name|String
name|mergedName
init|=
name|newSegmentName
argument_list|()
decl_stmt|;
name|SegmentMerger
name|merger
init|=
literal|null
decl_stmt|;
name|SegmentInfo
name|newSegment
init|=
literal|null
decl_stmt|;
name|int
name|mergedDocCount
init|=
literal|0
decl_stmt|;
comment|// This is try/finally to make sure merger's readers are closed:
try|try
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|print
argument_list|(
literal|"merging segments"
argument_list|)
expr_stmt|;
comment|// Check whether this merge will allow us to skip
comment|// merging the doc stores (stored field& vectors).
comment|// This is a very substantial optimization (saves tons
comment|// of IO) that can only be applied with
comment|// autoCommit=false.
name|Directory
name|lastDir
init|=
name|directory
decl_stmt|;
name|String
name|lastDocStoreSegment
init|=
literal|null
decl_stmt|;
name|boolean
name|mergeDocStores
init|=
literal|false
decl_stmt|;
name|boolean
name|doFlushDocStore
init|=
literal|false
decl_stmt|;
name|int
name|next
init|=
operator|-
literal|1
decl_stmt|;
comment|// Test each segment to be merged
for|for
control|(
name|int
name|i
init|=
name|minSegment
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|SegmentInfo
name|si
init|=
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// If it has deletions we must merge the doc stores
if|if
condition|(
name|si
operator|.
name|hasDeletions
argument_list|()
condition|)
name|mergeDocStores
operator|=
literal|true
expr_stmt|;
comment|// If it has its own (private) doc stores we must
comment|// merge the doc stores
if|if
condition|(
operator|-
literal|1
operator|==
name|si
operator|.
name|getDocStoreOffset
argument_list|()
condition|)
name|mergeDocStores
operator|=
literal|true
expr_stmt|;
comment|// If it has a different doc store segment than
comment|// previous segments, we must merge the doc stores
name|String
name|docStoreSegment
init|=
name|si
operator|.
name|getDocStoreSegment
argument_list|()
decl_stmt|;
if|if
condition|(
name|docStoreSegment
operator|==
literal|null
condition|)
name|mergeDocStores
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|lastDocStoreSegment
operator|==
literal|null
condition|)
name|lastDocStoreSegment
operator|=
name|docStoreSegment
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|lastDocStoreSegment
operator|.
name|equals
argument_list|(
name|docStoreSegment
argument_list|)
condition|)
name|mergeDocStores
operator|=
literal|true
expr_stmt|;
comment|// Segments' docScoreOffsets must be in-order,
comment|// contiguous.  For the default merge policy now
comment|// this will always be the case but for an arbitrary
comment|// merge policy this may not be the case
if|if
condition|(
operator|-
literal|1
operator|==
name|next
condition|)
name|next
operator|=
name|si
operator|.
name|getDocStoreOffset
argument_list|()
operator|+
name|si
operator|.
name|docCount
expr_stmt|;
elseif|else
if|if
condition|(
name|next
operator|!=
name|si
operator|.
name|getDocStoreOffset
argument_list|()
condition|)
name|mergeDocStores
operator|=
literal|true
expr_stmt|;
else|else
name|next
operator|=
name|si
operator|.
name|getDocStoreOffset
argument_list|()
operator|+
name|si
operator|.
name|docCount
expr_stmt|;
comment|// If the segment comes from a different directory
comment|// we must merge
if|if
condition|(
name|lastDir
operator|!=
name|si
operator|.
name|dir
condition|)
name|mergeDocStores
operator|=
literal|true
expr_stmt|;
comment|// If the segment is referencing the current "live"
comment|// doc store outputs then we must merge
if|if
condition|(
name|si
operator|.
name|getDocStoreOffset
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|si
operator|.
name|getDocStoreSegment
argument_list|()
operator|.
name|equals
argument_list|(
name|docWriter
operator|.
name|getDocStoreSegment
argument_list|()
argument_list|)
condition|)
name|doFlushDocStore
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|int
name|docStoreOffset
decl_stmt|;
specifier|final
name|String
name|docStoreSegment
decl_stmt|;
specifier|final
name|boolean
name|docStoreIsCompoundFile
decl_stmt|;
if|if
condition|(
name|mergeDocStores
condition|)
block|{
name|docStoreOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|docStoreSegment
operator|=
literal|null
expr_stmt|;
name|docStoreIsCompoundFile
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|SegmentInfo
name|si
init|=
name|segmentInfos
operator|.
name|info
argument_list|(
name|minSegment
argument_list|)
decl_stmt|;
name|docStoreOffset
operator|=
name|si
operator|.
name|getDocStoreOffset
argument_list|()
expr_stmt|;
name|docStoreSegment
operator|=
name|si
operator|.
name|getDocStoreSegment
argument_list|()
expr_stmt|;
name|docStoreIsCompoundFile
operator|=
name|si
operator|.
name|getDocStoreIsCompoundFile
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mergeDocStores
operator|&&
name|doFlushDocStore
condition|)
comment|// SegmentMerger intends to merge the doc stores
comment|// (stored fields, vectors), and at least one of the
comment|// segments to be merged refers to the currently
comment|// live doc stores.
name|flushDocStores
argument_list|()
expr_stmt|;
name|merger
operator|=
operator|new
name|SegmentMerger
argument_list|(
name|this
argument_list|,
name|mergedName
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|minSegment
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|SegmentInfo
name|si
init|=
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|print
argument_list|(
literal|" "
operator|+
name|si
operator|.
name|name
operator|+
literal|" ("
operator|+
name|si
operator|.
name|docCount
operator|+
literal|" docs)"
argument_list|)
expr_stmt|;
name|IndexReader
name|reader
init|=
name|SegmentReader
operator|.
name|get
argument_list|(
name|si
argument_list|,
name|MERGE_READ_BUFFER_SIZE
argument_list|,
name|mergeDocStores
argument_list|)
decl_stmt|;
comment|// no need to set deleter (yet)
name|merger
operator|.
name|add
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
name|SegmentInfos
name|rollback
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
comment|// This is try/finally to rollback our internal state
comment|// if we hit exception when doing the merge:
try|try
block|{
name|mergedDocCount
operator|=
name|merger
operator|.
name|merge
argument_list|(
name|mergeDocStores
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|infoStream
operator|.
name|println
argument_list|(
literal|" into "
operator|+
name|mergedName
operator|+
literal|" ("
operator|+
name|mergedDocCount
operator|+
literal|" docs)"
argument_list|)
expr_stmt|;
block|}
name|newSegment
operator|=
operator|new
name|SegmentInfo
argument_list|(
name|mergedName
argument_list|,
name|mergedDocCount
argument_list|,
name|directory
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
name|docStoreOffset
argument_list|,
name|docStoreSegment
argument_list|,
name|docStoreIsCompoundFile
argument_list|)
expr_stmt|;
name|rollback
operator|=
operator|(
name|SegmentInfos
operator|)
name|segmentInfos
operator|.
name|clone
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|end
operator|-
literal|1
init|;
name|i
operator|>
name|minSegment
condition|;
name|i
operator|--
control|)
comment|// remove old infos& add new
name|segmentInfos
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|segmentInfos
operator|.
name|set
argument_list|(
name|minSegment
argument_list|,
name|newSegment
argument_list|)
expr_stmt|;
name|checkpoint
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|rollback
operator|!=
literal|null
condition|)
block|{
comment|// Rollback the individual SegmentInfo
comment|// instances, but keep original SegmentInfos
comment|// instance (so we don't try to write again the
comment|// same segments_N file -- write once):
name|segmentInfos
operator|.
name|clear
argument_list|()
expr_stmt|;
name|segmentInfos
operator|.
name|addAll
argument_list|(
name|rollback
argument_list|)
expr_stmt|;
block|}
comment|// Delete any partially created and now unreferenced files:
name|deleter
operator|.
name|refresh
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
comment|// close readers before we attempt to delete now-obsolete segments
if|if
condition|(
name|merger
operator|!=
literal|null
condition|)
block|{
name|merger
operator|.
name|closeReaders
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Give deleter a chance to remove files now.
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
name|autoCommit
argument_list|)
expr_stmt|;
if|if
condition|(
name|useCompoundFile
condition|)
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|merger
operator|.
name|createCompoundFile
argument_list|(
name|mergedName
operator|+
literal|".cfs"
argument_list|)
expr_stmt|;
name|newSegment
operator|.
name|setUseCompoundFile
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|checkpoint
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// Must rollback:
name|newSegment
operator|.
name|setUseCompoundFile
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|refresh
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Give deleter a chance to remove files now.
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
name|autoCommit
argument_list|)
expr_stmt|;
block|}
return|return
name|mergedDocCount
return|;
block|}
comment|// Called during flush to apply any buffered deletes.  If
comment|// flushedNewSegment is true then a new segment was just
comment|// created and flushed from the ram segments, so we will
comment|// selectively apply the deletes to that new segment.
DECL|method|applyDeletes
specifier|private
specifier|final
name|void
name|applyDeletes
parameter_list|(
name|boolean
name|flushedNewSegment
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
if|if
condition|(
name|bufferedDeleteTerms
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"flush "
operator|+
name|numBufferedDeleteTerms
operator|+
literal|" buffered deleted terms on "
operator|+
name|segmentInfos
operator|.
name|size
argument_list|()
operator|+
literal|" segments."
argument_list|)
expr_stmt|;
if|if
condition|(
name|flushedNewSegment
condition|)
block|{
name|IndexReader
name|reader
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Open readers w/o opening the stored fields /
comment|// vectors because these files may still be held
comment|// open for writing by docWriter
name|reader
operator|=
name|SegmentReader
operator|.
name|get
argument_list|(
name|segmentInfos
operator|.
name|info
argument_list|(
name|segmentInfos
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Apply delete terms to the segment just flushed from ram
comment|// apply appropriately so that a delete term is only applied to
comment|// the documents buffered before it, not those buffered after it.
name|applyDeletesSelectively
argument_list|(
name|bufferedDeleteTerms
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|reader
operator|.
name|doCommit
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|reader
operator|.
name|doClose
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
name|int
name|infosEnd
init|=
name|segmentInfos
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|flushedNewSegment
condition|)
block|{
name|infosEnd
operator|--
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|infosEnd
condition|;
name|i
operator|++
control|)
block|{
name|IndexReader
name|reader
init|=
literal|null
decl_stmt|;
try|try
block|{
name|reader
operator|=
name|SegmentReader
operator|.
name|get
argument_list|(
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Apply delete terms to disk segments
comment|// except the one just flushed from ram.
name|applyDeletes
argument_list|(
name|bufferedDeleteTerms
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|reader
operator|.
name|doCommit
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|reader
operator|.
name|doClose
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Clean up bufferedDeleteTerms.
comment|// Rollbacks of buffered deletes are based on restoring the old
comment|// map, so don't modify this one. Rare enough that the gc
comment|// overhead is almost certainly lower than the alternate, which
comment|// would be clone to support rollback.
name|bufferedDeleteTerms
operator|=
operator|new
name|HashMap
argument_list|()
expr_stmt|;
name|numBufferedDeleteTerms
operator|=
literal|0
expr_stmt|;
block|}
block|}
DECL|method|checkNonDecreasingLevels
specifier|private
specifier|final
name|boolean
name|checkNonDecreasingLevels
parameter_list|(
name|int
name|start
parameter_list|)
block|{
name|int
name|lowerBound
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|upperBound
init|=
name|docWriter
operator|.
name|getMaxBufferedDocs
argument_list|()
decl_stmt|;
comment|/* new merge policy     if (upperBound == 0)       upperBound = 10;     */
for|for
control|(
name|int
name|i
init|=
name|segmentInfos
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
name|start
condition|;
name|i
operator|--
control|)
block|{
name|int
name|docCount
init|=
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
operator|.
name|docCount
decl_stmt|;
if|if
condition|(
name|docCount
operator|<=
name|lowerBound
condition|)
block|{
return|return
literal|false
return|;
block|}
while|while
condition|(
name|docCount
operator|>
name|upperBound
condition|)
block|{
name|lowerBound
operator|=
name|upperBound
expr_stmt|;
name|upperBound
operator|*=
name|mergeFactor
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// For test purposes.
DECL|method|getBufferedDeleteTermsSize
specifier|final
specifier|synchronized
name|int
name|getBufferedDeleteTermsSize
parameter_list|()
block|{
return|return
name|bufferedDeleteTerms
operator|.
name|size
argument_list|()
return|;
block|}
comment|// For test purposes.
DECL|method|getNumBufferedDeleteTerms
specifier|final
specifier|synchronized
name|int
name|getNumBufferedDeleteTerms
parameter_list|()
block|{
return|return
name|numBufferedDeleteTerms
return|;
block|}
comment|// Number of ram segments a delete term applies to.
DECL|class|Num
specifier|private
specifier|static
class|class
name|Num
block|{
DECL|field|num
specifier|private
name|int
name|num
decl_stmt|;
DECL|method|Num
name|Num
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|this
operator|.
name|num
operator|=
name|num
expr_stmt|;
block|}
DECL|method|getNum
name|int
name|getNum
parameter_list|()
block|{
return|return
name|num
return|;
block|}
DECL|method|setNum
name|void
name|setNum
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|this
operator|.
name|num
operator|=
name|num
expr_stmt|;
block|}
block|}
comment|// Buffer a term in bufferedDeleteTerms, which records the
comment|// current number of documents buffered in ram so that the
comment|// delete term will be applied to those ram segments as
comment|// well as the disk segments.
DECL|method|bufferDeleteTerm
specifier|private
name|void
name|bufferDeleteTerm
parameter_list|(
name|Term
name|term
parameter_list|)
block|{
name|Num
name|num
init|=
operator|(
name|Num
operator|)
name|bufferedDeleteTerms
operator|.
name|get
argument_list|(
name|term
argument_list|)
decl_stmt|;
name|int
name|numDoc
init|=
name|docWriter
operator|.
name|getNumDocsInRAM
argument_list|()
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|null
condition|)
block|{
name|bufferedDeleteTerms
operator|.
name|put
argument_list|(
name|term
argument_list|,
operator|new
name|Num
argument_list|(
name|numDoc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num
operator|.
name|setNum
argument_list|(
name|numDoc
argument_list|)
expr_stmt|;
block|}
name|numBufferedDeleteTerms
operator|++
expr_stmt|;
block|}
comment|// Apply buffered delete terms to the segment just flushed from ram
comment|// apply appropriately so that a delete term is only applied to
comment|// the documents buffered before it, not those buffered after it.
DECL|method|applyDeletesSelectively
specifier|private
specifier|final
name|void
name|applyDeletesSelectively
parameter_list|(
name|HashMap
name|deleteTerms
parameter_list|,
name|IndexReader
name|reader
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|Iterator
name|iter
init|=
name|deleteTerms
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
name|entry
init|=
operator|(
name|Entry
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|Term
name|term
init|=
operator|(
name|Term
operator|)
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|TermDocs
name|docs
init|=
name|reader
operator|.
name|termDocs
argument_list|(
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
name|docs
operator|!=
literal|null
condition|)
block|{
name|int
name|num
init|=
operator|(
operator|(
name|Num
operator|)
name|entry
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|getNum
argument_list|()
decl_stmt|;
try|try
block|{
while|while
condition|(
name|docs
operator|.
name|next
argument_list|()
condition|)
block|{
name|int
name|doc
init|=
name|docs
operator|.
name|doc
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
operator|>=
name|num
condition|)
block|{
break|break;
block|}
name|reader
operator|.
name|deleteDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|docs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Apply buffered delete terms to this reader.
DECL|method|applyDeletes
specifier|private
specifier|final
name|void
name|applyDeletes
parameter_list|(
name|HashMap
name|deleteTerms
parameter_list|,
name|IndexReader
name|reader
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|Iterator
name|iter
init|=
name|deleteTerms
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
name|entry
init|=
operator|(
name|Entry
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|reader
operator|.
name|deleteDocuments
argument_list|(
operator|(
name|Term
operator|)
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
