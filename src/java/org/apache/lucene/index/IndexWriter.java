begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocumentsWriter
operator|.
name|IndexingChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Lock
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|LockObtainFailedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|BufferedIndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Constants
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ThreadInterruptedException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_comment
comment|/**   An<code>IndexWriter</code> creates and maintains an index.<p>The<code>create</code> argument to the {@link   #IndexWriter(Directory, Analyzer, boolean, MaxFieldLength) constructor} determines    whether a new index is created, or whether an existing index is   opened.  Note that you can open an index with<code>create=true</code>   even while readers are using the index.  The old readers will    continue to search the "point in time" snapshot they had opened,    and won't see the newly created index until they re-open.  There are   also {@link #IndexWriter(Directory, Analyzer, MaxFieldLength) constructors}   with no<code>create</code> argument which will create a new index   if there is not already an index at the provided path and otherwise    open the existing index.</p><p>In either case, documents are added with {@link #addDocument(Document)   addDocument} and removed with {@link #deleteDocuments(Term)} or {@link   #deleteDocuments(Query)}. A document can be updated with {@link   #updateDocument(Term, Document) updateDocument} (which just deletes   and then adds the entire document). When finished adding, deleting    and updating documents, {@link #close() close} should be called.</p><a name="flush"></a><p>These changes are buffered in memory and periodically   flushed to the {@link Directory} (during the above method   calls).  A flush is triggered when there are enough   buffered deletes (see {@link #setMaxBufferedDeleteTerms})   or enough added documents since the last flush, whichever   is sooner.  For the added documents, flushing is triggered   either by RAM usage of the documents (see {@link   #setRAMBufferSizeMB}) or the number of added documents.   The default is to flush when RAM usage hits 16 MB.  For   best indexing speed you should flush by RAM usage with a   large RAM buffer.  Note that flushing just moves the   internal buffered state in IndexWriter into the index, but   these changes are not visible to IndexReader until either   {@link #commit()} or {@link #close} is called.  A flush may   also trigger one or more segment merges which by default   run with a background thread so as not to block the   addDocument calls (see<a href="#mergePolicy">below</a>   for changing the {@link MergeScheduler}).</p><p>If an index will not have more documents added for a while and optimal search   performance is desired, then either the full {@link #optimize() optimize}   method or partial {@link #optimize(int)} method should be   called before the index is closed.</p><p>Opening an<code>IndexWriter</code> creates a lock file for the directory in use. Trying to open   another<code>IndexWriter</code> on the same directory will lead to a   {@link LockObtainFailedException}. The {@link LockObtainFailedException}   is also thrown if an IndexReader on the same directory is used to delete documents   from the index.</p><a name="deletionPolicy"></a><p>Expert:<code>IndexWriter</code> allows an optional   {@link IndexDeletionPolicy} implementation to be   specified.  You can use this to control when prior commits   are deleted from the index.  The default policy is {@link   KeepOnlyLastCommitDeletionPolicy} which removes all prior   commits as soon as a new commit is done (this matches   behavior before 2.2).  Creating your own policy can allow   you to explicitly keep previous "point in time" commits   alive in the index for some time, to allow readers to   refresh to the new commit without having the old commit   deleted out from under them.  This is necessary on   filesystems like NFS that do not support "delete on last   close" semantics, which Lucene's "point in time" search   normally relies on.</p><a name="mergePolicy"></a><p>Expert:<code>IndexWriter</code> allows you to separately change   the {@link MergePolicy} and the {@link MergeScheduler}.   The {@link MergePolicy} is invoked whenever there are   changes to the segments in the index.  Its role is to   select which merges to do, if any, and return a {@link   MergePolicy.MergeSpecification} describing the merges.  It   also selects merges to do for optimize().  (The default is   {@link LogByteSizeMergePolicy}.  Then, the {@link   MergeScheduler} is invoked with the requested merges and   it decides when and how to run the merges.  The default is   {@link ConcurrentMergeScheduler}.</p><a name="OOME"></a><p><b>NOTE</b>: if you hit an   OutOfMemoryError then IndexWriter will quietly record this   fact and block all future segment commits.  This is a   defensive measure in case any internal state (buffered   documents and deletions) were corrupted.  Any subsequent   calls to {@link #commit()} will throw an   IllegalStateException.  The only course of action is to   call {@link #close()}, which internally will call {@link   #rollback()}, to undo any changes to the index since the   last commit.  You can also just call {@link #rollback()}   directly.</p><a name="thread-safety"></a><p><b>NOTE</b>: {@link<code>IndexWriter</code>} instances are completely thread   safe, meaning multiple threads can call any of its   methods, concurrently.  If your application requires   external synchronization, you should<b>not</b>   synchronize on the<code>IndexWriter</code> instance as   this may cause deadlock; use your own (non-Lucene) objects   instead.</p><p><b>NOTE</b>: If you call<code>Thread.interrupt()</code> on a thread that's within   IndexWriter, IndexWriter will try to catch this (eg, if   it's in a wait() or Thread.sleep()), and will then throw   the unchecked exception {@link ThreadInterruptedException}   and<b>clear</b> the interrupt status on the thread.</p> */
end_comment
begin_comment
comment|/*  * Clarification: Check Points (and commits)  * IndexWriter writes new index files to the directory without writing a new segments_N  * file which references these new files. It also means that the state of   * the in memory SegmentInfos object is different than the most recent  * segments_N file written to the directory.  *   * Each time the SegmentInfos is changed, and matches the (possibly   * modified) directory files, we have a new "check point".   * If the modified/new SegmentInfos is written to disk - as a new   * (generation of) segments_N file - this check point is also an   * IndexCommit.  *   * A new checkpoint always replaces the previous checkpoint and   * becomes the new "front" of the index. This allows the IndexFileDeleter   * to delete files that are referenced only by stale checkpoints.  * (files that were created since the last commit, but are no longer  * referenced by the "front" of the index). For this, IndexFileDeleter   * keeps track of the last non commit checkpoint.  */
end_comment
begin_class
DECL|class|IndexWriter
specifier|public
class|class
name|IndexWriter
implements|implements
name|Closeable
block|{
comment|/**    * Default value for the write lock timeout (1,000).    * @see #setDefaultWriteLockTimeout    */
DECL|field|WRITE_LOCK_TIMEOUT
specifier|public
specifier|static
name|long
name|WRITE_LOCK_TIMEOUT
init|=
literal|1000
decl_stmt|;
DECL|field|writeLockTimeout
specifier|private
name|long
name|writeLockTimeout
init|=
name|WRITE_LOCK_TIMEOUT
decl_stmt|;
comment|/**    * Name of the write lock in the index.    */
DECL|field|WRITE_LOCK_NAME
specifier|public
specifier|static
specifier|final
name|String
name|WRITE_LOCK_NAME
init|=
literal|"write.lock"
decl_stmt|;
comment|/**    * Value to denote a flush trigger is disabled    */
DECL|field|DISABLE_AUTO_FLUSH
specifier|public
specifier|final
specifier|static
name|int
name|DISABLE_AUTO_FLUSH
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * Disabled by default (because IndexWriter flushes by RAM usage    * by default). Change using {@link #setMaxBufferedDocs(int)}.    */
DECL|field|DEFAULT_MAX_BUFFERED_DOCS
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_BUFFERED_DOCS
init|=
name|DISABLE_AUTO_FLUSH
decl_stmt|;
comment|/**    * Default value is 16 MB (which means flush when buffered    * docs consume 16 MB RAM).  Change using {@link #setRAMBufferSizeMB}.    */
DECL|field|DEFAULT_RAM_BUFFER_SIZE_MB
specifier|public
specifier|final
specifier|static
name|double
name|DEFAULT_RAM_BUFFER_SIZE_MB
init|=
literal|16.0
decl_stmt|;
comment|/**    * Disabled by default (because IndexWriter flushes by RAM usage    * by default). Change using {@link #setMaxBufferedDeleteTerms(int)}.    */
DECL|field|DEFAULT_MAX_BUFFERED_DELETE_TERMS
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_BUFFERED_DELETE_TERMS
init|=
name|DISABLE_AUTO_FLUSH
decl_stmt|;
comment|/**    * Default value is 10,000. Change using {@link #setMaxFieldLength(int)}.    */
DECL|field|DEFAULT_MAX_FIELD_LENGTH
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_FIELD_LENGTH
init|=
literal|10000
decl_stmt|;
comment|/**    * Default value is 128. Change using {@link #setTermIndexInterval(int)}.    */
DECL|field|DEFAULT_TERM_INDEX_INTERVAL
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_TERM_INDEX_INTERVAL
init|=
literal|128
decl_stmt|;
comment|/**    * Absolute hard maximum length for a term.  If a term    * arrives from the analyzer longer than this length, it    * is skipped and a message is printed to infoStream, if    * set (see {@link #setInfoStream}).    */
DECL|field|MAX_TERM_LENGTH
specifier|public
specifier|final
specifier|static
name|int
name|MAX_TERM_LENGTH
init|=
name|DocumentsWriter
operator|.
name|MAX_TERM_LENGTH
decl_stmt|;
comment|// The normal read buffer size defaults to 1024, but
comment|// increasing this during merging seems to yield
comment|// performance gains.  However we don't want to increase
comment|// it too much because there are quite a few
comment|// BufferedIndexInputs created during merging.  See
comment|// LUCENE-888 for details.
DECL|field|MERGE_READ_BUFFER_SIZE
specifier|private
specifier|final
specifier|static
name|int
name|MERGE_READ_BUFFER_SIZE
init|=
literal|4096
decl_stmt|;
comment|// Used for printing messages
DECL|field|MESSAGE_ID_LOCK
specifier|private
specifier|static
name|Object
name|MESSAGE_ID_LOCK
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|MESSAGE_ID
specifier|private
specifier|static
name|int
name|MESSAGE_ID
init|=
literal|0
decl_stmt|;
DECL|field|messageID
specifier|private
name|int
name|messageID
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|hitOOM
specifier|volatile
specifier|private
name|boolean
name|hitOOM
decl_stmt|;
DECL|field|directory
specifier|private
name|Directory
name|directory
decl_stmt|;
comment|// where this index resides
DECL|field|analyzer
specifier|private
name|Analyzer
name|analyzer
decl_stmt|;
comment|// how to analyze text
DECL|field|similarity
specifier|private
name|Similarity
name|similarity
init|=
name|Similarity
operator|.
name|getDefault
argument_list|()
decl_stmt|;
comment|// how to normalize
DECL|field|changeCount
specifier|private
specifier|volatile
name|long
name|changeCount
decl_stmt|;
comment|// increments every time a change is completed
DECL|field|lastCommitChangeCount
specifier|private
name|long
name|lastCommitChangeCount
decl_stmt|;
comment|// last changeCount that was committed
DECL|field|rollbackSegmentInfos
specifier|private
name|SegmentInfos
name|rollbackSegmentInfos
decl_stmt|;
comment|// segmentInfos we will fallback to if the commit fails
DECL|field|rollbackSegments
specifier|private
name|HashMap
argument_list|<
name|SegmentInfo
argument_list|,
name|Integer
argument_list|>
name|rollbackSegments
decl_stmt|;
DECL|field|pendingCommit
specifier|volatile
name|SegmentInfos
name|pendingCommit
decl_stmt|;
comment|// set when a commit is pending (after prepareCommit()& before commit())
DECL|field|pendingCommitChangeCount
specifier|volatile
name|long
name|pendingCommitChangeCount
decl_stmt|;
DECL|field|localRollbackSegmentInfos
specifier|private
name|SegmentInfos
name|localRollbackSegmentInfos
decl_stmt|;
comment|// segmentInfos we will fallback to if the commit fails
DECL|field|localFlushedDocCount
specifier|private
name|int
name|localFlushedDocCount
decl_stmt|;
comment|// saved docWriter.getFlushedDocCount during local transaction
DECL|field|segmentInfos
specifier|private
name|SegmentInfos
name|segmentInfos
init|=
operator|new
name|SegmentInfos
argument_list|()
decl_stmt|;
comment|// the segments
DECL|field|docWriter
specifier|private
name|DocumentsWriter
name|docWriter
decl_stmt|;
DECL|field|deleter
specifier|private
name|IndexFileDeleter
name|deleter
decl_stmt|;
DECL|field|segmentsToOptimize
specifier|private
name|Set
argument_list|<
name|SegmentInfo
argument_list|>
name|segmentsToOptimize
init|=
operator|new
name|HashSet
argument_list|<
name|SegmentInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|// used by optimize to note those needing optimization
DECL|field|writeLock
specifier|private
name|Lock
name|writeLock
decl_stmt|;
DECL|field|termIndexInterval
specifier|private
name|int
name|termIndexInterval
init|=
name|DEFAULT_TERM_INDEX_INTERVAL
decl_stmt|;
DECL|field|closed
specifier|private
name|boolean
name|closed
decl_stmt|;
DECL|field|closing
specifier|private
name|boolean
name|closing
decl_stmt|;
comment|// Holds all SegmentInfo instances currently involved in
comment|// merges
DECL|field|mergingSegments
specifier|private
name|HashSet
argument_list|<
name|SegmentInfo
argument_list|>
name|mergingSegments
init|=
operator|new
name|HashSet
argument_list|<
name|SegmentInfo
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|mergePolicy
specifier|private
name|MergePolicy
name|mergePolicy
init|=
operator|new
name|LogByteSizeMergePolicy
argument_list|(
name|this
argument_list|)
decl_stmt|;
DECL|field|mergeScheduler
specifier|private
name|MergeScheduler
name|mergeScheduler
init|=
operator|new
name|ConcurrentMergeScheduler
argument_list|()
decl_stmt|;
DECL|field|pendingMerges
specifier|private
name|LinkedList
argument_list|<
name|MergePolicy
operator|.
name|OneMerge
argument_list|>
name|pendingMerges
init|=
operator|new
name|LinkedList
argument_list|<
name|MergePolicy
operator|.
name|OneMerge
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|runningMerges
specifier|private
name|Set
argument_list|<
name|MergePolicy
operator|.
name|OneMerge
argument_list|>
name|runningMerges
init|=
operator|new
name|HashSet
argument_list|<
name|MergePolicy
operator|.
name|OneMerge
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|mergeExceptions
specifier|private
name|List
argument_list|<
name|MergePolicy
operator|.
name|OneMerge
argument_list|>
name|mergeExceptions
init|=
operator|new
name|ArrayList
argument_list|<
name|MergePolicy
operator|.
name|OneMerge
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|mergeGen
specifier|private
name|long
name|mergeGen
decl_stmt|;
DECL|field|stopMerges
specifier|private
name|boolean
name|stopMerges
decl_stmt|;
DECL|field|flushCount
specifier|private
name|int
name|flushCount
decl_stmt|;
DECL|field|flushDeletesCount
specifier|private
name|int
name|flushDeletesCount
decl_stmt|;
comment|// Used to only allow one addIndexes to proceed at once
comment|// TODO: use ReadWriteLock once we are on 5.0
DECL|field|readCount
specifier|private
name|int
name|readCount
decl_stmt|;
comment|// count of how many threads are holding read lock
DECL|field|writeThread
specifier|private
name|Thread
name|writeThread
decl_stmt|;
comment|// non-null if any thread holds write lock
DECL|field|readerPool
specifier|final
name|ReaderPool
name|readerPool
init|=
operator|new
name|ReaderPool
argument_list|()
decl_stmt|;
DECL|field|upgradeCount
specifier|private
name|int
name|upgradeCount
decl_stmt|;
comment|// This is a "write once" variable (like the organic dye
comment|// on a DVD-R that may or may not be heated by a laser and
comment|// then cooled to permanently record the event): it's
comment|// false, until getReader() is called for the first time,
comment|// at which point it's switched to true and never changes
comment|// back to false.  Once this is true, we hold open and
comment|// reuse SegmentReader instances internally for applying
comment|// deletes, doing merges, and reopening near real-time
comment|// readers.
DECL|field|poolReaders
specifier|private
specifier|volatile
name|boolean
name|poolReaders
decl_stmt|;
comment|/**    * Expert: returns a readonly reader, covering all    * committed as well as un-committed changes to the index.    * This provides "near real-time" searching, in that    * changes made during an IndexWriter session can be    * quickly made available for searching without closing    * the writer nor calling {@link #commit}.    *    *<p>Note that this is functionally equivalent to calling    * {#commit} and then using {@link IndexReader#open} to    * open a new reader.  But the turarnound time of this    * method should be faster since it avoids the potentially    * costly {@link #commit}.<p>    *    *<p>It's<i>near</i> real-time because there is no hard    * guarantee on how quickly you can get a new reader after    * making changes with IndexWriter.  You'll have to    * experiment in your situation to determine if it's    * fast enough.  As this is a new and experimental    * feature, please report back on your findings so we can    * learn, improve and iterate.</p>    *    *<p>The resulting reader supports {@link    * IndexReader#reopen}, but that call will simply forward    * back to this method (though this may change in the    * future).</p>    *    *<p>The very first time this method is called, this    * writer instance will make every effort to pool the    * readers that it opens for doing merges, applying    * deletes, etc.  This means additional resources (RAM,    * file descriptors, CPU time) will be consumed.</p>    *    *<p>For lower latency on reopening a reader, you should    * call {@link #setMergedSegmentWarmer} to    * pre-warm a newly merged segment before it's committed    * to the index.  This is important for minimizing    * index-to-search delay after a large merge.</p>    *    *<p>If an addIndexes* call is running in another thread,    * then this reader will only search those segments from    * the foreign index that have been successfully copied    * over, so far</p>.    *    *<p><b>NOTE</b>: Once the writer is closed, any    * outstanding readers may continue to be used.  However,    * if you attempt to reopen any of those readers, you'll    * hit an {@link AlreadyClosedException}.</p>    *    *<p><b>NOTE:</b> This API is experimental and might    * change in incompatible ways in the next release.</p>    *    * @return IndexReader that covers entire index plus all    * changes made so far by this IndexWriter instance    *    * @throws IOException    */
DECL|method|getReader
specifier|public
name|IndexReader
name|getReader
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getReader
argument_list|(
name|IndexReader
operator|.
name|DEFAULT_TERMS_INDEX_DIVISOR
argument_list|)
return|;
block|}
comment|/** Expert: like {@link #getReader}, except you can    *  specify which termInfosIndexDivisor should be used for    *  any newly opened readers.    * @param termInfosIndexDivisor Subsamples which indexed    *  terms are loaded into RAM. This has the same effect as {@link    *  IndexWriter#setTermIndexInterval} except that setting    *  must be done at indexing time while this setting can be    *  set per reader.  When set to N, then one in every    *  N*termIndexInterval terms in the index is loaded into    *  memory.  By setting this to a value> 1 you can reduce    *  memory usage, at the expense of higher latency when    *  loading a TermInfo.  The default value is 1.  Set this    *  to -1 to skip loading the terms index entirely. */
DECL|method|getReader
specifier|public
name|IndexReader
name|getReader
parameter_list|(
name|int
name|termInfosIndexDivisor
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"flush at getReader"
argument_list|)
expr_stmt|;
block|}
comment|// Do this up front before flushing so that the readers
comment|// obtained during this flush are pooled, the first time
comment|// this method is called:
name|poolReaders
operator|=
literal|true
expr_stmt|;
name|flush
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Prevent segmentInfos from changing while opening the
comment|// reader; in theory we could do similar retry logic,
comment|// just like we do when loading segments_N
synchronized|synchronized
init|(
name|this
init|)
block|{
return|return
operator|new
name|ReadOnlyDirectoryReader
argument_list|(
name|this
argument_list|,
name|segmentInfos
argument_list|,
name|termInfosIndexDivisor
argument_list|)
return|;
block|}
block|}
comment|/** Holds shared SegmentReader instances. IndexWriter uses    *  SegmentReaders for 1) applying deletes, 2) doing    *  merges, 3) handing out a real-time reader.  This pool    *  reuses instances of the SegmentReaders in all these    *  places if it is in "near real-time mode" (getReader()    *  has been called on this instance). */
DECL|class|ReaderPool
class|class
name|ReaderPool
block|{
DECL|field|readerMap
specifier|private
specifier|final
name|Map
argument_list|<
name|SegmentInfo
argument_list|,
name|SegmentReader
argument_list|>
name|readerMap
init|=
operator|new
name|HashMap
argument_list|<
name|SegmentInfo
argument_list|,
name|SegmentReader
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Forcefully clear changes for the specified segments,      *  and remove from the pool.   This is called on successful merge. */
DECL|method|clear
specifier|synchronized
name|void
name|clear
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|infos
operator|==
literal|null
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|SegmentInfo
argument_list|,
name|SegmentReader
argument_list|>
name|ent
range|:
name|readerMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|hasChanges
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
specifier|final
name|SegmentInfo
name|info
range|:
name|infos
control|)
block|{
if|if
condition|(
name|readerMap
operator|.
name|containsKey
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|readerMap
operator|.
name|get
argument_list|(
name|info
argument_list|)
operator|.
name|hasChanges
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// used only by asserts
DECL|method|infoIsLive
specifier|public
specifier|synchronized
name|boolean
name|infoIsLive
parameter_list|(
name|SegmentInfo
name|info
parameter_list|)
block|{
name|int
name|idx
init|=
name|segmentInfos
operator|.
name|indexOf
argument_list|(
name|info
argument_list|)
decl_stmt|;
assert|assert
name|idx
operator|!=
operator|-
literal|1
assert|;
assert|assert
name|segmentInfos
operator|.
name|get
argument_list|(
name|idx
argument_list|)
operator|==
name|info
assert|;
return|return
literal|true
return|;
block|}
DECL|method|mapToLive
specifier|public
specifier|synchronized
name|SegmentInfo
name|mapToLive
parameter_list|(
name|SegmentInfo
name|info
parameter_list|)
block|{
name|int
name|idx
init|=
name|segmentInfos
operator|.
name|indexOf
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|info
operator|=
name|segmentInfos
operator|.
name|get
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
comment|/**      * Release the segment reader (i.e. decRef it and close if there      * are no more references.      * @param sr      * @throws IOException      */
DECL|method|release
specifier|public
specifier|synchronized
name|void
name|release
parameter_list|(
name|SegmentReader
name|sr
parameter_list|)
throws|throws
name|IOException
block|{
name|release
argument_list|(
name|sr
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Release the segment reader (i.e. decRef it and close if there      * are no more references.      * @param sr      * @throws IOException      */
DECL|method|release
specifier|public
specifier|synchronized
name|void
name|release
parameter_list|(
name|SegmentReader
name|sr
parameter_list|,
name|boolean
name|drop
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|boolean
name|pooled
init|=
name|readerMap
operator|.
name|containsKey
argument_list|(
name|sr
operator|.
name|getSegmentInfo
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
operator|!
name|pooled
operator||
name|readerMap
operator|.
name|get
argument_list|(
name|sr
operator|.
name|getSegmentInfo
argument_list|()
argument_list|)
operator|==
name|sr
assert|;
comment|// Drop caller's ref
name|sr
operator|.
name|decRef
argument_list|()
expr_stmt|;
if|if
condition|(
name|pooled
operator|&&
operator|(
name|drop
operator|||
operator|(
operator|!
name|poolReaders
operator|&&
name|sr
operator|.
name|getRefCount
argument_list|()
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
comment|// We are the last ref to this reader; since we're
comment|// not pooling readers, we release it:
name|readerMap
operator|.
name|remove
argument_list|(
name|sr
operator|.
name|getSegmentInfo
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|sr
operator|.
name|hasChanges
operator|||
name|Thread
operator|.
name|holdsLock
argument_list|(
name|IndexWriter
operator|.
name|this
argument_list|)
assert|;
comment|// Drop our ref -- this will commit any pending
comment|// changes to the dir
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|sr
operator|.
name|close
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
operator|&&
name|sr
operator|.
name|hasChanges
condition|)
block|{
comment|// Abandon the changes& retry closing:
name|sr
operator|.
name|hasChanges
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|sr
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ignore
parameter_list|)
block|{
comment|// Keep throwing original exception
block|}
block|}
block|}
block|}
block|}
comment|/** Remove all our references to readers, and commits      *  any pending changes. */
DECL|method|close
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|SegmentInfo
argument_list|,
name|SegmentReader
argument_list|>
argument_list|>
name|iter
init|=
name|readerMap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|SegmentInfo
argument_list|,
name|SegmentReader
argument_list|>
name|ent
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|SegmentReader
name|sr
init|=
name|ent
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|sr
operator|.
name|hasChanges
condition|)
block|{
assert|assert
name|infoIsLive
argument_list|(
name|sr
operator|.
name|getSegmentInfo
argument_list|()
argument_list|)
assert|;
name|sr
operator|.
name|startCommit
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|sr
operator|.
name|doCommit
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|sr
operator|.
name|rollbackCommit
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|// NOTE: it is allowed that this decRef does not
comment|// actually close the SR; this can happen when a
comment|// near real-time reader is kept open after the
comment|// IndexWriter instance is closed
name|sr
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Commit all segment reader in the pool.      * @throws IOException      */
DECL|method|commit
specifier|synchronized
name|void
name|commit
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|SegmentInfo
argument_list|,
name|SegmentReader
argument_list|>
name|ent
range|:
name|readerMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|SegmentReader
name|sr
init|=
name|ent
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|sr
operator|.
name|hasChanges
condition|)
block|{
assert|assert
name|infoIsLive
argument_list|(
name|sr
operator|.
name|getSegmentInfo
argument_list|()
argument_list|)
assert|;
name|sr
operator|.
name|startCommit
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|sr
operator|.
name|doCommit
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|sr
operator|.
name|rollbackCommit
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Returns a ref to a clone.  NOTE: this clone is not      * enrolled in the pool, so you should simply close()      * it when you're done (ie, do not call release()).      */
DECL|method|getReadOnlyClone
specifier|public
specifier|synchronized
name|SegmentReader
name|getReadOnlyClone
parameter_list|(
name|SegmentInfo
name|info
parameter_list|,
name|boolean
name|doOpenStores
parameter_list|,
name|int
name|termInfosIndexDivisor
parameter_list|)
throws|throws
name|IOException
block|{
name|SegmentReader
name|sr
init|=
name|get
argument_list|(
name|info
argument_list|,
name|doOpenStores
argument_list|,
name|BufferedIndexInput
operator|.
name|BUFFER_SIZE
argument_list|,
name|termInfosIndexDivisor
argument_list|)
decl_stmt|;
try|try
block|{
return|return
operator|(
name|SegmentReader
operator|)
name|sr
operator|.
name|clone
argument_list|(
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|sr
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Obtain a SegmentReader from the readerPool.  The reader      * must be returned by calling {@link #release(SegmentReader)}      * @see #release(SegmentReader)      * @param info      * @param doOpenStores      * @throws IOException      */
DECL|method|get
specifier|public
specifier|synchronized
name|SegmentReader
name|get
parameter_list|(
name|SegmentInfo
name|info
parameter_list|,
name|boolean
name|doOpenStores
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|get
argument_list|(
name|info
argument_list|,
name|doOpenStores
argument_list|,
name|BufferedIndexInput
operator|.
name|BUFFER_SIZE
argument_list|,
name|IndexReader
operator|.
name|DEFAULT_TERMS_INDEX_DIVISOR
argument_list|)
return|;
block|}
comment|/**      * Obtain a SegmentReader from the readerPool.  The reader      * must be returned by calling {@link #release(SegmentReader)}      *       * @see #release(SegmentReader)      * @param info      * @param doOpenStores      * @param readBufferSize      * @param termsIndexDivisor      * @throws IOException      */
DECL|method|get
specifier|public
specifier|synchronized
name|SegmentReader
name|get
parameter_list|(
name|SegmentInfo
name|info
parameter_list|,
name|boolean
name|doOpenStores
parameter_list|,
name|int
name|readBufferSize
parameter_list|,
name|int
name|termsIndexDivisor
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|poolReaders
condition|)
block|{
name|readBufferSize
operator|=
name|BufferedIndexInput
operator|.
name|BUFFER_SIZE
expr_stmt|;
block|}
name|SegmentReader
name|sr
init|=
name|readerMap
operator|.
name|get
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|sr
operator|==
literal|null
condition|)
block|{
comment|// TODO: we may want to avoid doing this while
comment|// synchronized
comment|// Returns a ref, which we xfer to readerMap:
name|sr
operator|=
name|SegmentReader
operator|.
name|get
argument_list|(
literal|false
argument_list|,
name|info
operator|.
name|dir
argument_list|,
name|info
argument_list|,
name|readBufferSize
argument_list|,
name|doOpenStores
argument_list|,
name|termsIndexDivisor
argument_list|)
expr_stmt|;
name|readerMap
operator|.
name|put
argument_list|(
name|info
argument_list|,
name|sr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|doOpenStores
condition|)
block|{
name|sr
operator|.
name|openDocStores
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|termsIndexDivisor
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|sr
operator|.
name|termsIndexLoaded
argument_list|()
condition|)
block|{
comment|// If this reader was originally opened because we
comment|// needed to merge it, we didn't load the terms
comment|// index.  But now, if the caller wants the terms
comment|// index (eg because it's doing deletes, or an NRT
comment|// reader is being opened) we ask the reader to
comment|// load its terms index.
name|sr
operator|.
name|loadTermsIndex
argument_list|(
name|termsIndexDivisor
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Return a ref to our caller
name|sr
operator|.
name|incRef
argument_list|()
expr_stmt|;
return|return
name|sr
return|;
block|}
comment|// Returns a ref
DECL|method|getIfExists
specifier|public
specifier|synchronized
name|SegmentReader
name|getIfExists
parameter_list|(
name|SegmentInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|SegmentReader
name|sr
init|=
name|readerMap
operator|.
name|get
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|sr
operator|!=
literal|null
condition|)
block|{
name|sr
operator|.
name|incRef
argument_list|()
expr_stmt|;
block|}
return|return
name|sr
return|;
block|}
block|}
comment|/**    * Obtain the number of deleted docs for a pooled reader.    * If the reader isn't being pooled, the segmentInfo's     * delCount is returned.    */
DECL|method|numDeletedDocs
specifier|public
name|int
name|numDeletedDocs
parameter_list|(
name|SegmentInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|SegmentReader
name|reader
init|=
name|readerPool
operator|.
name|getIfExists
argument_list|(
name|info
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
return|return
name|reader
operator|.
name|numDeletedDocs
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|info
operator|.
name|getDelCount
argument_list|()
return|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|readerPool
operator|.
name|release
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|acquireWrite
specifier|synchronized
name|void
name|acquireWrite
parameter_list|()
block|{
assert|assert
name|writeThread
operator|!=
name|Thread
operator|.
name|currentThread
argument_list|()
assert|;
while|while
condition|(
name|writeThread
operator|!=
literal|null
operator|||
name|readCount
operator|>
literal|0
condition|)
name|doWait
argument_list|()
expr_stmt|;
comment|// We could have been closed while we were waiting:
name|ensureOpen
argument_list|()
expr_stmt|;
name|writeThread
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
expr_stmt|;
block|}
DECL|method|releaseWrite
specifier|synchronized
name|void
name|releaseWrite
parameter_list|()
block|{
assert|assert
name|Thread
operator|.
name|currentThread
argument_list|()
operator|==
name|writeThread
assert|;
name|writeThread
operator|=
literal|null
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
DECL|method|acquireRead
specifier|synchronized
name|void
name|acquireRead
parameter_list|()
block|{
specifier|final
name|Thread
name|current
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
while|while
condition|(
name|writeThread
operator|!=
literal|null
operator|&&
name|writeThread
operator|!=
name|current
condition|)
name|doWait
argument_list|()
expr_stmt|;
name|readCount
operator|++
expr_stmt|;
block|}
comment|// Allows one readLock to upgrade to a writeLock even if
comment|// there are other readLocks as long as all other
comment|// readLocks are also blocked in this method:
DECL|method|upgradeReadToWrite
specifier|synchronized
name|void
name|upgradeReadToWrite
parameter_list|()
block|{
assert|assert
name|readCount
operator|>
literal|0
assert|;
name|upgradeCount
operator|++
expr_stmt|;
while|while
condition|(
name|readCount
operator|>
name|upgradeCount
operator|||
name|writeThread
operator|!=
literal|null
condition|)
block|{
name|doWait
argument_list|()
expr_stmt|;
block|}
name|writeThread
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
expr_stmt|;
name|readCount
operator|--
expr_stmt|;
name|upgradeCount
operator|--
expr_stmt|;
block|}
DECL|method|releaseRead
specifier|synchronized
name|void
name|releaseRead
parameter_list|()
block|{
name|readCount
operator|--
expr_stmt|;
assert|assert
name|readCount
operator|>=
literal|0
assert|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
DECL|method|isOpen
specifier|synchronized
specifier|final
name|boolean
name|isOpen
parameter_list|(
name|boolean
name|includePendingClose
parameter_list|)
block|{
return|return
operator|!
operator|(
name|closed
operator|||
operator|(
name|includePendingClose
operator|&&
name|closing
operator|)
operator|)
return|;
block|}
comment|/**    * Used internally to throw an {@link    * AlreadyClosedException} if this IndexWriter has been    * closed.    * @throws AlreadyClosedException if this IndexWriter is    */
DECL|method|ensureOpen
specifier|protected
specifier|synchronized
specifier|final
name|void
name|ensureOpen
parameter_list|(
name|boolean
name|includePendingClose
parameter_list|)
throws|throws
name|AlreadyClosedException
block|{
if|if
condition|(
operator|!
name|isOpen
argument_list|(
name|includePendingClose
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AlreadyClosedException
argument_list|(
literal|"this IndexWriter is closed"
argument_list|)
throw|;
block|}
block|}
DECL|method|ensureOpen
specifier|protected
specifier|synchronized
specifier|final
name|void
name|ensureOpen
parameter_list|()
throws|throws
name|AlreadyClosedException
block|{
name|ensureOpen
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Prints a message to the infoStream (if non-null),    * prefixed with the identifying information for this    * writer and the thread that's calling it.    */
DECL|method|message
specifier|public
name|void
name|message
parameter_list|(
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"IW "
operator|+
name|messageID
operator|+
literal|" ["
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"]: "
operator|+
name|message
argument_list|)
expr_stmt|;
block|}
DECL|method|setMessageID
specifier|private
specifier|synchronized
name|void
name|setMessageID
parameter_list|(
name|PrintStream
name|infoStream
parameter_list|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
operator|&&
name|messageID
operator|==
operator|-
literal|1
condition|)
block|{
synchronized|synchronized
init|(
name|MESSAGE_ID_LOCK
init|)
block|{
name|messageID
operator|=
name|MESSAGE_ID
operator|++
expr_stmt|;
block|}
block|}
name|this
operator|.
name|infoStream
operator|=
name|infoStream
expr_stmt|;
block|}
comment|/**    * Casts current mergePolicy to LogMergePolicy, and throws    * an exception if the mergePolicy is not a LogMergePolicy.    */
DECL|method|getLogMergePolicy
specifier|private
name|LogMergePolicy
name|getLogMergePolicy
parameter_list|()
block|{
if|if
condition|(
name|mergePolicy
operator|instanceof
name|LogMergePolicy
condition|)
return|return
operator|(
name|LogMergePolicy
operator|)
name|mergePolicy
return|;
else|else
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"this method can only be called when the merge policy is the default LogMergePolicy"
argument_list|)
throw|;
block|}
comment|/**<p>Get the current setting of whether newly flushed    *  segments will use the compound file format.  Note that    *  this just returns the value previously set with    *  setUseCompoundFile(boolean), or the default value    *  (true).  You cannot use this to query the status of    *  previously flushed segments.</p>    *    *<p>Note that this method is a convenience method: it    *  just calls mergePolicy.getUseCompoundFile as long as    *  mergePolicy is an instance of {@link LogMergePolicy}.    *  Otherwise an IllegalArgumentException is thrown.</p>    *    *  @see #setUseCompoundFile(boolean)    */
DECL|method|getUseCompoundFile
specifier|public
name|boolean
name|getUseCompoundFile
parameter_list|()
block|{
return|return
name|getLogMergePolicy
argument_list|()
operator|.
name|getUseCompoundFile
argument_list|()
return|;
block|}
comment|/**<p>Setting to turn on usage of a compound file. When on,    *  multiple files for each segment are merged into a    *  single file when a new segment is flushed.</p>    *    *<p>Note that this method is a convenience method: it    *  just calls mergePolicy.setUseCompoundFile as long as    *  mergePolicy is an instance of {@link LogMergePolicy}.    *  Otherwise an IllegalArgumentException is thrown.</p>    */
DECL|method|setUseCompoundFile
specifier|public
name|void
name|setUseCompoundFile
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|getLogMergePolicy
argument_list|()
operator|.
name|setUseCompoundFile
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|getLogMergePolicy
argument_list|()
operator|.
name|setUseCompoundDocStore
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** Expert: Set the Similarity implementation used by this IndexWriter.    *    * @see Similarity#setDefault(Similarity)    */
DECL|method|setSimilarity
specifier|public
name|void
name|setSimilarity
parameter_list|(
name|Similarity
name|similarity
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|similarity
operator|=
name|similarity
expr_stmt|;
name|docWriter
operator|.
name|setSimilarity
argument_list|(
name|similarity
argument_list|)
expr_stmt|;
block|}
comment|/** Expert: Return the Similarity implementation used by this IndexWriter.    *    *<p>This defaults to the current value of {@link Similarity#getDefault()}.    */
DECL|method|getSimilarity
specifier|public
name|Similarity
name|getSimilarity
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|this
operator|.
name|similarity
return|;
block|}
comment|/** Expert: Set the interval between indexed terms.  Large values cause less    * memory to be used by IndexReader, but slow random-access to terms.  Small    * values cause more memory to be used by an IndexReader, and speed    * random-access to terms.    *    * This parameter determines the amount of computation required per query    * term, regardless of the number of documents that contain that term.  In    * particular, it is the maximum number of other terms that must be    * scanned before a term is located and its frequency and position information    * may be processed.  In a large index with user-entered query terms, query    * processing time is likely to be dominated not by term lookup but rather    * by the processing of frequency and positional data.  In a small index    * or when many uncommon query terms are generated (e.g., by wildcard    * queries) term lookup may become a dominant cost.    *    * In particular,<code>numUniqueTerms/interval</code> terms are read into    * memory by an IndexReader, and, on average,<code>interval/2</code> terms    * must be scanned for each random term access.    *    * @see #DEFAULT_TERM_INDEX_INTERVAL    */
DECL|method|setTermIndexInterval
specifier|public
name|void
name|setTermIndexInterval
parameter_list|(
name|int
name|interval
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|termIndexInterval
operator|=
name|interval
expr_stmt|;
block|}
comment|/** Expert: Return the interval between indexed terms.    *    * @see #setTermIndexInterval(int)    */
DECL|method|getTermIndexInterval
specifier|public
name|int
name|getTermIndexInterval
parameter_list|()
block|{
comment|// We pass false because this method is called by SegmentMerger while we are in the process of closing
name|ensureOpen
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|termIndexInterval
return|;
block|}
comment|/**    * Constructs an IndexWriter for the index in<code>d</code>.    * Text will be analyzed with<code>a</code>.  If<code>create</code>    * is true, then a new, empty index will be created in    *<code>d</code>, replacing the index already there, if any.    *    * @param d the index directory    * @param a the analyzer to use    * @param create<code>true</code> to create the index or overwrite    *  the existing one;<code>false</code> to append to the existing    *  index    * @param mfl Maximum field length in number of terms/tokens: LIMITED, UNLIMITED, or user-specified    *   via the MaxFieldLength constructor.    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if the directory cannot be read/written to, or    *  if it does not exist and<code>create</code> is    *<code>false</code> or if there is any other low-level    *  IO error    */
DECL|method|IndexWriter
specifier|public
name|IndexWriter
parameter_list|(
name|Directory
name|d
parameter_list|,
name|Analyzer
name|a
parameter_list|,
name|boolean
name|create
parameter_list|,
name|MaxFieldLength
name|mfl
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|init
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|create
argument_list|,
literal|null
argument_list|,
name|mfl
operator|.
name|getLimit
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs an IndexWriter for the index in    *<code>d</code>, first creating it if it does not    * already exist.  Text will be analyzed with    *<code>a</code>.    *    * @param d the index directory    * @param a the analyzer to use    * @param mfl Maximum field length in number of terms/tokens: LIMITED, UNLIMITED, or user-specified    *   via the MaxFieldLength constructor.    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if the directory cannot be    *  read/written to or if there is any other low-level    *  IO error    */
DECL|method|IndexWriter
specifier|public
name|IndexWriter
parameter_list|(
name|Directory
name|d
parameter_list|,
name|Analyzer
name|a
parameter_list|,
name|MaxFieldLength
name|mfl
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|init
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
literal|null
argument_list|,
name|mfl
operator|.
name|getLimit
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expert: constructs an IndexWriter with a custom {@link    * IndexDeletionPolicy}, for the index in<code>d</code>,    * first creating it if it does not already exist.  Text    * will be analyzed with<code>a</code>.    *    * @param d the index directory    * @param a the analyzer to use    * @param deletionPolicy see<a href="#deletionPolicy">above</a>    * @param mfl whether or not to limit field lengths    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if the directory cannot be    *  read/written to or if there is any other low-level    *  IO error    */
DECL|method|IndexWriter
specifier|public
name|IndexWriter
parameter_list|(
name|Directory
name|d
parameter_list|,
name|Analyzer
name|a
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|,
name|MaxFieldLength
name|mfl
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|init
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|deletionPolicy
argument_list|,
name|mfl
operator|.
name|getLimit
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expert: constructs an IndexWriter with a custom {@link    * IndexDeletionPolicy}, for the index in<code>d</code>.    * Text will be analyzed with<code>a</code>.  If    *<code>create</code> is true, then a new, empty index    * will be created in<code>d</code>, replacing the index    * already there, if any.    *    * @param d the index directory    * @param a the analyzer to use    * @param create<code>true</code> to create the index or overwrite    *  the existing one;<code>false</code> to append to the existing    *  index    * @param deletionPolicy see<a href="#deletionPolicy">above</a>    * @param mfl {@link org.apache.lucene.index.IndexWriter.MaxFieldLength}, whether or not to limit field lengths.  Value is in number of terms/tokens    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if the directory cannot be read/written to, or    *  if it does not exist and<code>create</code> is    *<code>false</code> or if there is any other low-level    *  IO error    */
DECL|method|IndexWriter
specifier|public
name|IndexWriter
parameter_list|(
name|Directory
name|d
parameter_list|,
name|Analyzer
name|a
parameter_list|,
name|boolean
name|create
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|,
name|MaxFieldLength
name|mfl
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|init
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|create
argument_list|,
name|deletionPolicy
argument_list|,
name|mfl
operator|.
name|getLimit
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expert: constructs an IndexWriter with a custom {@link    * IndexDeletionPolicy} and {@link IndexingChain},     * for the index in<code>d</code>.    * Text will be analyzed with<code>a</code>.  If    *<code>create</code> is true, then a new, empty index    * will be created in<code>d</code>, replacing the index    * already there, if any.    *    * @param d the index directory    * @param a the analyzer to use    * @param create<code>true</code> to create the index or overwrite    *  the existing one;<code>false</code> to append to the existing    *  index    * @param deletionPolicy see<a href="#deletionPolicy">above</a>    * @param mfl whether or not to limit field lengths, value is in number of terms/tokens.  See {@link org.apache.lucene.index.IndexWriter.MaxFieldLength}.    * @param indexingChain the {@link DocConsumer} chain to be used to     *  process documents    * @param commit which commit to open    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if the directory cannot be read/written to, or    *  if it does not exist and<code>create</code> is    *<code>false</code> or if there is any other low-level    *  IO error    */
DECL|method|IndexWriter
name|IndexWriter
parameter_list|(
name|Directory
name|d
parameter_list|,
name|Analyzer
name|a
parameter_list|,
name|boolean
name|create
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|,
name|MaxFieldLength
name|mfl
parameter_list|,
name|IndexingChain
name|indexingChain
parameter_list|,
name|IndexCommit
name|commit
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|init
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|create
argument_list|,
name|deletionPolicy
argument_list|,
name|mfl
operator|.
name|getLimit
argument_list|()
argument_list|,
name|indexingChain
argument_list|,
name|commit
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expert: constructs an IndexWriter on specific commit    * point, with a custom {@link IndexDeletionPolicy}, for    * the index in<code>d</code>.  Text will be analyzed    * with<code>a</code>.    *    *<p> This is only meaningful if you've used a {@link    * IndexDeletionPolicy} in that past that keeps more than    * just the last commit.    *     *<p>This operation is similar to {@link #rollback()},    * except that method can only rollback what's been done    * with the current instance of IndexWriter since its last    * commit, whereas this method can rollback to an    * arbitrary commit point from the past, assuming the    * {@link IndexDeletionPolicy} has preserved past    * commits.    *    * @param d the index directory    * @param a the analyzer to use    * @param deletionPolicy see<a href="#deletionPolicy">above</a>    * @param mfl whether or not to limit field lengths, value is in number of terms/tokens.  See {@link org.apache.lucene.index.IndexWriter.MaxFieldLength}.    * @param commit which commit to open    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if the directory cannot be read/written to, or    *  if it does not exist and<code>create</code> is    *<code>false</code> or if there is any other low-level    *  IO error    */
DECL|method|IndexWriter
specifier|public
name|IndexWriter
parameter_list|(
name|Directory
name|d
parameter_list|,
name|Analyzer
name|a
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|,
name|MaxFieldLength
name|mfl
parameter_list|,
name|IndexCommit
name|commit
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|init
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
literal|false
argument_list|,
name|deletionPolicy
argument_list|,
name|mfl
operator|.
name|getLimit
argument_list|()
argument_list|,
literal|null
argument_list|,
name|commit
argument_list|)
expr_stmt|;
block|}
DECL|method|init
specifier|private
name|void
name|init
parameter_list|(
name|Directory
name|d
parameter_list|,
name|Analyzer
name|a
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|,
name|int
name|maxFieldLength
parameter_list|,
name|IndexingChain
name|indexingChain
parameter_list|,
name|IndexCommit
name|commit
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
if|if
condition|(
name|IndexReader
operator|.
name|indexExists
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|init
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
literal|false
argument_list|,
name|deletionPolicy
argument_list|,
name|maxFieldLength
argument_list|,
name|indexingChain
argument_list|,
name|commit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|init
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
literal|true
argument_list|,
name|deletionPolicy
argument_list|,
name|maxFieldLength
argument_list|,
name|indexingChain
argument_list|,
name|commit
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|init
specifier|private
name|void
name|init
parameter_list|(
name|Directory
name|d
parameter_list|,
name|Analyzer
name|a
parameter_list|,
specifier|final
name|boolean
name|create
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|,
name|int
name|maxFieldLength
parameter_list|,
name|IndexingChain
name|indexingChain
parameter_list|,
name|IndexCommit
name|commit
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|directory
operator|=
name|d
expr_stmt|;
name|analyzer
operator|=
name|a
expr_stmt|;
name|setMessageID
argument_list|(
name|defaultInfoStream
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxFieldLength
operator|=
name|maxFieldLength
expr_stmt|;
if|if
condition|(
name|indexingChain
operator|==
literal|null
condition|)
name|indexingChain
operator|=
name|DocumentsWriter
operator|.
name|DefaultIndexingChain
expr_stmt|;
if|if
condition|(
name|create
condition|)
block|{
comment|// Clear the write lock in case it's leftover:
name|directory
operator|.
name|clearLock
argument_list|(
name|WRITE_LOCK_NAME
argument_list|)
expr_stmt|;
block|}
name|Lock
name|writeLock
init|=
name|directory
operator|.
name|makeLock
argument_list|(
name|WRITE_LOCK_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|writeLock
operator|.
name|obtain
argument_list|(
name|writeLockTimeout
argument_list|)
condition|)
comment|// obtain write lock
throw|throw
operator|new
name|LockObtainFailedException
argument_list|(
literal|"Index locked for write: "
operator|+
name|writeLock
argument_list|)
throw|;
name|this
operator|.
name|writeLock
operator|=
name|writeLock
expr_stmt|;
comment|// save it
try|try
block|{
if|if
condition|(
name|create
condition|)
block|{
comment|// Try to read first.  This is to allow create
comment|// against an index that's currently open for
comment|// searching.  In this case we write the next
comment|// segments_N file with no segments:
name|boolean
name|doCommit
decl_stmt|;
try|try
block|{
name|segmentInfos
operator|.
name|read
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|segmentInfos
operator|.
name|clear
argument_list|()
expr_stmt|;
name|doCommit
operator|=
literal|false
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Likely this means it's a fresh directory
name|doCommit
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|doCommit
condition|)
block|{
comment|// Only commit if there is no segments file in
comment|// this dir already.
name|segmentInfos
operator|.
name|commit
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|synced
operator|.
name|addAll
argument_list|(
name|segmentInfos
operator|.
name|files
argument_list|(
name|directory
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Record that we have a change (zero out all
comment|// segments) pending:
name|changeCount
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|segmentInfos
operator|.
name|read
argument_list|(
name|directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
operator|!=
literal|null
condition|)
block|{
comment|// Swap out all segments, but, keep metadata in
comment|// SegmentInfos, like version& generation, to
comment|// preserve write-once.  This is important if
comment|// readers are open against the future commit
comment|// points.
if|if
condition|(
name|commit
operator|.
name|getDirectory
argument_list|()
operator|!=
name|directory
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"IndexCommit's directory doesn't match my directory"
argument_list|)
throw|;
name|SegmentInfos
name|oldInfos
init|=
operator|new
name|SegmentInfos
argument_list|()
decl_stmt|;
name|oldInfos
operator|.
name|read
argument_list|(
name|directory
argument_list|,
name|commit
operator|.
name|getSegmentsFileName
argument_list|()
argument_list|)
expr_stmt|;
name|segmentInfos
operator|.
name|replace
argument_list|(
name|oldInfos
argument_list|)
expr_stmt|;
name|changeCount
operator|++
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"init: loaded commit \""
operator|+
name|commit
operator|.
name|getSegmentsFileName
argument_list|()
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
comment|// We assume that this segments_N was previously
comment|// properly sync'd:
name|synced
operator|.
name|addAll
argument_list|(
name|segmentInfos
operator|.
name|files
argument_list|(
name|directory
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|setRollbackSegmentInfos
argument_list|(
name|segmentInfos
argument_list|)
expr_stmt|;
name|docWriter
operator|=
operator|new
name|DocumentsWriter
argument_list|(
name|directory
argument_list|,
name|this
argument_list|,
name|indexingChain
argument_list|)
expr_stmt|;
name|docWriter
operator|.
name|setInfoStream
argument_list|(
name|infoStream
argument_list|)
expr_stmt|;
name|docWriter
operator|.
name|setMaxFieldLength
argument_list|(
name|maxFieldLength
argument_list|)
expr_stmt|;
comment|// Default deleter (for backwards compatibility) is
comment|// KeepOnlyLastCommitDeleter:
name|deleter
operator|=
operator|new
name|IndexFileDeleter
argument_list|(
name|directory
argument_list|,
name|deletionPolicy
operator|==
literal|null
condition|?
operator|new
name|KeepOnlyLastCommitDeletionPolicy
argument_list|()
else|:
name|deletionPolicy
argument_list|,
name|segmentInfos
argument_list|,
name|infoStream
argument_list|,
name|docWriter
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleter
operator|.
name|startingCommitDeleted
condition|)
comment|// Deletion policy deleted the "head" commit point.
comment|// We have to mark ourself as changed so that if we
comment|// are closed w/o any further changes we write a new
comment|// segments_N file.
name|changeCount
operator|++
expr_stmt|;
name|pushMaxBufferedDocs
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"init: create="
operator|+
name|create
argument_list|)
expr_stmt|;
name|messageState
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|this
operator|.
name|writeLock
operator|.
name|release
argument_list|()
expr_stmt|;
name|this
operator|.
name|writeLock
operator|=
literal|null
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|setRollbackSegmentInfos
specifier|private
specifier|synchronized
name|void
name|setRollbackSegmentInfos
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|)
block|{
name|rollbackSegmentInfos
operator|=
operator|(
name|SegmentInfos
operator|)
name|infos
operator|.
name|clone
argument_list|()
expr_stmt|;
assert|assert
operator|!
name|rollbackSegmentInfos
operator|.
name|hasExternalSegments
argument_list|(
name|directory
argument_list|)
assert|;
name|rollbackSegments
operator|=
operator|new
name|HashMap
argument_list|<
name|SegmentInfo
argument_list|,
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
specifier|final
name|int
name|size
init|=
name|rollbackSegmentInfos
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|rollbackSegments
operator|.
name|put
argument_list|(
name|rollbackSegmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expert: set the merge policy used by this writer.    */
DECL|method|setMergePolicy
specifier|public
name|void
name|setMergePolicy
parameter_list|(
name|MergePolicy
name|mp
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|mp
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"MergePolicy must be non-null"
argument_list|)
throw|;
if|if
condition|(
name|mergePolicy
operator|!=
name|mp
condition|)
name|mergePolicy
operator|.
name|close
argument_list|()
expr_stmt|;
name|mergePolicy
operator|=
name|mp
expr_stmt|;
name|pushMaxBufferedDocs
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"setMergePolicy "
operator|+
name|mp
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expert: returns the current MergePolicy in use by this writer.    * @see #setMergePolicy    */
DECL|method|getMergePolicy
specifier|public
name|MergePolicy
name|getMergePolicy
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|mergePolicy
return|;
block|}
comment|/**    * Expert: set the merge scheduler used by this writer.    */
DECL|method|setMergeScheduler
specifier|synchronized
specifier|public
name|void
name|setMergeScheduler
parameter_list|(
name|MergeScheduler
name|mergeScheduler
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|mergeScheduler
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"MergeScheduler must be non-null"
argument_list|)
throw|;
if|if
condition|(
name|this
operator|.
name|mergeScheduler
operator|!=
name|mergeScheduler
condition|)
block|{
name|finishMerges
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|mergeScheduler
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|mergeScheduler
operator|=
name|mergeScheduler
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"setMergeScheduler "
operator|+
name|mergeScheduler
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expert: returns the current MergePolicy in use by this    * writer.    * @see #setMergePolicy    */
DECL|method|getMergeScheduler
specifier|public
name|MergeScheduler
name|getMergeScheduler
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|mergeScheduler
return|;
block|}
comment|/**<p>Determines the largest segment (measured by    * document count) that may be merged with other segments.    * Small values (e.g., less than 10,000) are best for    * interactive indexing, as this limits the length of    * pauses while indexing to a few seconds.  Larger values    * are best for batched indexing and speedier    * searches.</p>    *    *<p>The default value is {@link Integer#MAX_VALUE}.</p>    *    *<p>Note that this method is a convenience method: it    * just calls mergePolicy.setMaxMergeDocs as long as    * mergePolicy is an instance of {@link LogMergePolicy}.    * Otherwise an IllegalArgumentException is thrown.</p>    *    *<p>The default merge policy ({@link    * LogByteSizeMergePolicy}) also allows you to set this    * limit by net size (in MB) of the segment, using {@link    * LogByteSizeMergePolicy#setMaxMergeMB}.</p>    */
DECL|method|setMaxMergeDocs
specifier|public
name|void
name|setMaxMergeDocs
parameter_list|(
name|int
name|maxMergeDocs
parameter_list|)
block|{
name|getLogMergePolicy
argument_list|()
operator|.
name|setMaxMergeDocs
argument_list|(
name|maxMergeDocs
argument_list|)
expr_stmt|;
block|}
comment|/**    *<p>Returns the largest segment (measured by document    * count) that may be merged with other segments.</p>    *    *<p>Note that this method is a convenience method: it    * just calls mergePolicy.getMaxMergeDocs as long as    * mergePolicy is an instance of {@link LogMergePolicy}.    * Otherwise an IllegalArgumentException is thrown.</p>    *    * @see #setMaxMergeDocs    */
DECL|method|getMaxMergeDocs
specifier|public
name|int
name|getMaxMergeDocs
parameter_list|()
block|{
return|return
name|getLogMergePolicy
argument_list|()
operator|.
name|getMaxMergeDocs
argument_list|()
return|;
block|}
comment|/**    * The maximum number of terms that will be indexed for a single field in a    * document.  This limits the amount of memory required for indexing, so that    * collections with very large files will not crash the indexing process by    * running out of memory.  This setting refers to the number of running terms,    * not to the number of different terms.<p/>    *<strong>Note:</strong> this silently truncates large documents, excluding from the    * index all terms that occur further in the document.  If you know your source    * documents are large, be sure to set this value high enough to accomodate    * the expected size.  If you set it to Integer.MAX_VALUE, then the only limit    * is your memory, but you should anticipate an OutOfMemoryError.<p/>    * By default, no more than {@link #DEFAULT_MAX_FIELD_LENGTH} terms    * will be indexed for a field.    */
DECL|method|setMaxFieldLength
specifier|public
name|void
name|setMaxFieldLength
parameter_list|(
name|int
name|maxFieldLength
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxFieldLength
operator|=
name|maxFieldLength
expr_stmt|;
name|docWriter
operator|.
name|setMaxFieldLength
argument_list|(
name|maxFieldLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"setMaxFieldLength "
operator|+
name|maxFieldLength
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the maximum number of terms that will be    * indexed for a single field in a document.    * @see #setMaxFieldLength    */
DECL|method|getMaxFieldLength
specifier|public
name|int
name|getMaxFieldLength
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|maxFieldLength
return|;
block|}
comment|/** Determines the minimal number of documents required    * before the buffered in-memory documents are flushed as    * a new Segment.  Large values generally gives faster    * indexing.    *    *<p>When this is set, the writer will flush every    * maxBufferedDocs added documents.  Pass in {@link    * #DISABLE_AUTO_FLUSH} to prevent triggering a flush due    * to number of buffered documents.  Note that if flushing    * by RAM usage is also enabled, then the flush will be    * triggered by whichever comes first.</p>    *    *<p>Disabled by default (writer flushes by RAM usage).</p>    *    * @throws IllegalArgumentException if maxBufferedDocs is    * enabled but smaller than 2, or it disables maxBufferedDocs    * when ramBufferSize is already disabled    * @see #setRAMBufferSizeMB    */
DECL|method|setMaxBufferedDocs
specifier|public
name|void
name|setMaxBufferedDocs
parameter_list|(
name|int
name|maxBufferedDocs
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|maxBufferedDocs
operator|!=
name|DISABLE_AUTO_FLUSH
operator|&&
name|maxBufferedDocs
operator|<
literal|2
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxBufferedDocs must at least be 2 when enabled"
argument_list|)
throw|;
if|if
condition|(
name|maxBufferedDocs
operator|==
name|DISABLE_AUTO_FLUSH
operator|&&
name|getRAMBufferSizeMB
argument_list|()
operator|==
name|DISABLE_AUTO_FLUSH
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"at least one of ramBufferSize and maxBufferedDocs must be enabled"
argument_list|)
throw|;
name|docWriter
operator|.
name|setMaxBufferedDocs
argument_list|(
name|maxBufferedDocs
argument_list|)
expr_stmt|;
name|pushMaxBufferedDocs
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"setMaxBufferedDocs "
operator|+
name|maxBufferedDocs
argument_list|)
expr_stmt|;
block|}
comment|/**    * If we are flushing by doc count (not by RAM usage), and    * using LogDocMergePolicy then push maxBufferedDocs down    * as its minMergeDocs, to keep backwards compatibility.    */
DECL|method|pushMaxBufferedDocs
specifier|private
name|void
name|pushMaxBufferedDocs
parameter_list|()
block|{
if|if
condition|(
name|docWriter
operator|.
name|getMaxBufferedDocs
argument_list|()
operator|!=
name|DISABLE_AUTO_FLUSH
condition|)
block|{
specifier|final
name|MergePolicy
name|mp
init|=
name|mergePolicy
decl_stmt|;
if|if
condition|(
name|mp
operator|instanceof
name|LogDocMergePolicy
condition|)
block|{
name|LogDocMergePolicy
name|lmp
init|=
operator|(
name|LogDocMergePolicy
operator|)
name|mp
decl_stmt|;
specifier|final
name|int
name|maxBufferedDocs
init|=
name|docWriter
operator|.
name|getMaxBufferedDocs
argument_list|()
decl_stmt|;
if|if
condition|(
name|lmp
operator|.
name|getMinMergeDocs
argument_list|()
operator|!=
name|maxBufferedDocs
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"now push maxBufferedDocs "
operator|+
name|maxBufferedDocs
operator|+
literal|" to LogDocMergePolicy"
argument_list|)
expr_stmt|;
name|lmp
operator|.
name|setMinMergeDocs
argument_list|(
name|maxBufferedDocs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Returns the number of buffered added documents that will    * trigger a flush if enabled.    * @see #setMaxBufferedDocs    */
DECL|method|getMaxBufferedDocs
specifier|public
name|int
name|getMaxBufferedDocs
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|docWriter
operator|.
name|getMaxBufferedDocs
argument_list|()
return|;
block|}
comment|/** Determines the amount of RAM that may be used for    * buffering added documents and deletions before they are    * flushed to the Directory.  Generally for faster    * indexing performance it's best to flush by RAM usage    * instead of document count and use as large a RAM buffer    * as you can.    *    *<p>When this is set, the writer will flush whenever    * buffered documents and deletions use this much RAM.    * Pass in {@link #DISABLE_AUTO_FLUSH} to prevent    * triggering a flush due to RAM usage.  Note that if    * flushing by document count is also enabled, then the    * flush will be triggered by whichever comes first.</p>    *    *<p><b>NOTE</b>: the account of RAM usage for pending    * deletions is only approximate.  Specifically, if you    * delete by Query, Lucene currently has no way to measure    * the RAM usage if individual Queries so the accounting    * will under-estimate and you should compensate by either    * calling commit() periodically yourself, or by using    * {@link #setMaxBufferedDeleteTerms} to flush by count    * instead of RAM usage (each buffered delete Query counts    * as one).    *    *<p><b>NOTE</b>: because IndexWriter uses    *<code>int</code>s when managing its internal storage,    * the absolute maximum value for this setting is somewhat    * less than 2048 MB.  The precise limit depends on    * various factors, such as how large your documents are,    * how many fields have norms, etc., so it's best to set    * this value comfortably under 2048.</p>    *    *<p> The default value is {@link #DEFAULT_RAM_BUFFER_SIZE_MB}.</p>    *     * @throws IllegalArgumentException if ramBufferSize is    * enabled but non-positive, or it disables ramBufferSize    * when maxBufferedDocs is already disabled    */
DECL|method|setRAMBufferSizeMB
specifier|public
name|void
name|setRAMBufferSizeMB
parameter_list|(
name|double
name|mb
parameter_list|)
block|{
if|if
condition|(
name|mb
operator|>
literal|2048.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ramBufferSize "
operator|+
name|mb
operator|+
literal|" is too large; should be comfortably less than 2048"
argument_list|)
throw|;
block|}
if|if
condition|(
name|mb
operator|!=
name|DISABLE_AUTO_FLUSH
operator|&&
name|mb
operator|<=
literal|0.0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ramBufferSize should be> 0.0 MB when enabled"
argument_list|)
throw|;
if|if
condition|(
name|mb
operator|==
name|DISABLE_AUTO_FLUSH
operator|&&
name|getMaxBufferedDocs
argument_list|()
operator|==
name|DISABLE_AUTO_FLUSH
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"at least one of ramBufferSize and maxBufferedDocs must be enabled"
argument_list|)
throw|;
name|docWriter
operator|.
name|setRAMBufferSizeMB
argument_list|(
name|mb
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"setRAMBufferSizeMB "
operator|+
name|mb
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the value set by {@link #setRAMBufferSizeMB} if enabled.    */
DECL|method|getRAMBufferSizeMB
specifier|public
name|double
name|getRAMBufferSizeMB
parameter_list|()
block|{
return|return
name|docWriter
operator|.
name|getRAMBufferSizeMB
argument_list|()
return|;
block|}
comment|/**    *<p>Determines the minimal number of delete terms required before the buffered    * in-memory delete terms are applied and flushed. If there are documents    * buffered in memory at the time, they are merged and a new segment is    * created.</p>     *<p>Disabled by default (writer flushes by RAM usage).</p>    *     * @throws IllegalArgumentException if maxBufferedDeleteTerms    * is enabled but smaller than 1    * @see #setRAMBufferSizeMB    */
DECL|method|setMaxBufferedDeleteTerms
specifier|public
name|void
name|setMaxBufferedDeleteTerms
parameter_list|(
name|int
name|maxBufferedDeleteTerms
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|maxBufferedDeleteTerms
operator|!=
name|DISABLE_AUTO_FLUSH
operator|&&
name|maxBufferedDeleteTerms
operator|<
literal|1
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxBufferedDeleteTerms must at least be 1 when enabled"
argument_list|)
throw|;
name|docWriter
operator|.
name|setMaxBufferedDeleteTerms
argument_list|(
name|maxBufferedDeleteTerms
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"setMaxBufferedDeleteTerms "
operator|+
name|maxBufferedDeleteTerms
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the number of buffered deleted terms that will    * trigger a flush if enabled.    * @see #setMaxBufferedDeleteTerms    */
DECL|method|getMaxBufferedDeleteTerms
specifier|public
name|int
name|getMaxBufferedDeleteTerms
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|docWriter
operator|.
name|getMaxBufferedDeleteTerms
argument_list|()
return|;
block|}
comment|/** Determines how often segment indices are merged by addDocument().  With    * smaller values, less RAM is used while indexing, and searches on    * unoptimized indices are faster, but indexing speed is slower.  With larger    * values, more RAM is used during indexing, and while searches on unoptimized    * indices are slower, indexing is faster.  Thus larger values (> 10) are best    * for batch index creation, and smaller values (< 10) for indices that are    * interactively maintained.    *    *<p>Note that this method is a convenience method: it    * just calls mergePolicy.setMergeFactor as long as    * mergePolicy is an instance of {@link LogMergePolicy}.    * Otherwise an IllegalArgumentException is thrown.</p>    *    *<p>This must never be less than 2.  The default value is 10.    */
DECL|method|setMergeFactor
specifier|public
name|void
name|setMergeFactor
parameter_list|(
name|int
name|mergeFactor
parameter_list|)
block|{
name|getLogMergePolicy
argument_list|()
operator|.
name|setMergeFactor
argument_list|(
name|mergeFactor
argument_list|)
expr_stmt|;
block|}
comment|/**    *<p>Returns the number of segments that are merged at    * once and also controls the total number of segments    * allowed to accumulate in the index.</p>    *    *<p>Note that this method is a convenience method: it    * just calls mergePolicy.getMergeFactor as long as    * mergePolicy is an instance of {@link LogMergePolicy}.    * Otherwise an IllegalArgumentException is thrown.</p>    *    * @see #setMergeFactor    */
DECL|method|getMergeFactor
specifier|public
name|int
name|getMergeFactor
parameter_list|()
block|{
return|return
name|getLogMergePolicy
argument_list|()
operator|.
name|getMergeFactor
argument_list|()
return|;
block|}
comment|/** If non-null, this will be the default infoStream used    * by a newly instantiated IndexWriter.    * @see #setInfoStream    */
DECL|method|setDefaultInfoStream
specifier|public
specifier|static
name|void
name|setDefaultInfoStream
parameter_list|(
name|PrintStream
name|infoStream
parameter_list|)
block|{
name|IndexWriter
operator|.
name|defaultInfoStream
operator|=
name|infoStream
expr_stmt|;
block|}
comment|/**    * Returns the current default infoStream for newly    * instantiated IndexWriters.    * @see #setDefaultInfoStream    */
DECL|method|getDefaultInfoStream
specifier|public
specifier|static
name|PrintStream
name|getDefaultInfoStream
parameter_list|()
block|{
return|return
name|IndexWriter
operator|.
name|defaultInfoStream
return|;
block|}
comment|/** If non-null, information about merges, deletes and a    * message when maxFieldLength is reached will be printed    * to this.    */
DECL|method|setInfoStream
specifier|public
name|void
name|setInfoStream
parameter_list|(
name|PrintStream
name|infoStream
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|setMessageID
argument_list|(
name|infoStream
argument_list|)
expr_stmt|;
name|docWriter
operator|.
name|setInfoStream
argument_list|(
name|infoStream
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|setInfoStream
argument_list|(
name|infoStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|messageState
argument_list|()
expr_stmt|;
block|}
DECL|method|messageState
specifier|private
name|void
name|messageState
parameter_list|()
block|{
name|message
argument_list|(
literal|"setInfoStream: dir="
operator|+
name|directory
operator|+
literal|" mergePolicy="
operator|+
name|mergePolicy
operator|+
literal|" mergeScheduler="
operator|+
name|mergeScheduler
operator|+
literal|" ramBufferSizeMB="
operator|+
name|docWriter
operator|.
name|getRAMBufferSizeMB
argument_list|()
operator|+
literal|" maxBufferedDocs="
operator|+
name|docWriter
operator|.
name|getMaxBufferedDocs
argument_list|()
operator|+
literal|" maxBuffereDeleteTerms="
operator|+
name|docWriter
operator|.
name|getMaxBufferedDeleteTerms
argument_list|()
operator|+
literal|" maxFieldLength="
operator|+
name|maxFieldLength
operator|+
literal|" index="
operator|+
name|segString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the current infoStream in use by this writer.    * @see #setInfoStream    */
DECL|method|getInfoStream
specifier|public
name|PrintStream
name|getInfoStream
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|infoStream
return|;
block|}
comment|/** Returns true if verbosing is enabled (i.e., infoStream != null). */
DECL|method|verbose
specifier|public
name|boolean
name|verbose
parameter_list|()
block|{
return|return
name|infoStream
operator|!=
literal|null
return|;
block|}
comment|/**    * Sets the maximum time to wait for a write lock (in milliseconds) for this instance of IndexWriter.  @see    * @see #setDefaultWriteLockTimeout to change the default value for all instances of IndexWriter.    */
DECL|method|setWriteLockTimeout
specifier|public
name|void
name|setWriteLockTimeout
parameter_list|(
name|long
name|writeLockTimeout
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|writeLockTimeout
operator|=
name|writeLockTimeout
expr_stmt|;
block|}
comment|/**    * Returns allowed timeout when acquiring the write lock.    * @see #setWriteLockTimeout    */
DECL|method|getWriteLockTimeout
specifier|public
name|long
name|getWriteLockTimeout
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|writeLockTimeout
return|;
block|}
comment|/**    * Sets the default (for any instance of IndexWriter) maximum time to wait for a write lock (in    * milliseconds).    */
DECL|method|setDefaultWriteLockTimeout
specifier|public
specifier|static
name|void
name|setDefaultWriteLockTimeout
parameter_list|(
name|long
name|writeLockTimeout
parameter_list|)
block|{
name|IndexWriter
operator|.
name|WRITE_LOCK_TIMEOUT
operator|=
name|writeLockTimeout
expr_stmt|;
block|}
comment|/**    * Returns default write lock timeout for newly    * instantiated IndexWriters.    * @see #setDefaultWriteLockTimeout    */
DECL|method|getDefaultWriteLockTimeout
specifier|public
specifier|static
name|long
name|getDefaultWriteLockTimeout
parameter_list|()
block|{
return|return
name|IndexWriter
operator|.
name|WRITE_LOCK_TIMEOUT
return|;
block|}
comment|/**    * Commits all changes to an index and closes all    * associated files.  Note that this may be a costly    * operation, so, try to re-use a single writer instead of    * closing and opening a new one.  See {@link #commit()} for    * caveats about write caching done by some IO devices.    *    *<p> If an Exception is hit during close, eg due to disk    * full or some other reason, then both the on-disk index    * and the internal state of the IndexWriter instance will    * be consistent.  However, the close will not be complete    * even though part of it (flushing buffered documents)    * may have succeeded, so the write lock will still be    * held.</p>    *     *<p> If you can correct the underlying cause (eg free up    * some disk space) then you can call close() again.    * Failing that, if you want to force the write lock to be    * released (dangerous, because you may then lose buffered    * docs in the IndexWriter instance) then you can do    * something like this:</p>    *    *<pre>    * try {    *   writer.close();    * } finally {    *   if (IndexWriter.isLocked(directory)) {    *     IndexWriter.unlock(directory);    *   }    * }    *</pre>    *    * after which, you must be certain not to use the writer    * instance anymore.</p>    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer, again.  See<a    * href="#OOME">above</a> for details.</p>    *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|close
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Closes the index with or without waiting for currently    * running merges to finish.  This is only meaningful when    * using a MergeScheduler that runs merges in background    * threads.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer, again.  See<a    * href="#OOME">above</a> for details.</p>    *    *<p><b>NOTE</b>: it is dangerous to always call    * close(false), especially when IndexWriter is not open    * for very long, because this can result in "merge    * starvation" whereby long merges will never have a    * chance to finish.  This will cause too many segments in    * your index over time.</p>    *    * @param waitForMerges if true, this call will block    * until all merges complete; else, it will ask all    * running merges to abort, wait until those merges have    * finished (which should be at most a few seconds), and    * then return.    */
DECL|method|close
specifier|public
name|void
name|close
parameter_list|(
name|boolean
name|waitForMerges
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
comment|// Ensure that only one thread actually gets to do the closing:
if|if
condition|(
name|shouldClose
argument_list|()
condition|)
block|{
comment|// If any methods have hit OutOfMemoryError, then abort
comment|// on close, in case the internal state of IndexWriter
comment|// or DocumentsWriter is corrupt
if|if
condition|(
name|hitOOM
condition|)
name|rollbackInternal
argument_list|()
expr_stmt|;
else|else
name|closeInternal
argument_list|(
name|waitForMerges
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Returns true if this thread should attempt to close, or
comment|// false if IndexWriter is now closed; else, waits until
comment|// another thread finishes closing
DECL|method|shouldClose
specifier|synchronized
specifier|private
name|boolean
name|shouldClose
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
if|if
condition|(
operator|!
name|closing
condition|)
block|{
name|closing
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// Another thread is presently trying to close;
comment|// wait until it finishes one way (closes
comment|// successfully) or another (fails to close)
name|doWait
argument_list|()
expr_stmt|;
block|}
block|}
else|else
return|return
literal|false
return|;
block|}
block|}
DECL|method|closeInternal
specifier|private
name|void
name|closeInternal
parameter_list|(
name|boolean
name|waitForMerges
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|docWriter
operator|.
name|pauseAllThreads
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"now flush at close"
argument_list|)
expr_stmt|;
name|docWriter
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Only allow a new merge to be triggered if we are
comment|// going to wait for merges:
if|if
condition|(
operator|!
name|hitOOM
condition|)
block|{
name|flush
argument_list|(
name|waitForMerges
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|waitForMerges
condition|)
comment|// Give merge scheduler last chance to run, in case
comment|// any pending merges are waiting:
name|mergeScheduler
operator|.
name|merge
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mergePolicy
operator|.
name|close
argument_list|()
expr_stmt|;
name|finishMerges
argument_list|(
name|waitForMerges
argument_list|)
expr_stmt|;
name|stopMerges
operator|=
literal|true
expr_stmt|;
name|mergeScheduler
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"now call final commit()"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hitOOM
condition|)
block|{
name|commit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"at close: "
operator|+
name|segString
argument_list|()
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|readerPool
operator|.
name|close
argument_list|()
expr_stmt|;
name|docWriter
operator|=
literal|null
expr_stmt|;
name|deleter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|writeLock
operator|!=
literal|null
condition|)
block|{
name|writeLock
operator|.
name|release
argument_list|()
expr_stmt|;
comment|// release write lock
name|writeLock
operator|=
literal|null
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
name|closed
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"closeInternal"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|closing
operator|=
literal|false
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|closed
condition|)
block|{
if|if
condition|(
name|docWriter
operator|!=
literal|null
condition|)
name|docWriter
operator|.
name|resumeAllThreads
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"hit exception while closing"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Tells the docWriter to close its currently open shared    *  doc stores (stored fields& vectors files).    *  Return value specifices whether new doc store files are compound or not.    */
DECL|method|flushDocStores
specifier|private
specifier|synchronized
name|boolean
name|flushDocStores
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|useCompoundDocStore
init|=
literal|false
decl_stmt|;
name|String
name|docStoreSegment
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|docStoreSegment
operator|=
name|docWriter
operator|.
name|closeDocStore
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
operator|&&
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"hit exception closing doc store segment"
argument_list|)
expr_stmt|;
block|}
block|}
name|useCompoundDocStore
operator|=
name|mergePolicy
operator|.
name|useCompoundDocStore
argument_list|(
name|segmentInfos
argument_list|)
expr_stmt|;
if|if
condition|(
name|useCompoundDocStore
operator|&&
name|docStoreSegment
operator|!=
literal|null
operator|&&
name|docWriter
operator|.
name|closedFiles
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// Now build compound doc store file
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"create compound file "
operator|+
name|docStoreSegment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|COMPOUND_FILE_STORE_EXTENSION
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|false
expr_stmt|;
specifier|final
name|int
name|numSegments
init|=
name|segmentInfos
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|String
name|compoundFileName
init|=
name|docStoreSegment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|COMPOUND_FILE_STORE_EXTENSION
decl_stmt|;
try|try
block|{
name|CompoundFileWriter
name|cfsWriter
init|=
operator|new
name|CompoundFileWriter
argument_list|(
name|directory
argument_list|,
name|compoundFileName
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|String
name|file
range|:
name|docWriter
operator|.
name|closedFiles
argument_list|()
control|)
block|{
name|cfsWriter
operator|.
name|addFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
comment|// Perform the merge
name|cfsWriter
operator|.
name|close
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"hit exception building compound file doc store for segment "
operator|+
name|docStoreSegment
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|deleteFile
argument_list|(
name|compoundFileName
argument_list|)
expr_stmt|;
name|docWriter
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
condition|;
name|i
operator|++
control|)
block|{
name|SegmentInfo
name|si
init|=
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|si
operator|.
name|getDocStoreOffset
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|si
operator|.
name|getDocStoreSegment
argument_list|()
operator|.
name|equals
argument_list|(
name|docStoreSegment
argument_list|)
condition|)
name|si
operator|.
name|setDocStoreIsCompoundFile
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|checkpoint
argument_list|()
expr_stmt|;
comment|// In case the files we just merged into a CFS were
comment|// not previously checkpointed:
name|deleter
operator|.
name|deleteNewFiles
argument_list|(
name|docWriter
operator|.
name|closedFiles
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|useCompoundDocStore
return|;
block|}
comment|/** Returns the Directory used by this index. */
DECL|method|getDirectory
specifier|public
name|Directory
name|getDirectory
parameter_list|()
block|{
comment|// Pass false because the flush during closing calls getDirectory
name|ensureOpen
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|directory
return|;
block|}
comment|/** Returns the analyzer used by this index. */
DECL|method|getAnalyzer
specifier|public
name|Analyzer
name|getAnalyzer
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|analyzer
return|;
block|}
comment|/** Returns total number of docs in this index, including    *  docs not yet flushed (still in the RAM buffer),    *  not counting deletions.    *  @see #numDocs */
DECL|method|maxDoc
specifier|public
specifier|synchronized
name|int
name|maxDoc
parameter_list|()
block|{
name|int
name|count
decl_stmt|;
if|if
condition|(
name|docWriter
operator|!=
literal|null
condition|)
name|count
operator|=
name|docWriter
operator|.
name|getNumDocsInRAM
argument_list|()
expr_stmt|;
else|else
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segmentInfos
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
name|count
operator|+=
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
operator|.
name|docCount
expr_stmt|;
return|return
name|count
return|;
block|}
comment|/** Returns total number of docs in this index, including    *  docs not yet flushed (still in the RAM buffer), and    *  including deletions.<b>NOTE:</b> buffered deletions    *  are not counted.  If you really need these to be    *  counted you should call {@link #commit()} first.    *  @see #numDocs */
DECL|method|numDocs
specifier|public
specifier|synchronized
name|int
name|numDocs
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|count
decl_stmt|;
if|if
condition|(
name|docWriter
operator|!=
literal|null
condition|)
name|count
operator|=
name|docWriter
operator|.
name|getNumDocsInRAM
argument_list|()
expr_stmt|;
else|else
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segmentInfos
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentInfo
name|info
init|=
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|count
operator|+=
name|info
operator|.
name|docCount
operator|-
name|info
operator|.
name|getDelCount
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
DECL|method|hasDeletions
specifier|public
specifier|synchronized
name|boolean
name|hasDeletions
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|docWriter
operator|.
name|hasDeletes
argument_list|()
condition|)
return|return
literal|true
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segmentInfos
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
operator|.
name|hasDeletions
argument_list|()
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
comment|/**    * The maximum number of terms that will be indexed for a single field in a    * document.  This limits the amount of memory required for indexing, so that    * collections with very large files will not crash the indexing process by    * running out of memory.<p/>    * Note that this effectively truncates large documents, excluding from the    * index terms that occur further in the document.  If you know your source    * documents are large, be sure to set this value high enough to accommodate    * the expected size.  If you set it to Integer.MAX_VALUE, then the only limit    * is your memory, but you should anticipate an OutOfMemoryError.<p/>    * By default, no more than 10,000 terms will be indexed for a field.    *    * @see MaxFieldLength    */
DECL|field|maxFieldLength
specifier|private
name|int
name|maxFieldLength
decl_stmt|;
comment|/**    * Adds a document to this index.  If the document contains more than    * {@link #setMaxFieldLength(int)} terms for a given field, the remainder are    * discarded.    *    *<p> Note that if an Exception is hit (for example disk full)    * then the index will be consistent, but this document    * may not have been added.  Furthermore, it's possible    * the index will have one segment in non-compound format    * even when using compound files (when a merge has    * partially succeeded).</p>    *    *<p> This method periodically flushes pending documents    * to the Directory (see<a href="#flush">above</a>), and    * also periodically triggers segment merges in the index    * according to the {@link MergePolicy} in use.</p>    *    *<p>Merges temporarily consume space in the    * directory. The amount of space required is up to 1X the    * size of all segments being merged, when no    * readers/searchers are open against the index, and up to    * 2X the size of all segments being merged when    * readers/searchers are open against the index (see    * {@link #optimize()} for details). The sequence of    * primitive merge operations performed is governed by the    * merge policy.    *    *<p>Note that each term in the document can be no longer    * than 16383 characters, otherwise an    * IllegalArgumentException will be thrown.</p>    *    *<p>Note that it's possible to create an invalid Unicode    * string in java if a UTF16 surrogate pair is malformed.    * In this case, the invalid characters are silently    * replaced with the Unicode replacement character    * U+FFFD.</p>    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|addDocument
specifier|public
name|void
name|addDocument
parameter_list|(
name|Document
name|doc
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|addDocument
argument_list|(
name|doc
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds a document to this index, using the provided analyzer instead of the    * value of {@link #getAnalyzer()}.  If the document contains more than    * {@link #setMaxFieldLength(int)} terms for a given field, the remainder are    * discarded.    *    *<p>See {@link #addDocument(Document)} for details on    * index and IndexWriter state after an Exception, and    * flushing/merging temporary free space requirements.</p>    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|addDocument
specifier|public
name|void
name|addDocument
parameter_list|(
name|Document
name|doc
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|boolean
name|doFlush
init|=
literal|false
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
try|try
block|{
name|doFlush
operator|=
name|docWriter
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"hit exception adding document"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// If docWriter has some aborted files that were
comment|// never incref'd, then we clean them up here
if|if
condition|(
name|docWriter
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|files
init|=
name|docWriter
operator|.
name|abortedFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|files
operator|!=
literal|null
condition|)
name|deleter
operator|.
name|deleteNewFiles
argument_list|(
name|files
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|doFlush
condition|)
name|flush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"addDocument"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Deletes the document(s) containing<code>term</code>.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @param term the term to identify the documents to be deleted    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|deleteDocuments
specifier|public
name|void
name|deleteDocuments
parameter_list|(
name|Term
name|term
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
try|try
block|{
name|boolean
name|doFlush
init|=
name|docWriter
operator|.
name|bufferDeleteTerm
argument_list|(
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
name|doFlush
condition|)
name|flush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"deleteDocuments(Term)"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Deletes the document(s) containing any of the    * terms. All deletes are flushed at the same time.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @param terms array of terms to identify the documents    * to be deleted    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|deleteDocuments
specifier|public
name|void
name|deleteDocuments
parameter_list|(
name|Term
modifier|...
name|terms
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
try|try
block|{
name|boolean
name|doFlush
init|=
name|docWriter
operator|.
name|bufferDeleteTerms
argument_list|(
name|terms
argument_list|)
decl_stmt|;
if|if
condition|(
name|doFlush
condition|)
name|flush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"deleteDocuments(Term..)"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Deletes the document(s) matching the provided query.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @param query the query to identify the documents to be deleted    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|deleteDocuments
specifier|public
name|void
name|deleteDocuments
parameter_list|(
name|Query
name|query
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|boolean
name|doFlush
init|=
name|docWriter
operator|.
name|bufferDeleteQuery
argument_list|(
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|doFlush
condition|)
name|flush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Deletes the document(s) matching any of the provided queries.    * All deletes are flushed at the same time.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @param queries array of queries to identify the documents    * to be deleted    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|deleteDocuments
specifier|public
name|void
name|deleteDocuments
parameter_list|(
name|Query
modifier|...
name|queries
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|boolean
name|doFlush
init|=
name|docWriter
operator|.
name|bufferDeleteQueries
argument_list|(
name|queries
argument_list|)
decl_stmt|;
if|if
condition|(
name|doFlush
condition|)
name|flush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Updates a document by first deleting the document(s)    * containing<code>term</code> and then adding the new    * document.  The delete and then add are atomic as seen    * by a reader on the same index (flush may happen only after    * the add).    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @param term the term to identify the document(s) to be    * deleted    * @param doc the document to be added    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|updateDocument
specifier|public
name|void
name|updateDocument
parameter_list|(
name|Term
name|term
parameter_list|,
name|Document
name|doc
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|updateDocument
argument_list|(
name|term
argument_list|,
name|doc
argument_list|,
name|getAnalyzer
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Updates a document by first deleting the document(s)    * containing<code>term</code> and then adding the new    * document.  The delete and then add are atomic as seen    * by a reader on the same index (flush may happen only after    * the add).    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @param term the term to identify the document(s) to be    * deleted    * @param doc the document to be added    * @param analyzer the analyzer to use when analyzing the document    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|updateDocument
specifier|public
name|void
name|updateDocument
parameter_list|(
name|Term
name|term
parameter_list|,
name|Document
name|doc
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
try|try
block|{
name|boolean
name|doFlush
init|=
literal|false
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|doFlush
operator|=
name|docWriter
operator|.
name|updateDocument
argument_list|(
name|term
argument_list|,
name|doc
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"hit exception updating document"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// If docWriter has some aborted files that were
comment|// never incref'd, then we clean them up here
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|files
init|=
name|docWriter
operator|.
name|abortedFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|files
operator|!=
literal|null
condition|)
name|deleter
operator|.
name|deleteNewFiles
argument_list|(
name|files
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|doFlush
condition|)
name|flush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"updateDocument"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// for test purpose
DECL|method|getSegmentCount
specifier|final
specifier|synchronized
name|int
name|getSegmentCount
parameter_list|()
block|{
return|return
name|segmentInfos
operator|.
name|size
argument_list|()
return|;
block|}
comment|// for test purpose
DECL|method|getNumBufferedDocuments
specifier|final
specifier|synchronized
name|int
name|getNumBufferedDocuments
parameter_list|()
block|{
return|return
name|docWriter
operator|.
name|getNumDocsInRAM
argument_list|()
return|;
block|}
comment|// for test purpose
DECL|method|getDocCount
specifier|final
specifier|synchronized
name|int
name|getDocCount
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|segmentInfos
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
operator|.
name|docCount
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|// for test purpose
DECL|method|getFlushCount
specifier|final
specifier|synchronized
name|int
name|getFlushCount
parameter_list|()
block|{
return|return
name|flushCount
return|;
block|}
comment|// for test purpose
DECL|method|getFlushDeletesCount
specifier|final
specifier|synchronized
name|int
name|getFlushDeletesCount
parameter_list|()
block|{
return|return
name|flushDeletesCount
return|;
block|}
DECL|method|newSegmentName
specifier|final
name|String
name|newSegmentName
parameter_list|()
block|{
comment|// Cannot synchronize on IndexWriter because that causes
comment|// deadlock
synchronized|synchronized
init|(
name|segmentInfos
init|)
block|{
comment|// Important to increment changeCount so that the
comment|// segmentInfos is written on close.  Otherwise we
comment|// could close, re-open and re-return the same segment
comment|// name that was previously returned which can cause
comment|// problems at least with ConcurrentMergeScheduler.
name|changeCount
operator|++
expr_stmt|;
return|return
literal|"_"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|segmentInfos
operator|.
name|counter
operator|++
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
return|;
block|}
block|}
comment|/** If non-null, information about merges will be printed to this.    */
DECL|field|infoStream
specifier|private
name|PrintStream
name|infoStream
init|=
literal|null
decl_stmt|;
DECL|field|defaultInfoStream
specifier|private
specifier|static
name|PrintStream
name|defaultInfoStream
init|=
literal|null
decl_stmt|;
comment|/**    * Requests an "optimize" operation on an index, priming the index    * for the fastest available search. Traditionally this has meant    * merging all segments into a single segment as is done in the    * default merge policy, but individual merge policies may implement    * optimize in different ways.    *    *<p>It is recommended that this method be called upon completion of indexing.  In    * environments with frequent updates, optimize is best done during low volume times, if at all.     *     *</p>    *<p>See http://www.gossamer-threads.com/lists/lucene/java-dev/47895 for more discussion.</p>    *    *<p>Note that optimize requires 2X the index size free    * space in your Directory.  For example, if your index    * size is 10 MB then you need 20 MB free for optimize to    * complete.</p>    *    *<p>If some but not all readers re-open while an    * optimize is underway, this will cause> 2X temporary    * space to be consumed as those new readers will then    * hold open the partially optimized segments at that    * time.  It is best not to re-open readers while optimize    * is running.</p>    *    *<p>The actual temporary usage could be much less than    * these figures (it depends on many factors).</p>    *    *<p>In general, once the optimize completes, the total size of the    * index will be less than the size of the starting index.    * It could be quite a bit smaller (if there were many    * pending deletes) or just slightly smaller.</p>    *    *<p>If an Exception is hit during optimize(), for example    * due to disk full, the index will not be corrupt and no    * documents will have been lost.  However, it may have    * been partially optimized (some segments were merged but    * not all), and it's possible that one of the segments in    * the index will be in non-compound format even when    * using compound file format.  This will occur when the    * Exception is hit during conversion of the segment into    * compound format.</p>    *    *<p>This call will optimize those segments present in    * the index when the call started.  If other threads are    * still adding documents and flushing segments, those    * newly created segments will not be optimized unless you    * call optimize again.</p>    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    * @see LogMergePolicy#findMergesForOptimize   */
DECL|method|optimize
specifier|public
name|void
name|optimize
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|optimize
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Optimize the index down to<= maxNumSegments.  If    * maxNumSegments==1 then this is the same as {@link    * #optimize()}.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @param maxNumSegments maximum number of segments left    * in the index after optimization finishes    */
DECL|method|optimize
specifier|public
name|void
name|optimize
parameter_list|(
name|int
name|maxNumSegments
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|optimize
argument_list|(
name|maxNumSegments
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** Just like {@link #optimize()}, except you can specify    *  whether the call should block until the optimize    *  completes.  This is only meaningful with a    *  {@link MergeScheduler} that is able to run merges in    *  background threads.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    */
DECL|method|optimize
specifier|public
name|void
name|optimize
parameter_list|(
name|boolean
name|doWait
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|optimize
argument_list|(
literal|1
argument_list|,
name|doWait
argument_list|)
expr_stmt|;
block|}
comment|/** Just like {@link #optimize(int)}, except you can    *  specify whether the call should block until the    *  optimize completes.  This is only meaningful with a    *  {@link MergeScheduler} that is able to run merges in    *  background threads.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    */
DECL|method|optimize
specifier|public
name|void
name|optimize
parameter_list|(
name|int
name|maxNumSegments
parameter_list|,
name|boolean
name|doWait
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|maxNumSegments
operator|<
literal|1
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxNumSegments must be>= 1; got "
operator|+
name|maxNumSegments
argument_list|)
throw|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"optimize: index now "
operator|+
name|segString
argument_list|()
argument_list|)
expr_stmt|;
name|flush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|resetMergeExceptions
argument_list|()
expr_stmt|;
name|segmentsToOptimize
operator|=
operator|new
name|HashSet
argument_list|<
name|SegmentInfo
argument_list|>
argument_list|()
expr_stmt|;
specifier|final
name|int
name|numSegments
init|=
name|segmentInfos
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
condition|;
name|i
operator|++
control|)
name|segmentsToOptimize
operator|.
name|add
argument_list|(
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now mark all pending& running merges as optimize
comment|// merge:
for|for
control|(
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
range|:
name|pendingMerges
control|)
block|{
name|merge
operator|.
name|optimize
operator|=
literal|true
expr_stmt|;
name|merge
operator|.
name|maxNumSegmentsOptimize
operator|=
name|maxNumSegments
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
range|:
name|runningMerges
control|)
block|{
name|merge
operator|.
name|optimize
operator|=
literal|true
expr_stmt|;
name|merge
operator|.
name|maxNumSegmentsOptimize
operator|=
name|maxNumSegments
expr_stmt|;
block|}
block|}
name|maybeMerge
argument_list|(
name|maxNumSegments
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|doWait
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|hitOOM
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"this writer hit an OutOfMemoryError; cannot complete optimize"
argument_list|)
throw|;
block|}
if|if
condition|(
name|mergeExceptions
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Forward any exceptions in background merge
comment|// threads to the current thread:
specifier|final
name|int
name|size
init|=
name|mergeExceptions
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
init|=
name|mergeExceptions
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|merge
operator|.
name|optimize
condition|)
block|{
name|IOException
name|err
init|=
operator|new
name|IOException
argument_list|(
literal|"background merge hit exception: "
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|directory
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Throwable
name|t
init|=
name|merge
operator|.
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
name|err
operator|.
name|initCause
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|err
throw|;
block|}
block|}
block|}
if|if
condition|(
name|optimizeMergesPending
argument_list|()
condition|)
name|doWait
argument_list|()
expr_stmt|;
else|else
break|break;
block|}
block|}
comment|// If close is called while we are still
comment|// running, throw an exception so the calling
comment|// thread will know the optimize did not
comment|// complete
name|ensureOpen
argument_list|()
expr_stmt|;
block|}
comment|// NOTE: in the ConcurrentMergeScheduler case, when
comment|// doWait is false, we can return immediately while
comment|// background threads accomplish the optimization
block|}
comment|/** Returns true if any merges in pendingMerges or    *  runningMerges are optimization merges. */
DECL|method|optimizeMergesPending
specifier|private
specifier|synchronized
name|boolean
name|optimizeMergesPending
parameter_list|()
block|{
for|for
control|(
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
range|:
name|pendingMerges
control|)
block|{
if|if
condition|(
name|merge
operator|.
name|optimize
condition|)
return|return
literal|true
return|;
block|}
for|for
control|(
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
range|:
name|runningMerges
control|)
block|{
if|if
condition|(
name|merge
operator|.
name|optimize
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Just like {@link #expungeDeletes()}, except you can    *  specify whether the call should block until the    *  operation completes.  This is only meaningful with a    *  {@link MergeScheduler} that is able to run merges in    *  background threads.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    */
DECL|method|expungeDeletes
specifier|public
name|void
name|expungeDeletes
parameter_list|(
name|boolean
name|doWait
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"expungeDeletes: index now "
operator|+
name|segString
argument_list|()
argument_list|)
expr_stmt|;
name|MergePolicy
operator|.
name|MergeSpecification
name|spec
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|spec
operator|=
name|mergePolicy
operator|.
name|findMergesToExpungeDeletes
argument_list|(
name|segmentInfos
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|numMerges
init|=
name|spec
operator|.
name|merges
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numMerges
condition|;
name|i
operator|++
control|)
name|registerMerge
argument_list|(
name|spec
operator|.
name|merges
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|mergeScheduler
operator|.
name|merge
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
operator|&&
name|doWait
condition|)
block|{
specifier|final
name|int
name|numMerges
init|=
name|spec
operator|.
name|merges
operator|.
name|size
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|boolean
name|running
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|running
condition|)
block|{
if|if
condition|(
name|hitOOM
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"this writer hit an OutOfMemoryError; cannot complete expungeDeletes"
argument_list|)
throw|;
block|}
comment|// Check each merge that MergePolicy asked us to
comment|// do, to see if any of them are still running and
comment|// if any of them have hit an exception.
name|running
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numMerges
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
init|=
name|spec
operator|.
name|merges
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|pendingMerges
operator|.
name|contains
argument_list|(
name|merge
argument_list|)
operator|||
name|runningMerges
operator|.
name|contains
argument_list|(
name|merge
argument_list|)
condition|)
name|running
operator|=
literal|true
expr_stmt|;
name|Throwable
name|t
init|=
name|merge
operator|.
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|IOException
name|ioe
init|=
operator|new
name|IOException
argument_list|(
literal|"background merge hit exception: "
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|directory
argument_list|)
argument_list|)
decl_stmt|;
name|ioe
operator|.
name|initCause
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
block|}
comment|// If any of our merges are still running, wait:
if|if
condition|(
name|running
condition|)
name|doWait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// NOTE: in the ConcurrentMergeScheduler case, when
comment|// doWait is false, we can return immediately while
comment|// background threads accomplish the optimization
block|}
comment|/** Expunges all deletes from the index.  When an index    *  has many document deletions (or updates to existing    *  documents), it's best to either call optimize or    *  expungeDeletes to remove all unused data in the index    *  associated with the deleted documents.  To see how    *  many deletions you have pending in your index, call    *  {@link IndexReader#numDeletedDocs}    *  This saves disk space and memory usage while    *  searching.  expungeDeletes should be somewhat faster    *  than optimize since it does not insist on reducing the    *  index to a single segment (though, this depends on the    *  {@link MergePolicy}; see {@link    *  MergePolicy#findMergesToExpungeDeletes}.). Note that    *  this call does not first commit any buffered    *  documents, so you must do so yourself if necessary.    *  See also {@link #expungeDeletes(boolean)}    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    *  you should immediately close the writer.  See<a    *  href="#OOME">above</a> for details.</p>    */
DECL|method|expungeDeletes
specifier|public
name|void
name|expungeDeletes
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|expungeDeletes
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expert: asks the mergePolicy whether any merges are    * necessary now and if so, runs the requested merges and    * then iterate (test again if merges are needed) until no    * more merges are returned by the mergePolicy.    *    * Explicit calls to maybeMerge() are usually not    * necessary. The most common case is when merge policy    * parameters have changed.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    */
DECL|method|maybeMerge
specifier|public
specifier|final
name|void
name|maybeMerge
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|maybeMerge
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|maybeMerge
specifier|private
specifier|final
name|void
name|maybeMerge
parameter_list|(
name|boolean
name|optimize
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|maybeMerge
argument_list|(
literal|1
argument_list|,
name|optimize
argument_list|)
expr_stmt|;
block|}
DECL|method|maybeMerge
specifier|private
specifier|final
name|void
name|maybeMerge
parameter_list|(
name|int
name|maxNumSegmentsOptimize
parameter_list|,
name|boolean
name|optimize
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|updatePendingMerges
argument_list|(
name|maxNumSegmentsOptimize
argument_list|,
name|optimize
argument_list|)
expr_stmt|;
name|mergeScheduler
operator|.
name|merge
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|updatePendingMerges
specifier|private
specifier|synchronized
name|void
name|updatePendingMerges
parameter_list|(
name|int
name|maxNumSegmentsOptimize
parameter_list|,
name|boolean
name|optimize
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
assert|assert
operator|!
name|optimize
operator|||
name|maxNumSegmentsOptimize
operator|>
literal|0
assert|;
if|if
condition|(
name|stopMerges
condition|)
return|return;
comment|// Do not start new merges if we've hit OOME
if|if
condition|(
name|hitOOM
condition|)
block|{
return|return;
block|}
specifier|final
name|MergePolicy
operator|.
name|MergeSpecification
name|spec
decl_stmt|;
if|if
condition|(
name|optimize
condition|)
block|{
name|spec
operator|=
name|mergePolicy
operator|.
name|findMergesForOptimize
argument_list|(
name|segmentInfos
argument_list|,
name|maxNumSegmentsOptimize
argument_list|,
name|segmentsToOptimize
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|numMerges
init|=
name|spec
operator|.
name|merges
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numMerges
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
init|=
operator|(
name|spec
operator|.
name|merges
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
decl_stmt|;
name|merge
operator|.
name|optimize
operator|=
literal|true
expr_stmt|;
name|merge
operator|.
name|maxNumSegmentsOptimize
operator|=
name|maxNumSegmentsOptimize
expr_stmt|;
block|}
block|}
block|}
else|else
name|spec
operator|=
name|mergePolicy
operator|.
name|findMerges
argument_list|(
name|segmentInfos
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|numMerges
init|=
name|spec
operator|.
name|merges
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numMerges
condition|;
name|i
operator|++
control|)
name|registerMerge
argument_list|(
name|spec
operator|.
name|merges
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Expert: the {@link MergeScheduler} calls this method    *  to retrieve the next merge requested by the    *  MergePolicy */
DECL|method|getNextMerge
specifier|synchronized
name|MergePolicy
operator|.
name|OneMerge
name|getNextMerge
parameter_list|()
block|{
if|if
condition|(
name|pendingMerges
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
else|else
block|{
comment|// Advance the merge from pending to running
name|MergePolicy
operator|.
name|OneMerge
name|merge
init|=
name|pendingMerges
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
name|runningMerges
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
return|return
name|merge
return|;
block|}
block|}
comment|/** Like getNextMerge() except only returns a merge if it's    *  external. */
DECL|method|getNextExternalMerge
specifier|private
specifier|synchronized
name|MergePolicy
operator|.
name|OneMerge
name|getNextExternalMerge
parameter_list|()
block|{
if|if
condition|(
name|pendingMerges
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
else|else
block|{
name|Iterator
argument_list|<
name|MergePolicy
operator|.
name|OneMerge
argument_list|>
name|it
init|=
name|pendingMerges
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|MergePolicy
operator|.
name|OneMerge
name|merge
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|merge
operator|.
name|isExternal
condition|)
block|{
comment|// Advance the merge from pending to running
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|runningMerges
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
return|return
name|merge
return|;
block|}
block|}
comment|// All existing merges do not involve external segments
return|return
literal|null
return|;
block|}
block|}
comment|/*    * Begin a transaction.  During a transaction, any segment    * merges that happen (or ram segments flushed) will not    * write a new segments file and will not remove any files    * that were present at the start of the transaction.  You    * must make a matched (try/finally) call to    * commitTransaction() or rollbackTransaction() to finish    * the transaction.    *    * Note that buffered documents and delete terms are not handled    * within the transactions, so they must be flushed before the    * transaction is started.    */
DECL|method|startTransaction
specifier|private
specifier|synchronized
name|void
name|startTransaction
parameter_list|(
name|boolean
name|haveReadLock
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"now start transaction"
argument_list|)
expr_stmt|;
assert|assert
name|docWriter
operator|.
name|getNumBufferedDeleteTerms
argument_list|()
operator|==
literal|0
operator|:
literal|"calling startTransaction with buffered delete terms not supported: numBufferedDeleteTerms="
operator|+
name|docWriter
operator|.
name|getNumBufferedDeleteTerms
argument_list|()
assert|;
assert|assert
name|docWriter
operator|.
name|getNumDocsInRAM
argument_list|()
operator|==
literal|0
operator|:
literal|"calling startTransaction with buffered documents not supported: numDocsInRAM="
operator|+
name|docWriter
operator|.
name|getNumDocsInRAM
argument_list|()
assert|;
name|ensureOpen
argument_list|()
expr_stmt|;
comment|// If a transaction is trying to roll back (because
comment|// addIndexes hit an exception) then wait here until
comment|// that's done:
synchronized|synchronized
init|(
name|this
init|)
block|{
while|while
condition|(
name|stopMerges
condition|)
name|doWait
argument_list|()
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
comment|// Release the write lock if our caller held it, on
comment|// hitting an exception
if|if
condition|(
operator|!
name|success
operator|&&
name|haveReadLock
condition|)
name|releaseRead
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|haveReadLock
condition|)
block|{
name|upgradeReadToWrite
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|acquireWrite
argument_list|()
expr_stmt|;
block|}
name|success
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|localRollbackSegmentInfos
operator|=
operator|(
name|SegmentInfos
operator|)
name|segmentInfos
operator|.
name|clone
argument_list|()
expr_stmt|;
assert|assert
operator|!
name|hasExternalSegments
argument_list|()
assert|;
name|localFlushedDocCount
operator|=
name|docWriter
operator|.
name|getFlushedDocCount
argument_list|()
expr_stmt|;
comment|// We must "protect" our files at this point from
comment|// deletion in case we need to rollback:
name|deleter
operator|.
name|incRef
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
name|finishAddIndexes
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Rolls back the transaction and restores state to where    * we were at the start.    */
DECL|method|rollbackTransaction
specifier|private
specifier|synchronized
name|void
name|rollbackTransaction
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"now rollback transaction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|docWriter
operator|!=
literal|null
condition|)
block|{
name|docWriter
operator|.
name|setFlushedDocCount
argument_list|(
name|localFlushedDocCount
argument_list|)
expr_stmt|;
block|}
comment|// Must finish merges before rolling back segmentInfos
comment|// so merges don't hit exceptions on trying to commit
comment|// themselves, don't get files deleted out from under
comment|// them, etc:
name|finishMerges
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Keep the same segmentInfos instance but replace all
comment|// of its SegmentInfo instances.  This is so the next
comment|// attempt to commit using this instance of IndexWriter
comment|// will always write to a new generation ("write once").
name|segmentInfos
operator|.
name|clear
argument_list|()
expr_stmt|;
name|segmentInfos
operator|.
name|addAll
argument_list|(
name|localRollbackSegmentInfos
argument_list|)
expr_stmt|;
name|localRollbackSegmentInfos
operator|=
literal|null
expr_stmt|;
comment|// This must come after we rollback segmentInfos, so
comment|// that if a commit() kicks off it does not see the
comment|// segmentInfos with external segments
name|finishAddIndexes
argument_list|()
expr_stmt|;
comment|// Ask deleter to locate unreferenced files we had
comment|// created& remove them:
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Remove the incRef we did in startTransaction:
name|deleter
operator|.
name|decRef
argument_list|(
name|segmentInfos
argument_list|)
expr_stmt|;
comment|// Also ask deleter to remove any newly created files
comment|// that were never incref'd; this "garbage" is created
comment|// when a merge kicks off but aborts part way through
comment|// before it had a chance to incRef the files it had
comment|// partially created
name|deleter
operator|.
name|refresh
argument_list|()
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
assert|assert
operator|!
name|hasExternalSegments
argument_list|()
assert|;
block|}
comment|/*    * Commits the transaction.  This will write the new    * segments file and remove and pending deletions we have    * accumulated during the transaction    */
DECL|method|commitTransaction
specifier|private
specifier|synchronized
name|void
name|commitTransaction
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"now commit transaction"
argument_list|)
expr_stmt|;
comment|// Give deleter a chance to remove files now:
name|checkpoint
argument_list|()
expr_stmt|;
comment|// Remove the incRef we did in startTransaction.
name|deleter
operator|.
name|decRef
argument_list|(
name|localRollbackSegmentInfos
argument_list|)
expr_stmt|;
name|localRollbackSegmentInfos
operator|=
literal|null
expr_stmt|;
assert|assert
operator|!
name|hasExternalSegments
argument_list|()
assert|;
name|finishAddIndexes
argument_list|()
expr_stmt|;
block|}
comment|/**    * Close the<code>IndexWriter</code> without committing    * any changes that have occurred since the last commit    * (or since it was opened, if commit hasn't been called).    * This removes any temporary files that had been created,    * after which the state of the index will be the same as    * it was when commit() was last called or when this    * writer was first opened.  This also clears a previous    * call to {@link #prepareCommit}.    * @throws IOException if there is a low-level IO error    */
DECL|method|rollback
specifier|public
name|void
name|rollback
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
comment|// Ensure that only one thread actually gets to do the closing:
if|if
condition|(
name|shouldClose
argument_list|()
condition|)
name|rollbackInternal
argument_list|()
expr_stmt|;
block|}
DECL|method|rollbackInternal
specifier|private
name|void
name|rollbackInternal
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|docWriter
operator|.
name|pauseAllThreads
argument_list|()
expr_stmt|;
try|try
block|{
name|finishMerges
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Must pre-close these two, in case they increment
comment|// changeCount so that we can then set it to false
comment|// before calling closeInternal
name|mergePolicy
operator|.
name|close
argument_list|()
expr_stmt|;
name|mergeScheduler
operator|.
name|close
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|pendingCommit
operator|!=
literal|null
condition|)
block|{
name|pendingCommit
operator|.
name|rollbackCommit
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|decRef
argument_list|(
name|pendingCommit
argument_list|)
expr_stmt|;
name|pendingCommit
operator|=
literal|null
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|// Keep the same segmentInfos instance but replace all
comment|// of its SegmentInfo instances.  This is so the next
comment|// attempt to commit using this instance of IndexWriter
comment|// will always write to a new generation ("write
comment|// once").
name|segmentInfos
operator|.
name|clear
argument_list|()
expr_stmt|;
name|segmentInfos
operator|.
name|addAll
argument_list|(
name|rollbackSegmentInfos
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|hasExternalSegments
argument_list|()
assert|;
name|docWriter
operator|.
name|abort
argument_list|()
expr_stmt|;
assert|assert
name|testPoint
argument_list|(
literal|"rollback before checkpoint"
argument_list|)
assert|;
comment|// Ask deleter to locate unreferenced files& remove
comment|// them:
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|refresh
argument_list|()
expr_stmt|;
block|}
comment|// Don't bother saving any changes in our segmentInfos
name|readerPool
operator|.
name|clear
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|lastCommitChangeCount
operator|=
name|changeCount
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"rollbackInternal"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|docWriter
operator|.
name|resumeAllThreads
argument_list|()
expr_stmt|;
name|closing
operator|=
literal|false
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"hit exception during rollback"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|closeInternal
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete all documents in the index.    *    *<p>This method will drop all buffered documents and will     *    remove all segments from the index. This change will not be    *    visible until a {@link #commit()} has been called. This method    *    can be rolled back using {@link #rollback()}.</p>    *    *<p>NOTE: this method is much faster than using deleteDocuments( new MatchAllDocsQuery() ).</p>    *    *<p>NOTE: this method will forcefully abort all merges    *    in progress.  If other threads are running {@link    *    #optimize()} or any of the addIndexes methods, they    *    will receive {@link MergePolicy.MergeAbortedException}s.    */
DECL|method|deleteAll
specifier|public
specifier|synchronized
name|void
name|deleteAll
parameter_list|()
throws|throws
name|IOException
block|{
name|docWriter
operator|.
name|pauseAllThreads
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Abort any running merges
name|finishMerges
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Remove any buffered docs
name|docWriter
operator|.
name|abort
argument_list|()
expr_stmt|;
name|docWriter
operator|.
name|setFlushedDocCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Remove all segments
name|segmentInfos
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Ask deleter to locate unreferenced files& remove them:
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|refresh
argument_list|()
expr_stmt|;
comment|// Don't bother saving any changes in our segmentInfos
name|readerPool
operator|.
name|clear
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// Mark that the index has changed
operator|++
name|changeCount
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"deleteAll"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|docWriter
operator|.
name|resumeAllThreads
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"hit exception during deleteAll"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|finishMerges
specifier|private
specifier|synchronized
name|void
name|finishMerges
parameter_list|(
name|boolean
name|waitForMerges
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|waitForMerges
condition|)
block|{
name|stopMerges
operator|=
literal|true
expr_stmt|;
comment|// Abort all pending& running merges:
for|for
control|(
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
range|:
name|pendingMerges
control|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"now abort pending merge "
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|directory
argument_list|)
argument_list|)
expr_stmt|;
name|merge
operator|.
name|abort
argument_list|()
expr_stmt|;
name|mergeFinish
argument_list|(
name|merge
argument_list|)
expr_stmt|;
block|}
name|pendingMerges
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
range|:
name|runningMerges
control|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"now abort running merge "
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|directory
argument_list|)
argument_list|)
expr_stmt|;
name|merge
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
comment|// Ensure any running addIndexes finishes.  It's fine
comment|// if a new one attempts to start because its merges
comment|// will quickly see the stopMerges == true and abort.
name|acquireRead
argument_list|()
expr_stmt|;
name|releaseRead
argument_list|()
expr_stmt|;
comment|// These merges periodically check whether they have
comment|// been aborted, and stop if so.  We wait here to make
comment|// sure they all stop.  It should not take very long
comment|// because the merge threads periodically check if
comment|// they are aborted.
while|while
condition|(
name|runningMerges
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"now wait for "
operator|+
name|runningMerges
operator|.
name|size
argument_list|()
operator|+
literal|" running merge to abort"
argument_list|)
expr_stmt|;
name|doWait
argument_list|()
expr_stmt|;
block|}
name|stopMerges
operator|=
literal|false
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
assert|assert
literal|0
operator|==
name|mergingSegments
operator|.
name|size
argument_list|()
assert|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"all running merges have aborted"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// waitForMerges() will ensure any running addIndexes finishes.
comment|// It's fine if a new one attempts to start because from our
comment|// caller above the call will see that we are in the
comment|// process of closing, and will throw an
comment|// AlreadyClosedException.
name|waitForMerges
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Wait for any currently outstanding merges to finish.    *    *<p>It is guaranteed that any merges started prior to calling this method     *    will have completed once this method completes.</p>    */
DECL|method|waitForMerges
specifier|public
specifier|synchronized
name|void
name|waitForMerges
parameter_list|()
block|{
comment|// Ensure any running addIndexes finishes.
name|acquireRead
argument_list|()
expr_stmt|;
name|releaseRead
argument_list|()
expr_stmt|;
while|while
condition|(
name|pendingMerges
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|||
name|runningMerges
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|doWait
argument_list|()
expr_stmt|;
block|}
comment|// sanity check
assert|assert
literal|0
operator|==
name|mergingSegments
operator|.
name|size
argument_list|()
assert|;
block|}
comment|/*    * Called whenever the SegmentInfos has been updated and    * the index files referenced exist (correctly) in the    * index directory.    */
DECL|method|checkpoint
specifier|private
specifier|synchronized
name|void
name|checkpoint
parameter_list|()
throws|throws
name|IOException
block|{
name|changeCount
operator|++
expr_stmt|;
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|finishAddIndexes
specifier|private
name|void
name|finishAddIndexes
parameter_list|()
block|{
name|releaseWrite
argument_list|()
expr_stmt|;
block|}
DECL|method|blockAddIndexes
specifier|private
name|void
name|blockAddIndexes
parameter_list|(
name|boolean
name|includePendingClose
parameter_list|)
block|{
name|acquireRead
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// Make sure we are still open since we could have
comment|// waited quite a while for last addIndexes to finish
name|ensureOpen
argument_list|(
name|includePendingClose
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
name|releaseRead
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|resumeAddIndexes
specifier|private
name|void
name|resumeAddIndexes
parameter_list|()
block|{
name|releaseRead
argument_list|()
expr_stmt|;
block|}
DECL|method|resetMergeExceptions
specifier|private
specifier|synchronized
name|void
name|resetMergeExceptions
parameter_list|()
block|{
name|mergeExceptions
operator|=
operator|new
name|ArrayList
argument_list|<
name|MergePolicy
operator|.
name|OneMerge
argument_list|>
argument_list|()
expr_stmt|;
name|mergeGen
operator|++
expr_stmt|;
block|}
DECL|method|noDupDirs
specifier|private
name|void
name|noDupDirs
parameter_list|(
name|Directory
modifier|...
name|dirs
parameter_list|)
block|{
name|HashSet
argument_list|<
name|Directory
argument_list|>
name|dups
init|=
operator|new
name|HashSet
argument_list|<
name|Directory
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dups
operator|.
name|contains
argument_list|(
name|dirs
index|[
name|i
index|]
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Directory "
operator|+
name|dirs
index|[
name|i
index|]
operator|+
literal|" appears more than once"
argument_list|)
throw|;
if|if
condition|(
name|dirs
index|[
name|i
index|]
operator|==
name|directory
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot add directory to itself"
argument_list|)
throw|;
name|dups
operator|.
name|add
argument_list|(
name|dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Merges all segments from an array of indexes into this    * index.    *    *<p>This may be used to parallelize batch indexing.  A large document    * collection can be broken into sub-collections.  Each sub-collection can be    * indexed in parallel, on a different thread, process or machine.  The    * complete index can then be created by merging sub-collection indexes    * with this method.    *    *<p><b>NOTE:</b> the index in each Directory must not be    * changed (opened by a writer) while this method is    * running.  This method does not acquire a write lock in    * each input Directory, so it is up to the caller to    * enforce this.    *    *<p><b>NOTE:</b> while this is running, any attempts to    * add or delete documents (with another thread) will be    * paused until this method completes.    *    *<p>This method is transactional in how Exceptions are    * handled: it does not commit a new segments_N file until    * all indexes are added.  This means if an Exception    * occurs (for example disk full), then either no indexes    * will have been added or they all will have been.</p>    *    *<p>Note that this requires temporary free space in the    * Directory up to 2X the sum of all input indexes    * (including the starting index).  If readers/searchers    * are open against the starting index, then temporary    * free space required will be higher by the size of the    * starting index (see {@link #optimize()} for details).    *</p>    *    *<p>Once this completes, the final size of the index    * will be less than the sum of all input index sizes    * (including the starting index).  It could be quite a    * bit smaller (if there were many pending deletes) or    * just slightly smaller.</p>    *     *<p>    * This requires this index not be among those to be added.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|addIndexesNoOptimize
specifier|public
name|void
name|addIndexesNoOptimize
parameter_list|(
name|Directory
modifier|...
name|dirs
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|noDupDirs
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
comment|// Do not allow add docs or deletes while we are running:
name|docWriter
operator|.
name|pauseAllThreads
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"flush at addIndexesNoOptimize"
argument_list|)
expr_stmt|;
name|flush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|startTransaction
argument_list|(
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|int
name|docCount
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|directory
operator|==
name|dirs
index|[
name|i
index|]
condition|)
block|{
comment|// cannot add this index: segments may be deleted in merge before added
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot add this index to itself"
argument_list|)
throw|;
block|}
name|SegmentInfos
name|sis
init|=
operator|new
name|SegmentInfos
argument_list|()
decl_stmt|;
comment|// read infos from dir
name|sis
operator|.
name|read
argument_list|(
name|dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|sis
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|SegmentInfo
name|info
init|=
name|sis
operator|.
name|info
argument_list|(
name|j
argument_list|)
decl_stmt|;
assert|assert
operator|!
name|segmentInfos
operator|.
name|contains
argument_list|(
name|info
argument_list|)
operator|:
literal|"dup info dir="
operator|+
name|info
operator|.
name|dir
operator|+
literal|" name="
operator|+
name|info
operator|.
name|name
assert|;
name|docCount
operator|+=
name|info
operator|.
name|docCount
expr_stmt|;
name|segmentInfos
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|// add each info
block|}
block|}
block|}
comment|// Notify DocumentsWriter that the flushed count just increased
name|docWriter
operator|.
name|updateFlushedDocCount
argument_list|(
name|docCount
argument_list|)
expr_stmt|;
name|maybeMerge
argument_list|()
expr_stmt|;
name|ensureOpen
argument_list|()
expr_stmt|;
comment|// If after merging there remain segments in the index
comment|// that are in a different directory, just copy these
comment|// over into our index.  This is necessary (before
comment|// finishing the transaction) to avoid leaving the
comment|// index in an unusable (inconsistent) state.
name|resolveExternalSegments
argument_list|()
expr_stmt|;
name|ensureOpen
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|commitTransaction
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rollbackTransaction
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"addIndexesNoOptimize"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|docWriter
operator|!=
literal|null
condition|)
block|{
name|docWriter
operator|.
name|resumeAllThreads
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|hasExternalSegments
specifier|private
name|boolean
name|hasExternalSegments
parameter_list|()
block|{
return|return
name|segmentInfos
operator|.
name|hasExternalSegments
argument_list|(
name|directory
argument_list|)
return|;
block|}
comment|/* If any of our segments are using a directory != ours    * then we have to either copy them over one by one, merge    * them (if merge policy has chosen to) or wait until    * currently running merges (in the background) complete.    * We don't return until the SegmentInfos has no more    * external segments.  Currently this is only used by    * addIndexesNoOptimize(). */
DECL|method|resolveExternalSegments
specifier|private
name|void
name|resolveExternalSegments
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|boolean
name|any
init|=
literal|false
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|SegmentInfo
name|info
init|=
literal|null
decl_stmt|;
name|MergePolicy
operator|.
name|OneMerge
name|merge
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|stopMerges
condition|)
throw|throw
operator|new
name|MergePolicy
operator|.
name|MergeAbortedException
argument_list|(
literal|"rollback() was called or addIndexes* hit an unhandled exception"
argument_list|)
throw|;
specifier|final
name|int
name|numSegments
init|=
name|segmentInfos
operator|.
name|size
argument_list|()
decl_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
condition|;
name|i
operator|++
control|)
block|{
name|info
operator|=
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|dir
operator|!=
name|directory
condition|)
block|{
name|done
operator|=
literal|false
expr_stmt|;
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|newMerge
init|=
operator|new
name|MergePolicy
operator|.
name|OneMerge
argument_list|(
name|segmentInfos
operator|.
name|range
argument_list|(
name|i
argument_list|,
literal|1
operator|+
name|i
argument_list|)
argument_list|,
name|mergePolicy
operator|instanceof
name|LogMergePolicy
operator|&&
name|getUseCompoundFile
argument_list|()
argument_list|)
decl_stmt|;
comment|// Returns true if no running merge conflicts
comment|// with this one (and, records this merge as
comment|// pending), ie, this segment is not currently
comment|// being merged:
if|if
condition|(
name|registerMerge
argument_list|(
name|newMerge
argument_list|)
condition|)
block|{
name|merge
operator|=
name|newMerge
expr_stmt|;
comment|// If this segment is not currently being
comment|// merged, then advance it to running& run
comment|// the merge ourself (below):
name|pendingMerges
operator|.
name|remove
argument_list|(
name|merge
argument_list|)
expr_stmt|;
name|runningMerges
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|done
operator|&&
name|merge
operator|==
literal|null
condition|)
comment|// We are not yet done (external segments still
comment|// exist in segmentInfos), yet, all such segments
comment|// are currently "covered" by a pending or running
comment|// merge.  We now try to grab any pending merge
comment|// that involves external segments:
name|merge
operator|=
name|getNextExternalMerge
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|done
operator|&&
name|merge
operator|==
literal|null
condition|)
comment|// We are not yet done, and, all external segments
comment|// fall under merges that the merge scheduler is
comment|// currently running.  So, we now wait and check
comment|// back to see if the merge has completed.
name|doWait
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|merge
operator|!=
literal|null
condition|)
block|{
name|any
operator|=
literal|true
expr_stmt|;
name|merge
argument_list|(
name|merge
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|any
condition|)
comment|// Sometimes, on copying an external segment over,
comment|// more merges may become necessary:
name|mergeScheduler
operator|.
name|merge
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/** Merges the provided indexes into this index.    *<p>After this completes, the index is optimized.</p>    *<p>The provided IndexReaders are not closed.</p>    *    *<p><b>NOTE:</b> while this is running, any attempts to    * add or delete documents (with another thread) will be    * paused until this method completes.    *    *<p>See {@link #addIndexesNoOptimize} for    * details on transactional semantics, temporary free    * space required in the Directory, and non-CFS segments    * on an Exception.</p>    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|addIndexes
specifier|public
name|void
name|addIndexes
parameter_list|(
name|IndexReader
modifier|...
name|readers
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
comment|// Do not allow add docs or deletes while we are running:
name|docWriter
operator|.
name|pauseAllThreads
argument_list|()
expr_stmt|;
comment|// We must pre-acquire a read lock here (and upgrade to
comment|// write lock in startTransaction below) so that no
comment|// other addIndexes is allowed to start up after we have
comment|// flushed& optimized but before we then start our
comment|// transaction.  This is because the merging below
comment|// requires that only one segment is present in the
comment|// index:
name|acquireRead
argument_list|()
expr_stmt|;
try|try
block|{
name|SegmentInfo
name|info
init|=
literal|null
decl_stmt|;
name|String
name|mergedName
init|=
literal|null
decl_stmt|;
name|SegmentMerger
name|merger
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|flush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|optimize
argument_list|()
expr_stmt|;
comment|// start with zero or 1 seg
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
comment|// Take care to release the read lock if we hit an
comment|// exception before starting the transaction
if|if
condition|(
operator|!
name|success
condition|)
name|releaseRead
argument_list|()
expr_stmt|;
block|}
comment|// true means we already have a read lock; if this
comment|// call hits an exception it will release the write
comment|// lock:
name|startTransaction
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|mergedName
operator|=
name|newSegmentName
argument_list|()
expr_stmt|;
name|merger
operator|=
operator|new
name|SegmentMerger
argument_list|(
name|this
argument_list|,
name|mergedName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|SegmentReader
name|sReader
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|segmentInfos
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// add existing index, if any
name|sReader
operator|=
name|readerPool
operator|.
name|get
argument_list|(
name|segmentInfos
operator|.
name|info
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|true
argument_list|,
name|BufferedIndexInput
operator|.
name|BUFFER_SIZE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|success
operator|=
literal|false
expr_stmt|;
try|try
block|{
if|if
condition|(
name|sReader
operator|!=
literal|null
condition|)
name|merger
operator|.
name|add
argument_list|(
name|sReader
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|readers
operator|.
name|length
condition|;
name|i
operator|++
control|)
comment|// add new indexes
name|merger
operator|.
name|add
argument_list|(
name|readers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|int
name|docCount
init|=
name|merger
operator|.
name|merge
argument_list|()
decl_stmt|;
comment|// merge 'em
synchronized|synchronized
init|(
name|this
init|)
block|{
name|segmentInfos
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// pop old infos& add new
name|info
operator|=
operator|new
name|SegmentInfo
argument_list|(
name|mergedName
argument_list|,
name|docCount
argument_list|,
name|directory
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|merger
operator|.
name|hasProx
argument_list|()
argument_list|)
expr_stmt|;
name|setDiagnostics
argument_list|(
name|info
argument_list|,
literal|"addIndexes(IndexReader...)"
argument_list|)
expr_stmt|;
name|segmentInfos
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
comment|// Notify DocumentsWriter that the flushed count just increased
name|docWriter
operator|.
name|updateFlushedDocCount
argument_list|(
name|docCount
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|sReader
operator|!=
literal|null
condition|)
block|{
name|readerPool
operator|.
name|release
argument_list|(
name|sReader
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"hit exception in addIndexes during merge"
argument_list|)
expr_stmt|;
name|rollbackTransaction
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|commitTransaction
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mergePolicy
operator|instanceof
name|LogMergePolicy
operator|&&
name|getUseCompoundFile
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|files
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Must incRef our files so that if another thread
comment|// is running merge/optimize, it doesn't delete our
comment|// segment's files before we have a change to
comment|// finish making the compound file.
if|if
condition|(
name|segmentInfos
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|files
operator|=
name|info
operator|.
name|files
argument_list|()
expr_stmt|;
name|deleter
operator|.
name|incRef
argument_list|(
name|files
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|files
operator|!=
literal|null
condition|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
name|startTransaction
argument_list|(
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|merger
operator|.
name|createCompoundFile
argument_list|(
name|mergedName
operator|+
literal|".cfs"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|info
operator|.
name|setUseCompoundFile
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|deleter
operator|.
name|decRef
argument_list|(
name|files
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"hit exception building compound file in addIndexes during merge"
argument_list|)
expr_stmt|;
name|rollbackTransaction
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|commitTransaction
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"addIndexes(IndexReader...)"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|docWriter
operator|!=
literal|null
condition|)
block|{
name|docWriter
operator|.
name|resumeAllThreads
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// This is called after pending added and deleted
comment|// documents have been flushed to the Directory but before
comment|// the change is committed (new segments_N file written).
DECL|method|doAfterFlush
name|void
name|doAfterFlush
parameter_list|()
throws|throws
name|IOException
block|{   }
comment|/** Expert: prepare for commit.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @see #prepareCommit(Map) */
DECL|method|prepareCommit
specifier|public
specifier|final
name|void
name|prepareCommit
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|prepareCommit
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**<p>Expert: prepare for commit, specifying    *  commitUserData Map (String -> String).  This does the    *  first phase of 2-phase commit. This method does all    *  steps necessary to commit changes since this writer    *  was opened: flushes pending added and deleted docs,    *  syncs the index files, writes most of next segments_N    *  file.  After calling this you must call either {@link    *  #commit()} to finish the commit, or {@link    *  #rollback()} to revert the commit and undo all changes    *  done since the writer was opened.</p>    *     *  You can also just call {@link #commit(Map)} directly    *  without prepareCommit first in which case that method    *  will internally call prepareCommit.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    *  you should immediately close the writer.  See<a    *  href="#OOME">above</a> for details.</p>    *    *  @param commitUserData Opaque Map (String->String)    *  that's recorded into the segments file in the index,    *  and retrievable by {@link    *  IndexReader#getCommitUserData}.  Note that when    *  IndexWriter commits itself during {@link #close}, the    *  commitUserData is unchanged (just carried over from    *  the prior commit).  If this is null then the previous    *  commitUserData is kept.  Also, the commitUserData will    *  only "stick" if there are actually changes in the    *  index to commit.    */
DECL|method|prepareCommit
specifier|public
specifier|final
name|void
name|prepareCommit
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commitUserData
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
if|if
condition|(
name|hitOOM
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"this writer hit an OutOfMemoryError; cannot commit"
argument_list|)
throw|;
block|}
if|if
condition|(
name|pendingCommit
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"prepareCommit was already called with no corresponding call to commit"
argument_list|)
throw|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"prepareCommit: flush"
argument_list|)
expr_stmt|;
name|flush
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|startCommit
argument_list|(
literal|0
argument_list|,
name|commitUserData
argument_list|)
expr_stmt|;
block|}
DECL|method|commit
specifier|private
name|void
name|commit
parameter_list|(
name|long
name|sizeInBytes
parameter_list|)
throws|throws
name|IOException
block|{
name|startCommit
argument_list|(
name|sizeInBytes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|finishCommit
argument_list|()
expr_stmt|;
block|}
comment|/**    *<p>Commits all pending changes (added& deleted    * documents, optimizations, segment merges, added    * indexes, etc.) to the index, and syncs all referenced    * index files, such that a reader will see the changes    * and the index updates will survive an OS or machine    * crash or power loss.  Note that this does not wait for    * any running background merges to finish.  This may be a    * costly operation, so you should test the cost in your    * application and do it only when really necessary.</p>    *    *<p> Note that this operation calls Directory.sync on    * the index files.  That call should not return until the    * file contents& metadata are on stable storage.  For    * FSDirectory, this calls the OS's fsync.  But, beware:    * some hardware devices may in fact cache writes even    * during fsync, and return before the bits are actually    * on stable storage, to give the appearance of faster    * performance.  If you have such a device, and it does    * not have a battery backup (for example) then on power    * loss it may still lose data.  Lucene cannot guarantee    * consistency on such devices.</p>    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @see #prepareCommit    * @see #commit(Map)    */
DECL|method|commit
specifier|public
specifier|final
name|void
name|commit
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|commit
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/** Commits all changes to the index, specifying a    *  commitUserData Map (String -> String).  This just    *  calls {@link #prepareCommit(Map)} (if you didn't    *  already call it) and then {@link #finishCommit}.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    */
DECL|method|commit
specifier|public
specifier|final
name|void
name|commit
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commitUserData
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"commit: start"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pendingCommit
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"commit: now prepare"
argument_list|)
expr_stmt|;
name|prepareCommit
argument_list|(
name|commitUserData
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"commit: already prepared"
argument_list|)
expr_stmt|;
name|finishCommit
argument_list|()
expr_stmt|;
block|}
DECL|method|finishCommit
specifier|private
specifier|synchronized
specifier|final
name|void
name|finishCommit
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
if|if
condition|(
name|pendingCommit
operator|!=
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"commit: pendingCommit != null"
argument_list|)
expr_stmt|;
name|pendingCommit
operator|.
name|finishCommit
argument_list|(
name|directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"commit: wrote segments file \""
operator|+
name|pendingCommit
operator|.
name|getCurrentSegmentFileName
argument_list|()
operator|+
literal|"\""
argument_list|)
expr_stmt|;
name|lastCommitChangeCount
operator|=
name|pendingCommitChangeCount
expr_stmt|;
name|segmentInfos
operator|.
name|updateGeneration
argument_list|(
name|pendingCommit
argument_list|)
expr_stmt|;
name|segmentInfos
operator|.
name|setUserData
argument_list|(
name|pendingCommit
operator|.
name|getUserData
argument_list|()
argument_list|)
expr_stmt|;
name|setRollbackSegmentInfos
argument_list|(
name|pendingCommit
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|checkpoint
argument_list|(
name|pendingCommit
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|deleter
operator|.
name|decRef
argument_list|(
name|pendingCommit
argument_list|)
expr_stmt|;
name|pendingCommit
operator|=
literal|null
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"commit: pendingCommit == null; skip"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"commit: done"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Flush all in-memory buffered udpates (adds and deletes)    * to the Directory.    * @param triggerMerge if true, we may merge segments (if    *  deletes or docs were flushed) if necessary    * @param flushDocStores if false we are allowed to keep    *  doc stores open to share with the next segment    * @param flushDeletes whether pending deletes should also    *  be flushed    */
DECL|method|flush
specifier|protected
specifier|final
name|void
name|flush
parameter_list|(
name|boolean
name|triggerMerge
parameter_list|,
name|boolean
name|flushDocStores
parameter_list|,
name|boolean
name|flushDeletes
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
comment|// We can be called during close, when closing==true, so we must pass false to ensureOpen:
name|ensureOpen
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|doFlush
argument_list|(
name|flushDocStores
argument_list|,
name|flushDeletes
argument_list|)
operator|&&
name|triggerMerge
condition|)
name|maybeMerge
argument_list|()
expr_stmt|;
block|}
comment|// TODO: this method should not have to be entirely
comment|// synchronized, ie, merges should be allowed to commit
comment|// even while a flush is happening
DECL|method|doFlush
specifier|private
specifier|synchronized
specifier|final
name|boolean
name|doFlush
parameter_list|(
name|boolean
name|flushDocStores
parameter_list|,
name|boolean
name|flushDeletes
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
try|try
block|{
return|return
name|doFlushInternal
argument_list|(
name|flushDocStores
argument_list|,
name|flushDeletes
argument_list|)
return|;
block|}
finally|finally
block|{
name|docWriter
operator|.
name|clearFlushPending
argument_list|()
expr_stmt|;
block|}
block|}
comment|// TODO: this method should not have to be entirely
comment|// synchronized, ie, merges should be allowed to commit
comment|// even while a flush is happening
DECL|method|doFlushInternal
specifier|private
specifier|synchronized
specifier|final
name|boolean
name|doFlushInternal
parameter_list|(
name|boolean
name|flushDocStores
parameter_list|,
name|boolean
name|flushDeletes
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
if|if
condition|(
name|hitOOM
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"this writer hit an OutOfMemoryError; cannot flush"
argument_list|)
throw|;
block|}
name|ensureOpen
argument_list|(
literal|false
argument_list|)
expr_stmt|;
assert|assert
name|testPoint
argument_list|(
literal|"startDoFlush"
argument_list|)
assert|;
name|flushCount
operator|++
expr_stmt|;
comment|// If we are flushing because too many deletes
comment|// accumulated, then we should apply the deletes to free
comment|// RAM:
name|flushDeletes
operator||=
name|docWriter
operator|.
name|doApplyDeletes
argument_list|()
expr_stmt|;
comment|// Make sure no threads are actively adding a document.
comment|// Returns true if docWriter is currently aborting, in
comment|// which case we skip flushing this segment
if|if
condition|(
name|docWriter
operator|.
name|pauseAllThreads
argument_list|()
condition|)
block|{
name|docWriter
operator|.
name|resumeAllThreads
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
try|try
block|{
name|SegmentInfo
name|newSegment
init|=
literal|null
decl_stmt|;
specifier|final
name|int
name|numDocs
init|=
name|docWriter
operator|.
name|getNumDocsInRAM
argument_list|()
decl_stmt|;
comment|// Always flush docs if there are any
name|boolean
name|flushDocs
init|=
name|numDocs
operator|>
literal|0
decl_stmt|;
name|String
name|docStoreSegment
init|=
name|docWriter
operator|.
name|getDocStoreSegment
argument_list|()
decl_stmt|;
assert|assert
name|docStoreSegment
operator|!=
literal|null
operator|||
name|numDocs
operator|==
literal|0
operator|:
literal|"dss="
operator|+
name|docStoreSegment
operator|+
literal|" numDocs="
operator|+
name|numDocs
assert|;
if|if
condition|(
name|docStoreSegment
operator|==
literal|null
condition|)
name|flushDocStores
operator|=
literal|false
expr_stmt|;
name|int
name|docStoreOffset
init|=
name|docWriter
operator|.
name|getDocStoreOffset
argument_list|()
decl_stmt|;
name|boolean
name|docStoreIsCompoundFile
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"  flush: segment="
operator|+
name|docWriter
operator|.
name|getSegment
argument_list|()
operator|+
literal|" docStoreSegment="
operator|+
name|docWriter
operator|.
name|getDocStoreSegment
argument_list|()
operator|+
literal|" docStoreOffset="
operator|+
name|docStoreOffset
operator|+
literal|" flushDocs="
operator|+
name|flushDocs
operator|+
literal|" flushDeletes="
operator|+
name|flushDeletes
operator|+
literal|" flushDocStores="
operator|+
name|flushDocStores
operator|+
literal|" numDocs="
operator|+
name|numDocs
operator|+
literal|" numBufDelTerms="
operator|+
name|docWriter
operator|.
name|getNumBufferedDeleteTerms
argument_list|()
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"  index before flush "
operator|+
name|segString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Check if the doc stores must be separately flushed
comment|// because other segments, besides the one we are about
comment|// to flush, reference it
if|if
condition|(
name|flushDocStores
operator|&&
operator|(
operator|!
name|flushDocs
operator|||
operator|!
name|docWriter
operator|.
name|getSegment
argument_list|()
operator|.
name|equals
argument_list|(
name|docWriter
operator|.
name|getDocStoreSegment
argument_list|()
argument_list|)
operator|)
condition|)
block|{
comment|// We must separately flush the doc store
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"  flush shared docStore segment "
operator|+
name|docStoreSegment
argument_list|)
expr_stmt|;
name|docStoreIsCompoundFile
operator|=
name|flushDocStores
argument_list|()
expr_stmt|;
name|flushDocStores
operator|=
literal|false
expr_stmt|;
block|}
name|String
name|segment
init|=
name|docWriter
operator|.
name|getSegment
argument_list|()
decl_stmt|;
comment|// If we are flushing docs, segment must not be null:
assert|assert
name|segment
operator|!=
literal|null
operator|||
operator|!
name|flushDocs
assert|;
if|if
condition|(
name|flushDocs
condition|)
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
specifier|final
name|int
name|flushedDocCount
decl_stmt|;
try|try
block|{
name|flushedDocCount
operator|=
name|docWriter
operator|.
name|flush
argument_list|(
name|flushDocStores
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"hit exception flushing segment "
operator|+
name|segment
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|refresh
argument_list|(
name|segment
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|0
operator|==
name|docStoreOffset
operator|&&
name|flushDocStores
condition|)
block|{
comment|// This means we are flushing private doc stores
comment|// with this segment, so it will not be shared
comment|// with other segments
assert|assert
name|docStoreSegment
operator|!=
literal|null
assert|;
assert|assert
name|docStoreSegment
operator|.
name|equals
argument_list|(
name|segment
argument_list|)
assert|;
name|docStoreOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|docStoreIsCompoundFile
operator|=
literal|false
expr_stmt|;
name|docStoreSegment
operator|=
literal|null
expr_stmt|;
block|}
comment|// Create new SegmentInfo, but do not add to our
comment|// segmentInfos until deletes are flushed
comment|// successfully.
name|newSegment
operator|=
operator|new
name|SegmentInfo
argument_list|(
name|segment
argument_list|,
name|flushedDocCount
argument_list|,
name|directory
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
name|docStoreOffset
argument_list|,
name|docStoreSegment
argument_list|,
name|docStoreIsCompoundFile
argument_list|,
name|docWriter
operator|.
name|hasProx
argument_list|()
argument_list|)
expr_stmt|;
name|setDiagnostics
argument_list|(
name|newSegment
argument_list|,
literal|"flush"
argument_list|)
expr_stmt|;
block|}
name|docWriter
operator|.
name|pushDeletes
argument_list|()
expr_stmt|;
if|if
condition|(
name|flushDocs
condition|)
block|{
name|segmentInfos
operator|.
name|add
argument_list|(
name|newSegment
argument_list|)
expr_stmt|;
name|checkpoint
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flushDocs
operator|&&
name|mergePolicy
operator|.
name|useCompoundFile
argument_list|(
name|segmentInfos
argument_list|,
name|newSegment
argument_list|)
condition|)
block|{
comment|// Now build compound file
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|docWriter
operator|.
name|createCompoundFile
argument_list|(
name|segment
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"hit exception creating compound file for newly flushed segment "
operator|+
name|segment
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|deleteFile
argument_list|(
name|segment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|COMPOUND_FILE_EXTENSION
argument_list|)
expr_stmt|;
block|}
block|}
name|newSegment
operator|.
name|setUseCompoundFile
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|checkpoint
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flushDeletes
condition|)
block|{
name|flushDeletesCount
operator|++
expr_stmt|;
name|applyDeletes
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flushDocs
condition|)
name|checkpoint
argument_list|()
expr_stmt|;
name|doAfterFlush
argument_list|()
expr_stmt|;
return|return
name|flushDocs
return|;
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"doFlush"
argument_list|)
expr_stmt|;
comment|// never hit
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|docWriter
operator|.
name|resumeAllThreads
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Expert:  Return the total size of all index files currently cached in memory.    * Useful for size management with flushRamDocs()    */
DECL|method|ramSizeInBytes
specifier|public
specifier|final
name|long
name|ramSizeInBytes
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|docWriter
operator|.
name|getRAMUsed
argument_list|()
return|;
block|}
comment|/** Expert:  Return the number of documents currently    *  buffered in RAM. */
DECL|method|numRamDocs
specifier|public
specifier|final
specifier|synchronized
name|int
name|numRamDocs
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|docWriter
operator|.
name|getNumDocsInRAM
argument_list|()
return|;
block|}
DECL|method|ensureContiguousMerge
specifier|private
name|int
name|ensureContiguousMerge
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
block|{
name|int
name|first
init|=
name|segmentInfos
operator|.
name|indexOf
argument_list|(
name|merge
operator|.
name|segments
operator|.
name|info
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
operator|==
operator|-
literal|1
condition|)
throw|throw
operator|new
name|MergePolicy
operator|.
name|MergeException
argument_list|(
literal|"could not find segment "
operator|+
name|merge
operator|.
name|segments
operator|.
name|info
argument_list|(
literal|0
argument_list|)
operator|.
name|name
operator|+
literal|" in current index "
operator|+
name|segString
argument_list|()
argument_list|,
name|directory
argument_list|)
throw|;
specifier|final
name|int
name|numSegments
init|=
name|segmentInfos
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numSegmentsToMerge
init|=
name|merge
operator|.
name|segments
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegmentsToMerge
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentInfo
name|info
init|=
name|merge
operator|.
name|segments
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
operator|+
name|i
operator|>=
name|numSegments
operator|||
operator|!
name|segmentInfos
operator|.
name|info
argument_list|(
name|first
operator|+
name|i
argument_list|)
operator|.
name|equals
argument_list|(
name|info
argument_list|)
condition|)
block|{
if|if
condition|(
name|segmentInfos
operator|.
name|indexOf
argument_list|(
name|info
argument_list|)
operator|==
operator|-
literal|1
condition|)
throw|throw
operator|new
name|MergePolicy
operator|.
name|MergeException
argument_list|(
literal|"MergePolicy selected a segment ("
operator|+
name|info
operator|.
name|name
operator|+
literal|") that is not in the current index "
operator|+
name|segString
argument_list|()
argument_list|,
name|directory
argument_list|)
throw|;
else|else
throw|throw
operator|new
name|MergePolicy
operator|.
name|MergeException
argument_list|(
literal|"MergePolicy selected non-contiguous segments to merge ("
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|directory
argument_list|)
operator|+
literal|" vs "
operator|+
name|segString
argument_list|()
operator|+
literal|"), which IndexWriter (currently) cannot handle"
argument_list|,
name|directory
argument_list|)
throw|;
block|}
block|}
return|return
name|first
return|;
block|}
comment|/** Carefully merges deletes for the segments we just    *  merged.  This is tricky because, although merging will    *  clear all deletes (compacts the documents), new    *  deletes may have been flushed to the segments since    *  the merge was started.  This method "carries over"    *  such new deletes onto the newly merged segment, and    *  saves the resulting deletes file (incrementing the    *  delete generation for merge.info).  If no deletes were    *  flushed, no new deletes file is saved. */
DECL|method|commitMergedDeletes
specifier|synchronized
specifier|private
name|void
name|commitMergedDeletes
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|,
name|SegmentReader
name|mergeReader
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|testPoint
argument_list|(
literal|"startCommitMergeDeletes"
argument_list|)
assert|;
specifier|final
name|SegmentInfos
name|sourceSegments
init|=
name|merge
operator|.
name|segments
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"commitMergeDeletes "
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|directory
argument_list|)
argument_list|)
expr_stmt|;
comment|// Carefully merge deletes that occurred after we
comment|// started merging:
name|int
name|docUpto
init|=
literal|0
decl_stmt|;
name|int
name|delCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sourceSegments
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SegmentInfo
name|info
init|=
name|sourceSegments
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|docCount
init|=
name|info
operator|.
name|docCount
decl_stmt|;
name|SegmentReader
name|previousReader
init|=
name|merge
operator|.
name|readersClone
index|[
name|i
index|]
decl_stmt|;
name|SegmentReader
name|currentReader
init|=
name|merge
operator|.
name|readers
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|previousReader
operator|.
name|hasDeletions
argument_list|()
condition|)
block|{
comment|// There were deletes on this segment when the merge
comment|// started.  The merge has collapsed away those
comment|// deletes, but, if new deletes were flushed since
comment|// the merge started, we must now carefully keep any
comment|// newly flushed deletes but mapping them to the new
comment|// docIDs.
if|if
condition|(
name|currentReader
operator|.
name|numDeletedDocs
argument_list|()
operator|>
name|previousReader
operator|.
name|numDeletedDocs
argument_list|()
condition|)
block|{
comment|// This means this segment has had new deletes
comment|// committed since we started the merge, so we
comment|// must merge them:
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|docCount
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|previousReader
operator|.
name|isDeleted
argument_list|(
name|j
argument_list|)
condition|)
assert|assert
name|currentReader
operator|.
name|isDeleted
argument_list|(
name|j
argument_list|)
assert|;
else|else
block|{
if|if
condition|(
name|currentReader
operator|.
name|isDeleted
argument_list|(
name|j
argument_list|)
condition|)
block|{
name|mergeReader
operator|.
name|doDelete
argument_list|(
name|docUpto
argument_list|)
expr_stmt|;
name|delCount
operator|++
expr_stmt|;
block|}
name|docUpto
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|docUpto
operator|+=
name|docCount
operator|-
name|previousReader
operator|.
name|numDeletedDocs
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|currentReader
operator|.
name|hasDeletions
argument_list|()
condition|)
block|{
comment|// This segment had no deletes before but now it
comment|// does:
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|docCount
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|currentReader
operator|.
name|isDeleted
argument_list|(
name|j
argument_list|)
condition|)
block|{
name|mergeReader
operator|.
name|doDelete
argument_list|(
name|docUpto
argument_list|)
expr_stmt|;
name|delCount
operator|++
expr_stmt|;
block|}
name|docUpto
operator|++
expr_stmt|;
block|}
block|}
else|else
comment|// No deletes before or after
name|docUpto
operator|+=
name|info
operator|.
name|docCount
expr_stmt|;
block|}
assert|assert
name|mergeReader
operator|.
name|numDeletedDocs
argument_list|()
operator|==
name|delCount
assert|;
name|mergeReader
operator|.
name|hasChanges
operator|=
name|delCount
operator|>=
literal|0
expr_stmt|;
block|}
comment|/* FIXME if we want to support non-contiguous segment merges */
DECL|method|commitMerge
specifier|synchronized
specifier|private
name|boolean
name|commitMerge
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|,
name|SegmentMerger
name|merger
parameter_list|,
name|int
name|mergedDocCount
parameter_list|,
name|SegmentReader
name|mergedReader
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|testPoint
argument_list|(
literal|"startCommitMerge"
argument_list|)
assert|;
if|if
condition|(
name|hitOOM
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"this writer hit an OutOfMemoryError; cannot complete merge"
argument_list|)
throw|;
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"commitMerge: "
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|directory
argument_list|)
operator|+
literal|" index="
operator|+
name|segString
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
name|merge
operator|.
name|registerDone
assert|;
comment|// If merge was explicitly aborted, or, if rollback() or
comment|// rollbackTransaction() had been called since our merge
comment|// started (which results in an unqualified
comment|// deleter.refresh() call that will remove any index
comment|// file that current segments does not reference), we
comment|// abort this merge
if|if
condition|(
name|merge
operator|.
name|isAborted
argument_list|()
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"commitMerge: skipping merge "
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|directory
argument_list|)
operator|+
literal|": it was aborted"
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|refresh
argument_list|(
name|merge
operator|.
name|info
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|start
init|=
name|ensureContiguousMerge
argument_list|(
name|merge
argument_list|)
decl_stmt|;
name|commitMergedDeletes
argument_list|(
name|merge
argument_list|,
name|mergedReader
argument_list|)
expr_stmt|;
name|docWriter
operator|.
name|remapDeletes
argument_list|(
name|segmentInfos
argument_list|,
name|merger
operator|.
name|getDocMaps
argument_list|()
argument_list|,
name|merger
operator|.
name|getDelCounts
argument_list|()
argument_list|,
name|merge
argument_list|,
name|mergedDocCount
argument_list|)
expr_stmt|;
comment|// Simple optimization: if the doc store we are using
comment|// has been closed and is in now compound format (but
comment|// wasn't when we started), then we will switch to the
comment|// compound format as well:
specifier|final
name|String
name|mergeDocStoreSegment
init|=
name|merge
operator|.
name|info
operator|.
name|getDocStoreSegment
argument_list|()
decl_stmt|;
if|if
condition|(
name|mergeDocStoreSegment
operator|!=
literal|null
operator|&&
operator|!
name|merge
operator|.
name|info
operator|.
name|getDocStoreIsCompoundFile
argument_list|()
condition|)
block|{
specifier|final
name|int
name|size
init|=
name|segmentInfos
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentInfo
name|info
init|=
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|String
name|docStoreSegment
init|=
name|info
operator|.
name|getDocStoreSegment
argument_list|()
decl_stmt|;
if|if
condition|(
name|docStoreSegment
operator|!=
literal|null
operator|&&
name|docStoreSegment
operator|.
name|equals
argument_list|(
name|mergeDocStoreSegment
argument_list|)
operator|&&
name|info
operator|.
name|getDocStoreIsCompoundFile
argument_list|()
condition|)
block|{
name|merge
operator|.
name|info
operator|.
name|setDocStoreIsCompoundFile
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|merge
operator|.
name|info
operator|.
name|setHasProx
argument_list|(
name|merger
operator|.
name|hasProx
argument_list|()
argument_list|)
expr_stmt|;
name|segmentInfos
operator|.
name|subList
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|merge
operator|.
name|segments
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
assert|assert
operator|!
name|segmentInfos
operator|.
name|contains
argument_list|(
name|merge
operator|.
name|info
argument_list|)
assert|;
name|segmentInfos
operator|.
name|add
argument_list|(
name|start
argument_list|,
name|merge
operator|.
name|info
argument_list|)
expr_stmt|;
comment|// Must note the change to segmentInfos so any commits
comment|// in-flight don't lose it:
name|checkpoint
argument_list|()
expr_stmt|;
comment|// If the merged segments had pending changes, clear
comment|// them so that they don't bother writing them to
comment|// disk, updating SegmentInfo, etc.:
name|readerPool
operator|.
name|clear
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge
operator|.
name|optimize
condition|)
name|segmentsToOptimize
operator|.
name|add
argument_list|(
name|merge
operator|.
name|info
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|decrefMergeSegments
specifier|private
specifier|synchronized
name|void
name|decrefMergeSegments
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|merge
operator|.
name|increfDone
assert|;
name|merge
operator|.
name|increfDone
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|handleMergeException
specifier|final
specifier|private
name|void
name|handleMergeException
parameter_list|(
name|Throwable
name|t
parameter_list|,
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"handleMergeException: merge="
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|directory
argument_list|)
operator|+
literal|" exc="
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
comment|// Set the exception on the merge, so if
comment|// optimize() is waiting on us it sees the root
comment|// cause exception:
name|merge
operator|.
name|setException
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|addMergeException
argument_list|(
name|merge
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|MergePolicy
operator|.
name|MergeAbortedException
condition|)
block|{
comment|// We can ignore this exception (it happens when
comment|// close(false) or rollback is called), unless the
comment|// merge involves segments from external directories,
comment|// in which case we must throw it so, for example, the
comment|// rollbackTransaction code in addIndexes* is
comment|// executed.
if|if
condition|(
name|merge
operator|.
name|isExternal
condition|)
throw|throw
operator|(
name|MergePolicy
operator|.
name|MergeAbortedException
operator|)
name|t
throw|;
block|}
elseif|else
if|if
condition|(
name|t
operator|instanceof
name|IOException
condition|)
throw|throw
operator|(
name|IOException
operator|)
name|t
throw|;
elseif|else
if|if
condition|(
name|t
operator|instanceof
name|RuntimeException
condition|)
throw|throw
operator|(
name|RuntimeException
operator|)
name|t
throw|;
elseif|else
if|if
condition|(
name|t
operator|instanceof
name|Error
condition|)
throw|throw
operator|(
name|Error
operator|)
name|t
throw|;
else|else
comment|// Should not get here
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|t
argument_list|)
throw|;
block|}
comment|/**    * Merges the indicated segments, replacing them in the stack with a    * single segment.    */
DECL|method|merge
specifier|final
name|void
name|merge
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
specifier|final
name|long
name|t0
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
try|try
block|{
try|try
block|{
name|mergeInit
argument_list|(
name|merge
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"now merge\n  merge="
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|directory
argument_list|)
operator|+
literal|"\n  merge="
operator|+
name|merge
operator|+
literal|"\n  index="
operator|+
name|segString
argument_list|()
argument_list|)
expr_stmt|;
name|mergeMiddle
argument_list|(
name|merge
argument_list|)
expr_stmt|;
name|mergeSuccess
argument_list|(
name|merge
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|handleMergeException
argument_list|(
name|t
argument_list|,
name|merge
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|mergeFinish
argument_list|(
name|merge
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"hit exception during merge"
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge
operator|.
name|info
operator|!=
literal|null
operator|&&
operator|!
name|segmentInfos
operator|.
name|contains
argument_list|(
name|merge
operator|.
name|info
argument_list|)
condition|)
name|deleter
operator|.
name|refresh
argument_list|(
name|merge
operator|.
name|info
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|// This merge (and, generally, any change to the
comment|// segments) may now enable new merges, so we call
comment|// merge policy& update pending merges.
if|if
condition|(
name|success
operator|&&
operator|!
name|merge
operator|.
name|isAborted
argument_list|()
operator|&&
operator|!
name|closed
operator|&&
operator|!
name|closing
condition|)
name|updatePendingMerges
argument_list|(
name|merge
operator|.
name|maxNumSegmentsOptimize
argument_list|,
name|merge
operator|.
name|optimize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"merge"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"merge time "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|t0
operator|)
operator|+
literal|" msec"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Hook that's called when the specified merge is complete. */
DECL|method|mergeSuccess
name|void
name|mergeSuccess
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
block|{   }
comment|/** Checks whether this merge involves any segments    *  already participating in a merge.  If not, this merge    *  is "registered", meaning we record that its segments    *  are now participating in a merge, and true is    *  returned.  Else (the merge conflicts) false is    *  returned. */
DECL|method|registerMerge
specifier|final
specifier|synchronized
name|boolean
name|registerMerge
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
throws|throws
name|MergePolicy
operator|.
name|MergeAbortedException
block|{
if|if
condition|(
name|merge
operator|.
name|registerDone
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|stopMerges
condition|)
block|{
name|merge
operator|.
name|abort
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MergePolicy
operator|.
name|MergeAbortedException
argument_list|(
literal|"merge is aborted: "
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|directory
argument_list|)
argument_list|)
throw|;
block|}
specifier|final
name|int
name|count
init|=
name|merge
operator|.
name|segments
operator|.
name|size
argument_list|()
decl_stmt|;
name|boolean
name|isExternal
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentInfo
name|info
init|=
name|merge
operator|.
name|segments
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergingSegments
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|segmentInfos
operator|.
name|indexOf
argument_list|(
name|info
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|info
operator|.
name|dir
operator|!=
name|directory
condition|)
name|isExternal
operator|=
literal|true
expr_stmt|;
block|}
name|ensureContiguousMerge
argument_list|(
name|merge
argument_list|)
expr_stmt|;
name|pendingMerges
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"add merge to pendingMerges: "
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|directory
argument_list|)
operator|+
literal|" [total "
operator|+
name|pendingMerges
operator|.
name|size
argument_list|()
operator|+
literal|" pending]"
argument_list|)
expr_stmt|;
name|merge
operator|.
name|mergeGen
operator|=
name|mergeGen
expr_stmt|;
name|merge
operator|.
name|isExternal
operator|=
name|isExternal
expr_stmt|;
comment|// OK it does not conflict; now record that this merge
comment|// is running (while synchronized) to avoid race
comment|// condition where two conflicting merges from different
comment|// threads, start
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|mergingSegments
operator|.
name|add
argument_list|(
name|merge
operator|.
name|segments
operator|.
name|info
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// Merge is now registered
name|merge
operator|.
name|registerDone
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/** Does initial setup for a merge, which is fast but holds    *  the synchronized lock on IndexWriter instance.  */
DECL|method|mergeInit
specifier|final
specifier|synchronized
name|void
name|mergeInit
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|_mergeInit
argument_list|(
name|merge
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|mergeFinish
argument_list|(
name|merge
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|_mergeInit
specifier|final
specifier|synchronized
specifier|private
name|void
name|_mergeInit
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|testPoint
argument_list|(
literal|"startMergeInit"
argument_list|)
assert|;
assert|assert
name|merge
operator|.
name|registerDone
assert|;
assert|assert
operator|!
name|merge
operator|.
name|optimize
operator|||
name|merge
operator|.
name|maxNumSegmentsOptimize
operator|>
literal|0
assert|;
if|if
condition|(
name|hitOOM
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"this writer hit an OutOfMemoryError; cannot merge"
argument_list|)
throw|;
block|}
if|if
condition|(
name|merge
operator|.
name|info
operator|!=
literal|null
condition|)
comment|// mergeInit already done
return|return;
if|if
condition|(
name|merge
operator|.
name|isAborted
argument_list|()
condition|)
return|return;
name|applyDeletes
argument_list|()
expr_stmt|;
specifier|final
name|SegmentInfos
name|sourceSegments
init|=
name|merge
operator|.
name|segments
decl_stmt|;
specifier|final
name|int
name|end
init|=
name|sourceSegments
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Check whether this merge will allow us to skip
comment|// merging the doc stores (stored field& vectors).
comment|// This is a very substantial optimization (saves tons
comment|// of IO).
name|Directory
name|lastDir
init|=
name|directory
decl_stmt|;
name|String
name|lastDocStoreSegment
init|=
literal|null
decl_stmt|;
name|int
name|next
init|=
operator|-
literal|1
decl_stmt|;
name|boolean
name|mergeDocStores
init|=
literal|false
decl_stmt|;
name|boolean
name|doFlushDocStore
init|=
literal|false
decl_stmt|;
specifier|final
name|String
name|currentDocStoreSegment
init|=
name|docWriter
operator|.
name|getDocStoreSegment
argument_list|()
decl_stmt|;
comment|// Test each segment to be merged: check if we need to
comment|// flush/merge doc stores
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|SegmentInfo
name|si
init|=
name|sourceSegments
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// If it has deletions we must merge the doc stores
if|if
condition|(
name|si
operator|.
name|hasDeletions
argument_list|()
condition|)
name|mergeDocStores
operator|=
literal|true
expr_stmt|;
comment|// If it has its own (private) doc stores we must
comment|// merge the doc stores
if|if
condition|(
operator|-
literal|1
operator|==
name|si
operator|.
name|getDocStoreOffset
argument_list|()
condition|)
name|mergeDocStores
operator|=
literal|true
expr_stmt|;
comment|// If it has a different doc store segment than
comment|// previous segments, we must merge the doc stores
name|String
name|docStoreSegment
init|=
name|si
operator|.
name|getDocStoreSegment
argument_list|()
decl_stmt|;
if|if
condition|(
name|docStoreSegment
operator|==
literal|null
condition|)
name|mergeDocStores
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|lastDocStoreSegment
operator|==
literal|null
condition|)
name|lastDocStoreSegment
operator|=
name|docStoreSegment
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|lastDocStoreSegment
operator|.
name|equals
argument_list|(
name|docStoreSegment
argument_list|)
condition|)
name|mergeDocStores
operator|=
literal|true
expr_stmt|;
comment|// Segments' docScoreOffsets must be in-order,
comment|// contiguous.  For the default merge policy now
comment|// this will always be the case but for an arbitrary
comment|// merge policy this may not be the case
if|if
condition|(
operator|-
literal|1
operator|==
name|next
condition|)
name|next
operator|=
name|si
operator|.
name|getDocStoreOffset
argument_list|()
operator|+
name|si
operator|.
name|docCount
expr_stmt|;
elseif|else
if|if
condition|(
name|next
operator|!=
name|si
operator|.
name|getDocStoreOffset
argument_list|()
condition|)
name|mergeDocStores
operator|=
literal|true
expr_stmt|;
else|else
name|next
operator|=
name|si
operator|.
name|getDocStoreOffset
argument_list|()
operator|+
name|si
operator|.
name|docCount
expr_stmt|;
comment|// If the segment comes from a different directory
comment|// we must merge
if|if
condition|(
name|lastDir
operator|!=
name|si
operator|.
name|dir
condition|)
name|mergeDocStores
operator|=
literal|true
expr_stmt|;
comment|// If the segment is referencing the current "live"
comment|// doc store outputs then we must merge
if|if
condition|(
name|si
operator|.
name|getDocStoreOffset
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|currentDocStoreSegment
operator|!=
literal|null
operator|&&
name|si
operator|.
name|getDocStoreSegment
argument_list|()
operator|.
name|equals
argument_list|(
name|currentDocStoreSegment
argument_list|)
condition|)
block|{
name|doFlushDocStore
operator|=
literal|true
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|docStoreOffset
decl_stmt|;
specifier|final
name|String
name|docStoreSegment
decl_stmt|;
specifier|final
name|boolean
name|docStoreIsCompoundFile
decl_stmt|;
if|if
condition|(
name|mergeDocStores
condition|)
block|{
name|docStoreOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|docStoreSegment
operator|=
literal|null
expr_stmt|;
name|docStoreIsCompoundFile
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|SegmentInfo
name|si
init|=
name|sourceSegments
operator|.
name|info
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|docStoreOffset
operator|=
name|si
operator|.
name|getDocStoreOffset
argument_list|()
expr_stmt|;
name|docStoreSegment
operator|=
name|si
operator|.
name|getDocStoreSegment
argument_list|()
expr_stmt|;
name|docStoreIsCompoundFile
operator|=
name|si
operator|.
name|getDocStoreIsCompoundFile
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mergeDocStores
operator|&&
name|doFlushDocStore
condition|)
block|{
comment|// SegmentMerger intends to merge the doc stores
comment|// (stored fields, vectors), and at least one of the
comment|// segments to be merged refers to the currently
comment|// live doc stores.
comment|// TODO: if we know we are about to merge away these
comment|// newly flushed doc store files then we should not
comment|// make compound file out of them...
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"now flush at merge"
argument_list|)
expr_stmt|;
name|doFlush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|merge
operator|.
name|increfDone
operator|=
literal|true
expr_stmt|;
name|merge
operator|.
name|mergeDocStores
operator|=
name|mergeDocStores
expr_stmt|;
comment|// Bind a new segment name here so even with
comment|// ConcurrentMergePolicy we keep deterministic segment
comment|// names.
name|merge
operator|.
name|info
operator|=
operator|new
name|SegmentInfo
argument_list|(
name|newSegmentName
argument_list|()
argument_list|,
literal|0
argument_list|,
name|directory
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
name|docStoreOffset
argument_list|,
name|docStoreSegment
argument_list|,
name|docStoreIsCompoundFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|details
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|details
operator|.
name|put
argument_list|(
literal|"optimize"
argument_list|,
name|merge
operator|.
name|optimize
operator|+
literal|""
argument_list|)
expr_stmt|;
name|details
operator|.
name|put
argument_list|(
literal|"mergeFactor"
argument_list|,
name|end
operator|+
literal|""
argument_list|)
expr_stmt|;
name|details
operator|.
name|put
argument_list|(
literal|"mergeDocStores"
argument_list|,
name|mergeDocStores
operator|+
literal|""
argument_list|)
expr_stmt|;
name|setDiagnostics
argument_list|(
name|merge
operator|.
name|info
argument_list|,
literal|"merge"
argument_list|,
name|details
argument_list|)
expr_stmt|;
comment|// Also enroll the merged segment into mergingSegments;
comment|// this prevents it from getting selected for a merge
comment|// after our merge is done but while we are building the
comment|// CFS:
name|mergingSegments
operator|.
name|add
argument_list|(
name|merge
operator|.
name|info
argument_list|)
expr_stmt|;
block|}
DECL|method|setDiagnostics
specifier|private
name|void
name|setDiagnostics
parameter_list|(
name|SegmentInfo
name|info
parameter_list|,
name|String
name|source
parameter_list|)
block|{
name|setDiagnostics
argument_list|(
name|info
argument_list|,
name|source
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|setDiagnostics
specifier|private
name|void
name|setDiagnostics
parameter_list|(
name|SegmentInfo
name|info
parameter_list|,
name|String
name|source
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|details
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|diagnostics
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|diagnostics
operator|.
name|put
argument_list|(
literal|"source"
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|diagnostics
operator|.
name|put
argument_list|(
literal|"lucene.version"
argument_list|,
name|Constants
operator|.
name|LUCENE_VERSION
argument_list|)
expr_stmt|;
name|diagnostics
operator|.
name|put
argument_list|(
literal|"os"
argument_list|,
name|Constants
operator|.
name|OS_NAME
operator|+
literal|""
argument_list|)
expr_stmt|;
name|diagnostics
operator|.
name|put
argument_list|(
literal|"os.arch"
argument_list|,
name|Constants
operator|.
name|OS_ARCH
operator|+
literal|""
argument_list|)
expr_stmt|;
name|diagnostics
operator|.
name|put
argument_list|(
literal|"os.version"
argument_list|,
name|Constants
operator|.
name|OS_VERSION
operator|+
literal|""
argument_list|)
expr_stmt|;
name|diagnostics
operator|.
name|put
argument_list|(
literal|"java.version"
argument_list|,
name|Constants
operator|.
name|JAVA_VERSION
operator|+
literal|""
argument_list|)
expr_stmt|;
name|diagnostics
operator|.
name|put
argument_list|(
literal|"java.vendor"
argument_list|,
name|Constants
operator|.
name|JAVA_VENDOR
operator|+
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|details
operator|!=
literal|null
condition|)
block|{
name|diagnostics
operator|.
name|putAll
argument_list|(
name|details
argument_list|)
expr_stmt|;
block|}
name|info
operator|.
name|setDiagnostics
argument_list|(
name|diagnostics
argument_list|)
expr_stmt|;
block|}
comment|/** Does fininishing for a merge, which is fast but holds    *  the synchronized lock on IndexWriter instance. */
DECL|method|mergeFinish
specifier|final
specifier|synchronized
name|void
name|mergeFinish
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Optimize, addIndexes or finishMerges may be waiting
comment|// on merges to finish.
name|notifyAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|merge
operator|.
name|increfDone
condition|)
name|decrefMergeSegments
argument_list|(
name|merge
argument_list|)
expr_stmt|;
comment|// It's possible we are called twice, eg if there was an
comment|// exception inside mergeInit
if|if
condition|(
name|merge
operator|.
name|registerDone
condition|)
block|{
specifier|final
name|SegmentInfos
name|sourceSegments
init|=
name|merge
operator|.
name|segments
decl_stmt|;
specifier|final
name|int
name|end
init|=
name|sourceSegments
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
name|mergingSegments
operator|.
name|remove
argument_list|(
name|sourceSegments
operator|.
name|info
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mergingSegments
operator|.
name|remove
argument_list|(
name|merge
operator|.
name|info
argument_list|)
expr_stmt|;
name|merge
operator|.
name|registerDone
operator|=
literal|false
expr_stmt|;
block|}
name|runningMerges
operator|.
name|remove
argument_list|(
name|merge
argument_list|)
expr_stmt|;
block|}
comment|/** Does the actual (time-consuming) work of the merge,    *  but without holding synchronized lock on IndexWriter    *  instance */
DECL|method|mergeMiddle
specifier|final
specifier|private
name|int
name|mergeMiddle
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|merge
operator|.
name|checkAborted
argument_list|(
name|directory
argument_list|)
expr_stmt|;
specifier|final
name|String
name|mergedName
init|=
name|merge
operator|.
name|info
operator|.
name|name
decl_stmt|;
name|SegmentMerger
name|merger
init|=
literal|null
decl_stmt|;
name|int
name|mergedDocCount
init|=
literal|0
decl_stmt|;
name|SegmentInfos
name|sourceSegments
init|=
name|merge
operator|.
name|segments
decl_stmt|;
specifier|final
name|int
name|numSegments
init|=
name|sourceSegments
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"merging "
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|directory
argument_list|)
argument_list|)
expr_stmt|;
name|merger
operator|=
operator|new
name|SegmentMerger
argument_list|(
name|this
argument_list|,
name|mergedName
argument_list|,
name|merge
argument_list|)
expr_stmt|;
name|merge
operator|.
name|readers
operator|=
operator|new
name|SegmentReader
index|[
name|numSegments
index|]
expr_stmt|;
name|merge
operator|.
name|readersClone
operator|=
operator|new
name|SegmentReader
index|[
name|numSegments
index|]
expr_stmt|;
name|boolean
name|mergeDocStores
init|=
literal|false
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|dss
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// This is try/finally to make sure merger's readers are
comment|// closed:
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|int
name|totDocCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentInfo
name|info
init|=
name|sourceSegments
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Hold onto the "live" reader; we will use this to
comment|// commit merged deletes
name|SegmentReader
name|reader
init|=
name|merge
operator|.
name|readers
index|[
name|i
index|]
operator|=
name|readerPool
operator|.
name|get
argument_list|(
name|info
argument_list|,
name|merge
operator|.
name|mergeDocStores
argument_list|,
name|MERGE_READ_BUFFER_SIZE
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// We clone the segment readers because other
comment|// deletes may come in while we're merging so we
comment|// need readers that will not change
name|SegmentReader
name|clone
init|=
name|merge
operator|.
name|readersClone
index|[
name|i
index|]
operator|=
operator|(
name|SegmentReader
operator|)
name|reader
operator|.
name|clone
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|merger
operator|.
name|add
argument_list|(
name|clone
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone
operator|.
name|hasDeletions
argument_list|()
condition|)
block|{
name|mergeDocStores
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|getDocStoreOffset
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|dss
operator|.
name|add
argument_list|(
name|info
operator|.
name|getDocStoreSegment
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|totDocCount
operator|+=
name|clone
operator|.
name|numDocs
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"merge: total "
operator|+
name|totDocCount
operator|+
literal|" docs"
argument_list|)
expr_stmt|;
block|}
name|merge
operator|.
name|checkAborted
argument_list|(
name|directory
argument_list|)
expr_stmt|;
comment|// If deletions have arrived and it has now become
comment|// necessary to merge doc stores, go and open them:
if|if
condition|(
name|mergeDocStores
operator|&&
operator|!
name|merge
operator|.
name|mergeDocStores
condition|)
block|{
name|merge
operator|.
name|mergeDocStores
operator|=
literal|true
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|dss
operator|.
name|contains
argument_list|(
name|docWriter
operator|.
name|getDocStoreSegment
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"now flush at mergeMiddle"
argument_list|)
expr_stmt|;
name|doFlush
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
condition|;
name|i
operator|++
control|)
block|{
name|merge
operator|.
name|readersClone
index|[
name|i
index|]
operator|.
name|openDocStores
argument_list|()
expr_stmt|;
block|}
comment|// Clear DSS
synchronized|synchronized
init|(
name|this
init|)
block|{
name|merge
operator|.
name|info
operator|.
name|setDocStore
argument_list|(
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|// This is where all the work happens:
name|mergedDocCount
operator|=
name|merge
operator|.
name|info
operator|.
name|docCount
operator|=
name|merger
operator|.
name|merge
argument_list|(
name|merge
operator|.
name|mergeDocStores
argument_list|)
expr_stmt|;
assert|assert
name|mergedDocCount
operator|==
name|totDocCount
assert|;
comment|// TODO: in the non-realtime case, we may want to only
comment|// keep deletes (it's costly to open entire reader
comment|// when we just need deletes)
specifier|final
name|SegmentReader
name|mergedReader
init|=
name|readerPool
operator|.
name|get
argument_list|(
name|merge
operator|.
name|info
argument_list|,
literal|false
argument_list|,
name|BufferedIndexInput
operator|.
name|BUFFER_SIZE
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|poolReaders
operator|&&
name|mergedSegmentWarmer
operator|!=
literal|null
condition|)
block|{
name|mergedSegmentWarmer
operator|.
name|warm
argument_list|(
name|mergedReader
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|commitMerge
argument_list|(
name|merge
argument_list|,
name|merger
argument_list|,
name|mergedDocCount
argument_list|,
name|mergedReader
argument_list|)
condition|)
comment|// commitMerge will return false if this merge was aborted
return|return
literal|0
return|;
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|readerPool
operator|.
name|release
argument_list|(
name|mergedReader
argument_list|)
expr_stmt|;
block|}
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// Suppress any new exceptions so we throw the
comment|// original cause
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|merge
operator|.
name|readers
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|readerPool
operator|.
name|release
argument_list|(
name|merge
operator|.
name|readers
index|[
name|i
index|]
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{               }
block|}
if|if
condition|(
name|merge
operator|.
name|readersClone
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|merge
operator|.
name|readersClone
index|[
name|i
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{               }
comment|// This was a private clone and we had the only reference
assert|assert
name|merge
operator|.
name|readersClone
index|[
name|i
index|]
operator|.
name|getRefCount
argument_list|()
operator|==
literal|0
assert|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|merge
operator|.
name|readers
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
name|readerPool
operator|.
name|release
argument_list|(
name|merge
operator|.
name|readers
index|[
name|i
index|]
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge
operator|.
name|readersClone
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
name|merge
operator|.
name|readersClone
index|[
name|i
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// This was a private clone and we had the only reference
assert|assert
name|merge
operator|.
name|readersClone
index|[
name|i
index|]
operator|.
name|getRefCount
argument_list|()
operator|==
literal|0
assert|;
block|}
block|}
block|}
block|}
block|}
comment|// Must checkpoint before decrefing so any newly
comment|// referenced files in the new merge.info are incref'd
comment|// first:
synchronized|synchronized
init|(
name|this
init|)
block|{
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|decrefMergeSegments
argument_list|(
name|merge
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge
operator|.
name|useCompoundFile
condition|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
specifier|final
name|String
name|compoundFileName
init|=
name|mergedName
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|COMPOUND_FILE_EXTENSION
decl_stmt|;
try|try
block|{
name|merger
operator|.
name|createCompoundFile
argument_list|(
name|compoundFileName
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|merge
operator|.
name|isAborted
argument_list|()
condition|)
block|{
comment|// This can happen if rollback or close(false)
comment|// is called -- fall through to logic below to
comment|// remove the partially created CFS:
name|success
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|handleMergeException
argument_list|(
name|ioe
argument_list|,
name|merge
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|handleMergeException
argument_list|(
name|t
argument_list|,
name|merge
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"hit exception creating compound file during merge"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|deleter
operator|.
name|deleteFile
argument_list|(
name|compoundFileName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|merge
operator|.
name|isAborted
argument_list|()
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"abort merge after building CFS"
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|deleteFile
argument_list|(
name|compoundFileName
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|segmentInfos
operator|.
name|indexOf
argument_list|(
name|merge
operator|.
name|info
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|merge
operator|.
name|isAborted
argument_list|()
condition|)
block|{
comment|// Our segment (committed in non-compound
comment|// format) got merged away while we were
comment|// building the compound format.
name|deleter
operator|.
name|deleteFile
argument_list|(
name|compoundFileName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|merge
operator|.
name|info
operator|.
name|setUseCompoundFile
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|checkpoint
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|mergedDocCount
return|;
block|}
DECL|method|addMergeException
specifier|synchronized
name|void
name|addMergeException
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
block|{
assert|assert
name|merge
operator|.
name|getException
argument_list|()
operator|!=
literal|null
assert|;
if|if
condition|(
operator|!
name|mergeExceptions
operator|.
name|contains
argument_list|(
name|merge
argument_list|)
operator|&&
name|mergeGen
operator|==
name|merge
operator|.
name|mergeGen
condition|)
name|mergeExceptions
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
block|}
comment|// Apply buffered deletes to all segments.
DECL|method|applyDeletes
specifier|private
specifier|final
specifier|synchronized
name|boolean
name|applyDeletes
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
assert|assert
name|testPoint
argument_list|(
literal|"startApplyDeletes"
argument_list|)
assert|;
name|SegmentInfos
name|rollback
init|=
operator|(
name|SegmentInfos
operator|)
name|segmentInfos
operator|.
name|clone
argument_list|()
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|boolean
name|changed
decl_stmt|;
try|try
block|{
name|changed
operator|=
name|docWriter
operator|.
name|applyDeletes
argument_list|(
name|segmentInfos
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"hit exception flushing deletes"
argument_list|)
expr_stmt|;
comment|// Carefully remove any partially written .del
comment|// files
specifier|final
name|int
name|size
init|=
name|rollback
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|String
name|newDelFileName
init|=
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
operator|.
name|getDelFileName
argument_list|()
decl_stmt|;
specifier|final
name|String
name|delFileName
init|=
name|rollback
operator|.
name|info
argument_list|(
name|i
argument_list|)
operator|.
name|getDelFileName
argument_list|()
decl_stmt|;
if|if
condition|(
name|newDelFileName
operator|!=
literal|null
operator|&&
operator|!
name|newDelFileName
operator|.
name|equals
argument_list|(
name|delFileName
argument_list|)
condition|)
name|deleter
operator|.
name|deleteFile
argument_list|(
name|newDelFileName
argument_list|)
expr_stmt|;
block|}
comment|// Fully replace the segmentInfos since flushed
comment|// deletes could have changed any of the
comment|// SegmentInfo instances:
name|segmentInfos
operator|.
name|clear
argument_list|()
expr_stmt|;
name|segmentInfos
operator|.
name|addAll
argument_list|(
name|rollback
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changed
condition|)
name|checkpoint
argument_list|()
expr_stmt|;
return|return
name|changed
return|;
block|}
comment|// For test purposes.
DECL|method|getBufferedDeleteTermsSize
specifier|final
specifier|synchronized
name|int
name|getBufferedDeleteTermsSize
parameter_list|()
block|{
return|return
name|docWriter
operator|.
name|getBufferedDeleteTerms
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
comment|// For test purposes.
DECL|method|getNumBufferedDeleteTerms
specifier|final
specifier|synchronized
name|int
name|getNumBufferedDeleteTerms
parameter_list|()
block|{
return|return
name|docWriter
operator|.
name|getNumBufferedDeleteTerms
argument_list|()
return|;
block|}
comment|// utility routines for tests
DECL|method|newestSegment
name|SegmentInfo
name|newestSegment
parameter_list|()
block|{
return|return
name|segmentInfos
operator|.
name|info
argument_list|(
name|segmentInfos
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
DECL|method|segString
specifier|public
specifier|synchronized
name|String
name|segString
parameter_list|()
block|{
return|return
name|segString
argument_list|(
name|segmentInfos
argument_list|)
return|;
block|}
DECL|method|segString
specifier|private
specifier|synchronized
name|String
name|segString
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|)
block|{
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
specifier|final
name|int
name|count
init|=
name|infos
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SegmentInfo
name|info
init|=
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|info
operator|.
name|segString
argument_list|(
name|directory
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|dir
operator|!=
name|directory
condition|)
name|buffer
operator|.
name|append
argument_list|(
literal|"**"
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// Files that have been sync'd already
DECL|field|synced
specifier|private
name|HashSet
argument_list|<
name|String
argument_list|>
name|synced
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Files that are now being sync'd
DECL|field|syncing
specifier|private
name|HashSet
argument_list|<
name|String
argument_list|>
name|syncing
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|startSync
specifier|private
name|boolean
name|startSync
parameter_list|(
name|String
name|fileName
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|pending
parameter_list|)
block|{
synchronized|synchronized
init|(
name|synced
init|)
block|{
if|if
condition|(
operator|!
name|synced
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|syncing
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
name|syncing
operator|.
name|add
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|pending
operator|.
name|add
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
return|return
literal|false
return|;
block|}
block|}
DECL|method|finishSync
specifier|private
name|void
name|finishSync
parameter_list|(
name|String
name|fileName
parameter_list|,
name|boolean
name|success
parameter_list|)
block|{
synchronized|synchronized
init|(
name|synced
init|)
block|{
assert|assert
name|syncing
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
assert|;
name|syncing
operator|.
name|remove
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|synced
operator|.
name|add
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|synced
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Blocks until all files in syncing are sync'd */
DECL|method|waitForAllSynced
specifier|private
name|boolean
name|waitForAllSynced
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|syncing
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|synced
init|)
block|{
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|syncing
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|String
name|fileName
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|synced
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|syncing
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
condition|)
comment|// There was an error because a file that was
comment|// previously syncing failed to appear in synced
return|return
literal|false
return|;
else|else
try|try
block|{
name|synced
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|ThreadInterruptedException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
DECL|method|doWait
specifier|private
specifier|synchronized
name|void
name|doWait
parameter_list|()
block|{
comment|// NOTE: the callers of this method should in theory
comment|// be able to do simply wait(), but, as a defense
comment|// against thread timing hazards where notifyAll()
comment|// falls to be called, we wait for at most 1 second
comment|// and then return so caller can check if wait
comment|// conditions are satisfied:
try|try
block|{
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|ThreadInterruptedException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
comment|/** Walk through all files referenced by the current    *  segmentInfos and ask the Directory to sync each file,    *  if it wasn't already.  If that succeeds, then we    *  prepare a new segments_N file but do not fully commit    *  it. */
DECL|method|startCommit
specifier|private
name|void
name|startCommit
parameter_list|(
name|long
name|sizeInBytes
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commitUserData
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|testPoint
argument_list|(
literal|"startStartCommit"
argument_list|)
assert|;
if|if
condition|(
name|hitOOM
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"this writer hit an OutOfMemoryError; cannot commit"
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"startCommit(): start sizeInBytes="
operator|+
name|sizeInBytes
argument_list|)
expr_stmt|;
name|SegmentInfos
name|toSync
init|=
literal|null
decl_stmt|;
specifier|final
name|long
name|myChangeCount
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Wait for any running addIndexes to complete
comment|// first, then block any from running until we've
comment|// copied the segmentInfos we intend to sync:
name|blockAddIndexes
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// On commit the segmentInfos must never
comment|// reference a segment in another directory:
assert|assert
operator|!
name|hasExternalSegments
argument_list|()
assert|;
try|try
block|{
assert|assert
name|lastCommitChangeCount
operator|<=
name|changeCount
assert|;
if|if
condition|(
name|changeCount
operator|==
name|lastCommitChangeCount
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"  skip startCommit(): no changes pending"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// First, we clone& incref the segmentInfos we intend
comment|// to sync, then, without locking, we sync() each file
comment|// referenced by toSync, in the background.  Multiple
comment|// threads can be doing this at once, if say a large
comment|// merge and a small merge finish at the same time:
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"startCommit index="
operator|+
name|segString
argument_list|(
name|segmentInfos
argument_list|)
operator|+
literal|" changeCount="
operator|+
name|changeCount
argument_list|)
expr_stmt|;
name|readerPool
operator|.
name|commit
argument_list|()
expr_stmt|;
name|toSync
operator|=
operator|(
name|SegmentInfos
operator|)
name|segmentInfos
operator|.
name|clone
argument_list|()
expr_stmt|;
if|if
condition|(
name|commitUserData
operator|!=
literal|null
condition|)
name|toSync
operator|.
name|setUserData
argument_list|(
name|commitUserData
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|incRef
argument_list|(
name|toSync
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|myChangeCount
operator|=
name|changeCount
expr_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|files
init|=
name|toSync
operator|.
name|files
argument_list|(
name|directory
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|String
name|fileName
range|:
name|files
control|)
block|{
assert|assert
name|directory
operator|.
name|fileExists
argument_list|(
name|fileName
argument_list|)
operator|:
literal|"file "
operator|+
name|fileName
operator|+
literal|" does not exist"
assert|;
block|}
block|}
finally|finally
block|{
name|resumeAddIndexes
argument_list|()
expr_stmt|;
block|}
block|}
assert|assert
name|testPoint
argument_list|(
literal|"midStartCommit"
argument_list|)
assert|;
name|boolean
name|setPending
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// Loop until all files toSync references are sync'd:
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|pending
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|toSync
operator|.
name|files
argument_list|(
name|directory
argument_list|,
literal|false
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|String
name|fileName
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|startSync
argument_list|(
name|fileName
argument_list|,
name|pending
argument_list|)
condition|)
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// Because we incRef'd this commit point, above,
comment|// the file had better exist:
assert|assert
name|directory
operator|.
name|fileExists
argument_list|(
name|fileName
argument_list|)
operator|:
literal|"file '"
operator|+
name|fileName
operator|+
literal|"' does not exist dir="
operator|+
name|directory
assert|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"now sync "
operator|+
name|fileName
argument_list|)
expr_stmt|;
name|directory
operator|.
name|sync
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|finishSync
argument_list|(
name|fileName
argument_list|,
name|success
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// All files that I require are either synced or being
comment|// synced by other threads.  If they are being synced,
comment|// we must at this point block until they are done.
comment|// If this returns false, that means an error in
comment|// another thread resulted in failing to actually
comment|// sync one of our files, so we repeat:
if|if
condition|(
name|waitForAllSynced
argument_list|(
name|pending
argument_list|)
condition|)
break|break;
block|}
assert|assert
name|testPoint
argument_list|(
literal|"midStartCommit2"
argument_list|)
assert|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// If someone saved a newer version of segments file
comment|// since I first started syncing my version, I can
comment|// safely skip saving myself since I've been
comment|// superseded:
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|myChangeCount
operator|<=
name|lastCommitChangeCount
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"sync superseded by newer infos"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|pendingCommit
operator|==
literal|null
condition|)
block|{
comment|// My turn to commit
if|if
condition|(
name|segmentInfos
operator|.
name|getGeneration
argument_list|()
operator|>
name|toSync
operator|.
name|getGeneration
argument_list|()
condition|)
name|toSync
operator|.
name|updateGeneration
argument_list|(
name|segmentInfos
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// Exception here means nothing is prepared
comment|// (this method unwinds everything it did on
comment|// an exception)
try|try
block|{
name|toSync
operator|.
name|prepareCommit
argument_list|(
name|directory
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Have our master segmentInfos record the
comment|// generations we just prepared.  We do this
comment|// on error or success so we don't
comment|// double-write a segments_N file.
name|segmentInfos
operator|.
name|updateGeneration
argument_list|(
name|toSync
argument_list|)
expr_stmt|;
block|}
assert|assert
name|pendingCommit
operator|==
literal|null
assert|;
name|setPending
operator|=
literal|true
expr_stmt|;
name|pendingCommit
operator|=
name|toSync
expr_stmt|;
name|pendingCommitChangeCount
operator|=
name|myChangeCount
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
operator|&&
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"hit exception committing segments file"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|// Must wait for other commit to complete
name|doWait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"done all syncs"
argument_list|)
expr_stmt|;
assert|assert
name|testPoint
argument_list|(
literal|"midStartCommitSuccess"
argument_list|)
assert|;
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|setPending
condition|)
name|deleter
operator|.
name|decRef
argument_list|(
name|toSync
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"startCommit"
argument_list|)
expr_stmt|;
block|}
assert|assert
name|testPoint
argument_list|(
literal|"finishStartCommit"
argument_list|)
assert|;
block|}
comment|/**    * Returns<code>true</code> iff the index in the named directory is    * currently locked.    * @param directory the directory to check for a lock    * @throws IOException if there is a low-level IO error    */
DECL|method|isLocked
specifier|public
specifier|static
name|boolean
name|isLocked
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|directory
operator|.
name|makeLock
argument_list|(
name|WRITE_LOCK_NAME
argument_list|)
operator|.
name|isLocked
argument_list|()
return|;
block|}
comment|/**    * Forcibly unlocks the index in the named directory.    *<P>    * Caution: this should only be used by failure recovery code,    * when it is known that no other process nor thread is in fact    * currently accessing this index.    */
DECL|method|unlock
specifier|public
specifier|static
name|void
name|unlock
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
name|directory
operator|.
name|makeLock
argument_list|(
name|IndexWriter
operator|.
name|WRITE_LOCK_NAME
argument_list|)
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
comment|/**    * Specifies maximum field length (in number of tokens/terms) in {@link IndexWriter} constructors.    * {@link #setMaxFieldLength(int)} overrides the value set by    * the constructor.    */
DECL|class|MaxFieldLength
specifier|public
specifier|static
specifier|final
class|class
name|MaxFieldLength
block|{
DECL|field|limit
specifier|private
name|int
name|limit
decl_stmt|;
DECL|field|name
specifier|private
name|String
name|name
decl_stmt|;
comment|/**      * Private type-safe-enum-pattern constructor.      *       * @param name instance name      * @param limit maximum field length      */
DECL|method|MaxFieldLength
specifier|private
name|MaxFieldLength
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|limit
operator|=
name|limit
expr_stmt|;
block|}
comment|/**      * Public constructor to allow users to specify the maximum field size limit.      *       * @param limit The maximum field length      */
DECL|method|MaxFieldLength
specifier|public
name|MaxFieldLength
parameter_list|(
name|int
name|limit
parameter_list|)
block|{
name|this
argument_list|(
literal|"User-specified"
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
DECL|method|getLimit
specifier|public
name|int
name|getLimit
parameter_list|()
block|{
return|return
name|limit
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
operator|+
literal|":"
operator|+
name|limit
return|;
block|}
comment|/** Sets the maximum field length to {@link Integer#MAX_VALUE}. */
DECL|field|UNLIMITED
specifier|public
specifier|static
specifier|final
name|MaxFieldLength
name|UNLIMITED
init|=
operator|new
name|MaxFieldLength
argument_list|(
literal|"UNLIMITED"
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
comment|/**      *  Sets the maximum field length to       * {@link #DEFAULT_MAX_FIELD_LENGTH}       * */
DECL|field|LIMITED
specifier|public
specifier|static
specifier|final
name|MaxFieldLength
name|LIMITED
init|=
operator|new
name|MaxFieldLength
argument_list|(
literal|"LIMITED"
argument_list|,
name|DEFAULT_MAX_FIELD_LENGTH
argument_list|)
decl_stmt|;
block|}
comment|/** If {@link #getReader} has been called (ie, this writer    *  is in near real-time mode), then after a merge    *  completes, this class can be invoked to warm the    *  reader on the newly merged segment, before the merge    *  commits.  This is not required for near real-time    *  search, but will reduce search latency on opening a    *  new near real-time reader after a merge completes.    *    *<p><b>NOTE:</b> This API is experimental and might    * change in incompatible ways in the next release.</p>    *    *<p><b>NOTE</b>: warm is called before any deletes have    * been carried over to the merged segment. */
DECL|class|IndexReaderWarmer
specifier|public
specifier|static
specifier|abstract
class|class
name|IndexReaderWarmer
block|{
DECL|method|warm
specifier|public
specifier|abstract
name|void
name|warm
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
DECL|field|mergedSegmentWarmer
specifier|private
name|IndexReaderWarmer
name|mergedSegmentWarmer
decl_stmt|;
comment|/** Set the merged segment warmer.  See {@link    *  IndexReaderWarmer}. */
DECL|method|setMergedSegmentWarmer
specifier|public
name|void
name|setMergedSegmentWarmer
parameter_list|(
name|IndexReaderWarmer
name|warmer
parameter_list|)
block|{
name|mergedSegmentWarmer
operator|=
name|warmer
expr_stmt|;
block|}
comment|/** Returns the current merged segment warmer.  See {@link    *  IndexReaderWarmer}. */
DECL|method|getMergedSegmentWarmer
specifier|public
name|IndexReaderWarmer
name|getMergedSegmentWarmer
parameter_list|()
block|{
return|return
name|mergedSegmentWarmer
return|;
block|}
DECL|method|handleOOM
specifier|private
name|void
name|handleOOM
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|,
name|String
name|location
parameter_list|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"hit OutOfMemoryError inside "
operator|+
name|location
argument_list|)
expr_stmt|;
block|}
name|hitOOM
operator|=
literal|true
expr_stmt|;
throw|throw
name|oom
throw|;
block|}
comment|// Used only by assert for testing.  Current points:
comment|//   startDoFlush
comment|//   startCommitMerge
comment|//   startStartCommit
comment|//   midStartCommit
comment|//   midStartCommit2
comment|//   midStartCommitSuccess
comment|//   finishStartCommit
comment|//   startCommitMergeDeletes
comment|//   startMergeInit
comment|//   startApplyDeletes
comment|//   DocumentsWriter.ThreadState.init start
DECL|method|testPoint
name|boolean
name|testPoint
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
DECL|method|nrtIsCurrent
specifier|synchronized
name|boolean
name|nrtIsCurrent
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|)
block|{
if|if
condition|(
operator|!
name|infos
operator|.
name|equals
argument_list|(
name|segmentInfos
argument_list|)
condition|)
block|{
comment|// if any structural changes (new segments), we are
comment|// stale
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
operator|!
name|docWriter
operator|.
name|anyChanges
argument_list|()
return|;
block|}
block|}
DECL|method|isClosed
specifier|synchronized
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|closed
return|;
block|}
block|}
end_class
end_unit
