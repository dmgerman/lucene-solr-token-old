begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RAMOutputStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Fieldable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|UnicodeUtil
import|;
end_import
begin_comment
comment|/** Used by DocumentsWriter to maintain per-thread state.  *  We keep a separate Posting hash and other state for each  *  thread and then merge postings hashes from all threads  *  when writing the segment. */
end_comment
begin_class
DECL|class|DocumentsWriterThreadState
specifier|final
class|class
name|DocumentsWriterThreadState
block|{
DECL|field|postingsFreeList
name|Posting
index|[]
name|postingsFreeList
decl_stmt|;
comment|// Free Posting instances
DECL|field|postingsFreeCount
name|int
name|postingsFreeCount
decl_stmt|;
DECL|field|tvfLocal
name|RAMOutputStream
name|tvfLocal
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
comment|// Term vectors for one doc
DECL|field|fdtLocal
name|RAMOutputStream
name|fdtLocal
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
comment|// Stored fields for one doc
DECL|field|localFieldsWriter
name|FieldsWriter
name|localFieldsWriter
decl_stmt|;
comment|// Fields for one doc
DECL|field|vectorFieldPointers
name|long
index|[]
name|vectorFieldPointers
decl_stmt|;
DECL|field|vectorFieldNumbers
name|int
index|[]
name|vectorFieldNumbers
decl_stmt|;
DECL|field|isIdle
name|boolean
name|isIdle
init|=
literal|true
decl_stmt|;
comment|// Whether we are in use
DECL|field|numThreads
name|int
name|numThreads
init|=
literal|1
decl_stmt|;
comment|// Number of threads that use this instance
DECL|field|docID
name|int
name|docID
decl_stmt|;
comment|// docID we are now working on
DECL|field|numStoredFields
name|int
name|numStoredFields
decl_stmt|;
comment|// How many stored fields in current doc
DECL|field|docBoost
name|float
name|docBoost
decl_stmt|;
comment|// Boost for current doc
DECL|field|fieldDataArray
name|DocumentsWriterFieldData
index|[]
name|fieldDataArray
decl_stmt|;
comment|// Fields touched by current doc
DECL|field|numFieldData
name|int
name|numFieldData
decl_stmt|;
comment|// How many fields in current doc
DECL|field|numVectorFields
name|int
name|numVectorFields
decl_stmt|;
comment|// How many vector fields in current doc
DECL|field|allFieldDataArray
name|DocumentsWriterFieldData
index|[]
name|allFieldDataArray
init|=
operator|new
name|DocumentsWriterFieldData
index|[
literal|10
index|]
decl_stmt|;
comment|// All FieldData instances
DECL|field|numAllFieldData
name|int
name|numAllFieldData
decl_stmt|;
DECL|field|fieldDataHash
name|DocumentsWriterFieldData
index|[]
name|fieldDataHash
decl_stmt|;
comment|// Hash FieldData instances by field name
DECL|field|fieldDataHashMask
name|int
name|fieldDataHashMask
decl_stmt|;
DECL|field|maxTermPrefix
name|String
name|maxTermPrefix
decl_stmt|;
comment|// Non-null prefix of a too-large term if this
comment|// doc has one
DECL|field|doFlushAfter
name|boolean
name|doFlushAfter
decl_stmt|;
DECL|field|docWriter
specifier|final
name|DocumentsWriter
name|docWriter
decl_stmt|;
DECL|field|postingsPool
specifier|final
name|ByteBlockPool
name|postingsPool
decl_stmt|;
DECL|field|vectorsPool
specifier|final
name|ByteBlockPool
name|vectorsPool
decl_stmt|;
DECL|field|charPool
specifier|final
name|CharBlockPool
name|charPool
decl_stmt|;
DECL|method|DocumentsWriterThreadState
specifier|public
name|DocumentsWriterThreadState
parameter_list|(
name|DocumentsWriter
name|docWriter
parameter_list|)
block|{
name|this
operator|.
name|docWriter
operator|=
name|docWriter
expr_stmt|;
name|fieldDataArray
operator|=
operator|new
name|DocumentsWriterFieldData
index|[
literal|8
index|]
expr_stmt|;
name|fieldDataHash
operator|=
operator|new
name|DocumentsWriterFieldData
index|[
literal|16
index|]
expr_stmt|;
name|fieldDataHashMask
operator|=
literal|15
expr_stmt|;
name|vectorFieldPointers
operator|=
operator|new
name|long
index|[
literal|10
index|]
expr_stmt|;
name|vectorFieldNumbers
operator|=
operator|new
name|int
index|[
literal|10
index|]
expr_stmt|;
name|postingsFreeList
operator|=
operator|new
name|Posting
index|[
literal|256
index|]
expr_stmt|;
name|postingsFreeCount
operator|=
literal|0
expr_stmt|;
name|postingsPool
operator|=
operator|new
name|ByteBlockPool
argument_list|(
name|docWriter
operator|.
name|byteBlockAllocator
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|vectorsPool
operator|=
operator|new
name|ByteBlockPool
argument_list|(
name|docWriter
operator|.
name|byteBlockAllocator
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|charPool
operator|=
operator|new
name|CharBlockPool
argument_list|(
name|docWriter
argument_list|)
expr_stmt|;
block|}
comment|/** Clear the postings hash and return objects back to    *  shared pool */
DECL|method|resetPostings
specifier|public
name|void
name|resetPostings
parameter_list|()
throws|throws
name|IOException
block|{
name|fieldGen
operator|=
literal|0
expr_stmt|;
name|maxPostingsVectors
operator|=
literal|0
expr_stmt|;
name|doFlushAfter
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|localFieldsWriter
operator|!=
literal|null
condition|)
block|{
name|localFieldsWriter
operator|.
name|close
argument_list|()
expr_stmt|;
name|localFieldsWriter
operator|=
literal|null
expr_stmt|;
block|}
name|postingsPool
operator|.
name|reset
argument_list|()
expr_stmt|;
name|charPool
operator|.
name|reset
argument_list|()
expr_stmt|;
name|docWriter
operator|.
name|recyclePostings
argument_list|(
name|postingsFreeList
argument_list|,
name|postingsFreeCount
argument_list|)
expr_stmt|;
name|postingsFreeCount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numAllFieldData
condition|;
name|i
operator|++
control|)
block|{
name|DocumentsWriterFieldData
name|fp
init|=
name|allFieldDataArray
index|[
name|i
index|]
decl_stmt|;
name|fp
operator|.
name|lastGen
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fp
operator|.
name|numPostings
operator|>
literal|0
condition|)
name|fp
operator|.
name|resetPostingArrays
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Move all per-document state that was accumulated in    *  the ThreadState into the "real" stores. */
DECL|method|writeDocument
specifier|public
name|void
name|writeDocument
parameter_list|()
throws|throws
name|IOException
throws|,
name|AbortException
block|{
comment|// If we hit an exception while appending to the
comment|// stored fields or term vectors files, we have to
comment|// abort all documents since we last flushed because
comment|// it means those files are possibly inconsistent.
try|try
block|{
name|docWriter
operator|.
name|numDocsInStore
operator|++
expr_stmt|;
comment|// Append stored fields to the real FieldsWriter:
name|docWriter
operator|.
name|fieldsWriter
operator|.
name|flushDocument
argument_list|(
name|numStoredFields
argument_list|,
name|fdtLocal
argument_list|)
expr_stmt|;
name|fdtLocal
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Append term vectors to the real outputs:
specifier|final
name|IndexOutput
name|tvx
init|=
name|docWriter
operator|.
name|tvx
decl_stmt|;
specifier|final
name|IndexOutput
name|tvd
init|=
name|docWriter
operator|.
name|tvd
decl_stmt|;
specifier|final
name|IndexOutput
name|tvf
init|=
name|docWriter
operator|.
name|tvf
decl_stmt|;
if|if
condition|(
name|tvx
operator|!=
literal|null
condition|)
block|{
name|tvx
operator|.
name|writeLong
argument_list|(
name|tvd
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
name|tvx
operator|.
name|writeLong
argument_list|(
name|tvf
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
name|tvd
operator|.
name|writeVInt
argument_list|(
name|numVectorFields
argument_list|)
expr_stmt|;
if|if
condition|(
name|numVectorFields
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numVectorFields
condition|;
name|i
operator|++
control|)
name|tvd
operator|.
name|writeVInt
argument_list|(
name|vectorFieldNumbers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
assert|assert
literal|0
operator|==
name|vectorFieldPointers
index|[
literal|0
index|]
assert|;
name|long
name|lastPos
init|=
name|vectorFieldPointers
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numVectorFields
condition|;
name|i
operator|++
control|)
block|{
name|long
name|pos
init|=
name|vectorFieldPointers
index|[
name|i
index|]
decl_stmt|;
name|tvd
operator|.
name|writeVLong
argument_list|(
name|pos
operator|-
name|lastPos
argument_list|)
expr_stmt|;
name|lastPos
operator|=
name|pos
expr_stmt|;
block|}
name|tvfLocal
operator|.
name|writeTo
argument_list|(
name|tvf
argument_list|)
expr_stmt|;
name|tvfLocal
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Append norms for the fields we saw:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFieldData
condition|;
name|i
operator|++
control|)
block|{
name|DocumentsWriterFieldData
name|fp
init|=
name|fieldDataArray
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|fp
operator|.
name|doNorms
condition|)
block|{
name|BufferedNorms
name|bn
init|=
name|docWriter
operator|.
name|norms
index|[
name|fp
operator|.
name|fieldInfo
operator|.
name|number
index|]
decl_stmt|;
assert|assert
name|bn
operator|!=
literal|null
assert|;
assert|assert
name|bn
operator|.
name|upto
operator|<=
name|docID
assert|;
name|bn
operator|.
name|fill
argument_list|(
name|docID
argument_list|)
expr_stmt|;
name|float
name|norm
init|=
name|fp
operator|.
name|boost
operator|*
name|docWriter
operator|.
name|writer
operator|.
name|getSimilarity
argument_list|()
operator|.
name|lengthNorm
argument_list|(
name|fp
operator|.
name|fieldInfo
operator|.
name|name
argument_list|,
name|fp
operator|.
name|length
argument_list|)
decl_stmt|;
name|bn
operator|.
name|add
argument_list|(
name|norm
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Forcefully idle this threadstate -- its state will
comment|// be reset by abort()
name|isIdle
operator|=
literal|true
expr_stmt|;
throw|throw
operator|new
name|AbortException
argument_list|(
name|t
argument_list|,
name|docWriter
argument_list|)
throw|;
block|}
if|if
condition|(
name|docWriter
operator|.
name|bufferIsFull
operator|&&
operator|!
name|docWriter
operator|.
name|flushPending
condition|)
block|{
name|docWriter
operator|.
name|flushPending
operator|=
literal|true
expr_stmt|;
name|doFlushAfter
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|field|fieldGen
name|int
name|fieldGen
decl_stmt|;
comment|/** Initializes shared state for this new document */
DECL|method|init
name|void
name|init
parameter_list|(
name|Document
name|doc
parameter_list|,
name|int
name|docID
parameter_list|)
throws|throws
name|IOException
throws|,
name|AbortException
block|{
assert|assert
operator|!
name|isIdle
assert|;
assert|assert
name|docWriter
operator|.
name|writer
operator|.
name|testPoint
argument_list|(
literal|"DocumentsWriter.ThreadState.init start"
argument_list|)
assert|;
name|this
operator|.
name|docID
operator|=
name|docID
expr_stmt|;
name|docBoost
operator|=
name|doc
operator|.
name|getBoost
argument_list|()
expr_stmt|;
name|numStoredFields
operator|=
literal|0
expr_stmt|;
name|numFieldData
operator|=
literal|0
expr_stmt|;
name|numVectorFields
operator|=
literal|0
expr_stmt|;
name|maxTermPrefix
operator|=
literal|null
expr_stmt|;
assert|assert
literal|0
operator|==
name|fdtLocal
operator|.
name|length
argument_list|()
assert|;
assert|assert
literal|0
operator|==
name|fdtLocal
operator|.
name|getFilePointer
argument_list|()
assert|;
assert|assert
literal|0
operator|==
name|tvfLocal
operator|.
name|length
argument_list|()
assert|;
assert|assert
literal|0
operator|==
name|tvfLocal
operator|.
name|getFilePointer
argument_list|()
assert|;
specifier|final
name|int
name|thisFieldGen
init|=
name|fieldGen
operator|++
decl_stmt|;
name|List
name|docFields
init|=
name|doc
operator|.
name|getFields
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numDocFields
init|=
name|docFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|boolean
name|docHasVectors
init|=
literal|false
decl_stmt|;
comment|// Absorb any new fields first seen in this document.
comment|// Also absorb any changes to fields we had already
comment|// seen before (eg suddenly turning on norms or
comment|// vectors, etc.):
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numDocFields
condition|;
name|i
operator|++
control|)
block|{
name|Fieldable
name|field
init|=
operator|(
name|Fieldable
operator|)
name|docFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|FieldInfo
name|fi
init|=
name|docWriter
operator|.
name|fieldInfos
operator|.
name|add
argument_list|(
name|field
operator|.
name|name
argument_list|()
argument_list|,
name|field
operator|.
name|isIndexed
argument_list|()
argument_list|,
name|field
operator|.
name|isTermVectorStored
argument_list|()
argument_list|,
name|field
operator|.
name|isStorePositionWithTermVector
argument_list|()
argument_list|,
name|field
operator|.
name|isStoreOffsetWithTermVector
argument_list|()
argument_list|,
name|field
operator|.
name|getOmitNorms
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|isIndexed
operator|&&
operator|!
name|fi
operator|.
name|omitNorms
condition|)
block|{
comment|// Maybe grow our buffered norms
if|if
condition|(
name|docWriter
operator|.
name|norms
operator|.
name|length
operator|<=
name|fi
operator|.
name|number
condition|)
block|{
name|int
name|newSize
init|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|1
operator|+
name|fi
operator|.
name|number
operator|)
operator|*
literal|1.25
argument_list|)
decl_stmt|;
name|BufferedNorms
index|[]
name|newNorms
init|=
operator|new
name|BufferedNorms
index|[
name|newSize
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|docWriter
operator|.
name|norms
argument_list|,
literal|0
argument_list|,
name|newNorms
argument_list|,
literal|0
argument_list|,
name|docWriter
operator|.
name|norms
operator|.
name|length
argument_list|)
expr_stmt|;
name|docWriter
operator|.
name|norms
operator|=
name|newNorms
expr_stmt|;
block|}
if|if
condition|(
name|docWriter
operator|.
name|norms
index|[
name|fi
operator|.
name|number
index|]
operator|==
literal|null
condition|)
name|docWriter
operator|.
name|norms
index|[
name|fi
operator|.
name|number
index|]
operator|=
operator|new
name|BufferedNorms
argument_list|()
expr_stmt|;
name|docWriter
operator|.
name|hasNorms
operator|=
literal|true
expr_stmt|;
block|}
comment|// Make sure we have a FieldData allocated
name|int
name|hashPos
init|=
name|fi
operator|.
name|name
operator|.
name|hashCode
argument_list|()
operator|&
name|fieldDataHashMask
decl_stmt|;
name|DocumentsWriterFieldData
name|fp
init|=
name|fieldDataHash
index|[
name|hashPos
index|]
decl_stmt|;
while|while
condition|(
name|fp
operator|!=
literal|null
operator|&&
operator|!
name|fp
operator|.
name|fieldInfo
operator|.
name|name
operator|.
name|equals
argument_list|(
name|fi
operator|.
name|name
argument_list|)
condition|)
name|fp
operator|=
name|fp
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|fp
operator|==
literal|null
condition|)
block|{
name|fp
operator|=
operator|new
name|DocumentsWriterFieldData
argument_list|(
name|this
argument_list|,
name|fi
argument_list|)
expr_stmt|;
name|fp
operator|.
name|next
operator|=
name|fieldDataHash
index|[
name|hashPos
index|]
expr_stmt|;
name|fieldDataHash
index|[
name|hashPos
index|]
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|numAllFieldData
operator|==
name|allFieldDataArray
operator|.
name|length
condition|)
block|{
name|int
name|newSize
init|=
call|(
name|int
call|)
argument_list|(
name|allFieldDataArray
operator|.
name|length
operator|*
literal|1.5
argument_list|)
decl_stmt|;
name|int
name|newHashSize
init|=
name|fieldDataHash
operator|.
name|length
operator|*
literal|2
decl_stmt|;
name|DocumentsWriterFieldData
name|newArray
index|[]
init|=
operator|new
name|DocumentsWriterFieldData
index|[
name|newSize
index|]
decl_stmt|;
name|DocumentsWriterFieldData
name|newHashArray
index|[]
init|=
operator|new
name|DocumentsWriterFieldData
index|[
name|newHashSize
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|allFieldDataArray
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|numAllFieldData
argument_list|)
expr_stmt|;
comment|// Rehash
name|fieldDataHashMask
operator|=
name|newSize
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|fieldDataHash
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|DocumentsWriterFieldData
name|fp0
init|=
name|fieldDataHash
index|[
name|j
index|]
decl_stmt|;
while|while
condition|(
name|fp0
operator|!=
literal|null
condition|)
block|{
name|hashPos
operator|=
name|fp0
operator|.
name|fieldInfo
operator|.
name|name
operator|.
name|hashCode
argument_list|()
operator|&
name|fieldDataHashMask
expr_stmt|;
name|DocumentsWriterFieldData
name|nextFP0
init|=
name|fp0
operator|.
name|next
decl_stmt|;
name|fp0
operator|.
name|next
operator|=
name|newHashArray
index|[
name|hashPos
index|]
expr_stmt|;
name|newHashArray
index|[
name|hashPos
index|]
operator|=
name|fp0
expr_stmt|;
name|fp0
operator|=
name|nextFP0
expr_stmt|;
block|}
block|}
name|allFieldDataArray
operator|=
name|newArray
expr_stmt|;
name|fieldDataHash
operator|=
name|newHashArray
expr_stmt|;
block|}
name|allFieldDataArray
index|[
name|numAllFieldData
operator|++
index|]
operator|=
name|fp
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|fp
operator|.
name|fieldInfo
operator|==
name|fi
assert|;
block|}
if|if
condition|(
name|thisFieldGen
operator|!=
name|fp
operator|.
name|lastGen
condition|)
block|{
comment|// First time we're seeing this field for this doc
name|fp
operator|.
name|lastGen
operator|=
name|thisFieldGen
expr_stmt|;
name|fp
operator|.
name|fieldCount
operator|=
literal|0
expr_stmt|;
name|fp
operator|.
name|doVectors
operator|=
name|fp
operator|.
name|doVectorPositions
operator|=
name|fp
operator|.
name|doVectorOffsets
operator|=
literal|false
expr_stmt|;
name|fp
operator|.
name|doNorms
operator|=
name|fi
operator|.
name|isIndexed
operator|&&
operator|!
name|fi
operator|.
name|omitNorms
expr_stmt|;
if|if
condition|(
name|numFieldData
operator|==
name|fieldDataArray
operator|.
name|length
condition|)
block|{
name|int
name|newSize
init|=
name|fieldDataArray
operator|.
name|length
operator|*
literal|2
decl_stmt|;
name|DocumentsWriterFieldData
name|newArray
index|[]
init|=
operator|new
name|DocumentsWriterFieldData
index|[
name|newSize
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|fieldDataArray
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|numFieldData
argument_list|)
expr_stmt|;
name|fieldDataArray
operator|=
name|newArray
expr_stmt|;
block|}
name|fieldDataArray
index|[
name|numFieldData
operator|++
index|]
operator|=
name|fp
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|.
name|isTermVectorStored
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|fp
operator|.
name|doVectors
operator|&&
name|numVectorFields
operator|++
operator|==
name|vectorFieldPointers
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|newSize
init|=
call|(
name|int
call|)
argument_list|(
name|numVectorFields
operator|*
literal|1.5
argument_list|)
decl_stmt|;
name|vectorFieldPointers
operator|=
operator|new
name|long
index|[
name|newSize
index|]
expr_stmt|;
name|vectorFieldNumbers
operator|=
operator|new
name|int
index|[
name|newSize
index|]
expr_stmt|;
block|}
name|fp
operator|.
name|doVectors
operator|=
literal|true
expr_stmt|;
name|docHasVectors
operator|=
literal|true
expr_stmt|;
name|fp
operator|.
name|doVectorPositions
operator||=
name|field
operator|.
name|isStorePositionWithTermVector
argument_list|()
expr_stmt|;
name|fp
operator|.
name|doVectorOffsets
operator||=
name|field
operator|.
name|isStoreOffsetWithTermVector
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|.
name|fieldCount
operator|==
name|fp
operator|.
name|docFields
operator|.
name|length
condition|)
block|{
name|Fieldable
index|[]
name|newArray
init|=
operator|new
name|Fieldable
index|[
name|fp
operator|.
name|docFields
operator|.
name|length
operator|*
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|fp
operator|.
name|docFields
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|fp
operator|.
name|docFields
operator|.
name|length
argument_list|)
expr_stmt|;
name|fp
operator|.
name|docFields
operator|=
name|newArray
expr_stmt|;
block|}
comment|// Lazily allocate arrays for postings:
if|if
condition|(
name|field
operator|.
name|isIndexed
argument_list|()
operator|&&
name|fp
operator|.
name|postingsHash
operator|==
literal|null
condition|)
name|fp
operator|.
name|initPostingArrays
argument_list|()
expr_stmt|;
name|fp
operator|.
name|docFields
index|[
name|fp
operator|.
name|fieldCount
operator|++
index|]
operator|=
name|field
expr_stmt|;
block|}
comment|// Maybe init the local& global fieldsWriter
if|if
condition|(
name|localFieldsWriter
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|docWriter
operator|.
name|fieldsWriter
operator|==
literal|null
condition|)
block|{
assert|assert
name|docWriter
operator|.
name|docStoreSegment
operator|==
literal|null
assert|;
assert|assert
name|docWriter
operator|.
name|segment
operator|!=
literal|null
assert|;
name|docWriter
operator|.
name|files
operator|=
literal|null
expr_stmt|;
name|docWriter
operator|.
name|docStoreSegment
operator|=
name|docWriter
operator|.
name|segment
expr_stmt|;
comment|// If we hit an exception while init'ing the
comment|// fieldsWriter, we must abort this segment
comment|// because those files will be in an unknown
comment|// state:
try|try
block|{
name|docWriter
operator|.
name|fieldsWriter
operator|=
operator|new
name|FieldsWriter
argument_list|(
name|docWriter
operator|.
name|directory
argument_list|,
name|docWriter
operator|.
name|docStoreSegment
argument_list|,
name|docWriter
operator|.
name|fieldInfos
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
operator|new
name|AbortException
argument_list|(
name|t
argument_list|,
name|docWriter
argument_list|)
throw|;
block|}
block|}
name|localFieldsWriter
operator|=
operator|new
name|FieldsWriter
argument_list|(
literal|null
argument_list|,
name|fdtLocal
argument_list|,
name|docWriter
operator|.
name|fieldInfos
argument_list|)
expr_stmt|;
block|}
comment|// First time we see a doc that has field(s) with
comment|// stored vectors, we init our tvx writer
if|if
condition|(
name|docHasVectors
condition|)
block|{
if|if
condition|(
name|docWriter
operator|.
name|tvx
operator|==
literal|null
condition|)
block|{
assert|assert
name|docWriter
operator|.
name|docStoreSegment
operator|!=
literal|null
assert|;
name|docWriter
operator|.
name|files
operator|=
literal|null
expr_stmt|;
comment|// If we hit an exception while init'ing the term
comment|// vector output files, we must abort this segment
comment|// because those files will be in an unknown
comment|// state:
try|try
block|{
name|docWriter
operator|.
name|tvx
operator|=
name|docWriter
operator|.
name|directory
operator|.
name|createOutput
argument_list|(
name|docWriter
operator|.
name|docStoreSegment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|VECTORS_INDEX_EXTENSION
argument_list|)
expr_stmt|;
name|docWriter
operator|.
name|tvx
operator|.
name|writeInt
argument_list|(
name|TermVectorsReader
operator|.
name|FORMAT_CURRENT
argument_list|)
expr_stmt|;
name|docWriter
operator|.
name|tvd
operator|=
name|docWriter
operator|.
name|directory
operator|.
name|createOutput
argument_list|(
name|docWriter
operator|.
name|docStoreSegment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|VECTORS_DOCUMENTS_EXTENSION
argument_list|)
expr_stmt|;
name|docWriter
operator|.
name|tvd
operator|.
name|writeInt
argument_list|(
name|TermVectorsReader
operator|.
name|FORMAT_CURRENT
argument_list|)
expr_stmt|;
name|docWriter
operator|.
name|tvf
operator|=
name|docWriter
operator|.
name|directory
operator|.
name|createOutput
argument_list|(
name|docWriter
operator|.
name|docStoreSegment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|VECTORS_FIELDS_EXTENSION
argument_list|)
expr_stmt|;
name|docWriter
operator|.
name|tvf
operator|.
name|writeInt
argument_list|(
name|TermVectorsReader
operator|.
name|FORMAT_CURRENT
argument_list|)
expr_stmt|;
comment|// We must "catch up" for all docs before us
comment|// that had no vectors:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docWriter
operator|.
name|numDocsInStore
condition|;
name|i
operator|++
control|)
block|{
name|docWriter
operator|.
name|tvx
operator|.
name|writeLong
argument_list|(
name|docWriter
operator|.
name|tvd
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
name|docWriter
operator|.
name|tvd
operator|.
name|writeVInt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|docWriter
operator|.
name|tvx
operator|.
name|writeLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
operator|new
name|AbortException
argument_list|(
name|t
argument_list|,
name|docWriter
argument_list|)
throw|;
block|}
block|}
name|numVectorFields
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/** Do in-place sort of Posting array */
DECL|method|doPostingSort
name|void
name|doPostingSort
parameter_list|(
name|Posting
index|[]
name|postings
parameter_list|,
name|int
name|numPosting
parameter_list|)
block|{
name|quickSort
argument_list|(
name|postings
argument_list|,
literal|0
argument_list|,
name|numPosting
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|quickSort
name|void
name|quickSort
parameter_list|(
name|Posting
index|[]
name|postings
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
if|if
condition|(
name|lo
operator|>=
name|hi
condition|)
return|return;
elseif|else
if|if
condition|(
name|hi
operator|==
literal|1
operator|+
name|lo
condition|)
block|{
if|if
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|lo
index|]
argument_list|,
name|postings
index|[
name|hi
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
specifier|final
name|Posting
name|tmp
init|=
name|postings
index|[
name|lo
index|]
decl_stmt|;
name|postings
index|[
name|lo
index|]
operator|=
name|postings
index|[
name|hi
index|]
expr_stmt|;
name|postings
index|[
name|hi
index|]
operator|=
name|tmp
expr_stmt|;
block|}
return|return;
block|}
name|int
name|mid
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>>
literal|1
decl_stmt|;
if|if
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|lo
index|]
argument_list|,
name|postings
index|[
name|mid
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|Posting
name|tmp
init|=
name|postings
index|[
name|lo
index|]
decl_stmt|;
name|postings
index|[
name|lo
index|]
operator|=
name|postings
index|[
name|mid
index|]
expr_stmt|;
name|postings
index|[
name|mid
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|mid
index|]
argument_list|,
name|postings
index|[
name|hi
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|Posting
name|tmp
init|=
name|postings
index|[
name|mid
index|]
decl_stmt|;
name|postings
index|[
name|mid
index|]
operator|=
name|postings
index|[
name|hi
index|]
expr_stmt|;
name|postings
index|[
name|hi
index|]
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|lo
index|]
argument_list|,
name|postings
index|[
name|mid
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|Posting
name|tmp2
init|=
name|postings
index|[
name|lo
index|]
decl_stmt|;
name|postings
index|[
name|lo
index|]
operator|=
name|postings
index|[
name|mid
index|]
expr_stmt|;
name|postings
index|[
name|mid
index|]
operator|=
name|tmp2
expr_stmt|;
block|}
block|}
name|int
name|left
init|=
name|lo
operator|+
literal|1
decl_stmt|;
name|int
name|right
init|=
name|hi
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|left
operator|>=
name|right
condition|)
return|return;
name|Posting
name|partition
init|=
name|postings
index|[
name|mid
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|right
index|]
argument_list|,
name|partition
argument_list|)
operator|>
literal|0
condition|)
operator|--
name|right
expr_stmt|;
while|while
condition|(
name|left
operator|<
name|right
operator|&&
name|comparePostings
argument_list|(
name|postings
index|[
name|left
index|]
argument_list|,
name|partition
argument_list|)
operator|<=
literal|0
condition|)
operator|++
name|left
expr_stmt|;
if|if
condition|(
name|left
operator|<
name|right
condition|)
block|{
name|Posting
name|tmp
init|=
name|postings
index|[
name|left
index|]
decl_stmt|;
name|postings
index|[
name|left
index|]
operator|=
name|postings
index|[
name|right
index|]
expr_stmt|;
name|postings
index|[
name|right
index|]
operator|=
name|tmp
expr_stmt|;
operator|--
name|right
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|quickSort
argument_list|(
name|postings
argument_list|,
name|lo
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|quickSort
argument_list|(
name|postings
argument_list|,
name|left
operator|+
literal|1
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
comment|/** Do in-place sort of PostingVector array */
DECL|method|doVectorSort
name|void
name|doVectorSort
parameter_list|(
name|PostingVector
index|[]
name|postings
parameter_list|,
name|int
name|numPosting
parameter_list|)
block|{
name|quickSort
argument_list|(
name|postings
argument_list|,
literal|0
argument_list|,
name|numPosting
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|quickSort
name|void
name|quickSort
parameter_list|(
name|PostingVector
index|[]
name|postings
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
if|if
condition|(
name|lo
operator|>=
name|hi
condition|)
return|return;
elseif|else
if|if
condition|(
name|hi
operator|==
literal|1
operator|+
name|lo
condition|)
block|{
if|if
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|lo
index|]
operator|.
name|p
argument_list|,
name|postings
index|[
name|hi
index|]
operator|.
name|p
argument_list|)
operator|>
literal|0
condition|)
block|{
specifier|final
name|PostingVector
name|tmp
init|=
name|postings
index|[
name|lo
index|]
decl_stmt|;
name|postings
index|[
name|lo
index|]
operator|=
name|postings
index|[
name|hi
index|]
expr_stmt|;
name|postings
index|[
name|hi
index|]
operator|=
name|tmp
expr_stmt|;
block|}
return|return;
block|}
name|int
name|mid
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>>
literal|1
decl_stmt|;
if|if
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|lo
index|]
operator|.
name|p
argument_list|,
name|postings
index|[
name|mid
index|]
operator|.
name|p
argument_list|)
operator|>
literal|0
condition|)
block|{
name|PostingVector
name|tmp
init|=
name|postings
index|[
name|lo
index|]
decl_stmt|;
name|postings
index|[
name|lo
index|]
operator|=
name|postings
index|[
name|mid
index|]
expr_stmt|;
name|postings
index|[
name|mid
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|mid
index|]
operator|.
name|p
argument_list|,
name|postings
index|[
name|hi
index|]
operator|.
name|p
argument_list|)
operator|>
literal|0
condition|)
block|{
name|PostingVector
name|tmp
init|=
name|postings
index|[
name|mid
index|]
decl_stmt|;
name|postings
index|[
name|mid
index|]
operator|=
name|postings
index|[
name|hi
index|]
expr_stmt|;
name|postings
index|[
name|hi
index|]
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|lo
index|]
operator|.
name|p
argument_list|,
name|postings
index|[
name|mid
index|]
operator|.
name|p
argument_list|)
operator|>
literal|0
condition|)
block|{
name|PostingVector
name|tmp2
init|=
name|postings
index|[
name|lo
index|]
decl_stmt|;
name|postings
index|[
name|lo
index|]
operator|=
name|postings
index|[
name|mid
index|]
expr_stmt|;
name|postings
index|[
name|mid
index|]
operator|=
name|tmp2
expr_stmt|;
block|}
block|}
name|int
name|left
init|=
name|lo
operator|+
literal|1
decl_stmt|;
name|int
name|right
init|=
name|hi
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|left
operator|>=
name|right
condition|)
return|return;
name|PostingVector
name|partition
init|=
name|postings
index|[
name|mid
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|right
index|]
operator|.
name|p
argument_list|,
name|partition
operator|.
name|p
argument_list|)
operator|>
literal|0
condition|)
operator|--
name|right
expr_stmt|;
while|while
condition|(
name|left
operator|<
name|right
operator|&&
name|comparePostings
argument_list|(
name|postings
index|[
name|left
index|]
operator|.
name|p
argument_list|,
name|partition
operator|.
name|p
argument_list|)
operator|<=
literal|0
condition|)
operator|++
name|left
expr_stmt|;
if|if
condition|(
name|left
operator|<
name|right
condition|)
block|{
name|PostingVector
name|tmp
init|=
name|postings
index|[
name|left
index|]
decl_stmt|;
name|postings
index|[
name|left
index|]
operator|=
name|postings
index|[
name|right
index|]
expr_stmt|;
name|postings
index|[
name|right
index|]
operator|=
name|tmp
expr_stmt|;
operator|--
name|right
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|quickSort
argument_list|(
name|postings
argument_list|,
name|lo
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|quickSort
argument_list|(
name|postings
argument_list|,
name|left
operator|+
literal|1
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
DECL|method|quickSort
name|void
name|quickSort
parameter_list|(
name|DocumentsWriterFieldData
index|[]
name|array
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
if|if
condition|(
name|lo
operator|>=
name|hi
condition|)
return|return;
elseif|else
if|if
condition|(
name|hi
operator|==
literal|1
operator|+
name|lo
condition|)
block|{
if|if
condition|(
name|array
index|[
name|lo
index|]
operator|.
name|compareTo
argument_list|(
name|array
index|[
name|hi
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
specifier|final
name|DocumentsWriterFieldData
name|tmp
init|=
name|array
index|[
name|lo
index|]
decl_stmt|;
name|array
index|[
name|lo
index|]
operator|=
name|array
index|[
name|hi
index|]
expr_stmt|;
name|array
index|[
name|hi
index|]
operator|=
name|tmp
expr_stmt|;
block|}
return|return;
block|}
name|int
name|mid
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>>
literal|1
decl_stmt|;
if|if
condition|(
name|array
index|[
name|lo
index|]
operator|.
name|compareTo
argument_list|(
name|array
index|[
name|mid
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|DocumentsWriterFieldData
name|tmp
init|=
name|array
index|[
name|lo
index|]
decl_stmt|;
name|array
index|[
name|lo
index|]
operator|=
name|array
index|[
name|mid
index|]
expr_stmt|;
name|array
index|[
name|mid
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|array
index|[
name|mid
index|]
operator|.
name|compareTo
argument_list|(
name|array
index|[
name|hi
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|DocumentsWriterFieldData
name|tmp
init|=
name|array
index|[
name|mid
index|]
decl_stmt|;
name|array
index|[
name|mid
index|]
operator|=
name|array
index|[
name|hi
index|]
expr_stmt|;
name|array
index|[
name|hi
index|]
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|array
index|[
name|lo
index|]
operator|.
name|compareTo
argument_list|(
name|array
index|[
name|mid
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|DocumentsWriterFieldData
name|tmp2
init|=
name|array
index|[
name|lo
index|]
decl_stmt|;
name|array
index|[
name|lo
index|]
operator|=
name|array
index|[
name|mid
index|]
expr_stmt|;
name|array
index|[
name|mid
index|]
operator|=
name|tmp2
expr_stmt|;
block|}
block|}
name|int
name|left
init|=
name|lo
operator|+
literal|1
decl_stmt|;
name|int
name|right
init|=
name|hi
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|left
operator|>=
name|right
condition|)
return|return;
name|DocumentsWriterFieldData
name|partition
init|=
name|array
index|[
name|mid
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|array
index|[
name|right
index|]
operator|.
name|compareTo
argument_list|(
name|partition
argument_list|)
operator|>
literal|0
condition|)
operator|--
name|right
expr_stmt|;
while|while
condition|(
name|left
operator|<
name|right
operator|&&
name|array
index|[
name|left
index|]
operator|.
name|compareTo
argument_list|(
name|partition
argument_list|)
operator|<=
literal|0
condition|)
operator|++
name|left
expr_stmt|;
if|if
condition|(
name|left
operator|<
name|right
condition|)
block|{
name|DocumentsWriterFieldData
name|tmp
init|=
name|array
index|[
name|left
index|]
decl_stmt|;
name|array
index|[
name|left
index|]
operator|=
name|array
index|[
name|right
index|]
expr_stmt|;
name|array
index|[
name|right
index|]
operator|=
name|tmp
expr_stmt|;
operator|--
name|right
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|quickSort
argument_list|(
name|array
argument_list|,
name|lo
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|quickSort
argument_list|(
name|array
argument_list|,
name|left
operator|+
literal|1
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
comment|/** If there are fields we've seen but did not see again    *  in the last run, then free them up.  Also reduce    *  postings hash size. */
DECL|method|trimFields
name|void
name|trimFields
parameter_list|()
block|{
name|int
name|upto
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numAllFieldData
condition|;
name|i
operator|++
control|)
block|{
name|DocumentsWriterFieldData
name|fp
init|=
name|allFieldDataArray
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|fp
operator|.
name|lastGen
operator|==
operator|-
literal|1
condition|)
block|{
comment|// This field was not seen since the previous
comment|// flush, so, free up its resources now
comment|// Unhash
specifier|final
name|int
name|hashPos
init|=
name|fp
operator|.
name|fieldInfo
operator|.
name|name
operator|.
name|hashCode
argument_list|()
operator|&
name|fieldDataHashMask
decl_stmt|;
name|DocumentsWriterFieldData
name|last
init|=
literal|null
decl_stmt|;
name|DocumentsWriterFieldData
name|fp0
init|=
name|fieldDataHash
index|[
name|hashPos
index|]
decl_stmt|;
while|while
condition|(
name|fp0
operator|!=
name|fp
condition|)
block|{
name|last
operator|=
name|fp0
expr_stmt|;
name|fp0
operator|=
name|fp0
operator|.
name|next
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|==
literal|null
condition|)
name|fieldDataHash
index|[
name|hashPos
index|]
operator|=
name|fp
operator|.
name|next
expr_stmt|;
else|else
name|last
operator|.
name|next
operator|=
name|fp
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|docWriter
operator|.
name|infoStream
operator|!=
literal|null
condition|)
name|docWriter
operator|.
name|infoStream
operator|.
name|println
argument_list|(
literal|"  remove field="
operator|+
name|fp
operator|.
name|fieldInfo
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Reset
name|fp
operator|.
name|lastGen
operator|=
operator|-
literal|1
expr_stmt|;
name|allFieldDataArray
index|[
name|upto
operator|++
index|]
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|fp
operator|.
name|numPostings
operator|>
literal|0
operator|&&
operator|(
operator|(
name|float
operator|)
name|fp
operator|.
name|numPostings
operator|)
operator|/
name|fp
operator|.
name|postingsHashSize
operator|<
literal|0.2
condition|)
block|{
name|int
name|hashSize
init|=
name|fp
operator|.
name|postingsHashSize
decl_stmt|;
comment|// Reduce hash so it's between 25-50% full
while|while
condition|(
name|fp
operator|.
name|numPostings
operator|<
operator|(
name|hashSize
operator|>>
literal|1
operator|)
operator|&&
name|hashSize
operator|>=
literal|2
condition|)
name|hashSize
operator|>>=
literal|1
expr_stmt|;
name|hashSize
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|hashSize
operator|!=
name|fp
operator|.
name|postingsHash
operator|.
name|length
condition|)
name|fp
operator|.
name|rehashPostings
argument_list|(
name|hashSize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// If we didn't see any norms for this field since
comment|// last flush, free it
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docWriter
operator|.
name|norms
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|BufferedNorms
name|n
init|=
name|docWriter
operator|.
name|norms
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|null
operator|&&
name|n
operator|.
name|upto
operator|==
literal|0
condition|)
name|docWriter
operator|.
name|norms
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
name|numAllFieldData
operator|=
name|upto
expr_stmt|;
comment|// Also pare back PostingsVectors if it's excessively
comment|// large
if|if
condition|(
name|maxPostingsVectors
operator|*
literal|1.5
operator|<
name|postingsVectors
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|newSize
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|maxPostingsVectors
condition|)
name|newSize
operator|=
literal|1
expr_stmt|;
else|else
name|newSize
operator|=
call|(
name|int
call|)
argument_list|(
literal|1.5
operator|*
name|maxPostingsVectors
argument_list|)
expr_stmt|;
name|PostingVector
index|[]
name|newArray
init|=
operator|new
name|PostingVector
index|[
name|newSize
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|postingsVectors
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|newSize
argument_list|)
expr_stmt|;
name|postingsVectors
operator|=
name|newArray
expr_stmt|;
block|}
block|}
comment|/** Tokenizes the fields of a document into Postings */
DECL|method|processDocument
name|void
name|processDocument
parameter_list|(
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|IOException
throws|,
name|AbortException
block|{
specifier|final
name|int
name|numFields
init|=
name|numFieldData
decl_stmt|;
assert|assert
name|clearLastVectorFieldName
argument_list|()
assert|;
assert|assert
literal|0
operator|==
name|fdtLocal
operator|.
name|length
argument_list|()
assert|;
if|if
condition|(
name|docWriter
operator|.
name|tvx
operator|!=
literal|null
condition|)
comment|// If we are writing vectors then we must visit
comment|// fields in sorted order so they are written in
comment|// sorted order.  TODO: we actually only need to
comment|// sort the subset of fields that have vectors
comment|// enabled; we could save [small amount of] CPU
comment|// here.
name|quickSort
argument_list|(
name|fieldDataArray
argument_list|,
literal|0
argument_list|,
name|numFields
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// We process the document one field at a time
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
name|i
operator|++
control|)
name|fieldDataArray
index|[
name|i
index|]
operator|.
name|processField
argument_list|(
name|analyzer
argument_list|)
expr_stmt|;
if|if
condition|(
name|docWriter
operator|.
name|infoStream
operator|!=
literal|null
operator|&&
name|maxTermPrefix
operator|!=
literal|null
condition|)
name|docWriter
operator|.
name|infoStream
operator|.
name|println
argument_list|(
literal|"WARNING: document contains at least one immense term (longer than the max length "
operator|+
name|DocumentsWriter
operator|.
name|MAX_TERM_LENGTH
operator|+
literal|"), all of which were skipped.  Please correct the analyzer to not produce such terms.  The prefix of the first immense term is: '"
operator|+
name|maxTermPrefix
operator|+
literal|"...'"
argument_list|)
expr_stmt|;
block|}
comment|// USE ONLY FOR DEBUGGING!
comment|/*     public String getPostingText() {     char[] text = charPool.buffers[p.textStart>> CHAR_BLOCK_SHIFT];     int upto = p.textStart& CHAR_BLOCK_MASK;     while(text[upto] != 0xffff)     upto++;     return new String(text, p.textStart, upto-(p.textStart& BYTE_BLOCK_MASK));     }   */
comment|/** Compares term text for two Posting instance and    *  returns -1 if p1< p2; 1 if p1> p2; else 0.    */
DECL|method|comparePostings
name|int
name|comparePostings
parameter_list|(
name|Posting
name|p1
parameter_list|,
name|Posting
name|p2
parameter_list|)
block|{
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return
literal|0
return|;
specifier|final
name|char
index|[]
name|text1
init|=
name|charPool
operator|.
name|buffers
index|[
name|p1
operator|.
name|textStart
operator|>>
name|DocumentsWriter
operator|.
name|CHAR_BLOCK_SHIFT
index|]
decl_stmt|;
name|int
name|pos1
init|=
name|p1
operator|.
name|textStart
operator|&
name|DocumentsWriter
operator|.
name|CHAR_BLOCK_MASK
decl_stmt|;
specifier|final
name|char
index|[]
name|text2
init|=
name|charPool
operator|.
name|buffers
index|[
name|p2
operator|.
name|textStart
operator|>>
name|DocumentsWriter
operator|.
name|CHAR_BLOCK_SHIFT
index|]
decl_stmt|;
name|int
name|pos2
init|=
name|p2
operator|.
name|textStart
operator|&
name|DocumentsWriter
operator|.
name|CHAR_BLOCK_MASK
decl_stmt|;
assert|assert
name|text1
operator|!=
name|text2
operator|||
name|pos1
operator|!=
name|pos2
assert|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|char
name|c1
init|=
name|text1
index|[
name|pos1
operator|++
index|]
decl_stmt|;
specifier|final
name|char
name|c2
init|=
name|text2
index|[
name|pos2
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
block|{
if|if
condition|(
literal|0xffff
operator|==
name|c2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
literal|0xffff
operator|==
name|c1
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|c1
operator|-
name|c2
return|;
block|}
else|else
comment|// This method should never compare equal postings
comment|// unless p1==p2
assert|assert
name|c1
operator|!=
literal|0xffff
assert|;
block|}
block|}
DECL|field|lastVectorFieldName
name|String
name|lastVectorFieldName
decl_stmt|;
comment|// Called only by assert
DECL|method|clearLastVectorFieldName
specifier|final
name|boolean
name|clearLastVectorFieldName
parameter_list|()
block|{
name|lastVectorFieldName
operator|=
literal|null
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Called only by assert
DECL|method|vectorFieldsInOrder
specifier|final
name|boolean
name|vectorFieldsInOrder
parameter_list|(
name|FieldInfo
name|fi
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|lastVectorFieldName
operator|!=
literal|null
condition|)
return|return
name|lastVectorFieldName
operator|.
name|compareTo
argument_list|(
name|fi
operator|.
name|name
argument_list|)
operator|<
literal|0
return|;
else|else
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|lastVectorFieldName
operator|=
name|fi
operator|.
name|name
expr_stmt|;
block|}
block|}
DECL|field|postingsVectors
name|PostingVector
index|[]
name|postingsVectors
init|=
operator|new
name|PostingVector
index|[
literal|1
index|]
decl_stmt|;
DECL|field|maxPostingsVectors
name|int
name|maxPostingsVectors
decl_stmt|;
comment|// Used to read a string value for a field
DECL|field|stringReader
name|ReusableStringReader
name|stringReader
init|=
operator|new
name|ReusableStringReader
argument_list|()
decl_stmt|;
DECL|field|utf8Results
specifier|final
name|UnicodeUtil
operator|.
name|UTF8Result
name|utf8Results
index|[]
init|=
block|{
operator|new
name|UnicodeUtil
operator|.
name|UTF8Result
argument_list|()
block|,
operator|new
name|UnicodeUtil
operator|.
name|UTF8Result
argument_list|()
block|}
decl_stmt|;
block|}
end_class
end_unit
