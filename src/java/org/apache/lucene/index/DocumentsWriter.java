begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Token
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Fieldable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RAMOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_comment
comment|/**  * This class accepts multiple added documents and directly  * writes a single segment file.  It does this more  * efficiently than creating a single segment per document  * (with DocumentWriter) and doing standard merges on those  * segments.  *  * When a document is added, its stored fields (if any) and  * term vectors (if any) are immediately written to the  * Directory (ie these do not consume RAM).  The freq/prox  * postings are accumulated into a Postings hash table keyed  * by term.  Each entry in this hash table holds a separate  * byte stream (allocated as incrementally growing slices  * into large shared byte[] arrays) for freq and prox, that  * contains the postings data for multiple documents.  If  * vectors are enabled, each unique term for each document  * also allocates a PostingVector instance to similarly  * track the offsets& positions byte stream.  *  * Once the Postings hash is full (ie is consuming the  * allowed RAM) or the number of added docs is large enough  * (in the case we are flushing by doc count instead of RAM  * usage), we create a real segment and flush it to disk and  * reset the Postings hash.  *  * In adding a document we first organize all of its fields  * by field name.  We then process field by field, and  * record the Posting hash per-field.  After each field we  * flush its term vectors.  When it's time to flush the full  * segment we first sort the fields by name, and then go  * field by field and sorts its postings.  *  *  * Threads:  *  * Multiple threads are allowed into addDocument at once.  * There is an initial synchronized call to getThreadState  * which allocates a ThreadState for this thread.  The same  * thread will get the same ThreadState over time (thread  * affinity) so that if there are consistent patterns (for  * example each thread is indexing a different content  * source) then we make better use of RAM.  Then  * processDocument is called on that ThreadState without  * synchronization (most of the "heavy lifting" is in this  * call).  Finally the synchronized "finishDocument" is  * called to flush changes to the directory.  *  * Each ThreadState instance has its own Posting hash. Once  * we're using too much RAM, we flush all Posting hashes to  * a segment by merging the docIDs in the posting lists for  * the same term across multiple thread states (see  * writeSegment and appendPostings).  *  * When flush is called by IndexWriter, or, we flush  * internally when autoCommit=false, we forcefully idle all  * threads and flush only once they are all idle.  This  * means you can call flush with a given thread even while  * other threads are actively adding/deleting documents.  */
end_comment
begin_class
DECL|class|DocumentsWriter
specifier|final
class|class
name|DocumentsWriter
block|{
DECL|field|writer
specifier|private
name|IndexWriter
name|writer
decl_stmt|;
DECL|field|directory
specifier|private
name|Directory
name|directory
decl_stmt|;
DECL|field|fieldInfos
specifier|private
name|FieldInfos
name|fieldInfos
init|=
operator|new
name|FieldInfos
argument_list|()
decl_stmt|;
comment|// All fields we've seen
DECL|field|tvx
DECL|field|tvf
DECL|field|tvd
specifier|private
name|IndexOutput
name|tvx
decl_stmt|,
name|tvf
decl_stmt|,
name|tvd
decl_stmt|;
comment|// To write term vectors
DECL|field|fieldsWriter
specifier|private
name|FieldsWriter
name|fieldsWriter
decl_stmt|;
comment|// To write stored fields
DECL|field|segment
specifier|private
name|String
name|segment
decl_stmt|;
comment|// Current segment we are working on
DECL|field|docStoreSegment
specifier|private
name|String
name|docStoreSegment
decl_stmt|;
comment|// Current doc-store segment we are writing
DECL|field|docStoreOffset
specifier|private
name|int
name|docStoreOffset
decl_stmt|;
comment|// Current starting doc-store offset of current segment
DECL|field|nextDocID
specifier|private
name|int
name|nextDocID
decl_stmt|;
comment|// Next docID to be added
DECL|field|numDocsInRAM
specifier|private
name|int
name|numDocsInRAM
decl_stmt|;
comment|// # docs buffered in RAM
DECL|field|nextWriteDocID
specifier|private
name|int
name|nextWriteDocID
decl_stmt|;
comment|// Next docID to be written
comment|// Max # ThreadState instances; if there are more threads
comment|// than this they share ThreadStates
DECL|field|MAX_THREAD_STATE
specifier|private
specifier|final
specifier|static
name|int
name|MAX_THREAD_STATE
init|=
literal|5
decl_stmt|;
DECL|field|threadStates
specifier|private
name|ThreadState
index|[]
name|threadStates
init|=
operator|new
name|ThreadState
index|[
literal|0
index|]
decl_stmt|;
DECL|field|threadBindings
specifier|private
specifier|final
name|HashMap
name|threadBindings
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
DECL|field|numWaiting
specifier|private
name|int
name|numWaiting
decl_stmt|;
DECL|field|waitingThreadStates
specifier|private
name|ThreadState
index|[]
name|waitingThreadStates
init|=
operator|new
name|ThreadState
index|[
literal|1
index|]
decl_stmt|;
DECL|field|pauseThreads
specifier|private
name|int
name|pauseThreads
decl_stmt|;
comment|// Non-zero when we need all threads to
comment|// pause (eg to flush)
DECL|field|flushPending
specifier|private
name|boolean
name|flushPending
decl_stmt|;
comment|// True when a thread has decided to flush
DECL|field|postingsIsFull
specifier|private
name|boolean
name|postingsIsFull
decl_stmt|;
comment|// True when it's time to write segment
DECL|field|infoStream
specifier|private
name|PrintStream
name|infoStream
decl_stmt|;
comment|// How much RAM we can use before flushing.  This is 0 if
comment|// we are flushing by doc count instead.
DECL|field|ramBufferSize
specifier|private
name|long
name|ramBufferSize
init|=
call|(
name|long
call|)
argument_list|(
name|IndexWriter
operator|.
name|DEFAULT_RAM_BUFFER_SIZE_MB
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
decl_stmt|;
comment|// Flush @ this number of docs.  If rarmBufferSize is
comment|// non-zero we will flush by RAM usage instead.
DECL|field|maxBufferedDocs
specifier|private
name|int
name|maxBufferedDocs
init|=
name|IndexWriter
operator|.
name|DEFAULT_MAX_BUFFERED_DOCS
decl_stmt|;
DECL|field|norms
specifier|private
name|BufferedNorms
index|[]
name|norms
init|=
operator|new
name|BufferedNorms
index|[
literal|0
index|]
decl_stmt|;
comment|// Holds norms until we flush
DECL|method|DocumentsWriter
name|DocumentsWriter
parameter_list|(
name|Directory
name|directory
parameter_list|,
name|IndexWriter
name|writer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
name|this
operator|.
name|writer
operator|=
name|writer
expr_stmt|;
name|postingsFreeList
operator|=
operator|new
name|Posting
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/** If non-null, various details of indexing are printed    *  here. */
DECL|method|setInfoStream
name|void
name|setInfoStream
parameter_list|(
name|PrintStream
name|infoStream
parameter_list|)
block|{
name|this
operator|.
name|infoStream
operator|=
name|infoStream
expr_stmt|;
block|}
comment|/** Set how much RAM we can use before flushing. */
DECL|method|setRAMBufferSizeMB
name|void
name|setRAMBufferSizeMB
parameter_list|(
name|double
name|mb
parameter_list|)
block|{
name|ramBufferSize
operator|=
call|(
name|long
call|)
argument_list|(
name|mb
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
block|}
DECL|method|getRAMBufferSizeMB
name|double
name|getRAMBufferSizeMB
parameter_list|()
block|{
return|return
name|ramBufferSize
operator|/
literal|1024.
operator|/
literal|1024.
return|;
block|}
comment|/** Set max buffered docs, which means we will flush by    *  doc count instead of by RAM usage. */
DECL|method|setMaxBufferedDocs
name|void
name|setMaxBufferedDocs
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|maxBufferedDocs
operator|=
name|count
expr_stmt|;
name|ramBufferSize
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|getMaxBufferedDocs
name|int
name|getMaxBufferedDocs
parameter_list|()
block|{
return|return
name|maxBufferedDocs
return|;
block|}
comment|/** Get current segment name we are writing. */
DECL|method|getSegment
name|String
name|getSegment
parameter_list|()
block|{
return|return
name|segment
return|;
block|}
comment|/** Returns how many docs are currently buffered in RAM. */
DECL|method|getNumDocsInRAM
name|int
name|getNumDocsInRAM
parameter_list|()
block|{
return|return
name|numDocsInRAM
return|;
block|}
comment|/** Returns the current doc store segment we are writing    *  to.  This will be the same as segment when autoCommit    *  * is true. */
DECL|method|getDocStoreSegment
name|String
name|getDocStoreSegment
parameter_list|()
block|{
return|return
name|docStoreSegment
return|;
block|}
comment|/** Returns the doc offset into the shared doc store for    *  the current buffered docs. */
DECL|method|getDocStoreOffset
name|int
name|getDocStoreOffset
parameter_list|()
block|{
return|return
name|docStoreOffset
return|;
block|}
comment|/** Closes the current open doc stores an returns the doc    *  store segment name.  This returns null if there are *    *  no buffered documents. */
DECL|method|closeDocStore
name|String
name|closeDocStore
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|allThreadsIdle
argument_list|()
assert|;
name|List
name|flushedFiles
init|=
name|files
argument_list|()
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"\ncloseDocStore: "
operator|+
name|flushedFiles
operator|.
name|size
argument_list|()
operator|+
literal|" files to flush to segment "
operator|+
name|docStoreSegment
argument_list|)
expr_stmt|;
if|if
condition|(
name|flushedFiles
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|files
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|tvx
operator|!=
literal|null
condition|)
block|{
comment|// At least one doc in this run had term vectors enabled
assert|assert
name|docStoreSegment
operator|!=
literal|null
assert|;
name|tvx
operator|.
name|close
argument_list|()
expr_stmt|;
name|tvf
operator|.
name|close
argument_list|()
expr_stmt|;
name|tvd
operator|.
name|close
argument_list|()
expr_stmt|;
name|tvx
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|fieldsWriter
operator|!=
literal|null
condition|)
block|{
assert|assert
name|docStoreSegment
operator|!=
literal|null
assert|;
name|fieldsWriter
operator|.
name|close
argument_list|()
expr_stmt|;
name|fieldsWriter
operator|=
literal|null
expr_stmt|;
block|}
name|String
name|s
init|=
name|docStoreSegment
decl_stmt|;
name|docStoreSegment
operator|=
literal|null
expr_stmt|;
name|docStoreOffset
operator|=
literal|0
expr_stmt|;
return|return
name|s
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
DECL|field|files
specifier|private
name|List
name|files
init|=
literal|null
decl_stmt|;
comment|// Cached list of files we've created
comment|/* Returns list of files in use by this instance,    * including any flushed segments. */
DECL|method|files
name|List
name|files
parameter_list|()
block|{
if|if
condition|(
name|files
operator|!=
literal|null
condition|)
return|return
name|files
return|;
name|files
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
comment|// Stored fields:
if|if
condition|(
name|fieldsWriter
operator|!=
literal|null
condition|)
block|{
assert|assert
name|docStoreSegment
operator|!=
literal|null
assert|;
name|files
operator|.
name|add
argument_list|(
name|docStoreSegment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|FIELDS_EXTENSION
argument_list|)
expr_stmt|;
name|files
operator|.
name|add
argument_list|(
name|docStoreSegment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|FIELDS_INDEX_EXTENSION
argument_list|)
expr_stmt|;
block|}
comment|// Vectors:
if|if
condition|(
name|tvx
operator|!=
literal|null
condition|)
block|{
assert|assert
name|docStoreSegment
operator|!=
literal|null
assert|;
name|files
operator|.
name|add
argument_list|(
name|docStoreSegment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|VECTORS_INDEX_EXTENSION
argument_list|)
expr_stmt|;
name|files
operator|.
name|add
argument_list|(
name|docStoreSegment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|VECTORS_FIELDS_EXTENSION
argument_list|)
expr_stmt|;
name|files
operator|.
name|add
argument_list|(
name|docStoreSegment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|VECTORS_DOCUMENTS_EXTENSION
argument_list|)
expr_stmt|;
block|}
return|return
name|files
return|;
block|}
comment|/** Called if we hit an exception when adding docs,    *  flushing, etc.  This resets our state, discarding any    *  * docs added since last flush. */
DECL|method|abort
name|void
name|abort
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Forcefully remove waiting ThreadStates from line
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numWaiting
condition|;
name|i
operator|++
control|)
name|waitingThreadStates
index|[
name|i
index|]
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
name|numWaiting
operator|=
literal|0
expr_stmt|;
name|pauseAllThreads
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Discard pending norms:
specifier|final
name|int
name|numField
init|=
name|fieldInfos
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numField
condition|;
name|i
operator|++
control|)
block|{
name|FieldInfo
name|fi
init|=
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|isIndexed
operator|&&
operator|!
name|fi
operator|.
name|omitNorms
condition|)
block|{
name|BufferedNorms
name|n
init|=
name|norms
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|null
condition|)
block|{
name|n
operator|.
name|out
operator|.
name|reset
argument_list|()
expr_stmt|;
name|n
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// Reset vectors writer
if|if
condition|(
name|tvx
operator|!=
literal|null
condition|)
block|{
name|tvx
operator|.
name|close
argument_list|()
expr_stmt|;
name|tvf
operator|.
name|close
argument_list|()
expr_stmt|;
name|tvd
operator|.
name|close
argument_list|()
expr_stmt|;
name|tvx
operator|=
literal|null
expr_stmt|;
block|}
comment|// Reset fields writer
if|if
condition|(
name|fieldsWriter
operator|!=
literal|null
condition|)
block|{
name|fieldsWriter
operator|.
name|close
argument_list|()
expr_stmt|;
name|fieldsWriter
operator|=
literal|null
expr_stmt|;
block|}
comment|// Reset all postings data
name|resetPostingsData
argument_list|()
expr_stmt|;
comment|// Clear vectors& fields from ThreadStates
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ThreadState
name|state
init|=
name|threadStates
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|state
operator|.
name|localFieldsWriter
operator|!=
literal|null
condition|)
block|{
name|state
operator|.
name|localFieldsWriter
operator|.
name|close
argument_list|()
expr_stmt|;
name|state
operator|.
name|localFieldsWriter
operator|=
literal|null
expr_stmt|;
block|}
name|state
operator|.
name|tvfLocal
operator|.
name|reset
argument_list|()
expr_stmt|;
name|state
operator|.
name|fdtLocal
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
name|files
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|resumeAllThreads
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Reset after a flush */
DECL|method|resetPostingsData
specifier|private
name|void
name|resetPostingsData
parameter_list|()
throws|throws
name|IOException
block|{
comment|// All ThreadStates should be idle when we are called
assert|assert
name|allThreadsIdle
argument_list|()
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|threadStates
index|[
name|i
index|]
operator|.
name|resetPostings
argument_list|()
expr_stmt|;
name|threadStates
index|[
name|i
index|]
operator|.
name|numThreads
operator|=
literal|0
expr_stmt|;
block|}
name|threadBindings
operator|.
name|clear
argument_list|()
expr_stmt|;
name|numBytesUsed
operator|=
literal|0
expr_stmt|;
name|balanceRAM
argument_list|()
expr_stmt|;
name|postingsIsFull
operator|=
literal|false
expr_stmt|;
name|flushPending
operator|=
literal|false
expr_stmt|;
name|segment
operator|=
literal|null
expr_stmt|;
name|numDocsInRAM
operator|=
literal|0
expr_stmt|;
name|nextDocID
operator|=
literal|0
expr_stmt|;
name|nextWriteDocID
operator|=
literal|0
expr_stmt|;
name|files
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|pauseAllThreads
specifier|synchronized
name|void
name|pauseAllThreads
parameter_list|()
block|{
name|pauseThreads
operator|++
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|pauseThreads
condition|)
block|{
while|while
condition|(
operator|!
name|allThreadsIdle
argument_list|()
condition|)
block|{
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{         }
block|}
block|}
block|}
DECL|method|resumeAllThreads
specifier|synchronized
name|void
name|resumeAllThreads
parameter_list|()
block|{
name|pauseThreads
operator|--
expr_stmt|;
assert|assert
name|pauseThreads
operator|>=
literal|0
assert|;
if|if
condition|(
literal|0
operator|==
name|pauseThreads
condition|)
name|notifyAll
argument_list|()
expr_stmt|;
block|}
DECL|method|allThreadsIdle
specifier|private
specifier|synchronized
name|boolean
name|allThreadsIdle
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|threadStates
index|[
name|i
index|]
operator|.
name|isIdle
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
DECL|field|hasNorms
specifier|private
name|boolean
name|hasNorms
decl_stmt|;
comment|// Whether any norms were seen since last flush
DECL|field|newFiles
name|List
name|newFiles
decl_stmt|;
comment|/** Flush all pending docs to a new segment */
DECL|method|flush
name|int
name|flush
parameter_list|(
name|boolean
name|closeDocStore
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|allThreadsIdle
argument_list|()
assert|;
if|if
condition|(
name|segment
operator|==
literal|null
condition|)
comment|// In case we are asked to flush an empty segment
name|segment
operator|=
name|writer
operator|.
name|newSegmentName
argument_list|()
expr_stmt|;
name|newFiles
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
name|docStoreOffset
operator|+=
name|numDocsInRAM
expr_stmt|;
if|if
condition|(
name|closeDocStore
condition|)
block|{
assert|assert
name|docStoreSegment
operator|!=
literal|null
assert|;
assert|assert
name|docStoreSegment
operator|.
name|equals
argument_list|(
name|segment
argument_list|)
assert|;
name|newFiles
operator|.
name|addAll
argument_list|(
name|files
argument_list|()
argument_list|)
expr_stmt|;
name|closeDocStore
argument_list|()
expr_stmt|;
block|}
name|int
name|docCount
decl_stmt|;
assert|assert
name|numDocsInRAM
operator|>
literal|0
assert|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"\nflush postings as segment "
operator|+
name|segment
operator|+
literal|" numDocs="
operator|+
name|numDocsInRAM
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|fieldInfos
operator|.
name|write
argument_list|(
name|directory
argument_list|,
name|segment
operator|+
literal|".fnm"
argument_list|)
expr_stmt|;
name|docCount
operator|=
name|numDocsInRAM
expr_stmt|;
name|newFiles
operator|.
name|addAll
argument_list|(
name|writeSegment
argument_list|()
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|docCount
return|;
block|}
comment|/** Build compound file for the segment we just flushed */
DECL|method|createCompoundFile
name|void
name|createCompoundFile
parameter_list|(
name|String
name|segment
parameter_list|)
throws|throws
name|IOException
block|{
name|CompoundFileWriter
name|cfsWriter
init|=
operator|new
name|CompoundFileWriter
argument_list|(
name|directory
argument_list|,
name|segment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|COMPOUND_FILE_EXTENSION
argument_list|)
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|newFiles
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|cfsWriter
operator|.
name|addFile
argument_list|(
operator|(
name|String
operator|)
name|newFiles
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// Perform the merge
name|cfsWriter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Set flushPending if it is not already set and returns    *  whether it was set. This is used by IndexWriter to *    *  trigger a single flush even when multiple threads are    *  * trying to do so. */
DECL|method|setFlushPending
specifier|synchronized
name|boolean
name|setFlushPending
parameter_list|()
block|{
if|if
condition|(
name|flushPending
condition|)
return|return
literal|false
return|;
else|else
block|{
name|flushPending
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
DECL|method|clearFlushPending
specifier|synchronized
name|void
name|clearFlushPending
parameter_list|()
block|{
name|flushPending
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Per-thread state.  We keep a separate Posting hash and    *  other state for each thread and then merge postings *    *  hashes from all threads when writing the segment. */
DECL|class|ThreadState
specifier|private
specifier|final
class|class
name|ThreadState
block|{
DECL|field|postingsFreeList
name|Posting
index|[]
name|postingsFreeList
decl_stmt|;
comment|// Free Posting instances
DECL|field|postingsFreeCount
name|int
name|postingsFreeCount
decl_stmt|;
DECL|field|tvfLocal
name|RAMOutputStream
name|tvfLocal
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
comment|// Term vectors for one doc
DECL|field|fdtLocal
name|RAMOutputStream
name|fdtLocal
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
comment|// Stored fields for one doc
DECL|field|localFieldsWriter
name|FieldsWriter
name|localFieldsWriter
decl_stmt|;
comment|// Fields for one doc
DECL|field|vectorFieldPointers
name|long
index|[]
name|vectorFieldPointers
decl_stmt|;
DECL|field|vectorFieldNumbers
name|int
index|[]
name|vectorFieldNumbers
decl_stmt|;
DECL|field|isIdle
name|boolean
name|isIdle
init|=
literal|true
decl_stmt|;
comment|// Whether we are in use
DECL|field|numThreads
name|int
name|numThreads
init|=
literal|1
decl_stmt|;
comment|// Number of threads that use this instance
DECL|field|docID
name|int
name|docID
decl_stmt|;
comment|// docID we are now working on
DECL|field|numStoredFields
name|int
name|numStoredFields
decl_stmt|;
comment|// How many stored fields in current doc
DECL|field|docBoost
name|float
name|docBoost
decl_stmt|;
comment|// Boost for current doc
DECL|field|fieldDataArray
name|FieldData
index|[]
name|fieldDataArray
decl_stmt|;
comment|// Fields touched by current doc
DECL|field|numFieldData
name|int
name|numFieldData
decl_stmt|;
comment|// How many fields in current doc
DECL|field|numVectorFields
name|int
name|numVectorFields
decl_stmt|;
comment|// How many vector fields in current doc
DECL|field|allFieldDataArray
name|FieldData
index|[]
name|allFieldDataArray
init|=
operator|new
name|FieldData
index|[
literal|10
index|]
decl_stmt|;
comment|// All FieldData instances
DECL|field|numAllFieldData
name|int
name|numAllFieldData
decl_stmt|;
DECL|field|fieldDataHash
name|FieldData
index|[]
name|fieldDataHash
decl_stmt|;
comment|// Hash FieldData instances by field name
DECL|field|fieldDataHashMask
name|int
name|fieldDataHashMask
decl_stmt|;
DECL|field|doFlushAfter
name|boolean
name|doFlushAfter
decl_stmt|;
DECL|method|ThreadState
specifier|public
name|ThreadState
parameter_list|()
block|{
name|fieldDataArray
operator|=
operator|new
name|FieldData
index|[
literal|8
index|]
expr_stmt|;
name|fieldDataHash
operator|=
operator|new
name|FieldData
index|[
literal|16
index|]
expr_stmt|;
name|fieldDataHashMask
operator|=
literal|15
expr_stmt|;
name|vectorFieldPointers
operator|=
operator|new
name|long
index|[
literal|10
index|]
expr_stmt|;
name|vectorFieldNumbers
operator|=
operator|new
name|int
index|[
literal|10
index|]
expr_stmt|;
name|postingsFreeList
operator|=
operator|new
name|Posting
index|[
literal|256
index|]
expr_stmt|;
name|postingsFreeCount
operator|=
literal|0
expr_stmt|;
block|}
comment|/** Clear the postings hash and return objects back to      *  shared pool */
DECL|method|resetPostings
specifier|public
name|void
name|resetPostings
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|localFieldsWriter
operator|!=
literal|null
condition|)
block|{
name|localFieldsWriter
operator|.
name|close
argument_list|()
expr_stmt|;
name|localFieldsWriter
operator|=
literal|null
expr_stmt|;
block|}
name|maxPostingsVectors
operator|=
literal|0
expr_stmt|;
name|doFlushAfter
operator|=
literal|false
expr_stmt|;
name|postingsPool
operator|.
name|reset
argument_list|()
expr_stmt|;
name|charPool
operator|.
name|reset
argument_list|()
expr_stmt|;
name|recyclePostings
argument_list|(
name|postingsFreeList
argument_list|,
name|postingsFreeCount
argument_list|)
expr_stmt|;
name|postingsFreeCount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numAllFieldData
condition|;
name|i
operator|++
control|)
block|{
name|FieldData
name|fp
init|=
name|allFieldDataArray
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|fp
operator|.
name|numPostings
operator|>
literal|0
condition|)
name|fp
operator|.
name|resetPostingArrays
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Move all per-document state that was accumulated in      *  the ThreadState into the "real" stores. */
DECL|method|writeDocument
specifier|public
name|void
name|writeDocument
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Append stored fields to the real FieldsWriter:
name|fieldsWriter
operator|.
name|flushDocument
argument_list|(
name|fdtLocal
argument_list|)
expr_stmt|;
name|fdtLocal
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Append term vectors to the real outputs:
if|if
condition|(
name|tvx
operator|!=
literal|null
condition|)
block|{
name|tvx
operator|.
name|writeLong
argument_list|(
name|tvd
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|numVectorFields
operator|>
literal|0
condition|)
block|{
name|tvd
operator|.
name|writeVInt
argument_list|(
name|numVectorFields
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numVectorFields
condition|;
name|i
operator|++
control|)
name|tvd
operator|.
name|writeVInt
argument_list|(
name|vectorFieldNumbers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
assert|assert
literal|0
operator|==
name|vectorFieldPointers
index|[
literal|0
index|]
assert|;
name|tvd
operator|.
name|writeVLong
argument_list|(
name|tvf
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|lastPos
init|=
name|vectorFieldPointers
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numVectorFields
condition|;
name|i
operator|++
control|)
block|{
name|long
name|pos
init|=
name|vectorFieldPointers
index|[
name|i
index|]
decl_stmt|;
name|tvd
operator|.
name|writeVLong
argument_list|(
name|pos
operator|-
name|lastPos
argument_list|)
expr_stmt|;
name|lastPos
operator|=
name|pos
expr_stmt|;
block|}
name|tvfLocal
operator|.
name|writeTo
argument_list|(
name|tvf
argument_list|)
expr_stmt|;
name|tvfLocal
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Append norms for the fields we saw:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFieldData
condition|;
name|i
operator|++
control|)
block|{
name|FieldData
name|fp
init|=
name|fieldDataArray
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|fp
operator|.
name|doNorms
condition|)
block|{
name|BufferedNorms
name|bn
init|=
name|norms
index|[
name|fp
operator|.
name|fieldInfo
operator|.
name|number
index|]
decl_stmt|;
assert|assert
name|bn
operator|!=
literal|null
assert|;
assert|assert
name|bn
operator|.
name|upto
operator|<=
name|docID
assert|;
name|bn
operator|.
name|fill
argument_list|(
name|docID
argument_list|)
expr_stmt|;
name|float
name|norm
init|=
name|fp
operator|.
name|boost
operator|*
name|writer
operator|.
name|getSimilarity
argument_list|()
operator|.
name|lengthNorm
argument_list|(
name|fp
operator|.
name|fieldInfo
operator|.
name|name
argument_list|,
name|fp
operator|.
name|length
argument_list|)
decl_stmt|;
name|bn
operator|.
name|add
argument_list|(
name|norm
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|postingsIsFull
operator|&&
operator|!
name|flushPending
condition|)
block|{
name|flushPending
operator|=
literal|true
expr_stmt|;
name|doFlushAfter
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/** Initializes shared state for this new document */
DECL|method|init
name|void
name|init
parameter_list|(
name|Document
name|doc
parameter_list|,
name|int
name|docID
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|docID
operator|=
name|docID
expr_stmt|;
name|docBoost
operator|=
name|doc
operator|.
name|getBoost
argument_list|()
expr_stmt|;
name|numStoredFields
operator|=
literal|0
expr_stmt|;
name|numFieldData
operator|=
literal|0
expr_stmt|;
name|numVectorFields
operator|=
literal|0
expr_stmt|;
name|List
name|docFields
init|=
name|doc
operator|.
name|getFields
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numDocFields
init|=
name|docFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|boolean
name|docHasVectors
init|=
literal|false
decl_stmt|;
comment|// Absorb any new fields first seen in this document.
comment|// Also absorb any changes to fields we had already
comment|// seen before (eg suddenly turning on norms or
comment|// vectors, etc.):
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numDocFields
condition|;
name|i
operator|++
control|)
block|{
name|Fieldable
name|field
init|=
operator|(
name|Fieldable
operator|)
name|docFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|FieldInfo
name|fi
init|=
name|fieldInfos
operator|.
name|add
argument_list|(
name|field
operator|.
name|name
argument_list|()
argument_list|,
name|field
operator|.
name|isIndexed
argument_list|()
argument_list|,
name|field
operator|.
name|isTermVectorStored
argument_list|()
argument_list|,
name|field
operator|.
name|isStorePositionWithTermVector
argument_list|()
argument_list|,
name|field
operator|.
name|isStoreOffsetWithTermVector
argument_list|()
argument_list|,
name|field
operator|.
name|getOmitNorms
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|numStoredFields
operator|+=
name|field
operator|.
name|isStored
argument_list|()
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|fi
operator|.
name|isIndexed
operator|&&
operator|!
name|fi
operator|.
name|omitNorms
condition|)
block|{
comment|// Maybe grow our buffered norms
if|if
condition|(
name|norms
operator|.
name|length
operator|<=
name|fi
operator|.
name|number
condition|)
block|{
name|int
name|newSize
init|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|1
operator|+
name|fi
operator|.
name|number
operator|)
operator|*
literal|1.25
argument_list|)
decl_stmt|;
name|BufferedNorms
index|[]
name|newNorms
init|=
operator|new
name|BufferedNorms
index|[
name|newSize
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|norms
argument_list|,
literal|0
argument_list|,
name|newNorms
argument_list|,
literal|0
argument_list|,
name|norms
operator|.
name|length
argument_list|)
expr_stmt|;
name|norms
operator|=
name|newNorms
expr_stmt|;
block|}
if|if
condition|(
name|norms
index|[
name|fi
operator|.
name|number
index|]
operator|==
literal|null
condition|)
name|norms
index|[
name|fi
operator|.
name|number
index|]
operator|=
operator|new
name|BufferedNorms
argument_list|()
expr_stmt|;
name|hasNorms
operator|=
literal|true
expr_stmt|;
block|}
comment|// Make sure we have a FieldData allocated
name|int
name|hashPos
init|=
name|fi
operator|.
name|name
operator|.
name|hashCode
argument_list|()
operator|&
name|fieldDataHashMask
decl_stmt|;
name|FieldData
name|fp
init|=
name|fieldDataHash
index|[
name|hashPos
index|]
decl_stmt|;
while|while
condition|(
name|fp
operator|!=
literal|null
operator|&&
operator|!
name|fp
operator|.
name|fieldInfo
operator|.
name|name
operator|.
name|equals
argument_list|(
name|fi
operator|.
name|name
argument_list|)
condition|)
name|fp
operator|=
name|fp
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|fp
operator|==
literal|null
condition|)
block|{
name|fp
operator|=
operator|new
name|FieldData
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|fp
operator|.
name|next
operator|=
name|fieldDataHash
index|[
name|hashPos
index|]
expr_stmt|;
name|fieldDataHash
index|[
name|hashPos
index|]
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|numAllFieldData
operator|==
name|allFieldDataArray
operator|.
name|length
condition|)
block|{
name|int
name|newSize
init|=
call|(
name|int
call|)
argument_list|(
name|allFieldDataArray
operator|.
name|length
operator|*
literal|1.5
argument_list|)
decl_stmt|;
name|FieldData
name|newArray
index|[]
init|=
operator|new
name|FieldData
index|[
name|newSize
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|allFieldDataArray
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|numAllFieldData
argument_list|)
expr_stmt|;
name|allFieldDataArray
operator|=
name|newArray
expr_stmt|;
comment|// Rehash
name|newSize
operator|=
name|fieldDataHash
operator|.
name|length
operator|*
literal|2
expr_stmt|;
name|newArray
operator|=
operator|new
name|FieldData
index|[
name|newSize
index|]
expr_stmt|;
name|fieldDataHashMask
operator|=
name|newSize
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|fieldDataHash
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|FieldData
name|fp0
init|=
name|fieldDataHash
index|[
name|j
index|]
decl_stmt|;
while|while
condition|(
name|fp0
operator|!=
literal|null
condition|)
block|{
name|hashPos
operator|=
name|fp0
operator|.
name|fieldInfo
operator|.
name|name
operator|.
name|hashCode
argument_list|()
operator|&
name|fieldDataHashMask
expr_stmt|;
name|FieldData
name|nextFP0
init|=
name|fp0
operator|.
name|next
decl_stmt|;
name|fp0
operator|.
name|next
operator|=
name|newArray
index|[
name|hashPos
index|]
expr_stmt|;
name|newArray
index|[
name|hashPos
index|]
operator|=
name|fp0
expr_stmt|;
name|fp0
operator|=
name|nextFP0
expr_stmt|;
block|}
block|}
name|fieldDataHash
operator|=
name|newArray
expr_stmt|;
block|}
name|allFieldDataArray
index|[
name|numAllFieldData
operator|++
index|]
operator|=
name|fp
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|fp
operator|.
name|fieldInfo
operator|==
name|fi
assert|;
block|}
if|if
condition|(
name|docID
operator|!=
name|fp
operator|.
name|lastDocID
condition|)
block|{
comment|// First time we're seeing this field for this doc
name|fp
operator|.
name|lastDocID
operator|=
name|docID
expr_stmt|;
name|fp
operator|.
name|fieldCount
operator|=
literal|0
expr_stmt|;
name|fp
operator|.
name|doVectors
operator|=
name|fp
operator|.
name|doVectorPositions
operator|=
name|fp
operator|.
name|doVectorOffsets
operator|=
literal|false
expr_stmt|;
name|fp
operator|.
name|doNorms
operator|=
name|fi
operator|.
name|isIndexed
operator|&&
operator|!
name|fi
operator|.
name|omitNorms
expr_stmt|;
if|if
condition|(
name|numFieldData
operator|==
name|fieldDataArray
operator|.
name|length
condition|)
block|{
name|int
name|newSize
init|=
name|fieldDataArray
operator|.
name|length
operator|*
literal|2
decl_stmt|;
name|FieldData
name|newArray
index|[]
init|=
operator|new
name|FieldData
index|[
name|newSize
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|fieldDataArray
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|numFieldData
argument_list|)
expr_stmt|;
name|fieldDataArray
operator|=
name|newArray
expr_stmt|;
block|}
name|fieldDataArray
index|[
name|numFieldData
operator|++
index|]
operator|=
name|fp
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|.
name|isTermVectorStored
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|fp
operator|.
name|doVectors
condition|)
block|{
if|if
condition|(
name|numVectorFields
operator|++
operator|==
name|vectorFieldPointers
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|newSize
init|=
call|(
name|int
call|)
argument_list|(
name|numVectorFields
operator|*
literal|1.5
argument_list|)
decl_stmt|;
name|vectorFieldPointers
operator|=
operator|new
name|long
index|[
name|newSize
index|]
expr_stmt|;
name|vectorFieldNumbers
operator|=
operator|new
name|int
index|[
name|newSize
index|]
expr_stmt|;
block|}
block|}
name|fp
operator|.
name|doVectors
operator|=
literal|true
expr_stmt|;
name|docHasVectors
operator|=
literal|true
expr_stmt|;
name|fp
operator|.
name|doVectorPositions
operator||=
name|field
operator|.
name|isStorePositionWithTermVector
argument_list|()
expr_stmt|;
name|fp
operator|.
name|doVectorOffsets
operator||=
name|field
operator|.
name|isStoreOffsetWithTermVector
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|.
name|fieldCount
operator|==
name|fp
operator|.
name|docFields
operator|.
name|length
condition|)
block|{
name|Fieldable
index|[]
name|newArray
init|=
operator|new
name|Fieldable
index|[
name|fp
operator|.
name|docFields
operator|.
name|length
operator|*
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|fp
operator|.
name|docFields
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|fp
operator|.
name|docFields
operator|.
name|length
argument_list|)
expr_stmt|;
name|fp
operator|.
name|docFields
operator|=
name|newArray
expr_stmt|;
block|}
comment|// Lazily allocate arrays for postings:
if|if
condition|(
name|field
operator|.
name|isIndexed
argument_list|()
operator|&&
name|fp
operator|.
name|postingsHash
operator|==
literal|null
condition|)
name|fp
operator|.
name|initPostingArrays
argument_list|()
expr_stmt|;
name|fp
operator|.
name|docFields
index|[
name|fp
operator|.
name|fieldCount
operator|++
index|]
operator|=
name|field
expr_stmt|;
block|}
specifier|final
name|int
name|numFields
init|=
name|fieldInfos
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Maybe init the local& global fieldsWriter
if|if
condition|(
name|localFieldsWriter
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|fieldsWriter
operator|==
literal|null
condition|)
block|{
assert|assert
name|docStoreSegment
operator|==
literal|null
assert|;
assert|assert
name|segment
operator|!=
literal|null
assert|;
name|docStoreSegment
operator|=
name|segment
expr_stmt|;
name|fieldsWriter
operator|=
operator|new
name|FieldsWriter
argument_list|(
name|directory
argument_list|,
name|docStoreSegment
argument_list|,
name|fieldInfos
argument_list|)
expr_stmt|;
name|files
operator|=
literal|null
expr_stmt|;
block|}
name|localFieldsWriter
operator|=
operator|new
name|FieldsWriter
argument_list|(
literal|null
argument_list|,
name|fdtLocal
argument_list|,
name|fieldInfos
argument_list|)
expr_stmt|;
block|}
comment|// First time we see a doc that has field(s) with
comment|// stored vectors, we init our tvx writer
if|if
condition|(
name|docHasVectors
condition|)
block|{
if|if
condition|(
name|tvx
operator|==
literal|null
condition|)
block|{
assert|assert
name|docStoreSegment
operator|!=
literal|null
assert|;
name|tvx
operator|=
name|directory
operator|.
name|createOutput
argument_list|(
name|docStoreSegment
operator|+
name|TermVectorsWriter
operator|.
name|TVX_EXTENSION
argument_list|)
expr_stmt|;
name|tvx
operator|.
name|writeInt
argument_list|(
name|TermVectorsWriter
operator|.
name|FORMAT_VERSION
argument_list|)
expr_stmt|;
name|tvd
operator|=
name|directory
operator|.
name|createOutput
argument_list|(
name|docStoreSegment
operator|+
name|TermVectorsWriter
operator|.
name|TVD_EXTENSION
argument_list|)
expr_stmt|;
name|tvd
operator|.
name|writeInt
argument_list|(
name|TermVectorsWriter
operator|.
name|FORMAT_VERSION
argument_list|)
expr_stmt|;
name|tvf
operator|=
name|directory
operator|.
name|createOutput
argument_list|(
name|docStoreSegment
operator|+
name|TermVectorsWriter
operator|.
name|TVF_EXTENSION
argument_list|)
expr_stmt|;
name|tvf
operator|.
name|writeInt
argument_list|(
name|TermVectorsWriter
operator|.
name|FORMAT_VERSION
argument_list|)
expr_stmt|;
name|files
operator|=
literal|null
expr_stmt|;
comment|// We must "catch up" for all docIDs that had no
comment|// vectors before this one
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docID
condition|;
name|i
operator|++
control|)
name|tvx
operator|.
name|writeLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|numVectorFields
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/** Do in-place sort of Posting array */
DECL|method|doPostingSort
specifier|final
name|void
name|doPostingSort
parameter_list|(
name|Posting
index|[]
name|postings
parameter_list|,
name|int
name|numPosting
parameter_list|)
block|{
name|quickSort
argument_list|(
name|postings
argument_list|,
literal|0
argument_list|,
name|numPosting
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|quickSort
specifier|final
name|void
name|quickSort
parameter_list|(
name|Posting
index|[]
name|postings
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
if|if
condition|(
name|lo
operator|>=
name|hi
condition|)
return|return;
name|int
name|mid
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>>
literal|1
decl_stmt|;
if|if
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|lo
index|]
argument_list|,
name|postings
index|[
name|mid
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|Posting
name|tmp
init|=
name|postings
index|[
name|lo
index|]
decl_stmt|;
name|postings
index|[
name|lo
index|]
operator|=
name|postings
index|[
name|mid
index|]
expr_stmt|;
name|postings
index|[
name|mid
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|mid
index|]
argument_list|,
name|postings
index|[
name|hi
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|Posting
name|tmp
init|=
name|postings
index|[
name|mid
index|]
decl_stmt|;
name|postings
index|[
name|mid
index|]
operator|=
name|postings
index|[
name|hi
index|]
expr_stmt|;
name|postings
index|[
name|hi
index|]
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|lo
index|]
argument_list|,
name|postings
index|[
name|mid
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|Posting
name|tmp2
init|=
name|postings
index|[
name|lo
index|]
decl_stmt|;
name|postings
index|[
name|lo
index|]
operator|=
name|postings
index|[
name|mid
index|]
expr_stmt|;
name|postings
index|[
name|mid
index|]
operator|=
name|tmp2
expr_stmt|;
block|}
block|}
name|int
name|left
init|=
name|lo
operator|+
literal|1
decl_stmt|;
name|int
name|right
init|=
name|hi
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|left
operator|>=
name|right
condition|)
return|return;
name|Posting
name|partition
init|=
name|postings
index|[
name|mid
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|right
index|]
argument_list|,
name|partition
argument_list|)
operator|>
literal|0
condition|)
operator|--
name|right
expr_stmt|;
while|while
condition|(
name|left
operator|<
name|right
operator|&&
name|comparePostings
argument_list|(
name|postings
index|[
name|left
index|]
argument_list|,
name|partition
argument_list|)
operator|<=
literal|0
condition|)
operator|++
name|left
expr_stmt|;
if|if
condition|(
name|left
operator|<
name|right
condition|)
block|{
name|Posting
name|tmp
init|=
name|postings
index|[
name|left
index|]
decl_stmt|;
name|postings
index|[
name|left
index|]
operator|=
name|postings
index|[
name|right
index|]
expr_stmt|;
name|postings
index|[
name|right
index|]
operator|=
name|tmp
expr_stmt|;
operator|--
name|right
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|quickSort
argument_list|(
name|postings
argument_list|,
name|lo
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|quickSort
argument_list|(
name|postings
argument_list|,
name|left
operator|+
literal|1
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
comment|/** Do in-place sort of PostingVector array */
DECL|method|doVectorSort
specifier|final
name|void
name|doVectorSort
parameter_list|(
name|PostingVector
index|[]
name|postings
parameter_list|,
name|int
name|numPosting
parameter_list|)
block|{
name|quickSort
argument_list|(
name|postings
argument_list|,
literal|0
argument_list|,
name|numPosting
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|quickSort
specifier|final
name|void
name|quickSort
parameter_list|(
name|PostingVector
index|[]
name|postings
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
if|if
condition|(
name|lo
operator|>=
name|hi
condition|)
return|return;
name|int
name|mid
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>>
literal|1
decl_stmt|;
if|if
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|lo
index|]
operator|.
name|p
argument_list|,
name|postings
index|[
name|mid
index|]
operator|.
name|p
argument_list|)
operator|>
literal|0
condition|)
block|{
name|PostingVector
name|tmp
init|=
name|postings
index|[
name|lo
index|]
decl_stmt|;
name|postings
index|[
name|lo
index|]
operator|=
name|postings
index|[
name|mid
index|]
expr_stmt|;
name|postings
index|[
name|mid
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|mid
index|]
operator|.
name|p
argument_list|,
name|postings
index|[
name|hi
index|]
operator|.
name|p
argument_list|)
operator|>
literal|0
condition|)
block|{
name|PostingVector
name|tmp
init|=
name|postings
index|[
name|mid
index|]
decl_stmt|;
name|postings
index|[
name|mid
index|]
operator|=
name|postings
index|[
name|hi
index|]
expr_stmt|;
name|postings
index|[
name|hi
index|]
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|lo
index|]
operator|.
name|p
argument_list|,
name|postings
index|[
name|mid
index|]
operator|.
name|p
argument_list|)
operator|>
literal|0
condition|)
block|{
name|PostingVector
name|tmp2
init|=
name|postings
index|[
name|lo
index|]
decl_stmt|;
name|postings
index|[
name|lo
index|]
operator|=
name|postings
index|[
name|mid
index|]
expr_stmt|;
name|postings
index|[
name|mid
index|]
operator|=
name|tmp2
expr_stmt|;
block|}
block|}
name|int
name|left
init|=
name|lo
operator|+
literal|1
decl_stmt|;
name|int
name|right
init|=
name|hi
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|left
operator|>=
name|right
condition|)
return|return;
name|PostingVector
name|partition
init|=
name|postings
index|[
name|mid
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|comparePostings
argument_list|(
name|postings
index|[
name|right
index|]
operator|.
name|p
argument_list|,
name|partition
operator|.
name|p
argument_list|)
operator|>
literal|0
condition|)
operator|--
name|right
expr_stmt|;
while|while
condition|(
name|left
operator|<
name|right
operator|&&
name|comparePostings
argument_list|(
name|postings
index|[
name|left
index|]
operator|.
name|p
argument_list|,
name|partition
operator|.
name|p
argument_list|)
operator|<=
literal|0
condition|)
operator|++
name|left
expr_stmt|;
if|if
condition|(
name|left
operator|<
name|right
condition|)
block|{
name|PostingVector
name|tmp
init|=
name|postings
index|[
name|left
index|]
decl_stmt|;
name|postings
index|[
name|left
index|]
operator|=
name|postings
index|[
name|right
index|]
expr_stmt|;
name|postings
index|[
name|right
index|]
operator|=
name|tmp
expr_stmt|;
operator|--
name|right
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|quickSort
argument_list|(
name|postings
argument_list|,
name|lo
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|quickSort
argument_list|(
name|postings
argument_list|,
name|left
operator|+
literal|1
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
comment|/** If there are fields we've seen but did not see again      *  in the last run, then free them up.  Also reduce      *  postings hash size. */
DECL|method|trimFields
name|void
name|trimFields
parameter_list|()
block|{
name|int
name|upto
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numAllFieldData
condition|;
name|i
operator|++
control|)
block|{
name|FieldData
name|fp
init|=
name|allFieldDataArray
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|fp
operator|.
name|lastDocID
operator|==
operator|-
literal|1
condition|)
block|{
comment|// This field was not seen since the previous
comment|// flush, so, free up its resources now
comment|// Unhash
specifier|final
name|int
name|hashPos
init|=
name|fp
operator|.
name|fieldInfo
operator|.
name|name
operator|.
name|hashCode
argument_list|()
operator|&
name|fieldDataHashMask
decl_stmt|;
name|FieldData
name|last
init|=
literal|null
decl_stmt|;
name|FieldData
name|fp0
init|=
name|fieldDataHash
index|[
name|hashPos
index|]
decl_stmt|;
while|while
condition|(
name|fp0
operator|!=
name|fp
condition|)
block|{
name|last
operator|=
name|fp0
expr_stmt|;
name|fp0
operator|=
name|fp0
operator|.
name|next
expr_stmt|;
block|}
assert|assert
name|fp0
operator|!=
literal|null
assert|;
if|if
condition|(
name|last
operator|==
literal|null
condition|)
name|fieldDataHash
index|[
name|hashPos
index|]
operator|=
name|fp
operator|.
name|next
expr_stmt|;
else|else
name|last
operator|.
name|next
operator|=
name|fp
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"  remove field="
operator|+
name|fp
operator|.
name|fieldInfo
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Reset
name|fp
operator|.
name|lastDocID
operator|=
operator|-
literal|1
expr_stmt|;
name|allFieldDataArray
index|[
name|upto
operator|++
index|]
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|fp
operator|.
name|numPostings
operator|>
literal|0
operator|&&
operator|(
operator|(
name|float
operator|)
name|fp
operator|.
name|numPostings
operator|)
operator|/
name|fp
operator|.
name|postingsHashSize
operator|<
literal|0.2
condition|)
block|{
name|int
name|hashSize
init|=
name|fp
operator|.
name|postingsHashSize
decl_stmt|;
comment|// Reduce hash so it's between 25-50% full
while|while
condition|(
name|fp
operator|.
name|numPostings
operator|<
operator|(
name|hashSize
operator|>>
literal|1
operator|)
operator|&&
name|hashSize
operator|>=
literal|2
condition|)
name|hashSize
operator|>>=
literal|1
expr_stmt|;
name|hashSize
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|hashSize
operator|!=
name|fp
operator|.
name|postingsHash
operator|.
name|length
condition|)
name|fp
operator|.
name|rehashPostings
argument_list|(
name|hashSize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// If we didn't see any norms for this field since
comment|// last flush, free it
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|norms
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|BufferedNorms
name|n
init|=
name|norms
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|null
operator|&&
name|n
operator|.
name|upto
operator|==
literal|0
condition|)
name|norms
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
name|numAllFieldData
operator|=
name|upto
expr_stmt|;
comment|// Also pare back PostingsVectors if it's excessively
comment|// large
if|if
condition|(
name|maxPostingsVectors
operator|*
literal|1.5
operator|<
name|postingsVectors
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|newSize
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|maxPostingsVectors
condition|)
name|newSize
operator|=
literal|1
expr_stmt|;
else|else
name|newSize
operator|=
call|(
name|int
call|)
argument_list|(
literal|1.5
operator|*
name|maxPostingsVectors
argument_list|)
expr_stmt|;
name|PostingVector
index|[]
name|newArray
init|=
operator|new
name|PostingVector
index|[
name|newSize
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|postingsVectors
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|newSize
argument_list|)
expr_stmt|;
name|postingsVectors
operator|=
name|newArray
expr_stmt|;
block|}
block|}
comment|/** Tokenizes the fields of a document into Postings */
DECL|method|processDocument
name|void
name|processDocument
parameter_list|(
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|numFields
init|=
name|numFieldData
decl_stmt|;
name|fdtLocal
operator|.
name|writeVInt
argument_list|(
name|numStoredFields
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvx
operator|!=
literal|null
condition|)
comment|// If we are writing vectors then we must visit
comment|// fields in sorted order so they are written in
comment|// sorted order.  TODO: we actually only need to
comment|// sort the subset of fields that have vectors
comment|// enabled; we could save [small amount of] CPU
comment|// here.
name|Arrays
operator|.
name|sort
argument_list|(
name|fieldDataArray
argument_list|,
literal|0
argument_list|,
name|numFields
argument_list|)
expr_stmt|;
comment|// We process the document one field at a time
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
name|i
operator|++
control|)
name|fieldDataArray
index|[
name|i
index|]
operator|.
name|processField
argument_list|(
name|analyzer
argument_list|)
expr_stmt|;
if|if
condition|(
name|numBytesUsed
operator|>
literal|0.95
operator|*
name|ramBufferSize
condition|)
name|balanceRAM
argument_list|()
expr_stmt|;
block|}
DECL|field|postingsPool
specifier|final
name|ByteBlockPool
name|postingsPool
init|=
operator|new
name|ByteBlockPool
argument_list|()
decl_stmt|;
DECL|field|vectorsPool
specifier|final
name|ByteBlockPool
name|vectorsPool
init|=
operator|new
name|ByteBlockPool
argument_list|()
decl_stmt|;
DECL|field|charPool
specifier|final
name|CharBlockPool
name|charPool
init|=
operator|new
name|CharBlockPool
argument_list|()
decl_stmt|;
comment|// Current posting we are working on
DECL|field|p
name|Posting
name|p
decl_stmt|;
DECL|field|vector
name|PostingVector
name|vector
decl_stmt|;
comment|// USE ONLY FOR DEBUGGING!
comment|/*       public String getPostingText() {       char[] text = charPool.buffers[p.textStart>> CHAR_BLOCK_SHIFT];       int upto = p.textStart& CHAR_BLOCK_MASK;       while(text[upto] != 0xffff)       upto++;       return new String(text, p.textStart, upto-(p.textStart& BYTE_BLOCK_MASK));       }     */
comment|/** Test whether the text for current Posting p equals      *  current tokenText. */
DECL|method|postingEquals
name|boolean
name|postingEquals
parameter_list|(
specifier|final
name|char
index|[]
name|tokenText
parameter_list|,
specifier|final
name|int
name|tokenTextLen
parameter_list|)
block|{
specifier|final
name|char
index|[]
name|text
init|=
name|charPool
operator|.
name|buffers
index|[
name|p
operator|.
name|textStart
operator|>>
name|CHAR_BLOCK_SHIFT
index|]
decl_stmt|;
assert|assert
name|text
operator|!=
literal|null
assert|;
name|int
name|pos
init|=
name|p
operator|.
name|textStart
operator|&
name|CHAR_BLOCK_MASK
decl_stmt|;
name|int
name|tokenPos
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|tokenPos
operator|<
name|tokenTextLen
condition|;
name|pos
operator|++
operator|,
name|tokenPos
operator|++
control|)
if|if
condition|(
name|tokenText
index|[
name|tokenPos
index|]
operator|!=
name|text
index|[
name|pos
index|]
condition|)
return|return
literal|false
return|;
return|return
literal|0xffff
operator|==
name|text
index|[
name|pos
index|]
return|;
block|}
comment|/** Compares term text for two Posting instance and      *  returns -1 if p1< p2; 1 if p1> p2; else 0.      */
DECL|method|comparePostings
name|int
name|comparePostings
parameter_list|(
name|Posting
name|p1
parameter_list|,
name|Posting
name|p2
parameter_list|)
block|{
specifier|final
name|char
index|[]
name|text1
init|=
name|charPool
operator|.
name|buffers
index|[
name|p1
operator|.
name|textStart
operator|>>
name|CHAR_BLOCK_SHIFT
index|]
decl_stmt|;
name|int
name|pos1
init|=
name|p1
operator|.
name|textStart
operator|&
name|CHAR_BLOCK_MASK
decl_stmt|;
specifier|final
name|char
index|[]
name|text2
init|=
name|charPool
operator|.
name|buffers
index|[
name|p2
operator|.
name|textStart
operator|>>
name|CHAR_BLOCK_SHIFT
index|]
decl_stmt|;
name|int
name|pos2
init|=
name|p2
operator|.
name|textStart
operator|&
name|CHAR_BLOCK_MASK
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|char
name|c1
init|=
name|text1
index|[
name|pos1
operator|++
index|]
decl_stmt|;
specifier|final
name|char
name|c2
init|=
name|text2
index|[
name|pos2
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|c1
operator|<
name|c2
condition|)
if|if
condition|(
literal|0xffff
operator|==
name|c2
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|c2
operator|<
name|c1
condition|)
if|if
condition|(
literal|0xffff
operator|==
name|c1
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
elseif|else
if|if
condition|(
literal|0xffff
operator|==
name|c1
condition|)
return|return
literal|0
return|;
block|}
block|}
comment|/** Write vInt into freq stream of current Posting */
DECL|method|writeFreqVInt
specifier|public
name|void
name|writeFreqVInt
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|&
operator|~
literal|0x7F
operator|)
operator|!=
literal|0
condition|)
block|{
name|writeFreqByte
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|i
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|>>>=
literal|7
expr_stmt|;
block|}
name|writeFreqByte
argument_list|(
operator|(
name|byte
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
comment|/** Write vInt into prox stream of current Posting */
DECL|method|writeProxVInt
specifier|public
name|void
name|writeProxVInt
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|&
operator|~
literal|0x7F
operator|)
operator|!=
literal|0
condition|)
block|{
name|writeProxByte
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|i
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|>>>=
literal|7
expr_stmt|;
block|}
name|writeProxByte
argument_list|(
operator|(
name|byte
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
comment|/** Write byte into freq stream of current Posting */
DECL|field|freq
name|byte
index|[]
name|freq
decl_stmt|;
DECL|field|freqUpto
name|int
name|freqUpto
decl_stmt|;
DECL|method|writeFreqByte
specifier|public
name|void
name|writeFreqByte
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
assert|assert
name|freq
operator|!=
literal|null
assert|;
if|if
condition|(
name|freq
index|[
name|freqUpto
index|]
operator|!=
literal|0
condition|)
block|{
name|freqUpto
operator|=
name|postingsPool
operator|.
name|allocSlice
argument_list|(
name|freq
argument_list|,
name|freqUpto
argument_list|)
expr_stmt|;
name|freq
operator|=
name|postingsPool
operator|.
name|buffer
expr_stmt|;
name|p
operator|.
name|freqUpto
operator|=
name|postingsPool
operator|.
name|byteOffset
expr_stmt|;
block|}
name|freq
index|[
name|freqUpto
operator|++
index|]
operator|=
name|b
expr_stmt|;
block|}
comment|/** Write byte into prox stream of current Posting */
DECL|field|prox
name|byte
index|[]
name|prox
decl_stmt|;
DECL|field|proxUpto
name|int
name|proxUpto
decl_stmt|;
DECL|method|writeProxByte
specifier|public
name|void
name|writeProxByte
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
assert|assert
name|prox
operator|!=
literal|null
assert|;
if|if
condition|(
name|prox
index|[
name|proxUpto
index|]
operator|!=
literal|0
condition|)
block|{
name|proxUpto
operator|=
name|postingsPool
operator|.
name|allocSlice
argument_list|(
name|prox
argument_list|,
name|proxUpto
argument_list|)
expr_stmt|;
name|prox
operator|=
name|postingsPool
operator|.
name|buffer
expr_stmt|;
name|p
operator|.
name|proxUpto
operator|=
name|postingsPool
operator|.
name|byteOffset
expr_stmt|;
assert|assert
name|prox
operator|!=
literal|null
assert|;
block|}
name|prox
index|[
name|proxUpto
operator|++
index|]
operator|=
name|b
expr_stmt|;
assert|assert
name|proxUpto
operator|!=
name|prox
operator|.
name|length
assert|;
block|}
comment|/** Currently only used to copy a payload into the prox      *  stream. */
DECL|method|writeProxBytes
specifier|public
name|void
name|writeProxBytes
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|final
name|int
name|offsetEnd
init|=
name|offset
operator|+
name|len
decl_stmt|;
while|while
condition|(
name|offset
operator|<
name|offsetEnd
condition|)
block|{
if|if
condition|(
name|prox
index|[
name|proxUpto
index|]
operator|!=
literal|0
condition|)
block|{
comment|// End marker
name|proxUpto
operator|=
name|postingsPool
operator|.
name|allocSlice
argument_list|(
name|prox
argument_list|,
name|proxUpto
argument_list|)
expr_stmt|;
name|prox
operator|=
name|postingsPool
operator|.
name|buffer
expr_stmt|;
name|p
operator|.
name|proxUpto
operator|=
name|postingsPool
operator|.
name|byteOffset
expr_stmt|;
block|}
name|prox
index|[
name|proxUpto
operator|++
index|]
operator|=
name|b
index|[
name|offset
operator|++
index|]
expr_stmt|;
assert|assert
name|proxUpto
operator|!=
name|prox
operator|.
name|length
assert|;
block|}
block|}
comment|/** Write vInt into offsets stream of current      *  PostingVector */
DECL|method|writeOffsetVInt
specifier|public
name|void
name|writeOffsetVInt
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|&
operator|~
literal|0x7F
operator|)
operator|!=
literal|0
condition|)
block|{
name|writeOffsetByte
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|i
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|>>>=
literal|7
expr_stmt|;
block|}
name|writeOffsetByte
argument_list|(
operator|(
name|byte
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
DECL|field|offsets
name|byte
index|[]
name|offsets
decl_stmt|;
DECL|field|offsetUpto
name|int
name|offsetUpto
decl_stmt|;
comment|/** Write byte into offsets stream of current      *  PostingVector */
DECL|method|writeOffsetByte
specifier|public
name|void
name|writeOffsetByte
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
assert|assert
name|offsets
operator|!=
literal|null
assert|;
if|if
condition|(
name|offsets
index|[
name|offsetUpto
index|]
operator|!=
literal|0
condition|)
block|{
name|offsetUpto
operator|=
name|vectorsPool
operator|.
name|allocSlice
argument_list|(
name|offsets
argument_list|,
name|offsetUpto
argument_list|)
expr_stmt|;
name|offsets
operator|=
name|vectorsPool
operator|.
name|buffer
expr_stmt|;
name|vector
operator|.
name|offsetUpto
operator|=
name|vectorsPool
operator|.
name|byteOffset
expr_stmt|;
block|}
name|offsets
index|[
name|offsetUpto
operator|++
index|]
operator|=
name|b
expr_stmt|;
block|}
comment|/** Write vInt into pos stream of current      *  PostingVector */
DECL|method|writePosVInt
specifier|public
name|void
name|writePosVInt
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|&
operator|~
literal|0x7F
operator|)
operator|!=
literal|0
condition|)
block|{
name|writePosByte
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|i
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|>>>=
literal|7
expr_stmt|;
block|}
name|writePosByte
argument_list|(
operator|(
name|byte
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
DECL|field|pos
name|byte
index|[]
name|pos
decl_stmt|;
DECL|field|posUpto
name|int
name|posUpto
decl_stmt|;
comment|/** Write byte into pos stream of current      *  PostingVector */
DECL|method|writePosByte
specifier|public
name|void
name|writePosByte
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
assert|assert
name|pos
operator|!=
literal|null
assert|;
if|if
condition|(
name|pos
index|[
name|posUpto
index|]
operator|!=
literal|0
condition|)
block|{
name|posUpto
operator|=
name|vectorsPool
operator|.
name|allocSlice
argument_list|(
name|pos
argument_list|,
name|posUpto
argument_list|)
expr_stmt|;
name|pos
operator|=
name|vectorsPool
operator|.
name|buffer
expr_stmt|;
name|vector
operator|.
name|posUpto
operator|=
name|vectorsPool
operator|.
name|byteOffset
expr_stmt|;
block|}
name|pos
index|[
name|posUpto
operator|++
index|]
operator|=
name|b
expr_stmt|;
block|}
DECL|field|postingsVectors
name|PostingVector
index|[]
name|postingsVectors
init|=
operator|new
name|PostingVector
index|[
literal|1
index|]
decl_stmt|;
DECL|field|maxPostingsVectors
name|int
name|maxPostingsVectors
decl_stmt|;
comment|// Used to read a string value for a field
DECL|field|stringReader
name|ReusableStringReader
name|stringReader
init|=
operator|new
name|ReusableStringReader
argument_list|()
decl_stmt|;
comment|/** Holds data associated with a single field, including      *  the Postings hash.  A document may have many *      *  occurrences for a given field name; we gather all *      *  such occurrences here (in docFields) so that we can      *  * process the entire field at once. */
DECL|class|FieldData
specifier|private
specifier|final
class|class
name|FieldData
implements|implements
name|Comparable
block|{
DECL|field|threadState
name|ThreadState
name|threadState
decl_stmt|;
DECL|field|fieldInfo
name|FieldInfo
name|fieldInfo
decl_stmt|;
DECL|field|fieldCount
name|int
name|fieldCount
decl_stmt|;
DECL|field|docFields
name|Fieldable
index|[]
name|docFields
init|=
operator|new
name|Fieldable
index|[
literal|1
index|]
decl_stmt|;
DECL|field|lastDocID
name|int
name|lastDocID
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|next
name|FieldData
name|next
decl_stmt|;
DECL|field|doNorms
name|boolean
name|doNorms
decl_stmt|;
DECL|field|doVectors
name|boolean
name|doVectors
decl_stmt|;
DECL|field|doVectorPositions
name|boolean
name|doVectorPositions
decl_stmt|;
DECL|field|doVectorOffsets
name|boolean
name|doVectorOffsets
decl_stmt|;
DECL|field|numPostings
name|int
name|numPostings
decl_stmt|;
DECL|field|postingsHash
name|Posting
index|[]
name|postingsHash
decl_stmt|;
DECL|field|postingsHashSize
name|int
name|postingsHashSize
decl_stmt|;
DECL|field|postingsHashHalfSize
name|int
name|postingsHashHalfSize
decl_stmt|;
DECL|field|postingsHashMask
name|int
name|postingsHashMask
decl_stmt|;
DECL|field|position
name|int
name|position
decl_stmt|;
DECL|field|length
name|int
name|length
decl_stmt|;
DECL|field|offset
name|int
name|offset
decl_stmt|;
DECL|field|boost
name|float
name|boost
decl_stmt|;
DECL|field|postingsVectorsUpto
name|int
name|postingsVectorsUpto
decl_stmt|;
DECL|method|FieldData
specifier|public
name|FieldData
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
name|this
operator|.
name|fieldInfo
operator|=
name|fieldInfo
expr_stmt|;
name|threadState
operator|=
name|ThreadState
operator|.
name|this
expr_stmt|;
block|}
DECL|method|resetPostingArrays
name|void
name|resetPostingArrays
parameter_list|()
block|{
name|recyclePostings
argument_list|(
name|this
operator|.
name|postingsHash
argument_list|,
name|numPostings
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|postingsHash
argument_list|,
literal|0
argument_list|,
name|postingsHash
operator|.
name|length
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|numPostings
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|initPostingArrays
name|void
name|initPostingArrays
parameter_list|()
block|{
comment|// Target hash fill factor of<= 50%
comment|// NOTE: must be a power of two for hash collision
comment|// strategy to work correctly
name|postingsHashSize
operator|=
literal|4
expr_stmt|;
name|postingsHashHalfSize
operator|=
literal|2
expr_stmt|;
name|postingsHashMask
operator|=
name|postingsHashSize
operator|-
literal|1
expr_stmt|;
name|postingsHash
operator|=
operator|new
name|Posting
index|[
name|postingsHashSize
index|]
expr_stmt|;
block|}
comment|/** So Arrays.sort can sort us. */
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|fieldInfo
operator|.
name|name
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|FieldData
operator|)
name|o
operator|)
operator|.
name|fieldInfo
operator|.
name|name
argument_list|)
return|;
block|}
comment|/** Collapse the hash table& sort in-place. */
DECL|method|sortPostings
specifier|public
name|Posting
index|[]
name|sortPostings
parameter_list|()
block|{
name|int
name|upto
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|postingsHashSize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|postingsHash
index|[
name|i
index|]
operator|!=
literal|null
condition|)
name|postingsHash
index|[
name|upto
operator|++
index|]
operator|=
name|postingsHash
index|[
name|i
index|]
expr_stmt|;
assert|assert
name|upto
operator|==
name|numPostings
assert|;
name|doPostingSort
argument_list|(
name|postingsHash
argument_list|,
name|upto
argument_list|)
expr_stmt|;
return|return
name|postingsHash
return|;
block|}
comment|/** Process all occurrences of one field in the document. */
DECL|method|processField
specifier|public
name|void
name|processField
parameter_list|(
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|IOException
block|{
name|length
operator|=
literal|0
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|boost
operator|=
name|docBoost
expr_stmt|;
specifier|final
name|int
name|startNumPostings
init|=
name|numPostings
decl_stmt|;
specifier|final
name|int
name|maxFieldLength
init|=
name|writer
operator|.
name|getMaxFieldLength
argument_list|()
decl_stmt|;
specifier|final
name|int
name|limit
init|=
name|fieldCount
decl_stmt|;
specifier|final
name|Fieldable
index|[]
name|docFieldsFinal
init|=
name|docFields
decl_stmt|;
comment|// Walk through all occurrences in this doc for this field:
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|limit
condition|;
name|j
operator|++
control|)
block|{
name|Fieldable
name|field
init|=
name|docFieldsFinal
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|isIndexed
argument_list|()
condition|)
name|invertField
argument_list|(
name|field
argument_list|,
name|analyzer
argument_list|,
name|maxFieldLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|.
name|isStored
argument_list|()
condition|)
name|localFieldsWriter
operator|.
name|writeField
argument_list|(
name|fieldInfo
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|docFieldsFinal
index|[
name|j
index|]
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|postingsVectorsUpto
operator|>
literal|0
condition|)
block|{
comment|// Add term vectors for this field
name|writeVectors
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|postingsVectorsUpto
operator|>
name|maxPostingsVectors
condition|)
name|maxPostingsVectors
operator|=
name|postingsVectorsUpto
expr_stmt|;
name|postingsVectorsUpto
operator|=
literal|0
expr_stmt|;
name|vectorsPool
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|offsetEnd
name|int
name|offsetEnd
decl_stmt|;
DECL|field|localToken
name|Token
name|localToken
init|=
operator|new
name|Token
argument_list|()
decl_stmt|;
comment|/* Invert one occurrence of one field in the document */
DECL|method|invertField
specifier|public
name|void
name|invertField
parameter_list|(
name|Fieldable
name|field
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|,
specifier|final
name|int
name|maxFieldLength
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|length
operator|>
literal|0
condition|)
name|position
operator|+=
name|analyzer
operator|.
name|getPositionIncrementGap
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|field
operator|.
name|isTokenized
argument_list|()
condition|)
block|{
comment|// un-tokenized field
name|String
name|stringValue
init|=
name|field
operator|.
name|stringValue
argument_list|()
decl_stmt|;
name|Token
name|token
init|=
name|localToken
decl_stmt|;
name|token
operator|.
name|setTermText
argument_list|(
name|stringValue
argument_list|)
expr_stmt|;
name|token
operator|.
name|setStartOffset
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|token
operator|.
name|setEndOffset
argument_list|(
name|offset
operator|+
name|stringValue
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|addPosition
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|stringValue
operator|.
name|length
argument_list|()
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// tokenized field
specifier|final
name|TokenStream
name|stream
decl_stmt|;
specifier|final
name|TokenStream
name|streamValue
init|=
name|field
operator|.
name|tokenStreamValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|streamValue
operator|!=
literal|null
condition|)
name|stream
operator|=
name|streamValue
expr_stmt|;
else|else
block|{
comment|// the field does not have a TokenStream,
comment|// so we have to obtain one from the analyzer
specifier|final
name|Reader
name|reader
decl_stmt|;
comment|// find or make Reader
specifier|final
name|Reader
name|readerValue
init|=
name|field
operator|.
name|readerValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|readerValue
operator|!=
literal|null
condition|)
name|reader
operator|=
name|readerValue
expr_stmt|;
else|else
block|{
name|String
name|stringValue
init|=
name|field
operator|.
name|stringValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|stringValue
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field must have either TokenStream, String or Reader value"
argument_list|)
throw|;
name|stringReader
operator|.
name|init
argument_list|(
name|stringValue
argument_list|)
expr_stmt|;
name|reader
operator|=
name|stringReader
expr_stmt|;
block|}
comment|// Tokenize field and add to postingTable
name|stream
operator|=
name|analyzer
operator|.
name|reusableTokenStream
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
comment|// reset the TokenStream to the first token
name|stream
operator|.
name|reset
argument_list|()
expr_stmt|;
try|try
block|{
name|offsetEnd
operator|=
name|offset
operator|-
literal|1
expr_stmt|;
name|Token
name|token
decl_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|stream
operator|.
name|next
argument_list|(
name|localToken
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|position
operator|+=
operator|(
name|token
operator|.
name|getPositionIncrement
argument_list|()
operator|-
literal|1
operator|)
expr_stmt|;
name|addPosition
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|length
operator|>=
name|maxFieldLength
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"maxFieldLength "
operator|+
name|maxFieldLength
operator|+
literal|" reached for field "
operator|+
name|fieldInfo
operator|.
name|name
operator|+
literal|", ignoring following tokens"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|offset
operator|=
name|offsetEnd
operator|+
literal|1
expr_stmt|;
block|}
finally|finally
block|{
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|boost
operator|*=
name|field
operator|.
name|getBoost
argument_list|()
expr_stmt|;
block|}
comment|/** Only called when term vectors are enabled.  This        *  is called the first time we see a given term for        *  each * document, to allocate a PostingVector        *  instance that * is used to record data needed to        *  write the posting * vectors. */
DECL|method|addNewVector
specifier|private
name|PostingVector
name|addNewVector
parameter_list|()
block|{
if|if
condition|(
name|postingsVectorsUpto
operator|==
name|postingsVectors
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|newSize
decl_stmt|;
if|if
condition|(
name|postingsVectors
operator|.
name|length
operator|<
literal|2
condition|)
name|newSize
operator|=
literal|2
expr_stmt|;
else|else
name|newSize
operator|=
call|(
name|int
call|)
argument_list|(
literal|1.5
operator|*
name|postingsVectors
operator|.
name|length
argument_list|)
expr_stmt|;
name|PostingVector
index|[]
name|newArray
init|=
operator|new
name|PostingVector
index|[
name|newSize
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|postingsVectors
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|postingsVectors
operator|.
name|length
argument_list|)
expr_stmt|;
name|postingsVectors
operator|=
name|newArray
expr_stmt|;
block|}
name|p
operator|.
name|vector
operator|=
name|postingsVectors
index|[
name|postingsVectorsUpto
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|vector
operator|==
literal|null
condition|)
name|p
operator|.
name|vector
operator|=
name|postingsVectors
index|[
name|postingsVectorsUpto
index|]
operator|=
operator|new
name|PostingVector
argument_list|()
expr_stmt|;
name|postingsVectorsUpto
operator|++
expr_stmt|;
specifier|final
name|PostingVector
name|v
init|=
name|p
operator|.
name|vector
decl_stmt|;
name|v
operator|.
name|p
operator|=
name|p
expr_stmt|;
specifier|final
name|int
name|firstSize
init|=
name|levelSizeArray
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|doVectorPositions
condition|)
block|{
specifier|final
name|int
name|upto
init|=
name|vectorsPool
operator|.
name|newSlice
argument_list|(
name|firstSize
argument_list|)
decl_stmt|;
name|v
operator|.
name|posStart
operator|=
name|v
operator|.
name|posUpto
operator|=
name|vectorsPool
operator|.
name|byteOffset
operator|+
name|upto
expr_stmt|;
block|}
if|if
condition|(
name|doVectorOffsets
condition|)
block|{
specifier|final
name|int
name|upto
init|=
name|vectorsPool
operator|.
name|newSlice
argument_list|(
name|firstSize
argument_list|)
decl_stmt|;
name|v
operator|.
name|offsetStart
operator|=
name|v
operator|.
name|offsetUpto
operator|=
name|vectorsPool
operator|.
name|byteOffset
operator|+
name|upto
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
DECL|field|offsetStartCode
name|int
name|offsetStartCode
decl_stmt|;
DECL|field|offsetStart
name|int
name|offsetStart
decl_stmt|;
comment|/** This is the hotspot of indexing: it's called once        *  for every term of every document.  Its job is to *        *  update the postings byte stream (Postings hash) *        *  based on the occurence of a single term. */
DECL|method|addPosition
specifier|private
name|void
name|addPosition
parameter_list|(
name|Token
name|token
parameter_list|)
block|{
specifier|final
name|Payload
name|payload
init|=
name|token
operator|.
name|getPayload
argument_list|()
decl_stmt|;
comment|// Get the text of this term.  Term can either
comment|// provide a String token or offset into a char[]
comment|// array
specifier|final
name|char
index|[]
name|tokenText
init|=
name|token
operator|.
name|termBuffer
argument_list|()
decl_stmt|;
specifier|final
name|int
name|tokenTextLen
init|=
name|token
operator|.
name|termLength
argument_list|()
decl_stmt|;
name|int
name|code
init|=
literal|0
decl_stmt|;
name|int
name|code2
init|=
literal|0
decl_stmt|;
comment|// Compute hashcode
name|int
name|downto
init|=
name|tokenTextLen
decl_stmt|;
while|while
condition|(
name|downto
operator|>
literal|0
condition|)
name|code
operator|=
operator|(
name|code
operator|*
literal|31
operator|)
operator|+
name|tokenText
index|[
operator|--
name|downto
index|]
expr_stmt|;
comment|// System.out.println("  addPosition: buffer=" + new String(tokenText, 0, tokenTextLen) + " pos=" + position + " offsetStart=" + (offset+token.startOffset()) + " offsetEnd=" + (offset + token.endOffset()) + " docID=" + docID + " doPos=" + doVectorPositions + " doOffset=" + doVectorOffsets);
name|int
name|hashPos
init|=
name|code
operator|&
name|postingsHashMask
decl_stmt|;
comment|// Locate Posting in hash
name|p
operator|=
name|postingsHash
index|[
name|hashPos
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
operator|&&
operator|!
name|postingEquals
argument_list|(
name|tokenText
argument_list|,
name|tokenTextLen
argument_list|)
condition|)
block|{
comment|// Conflict: keep searching different locations in
comment|// the hash table.
specifier|final
name|int
name|inc
init|=
name|code
operator|*
literal|1347
operator||
literal|1
decl_stmt|;
do|do
block|{
name|code
operator|+=
name|inc
expr_stmt|;
name|hashPos
operator|=
name|code
operator|&
name|postingsHashMask
expr_stmt|;
name|p
operator|=
name|postingsHash
index|[
name|hashPos
index|]
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
literal|null
operator|&&
operator|!
name|postingEquals
argument_list|(
name|tokenText
argument_list|,
name|tokenTextLen
argument_list|)
condition|)
do|;
block|}
specifier|final
name|int
name|proxCode
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
comment|// term seen since last flush
if|if
condition|(
name|docID
operator|!=
name|p
operator|.
name|lastDocID
condition|)
block|{
comment|// term not yet seen in this doc
comment|// System.out.println("    seen before (new docID=" + docID + ") freqUpto=" + p.freqUpto +" proxUpto=" + p.proxUpto);
assert|assert
name|p
operator|.
name|docFreq
operator|>
literal|0
assert|;
comment|// Now that we know doc freq for previous doc,
comment|// write it& lastDocCode
name|freqUpto
operator|=
name|p
operator|.
name|freqUpto
operator|&
name|BYTE_BLOCK_MASK
expr_stmt|;
name|freq
operator|=
name|postingsPool
operator|.
name|buffers
index|[
name|p
operator|.
name|freqUpto
operator|>>
name|BYTE_BLOCK_SHIFT
index|]
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|p
operator|.
name|docFreq
condition|)
name|writeFreqVInt
argument_list|(
name|p
operator|.
name|lastDocCode
operator||
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|writeFreqVInt
argument_list|(
name|p
operator|.
name|lastDocCode
argument_list|)
expr_stmt|;
name|writeFreqVInt
argument_list|(
name|p
operator|.
name|docFreq
argument_list|)
expr_stmt|;
block|}
name|p
operator|.
name|freqUpto
operator|=
name|freqUpto
operator|+
operator|(
name|p
operator|.
name|freqUpto
operator|&
name|BYTE_BLOCK_NOT_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|doVectors
condition|)
block|{
name|vector
operator|=
name|addNewVector
argument_list|()
expr_stmt|;
if|if
condition|(
name|doVectorOffsets
condition|)
block|{
name|offsetStartCode
operator|=
name|offsetStart
operator|=
name|offset
operator|+
name|token
operator|.
name|startOffset
argument_list|()
expr_stmt|;
name|offsetEnd
operator|=
name|offset
operator|+
name|token
operator|.
name|endOffset
argument_list|()
expr_stmt|;
block|}
block|}
name|proxCode
operator|=
name|position
expr_stmt|;
name|p
operator|.
name|docFreq
operator|=
literal|1
expr_stmt|;
comment|// Store code so we can write this after we're
comment|// done with this new doc
name|p
operator|.
name|lastDocCode
operator|=
operator|(
name|docID
operator|-
name|p
operator|.
name|lastDocID
operator|)
operator|<<
literal|1
expr_stmt|;
name|p
operator|.
name|lastDocID
operator|=
name|docID
expr_stmt|;
block|}
else|else
block|{
comment|// term already seen in this doc
comment|// System.out.println("    seen before (same docID=" + docID + ") proxUpto=" + p.proxUpto);
name|p
operator|.
name|docFreq
operator|++
expr_stmt|;
name|proxCode
operator|=
name|position
operator|-
name|p
operator|.
name|lastPosition
expr_stmt|;
if|if
condition|(
name|doVectors
condition|)
block|{
name|vector
operator|=
name|p
operator|.
name|vector
expr_stmt|;
if|if
condition|(
name|vector
operator|==
literal|null
condition|)
name|vector
operator|=
name|addNewVector
argument_list|()
expr_stmt|;
if|if
condition|(
name|doVectorOffsets
condition|)
block|{
name|offsetStart
operator|=
name|offset
operator|+
name|token
operator|.
name|startOffset
argument_list|()
expr_stmt|;
name|offsetEnd
operator|=
name|offset
operator|+
name|token
operator|.
name|endOffset
argument_list|()
expr_stmt|;
name|offsetStartCode
operator|=
name|offsetStart
operator|-
name|vector
operator|.
name|lastOffset
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// term not seen before
comment|// System.out.println("    never seen docID=" + docID);
comment|// Refill?
if|if
condition|(
literal|0
operator|==
name|postingsFreeCount
condition|)
block|{
name|postingsFreeCount
operator|=
name|postingsFreeList
operator|.
name|length
expr_stmt|;
name|getPostings
argument_list|(
name|postingsFreeList
argument_list|)
expr_stmt|;
block|}
comment|// Pull next free Posting from free list
name|p
operator|=
name|postingsFreeList
index|[
operator|--
name|postingsFreeCount
index|]
expr_stmt|;
specifier|final
name|int
name|textLen1
init|=
literal|1
operator|+
name|tokenTextLen
decl_stmt|;
if|if
condition|(
name|textLen1
operator|+
name|charPool
operator|.
name|byteUpto
operator|>
name|CHAR_BLOCK_SIZE
condition|)
name|charPool
operator|.
name|nextBuffer
argument_list|()
expr_stmt|;
specifier|final
name|char
index|[]
name|text
init|=
name|charPool
operator|.
name|buffer
decl_stmt|;
specifier|final
name|int
name|textUpto
init|=
name|charPool
operator|.
name|byteUpto
decl_stmt|;
name|p
operator|.
name|textStart
operator|=
name|textUpto
operator|+
name|charPool
operator|.
name|byteOffset
expr_stmt|;
name|charPool
operator|.
name|byteUpto
operator|+=
name|textLen1
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|tokenText
argument_list|,
literal|0
argument_list|,
name|text
argument_list|,
name|textUpto
argument_list|,
name|tokenTextLen
argument_list|)
expr_stmt|;
name|text
index|[
name|textUpto
operator|+
name|tokenTextLen
index|]
operator|=
literal|0xffff
expr_stmt|;
assert|assert
name|postingsHash
index|[
name|hashPos
index|]
operator|==
literal|null
assert|;
name|postingsHash
index|[
name|hashPos
index|]
operator|=
name|p
expr_stmt|;
name|numPostings
operator|++
expr_stmt|;
if|if
condition|(
name|numPostings
operator|==
name|postingsHashHalfSize
condition|)
name|rehashPostings
argument_list|(
literal|2
operator|*
name|postingsHashSize
argument_list|)
expr_stmt|;
comment|// Init first slice for freq& prox streams
specifier|final
name|int
name|firstSize
init|=
name|levelSizeArray
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|int
name|upto1
init|=
name|postingsPool
operator|.
name|newSlice
argument_list|(
name|firstSize
argument_list|)
decl_stmt|;
name|p
operator|.
name|freqStart
operator|=
name|p
operator|.
name|freqUpto
operator|=
name|postingsPool
operator|.
name|byteOffset
operator|+
name|upto1
expr_stmt|;
specifier|final
name|int
name|upto2
init|=
name|postingsPool
operator|.
name|newSlice
argument_list|(
name|firstSize
argument_list|)
decl_stmt|;
name|p
operator|.
name|proxStart
operator|=
name|p
operator|.
name|proxUpto
operator|=
name|postingsPool
operator|.
name|byteOffset
operator|+
name|upto2
expr_stmt|;
name|p
operator|.
name|lastDocCode
operator|=
name|docID
operator|<<
literal|1
expr_stmt|;
name|p
operator|.
name|lastDocID
operator|=
name|docID
expr_stmt|;
name|p
operator|.
name|docFreq
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|doVectors
condition|)
block|{
name|vector
operator|=
name|addNewVector
argument_list|()
expr_stmt|;
if|if
condition|(
name|doVectorOffsets
condition|)
block|{
name|offsetStart
operator|=
name|offsetStartCode
operator|=
name|offset
operator|+
name|token
operator|.
name|startOffset
argument_list|()
expr_stmt|;
name|offsetEnd
operator|=
name|offset
operator|+
name|token
operator|.
name|endOffset
argument_list|()
expr_stmt|;
block|}
block|}
name|proxCode
operator|=
name|position
expr_stmt|;
block|}
name|proxUpto
operator|=
name|p
operator|.
name|proxUpto
operator|&
name|BYTE_BLOCK_MASK
expr_stmt|;
name|prox
operator|=
name|postingsPool
operator|.
name|buffers
index|[
name|p
operator|.
name|proxUpto
operator|>>
name|BYTE_BLOCK_SHIFT
index|]
expr_stmt|;
assert|assert
name|prox
operator|!=
literal|null
assert|;
if|if
condition|(
name|payload
operator|!=
literal|null
operator|&&
name|payload
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|writeProxVInt
argument_list|(
operator|(
name|proxCode
operator|<<
literal|1
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|writeProxVInt
argument_list|(
name|payload
operator|.
name|length
argument_list|)
expr_stmt|;
name|writeProxBytes
argument_list|(
name|payload
operator|.
name|data
argument_list|,
name|payload
operator|.
name|offset
argument_list|,
name|payload
operator|.
name|length
argument_list|)
expr_stmt|;
name|fieldInfo
operator|.
name|storePayloads
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|writeProxVInt
argument_list|(
name|proxCode
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|p
operator|.
name|proxUpto
operator|=
name|proxUpto
operator|+
operator|(
name|p
operator|.
name|proxUpto
operator|&
name|BYTE_BLOCK_NOT_MASK
operator|)
expr_stmt|;
name|p
operator|.
name|lastPosition
operator|=
name|position
operator|++
expr_stmt|;
if|if
condition|(
name|doVectorPositions
condition|)
block|{
name|posUpto
operator|=
name|vector
operator|.
name|posUpto
operator|&
name|BYTE_BLOCK_MASK
expr_stmt|;
name|pos
operator|=
name|vectorsPool
operator|.
name|buffers
index|[
name|vector
operator|.
name|posUpto
operator|>>
name|BYTE_BLOCK_SHIFT
index|]
expr_stmt|;
name|writePosVInt
argument_list|(
name|proxCode
argument_list|)
expr_stmt|;
name|vector
operator|.
name|posUpto
operator|=
name|posUpto
operator|+
operator|(
name|vector
operator|.
name|posUpto
operator|&
name|BYTE_BLOCK_NOT_MASK
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|doVectorOffsets
condition|)
block|{
name|offsetUpto
operator|=
name|vector
operator|.
name|offsetUpto
operator|&
name|BYTE_BLOCK_MASK
expr_stmt|;
name|offsets
operator|=
name|vectorsPool
operator|.
name|buffers
index|[
name|vector
operator|.
name|offsetUpto
operator|>>
name|BYTE_BLOCK_SHIFT
index|]
expr_stmt|;
name|writeOffsetVInt
argument_list|(
name|offsetStartCode
argument_list|)
expr_stmt|;
name|writeOffsetVInt
argument_list|(
name|offsetEnd
operator|-
name|offsetStart
argument_list|)
expr_stmt|;
name|vector
operator|.
name|lastOffset
operator|=
name|offsetEnd
expr_stmt|;
name|vector
operator|.
name|offsetUpto
operator|=
name|offsetUpto
operator|+
operator|(
name|vector
operator|.
name|offsetUpto
operator|&
name|BYTE_BLOCK_NOT_MASK
operator|)
expr_stmt|;
block|}
block|}
comment|/** Called when postings hash is too small (> 50%        *  occupied) or too large (< 20% occupied). */
DECL|method|rehashPostings
name|void
name|rehashPostings
parameter_list|(
specifier|final
name|int
name|newSize
parameter_list|)
block|{
name|postingsHashMask
operator|=
name|newSize
operator|-
literal|1
expr_stmt|;
name|Posting
index|[]
name|newHash
init|=
operator|new
name|Posting
index|[
name|newSize
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|postingsHashSize
condition|;
name|i
operator|++
control|)
block|{
name|Posting
name|p0
init|=
name|postingsHash
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|p0
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|start
init|=
name|p0
operator|.
name|textStart
operator|&
name|CHAR_BLOCK_MASK
decl_stmt|;
specifier|final
name|char
index|[]
name|text
init|=
name|charPool
operator|.
name|buffers
index|[
name|p0
operator|.
name|textStart
operator|>>
name|CHAR_BLOCK_SHIFT
index|]
decl_stmt|;
name|int
name|pos
init|=
name|start
decl_stmt|;
while|while
condition|(
name|text
index|[
name|pos
index|]
operator|!=
literal|0xffff
condition|)
name|pos
operator|++
expr_stmt|;
name|int
name|code
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pos
operator|>
name|start
condition|)
name|code
operator|=
operator|(
name|code
operator|*
literal|31
operator|)
operator|+
name|text
index|[
operator|--
name|pos
index|]
expr_stmt|;
name|int
name|hashPos
init|=
name|code
operator|&
name|postingsHashMask
decl_stmt|;
assert|assert
name|hashPos
operator|>=
literal|0
assert|;
if|if
condition|(
name|newHash
index|[
name|hashPos
index|]
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|inc
init|=
name|code
operator|*
literal|1347
operator||
literal|1
decl_stmt|;
do|do
block|{
name|code
operator|+=
name|inc
expr_stmt|;
name|hashPos
operator|=
name|code
operator|&
name|postingsHashMask
expr_stmt|;
block|}
do|while
condition|(
name|newHash
index|[
name|hashPos
index|]
operator|!=
literal|null
condition|)
do|;
block|}
name|newHash
index|[
name|hashPos
index|]
operator|=
name|p0
expr_stmt|;
block|}
block|}
name|postingsHash
operator|=
name|newHash
expr_stmt|;
name|postingsHashSize
operator|=
name|newSize
expr_stmt|;
name|postingsHashHalfSize
operator|=
name|newSize
operator|>>
literal|1
expr_stmt|;
block|}
DECL|field|vectorSliceReader
specifier|final
name|ByteSliceReader
name|vectorSliceReader
init|=
operator|new
name|ByteSliceReader
argument_list|()
decl_stmt|;
comment|/** Called once per field per document if term vectors        *  are enabled, to write the vectors to *        *  RAMOutputStream, which is then quickly flushed to        *  * the real term vectors files in the Directory. */
DECL|method|writeVectors
name|void
name|writeVectors
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|fieldInfo
operator|.
name|storeTermVector
assert|;
name|vectorFieldNumbers
index|[
name|numVectorFields
index|]
operator|=
name|fieldInfo
operator|.
name|number
expr_stmt|;
name|vectorFieldPointers
index|[
name|numVectorFields
index|]
operator|=
name|tvfLocal
operator|.
name|getFilePointer
argument_list|()
expr_stmt|;
name|numVectorFields
operator|++
expr_stmt|;
specifier|final
name|int
name|numPostingsVectors
init|=
name|postingsVectorsUpto
decl_stmt|;
name|tvfLocal
operator|.
name|writeVInt
argument_list|(
name|numPostingsVectors
argument_list|)
expr_stmt|;
name|byte
name|bits
init|=
literal|0x0
decl_stmt|;
if|if
condition|(
name|doVectorPositions
condition|)
name|bits
operator||=
name|TermVectorsWriter
operator|.
name|STORE_POSITIONS_WITH_TERMVECTOR
expr_stmt|;
if|if
condition|(
name|doVectorOffsets
condition|)
name|bits
operator||=
name|TermVectorsWriter
operator|.
name|STORE_OFFSET_WITH_TERMVECTOR
expr_stmt|;
name|tvfLocal
operator|.
name|writeByte
argument_list|(
name|bits
argument_list|)
expr_stmt|;
name|doVectorSort
argument_list|(
name|postingsVectors
argument_list|,
name|numPostingsVectors
argument_list|)
expr_stmt|;
name|Posting
name|lastPosting
init|=
literal|null
decl_stmt|;
specifier|final
name|ByteSliceReader
name|reader
init|=
name|vectorSliceReader
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numPostingsVectors
condition|;
name|j
operator|++
control|)
block|{
name|PostingVector
name|vector
init|=
name|postingsVectors
index|[
name|j
index|]
decl_stmt|;
name|Posting
name|posting
init|=
name|vector
operator|.
name|p
decl_stmt|;
specifier|final
name|int
name|freq
init|=
name|posting
operator|.
name|docFreq
decl_stmt|;
specifier|final
name|int
name|prefix
decl_stmt|;
specifier|final
name|char
index|[]
name|text2
init|=
name|charPool
operator|.
name|buffers
index|[
name|posting
operator|.
name|textStart
operator|>>
name|CHAR_BLOCK_SHIFT
index|]
decl_stmt|;
specifier|final
name|int
name|start2
init|=
name|posting
operator|.
name|textStart
operator|&
name|CHAR_BLOCK_MASK
decl_stmt|;
name|int
name|pos2
init|=
name|start2
decl_stmt|;
comment|// Compute common prefix between last term and
comment|// this term
if|if
condition|(
name|lastPosting
operator|==
literal|null
condition|)
name|prefix
operator|=
literal|0
expr_stmt|;
else|else
block|{
specifier|final
name|char
index|[]
name|text1
init|=
name|charPool
operator|.
name|buffers
index|[
name|lastPosting
operator|.
name|textStart
operator|>>
name|CHAR_BLOCK_SHIFT
index|]
decl_stmt|;
specifier|final
name|int
name|start1
init|=
name|lastPosting
operator|.
name|textStart
operator|&
name|CHAR_BLOCK_MASK
decl_stmt|;
name|int
name|pos1
init|=
name|start1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|char
name|c1
init|=
name|text1
index|[
name|pos1
index|]
decl_stmt|;
specifier|final
name|char
name|c2
init|=
name|text2
index|[
name|pos2
index|]
decl_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
operator|||
name|c1
operator|==
literal|0xffff
condition|)
block|{
name|prefix
operator|=
name|pos1
operator|-
name|start1
expr_stmt|;
break|break;
block|}
name|pos1
operator|++
expr_stmt|;
name|pos2
operator|++
expr_stmt|;
block|}
block|}
name|lastPosting
operator|=
name|posting
expr_stmt|;
comment|// Compute length
while|while
condition|(
name|text2
index|[
name|pos2
index|]
operator|!=
literal|0xffff
condition|)
name|pos2
operator|++
expr_stmt|;
specifier|final
name|int
name|suffix
init|=
name|pos2
operator|-
name|start2
operator|-
name|prefix
decl_stmt|;
name|tvfLocal
operator|.
name|writeVInt
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|tvfLocal
operator|.
name|writeVInt
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
name|tvfLocal
operator|.
name|writeChars
argument_list|(
name|text2
argument_list|,
name|start2
operator|+
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|tvfLocal
operator|.
name|writeVInt
argument_list|(
name|freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|doVectorPositions
condition|)
block|{
name|reader
operator|.
name|init
argument_list|(
name|vectorsPool
argument_list|,
name|vector
operator|.
name|posStart
argument_list|,
name|vector
operator|.
name|posUpto
argument_list|)
expr_stmt|;
name|reader
operator|.
name|writeTo
argument_list|(
name|tvfLocal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doVectorOffsets
condition|)
block|{
name|reader
operator|.
name|init
argument_list|(
name|vectorsPool
argument_list|,
name|vector
operator|.
name|offsetStart
argument_list|,
name|vector
operator|.
name|offsetUpto
argument_list|)
expr_stmt|;
name|reader
operator|.
name|writeTo
argument_list|(
name|tvfLocal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|field|defaultNorm
specifier|private
specifier|static
specifier|final
name|byte
name|defaultNorm
init|=
name|Similarity
operator|.
name|encodeNorm
argument_list|(
literal|1.0f
argument_list|)
decl_stmt|;
comment|/** Write norms in the "true" segment format.  This is    *  called only during commit, to create the .nrm file. */
DECL|method|writeNorms
name|void
name|writeNorms
parameter_list|(
name|String
name|segmentName
parameter_list|,
name|int
name|totalNumDoc
parameter_list|)
throws|throws
name|IOException
block|{
name|IndexOutput
name|normsOut
init|=
name|directory
operator|.
name|createOutput
argument_list|(
name|segmentName
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|NORMS_EXTENSION
argument_list|)
decl_stmt|;
try|try
block|{
name|normsOut
operator|.
name|writeBytes
argument_list|(
name|SegmentMerger
operator|.
name|NORMS_HEADER
argument_list|,
literal|0
argument_list|,
name|SegmentMerger
operator|.
name|NORMS_HEADER
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|int
name|numField
init|=
name|fieldInfos
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|fieldIdx
init|=
literal|0
init|;
name|fieldIdx
operator|<
name|numField
condition|;
name|fieldIdx
operator|++
control|)
block|{
name|FieldInfo
name|fi
init|=
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|fieldIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|isIndexed
operator|&&
operator|!
name|fi
operator|.
name|omitNorms
condition|)
block|{
name|BufferedNorms
name|n
init|=
name|norms
index|[
name|fieldIdx
index|]
decl_stmt|;
specifier|final
name|long
name|v
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|null
condition|)
name|v
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|v
operator|=
name|n
operator|.
name|out
operator|.
name|getFilePointer
argument_list|()
expr_stmt|;
name|n
operator|.
name|out
operator|.
name|writeTo
argument_list|(
name|normsOut
argument_list|)
expr_stmt|;
name|n
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|<
name|totalNumDoc
condition|)
name|fillBytes
argument_list|(
name|normsOut
argument_list|,
name|defaultNorm
argument_list|,
call|(
name|int
call|)
argument_list|(
name|totalNumDoc
operator|-
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|normsOut
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|skipListWriter
specifier|private
name|DefaultSkipListWriter
name|skipListWriter
init|=
literal|null
decl_stmt|;
DECL|field|currentFieldStorePayloads
specifier|private
name|boolean
name|currentFieldStorePayloads
decl_stmt|;
comment|/** Creates a segment from all Postings in the Postings    *  hashes across all ThreadStates& FieldDatas. */
DECL|method|writeSegment
specifier|private
name|List
name|writeSegment
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|allThreadsIdle
argument_list|()
assert|;
assert|assert
name|nextDocID
operator|==
name|numDocsInRAM
assert|;
specifier|final
name|String
name|segmentName
decl_stmt|;
name|segmentName
operator|=
name|segment
expr_stmt|;
name|TermInfosWriter
name|termsOut
init|=
operator|new
name|TermInfosWriter
argument_list|(
name|directory
argument_list|,
name|segmentName
argument_list|,
name|fieldInfos
argument_list|,
name|writer
operator|.
name|getTermIndexInterval
argument_list|()
argument_list|)
decl_stmt|;
name|IndexOutput
name|freqOut
init|=
name|directory
operator|.
name|createOutput
argument_list|(
name|segmentName
operator|+
literal|".frq"
argument_list|)
decl_stmt|;
name|IndexOutput
name|proxOut
init|=
name|directory
operator|.
name|createOutput
argument_list|(
name|segmentName
operator|+
literal|".prx"
argument_list|)
decl_stmt|;
comment|// Gather all FieldData's that have postings, across all
comment|// ThreadStates
name|ArrayList
name|allFields
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
assert|assert
name|allThreadsIdle
argument_list|()
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ThreadState
name|state
init|=
name|threadStates
index|[
name|i
index|]
decl_stmt|;
name|state
operator|.
name|trimFields
argument_list|()
expr_stmt|;
specifier|final
name|int
name|numFields
init|=
name|state
operator|.
name|numAllFieldData
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numFields
condition|;
name|j
operator|++
control|)
block|{
name|ThreadState
operator|.
name|FieldData
name|fp
init|=
name|state
operator|.
name|allFieldDataArray
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|fp
operator|.
name|numPostings
operator|>
literal|0
condition|)
name|allFields
operator|.
name|add
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Sort by field name
name|Collections
operator|.
name|sort
argument_list|(
name|allFields
argument_list|)
expr_stmt|;
specifier|final
name|int
name|numAllFields
init|=
name|allFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|skipListWriter
operator|=
operator|new
name|DefaultSkipListWriter
argument_list|(
name|termsOut
operator|.
name|skipInterval
argument_list|,
name|termsOut
operator|.
name|maxSkipLevels
argument_list|,
name|numDocsInRAM
argument_list|,
name|freqOut
argument_list|,
name|proxOut
argument_list|)
expr_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|numAllFields
condition|)
block|{
specifier|final
name|String
name|fieldName
init|=
operator|(
operator|(
name|ThreadState
operator|.
name|FieldData
operator|)
name|allFields
operator|.
name|get
argument_list|(
name|start
argument_list|)
operator|)
operator|.
name|fieldInfo
operator|.
name|name
decl_stmt|;
name|int
name|end
init|=
name|start
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|end
operator|<
name|numAllFields
operator|&&
operator|(
operator|(
name|ThreadState
operator|.
name|FieldData
operator|)
name|allFields
operator|.
name|get
argument_list|(
name|end
argument_list|)
operator|)
operator|.
name|fieldInfo
operator|.
name|name
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
name|end
operator|++
expr_stmt|;
name|ThreadState
operator|.
name|FieldData
index|[]
name|fields
init|=
operator|new
name|ThreadState
operator|.
name|FieldData
index|[
name|end
operator|-
name|start
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
name|fields
index|[
name|i
operator|-
name|start
index|]
operator|=
operator|(
name|ThreadState
operator|.
name|FieldData
operator|)
name|allFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// If this field has postings then add them to the
comment|// segment
name|appendPostings
argument_list|(
name|fields
argument_list|,
name|termsOut
argument_list|,
name|freqOut
argument_list|,
name|proxOut
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|fields
index|[
name|i
index|]
operator|.
name|resetPostingArrays
argument_list|()
expr_stmt|;
name|start
operator|=
name|end
expr_stmt|;
block|}
name|freqOut
operator|.
name|close
argument_list|()
expr_stmt|;
name|proxOut
operator|.
name|close
argument_list|()
expr_stmt|;
name|termsOut
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Record all files we have flushed
name|List
name|flushedFiles
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|flushedFiles
operator|.
name|add
argument_list|(
name|segmentFileName
argument_list|(
name|IndexFileNames
operator|.
name|FIELD_INFOS_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|flushedFiles
operator|.
name|add
argument_list|(
name|segmentFileName
argument_list|(
name|IndexFileNames
operator|.
name|FREQ_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|flushedFiles
operator|.
name|add
argument_list|(
name|segmentFileName
argument_list|(
name|IndexFileNames
operator|.
name|PROX_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|flushedFiles
operator|.
name|add
argument_list|(
name|segmentFileName
argument_list|(
name|IndexFileNames
operator|.
name|TERMS_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|flushedFiles
operator|.
name|add
argument_list|(
name|segmentFileName
argument_list|(
name|IndexFileNames
operator|.
name|TERMS_INDEX_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasNorms
condition|)
block|{
name|writeNorms
argument_list|(
name|segmentName
argument_list|,
name|numDocsInRAM
argument_list|)
expr_stmt|;
name|flushedFiles
operator|.
name|add
argument_list|(
name|segmentFileName
argument_list|(
name|IndexFileNames
operator|.
name|NORMS_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
specifier|final
name|long
name|newSegmentSize
init|=
name|segmentSize
argument_list|(
name|segmentName
argument_list|)
decl_stmt|;
name|String
name|message
init|=
literal|"  oldRAMSize="
operator|+
name|numBytesUsed
operator|+
literal|" newFlushedSize="
operator|+
name|newSegmentSize
operator|+
literal|" docs/MB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|numDocsInRAM
operator|/
operator|(
name|newSegmentSize
operator|/
literal|1024.
operator|/
literal|1024.
operator|)
argument_list|)
operator|+
literal|" new/old="
operator|+
name|nf
operator|.
name|format
argument_list|(
literal|100.0
operator|*
name|newSegmentSize
operator|/
name|numBytesUsed
argument_list|)
operator|+
literal|"%"
decl_stmt|;
name|infoStream
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|resetPostingsData
argument_list|()
expr_stmt|;
name|nextDocID
operator|=
literal|0
expr_stmt|;
name|nextWriteDocID
operator|=
literal|0
expr_stmt|;
name|numDocsInRAM
operator|=
literal|0
expr_stmt|;
name|files
operator|=
literal|null
expr_stmt|;
comment|// Maybe downsize postingsFreeList array
if|if
condition|(
name|postingsFreeList
operator|.
name|length
operator|>
literal|1.5
operator|*
name|postingsFreeCount
condition|)
block|{
name|int
name|newSize
init|=
name|postingsFreeList
operator|.
name|length
decl_stmt|;
while|while
condition|(
name|newSize
operator|>
literal|1.25
operator|*
name|postingsFreeCount
condition|)
block|{
name|newSize
operator|=
call|(
name|int
call|)
argument_list|(
name|newSize
operator|*
literal|0.8
argument_list|)
expr_stmt|;
block|}
name|Posting
index|[]
name|newArray
init|=
operator|new
name|Posting
index|[
name|newSize
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|postingsFreeList
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|postingsFreeCount
argument_list|)
expr_stmt|;
name|postingsFreeList
operator|=
name|newArray
expr_stmt|;
block|}
return|return
name|flushedFiles
return|;
block|}
comment|/** Returns the name of the file with this extension, on    *  the current segment we are working on. */
DECL|method|segmentFileName
specifier|private
name|String
name|segmentFileName
parameter_list|(
name|String
name|extension
parameter_list|)
block|{
return|return
name|segment
operator|+
literal|"."
operator|+
name|extension
return|;
block|}
DECL|field|termInfo
specifier|private
specifier|final
name|TermInfo
name|termInfo
init|=
operator|new
name|TermInfo
argument_list|()
decl_stmt|;
comment|// minimize consing
comment|/** Used to merge the postings from multiple ThreadStates    * when creating a segment */
DECL|class|FieldMergeState
specifier|final
specifier|static
class|class
name|FieldMergeState
block|{
DECL|field|field
specifier|private
name|ThreadState
operator|.
name|FieldData
name|field
decl_stmt|;
DECL|field|postings
specifier|private
name|Posting
index|[]
name|postings
decl_stmt|;
DECL|field|p
specifier|private
name|Posting
name|p
decl_stmt|;
DECL|field|text
specifier|private
name|char
index|[]
name|text
decl_stmt|;
DECL|field|textOffset
specifier|private
name|int
name|textOffset
decl_stmt|;
DECL|field|postingUpto
specifier|private
name|int
name|postingUpto
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|freq
specifier|private
name|ByteSliceReader
name|freq
init|=
operator|new
name|ByteSliceReader
argument_list|()
decl_stmt|;
DECL|field|prox
specifier|private
name|ByteSliceReader
name|prox
init|=
operator|new
name|ByteSliceReader
argument_list|()
decl_stmt|;
DECL|field|lastDocID
specifier|private
name|int
name|lastDocID
decl_stmt|;
DECL|field|docID
specifier|private
name|int
name|docID
decl_stmt|;
DECL|field|termFreq
specifier|private
name|int
name|termFreq
decl_stmt|;
DECL|method|nextTerm
name|boolean
name|nextTerm
parameter_list|()
throws|throws
name|IOException
block|{
name|postingUpto
operator|++
expr_stmt|;
if|if
condition|(
name|postingUpto
operator|==
name|field
operator|.
name|numPostings
condition|)
return|return
literal|false
return|;
name|p
operator|=
name|postings
index|[
name|postingUpto
index|]
expr_stmt|;
name|docID
operator|=
literal|0
expr_stmt|;
name|text
operator|=
name|field
operator|.
name|threadState
operator|.
name|charPool
operator|.
name|buffers
index|[
name|p
operator|.
name|textStart
operator|>>
name|CHAR_BLOCK_SHIFT
index|]
expr_stmt|;
name|textOffset
operator|=
name|p
operator|.
name|textStart
operator|&
name|CHAR_BLOCK_MASK
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|freqUpto
operator|>
name|p
operator|.
name|freqStart
condition|)
name|freq
operator|.
name|init
argument_list|(
name|field
operator|.
name|threadState
operator|.
name|postingsPool
argument_list|,
name|p
operator|.
name|freqStart
argument_list|,
name|p
operator|.
name|freqUpto
argument_list|)
expr_stmt|;
else|else
name|freq
operator|.
name|bufferOffset
operator|=
name|freq
operator|.
name|upto
operator|=
name|freq
operator|.
name|endIndex
operator|=
literal|0
expr_stmt|;
name|prox
operator|.
name|init
argument_list|(
name|field
operator|.
name|threadState
operator|.
name|postingsPool
argument_list|,
name|p
operator|.
name|proxStart
argument_list|,
name|p
operator|.
name|proxUpto
argument_list|)
expr_stmt|;
comment|// Should always be true
name|boolean
name|result
init|=
name|nextDoc
argument_list|()
decl_stmt|;
assert|assert
name|result
assert|;
return|return
literal|true
return|;
block|}
DECL|method|nextDoc
specifier|public
name|boolean
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|freq
operator|.
name|bufferOffset
operator|+
name|freq
operator|.
name|upto
operator|==
name|freq
operator|.
name|endIndex
condition|)
block|{
if|if
condition|(
name|p
operator|.
name|lastDocCode
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Return last doc
name|docID
operator|=
name|p
operator|.
name|lastDocID
expr_stmt|;
name|termFreq
operator|=
name|p
operator|.
name|docFreq
expr_stmt|;
name|p
operator|.
name|lastDocCode
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
comment|// EOF
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|code
init|=
name|freq
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|docID
operator|+=
name|code
operator|>>>
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|termFreq
operator|=
literal|1
expr_stmt|;
else|else
name|termFreq
operator|=
name|freq
operator|.
name|readVInt
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
DECL|method|compareText
name|int
name|compareText
parameter_list|(
specifier|final
name|char
index|[]
name|text1
parameter_list|,
name|int
name|pos1
parameter_list|,
specifier|final
name|char
index|[]
name|text2
parameter_list|,
name|int
name|pos2
parameter_list|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|char
name|c1
init|=
name|text1
index|[
name|pos1
operator|++
index|]
decl_stmt|;
specifier|final
name|char
name|c2
init|=
name|text2
index|[
name|pos2
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|c1
operator|<
name|c2
condition|)
if|if
condition|(
literal|0xffff
operator|==
name|c2
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|c2
operator|<
name|c1
condition|)
if|if
condition|(
literal|0xffff
operator|==
name|c1
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
elseif|else
if|if
condition|(
literal|0xffff
operator|==
name|c1
condition|)
return|return
literal|0
return|;
block|}
block|}
comment|/* Walk through all unique text tokens (Posting    * instances) found in this field and serialize them    * into a single RAM segment. */
DECL|method|appendPostings
name|void
name|appendPostings
parameter_list|(
name|ThreadState
operator|.
name|FieldData
index|[]
name|fields
parameter_list|,
name|TermInfosWriter
name|termsOut
parameter_list|,
name|IndexOutput
name|freqOut
parameter_list|,
name|IndexOutput
name|proxOut
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
specifier|final
name|String
name|fieldName
init|=
name|fields
index|[
literal|0
index|]
operator|.
name|fieldInfo
operator|.
name|name
decl_stmt|;
name|int
name|numFields
init|=
name|fields
operator|.
name|length
decl_stmt|;
specifier|final
name|FieldMergeState
index|[]
name|mergeStates
init|=
operator|new
name|FieldMergeState
index|[
name|numFields
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
name|i
operator|++
control|)
block|{
name|FieldMergeState
name|fms
init|=
name|mergeStates
index|[
name|i
index|]
operator|=
operator|new
name|FieldMergeState
argument_list|()
decl_stmt|;
name|fms
operator|.
name|field
operator|=
name|fields
index|[
name|i
index|]
expr_stmt|;
name|fms
operator|.
name|postings
operator|=
name|fms
operator|.
name|field
operator|.
name|sortPostings
argument_list|()
expr_stmt|;
assert|assert
name|fms
operator|.
name|field
operator|.
name|fieldInfo
operator|==
name|fields
index|[
literal|0
index|]
operator|.
name|fieldInfo
assert|;
comment|// Should always be true
name|boolean
name|result
init|=
name|fms
operator|.
name|nextTerm
argument_list|()
decl_stmt|;
assert|assert
name|result
assert|;
block|}
name|Posting
name|lastPosting
init|=
literal|null
decl_stmt|;
specifier|final
name|int
name|skipInterval
init|=
name|termsOut
operator|.
name|skipInterval
decl_stmt|;
name|currentFieldStorePayloads
operator|=
name|fields
index|[
literal|0
index|]
operator|.
name|fieldInfo
operator|.
name|storePayloads
expr_stmt|;
name|FieldMergeState
index|[]
name|termStates
init|=
operator|new
name|FieldMergeState
index|[
name|numFields
index|]
decl_stmt|;
while|while
condition|(
name|numFields
operator|>
literal|0
condition|)
block|{
comment|// Get the next term to merge
name|termStates
index|[
literal|0
index|]
operator|=
name|mergeStates
index|[
literal|0
index|]
expr_stmt|;
name|int
name|numToMerge
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numFields
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|char
index|[]
name|text
init|=
name|mergeStates
index|[
name|i
index|]
operator|.
name|text
decl_stmt|;
specifier|final
name|int
name|textOffset
init|=
name|mergeStates
index|[
name|i
index|]
operator|.
name|textOffset
decl_stmt|;
specifier|final
name|int
name|cmp
init|=
name|compareText
argument_list|(
name|text
argument_list|,
name|textOffset
argument_list|,
name|termStates
index|[
literal|0
index|]
operator|.
name|text
argument_list|,
name|termStates
index|[
literal|0
index|]
operator|.
name|textOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|termStates
index|[
literal|0
index|]
operator|=
name|mergeStates
index|[
name|i
index|]
expr_stmt|;
name|numToMerge
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
name|termStates
index|[
name|numToMerge
operator|++
index|]
operator|=
name|mergeStates
index|[
name|i
index|]
expr_stmt|;
block|}
name|int
name|df
init|=
literal|0
decl_stmt|;
name|int
name|lastPayloadLength
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|lastDoc
init|=
literal|0
decl_stmt|;
specifier|final
name|char
index|[]
name|text
init|=
name|termStates
index|[
literal|0
index|]
operator|.
name|text
decl_stmt|;
specifier|final
name|int
name|start
init|=
name|termStates
index|[
literal|0
index|]
operator|.
name|textOffset
decl_stmt|;
name|int
name|pos
init|=
name|start
decl_stmt|;
while|while
condition|(
name|text
index|[
name|pos
index|]
operator|!=
literal|0xffff
condition|)
name|pos
operator|++
expr_stmt|;
comment|// TODO: can we avoid 2 new objects here?
name|Term
name|term
init|=
operator|new
name|Term
argument_list|(
name|fieldName
argument_list|,
operator|new
name|String
argument_list|(
name|text
argument_list|,
name|start
argument_list|,
name|pos
operator|-
name|start
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|freqPointer
init|=
name|freqOut
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
name|long
name|proxPointer
init|=
name|proxOut
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
name|skipListWriter
operator|.
name|resetSkip
argument_list|()
expr_stmt|;
comment|// Now termStates has numToMerge FieldMergeStates
comment|// which all share the same term.  Now we must
comment|// interleave the docID streams.
while|while
condition|(
name|numToMerge
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|++
name|df
operator|%
name|skipInterval
operator|)
operator|==
literal|0
condition|)
block|{
name|skipListWriter
operator|.
name|setSkipData
argument_list|(
name|lastDoc
argument_list|,
name|currentFieldStorePayloads
argument_list|,
name|lastPayloadLength
argument_list|)
expr_stmt|;
name|skipListWriter
operator|.
name|bufferSkip
argument_list|(
name|df
argument_list|)
expr_stmt|;
block|}
name|FieldMergeState
name|minState
init|=
name|termStates
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numToMerge
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|termStates
index|[
name|i
index|]
operator|.
name|docID
operator|<
name|minState
operator|.
name|docID
condition|)
name|minState
operator|=
name|termStates
index|[
name|i
index|]
expr_stmt|;
specifier|final
name|int
name|doc
init|=
name|minState
operator|.
name|docID
decl_stmt|;
specifier|final
name|int
name|termDocFreq
init|=
name|minState
operator|.
name|termFreq
decl_stmt|;
assert|assert
name|doc
operator|<
name|numDocsInRAM
assert|;
assert|assert
name|doc
operator|>
name|lastDoc
operator|||
name|df
operator|==
literal|1
assert|;
specifier|final
name|int
name|newDocCode
init|=
operator|(
name|doc
operator|-
name|lastDoc
operator|)
operator|<<
literal|1
decl_stmt|;
name|lastDoc
operator|=
name|doc
expr_stmt|;
specifier|final
name|ByteSliceReader
name|prox
init|=
name|minState
operator|.
name|prox
decl_stmt|;
comment|// Carefully copy over the prox + payload info,
comment|// changing the format to match Lucene's segment
comment|// format.
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|termDocFreq
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|int
name|code
init|=
name|prox
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentFieldStorePayloads
condition|)
block|{
specifier|final
name|int
name|payloadLength
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// This position has a payload
name|payloadLength
operator|=
name|prox
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
name|payloadLength
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|payloadLength
operator|!=
name|lastPayloadLength
condition|)
block|{
name|proxOut
operator|.
name|writeVInt
argument_list|(
name|code
operator||
literal|1
argument_list|)
expr_stmt|;
name|proxOut
operator|.
name|writeVInt
argument_list|(
name|payloadLength
argument_list|)
expr_stmt|;
name|lastPayloadLength
operator|=
name|payloadLength
expr_stmt|;
block|}
else|else
name|proxOut
operator|.
name|writeVInt
argument_list|(
name|code
operator|&
operator|(
operator|~
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|payloadLength
operator|>
literal|0
condition|)
name|copyBytes
argument_list|(
name|prox
argument_list|,
name|proxOut
argument_list|,
name|payloadLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
literal|0
operator|==
operator|(
name|code
operator|&
literal|1
operator|)
assert|;
name|proxOut
operator|.
name|writeVInt
argument_list|(
name|code
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|1
operator|==
name|termDocFreq
condition|)
block|{
name|freqOut
operator|.
name|writeVInt
argument_list|(
name|newDocCode
operator||
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|freqOut
operator|.
name|writeVInt
argument_list|(
name|newDocCode
argument_list|)
expr_stmt|;
name|freqOut
operator|.
name|writeVInt
argument_list|(
name|termDocFreq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|minState
operator|.
name|nextDoc
argument_list|()
condition|)
block|{
comment|// Remove from termStates
name|int
name|upto
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numToMerge
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|termStates
index|[
name|i
index|]
operator|!=
name|minState
condition|)
name|termStates
index|[
name|upto
operator|++
index|]
operator|=
name|termStates
index|[
name|i
index|]
expr_stmt|;
name|numToMerge
operator|--
expr_stmt|;
assert|assert
name|upto
operator|==
name|numToMerge
assert|;
comment|// Advance this state to the next term
if|if
condition|(
operator|!
name|minState
operator|.
name|nextTerm
argument_list|()
condition|)
block|{
comment|// OK, no more terms, so remove from mergeStates
comment|// as well
name|upto
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mergeStates
index|[
name|i
index|]
operator|!=
name|minState
condition|)
name|mergeStates
index|[
name|upto
operator|++
index|]
operator|=
name|mergeStates
index|[
name|i
index|]
expr_stmt|;
name|numFields
operator|--
expr_stmt|;
assert|assert
name|upto
operator|==
name|numFields
assert|;
block|}
block|}
block|}
assert|assert
name|df
operator|>
literal|0
assert|;
comment|// Done merging this term
name|long
name|skipPointer
init|=
name|skipListWriter
operator|.
name|writeSkip
argument_list|(
name|freqOut
argument_list|)
decl_stmt|;
comment|// Write term
name|termInfo
operator|.
name|set
argument_list|(
name|df
argument_list|,
name|freqPointer
argument_list|,
name|proxPointer
argument_list|,
call|(
name|int
call|)
argument_list|(
name|skipPointer
operator|-
name|freqPointer
argument_list|)
argument_list|)
expr_stmt|;
name|termsOut
operator|.
name|add
argument_list|(
name|term
argument_list|,
name|termInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Returns a free (idle) ThreadState that may be used for    * indexing this one document.  This call also pauses if a    * flush is pending. */
DECL|method|getThreadState
specifier|synchronized
name|ThreadState
name|getThreadState
parameter_list|(
name|Document
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
comment|// First, find a thread state.  If this thread already
comment|// has affinity to a specific ThreadState, use that one
comment|// again.
name|ThreadState
name|state
init|=
operator|(
name|ThreadState
operator|)
name|threadBindings
operator|.
name|get
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
comment|// First time this thread has called us since last flush
name|ThreadState
name|minThreadState
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ThreadState
name|ts
init|=
name|threadStates
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|minThreadState
operator|==
literal|null
operator|||
name|ts
operator|.
name|numThreads
operator|<
name|minThreadState
operator|.
name|numThreads
condition|)
name|minThreadState
operator|=
name|ts
expr_stmt|;
block|}
if|if
condition|(
name|minThreadState
operator|!=
literal|null
operator|&&
operator|(
name|minThreadState
operator|.
name|numThreads
operator|==
literal|0
operator|||
name|threadStates
operator|.
name|length
operator|==
name|MAX_THREAD_STATE
operator|)
condition|)
block|{
name|state
operator|=
name|minThreadState
expr_stmt|;
name|state
operator|.
name|numThreads
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// Just create a new "private" thread state
name|ThreadState
index|[]
name|newArray
init|=
operator|new
name|ThreadState
index|[
literal|1
operator|+
name|threadStates
operator|.
name|length
index|]
decl_stmt|;
if|if
condition|(
name|threadStates
operator|.
name|length
operator|>
literal|0
condition|)
name|System
operator|.
name|arraycopy
argument_list|(
name|threadStates
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|threadStates
operator|.
name|length
argument_list|)
expr_stmt|;
name|state
operator|=
name|newArray
index|[
name|threadStates
operator|.
name|length
index|]
operator|=
operator|new
name|ThreadState
argument_list|()
expr_stmt|;
name|threadStates
operator|=
name|newArray
expr_stmt|;
block|}
name|threadBindings
operator|.
name|put
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
comment|// Next, wait until my thread state is idle (in case
comment|// it's shared with other threads) and for threads to
comment|// not be paused nor a flush pending:
while|while
condition|(
operator|!
name|state
operator|.
name|isIdle
operator|||
name|pauseThreads
operator|!=
literal|0
operator|||
name|flushPending
condition|)
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{}
if|if
condition|(
name|segment
operator|==
literal|null
condition|)
name|segment
operator|=
name|writer
operator|.
name|newSegmentName
argument_list|()
expr_stmt|;
name|numDocsInRAM
operator|++
expr_stmt|;
comment|// We must at this point commit to flushing to ensure we
comment|// always get N docs when we flush by doc count, even if
comment|//> 1 thread is adding documents:
comment|/* new merge policy     if (!flushPending&& maxBufferedDocs> 0&& numDocsInRAM>= maxBufferedDocs) {     */
if|if
condition|(
operator|!
name|flushPending
operator|&&
name|ramBufferSize
operator|==
literal|0
operator|&&
name|numDocsInRAM
operator|>=
name|maxBufferedDocs
condition|)
block|{
name|flushPending
operator|=
literal|true
expr_stmt|;
name|state
operator|.
name|doFlushAfter
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|state
operator|.
name|doFlushAfter
operator|=
literal|false
expr_stmt|;
name|state
operator|.
name|isIdle
operator|=
literal|false
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|state
operator|.
name|init
argument_list|(
name|doc
argument_list|,
name|nextDocID
operator|++
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|state
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|doFlushAfter
condition|)
block|{
name|state
operator|.
name|doFlushAfter
operator|=
literal|false
expr_stmt|;
name|flushPending
operator|=
literal|false
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|state
return|;
block|}
comment|/** Returns true if the caller (IndexWriter) should now    * flush. */
DECL|method|addDocument
name|boolean
name|addDocument
parameter_list|(
name|Document
name|doc
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
comment|// This call is synchronized but fast
specifier|final
name|ThreadState
name|state
init|=
name|getThreadState
argument_list|(
name|doc
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// This call is not synchronized and does all the work
name|state
operator|.
name|processDocument
argument_list|(
name|analyzer
argument_list|)
expr_stmt|;
comment|// This call synchronized but fast
name|finishDocument
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|state
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|state
operator|.
name|doFlushAfter
return|;
block|}
comment|/** Does the synchronized work to finish/flush the    * inverted document. */
DECL|method|finishDocument
specifier|private
specifier|synchronized
name|void
name|finishDocument
parameter_list|(
name|ThreadState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Now write the indexed document to the real files.
if|if
condition|(
name|nextWriteDocID
operator|==
name|state
operator|.
name|docID
condition|)
block|{
comment|// It's my turn, so write everything now:
name|state
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
name|nextWriteDocID
operator|++
expr_stmt|;
name|state
operator|.
name|writeDocument
argument_list|()
expr_stmt|;
comment|// If any states were waiting on me, sweep through and
comment|// flush those that are enabled by my write.
if|if
condition|(
name|numWaiting
operator|>
literal|0
condition|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|upto
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numWaiting
condition|;
name|i
operator|++
control|)
block|{
name|ThreadState
name|s
init|=
name|waitingThreadStates
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|docID
operator|==
name|nextWriteDocID
condition|)
block|{
name|s
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
name|nextWriteDocID
operator|++
expr_stmt|;
name|s
operator|.
name|writeDocument
argument_list|()
expr_stmt|;
block|}
else|else
comment|// Compact as we go
name|waitingThreadStates
index|[
name|upto
operator|++
index|]
operator|=
name|waitingThreadStates
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|upto
operator|==
name|numWaiting
condition|)
break|break;
name|numWaiting
operator|=
name|upto
expr_stmt|;
block|}
block|}
comment|// Now notify any incoming calls to addDocument
comment|// (above) that are waiting on our line to
comment|// shrink
name|notifyAll
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Another thread got a docID before me, but, it
comment|// hasn't finished its processing.  So add myself to
comment|// the line but don't hold up this thread.
if|if
condition|(
name|numWaiting
operator|==
name|waitingThreadStates
operator|.
name|length
condition|)
block|{
name|ThreadState
index|[]
name|newWaiting
init|=
operator|new
name|ThreadState
index|[
literal|2
operator|*
name|waitingThreadStates
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|waitingThreadStates
argument_list|,
literal|0
argument_list|,
name|newWaiting
argument_list|,
literal|0
argument_list|,
name|numWaiting
argument_list|)
expr_stmt|;
name|waitingThreadStates
operator|=
name|newWaiting
expr_stmt|;
block|}
name|waitingThreadStates
index|[
name|numWaiting
operator|++
index|]
operator|=
name|state
expr_stmt|;
block|}
block|}
DECL|method|getRAMUsed
name|long
name|getRAMUsed
parameter_list|()
block|{
return|return
name|numBytesUsed
return|;
block|}
DECL|field|numBytesAlloc
name|long
name|numBytesAlloc
decl_stmt|;
DECL|field|numBytesUsed
name|long
name|numBytesUsed
decl_stmt|;
DECL|field|nf
name|NumberFormat
name|nf
init|=
name|NumberFormat
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|/* Used only when writing norms to fill in default norm    * value into the holes in docID stream for those docs    * that didn't have this field. */
DECL|method|fillBytes
specifier|static
name|void
name|fillBytes
parameter_list|(
name|IndexOutput
name|out
parameter_list|,
name|byte
name|b
parameter_list|,
name|int
name|numBytes
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numBytes
condition|;
name|i
operator|++
control|)
name|out
operator|.
name|writeByte
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
DECL|field|copyByteBuffer
name|byte
index|[]
name|copyByteBuffer
init|=
operator|new
name|byte
index|[
literal|4096
index|]
decl_stmt|;
comment|/** Copy numBytes from srcIn to destIn */
DECL|method|copyBytes
name|void
name|copyBytes
parameter_list|(
name|IndexInput
name|srcIn
parameter_list|,
name|IndexOutput
name|destIn
parameter_list|,
name|long
name|numBytes
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: we could do this more efficiently (save a copy)
comment|// because it's always from a ByteSliceReader ->
comment|// IndexOutput
while|while
condition|(
name|numBytes
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|chunk
decl_stmt|;
if|if
condition|(
name|numBytes
operator|>
literal|4096
condition|)
name|chunk
operator|=
literal|4096
expr_stmt|;
else|else
name|chunk
operator|=
operator|(
name|int
operator|)
name|numBytes
expr_stmt|;
name|srcIn
operator|.
name|readBytes
argument_list|(
name|copyByteBuffer
argument_list|,
literal|0
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|destIn
operator|.
name|writeBytes
argument_list|(
name|copyByteBuffer
argument_list|,
literal|0
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|numBytes
operator|-=
name|chunk
expr_stmt|;
block|}
block|}
comment|/* Stores norms, buffered in RAM, until they are flushed    * to a partial segment. */
DECL|class|BufferedNorms
specifier|private
specifier|static
class|class
name|BufferedNorms
block|{
DECL|field|out
name|RAMOutputStream
name|out
decl_stmt|;
DECL|field|upto
name|int
name|upto
decl_stmt|;
DECL|method|BufferedNorms
name|BufferedNorms
parameter_list|()
block|{
name|out
operator|=
operator|new
name|RAMOutputStream
argument_list|()
expr_stmt|;
block|}
DECL|method|add
name|void
name|add
parameter_list|(
name|float
name|norm
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
name|b
init|=
name|Similarity
operator|.
name|encodeNorm
argument_list|(
name|norm
argument_list|)
decl_stmt|;
name|out
operator|.
name|writeByte
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
DECL|method|reset
name|void
name|reset
parameter_list|()
block|{
name|out
operator|.
name|reset
argument_list|()
expr_stmt|;
name|upto
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|fill
name|void
name|fill
parameter_list|(
name|int
name|docID
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Must now fill in docs that didn't have this
comment|// field.  Note that this is how norms can consume
comment|// tremendous storage when the docs have widely
comment|// varying different fields, because we are not
comment|// storing the norms sparsely (see LUCENE-830)
if|if
condition|(
name|upto
operator|<
name|docID
condition|)
block|{
name|fillBytes
argument_list|(
name|out
argument_list|,
name|defaultNorm
argument_list|,
name|docID
operator|-
name|upto
argument_list|)
expr_stmt|;
name|upto
operator|=
name|docID
expr_stmt|;
block|}
block|}
block|}
comment|/* Simple StringReader that can be reset to a new string;    * we use this when tokenizing the string value from a    * Field. */
DECL|class|ReusableStringReader
specifier|private
specifier|final
specifier|static
class|class
name|ReusableStringReader
extends|extends
name|Reader
block|{
DECL|field|upto
name|int
name|upto
decl_stmt|;
DECL|field|left
name|int
name|left
decl_stmt|;
DECL|field|s
name|String
name|s
decl_stmt|;
DECL|method|init
name|void
name|init
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|this
operator|.
name|s
operator|=
name|s
expr_stmt|;
name|left
operator|=
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
name|this
operator|.
name|upto
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|read
specifier|public
name|int
name|read
parameter_list|(
name|char
index|[]
name|c
parameter_list|)
block|{
return|return
name|read
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
name|c
operator|.
name|length
argument_list|)
return|;
block|}
DECL|method|read
specifier|public
name|int
name|read
parameter_list|(
name|char
index|[]
name|c
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|left
operator|>
name|len
condition|)
block|{
name|s
operator|.
name|getChars
argument_list|(
name|upto
argument_list|,
name|upto
operator|+
name|len
argument_list|,
name|c
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|upto
operator|+=
name|len
expr_stmt|;
name|left
operator|-=
name|len
expr_stmt|;
return|return
name|len
return|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|left
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|s
operator|.
name|getChars
argument_list|(
name|upto
argument_list|,
name|upto
operator|+
name|left
argument_list|,
name|c
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|int
name|r
init|=
name|left
decl_stmt|;
name|left
operator|=
literal|0
expr_stmt|;
name|upto
operator|=
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{}
empty_stmt|;
block|}
comment|/* IndexInput that knows how to read the byte slices written    * by Posting and PostingVector.  We read the bytes in    * each slice until we hit the end of that slice at which    * point we read the forwarding address of the next slice    * and then jump to it.*/
DECL|class|ByteSliceReader
specifier|private
specifier|final
specifier|static
class|class
name|ByteSliceReader
extends|extends
name|IndexInput
block|{
DECL|field|pool
name|ByteBlockPool
name|pool
decl_stmt|;
DECL|field|bufferUpto
name|int
name|bufferUpto
decl_stmt|;
DECL|field|buffer
name|byte
index|[]
name|buffer
decl_stmt|;
DECL|field|upto
specifier|public
name|int
name|upto
decl_stmt|;
DECL|field|limit
name|int
name|limit
decl_stmt|;
DECL|field|level
name|int
name|level
decl_stmt|;
DECL|field|bufferOffset
specifier|public
name|int
name|bufferOffset
decl_stmt|;
DECL|field|endIndex
specifier|public
name|int
name|endIndex
decl_stmt|;
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
name|ByteBlockPool
name|pool
parameter_list|,
name|int
name|startIndex
parameter_list|,
name|int
name|endIndex
parameter_list|)
block|{
assert|assert
name|endIndex
operator|-
name|startIndex
operator|>
literal|0
assert|;
name|this
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|this
operator|.
name|endIndex
operator|=
name|endIndex
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
name|bufferUpto
operator|=
name|startIndex
operator|/
name|BYTE_BLOCK_SIZE
expr_stmt|;
name|bufferOffset
operator|=
name|bufferUpto
operator|*
name|BYTE_BLOCK_SIZE
expr_stmt|;
name|buffer
operator|=
name|pool
operator|.
name|buffers
index|[
name|bufferUpto
index|]
expr_stmt|;
name|upto
operator|=
name|startIndex
operator|&
name|BYTE_BLOCK_MASK
expr_stmt|;
specifier|final
name|int
name|firstSize
init|=
name|levelSizeArray
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|startIndex
operator|+
name|firstSize
operator|>=
name|endIndex
condition|)
block|{
comment|// There is only this one slice to read
name|limit
operator|=
name|endIndex
operator|&
name|BYTE_BLOCK_MASK
expr_stmt|;
block|}
else|else
name|limit
operator|=
name|upto
operator|+
name|firstSize
operator|-
literal|4
expr_stmt|;
block|}
DECL|method|readByte
specifier|public
name|byte
name|readByte
parameter_list|()
block|{
comment|// Assert that we are not @ EOF
assert|assert
name|upto
operator|+
name|bufferOffset
operator|<
name|endIndex
assert|;
if|if
condition|(
name|upto
operator|==
name|limit
condition|)
name|nextSlice
argument_list|()
expr_stmt|;
return|return
name|buffer
index|[
name|upto
operator|++
index|]
return|;
block|}
DECL|method|writeTo
specifier|public
name|long
name|writeTo
parameter_list|(
name|IndexOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|size
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|limit
operator|+
name|bufferOffset
operator|==
name|endIndex
condition|)
block|{
assert|assert
name|endIndex
operator|-
name|bufferOffset
operator|>=
name|upto
assert|;
name|out
operator|.
name|writeBytes
argument_list|(
name|buffer
argument_list|,
name|upto
argument_list|,
name|limit
operator|-
name|upto
argument_list|)
expr_stmt|;
name|size
operator|+=
name|limit
operator|-
name|upto
expr_stmt|;
break|break;
block|}
else|else
block|{
name|out
operator|.
name|writeBytes
argument_list|(
name|buffer
argument_list|,
name|upto
argument_list|,
name|limit
operator|-
name|upto
argument_list|)
expr_stmt|;
name|size
operator|+=
name|limit
operator|-
name|upto
expr_stmt|;
name|nextSlice
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
DECL|method|nextSlice
specifier|public
name|void
name|nextSlice
parameter_list|()
block|{
comment|// Skip to our next slice
specifier|final
name|int
name|nextIndex
init|=
operator|(
operator|(
name|buffer
index|[
name|limit
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator|+
operator|(
operator|(
name|buffer
index|[
literal|1
operator|+
name|limit
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|buffer
index|[
literal|2
operator|+
name|limit
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
name|buffer
index|[
literal|3
operator|+
name|limit
index|]
operator|&
literal|0xff
operator|)
decl_stmt|;
name|level
operator|=
name|nextLevelArray
index|[
name|level
index|]
expr_stmt|;
specifier|final
name|int
name|newSize
init|=
name|levelSizeArray
index|[
name|level
index|]
decl_stmt|;
name|bufferUpto
operator|=
name|nextIndex
operator|/
name|BYTE_BLOCK_SIZE
expr_stmt|;
name|bufferOffset
operator|=
name|bufferUpto
operator|*
name|BYTE_BLOCK_SIZE
expr_stmt|;
name|buffer
operator|=
name|pool
operator|.
name|buffers
index|[
name|bufferUpto
index|]
expr_stmt|;
name|upto
operator|=
name|nextIndex
operator|&
name|BYTE_BLOCK_MASK
expr_stmt|;
if|if
condition|(
name|nextIndex
operator|+
name|newSize
operator|>=
name|endIndex
condition|)
block|{
comment|// We are advancing to the final slice
assert|assert
name|endIndex
operator|-
name|nextIndex
operator|>
literal|0
assert|;
name|limit
operator|=
name|endIndex
operator|-
name|bufferOffset
expr_stmt|;
block|}
else|else
block|{
comment|// This is not the final slice (subtract 4 for the
comment|// forwarding address at the end of this new slice)
name|limit
operator|=
name|upto
operator|+
name|newSize
operator|-
literal|4
expr_stmt|;
block|}
block|}
DECL|method|readBytes
specifier|public
name|void
name|readBytes
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|numLeft
init|=
name|limit
operator|-
name|upto
decl_stmt|;
if|if
condition|(
name|numLeft
operator|<
name|len
condition|)
block|{
comment|// Read entire slice
name|System
operator|.
name|arraycopy
argument_list|(
name|buffer
argument_list|,
name|upto
argument_list|,
name|b
argument_list|,
name|offset
argument_list|,
name|numLeft
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|numLeft
expr_stmt|;
name|len
operator|-=
name|numLeft
expr_stmt|;
name|nextSlice
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// This slice is the last one
name|System
operator|.
name|arraycopy
argument_list|(
name|buffer
argument_list|,
name|upto
argument_list|,
name|b
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|upto
operator|+=
name|len
expr_stmt|;
break|break;
block|}
block|}
block|}
DECL|method|getFilePointer
specifier|public
name|long
name|getFilePointer
parameter_list|()
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"not implemented"
argument_list|)
throw|;
block|}
DECL|method|length
specifier|public
name|long
name|length
parameter_list|()
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"not implemented"
argument_list|)
throw|;
block|}
DECL|method|seek
specifier|public
name|void
name|seek
parameter_list|(
name|long
name|pos
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"not implemented"
argument_list|)
throw|;
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"not implemented"
argument_list|)
throw|;
block|}
block|}
comment|// Size of each slice.  These arrays should be at most 16
comment|// elements.  First array is just a compact way to encode
comment|// X+1 with a max.  Second array is the length of each
comment|// slice, ie first slice is 5 bytes, next slice is 14
comment|// bytes, etc.
DECL|field|nextLevelArray
specifier|final
specifier|static
name|int
index|[]
name|nextLevelArray
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|9
block|}
decl_stmt|;
DECL|field|levelSizeArray
specifier|final
specifier|static
name|int
index|[]
name|levelSizeArray
init|=
block|{
literal|5
block|,
literal|14
block|,
literal|20
block|,
literal|30
block|,
literal|40
block|,
literal|40
block|,
literal|80
block|,
literal|80
block|,
literal|120
block|,
literal|200
block|}
decl_stmt|;
comment|/* Class that Posting and PostingVector use to write byte    * streams into shared fixed-size byte[] arrays.  The idea    * is to allocate slices of increasing lengths For    * example, the first slice is 5 bytes, the next slice is    * 14, etc.  We start by writing our bytes into the first    * 5 bytes.  When we hit the end of the slice, we allocate    * the next slice and then write the address of the new    * slice into the last 4 bytes of the previous slice (the    * "forwarding address").    *    * Each slice is filled with 0's initially, and we mark    * the end with a non-zero byte.  This way the methods    * that are writing into the slice don't need to record    * its length and instead allocate a new slice once they    * hit a non-zero byte. */
DECL|class|ByteBlockPool
specifier|private
specifier|final
class|class
name|ByteBlockPool
block|{
DECL|field|buffers
specifier|public
name|byte
index|[]
index|[]
name|buffers
init|=
operator|new
name|byte
index|[
literal|10
index|]
index|[]
decl_stmt|;
DECL|field|bufferUpto
name|int
name|bufferUpto
init|=
operator|-
literal|1
decl_stmt|;
comment|// Which buffer we are upto
DECL|field|byteUpto
specifier|public
name|int
name|byteUpto
init|=
name|BYTE_BLOCK_SIZE
decl_stmt|;
comment|// Where we are in head buffer
DECL|field|buffer
specifier|public
name|byte
index|[]
name|buffer
decl_stmt|;
comment|// Current head buffer
DECL|field|byteOffset
specifier|public
name|int
name|byteOffset
init|=
operator|-
name|BYTE_BLOCK_SIZE
decl_stmt|;
comment|// Current head offset
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|recycleByteBlocks
argument_list|(
name|buffers
argument_list|,
literal|1
operator|+
name|bufferUpto
argument_list|)
expr_stmt|;
name|bufferUpto
operator|=
operator|-
literal|1
expr_stmt|;
name|byteUpto
operator|=
name|BYTE_BLOCK_SIZE
expr_stmt|;
name|byteOffset
operator|=
operator|-
name|BYTE_BLOCK_SIZE
expr_stmt|;
block|}
DECL|method|nextBuffer
specifier|public
name|void
name|nextBuffer
parameter_list|()
block|{
name|bufferUpto
operator|++
expr_stmt|;
if|if
condition|(
name|bufferUpto
operator|==
name|buffers
operator|.
name|length
condition|)
block|{
name|byte
index|[]
index|[]
name|newBuffers
init|=
operator|new
name|byte
index|[
call|(
name|int
call|)
argument_list|(
name|bufferUpto
operator|*
literal|1.5
argument_list|)
index|]
index|[]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|buffers
argument_list|,
literal|0
argument_list|,
name|newBuffers
argument_list|,
literal|0
argument_list|,
name|bufferUpto
argument_list|)
expr_stmt|;
name|buffers
operator|=
name|newBuffers
expr_stmt|;
block|}
name|buffer
operator|=
name|buffers
index|[
name|bufferUpto
index|]
operator|=
name|getByteBlock
argument_list|()
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|buffer
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|byteUpto
operator|=
literal|0
expr_stmt|;
name|byteOffset
operator|+=
name|BYTE_BLOCK_SIZE
expr_stmt|;
block|}
DECL|method|newSlice
specifier|public
name|int
name|newSlice
parameter_list|(
specifier|final
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|byteUpto
operator|>
name|BYTE_BLOCK_SIZE
operator|-
name|size
condition|)
name|nextBuffer
argument_list|()
expr_stmt|;
specifier|final
name|int
name|upto
init|=
name|byteUpto
decl_stmt|;
name|byteUpto
operator|+=
name|size
expr_stmt|;
name|buffer
index|[
name|byteUpto
operator|-
literal|1
index|]
operator|=
literal|16
expr_stmt|;
return|return
name|upto
return|;
block|}
DECL|method|allocSlice
specifier|public
name|int
name|allocSlice
parameter_list|(
specifier|final
name|byte
index|[]
name|slice
parameter_list|,
specifier|final
name|int
name|upto
parameter_list|)
block|{
specifier|final
name|int
name|level
init|=
name|slice
index|[
name|upto
index|]
operator|&
literal|15
decl_stmt|;
specifier|final
name|int
name|newLevel
init|=
name|nextLevelArray
index|[
name|level
index|]
decl_stmt|;
specifier|final
name|int
name|newSize
init|=
name|levelSizeArray
index|[
name|newLevel
index|]
decl_stmt|;
comment|// Maybe allocate another block
if|if
condition|(
name|byteUpto
operator|>
name|BYTE_BLOCK_SIZE
operator|-
name|newSize
condition|)
name|nextBuffer
argument_list|()
expr_stmt|;
specifier|final
name|int
name|newUpto
init|=
name|byteUpto
decl_stmt|;
specifier|final
name|int
name|offset
init|=
name|newUpto
operator|+
name|byteOffset
decl_stmt|;
name|byteUpto
operator|+=
name|newSize
expr_stmt|;
comment|// Copy forward the past 3 bytes (which we are about
comment|// to overwrite with the forwarding address):
name|buffer
index|[
name|newUpto
index|]
operator|=
name|slice
index|[
name|upto
operator|-
literal|3
index|]
expr_stmt|;
name|buffer
index|[
name|newUpto
operator|+
literal|1
index|]
operator|=
name|slice
index|[
name|upto
operator|-
literal|2
index|]
expr_stmt|;
name|buffer
index|[
name|newUpto
operator|+
literal|2
index|]
operator|=
name|slice
index|[
name|upto
operator|-
literal|1
index|]
expr_stmt|;
comment|// Write forwarding address at end of last slice:
name|slice
index|[
name|upto
operator|-
literal|3
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|offset
operator|>>>
literal|24
argument_list|)
expr_stmt|;
name|slice
index|[
name|upto
operator|-
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|offset
operator|>>>
literal|16
argument_list|)
expr_stmt|;
name|slice
index|[
name|upto
operator|-
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|offset
operator|>>>
literal|8
argument_list|)
expr_stmt|;
name|slice
index|[
name|upto
index|]
operator|=
operator|(
name|byte
operator|)
name|offset
expr_stmt|;
comment|// Write new level:
name|buffer
index|[
name|byteUpto
operator|-
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|16
operator||
name|newLevel
argument_list|)
expr_stmt|;
return|return
name|newUpto
operator|+
literal|3
return|;
block|}
block|}
DECL|class|CharBlockPool
specifier|private
specifier|final
class|class
name|CharBlockPool
block|{
DECL|field|buffers
specifier|public
name|char
index|[]
index|[]
name|buffers
init|=
operator|new
name|char
index|[
literal|10
index|]
index|[]
decl_stmt|;
DECL|field|numBuffer
name|int
name|numBuffer
decl_stmt|;
DECL|field|bufferUpto
name|int
name|bufferUpto
init|=
operator|-
literal|1
decl_stmt|;
comment|// Which buffer we are upto
DECL|field|byteUpto
specifier|public
name|int
name|byteUpto
init|=
name|CHAR_BLOCK_SIZE
decl_stmt|;
comment|// Where we are in head buffer
DECL|field|buffer
specifier|public
name|char
index|[]
name|buffer
decl_stmt|;
comment|// Current head buffer
DECL|field|byteOffset
specifier|public
name|int
name|byteOffset
init|=
operator|-
name|CHAR_BLOCK_SIZE
decl_stmt|;
comment|// Current head offset
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|recycleCharBlocks
argument_list|(
name|buffers
argument_list|,
literal|1
operator|+
name|bufferUpto
argument_list|)
expr_stmt|;
name|bufferUpto
operator|=
operator|-
literal|1
expr_stmt|;
name|byteUpto
operator|=
name|CHAR_BLOCK_SIZE
expr_stmt|;
name|byteOffset
operator|=
operator|-
name|CHAR_BLOCK_SIZE
expr_stmt|;
block|}
DECL|method|nextBuffer
specifier|public
name|void
name|nextBuffer
parameter_list|()
block|{
name|bufferUpto
operator|++
expr_stmt|;
if|if
condition|(
name|bufferUpto
operator|==
name|buffers
operator|.
name|length
condition|)
block|{
name|char
index|[]
index|[]
name|newBuffers
init|=
operator|new
name|char
index|[
call|(
name|int
call|)
argument_list|(
name|bufferUpto
operator|*
literal|1.5
argument_list|)
index|]
index|[]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|buffers
argument_list|,
literal|0
argument_list|,
name|newBuffers
argument_list|,
literal|0
argument_list|,
name|bufferUpto
argument_list|)
expr_stmt|;
name|buffers
operator|=
name|newBuffers
expr_stmt|;
block|}
name|buffer
operator|=
name|buffers
index|[
name|bufferUpto
index|]
operator|=
name|getCharBlock
argument_list|()
expr_stmt|;
name|byteUpto
operator|=
literal|0
expr_stmt|;
name|byteOffset
operator|+=
name|CHAR_BLOCK_SIZE
expr_stmt|;
block|}
block|}
comment|// Used only when infoStream != null
DECL|method|segmentSize
specifier|private
name|long
name|segmentSize
parameter_list|(
name|String
name|segmentName
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|infoStream
operator|!=
literal|null
assert|;
name|long
name|size
init|=
name|directory
operator|.
name|fileLength
argument_list|(
name|segmentName
operator|+
literal|".tii"
argument_list|)
operator|+
name|directory
operator|.
name|fileLength
argument_list|(
name|segmentName
operator|+
literal|".tis"
argument_list|)
operator|+
name|directory
operator|.
name|fileLength
argument_list|(
name|segmentName
operator|+
literal|".frq"
argument_list|)
operator|+
name|directory
operator|.
name|fileLength
argument_list|(
name|segmentName
operator|+
literal|".prx"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|normFileName
init|=
name|segmentName
operator|+
literal|".nrm"
decl_stmt|;
if|if
condition|(
name|directory
operator|.
name|fileExists
argument_list|(
name|normFileName
argument_list|)
condition|)
name|size
operator|+=
name|directory
operator|.
name|fileLength
argument_list|(
name|normFileName
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
DECL|field|POINTER_NUM_BYTE
specifier|final
specifier|private
specifier|static
name|int
name|POINTER_NUM_BYTE
init|=
literal|4
decl_stmt|;
DECL|field|INT_NUM_BYTE
specifier|final
specifier|private
specifier|static
name|int
name|INT_NUM_BYTE
init|=
literal|4
decl_stmt|;
DECL|field|CHAR_NUM_BYTE
specifier|final
specifier|private
specifier|static
name|int
name|CHAR_NUM_BYTE
init|=
literal|2
decl_stmt|;
DECL|field|OBJECT_HEADER_NUM_BYTE
specifier|final
specifier|private
specifier|static
name|int
name|OBJECT_HEADER_NUM_BYTE
init|=
literal|8
decl_stmt|;
DECL|field|POSTING_NUM_BYTE
specifier|final
specifier|static
name|int
name|POSTING_NUM_BYTE
init|=
name|OBJECT_HEADER_NUM_BYTE
operator|+
literal|9
operator|*
name|INT_NUM_BYTE
operator|+
name|POINTER_NUM_BYTE
decl_stmt|;
comment|// Holds free pool of Posting instances
DECL|field|postingsFreeList
specifier|private
name|Posting
index|[]
name|postingsFreeList
decl_stmt|;
DECL|field|postingsFreeCount
specifier|private
name|int
name|postingsFreeCount
decl_stmt|;
comment|/* Allocate more Postings from shared pool */
DECL|method|getPostings
specifier|private
specifier|synchronized
name|void
name|getPostings
parameter_list|(
name|Posting
index|[]
name|postings
parameter_list|)
block|{
name|numBytesUsed
operator|+=
name|postings
operator|.
name|length
operator|*
name|POSTING_NUM_BYTE
expr_stmt|;
specifier|final
name|int
name|numToCopy
decl_stmt|;
if|if
condition|(
name|postingsFreeCount
operator|<
name|postings
operator|.
name|length
condition|)
name|numToCopy
operator|=
name|postingsFreeCount
expr_stmt|;
else|else
name|numToCopy
operator|=
name|postings
operator|.
name|length
expr_stmt|;
specifier|final
name|int
name|start
init|=
name|postingsFreeCount
operator|-
name|numToCopy
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|postingsFreeList
argument_list|,
name|start
argument_list|,
name|postings
argument_list|,
literal|0
argument_list|,
name|numToCopy
argument_list|)
expr_stmt|;
name|postingsFreeCount
operator|-=
name|numToCopy
expr_stmt|;
comment|// Directly allocate the remainder if any
if|if
condition|(
name|numToCopy
operator|<
name|postings
operator|.
name|length
condition|)
block|{
name|numBytesAlloc
operator|+=
operator|(
name|postings
operator|.
name|length
operator|-
name|numToCopy
operator|)
operator|*
name|POSTING_NUM_BYTE
expr_stmt|;
name|balanceRAM
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|numToCopy
init|;
name|i
operator|<
name|postings
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|postings
index|[
name|i
index|]
operator|=
operator|new
name|Posting
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|recyclePostings
specifier|private
specifier|synchronized
name|void
name|recyclePostings
parameter_list|(
name|Posting
index|[]
name|postings
parameter_list|,
name|int
name|numPostings
parameter_list|)
block|{
comment|// Move all Postings from this ThreadState back to our
comment|// free list
if|if
condition|(
name|postingsFreeCount
operator|+
name|numPostings
operator|>
name|postingsFreeList
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|newSize
init|=
call|(
name|int
call|)
argument_list|(
literal|1.25
operator|*
operator|(
name|postingsFreeCount
operator|+
name|numPostings
operator|)
argument_list|)
decl_stmt|;
name|Posting
index|[]
name|newArray
init|=
operator|new
name|Posting
index|[
name|newSize
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|postingsFreeList
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|postingsFreeCount
argument_list|)
expr_stmt|;
name|postingsFreeList
operator|=
name|newArray
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|postings
argument_list|,
literal|0
argument_list|,
name|postingsFreeList
argument_list|,
name|postingsFreeCount
argument_list|,
name|numPostings
argument_list|)
expr_stmt|;
name|postingsFreeCount
operator|+=
name|numPostings
expr_stmt|;
name|numBytesUsed
operator|-=
name|numPostings
operator|*
name|POSTING_NUM_BYTE
expr_stmt|;
block|}
comment|/* Initial chunks size of the shared byte[] blocks used to      store postings data */
DECL|field|BYTE_BLOCK_SHIFT
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_SHIFT
init|=
literal|15
decl_stmt|;
DECL|field|BYTE_BLOCK_SIZE
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_SIZE
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|pow
argument_list|(
literal|2.0
argument_list|,
name|BYTE_BLOCK_SHIFT
argument_list|)
decl_stmt|;
DECL|field|BYTE_BLOCK_MASK
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_MASK
init|=
name|BYTE_BLOCK_SIZE
operator|-
literal|1
decl_stmt|;
DECL|field|BYTE_BLOCK_NOT_MASK
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_NOT_MASK
init|=
operator|~
name|BYTE_BLOCK_MASK
decl_stmt|;
DECL|field|freeByteBlocks
specifier|private
name|ArrayList
name|freeByteBlocks
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
comment|/* Allocate another byte[] from the shared pool */
DECL|method|getByteBlock
specifier|synchronized
name|byte
index|[]
name|getByteBlock
parameter_list|()
block|{
specifier|final
name|int
name|size
init|=
name|freeByteBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|b
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|size
condition|)
block|{
name|numBytesAlloc
operator|+=
name|BYTE_BLOCK_SIZE
expr_stmt|;
name|balanceRAM
argument_list|()
expr_stmt|;
name|b
operator|=
operator|new
name|byte
index|[
name|BYTE_BLOCK_SIZE
index|]
expr_stmt|;
block|}
else|else
name|b
operator|=
operator|(
name|byte
index|[]
operator|)
name|freeByteBlocks
operator|.
name|remove
argument_list|(
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|numBytesUsed
operator|+=
name|BYTE_BLOCK_SIZE
expr_stmt|;
return|return
name|b
return|;
block|}
comment|/* Return a byte[] to the pool */
DECL|method|recycleByteBlocks
specifier|synchronized
name|void
name|recycleByteBlocks
parameter_list|(
name|byte
index|[]
index|[]
name|blocks
parameter_list|,
name|int
name|numBlocks
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numBlocks
condition|;
name|i
operator|++
control|)
name|freeByteBlocks
operator|.
name|add
argument_list|(
name|blocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|numBytesUsed
operator|-=
name|numBlocks
operator|*
name|BYTE_BLOCK_SIZE
expr_stmt|;
block|}
comment|/* Initial chunk size of the shared char[] blocks used to      store term text */
DECL|field|CHAR_BLOCK_SHIFT
specifier|final
specifier|static
name|int
name|CHAR_BLOCK_SHIFT
init|=
literal|14
decl_stmt|;
DECL|field|CHAR_BLOCK_SIZE
specifier|final
specifier|static
name|int
name|CHAR_BLOCK_SIZE
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|pow
argument_list|(
literal|2.0
argument_list|,
name|CHAR_BLOCK_SHIFT
argument_list|)
decl_stmt|;
DECL|field|CHAR_BLOCK_MASK
specifier|final
specifier|static
name|int
name|CHAR_BLOCK_MASK
init|=
name|CHAR_BLOCK_SIZE
operator|-
literal|1
decl_stmt|;
DECL|field|freeCharBlocks
specifier|private
name|ArrayList
name|freeCharBlocks
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
comment|/* Allocate another char[] from the shared pool */
DECL|method|getCharBlock
specifier|synchronized
name|char
index|[]
name|getCharBlock
parameter_list|()
block|{
specifier|final
name|int
name|size
init|=
name|freeCharBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|char
index|[]
name|c
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|size
condition|)
block|{
name|numBytesAlloc
operator|+=
name|CHAR_BLOCK_SIZE
operator|*
name|CHAR_NUM_BYTE
expr_stmt|;
name|balanceRAM
argument_list|()
expr_stmt|;
name|c
operator|=
operator|new
name|char
index|[
name|BYTE_BLOCK_SIZE
index|]
expr_stmt|;
block|}
else|else
name|c
operator|=
operator|(
name|char
index|[]
operator|)
name|freeCharBlocks
operator|.
name|remove
argument_list|(
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|numBytesUsed
operator|+=
name|CHAR_BLOCK_SIZE
operator|*
name|CHAR_NUM_BYTE
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/* Return a char[] to the pool */
DECL|method|recycleCharBlocks
specifier|synchronized
name|void
name|recycleCharBlocks
parameter_list|(
name|char
index|[]
index|[]
name|blocks
parameter_list|,
name|int
name|numBlocks
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numBlocks
condition|;
name|i
operator|++
control|)
name|freeCharBlocks
operator|.
name|add
argument_list|(
name|blocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|numBytesUsed
operator|-=
name|numBlocks
operator|*
name|CHAR_BLOCK_SIZE
operator|*
name|CHAR_NUM_BYTE
expr_stmt|;
block|}
DECL|method|toMB
name|String
name|toMB
parameter_list|(
name|long
name|v
parameter_list|)
block|{
return|return
name|nf
operator|.
name|format
argument_list|(
name|v
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
return|;
block|}
comment|/* We have three pools of RAM: Postings, byte blocks    * (holds freq/prox posting data) and char blocks (holds    * characters in the term).  Different docs require    * varying amount of storage from these three classes.    * For example, docs with many unique single-occurrence    * short terms will use up the Postings RAM and hardly any    * of the other two.  Whereas docs with very large terms    * will use alot of char blocks RAM and relatively less of    * the other two.  This method just frees allocations from    * the pools once we are over-budget, which balances the    * pools to match the current docs. */
DECL|method|balanceRAM
specifier|private
specifier|synchronized
name|void
name|balanceRAM
parameter_list|()
block|{
if|if
condition|(
name|ramBufferSize
operator|==
literal|0.0
operator|||
name|postingsIsFull
condition|)
return|return;
comment|// We free our allocations if we've allocated 5% over
comment|// our allowed RAM buffer
specifier|final
name|long
name|freeTrigger
init|=
call|(
name|long
call|)
argument_list|(
literal|1.05
operator|*
name|ramBufferSize
argument_list|)
decl_stmt|;
specifier|final
name|long
name|freeLevel
init|=
call|(
name|long
call|)
argument_list|(
literal|0.95
operator|*
name|ramBufferSize
argument_list|)
decl_stmt|;
comment|// We flush when we've used our target usage
specifier|final
name|long
name|flushTrigger
init|=
operator|(
name|long
operator|)
name|ramBufferSize
decl_stmt|;
if|if
condition|(
name|numBytesAlloc
operator|>
name|freeTrigger
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"  RAM: now balance allocations: usedMB="
operator|+
name|toMB
argument_list|(
name|numBytesUsed
argument_list|)
operator|+
literal|" vs trigger="
operator|+
name|toMB
argument_list|(
name|flushTrigger
argument_list|)
operator|+
literal|" allocMB="
operator|+
name|toMB
argument_list|(
name|numBytesAlloc
argument_list|)
operator|+
literal|" vs trigger="
operator|+
name|toMB
argument_list|(
name|freeTrigger
argument_list|)
operator|+
literal|" postingsFree="
operator|+
name|toMB
argument_list|(
name|postingsFreeCount
operator|*
name|POSTING_NUM_BYTE
argument_list|)
operator|+
literal|" byteBlockFree="
operator|+
name|toMB
argument_list|(
name|freeByteBlocks
operator|.
name|size
argument_list|()
operator|*
name|BYTE_BLOCK_SIZE
argument_list|)
operator|+
literal|" charBlockFree="
operator|+
name|toMB
argument_list|(
name|freeCharBlocks
operator|.
name|size
argument_list|()
operator|*
name|CHAR_BLOCK_SIZE
operator|*
name|CHAR_NUM_BYTE
argument_list|)
argument_list|)
expr_stmt|;
comment|// When we've crossed 100% of our target Postings
comment|// RAM usage, try to free up until we're back down
comment|// to 95%
specifier|final
name|long
name|startBytesAlloc
init|=
name|numBytesAlloc
decl_stmt|;
specifier|final
name|int
name|postingsFreeChunk
init|=
call|(
name|int
call|)
argument_list|(
name|BYTE_BLOCK_SIZE
operator|/
name|POSTING_NUM_BYTE
argument_list|)
decl_stmt|;
name|int
name|iter
init|=
literal|0
decl_stmt|;
comment|// We free equally from each pool in 64 KB
comment|// chunks until we are below our threshold
comment|// (freeLevel)
while|while
condition|(
name|numBytesAlloc
operator|>
name|freeLevel
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|freeByteBlocks
operator|.
name|size
argument_list|()
operator|&&
literal|0
operator|==
name|freeCharBlocks
operator|.
name|size
argument_list|()
operator|&&
literal|0
operator|==
name|postingsFreeCount
condition|)
block|{
comment|// Nothing else to free -- must flush now.
name|postingsIsFull
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"    nothing to free; now set postingsIsFull"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
literal|0
operator|==
name|iter
operator|%
literal|3
operator|)
operator|&&
name|freeByteBlocks
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|freeByteBlocks
operator|.
name|remove
argument_list|(
name|freeByteBlocks
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|numBytesAlloc
operator|-=
name|BYTE_BLOCK_SIZE
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|1
operator|==
name|iter
operator|%
literal|3
operator|)
operator|&&
name|freeCharBlocks
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|freeCharBlocks
operator|.
name|remove
argument_list|(
name|freeCharBlocks
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|numBytesAlloc
operator|-=
name|CHAR_BLOCK_SIZE
operator|*
name|CHAR_NUM_BYTE
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|2
operator|==
name|iter
operator|%
literal|3
operator|)
operator|&&
name|postingsFreeCount
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|numToFree
decl_stmt|;
if|if
condition|(
name|postingsFreeCount
operator|>=
name|postingsFreeChunk
condition|)
name|numToFree
operator|=
name|postingsFreeChunk
expr_stmt|;
else|else
name|numToFree
operator|=
name|postingsFreeCount
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|postingsFreeList
argument_list|,
name|postingsFreeCount
operator|-
name|numToFree
argument_list|,
name|postingsFreeCount
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|postingsFreeCount
operator|-=
name|numToFree
expr_stmt|;
name|numBytesAlloc
operator|-=
name|numToFree
operator|*
name|POSTING_NUM_BYTE
expr_stmt|;
block|}
name|iter
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"    after free: freedMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
operator|(
name|startBytesAlloc
operator|-
name|numBytesAlloc
operator|)
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
operator|+
literal|" usedMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|numBytesUsed
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
operator|+
literal|" allocMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|numBytesAlloc
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If we have not crossed the 100% mark, but have
comment|// crossed the 95% mark of RAM we are actually
comment|// using, go ahead and flush.  This prevents
comment|// over-allocating and then freeing, with every
comment|// flush.
if|if
condition|(
name|numBytesUsed
operator|>
name|flushTrigger
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"  RAM: now flush @ usedMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|numBytesUsed
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
operator|+
literal|" allocMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|numBytesAlloc
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
operator|+
literal|" triggerMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|flushTrigger
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
argument_list|)
expr_stmt|;
name|postingsIsFull
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|/* Used to track postings for a single term.  One of these    * exists per unique term seen since the last flush. */
DECL|class|Posting
specifier|private
specifier|final
specifier|static
class|class
name|Posting
block|{
DECL|field|textStart
name|int
name|textStart
decl_stmt|;
comment|// Address into char[] blocks where our text is stored
DECL|field|docFreq
name|int
name|docFreq
decl_stmt|;
comment|// # times this term occurs in the current doc
DECL|field|freqStart
name|int
name|freqStart
decl_stmt|;
comment|// Address of first byte[] slice for freq
DECL|field|freqUpto
name|int
name|freqUpto
decl_stmt|;
comment|// Next write address for freq
DECL|field|proxStart
name|int
name|proxStart
decl_stmt|;
comment|// Address of first byte[] slice
DECL|field|proxUpto
name|int
name|proxUpto
decl_stmt|;
comment|// Next write address for prox
DECL|field|lastDocID
name|int
name|lastDocID
decl_stmt|;
comment|// Last docID where this term occurred
DECL|field|lastDocCode
name|int
name|lastDocCode
decl_stmt|;
comment|// Code for prior doc
DECL|field|lastPosition
name|int
name|lastPosition
decl_stmt|;
comment|// Last position where this term occurred
DECL|field|vector
name|PostingVector
name|vector
decl_stmt|;
comment|// Corresponding PostingVector instance
block|}
comment|/* Used to track data for term vectors.  One of these    * exists per unique term seen in each field in the    * document. */
DECL|class|PostingVector
specifier|private
specifier|final
specifier|static
class|class
name|PostingVector
block|{
DECL|field|p
name|Posting
name|p
decl_stmt|;
comment|// Corresponding Posting instance for this term
DECL|field|lastOffset
name|int
name|lastOffset
decl_stmt|;
comment|// Last offset we saw
DECL|field|offsetStart
name|int
name|offsetStart
decl_stmt|;
comment|// Address of first slice for offsets
DECL|field|offsetUpto
name|int
name|offsetUpto
decl_stmt|;
comment|// Next write address for offsets
DECL|field|posStart
name|int
name|posStart
decl_stmt|;
comment|// Address of first slice for positions
DECL|field|posUpto
name|int
name|posUpto
decl_stmt|;
comment|// Next write address for positions
block|}
block|}
end_class
end_unit
