begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Scorer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Weight
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_comment
comment|/**  * This class accepts multiple added documents and directly  * writes a single segment file.  It does this more  * efficiently than creating a single segment per document  * (with DocumentWriter) and doing standard merges on those  * segments.  *  * When a document is added, its stored fields (if any) and  * term vectors (if any) are immediately written to the  * Directory (ie these do not consume RAM).  The freq/prox  * postings are accumulated into a Postings hash table keyed  * by term.  Each entry in this hash table holds a separate  * byte stream (allocated as incrementally growing slices  * into large shared byte[] arrays) for freq and prox, that  * contains the postings data for multiple documents.  If  * vectors are enabled, each unique term for each document  * also allocates a PostingVector instance to similarly  * track the offsets& positions byte stream.  *  * Once the Postings hash is full (ie is consuming the  * allowed RAM) or the number of added docs is large enough  * (in the case we are flushing by doc count instead of RAM  * usage), we create a real segment and flush it to disk and  * reset the Postings hash.  *  * In adding a document we first organize all of its fields  * by field name.  We then process field by field, and  * record the Posting hash per-field.  After each field we  * flush its term vectors.  When it's time to flush the full  * segment we first sort the fields by name, and then go  * field by field and sorts its postings.  *  *  * Threads:  *  * Multiple threads are allowed into addDocument at once.  * There is an initial synchronized call to getThreadState  * which allocates a ThreadState for this thread.  The same  * thread will get the same ThreadState over time (thread  * affinity) so that if there are consistent patterns (for  * example each thread is indexing a different content  * source) then we make better use of RAM.  Then  * processDocument is called on that ThreadState without  * synchronization (most of the "heavy lifting" is in this  * call).  Finally the synchronized "finishDocument" is  * called to flush changes to the directory.  *  * Each ThreadState instance has its own Posting hash. Once  * we're using too much RAM, we flush all Posting hashes to  * a segment by merging the docIDs in the posting lists for  * the same term across multiple thread states (see  * writeSegment and appendPostings).  *  * When flush is called by IndexWriter, or, we flush  * internally when autoCommit=false, we forcefully idle all  * threads and flush only once they are all idle.  This  * means you can call flush with a given thread even while  * other threads are actively adding/deleting documents.  *  *  * Exceptions:  *  * Because this class directly updates in-memory posting  * lists, and flushes stored fields and term vectors  * directly to files in the directory, there are certain  * limited times when an exception can corrupt this state.  * For example, a disk full while flushing stored fields  * leaves this file in a corrupt state.  Or, an OOM  * exception while appending to the in-memory posting lists  * can corrupt that posting list.  We call such exceptions  * "aborting exceptions".  In these cases we must call  * abort() to discard all docs added since the last flush.  *  * All other exceptions ("non-aborting exceptions") can  * still partially update the index structures.  These  * updates are consistent, but, they represent only a part  * of the document seen up until the exception was hit.  * When this happens, we immediately mark the document as  * deleted so that the document is always atomically ("all  * or none") added to the index.  */
end_comment
begin_class
DECL|class|DocumentsWriter
specifier|final
class|class
name|DocumentsWriter
block|{
DECL|field|writer
name|IndexWriter
name|writer
decl_stmt|;
DECL|field|directory
name|Directory
name|directory
decl_stmt|;
DECL|field|fieldInfos
name|FieldInfos
name|fieldInfos
init|=
operator|new
name|FieldInfos
argument_list|()
decl_stmt|;
comment|// All fields we've seen
DECL|field|tvx
DECL|field|tvf
DECL|field|tvd
name|IndexOutput
name|tvx
decl_stmt|,
name|tvf
decl_stmt|,
name|tvd
decl_stmt|;
comment|// To write term vectors
DECL|field|fieldsWriter
name|FieldsWriter
name|fieldsWriter
decl_stmt|;
comment|// To write stored fields
DECL|field|segment
name|String
name|segment
decl_stmt|;
comment|// Current segment we are working on
DECL|field|docStoreSegment
name|String
name|docStoreSegment
decl_stmt|;
comment|// Current doc-store segment we are writing
DECL|field|docStoreOffset
specifier|private
name|int
name|docStoreOffset
decl_stmt|;
comment|// Current starting doc-store offset of current segment
DECL|field|nextDocID
specifier|private
name|int
name|nextDocID
decl_stmt|;
comment|// Next docID to be added
DECL|field|numDocsInRAM
specifier|private
name|int
name|numDocsInRAM
decl_stmt|;
comment|// # docs buffered in RAM
DECL|field|numDocsInStore
name|int
name|numDocsInStore
decl_stmt|;
comment|// # docs written to doc stores
DECL|field|nextWriteDocID
specifier|private
name|int
name|nextWriteDocID
decl_stmt|;
comment|// Next docID to be written
comment|// Max # ThreadState instances; if there are more threads
comment|// than this they share ThreadStates
DECL|field|MAX_THREAD_STATE
specifier|private
specifier|final
specifier|static
name|int
name|MAX_THREAD_STATE
init|=
literal|5
decl_stmt|;
DECL|field|threadStates
specifier|private
name|DocumentsWriterThreadState
index|[]
name|threadStates
init|=
operator|new
name|DocumentsWriterThreadState
index|[
literal|0
index|]
decl_stmt|;
DECL|field|threadBindings
specifier|private
specifier|final
name|HashMap
name|threadBindings
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
DECL|field|numWaiting
specifier|private
name|int
name|numWaiting
decl_stmt|;
DECL|field|waitingThreadStates
specifier|private
specifier|final
name|DocumentsWriterThreadState
index|[]
name|waitingThreadStates
init|=
operator|new
name|DocumentsWriterThreadState
index|[
name|MAX_THREAD_STATE
index|]
decl_stmt|;
DECL|field|pauseThreads
specifier|private
name|int
name|pauseThreads
decl_stmt|;
comment|// Non-zero when we need all threads to
comment|// pause (eg to flush)
DECL|field|flushPending
name|boolean
name|flushPending
decl_stmt|;
comment|// True when a thread has decided to flush
DECL|field|bufferIsFull
name|boolean
name|bufferIsFull
decl_stmt|;
comment|// True when it's time to write segment
DECL|field|abortCount
specifier|private
name|int
name|abortCount
decl_stmt|;
comment|// Non-zero while abort is pending or running
DECL|field|infoStream
name|PrintStream
name|infoStream
decl_stmt|;
DECL|field|hasNorms
name|boolean
name|hasNorms
decl_stmt|;
comment|// Whether any norms were seen since last flush
DECL|field|newFiles
name|List
name|newFiles
decl_stmt|;
comment|// Deletes done after the last flush; these are discarded
comment|// on abort
DECL|field|deletesInRAM
specifier|private
name|BufferedDeletes
name|deletesInRAM
init|=
operator|new
name|BufferedDeletes
argument_list|()
decl_stmt|;
comment|// Deletes done before the last flush; these are still
comment|// kept on abort
DECL|field|deletesFlushed
specifier|private
name|BufferedDeletes
name|deletesFlushed
init|=
operator|new
name|BufferedDeletes
argument_list|()
decl_stmt|;
comment|// The max number of delete terms that can be buffered before
comment|// they must be flushed to disk.
DECL|field|maxBufferedDeleteTerms
specifier|private
name|int
name|maxBufferedDeleteTerms
init|=
name|IndexWriter
operator|.
name|DEFAULT_MAX_BUFFERED_DELETE_TERMS
decl_stmt|;
comment|// How much RAM we can use before flushing.  This is 0 if
comment|// we are flushing by doc count instead.
DECL|field|ramBufferSize
specifier|private
name|long
name|ramBufferSize
init|=
call|(
name|long
call|)
argument_list|(
name|IndexWriter
operator|.
name|DEFAULT_RAM_BUFFER_SIZE_MB
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
decl_stmt|;
comment|// Flush @ this number of docs.  If rarmBufferSize is
comment|// non-zero we will flush by RAM usage instead.
DECL|field|maxBufferedDocs
specifier|private
name|int
name|maxBufferedDocs
init|=
name|IndexWriter
operator|.
name|DEFAULT_MAX_BUFFERED_DOCS
decl_stmt|;
DECL|field|flushedDocCount
specifier|private
name|int
name|flushedDocCount
decl_stmt|;
comment|// How many docs already flushed to index
DECL|method|updateFlushedDocCount
specifier|synchronized
name|void
name|updateFlushedDocCount
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|flushedDocCount
operator|+=
name|n
expr_stmt|;
block|}
DECL|method|getFlushedDocCount
specifier|synchronized
name|int
name|getFlushedDocCount
parameter_list|()
block|{
return|return
name|flushedDocCount
return|;
block|}
DECL|method|setFlushedDocCount
specifier|synchronized
name|void
name|setFlushedDocCount
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|flushedDocCount
operator|=
name|n
expr_stmt|;
block|}
DECL|field|closed
specifier|private
name|boolean
name|closed
decl_stmt|;
comment|// Coarse estimates used to measure RAM usage of buffered deletes
DECL|field|OBJECT_HEADER_BYTES
specifier|private
specifier|static
name|int
name|OBJECT_HEADER_BYTES
init|=
literal|8
decl_stmt|;
DECL|field|norms
name|BufferedNorms
index|[]
name|norms
init|=
operator|new
name|BufferedNorms
index|[
literal|0
index|]
decl_stmt|;
comment|// Holds norms until we flush
DECL|method|DocumentsWriter
name|DocumentsWriter
parameter_list|(
name|Directory
name|directory
parameter_list|,
name|IndexWriter
name|writer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
name|this
operator|.
name|writer
operator|=
name|writer
expr_stmt|;
name|flushedDocCount
operator|=
name|writer
operator|.
name|docCount
argument_list|()
expr_stmt|;
name|postingsFreeList
operator|=
operator|new
name|Posting
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/** If non-null, various details of indexing are printed    *  here. */
DECL|method|setInfoStream
name|void
name|setInfoStream
parameter_list|(
name|PrintStream
name|infoStream
parameter_list|)
block|{
name|this
operator|.
name|infoStream
operator|=
name|infoStream
expr_stmt|;
block|}
comment|/** Set how much RAM we can use before flushing. */
DECL|method|setRAMBufferSizeMB
name|void
name|setRAMBufferSizeMB
parameter_list|(
name|double
name|mb
parameter_list|)
block|{
if|if
condition|(
name|mb
operator|==
name|IndexWriter
operator|.
name|DISABLE_AUTO_FLUSH
condition|)
block|{
name|ramBufferSize
operator|=
name|IndexWriter
operator|.
name|DISABLE_AUTO_FLUSH
expr_stmt|;
block|}
else|else
block|{
name|ramBufferSize
operator|=
call|(
name|long
call|)
argument_list|(
name|mb
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getRAMBufferSizeMB
name|double
name|getRAMBufferSizeMB
parameter_list|()
block|{
if|if
condition|(
name|ramBufferSize
operator|==
name|IndexWriter
operator|.
name|DISABLE_AUTO_FLUSH
condition|)
block|{
return|return
name|ramBufferSize
return|;
block|}
else|else
block|{
return|return
name|ramBufferSize
operator|/
literal|1024.
operator|/
literal|1024.
return|;
block|}
block|}
comment|/** Set max buffered docs, which means we will flush by    *  doc count instead of by RAM usage. */
DECL|method|setMaxBufferedDocs
name|void
name|setMaxBufferedDocs
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|maxBufferedDocs
operator|=
name|count
expr_stmt|;
block|}
DECL|method|getMaxBufferedDocs
name|int
name|getMaxBufferedDocs
parameter_list|()
block|{
return|return
name|maxBufferedDocs
return|;
block|}
comment|/** Get current segment name we are writing. */
DECL|method|getSegment
name|String
name|getSegment
parameter_list|()
block|{
return|return
name|segment
return|;
block|}
comment|/** Returns how many docs are currently buffered in RAM. */
DECL|method|getNumDocsInRAM
name|int
name|getNumDocsInRAM
parameter_list|()
block|{
return|return
name|numDocsInRAM
return|;
block|}
comment|/** Returns the current doc store segment we are writing    *  to.  This will be the same as segment when autoCommit    *  * is true. */
DECL|method|getDocStoreSegment
name|String
name|getDocStoreSegment
parameter_list|()
block|{
return|return
name|docStoreSegment
return|;
block|}
comment|/** Returns the doc offset into the shared doc store for    *  the current buffered docs. */
DECL|method|getDocStoreOffset
name|int
name|getDocStoreOffset
parameter_list|()
block|{
return|return
name|docStoreOffset
return|;
block|}
comment|/** Closes the current open doc stores an returns the doc    *  store segment name.  This returns null if there are *    *  no buffered documents. */
DECL|method|closeDocStore
name|String
name|closeDocStore
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|allThreadsIdle
argument_list|()
assert|;
name|List
name|flushedFiles
init|=
name|files
argument_list|()
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"\ncloseDocStore: "
operator|+
name|flushedFiles
operator|.
name|size
argument_list|()
operator|+
literal|" files to flush to segment "
operator|+
name|docStoreSegment
operator|+
literal|" numDocs="
operator|+
name|numDocsInStore
argument_list|)
expr_stmt|;
if|if
condition|(
name|flushedFiles
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|files
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|tvx
operator|!=
literal|null
condition|)
block|{
comment|// At least one doc in this run had term vectors enabled
assert|assert
name|docStoreSegment
operator|!=
literal|null
assert|;
name|tvx
operator|.
name|close
argument_list|()
expr_stmt|;
name|tvf
operator|.
name|close
argument_list|()
expr_stmt|;
name|tvd
operator|.
name|close
argument_list|()
expr_stmt|;
name|tvx
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|fieldsWriter
operator|!=
literal|null
condition|)
block|{
assert|assert
name|docStoreSegment
operator|!=
literal|null
assert|;
name|fieldsWriter
operator|.
name|close
argument_list|()
expr_stmt|;
name|fieldsWriter
operator|=
literal|null
expr_stmt|;
block|}
name|String
name|s
init|=
name|docStoreSegment
decl_stmt|;
name|docStoreSegment
operator|=
literal|null
expr_stmt|;
name|docStoreOffset
operator|=
literal|0
expr_stmt|;
name|numDocsInStore
operator|=
literal|0
expr_stmt|;
return|return
name|s
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
DECL|field|files
name|List
name|files
init|=
literal|null
decl_stmt|;
comment|// Cached list of files we've created
DECL|field|abortedFiles
specifier|private
name|List
name|abortedFiles
init|=
literal|null
decl_stmt|;
comment|// List of files that were written before last abort()
DECL|method|abortedFiles
name|List
name|abortedFiles
parameter_list|()
block|{
return|return
name|abortedFiles
return|;
block|}
comment|/* Returns list of files in use by this instance,    * including any flushed segments. */
DECL|method|files
specifier|synchronized
name|List
name|files
parameter_list|()
block|{
if|if
condition|(
name|files
operator|!=
literal|null
condition|)
return|return
name|files
return|;
name|files
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
comment|// Stored fields:
if|if
condition|(
name|fieldsWriter
operator|!=
literal|null
condition|)
block|{
assert|assert
name|docStoreSegment
operator|!=
literal|null
assert|;
name|files
operator|.
name|add
argument_list|(
name|docStoreSegment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|FIELDS_EXTENSION
argument_list|)
expr_stmt|;
name|files
operator|.
name|add
argument_list|(
name|docStoreSegment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|FIELDS_INDEX_EXTENSION
argument_list|)
expr_stmt|;
block|}
comment|// Vectors:
if|if
condition|(
name|tvx
operator|!=
literal|null
condition|)
block|{
assert|assert
name|docStoreSegment
operator|!=
literal|null
assert|;
name|files
operator|.
name|add
argument_list|(
name|docStoreSegment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|VECTORS_INDEX_EXTENSION
argument_list|)
expr_stmt|;
name|files
operator|.
name|add
argument_list|(
name|docStoreSegment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|VECTORS_FIELDS_EXTENSION
argument_list|)
expr_stmt|;
name|files
operator|.
name|add
argument_list|(
name|docStoreSegment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|VECTORS_DOCUMENTS_EXTENSION
argument_list|)
expr_stmt|;
block|}
return|return
name|files
return|;
block|}
DECL|method|setAborting
specifier|synchronized
name|void
name|setAborting
parameter_list|()
block|{
name|abortCount
operator|++
expr_stmt|;
block|}
comment|/** Called if we hit an exception when adding docs,    *  flushing, etc.  This resets our state, discarding any    *  docs added since last flush.  If ae is non-null, it    *  contains the root cause exception (which we re-throw    *  after we are done aborting). */
DECL|method|abort
specifier|synchronized
name|void
name|abort
parameter_list|(
name|AbortException
name|ae
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Anywhere that throws an AbortException must first
comment|// mark aborting to make sure while the exception is
comment|// unwinding the un-synchronized stack, no thread grabs
comment|// the corrupt ThreadState that hit the aborting
comment|// exception:
assert|assert
name|ae
operator|==
literal|null
operator|||
name|abortCount
operator|>
literal|0
assert|;
try|try
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"docWriter: now abort"
argument_list|)
expr_stmt|;
comment|// Forcefully remove waiting ThreadStates from line
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numWaiting
condition|;
name|i
operator|++
control|)
name|waitingThreadStates
index|[
name|i
index|]
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
name|numWaiting
operator|=
literal|0
expr_stmt|;
comment|// Wait for all other threads to finish with DocumentsWriter:
name|pauseAllThreads
argument_list|()
expr_stmt|;
assert|assert
literal|0
operator|==
name|numWaiting
assert|;
try|try
block|{
name|deletesInRAM
operator|.
name|clear
argument_list|()
expr_stmt|;
try|try
block|{
name|abortedFiles
operator|=
name|files
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|abortedFiles
operator|=
literal|null
expr_stmt|;
block|}
name|docStoreSegment
operator|=
literal|null
expr_stmt|;
name|numDocsInStore
operator|=
literal|0
expr_stmt|;
name|docStoreOffset
operator|=
literal|0
expr_stmt|;
name|files
operator|=
literal|null
expr_stmt|;
comment|// Clear vectors& fields from ThreadStates
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|DocumentsWriterThreadState
name|state
init|=
name|threadStates
index|[
name|i
index|]
decl_stmt|;
name|state
operator|.
name|tvfLocal
operator|.
name|reset
argument_list|()
expr_stmt|;
name|state
operator|.
name|fdtLocal
operator|.
name|reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|localFieldsWriter
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|state
operator|.
name|localFieldsWriter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{             }
name|state
operator|.
name|localFieldsWriter
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// Reset vectors writer
if|if
condition|(
name|tvx
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|tvx
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{           }
name|tvx
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|tvd
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|tvd
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{           }
name|tvd
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|tvf
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|tvf
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{           }
name|tvf
operator|=
literal|null
expr_stmt|;
block|}
comment|// Reset fields writer
if|if
condition|(
name|fieldsWriter
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|fieldsWriter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{           }
name|fieldsWriter
operator|=
literal|null
expr_stmt|;
block|}
comment|// Discard pending norms:
specifier|final
name|int
name|numField
init|=
name|fieldInfos
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numField
condition|;
name|i
operator|++
control|)
block|{
name|FieldInfo
name|fi
init|=
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|isIndexed
operator|&&
operator|!
name|fi
operator|.
name|omitNorms
condition|)
block|{
name|BufferedNorms
name|n
init|=
name|norms
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|null
condition|)
try|try
block|{
name|n
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{               }
block|}
block|}
comment|// Reset all postings data
name|resetPostingsData
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|resumeAllThreads
argument_list|()
expr_stmt|;
block|}
comment|// If we have a root cause exception, re-throw it now:
if|if
condition|(
name|ae
operator|!=
literal|null
condition|)
block|{
name|Throwable
name|t
init|=
name|ae
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|IOException
condition|)
throw|throw
operator|(
name|IOException
operator|)
name|t
throw|;
elseif|else
if|if
condition|(
name|t
operator|instanceof
name|RuntimeException
condition|)
throw|throw
operator|(
name|RuntimeException
operator|)
name|t
throw|;
elseif|else
if|if
condition|(
name|t
operator|instanceof
name|Error
condition|)
throw|throw
operator|(
name|Error
operator|)
name|t
throw|;
else|else
comment|// Should not get here
assert|assert
literal|false
operator|:
literal|"unknown exception: "
operator|+
name|t
assert|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|ae
operator|!=
literal|null
condition|)
name|abortCount
operator|--
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Reset after a flush */
DECL|method|resetPostingsData
specifier|private
name|void
name|resetPostingsData
parameter_list|()
throws|throws
name|IOException
block|{
comment|// All ThreadStates should be idle when we are called
assert|assert
name|allThreadsIdle
argument_list|()
assert|;
name|threadBindings
operator|.
name|clear
argument_list|()
expr_stmt|;
name|segment
operator|=
literal|null
expr_stmt|;
name|numDocsInRAM
operator|=
literal|0
expr_stmt|;
name|nextDocID
operator|=
literal|0
expr_stmt|;
name|nextWriteDocID
operator|=
literal|0
expr_stmt|;
name|files
operator|=
literal|null
expr_stmt|;
name|balanceRAM
argument_list|()
expr_stmt|;
name|bufferIsFull
operator|=
literal|false
expr_stmt|;
name|flushPending
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|threadStates
index|[
name|i
index|]
operator|.
name|numThreads
operator|=
literal|0
expr_stmt|;
name|threadStates
index|[
name|i
index|]
operator|.
name|resetPostings
argument_list|()
expr_stmt|;
block|}
name|numBytesUsed
operator|=
literal|0
expr_stmt|;
block|}
comment|// Returns true if an abort is in progress
DECL|method|pauseAllThreads
specifier|synchronized
name|boolean
name|pauseAllThreads
parameter_list|()
block|{
name|pauseThreads
operator|++
expr_stmt|;
while|while
condition|(
operator|!
name|allThreadsIdle
argument_list|()
condition|)
block|{
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|abortCount
operator|>
literal|0
return|;
block|}
DECL|method|resumeAllThreads
specifier|synchronized
name|void
name|resumeAllThreads
parameter_list|()
block|{
name|pauseThreads
operator|--
expr_stmt|;
assert|assert
name|pauseThreads
operator|>=
literal|0
assert|;
if|if
condition|(
literal|0
operator|==
name|pauseThreads
condition|)
name|notifyAll
argument_list|()
expr_stmt|;
block|}
DECL|method|allThreadsIdle
specifier|private
specifier|synchronized
name|boolean
name|allThreadsIdle
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|threadStates
index|[
name|i
index|]
operator|.
name|isIdle
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
comment|/** Flush all pending docs to a new segment */
DECL|method|flush
specifier|synchronized
name|int
name|flush
parameter_list|(
name|boolean
name|closeDocStore
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|allThreadsIdle
argument_list|()
assert|;
if|if
condition|(
name|segment
operator|==
literal|null
condition|)
comment|// In case we are asked to flush an empty segment
name|segment
operator|=
name|writer
operator|.
name|newSegmentName
argument_list|()
expr_stmt|;
name|newFiles
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
name|docStoreOffset
operator|=
name|numDocsInStore
expr_stmt|;
name|int
name|docCount
decl_stmt|;
assert|assert
name|numDocsInRAM
operator|>
literal|0
assert|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"\nflush postings as segment "
operator|+
name|segment
operator|+
literal|" numDocs="
operator|+
name|numDocsInRAM
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|closeDocStore
condition|)
block|{
assert|assert
name|docStoreSegment
operator|!=
literal|null
assert|;
assert|assert
name|docStoreSegment
operator|.
name|equals
argument_list|(
name|segment
argument_list|)
assert|;
name|newFiles
operator|.
name|addAll
argument_list|(
name|files
argument_list|()
argument_list|)
expr_stmt|;
name|closeDocStore
argument_list|()
expr_stmt|;
block|}
name|fieldInfos
operator|.
name|write
argument_list|(
name|directory
argument_list|,
name|segment
operator|+
literal|".fnm"
argument_list|)
expr_stmt|;
name|docCount
operator|=
name|numDocsInRAM
expr_stmt|;
name|newFiles
operator|.
name|addAll
argument_list|(
name|writeSegment
argument_list|()
argument_list|)
expr_stmt|;
name|flushedDocCount
operator|+=
name|docCount
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
name|abort
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|docCount
return|;
block|}
comment|/** Build compound file for the segment we just flushed */
DECL|method|createCompoundFile
name|void
name|createCompoundFile
parameter_list|(
name|String
name|segment
parameter_list|)
throws|throws
name|IOException
block|{
name|CompoundFileWriter
name|cfsWriter
init|=
operator|new
name|CompoundFileWriter
argument_list|(
name|directory
argument_list|,
name|segment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|COMPOUND_FILE_EXTENSION
argument_list|)
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|newFiles
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|cfsWriter
operator|.
name|addFile
argument_list|(
operator|(
name|String
operator|)
name|newFiles
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// Perform the merge
name|cfsWriter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Set flushPending if it is not already set and returns    *  whether it was set. This is used by IndexWriter to *    *  trigger a single flush even when multiple threads are    *  * trying to do so. */
DECL|method|setFlushPending
specifier|synchronized
name|boolean
name|setFlushPending
parameter_list|()
block|{
if|if
condition|(
name|flushPending
condition|)
return|return
literal|false
return|;
else|else
block|{
name|flushPending
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
DECL|method|clearFlushPending
specifier|synchronized
name|void
name|clearFlushPending
parameter_list|()
block|{
name|flushPending
operator|=
literal|false
expr_stmt|;
block|}
DECL|field|defaultNorm
specifier|private
specifier|static
specifier|final
name|byte
name|defaultNorm
init|=
name|Similarity
operator|.
name|encodeNorm
argument_list|(
literal|1.0f
argument_list|)
decl_stmt|;
comment|/** Write norms in the "true" segment format.  This is    *  called only during commit, to create the .nrm file. */
DECL|method|writeNorms
name|void
name|writeNorms
parameter_list|(
name|String
name|segmentName
parameter_list|,
name|int
name|totalNumDoc
parameter_list|)
throws|throws
name|IOException
block|{
name|IndexOutput
name|normsOut
init|=
name|directory
operator|.
name|createOutput
argument_list|(
name|segmentName
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|NORMS_EXTENSION
argument_list|)
decl_stmt|;
try|try
block|{
name|normsOut
operator|.
name|writeBytes
argument_list|(
name|SegmentMerger
operator|.
name|NORMS_HEADER
argument_list|,
literal|0
argument_list|,
name|SegmentMerger
operator|.
name|NORMS_HEADER
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|int
name|numField
init|=
name|fieldInfos
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|fieldIdx
init|=
literal|0
init|;
name|fieldIdx
operator|<
name|numField
condition|;
name|fieldIdx
operator|++
control|)
block|{
name|FieldInfo
name|fi
init|=
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|fieldIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|isIndexed
operator|&&
operator|!
name|fi
operator|.
name|omitNorms
condition|)
block|{
name|BufferedNorms
name|n
init|=
name|norms
index|[
name|fieldIdx
index|]
decl_stmt|;
specifier|final
name|long
name|v
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|null
condition|)
name|v
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|v
operator|=
name|n
operator|.
name|out
operator|.
name|getFilePointer
argument_list|()
expr_stmt|;
name|n
operator|.
name|out
operator|.
name|writeTo
argument_list|(
name|normsOut
argument_list|)
expr_stmt|;
name|n
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|<
name|totalNumDoc
condition|)
name|fillBytes
argument_list|(
name|normsOut
argument_list|,
name|defaultNorm
argument_list|,
call|(
name|int
call|)
argument_list|(
name|totalNumDoc
operator|-
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|normsOut
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|skipListWriter
specifier|private
name|DefaultSkipListWriter
name|skipListWriter
init|=
literal|null
decl_stmt|;
DECL|field|currentFieldStorePayloads
specifier|private
name|boolean
name|currentFieldStorePayloads
decl_stmt|;
comment|/** Creates a segment from all Postings in the Postings    *  hashes across all ThreadStates& FieldDatas. */
DECL|method|writeSegment
specifier|private
name|List
name|writeSegment
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|allThreadsIdle
argument_list|()
assert|;
assert|assert
name|nextDocID
operator|==
name|numDocsInRAM
assert|;
specifier|final
name|String
name|segmentName
decl_stmt|;
name|segmentName
operator|=
name|segment
expr_stmt|;
name|TermInfosWriter
name|termsOut
init|=
operator|new
name|TermInfosWriter
argument_list|(
name|directory
argument_list|,
name|segmentName
argument_list|,
name|fieldInfos
argument_list|,
name|writer
operator|.
name|getTermIndexInterval
argument_list|()
argument_list|)
decl_stmt|;
name|IndexOutput
name|freqOut
init|=
name|directory
operator|.
name|createOutput
argument_list|(
name|segmentName
operator|+
literal|".frq"
argument_list|)
decl_stmt|;
name|IndexOutput
name|proxOut
init|=
name|directory
operator|.
name|createOutput
argument_list|(
name|segmentName
operator|+
literal|".prx"
argument_list|)
decl_stmt|;
comment|// Gather all FieldData's that have postings, across all
comment|// ThreadStates
name|ArrayList
name|allFields
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
assert|assert
name|allThreadsIdle
argument_list|()
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|DocumentsWriterThreadState
name|state
init|=
name|threadStates
index|[
name|i
index|]
decl_stmt|;
name|state
operator|.
name|trimFields
argument_list|()
expr_stmt|;
specifier|final
name|int
name|numFields
init|=
name|state
operator|.
name|numAllFieldData
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numFields
condition|;
name|j
operator|++
control|)
block|{
name|DocumentsWriterFieldData
name|fp
init|=
name|state
operator|.
name|allFieldDataArray
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|fp
operator|.
name|numPostings
operator|>
literal|0
condition|)
name|allFields
operator|.
name|add
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Sort by field name
name|Collections
operator|.
name|sort
argument_list|(
name|allFields
argument_list|)
expr_stmt|;
specifier|final
name|int
name|numAllFields
init|=
name|allFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|skipListWriter
operator|=
operator|new
name|DefaultSkipListWriter
argument_list|(
name|termsOut
operator|.
name|skipInterval
argument_list|,
name|termsOut
operator|.
name|maxSkipLevels
argument_list|,
name|numDocsInRAM
argument_list|,
name|freqOut
argument_list|,
name|proxOut
argument_list|)
expr_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|numAllFields
condition|)
block|{
specifier|final
name|String
name|fieldName
init|=
operator|(
operator|(
name|DocumentsWriterFieldData
operator|)
name|allFields
operator|.
name|get
argument_list|(
name|start
argument_list|)
operator|)
operator|.
name|fieldInfo
operator|.
name|name
decl_stmt|;
name|int
name|end
init|=
name|start
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|end
operator|<
name|numAllFields
operator|&&
operator|(
operator|(
name|DocumentsWriterFieldData
operator|)
name|allFields
operator|.
name|get
argument_list|(
name|end
argument_list|)
operator|)
operator|.
name|fieldInfo
operator|.
name|name
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
name|end
operator|++
expr_stmt|;
name|DocumentsWriterFieldData
index|[]
name|fields
init|=
operator|new
name|DocumentsWriterFieldData
index|[
name|end
operator|-
name|start
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
name|fields
index|[
name|i
operator|-
name|start
index|]
operator|=
operator|(
name|DocumentsWriterFieldData
operator|)
name|allFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// If this field has postings then add them to the
comment|// segment
name|appendPostings
argument_list|(
name|fields
argument_list|,
name|termsOut
argument_list|,
name|freqOut
argument_list|,
name|proxOut
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|fields
index|[
name|i
index|]
operator|.
name|resetPostingArrays
argument_list|()
expr_stmt|;
name|start
operator|=
name|end
expr_stmt|;
block|}
name|freqOut
operator|.
name|close
argument_list|()
expr_stmt|;
name|proxOut
operator|.
name|close
argument_list|()
expr_stmt|;
name|termsOut
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Record all files we have flushed
name|List
name|flushedFiles
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|flushedFiles
operator|.
name|add
argument_list|(
name|segmentFileName
argument_list|(
name|IndexFileNames
operator|.
name|FIELD_INFOS_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|flushedFiles
operator|.
name|add
argument_list|(
name|segmentFileName
argument_list|(
name|IndexFileNames
operator|.
name|FREQ_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|flushedFiles
operator|.
name|add
argument_list|(
name|segmentFileName
argument_list|(
name|IndexFileNames
operator|.
name|PROX_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|flushedFiles
operator|.
name|add
argument_list|(
name|segmentFileName
argument_list|(
name|IndexFileNames
operator|.
name|TERMS_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|flushedFiles
operator|.
name|add
argument_list|(
name|segmentFileName
argument_list|(
name|IndexFileNames
operator|.
name|TERMS_INDEX_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasNorms
condition|)
block|{
name|writeNorms
argument_list|(
name|segmentName
argument_list|,
name|numDocsInRAM
argument_list|)
expr_stmt|;
name|flushedFiles
operator|.
name|add
argument_list|(
name|segmentFileName
argument_list|(
name|IndexFileNames
operator|.
name|NORMS_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
specifier|final
name|long
name|newSegmentSize
init|=
name|segmentSize
argument_list|(
name|segmentName
argument_list|)
decl_stmt|;
name|String
name|message
init|=
literal|"  oldRAMSize="
operator|+
name|numBytesUsed
operator|+
literal|" newFlushedSize="
operator|+
name|newSegmentSize
operator|+
literal|" docs/MB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|numDocsInRAM
operator|/
operator|(
name|newSegmentSize
operator|/
literal|1024.
operator|/
literal|1024.
operator|)
argument_list|)
operator|+
literal|" new/old="
operator|+
name|nf
operator|.
name|format
argument_list|(
literal|100.0
operator|*
name|newSegmentSize
operator|/
name|numBytesUsed
argument_list|)
operator|+
literal|"%"
decl_stmt|;
name|infoStream
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|resetPostingsData
argument_list|()
expr_stmt|;
comment|// Maybe downsize postingsFreeList array
if|if
condition|(
name|postingsFreeList
operator|.
name|length
operator|>
literal|1.5
operator|*
name|postingsFreeCount
condition|)
block|{
name|int
name|newSize
init|=
name|postingsFreeList
operator|.
name|length
decl_stmt|;
while|while
condition|(
name|newSize
operator|>
literal|1.25
operator|*
name|postingsFreeCount
condition|)
block|{
name|newSize
operator|=
call|(
name|int
call|)
argument_list|(
name|newSize
operator|*
literal|0.8
argument_list|)
expr_stmt|;
block|}
name|Posting
index|[]
name|newArray
init|=
operator|new
name|Posting
index|[
name|newSize
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|postingsFreeList
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|postingsFreeCount
argument_list|)
expr_stmt|;
name|postingsFreeList
operator|=
name|newArray
expr_stmt|;
block|}
return|return
name|flushedFiles
return|;
block|}
DECL|method|pushDeletes
specifier|synchronized
name|void
name|pushDeletes
parameter_list|()
block|{
name|deletesFlushed
operator|.
name|update
argument_list|(
name|deletesInRAM
argument_list|)
expr_stmt|;
block|}
comment|/** Returns the name of the file with this extension, on    *  the current segment we are working on. */
DECL|method|segmentFileName
specifier|private
name|String
name|segmentFileName
parameter_list|(
name|String
name|extension
parameter_list|)
block|{
return|return
name|segment
operator|+
literal|"."
operator|+
name|extension
return|;
block|}
DECL|method|compareText
specifier|static
name|int
name|compareText
parameter_list|(
specifier|final
name|char
index|[]
name|text1
parameter_list|,
name|int
name|pos1
parameter_list|,
specifier|final
name|char
index|[]
name|text2
parameter_list|,
name|int
name|pos2
parameter_list|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|char
name|c1
init|=
name|text1
index|[
name|pos1
operator|++
index|]
decl_stmt|;
specifier|final
name|char
name|c2
init|=
name|text2
index|[
name|pos2
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|c1
operator|<
name|c2
condition|)
if|if
condition|(
literal|0xffff
operator|==
name|c2
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|c2
operator|<
name|c1
condition|)
if|if
condition|(
literal|0xffff
operator|==
name|c1
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
elseif|else
if|if
condition|(
literal|0xffff
operator|==
name|c1
condition|)
return|return
literal|0
return|;
block|}
block|}
DECL|field|termInfo
specifier|private
specifier|final
name|TermInfo
name|termInfo
init|=
operator|new
name|TermInfo
argument_list|()
decl_stmt|;
comment|// minimize consing
comment|/* Walk through all unique text tokens (Posting    * instances) found in this field and serialize them    * into a single RAM segment. */
DECL|method|appendPostings
name|void
name|appendPostings
parameter_list|(
name|DocumentsWriterFieldData
index|[]
name|fields
parameter_list|,
name|TermInfosWriter
name|termsOut
parameter_list|,
name|IndexOutput
name|freqOut
parameter_list|,
name|IndexOutput
name|proxOut
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
specifier|final
name|int
name|fieldNumber
init|=
name|fields
index|[
literal|0
index|]
operator|.
name|fieldInfo
operator|.
name|number
decl_stmt|;
name|int
name|numFields
init|=
name|fields
operator|.
name|length
decl_stmt|;
specifier|final
name|DocumentsWriterFieldMergeState
index|[]
name|mergeStates
init|=
operator|new
name|DocumentsWriterFieldMergeState
index|[
name|numFields
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
name|i
operator|++
control|)
block|{
name|DocumentsWriterFieldMergeState
name|fms
init|=
name|mergeStates
index|[
name|i
index|]
operator|=
operator|new
name|DocumentsWriterFieldMergeState
argument_list|()
decl_stmt|;
name|fms
operator|.
name|field
operator|=
name|fields
index|[
name|i
index|]
expr_stmt|;
name|fms
operator|.
name|postings
operator|=
name|fms
operator|.
name|field
operator|.
name|sortPostings
argument_list|()
expr_stmt|;
assert|assert
name|fms
operator|.
name|field
operator|.
name|fieldInfo
operator|==
name|fields
index|[
literal|0
index|]
operator|.
name|fieldInfo
assert|;
comment|// Should always be true
name|boolean
name|result
init|=
name|fms
operator|.
name|nextTerm
argument_list|()
decl_stmt|;
assert|assert
name|result
assert|;
block|}
specifier|final
name|int
name|skipInterval
init|=
name|termsOut
operator|.
name|skipInterval
decl_stmt|;
name|currentFieldStorePayloads
operator|=
name|fields
index|[
literal|0
index|]
operator|.
name|fieldInfo
operator|.
name|storePayloads
expr_stmt|;
name|DocumentsWriterFieldMergeState
index|[]
name|termStates
init|=
operator|new
name|DocumentsWriterFieldMergeState
index|[
name|numFields
index|]
decl_stmt|;
while|while
condition|(
name|numFields
operator|>
literal|0
condition|)
block|{
comment|// Get the next term to merge
name|termStates
index|[
literal|0
index|]
operator|=
name|mergeStates
index|[
literal|0
index|]
expr_stmt|;
name|int
name|numToMerge
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numFields
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|char
index|[]
name|text
init|=
name|mergeStates
index|[
name|i
index|]
operator|.
name|text
decl_stmt|;
specifier|final
name|int
name|textOffset
init|=
name|mergeStates
index|[
name|i
index|]
operator|.
name|textOffset
decl_stmt|;
specifier|final
name|int
name|cmp
init|=
name|compareText
argument_list|(
name|text
argument_list|,
name|textOffset
argument_list|,
name|termStates
index|[
literal|0
index|]
operator|.
name|text
argument_list|,
name|termStates
index|[
literal|0
index|]
operator|.
name|textOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|termStates
index|[
literal|0
index|]
operator|=
name|mergeStates
index|[
name|i
index|]
expr_stmt|;
name|numToMerge
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
name|termStates
index|[
name|numToMerge
operator|++
index|]
operator|=
name|mergeStates
index|[
name|i
index|]
expr_stmt|;
block|}
name|int
name|df
init|=
literal|0
decl_stmt|;
name|int
name|lastPayloadLength
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|lastDoc
init|=
literal|0
decl_stmt|;
specifier|final
name|char
index|[]
name|text
init|=
name|termStates
index|[
literal|0
index|]
operator|.
name|text
decl_stmt|;
specifier|final
name|int
name|start
init|=
name|termStates
index|[
literal|0
index|]
operator|.
name|textOffset
decl_stmt|;
name|int
name|pos
init|=
name|start
decl_stmt|;
while|while
condition|(
name|text
index|[
name|pos
index|]
operator|!=
literal|0xffff
condition|)
name|pos
operator|++
expr_stmt|;
name|long
name|freqPointer
init|=
name|freqOut
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
name|long
name|proxPointer
init|=
name|proxOut
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
name|skipListWriter
operator|.
name|resetSkip
argument_list|()
expr_stmt|;
comment|// Now termStates has numToMerge FieldMergeStates
comment|// which all share the same term.  Now we must
comment|// interleave the docID streams.
while|while
condition|(
name|numToMerge
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|++
name|df
operator|%
name|skipInterval
operator|)
operator|==
literal|0
condition|)
block|{
name|skipListWriter
operator|.
name|setSkipData
argument_list|(
name|lastDoc
argument_list|,
name|currentFieldStorePayloads
argument_list|,
name|lastPayloadLength
argument_list|)
expr_stmt|;
name|skipListWriter
operator|.
name|bufferSkip
argument_list|(
name|df
argument_list|)
expr_stmt|;
block|}
name|DocumentsWriterFieldMergeState
name|minState
init|=
name|termStates
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numToMerge
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|termStates
index|[
name|i
index|]
operator|.
name|docID
operator|<
name|minState
operator|.
name|docID
condition|)
name|minState
operator|=
name|termStates
index|[
name|i
index|]
expr_stmt|;
specifier|final
name|int
name|doc
init|=
name|minState
operator|.
name|docID
decl_stmt|;
specifier|final
name|int
name|termDocFreq
init|=
name|minState
operator|.
name|termFreq
decl_stmt|;
assert|assert
name|doc
operator|<
name|numDocsInRAM
assert|;
assert|assert
name|doc
operator|>
name|lastDoc
operator|||
name|df
operator|==
literal|1
assert|;
specifier|final
name|int
name|newDocCode
init|=
operator|(
name|doc
operator|-
name|lastDoc
operator|)
operator|<<
literal|1
decl_stmt|;
name|lastDoc
operator|=
name|doc
expr_stmt|;
specifier|final
name|ByteSliceReader
name|prox
init|=
name|minState
operator|.
name|prox
decl_stmt|;
comment|// Carefully copy over the prox + payload info,
comment|// changing the format to match Lucene's segment
comment|// format.
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|termDocFreq
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|int
name|code
init|=
name|prox
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentFieldStorePayloads
condition|)
block|{
specifier|final
name|int
name|payloadLength
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// This position has a payload
name|payloadLength
operator|=
name|prox
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
name|payloadLength
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|payloadLength
operator|!=
name|lastPayloadLength
condition|)
block|{
name|proxOut
operator|.
name|writeVInt
argument_list|(
name|code
operator||
literal|1
argument_list|)
expr_stmt|;
name|proxOut
operator|.
name|writeVInt
argument_list|(
name|payloadLength
argument_list|)
expr_stmt|;
name|lastPayloadLength
operator|=
name|payloadLength
expr_stmt|;
block|}
else|else
name|proxOut
operator|.
name|writeVInt
argument_list|(
name|code
operator|&
operator|(
operator|~
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|payloadLength
operator|>
literal|0
condition|)
name|copyBytes
argument_list|(
name|prox
argument_list|,
name|proxOut
argument_list|,
name|payloadLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
literal|0
operator|==
operator|(
name|code
operator|&
literal|1
operator|)
assert|;
name|proxOut
operator|.
name|writeVInt
argument_list|(
name|code
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|1
operator|==
name|termDocFreq
condition|)
block|{
name|freqOut
operator|.
name|writeVInt
argument_list|(
name|newDocCode
operator||
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|freqOut
operator|.
name|writeVInt
argument_list|(
name|newDocCode
argument_list|)
expr_stmt|;
name|freqOut
operator|.
name|writeVInt
argument_list|(
name|termDocFreq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|minState
operator|.
name|nextDoc
argument_list|()
condition|)
block|{
comment|// Remove from termStates
name|int
name|upto
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numToMerge
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|termStates
index|[
name|i
index|]
operator|!=
name|minState
condition|)
name|termStates
index|[
name|upto
operator|++
index|]
operator|=
name|termStates
index|[
name|i
index|]
expr_stmt|;
name|numToMerge
operator|--
expr_stmt|;
assert|assert
name|upto
operator|==
name|numToMerge
assert|;
comment|// Advance this state to the next term
if|if
condition|(
operator|!
name|minState
operator|.
name|nextTerm
argument_list|()
condition|)
block|{
comment|// OK, no more terms, so remove from mergeStates
comment|// as well
name|upto
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mergeStates
index|[
name|i
index|]
operator|!=
name|minState
condition|)
name|mergeStates
index|[
name|upto
operator|++
index|]
operator|=
name|mergeStates
index|[
name|i
index|]
expr_stmt|;
name|numFields
operator|--
expr_stmt|;
assert|assert
name|upto
operator|==
name|numFields
assert|;
block|}
block|}
block|}
assert|assert
name|df
operator|>
literal|0
assert|;
comment|// Done merging this term
name|long
name|skipPointer
init|=
name|skipListWriter
operator|.
name|writeSkip
argument_list|(
name|freqOut
argument_list|)
decl_stmt|;
comment|// Write term
name|termInfo
operator|.
name|set
argument_list|(
name|df
argument_list|,
name|freqPointer
argument_list|,
name|proxPointer
argument_list|,
call|(
name|int
call|)
argument_list|(
name|skipPointer
operator|-
name|freqPointer
argument_list|)
argument_list|)
expr_stmt|;
name|termsOut
operator|.
name|add
argument_list|(
name|fieldNumber
argument_list|,
name|text
argument_list|,
name|start
argument_list|,
name|pos
operator|-
name|start
argument_list|,
name|termInfo
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|close
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
name|closed
operator|=
literal|true
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|/** Returns a free (idle) ThreadState that may be used for    * indexing this one document.  This call also pauses if a    * flush is pending.  If delTerm is non-null then we    * buffer this deleted term after the thread state has    * been acquired. */
DECL|method|getThreadState
specifier|synchronized
name|DocumentsWriterThreadState
name|getThreadState
parameter_list|(
name|Document
name|doc
parameter_list|,
name|Term
name|delTerm
parameter_list|)
throws|throws
name|IOException
block|{
comment|// First, find a thread state.  If this thread already
comment|// has affinity to a specific ThreadState, use that one
comment|// again.
name|DocumentsWriterThreadState
name|state
init|=
operator|(
name|DocumentsWriterThreadState
operator|)
name|threadBindings
operator|.
name|get
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
comment|// First time this thread has called us since last flush
name|DocumentsWriterThreadState
name|minThreadState
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|DocumentsWriterThreadState
name|ts
init|=
name|threadStates
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|minThreadState
operator|==
literal|null
operator|||
name|ts
operator|.
name|numThreads
operator|<
name|minThreadState
operator|.
name|numThreads
condition|)
name|minThreadState
operator|=
name|ts
expr_stmt|;
block|}
if|if
condition|(
name|minThreadState
operator|!=
literal|null
operator|&&
operator|(
name|minThreadState
operator|.
name|numThreads
operator|==
literal|0
operator|||
name|threadStates
operator|.
name|length
operator|==
name|MAX_THREAD_STATE
operator|)
condition|)
block|{
name|state
operator|=
name|minThreadState
expr_stmt|;
name|state
operator|.
name|numThreads
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// Just create a new "private" thread state
name|DocumentsWriterThreadState
index|[]
name|newArray
init|=
operator|new
name|DocumentsWriterThreadState
index|[
literal|1
operator|+
name|threadStates
operator|.
name|length
index|]
decl_stmt|;
if|if
condition|(
name|threadStates
operator|.
name|length
operator|>
literal|0
condition|)
name|System
operator|.
name|arraycopy
argument_list|(
name|threadStates
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|threadStates
operator|.
name|length
argument_list|)
expr_stmt|;
name|state
operator|=
name|newArray
index|[
name|threadStates
operator|.
name|length
index|]
operator|=
operator|new
name|DocumentsWriterThreadState
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|threadStates
operator|=
name|newArray
expr_stmt|;
block|}
name|threadBindings
operator|.
name|put
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
comment|// Next, wait until my thread state is idle (in case
comment|// it's shared with other threads) and for threads to
comment|// not be paused nor a flush pending:
name|waitReady
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|segment
operator|==
literal|null
condition|)
name|segment
operator|=
name|writer
operator|.
name|newSegmentName
argument_list|()
expr_stmt|;
name|state
operator|.
name|isIdle
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|state
operator|.
name|init
argument_list|(
name|doc
argument_list|,
name|nextDocID
argument_list|)
expr_stmt|;
if|if
condition|(
name|delTerm
operator|!=
literal|null
condition|)
block|{
name|addDeleteTerm
argument_list|(
name|delTerm
argument_list|,
name|state
operator|.
name|docID
argument_list|)
expr_stmt|;
name|state
operator|.
name|doFlushAfter
operator|=
name|timeToFlushDeletes
argument_list|()
expr_stmt|;
block|}
comment|// Only increment nextDocID& numDocsInRAM on successful init
name|nextDocID
operator|++
expr_stmt|;
name|numDocsInRAM
operator|++
expr_stmt|;
comment|// We must at this point commit to flushing to ensure we
comment|// always get N docs when we flush by doc count, even if
comment|//> 1 thread is adding documents:
if|if
condition|(
operator|!
name|flushPending
operator|&&
name|maxBufferedDocs
operator|!=
name|IndexWriter
operator|.
name|DISABLE_AUTO_FLUSH
operator|&&
name|numDocsInRAM
operator|>=
name|maxBufferedDocs
condition|)
block|{
name|flushPending
operator|=
literal|true
expr_stmt|;
name|state
operator|.
name|doFlushAfter
operator|=
literal|true
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// Forcefully idle this ThreadState:
name|state
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|doFlushAfter
condition|)
block|{
name|state
operator|.
name|doFlushAfter
operator|=
literal|false
expr_stmt|;
name|flushPending
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|AbortException
name|ae
parameter_list|)
block|{
name|abort
argument_list|(
name|ae
argument_list|)
expr_stmt|;
block|}
return|return
name|state
return|;
block|}
comment|/** Returns true if the caller (IndexWriter) should now    * flush. */
DECL|method|addDocument
name|boolean
name|addDocument
parameter_list|(
name|Document
name|doc
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|updateDocument
argument_list|(
name|doc
argument_list|,
name|analyzer
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|updateDocument
name|boolean
name|updateDocument
parameter_list|(
name|Term
name|t
parameter_list|,
name|Document
name|doc
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|updateDocument
argument_list|(
name|doc
argument_list|,
name|analyzer
argument_list|,
name|t
argument_list|)
return|;
block|}
DECL|method|updateDocument
name|boolean
name|updateDocument
parameter_list|(
name|Document
name|doc
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|,
name|Term
name|delTerm
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
comment|// This call is synchronized but fast
specifier|final
name|DocumentsWriterThreadState
name|state
init|=
name|getThreadState
argument_list|(
name|doc
argument_list|,
name|delTerm
argument_list|)
decl_stmt|;
try|try
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
try|try
block|{
comment|// This call is not synchronized and does all the work
name|state
operator|.
name|processDocument
argument_list|(
name|analyzer
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// This call is synchronized but fast
name|finishDocument
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// If this thread state had decided to flush, we
comment|// must clear it so another thread can flush
if|if
condition|(
name|state
operator|.
name|doFlushAfter
condition|)
block|{
name|state
operator|.
name|doFlushAfter
operator|=
literal|false
expr_stmt|;
name|flushPending
operator|=
literal|false
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|// Immediately mark this document as deleted
comment|// since likely it was partially added.  This
comment|// keeps indexing as "all or none" (atomic) when
comment|// adding a document:
name|addDeleteDocID
argument_list|(
name|state
operator|.
name|docID
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|AbortException
name|ae
parameter_list|)
block|{
name|abort
argument_list|(
name|ae
argument_list|)
expr_stmt|;
block|}
return|return
name|state
operator|.
name|doFlushAfter
operator|||
name|timeToFlushDeletes
argument_list|()
return|;
block|}
comment|// for testing
DECL|method|getNumBufferedDeleteTerms
specifier|synchronized
name|int
name|getNumBufferedDeleteTerms
parameter_list|()
block|{
return|return
name|deletesInRAM
operator|.
name|numTerms
return|;
block|}
comment|// for testing
DECL|method|getBufferedDeleteTerms
specifier|synchronized
name|HashMap
name|getBufferedDeleteTerms
parameter_list|()
block|{
return|return
name|deletesInRAM
operator|.
name|terms
return|;
block|}
comment|/** Called whenever a merge has completed and the merged segments had deletions */
DECL|method|remapDeletes
specifier|synchronized
name|void
name|remapDeletes
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|int
index|[]
index|[]
name|docMaps
parameter_list|,
name|int
index|[]
name|delCounts
parameter_list|,
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|,
name|int
name|mergeDocCount
parameter_list|)
block|{
if|if
condition|(
name|docMaps
operator|==
literal|null
condition|)
comment|// The merged segments had no deletes so docIDs did not change and we have nothing to do
return|return;
name|MergeDocIDRemapper
name|mapper
init|=
operator|new
name|MergeDocIDRemapper
argument_list|(
name|infos
argument_list|,
name|docMaps
argument_list|,
name|delCounts
argument_list|,
name|merge
argument_list|,
name|mergeDocCount
argument_list|)
decl_stmt|;
name|deletesInRAM
operator|.
name|remap
argument_list|(
name|mapper
argument_list|,
name|infos
argument_list|,
name|docMaps
argument_list|,
name|delCounts
argument_list|,
name|merge
argument_list|,
name|mergeDocCount
argument_list|)
expr_stmt|;
name|deletesFlushed
operator|.
name|remap
argument_list|(
name|mapper
argument_list|,
name|infos
argument_list|,
name|docMaps
argument_list|,
name|delCounts
argument_list|,
name|merge
argument_list|,
name|mergeDocCount
argument_list|)
expr_stmt|;
name|flushedDocCount
operator|-=
name|mapper
operator|.
name|docShift
expr_stmt|;
block|}
DECL|method|waitReady
specifier|synchronized
specifier|private
name|void
name|waitReady
parameter_list|(
name|DocumentsWriterThreadState
name|state
parameter_list|)
block|{
while|while
condition|(
operator|!
name|closed
operator|&&
operator|(
operator|(
name|state
operator|!=
literal|null
operator|&&
operator|!
name|state
operator|.
name|isIdle
operator|)
operator|||
name|pauseThreads
operator|!=
literal|0
operator|||
name|flushPending
operator|||
name|abortCount
operator|>
literal|0
operator|)
condition|)
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|closed
condition|)
throw|throw
operator|new
name|AlreadyClosedException
argument_list|(
literal|"this IndexWriter is closed"
argument_list|)
throw|;
block|}
DECL|method|bufferDeleteTerms
specifier|synchronized
name|boolean
name|bufferDeleteTerms
parameter_list|(
name|Term
index|[]
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
name|waitReady
argument_list|(
literal|null
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|terms
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|addDeleteTerm
argument_list|(
name|terms
index|[
name|i
index|]
argument_list|,
name|numDocsInRAM
argument_list|)
expr_stmt|;
return|return
name|timeToFlushDeletes
argument_list|()
return|;
block|}
DECL|method|bufferDeleteTerm
specifier|synchronized
name|boolean
name|bufferDeleteTerm
parameter_list|(
name|Term
name|term
parameter_list|)
throws|throws
name|IOException
block|{
name|waitReady
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|addDeleteTerm
argument_list|(
name|term
argument_list|,
name|numDocsInRAM
argument_list|)
expr_stmt|;
return|return
name|timeToFlushDeletes
argument_list|()
return|;
block|}
DECL|method|bufferDeleteQueries
specifier|synchronized
name|boolean
name|bufferDeleteQueries
parameter_list|(
name|Query
index|[]
name|queries
parameter_list|)
throws|throws
name|IOException
block|{
name|waitReady
argument_list|(
literal|null
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queries
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|addDeleteQuery
argument_list|(
name|queries
index|[
name|i
index|]
argument_list|,
name|numDocsInRAM
argument_list|)
expr_stmt|;
return|return
name|timeToFlushDeletes
argument_list|()
return|;
block|}
DECL|method|bufferDeleteQuery
specifier|synchronized
name|boolean
name|bufferDeleteQuery
parameter_list|(
name|Query
name|query
parameter_list|)
throws|throws
name|IOException
block|{
name|waitReady
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|addDeleteQuery
argument_list|(
name|query
argument_list|,
name|numDocsInRAM
argument_list|)
expr_stmt|;
return|return
name|timeToFlushDeletes
argument_list|()
return|;
block|}
DECL|method|deletesFull
specifier|synchronized
name|boolean
name|deletesFull
parameter_list|()
block|{
return|return
name|maxBufferedDeleteTerms
operator|!=
name|IndexWriter
operator|.
name|DISABLE_AUTO_FLUSH
operator|&&
operator|(
operator|(
name|deletesInRAM
operator|.
name|numTerms
operator|+
name|deletesInRAM
operator|.
name|queries
operator|.
name|size
argument_list|()
operator|+
name|deletesInRAM
operator|.
name|docIDs
operator|.
name|size
argument_list|()
operator|)
operator|>=
name|maxBufferedDeleteTerms
operator|)
return|;
block|}
DECL|method|timeToFlushDeletes
specifier|synchronized
specifier|private
name|boolean
name|timeToFlushDeletes
parameter_list|()
block|{
return|return
operator|(
name|bufferIsFull
operator|||
name|deletesFull
argument_list|()
operator|)
operator|&&
name|setFlushPending
argument_list|()
return|;
block|}
DECL|method|setMaxBufferedDeleteTerms
name|void
name|setMaxBufferedDeleteTerms
parameter_list|(
name|int
name|maxBufferedDeleteTerms
parameter_list|)
block|{
name|this
operator|.
name|maxBufferedDeleteTerms
operator|=
name|maxBufferedDeleteTerms
expr_stmt|;
block|}
DECL|method|getMaxBufferedDeleteTerms
name|int
name|getMaxBufferedDeleteTerms
parameter_list|()
block|{
return|return
name|maxBufferedDeleteTerms
return|;
block|}
DECL|method|hasDeletes
specifier|synchronized
name|boolean
name|hasDeletes
parameter_list|()
block|{
return|return
name|deletesFlushed
operator|.
name|any
argument_list|()
return|;
block|}
DECL|method|applyDeletes
specifier|synchronized
name|boolean
name|applyDeletes
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|hasDeletes
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"apply "
operator|+
name|deletesFlushed
operator|.
name|numTerms
operator|+
literal|" buffered deleted terms and "
operator|+
name|deletesFlushed
operator|.
name|docIDs
operator|.
name|size
argument_list|()
operator|+
literal|" deleted docIDs and "
operator|+
name|deletesFlushed
operator|.
name|queries
operator|.
name|size
argument_list|()
operator|+
literal|" deleted queries on "
operator|+
operator|+
name|infos
operator|.
name|size
argument_list|()
operator|+
literal|" segments."
argument_list|)
expr_stmt|;
specifier|final
name|int
name|infosEnd
init|=
name|infos
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|docStart
init|=
literal|0
decl_stmt|;
name|boolean
name|any
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|infosEnd
condition|;
name|i
operator|++
control|)
block|{
name|IndexReader
name|reader
init|=
name|SegmentReader
operator|.
name|get
argument_list|(
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|any
operator||=
name|applyDeletes
argument_list|(
name|reader
argument_list|,
name|docStart
argument_list|)
expr_stmt|;
name|docStart
operator|+=
name|reader
operator|.
name|maxDoc
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|success
condition|)
name|reader
operator|.
name|doCommit
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|reader
operator|.
name|doClose
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
name|deletesFlushed
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|any
return|;
block|}
comment|// Apply buffered delete terms, queries and docIDs to the
comment|// provided reader
DECL|method|applyDeletes
specifier|private
specifier|final
specifier|synchronized
name|boolean
name|applyDeletes
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|int
name|docIDStart
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
specifier|final
name|int
name|docEnd
init|=
name|docIDStart
operator|+
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
name|boolean
name|any
init|=
literal|false
decl_stmt|;
comment|// Delete by term
name|Iterator
name|iter
init|=
name|deletesFlushed
operator|.
name|terms
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
name|entry
init|=
operator|(
name|Entry
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|Term
name|term
init|=
operator|(
name|Term
operator|)
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|TermDocs
name|docs
init|=
name|reader
operator|.
name|termDocs
argument_list|(
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
name|docs
operator|!=
literal|null
condition|)
block|{
name|int
name|limit
init|=
operator|(
operator|(
name|BufferedDeletes
operator|.
name|Num
operator|)
name|entry
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|getNum
argument_list|()
decl_stmt|;
try|try
block|{
while|while
condition|(
name|docs
operator|.
name|next
argument_list|()
condition|)
block|{
name|int
name|docID
init|=
name|docs
operator|.
name|doc
argument_list|()
decl_stmt|;
if|if
condition|(
name|docIDStart
operator|+
name|docID
operator|>=
name|limit
condition|)
break|break;
name|reader
operator|.
name|deleteDocument
argument_list|(
name|docID
argument_list|)
expr_stmt|;
name|any
operator|=
literal|true
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|docs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// Delete by docID
name|iter
operator|=
name|deletesFlushed
operator|.
name|docIDs
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|docID
init|=
operator|(
operator|(
name|Integer
operator|)
name|iter
operator|.
name|next
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|docID
operator|>=
name|docIDStart
operator|&&
name|docID
operator|<
name|docEnd
condition|)
block|{
name|reader
operator|.
name|deleteDocument
argument_list|(
name|docID
operator|-
name|docIDStart
argument_list|)
expr_stmt|;
name|any
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Delete by query
name|IndexSearcher
name|searcher
init|=
operator|new
name|IndexSearcher
argument_list|(
name|reader
argument_list|)
decl_stmt|;
name|iter
operator|=
name|deletesFlushed
operator|.
name|queries
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
name|entry
init|=
operator|(
name|Entry
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|Query
name|query
init|=
operator|(
name|Query
operator|)
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|int
name|limit
init|=
operator|(
operator|(
name|Integer
operator|)
name|entry
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|Weight
name|weight
init|=
name|query
operator|.
name|weight
argument_list|(
name|searcher
argument_list|)
decl_stmt|;
name|Scorer
name|scorer
init|=
name|weight
operator|.
name|scorer
argument_list|(
name|reader
argument_list|)
decl_stmt|;
while|while
condition|(
name|scorer
operator|.
name|next
argument_list|()
condition|)
block|{
specifier|final
name|int
name|docID
init|=
name|scorer
operator|.
name|doc
argument_list|()
decl_stmt|;
if|if
condition|(
name|docIDStart
operator|+
name|docID
operator|>=
name|limit
condition|)
break|break;
name|reader
operator|.
name|deleteDocument
argument_list|(
name|docID
argument_list|)
expr_stmt|;
name|any
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|searcher
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|any
return|;
block|}
comment|// Buffer a term in bufferedDeleteTerms, which records the
comment|// current number of documents buffered in ram so that the
comment|// delete term will be applied to those documents as well
comment|// as the disk segments.
DECL|method|addDeleteTerm
specifier|synchronized
specifier|private
name|void
name|addDeleteTerm
parameter_list|(
name|Term
name|term
parameter_list|,
name|int
name|docCount
parameter_list|)
block|{
name|BufferedDeletes
operator|.
name|Num
name|num
init|=
operator|(
name|BufferedDeletes
operator|.
name|Num
operator|)
name|deletesInRAM
operator|.
name|terms
operator|.
name|get
argument_list|(
name|term
argument_list|)
decl_stmt|;
specifier|final
name|int
name|docIDUpto
init|=
name|flushedDocCount
operator|+
name|docCount
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|null
condition|)
name|deletesInRAM
operator|.
name|terms
operator|.
name|put
argument_list|(
name|term
argument_list|,
operator|new
name|BufferedDeletes
operator|.
name|Num
argument_list|(
name|docIDUpto
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|num
operator|.
name|setNum
argument_list|(
name|docIDUpto
argument_list|)
expr_stmt|;
name|deletesInRAM
operator|.
name|numTerms
operator|++
expr_stmt|;
block|}
comment|// Buffer a specific docID for deletion.  Currently only
comment|// used when we hit a exception when adding a document
DECL|method|addDeleteDocID
specifier|synchronized
specifier|private
name|void
name|addDeleteDocID
parameter_list|(
name|int
name|docID
parameter_list|)
block|{
name|deletesInRAM
operator|.
name|docIDs
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
name|flushedDocCount
operator|+
name|docID
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|addDeleteQuery
specifier|synchronized
specifier|private
name|void
name|addDeleteQuery
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|docID
parameter_list|)
block|{
name|deletesInRAM
operator|.
name|queries
operator|.
name|put
argument_list|(
name|query
argument_list|,
operator|new
name|Integer
argument_list|(
name|flushedDocCount
operator|+
name|docID
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Does the synchronized work to finish/flush the    * inverted document. */
DECL|method|finishDocument
specifier|private
specifier|synchronized
name|void
name|finishDocument
parameter_list|(
name|DocumentsWriterThreadState
name|state
parameter_list|)
throws|throws
name|IOException
throws|,
name|AbortException
block|{
if|if
condition|(
name|abortCount
operator|>
literal|0
condition|)
block|{
comment|// Forcefully idle this threadstate -- its state will
comment|// be reset by abort()
name|state
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ramBufferSize
operator|!=
name|IndexWriter
operator|.
name|DISABLE_AUTO_FLUSH
operator|&&
name|numBytesUsed
operator|>=
name|ramBufferSize
condition|)
name|balanceRAM
argument_list|()
expr_stmt|;
comment|// Now write the indexed document to the real files.
if|if
condition|(
name|nextWriteDocID
operator|==
name|state
operator|.
name|docID
condition|)
block|{
comment|// It's my turn, so write everything now:
name|nextWriteDocID
operator|++
expr_stmt|;
name|state
operator|.
name|writeDocument
argument_list|()
expr_stmt|;
name|state
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
comment|// If any states were waiting on me, sweep through and
comment|// flush those that are enabled by my write.
if|if
condition|(
name|numWaiting
operator|>
literal|0
condition|)
block|{
name|boolean
name|any
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|any
condition|)
block|{
name|any
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numWaiting
condition|;
control|)
block|{
specifier|final
name|DocumentsWriterThreadState
name|s
init|=
name|waitingThreadStates
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|docID
operator|==
name|nextWriteDocID
condition|)
block|{
name|s
operator|.
name|writeDocument
argument_list|()
expr_stmt|;
name|s
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
name|nextWriteDocID
operator|++
expr_stmt|;
name|any
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|numWaiting
operator|>
name|i
operator|+
literal|1
condition|)
comment|// Swap in the last waiting state to fill in
comment|// the hole we just created.  It's important
comment|// to do this as-we-go and not at the end of
comment|// the loop, because if we hit an aborting
comment|// exception in one of the s.writeDocument
comment|// calls (above), it leaves this array in an
comment|// inconsistent state:
name|waitingThreadStates
index|[
name|i
index|]
operator|=
name|waitingThreadStates
index|[
name|numWaiting
operator|-
literal|1
index|]
expr_stmt|;
name|numWaiting
operator|--
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|!
name|s
operator|.
name|isIdle
assert|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
comment|// Another thread got a docID before me, but, it
comment|// hasn't finished its processing.  So add myself to
comment|// the line but don't hold up this thread.
name|waitingThreadStates
index|[
name|numWaiting
operator|++
index|]
operator|=
name|state
expr_stmt|;
block|}
block|}
DECL|method|getRAMUsed
name|long
name|getRAMUsed
parameter_list|()
block|{
return|return
name|numBytesUsed
return|;
block|}
DECL|field|numBytesAlloc
name|long
name|numBytesAlloc
decl_stmt|;
DECL|field|numBytesUsed
name|long
name|numBytesUsed
decl_stmt|;
DECL|field|nf
name|NumberFormat
name|nf
init|=
name|NumberFormat
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|/* Used only when writing norms to fill in default norm    * value into the holes in docID stream for those docs    * that didn't have this field. */
DECL|method|fillBytes
specifier|static
name|void
name|fillBytes
parameter_list|(
name|IndexOutput
name|out
parameter_list|,
name|byte
name|b
parameter_list|,
name|int
name|numBytes
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numBytes
condition|;
name|i
operator|++
control|)
name|out
operator|.
name|writeByte
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
DECL|field|copyByteBuffer
specifier|final
name|byte
index|[]
name|copyByteBuffer
init|=
operator|new
name|byte
index|[
literal|4096
index|]
decl_stmt|;
comment|/** Copy numBytes from srcIn to destIn */
DECL|method|copyBytes
name|void
name|copyBytes
parameter_list|(
name|IndexInput
name|srcIn
parameter_list|,
name|IndexOutput
name|destIn
parameter_list|,
name|long
name|numBytes
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: we could do this more efficiently (save a copy)
comment|// because it's always from a ByteSliceReader ->
comment|// IndexOutput
while|while
condition|(
name|numBytes
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|chunk
decl_stmt|;
if|if
condition|(
name|numBytes
operator|>
literal|4096
condition|)
name|chunk
operator|=
literal|4096
expr_stmt|;
else|else
name|chunk
operator|=
operator|(
name|int
operator|)
name|numBytes
expr_stmt|;
name|srcIn
operator|.
name|readBytes
argument_list|(
name|copyByteBuffer
argument_list|,
literal|0
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|destIn
operator|.
name|writeBytes
argument_list|(
name|copyByteBuffer
argument_list|,
literal|0
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|numBytes
operator|-=
name|chunk
expr_stmt|;
block|}
block|}
comment|// Used only when infoStream != null
DECL|method|segmentSize
specifier|private
name|long
name|segmentSize
parameter_list|(
name|String
name|segmentName
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|infoStream
operator|!=
literal|null
assert|;
name|long
name|size
init|=
name|directory
operator|.
name|fileLength
argument_list|(
name|segmentName
operator|+
literal|".tii"
argument_list|)
operator|+
name|directory
operator|.
name|fileLength
argument_list|(
name|segmentName
operator|+
literal|".tis"
argument_list|)
operator|+
name|directory
operator|.
name|fileLength
argument_list|(
name|segmentName
operator|+
literal|".frq"
argument_list|)
operator|+
name|directory
operator|.
name|fileLength
argument_list|(
name|segmentName
operator|+
literal|".prx"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|normFileName
init|=
name|segmentName
operator|+
literal|".nrm"
decl_stmt|;
if|if
condition|(
name|directory
operator|.
name|fileExists
argument_list|(
name|normFileName
argument_list|)
condition|)
name|size
operator|+=
name|directory
operator|.
name|fileLength
argument_list|(
name|normFileName
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
DECL|field|POINTER_NUM_BYTE
specifier|final
specifier|private
specifier|static
name|int
name|POINTER_NUM_BYTE
init|=
literal|4
decl_stmt|;
DECL|field|INT_NUM_BYTE
specifier|final
specifier|private
specifier|static
name|int
name|INT_NUM_BYTE
init|=
literal|4
decl_stmt|;
DECL|field|CHAR_NUM_BYTE
specifier|final
specifier|private
specifier|static
name|int
name|CHAR_NUM_BYTE
init|=
literal|2
decl_stmt|;
comment|// Why + 5*POINTER_NUM_BYTE below?
comment|//   1: Posting has "vector" field which is a pointer
comment|//   2: Posting is referenced by postingsFreeList array
comment|//   3,4,5: Posting is referenced by postings hash, which
comment|//          targets 25-50% fill factor; approximate this
comment|//          as 3X # pointers
DECL|field|POSTING_NUM_BYTE
specifier|final
specifier|static
name|int
name|POSTING_NUM_BYTE
init|=
name|OBJECT_HEADER_BYTES
operator|+
literal|9
operator|*
name|INT_NUM_BYTE
operator|+
literal|5
operator|*
name|POINTER_NUM_BYTE
decl_stmt|;
comment|// Holds free pool of Posting instances
DECL|field|postingsFreeList
specifier|private
name|Posting
index|[]
name|postingsFreeList
decl_stmt|;
DECL|field|postingsFreeCount
specifier|private
name|int
name|postingsFreeCount
decl_stmt|;
DECL|field|postingsAllocCount
specifier|private
name|int
name|postingsAllocCount
decl_stmt|;
comment|/* Allocate more Postings from shared pool */
DECL|method|getPostings
specifier|synchronized
name|void
name|getPostings
parameter_list|(
name|Posting
index|[]
name|postings
parameter_list|)
block|{
name|numBytesUsed
operator|+=
name|postings
operator|.
name|length
operator|*
name|POSTING_NUM_BYTE
expr_stmt|;
specifier|final
name|int
name|numToCopy
decl_stmt|;
if|if
condition|(
name|postingsFreeCount
operator|<
name|postings
operator|.
name|length
condition|)
name|numToCopy
operator|=
name|postingsFreeCount
expr_stmt|;
else|else
name|numToCopy
operator|=
name|postings
operator|.
name|length
expr_stmt|;
specifier|final
name|int
name|start
init|=
name|postingsFreeCount
operator|-
name|numToCopy
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|postingsFreeList
argument_list|,
name|start
argument_list|,
name|postings
argument_list|,
literal|0
argument_list|,
name|numToCopy
argument_list|)
expr_stmt|;
name|postingsFreeCount
operator|-=
name|numToCopy
expr_stmt|;
comment|// Directly allocate the remainder if any
if|if
condition|(
name|numToCopy
operator|<
name|postings
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|extra
init|=
name|postings
operator|.
name|length
operator|-
name|numToCopy
decl_stmt|;
specifier|final
name|int
name|newPostingsAllocCount
init|=
name|postingsAllocCount
operator|+
name|extra
decl_stmt|;
if|if
condition|(
name|newPostingsAllocCount
operator|>
name|postingsFreeList
operator|.
name|length
condition|)
name|postingsFreeList
operator|=
operator|new
name|Posting
index|[
call|(
name|int
call|)
argument_list|(
literal|1.25
operator|*
name|newPostingsAllocCount
argument_list|)
index|]
expr_stmt|;
name|balanceRAM
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|numToCopy
init|;
name|i
operator|<
name|postings
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|postings
index|[
name|i
index|]
operator|=
operator|new
name|Posting
argument_list|()
expr_stmt|;
name|numBytesAlloc
operator|+=
name|POSTING_NUM_BYTE
expr_stmt|;
name|postingsAllocCount
operator|++
expr_stmt|;
block|}
block|}
assert|assert
name|numBytesUsed
operator|<=
name|numBytesAlloc
assert|;
block|}
DECL|method|recyclePostings
specifier|synchronized
name|void
name|recyclePostings
parameter_list|(
name|Posting
index|[]
name|postings
parameter_list|,
name|int
name|numPostings
parameter_list|)
block|{
comment|// Move all Postings from this ThreadState back to our
comment|// free list.  We pre-allocated this array while we were
comment|// creating Postings to make sure it's large enough
assert|assert
name|postingsFreeCount
operator|+
name|numPostings
operator|<=
name|postingsFreeList
operator|.
name|length
assert|;
name|System
operator|.
name|arraycopy
argument_list|(
name|postings
argument_list|,
literal|0
argument_list|,
name|postingsFreeList
argument_list|,
name|postingsFreeCount
argument_list|,
name|numPostings
argument_list|)
expr_stmt|;
name|postingsFreeCount
operator|+=
name|numPostings
expr_stmt|;
block|}
comment|/* Initial chunks size of the shared byte[] blocks used to      store postings data */
DECL|field|BYTE_BLOCK_SHIFT
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_SHIFT
init|=
literal|15
decl_stmt|;
DECL|field|BYTE_BLOCK_SIZE
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_SIZE
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|pow
argument_list|(
literal|2.0
argument_list|,
name|BYTE_BLOCK_SHIFT
argument_list|)
decl_stmt|;
DECL|field|BYTE_BLOCK_MASK
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_MASK
init|=
name|BYTE_BLOCK_SIZE
operator|-
literal|1
decl_stmt|;
DECL|field|BYTE_BLOCK_NOT_MASK
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_NOT_MASK
init|=
operator|~
name|BYTE_BLOCK_MASK
decl_stmt|;
DECL|field|freeByteBlocks
specifier|private
name|ArrayList
name|freeByteBlocks
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
comment|/* Allocate another byte[] from the shared pool */
DECL|method|getByteBlock
specifier|synchronized
name|byte
index|[]
name|getByteBlock
parameter_list|(
name|boolean
name|trackAllocations
parameter_list|)
block|{
specifier|final
name|int
name|size
init|=
name|freeByteBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|b
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|size
condition|)
block|{
name|numBytesAlloc
operator|+=
name|BYTE_BLOCK_SIZE
expr_stmt|;
name|balanceRAM
argument_list|()
expr_stmt|;
name|b
operator|=
operator|new
name|byte
index|[
name|BYTE_BLOCK_SIZE
index|]
expr_stmt|;
block|}
else|else
name|b
operator|=
operator|(
name|byte
index|[]
operator|)
name|freeByteBlocks
operator|.
name|remove
argument_list|(
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|trackAllocations
condition|)
name|numBytesUsed
operator|+=
name|BYTE_BLOCK_SIZE
expr_stmt|;
assert|assert
name|numBytesUsed
operator|<=
name|numBytesAlloc
assert|;
return|return
name|b
return|;
block|}
comment|/* Return a byte[] to the pool */
DECL|method|recycleByteBlocks
specifier|synchronized
name|void
name|recycleByteBlocks
parameter_list|(
name|byte
index|[]
index|[]
name|blocks
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
name|freeByteBlocks
operator|.
name|add
argument_list|(
name|blocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Initial chunk size of the shared char[] blocks used to      store term text */
DECL|field|CHAR_BLOCK_SHIFT
specifier|final
specifier|static
name|int
name|CHAR_BLOCK_SHIFT
init|=
literal|14
decl_stmt|;
DECL|field|CHAR_BLOCK_SIZE
specifier|final
specifier|static
name|int
name|CHAR_BLOCK_SIZE
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|pow
argument_list|(
literal|2.0
argument_list|,
name|CHAR_BLOCK_SHIFT
argument_list|)
decl_stmt|;
DECL|field|CHAR_BLOCK_MASK
specifier|final
specifier|static
name|int
name|CHAR_BLOCK_MASK
init|=
name|CHAR_BLOCK_SIZE
operator|-
literal|1
decl_stmt|;
DECL|field|MAX_TERM_LENGTH
specifier|final
specifier|static
name|int
name|MAX_TERM_LENGTH
init|=
name|CHAR_BLOCK_SIZE
operator|-
literal|1
decl_stmt|;
DECL|field|freeCharBlocks
specifier|private
name|ArrayList
name|freeCharBlocks
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
comment|/* Allocate another char[] from the shared pool */
DECL|method|getCharBlock
specifier|synchronized
name|char
index|[]
name|getCharBlock
parameter_list|()
block|{
specifier|final
name|int
name|size
init|=
name|freeCharBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|char
index|[]
name|c
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|size
condition|)
block|{
name|numBytesAlloc
operator|+=
name|CHAR_BLOCK_SIZE
operator|*
name|CHAR_NUM_BYTE
expr_stmt|;
name|balanceRAM
argument_list|()
expr_stmt|;
name|c
operator|=
operator|new
name|char
index|[
name|CHAR_BLOCK_SIZE
index|]
expr_stmt|;
block|}
else|else
name|c
operator|=
operator|(
name|char
index|[]
operator|)
name|freeCharBlocks
operator|.
name|remove
argument_list|(
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|numBytesUsed
operator|+=
name|CHAR_BLOCK_SIZE
operator|*
name|CHAR_NUM_BYTE
expr_stmt|;
assert|assert
name|numBytesUsed
operator|<=
name|numBytesAlloc
assert|;
return|return
name|c
return|;
block|}
comment|/* Return a char[] to the pool */
DECL|method|recycleCharBlocks
specifier|synchronized
name|void
name|recycleCharBlocks
parameter_list|(
name|char
index|[]
index|[]
name|blocks
parameter_list|,
name|int
name|numBlocks
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numBlocks
condition|;
name|i
operator|++
control|)
name|freeCharBlocks
operator|.
name|add
argument_list|(
name|blocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
DECL|method|toMB
name|String
name|toMB
parameter_list|(
name|long
name|v
parameter_list|)
block|{
return|return
name|nf
operator|.
name|format
argument_list|(
name|v
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
return|;
block|}
comment|/* We have three pools of RAM: Postings, byte blocks    * (holds freq/prox posting data) and char blocks (holds    * characters in the term).  Different docs require    * varying amount of storage from these three classes.    * For example, docs with many unique single-occurrence    * short terms will use up the Postings RAM and hardly any    * of the other two.  Whereas docs with very large terms    * will use alot of char blocks RAM and relatively less of    * the other two.  This method just frees allocations from    * the pools once we are over-budget, which balances the    * pools to match the current docs. */
DECL|method|balanceRAM
specifier|synchronized
name|void
name|balanceRAM
parameter_list|()
block|{
if|if
condition|(
name|ramBufferSize
operator|==
name|IndexWriter
operator|.
name|DISABLE_AUTO_FLUSH
operator|||
name|bufferIsFull
condition|)
return|return;
comment|// We free our allocations if we've allocated 5% over
comment|// our allowed RAM buffer
specifier|final
name|long
name|freeTrigger
init|=
call|(
name|long
call|)
argument_list|(
literal|1.05
operator|*
name|ramBufferSize
argument_list|)
decl_stmt|;
specifier|final
name|long
name|freeLevel
init|=
call|(
name|long
call|)
argument_list|(
literal|0.95
operator|*
name|ramBufferSize
argument_list|)
decl_stmt|;
comment|// We flush when we've used our target usage
specifier|final
name|long
name|flushTrigger
init|=
operator|(
name|long
operator|)
name|ramBufferSize
decl_stmt|;
if|if
condition|(
name|numBytesAlloc
operator|>
name|freeTrigger
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"  RAM: now balance allocations: usedMB="
operator|+
name|toMB
argument_list|(
name|numBytesUsed
argument_list|)
operator|+
literal|" vs trigger="
operator|+
name|toMB
argument_list|(
name|flushTrigger
argument_list|)
operator|+
literal|" allocMB="
operator|+
name|toMB
argument_list|(
name|numBytesAlloc
argument_list|)
operator|+
literal|" vs trigger="
operator|+
name|toMB
argument_list|(
name|freeTrigger
argument_list|)
operator|+
literal|" postingsFree="
operator|+
name|toMB
argument_list|(
name|postingsFreeCount
operator|*
name|POSTING_NUM_BYTE
argument_list|)
operator|+
literal|" byteBlockFree="
operator|+
name|toMB
argument_list|(
name|freeByteBlocks
operator|.
name|size
argument_list|()
operator|*
name|BYTE_BLOCK_SIZE
argument_list|)
operator|+
literal|" charBlockFree="
operator|+
name|toMB
argument_list|(
name|freeCharBlocks
operator|.
name|size
argument_list|()
operator|*
name|CHAR_BLOCK_SIZE
operator|*
name|CHAR_NUM_BYTE
argument_list|)
argument_list|)
expr_stmt|;
comment|// When we've crossed 100% of our target Postings
comment|// RAM usage, try to free up until we're back down
comment|// to 95%
specifier|final
name|long
name|startBytesAlloc
init|=
name|numBytesAlloc
decl_stmt|;
specifier|final
name|int
name|postingsFreeChunk
init|=
call|(
name|int
call|)
argument_list|(
name|BYTE_BLOCK_SIZE
operator|/
name|POSTING_NUM_BYTE
argument_list|)
decl_stmt|;
name|int
name|iter
init|=
literal|0
decl_stmt|;
comment|// We free equally from each pool in 64 KB
comment|// chunks until we are below our threshold
comment|// (freeLevel)
while|while
condition|(
name|numBytesAlloc
operator|>
name|freeLevel
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|freeByteBlocks
operator|.
name|size
argument_list|()
operator|&&
literal|0
operator|==
name|freeCharBlocks
operator|.
name|size
argument_list|()
operator|&&
literal|0
operator|==
name|postingsFreeCount
condition|)
block|{
comment|// Nothing else to free -- must flush now.
name|bufferIsFull
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"    nothing to free; now set bufferIsFull"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
literal|0
operator|==
name|iter
operator|%
literal|3
operator|)
operator|&&
name|freeByteBlocks
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|freeByteBlocks
operator|.
name|remove
argument_list|(
name|freeByteBlocks
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|numBytesAlloc
operator|-=
name|BYTE_BLOCK_SIZE
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|1
operator|==
name|iter
operator|%
literal|3
operator|)
operator|&&
name|freeCharBlocks
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|freeCharBlocks
operator|.
name|remove
argument_list|(
name|freeCharBlocks
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|numBytesAlloc
operator|-=
name|CHAR_BLOCK_SIZE
operator|*
name|CHAR_NUM_BYTE
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|2
operator|==
name|iter
operator|%
literal|3
operator|)
operator|&&
name|postingsFreeCount
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|numToFree
decl_stmt|;
if|if
condition|(
name|postingsFreeCount
operator|>=
name|postingsFreeChunk
condition|)
name|numToFree
operator|=
name|postingsFreeChunk
expr_stmt|;
else|else
name|numToFree
operator|=
name|postingsFreeCount
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|postingsFreeList
argument_list|,
name|postingsFreeCount
operator|-
name|numToFree
argument_list|,
name|postingsFreeCount
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|postingsFreeCount
operator|-=
name|numToFree
expr_stmt|;
name|postingsAllocCount
operator|-=
name|numToFree
expr_stmt|;
name|numBytesAlloc
operator|-=
name|numToFree
operator|*
name|POSTING_NUM_BYTE
expr_stmt|;
block|}
name|iter
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"    after free: freedMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
operator|(
name|startBytesAlloc
operator|-
name|numBytesAlloc
operator|)
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
operator|+
literal|" usedMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|numBytesUsed
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
operator|+
literal|" allocMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|numBytesAlloc
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If we have not crossed the 100% mark, but have
comment|// crossed the 95% mark of RAM we are actually
comment|// using, go ahead and flush.  This prevents
comment|// over-allocating and then freeing, with every
comment|// flush.
if|if
condition|(
name|numBytesUsed
operator|>
name|flushTrigger
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|infoStream
operator|.
name|println
argument_list|(
literal|"  RAM: now flush @ usedMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|numBytesUsed
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
operator|+
literal|" allocMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|numBytesAlloc
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
operator|+
literal|" triggerMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|flushTrigger
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
argument_list|)
expr_stmt|;
name|bufferIsFull
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
end_class
end_unit
