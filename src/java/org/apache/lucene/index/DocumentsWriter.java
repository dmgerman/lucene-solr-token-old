begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|QueryWeight
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Scorer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Constants
import|;
end_import
begin_comment
comment|/**  * This class accepts multiple added documents and directly  * writes a single segment file.  It does this more  * efficiently than creating a single segment per document  * (with DocumentWriter) and doing standard merges on those  * segments.  *  * Each added document is passed to the {@link DocConsumer},  * which in turn processes the document and interacts with  * other consumers in the indexing chain.  Certain  * consumers, like {@link StoredFieldsWriter} and {@link  * TermVectorsTermsWriter}, digest a document and  * immediately write bytes to the "doc store" files (ie,  * they do not consume RAM per document, except while they  * are processing the document).  *  * Other consumers, eg {@link FreqProxTermsWriter} and  * {@link NormsWriter}, buffer bytes in RAM and flush only  * when a new segment is produced.   * Once we have used our allowed RAM buffer, or the number  * of added docs is large enough (in the case we are  * flushing by doc count instead of RAM usage), we create a  * real segment and flush it to the Directory.  *  * Threads:  *  * Multiple threads are allowed into addDocument at once.  * There is an initial synchronized call to getThreadState  * which allocates a ThreadState for this thread.  The same  * thread will get the same ThreadState over time (thread  * affinity) so that if there are consistent patterns (for  * example each thread is indexing a different content  * source) then we make better use of RAM.  Then  * processDocument is called on that ThreadState without  * synchronization (most of the "heavy lifting" is in this  * call).  Finally the synchronized "finishDocument" is  * called to flush changes to the directory.  *  * When flush is called by IndexWriter, or, we flush  * internally when autoCommit=false, we forcefully idle all  * threads and flush only once they are all idle.  This  * means you can call flush with a given thread even while  * other threads are actively adding/deleting documents.  *  *  * Exceptions:  *  * Because this class directly updates in-memory posting  * lists, and flushes stored fields and term vectors  * directly to files in the directory, there are certain  * limited times when an exception can corrupt this state.  * For example, a disk full while flushing stored fields  * leaves this file in a corrupt state.  Or, an OOM  * exception while appending to the in-memory posting lists  * can corrupt that posting list.  We call such exceptions  * "aborting exceptions".  In these cases we must call  * abort() to discard all docs added since the last flush.  *  * All other exceptions ("non-aborting exceptions") can  * still partially update the index structures.  These  * updates are consistent, but, they represent only a part  * of the document seen up until the exception was hit.  * When this happens, we immediately mark the document as  * deleted so that the document is always atomically ("all  * or none") added to the index.  */
end_comment
begin_class
DECL|class|DocumentsWriter
specifier|final
class|class
name|DocumentsWriter
block|{
DECL|field|writer
name|IndexWriter
name|writer
decl_stmt|;
DECL|field|directory
name|Directory
name|directory
decl_stmt|;
DECL|field|segment
name|String
name|segment
decl_stmt|;
comment|// Current segment we are working on
DECL|field|docStoreSegment
specifier|private
name|String
name|docStoreSegment
decl_stmt|;
comment|// Current doc-store segment we are writing
DECL|field|docStoreOffset
specifier|private
name|int
name|docStoreOffset
decl_stmt|;
comment|// Current starting doc-store offset of current segment
DECL|field|nextDocID
specifier|private
name|int
name|nextDocID
decl_stmt|;
comment|// Next docID to be added
DECL|field|numDocsInRAM
specifier|private
name|int
name|numDocsInRAM
decl_stmt|;
comment|// # docs buffered in RAM
DECL|field|numDocsInStore
name|int
name|numDocsInStore
decl_stmt|;
comment|// # docs written to doc stores
comment|// Max # ThreadState instances; if there are more threads
comment|// than this they share ThreadStates
DECL|field|MAX_THREAD_STATE
specifier|private
specifier|final
specifier|static
name|int
name|MAX_THREAD_STATE
init|=
literal|5
decl_stmt|;
DECL|field|threadStates
specifier|private
name|DocumentsWriterThreadState
index|[]
name|threadStates
init|=
operator|new
name|DocumentsWriterThreadState
index|[
literal|0
index|]
decl_stmt|;
DECL|field|threadBindings
specifier|private
specifier|final
name|HashMap
name|threadBindings
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
DECL|field|pauseThreads
specifier|private
name|int
name|pauseThreads
decl_stmt|;
comment|// Non-zero when we need all threads to
comment|// pause (eg to flush)
DECL|field|flushPending
name|boolean
name|flushPending
decl_stmt|;
comment|// True when a thread has decided to flush
DECL|field|bufferIsFull
name|boolean
name|bufferIsFull
decl_stmt|;
comment|// True when it's time to write segment
DECL|field|aborting
specifier|private
name|boolean
name|aborting
decl_stmt|;
comment|// True if an abort is pending
DECL|field|docFieldProcessor
specifier|private
name|DocFieldProcessor
name|docFieldProcessor
decl_stmt|;
DECL|field|infoStream
name|PrintStream
name|infoStream
decl_stmt|;
DECL|field|maxFieldLength
name|int
name|maxFieldLength
init|=
name|IndexWriter
operator|.
name|DEFAULT_MAX_FIELD_LENGTH
decl_stmt|;
DECL|field|similarity
name|Similarity
name|similarity
decl_stmt|;
DECL|field|newFiles
name|List
name|newFiles
decl_stmt|;
DECL|class|DocState
specifier|static
class|class
name|DocState
block|{
DECL|field|docWriter
name|DocumentsWriter
name|docWriter
decl_stmt|;
DECL|field|analyzer
name|Analyzer
name|analyzer
decl_stmt|;
DECL|field|maxFieldLength
name|int
name|maxFieldLength
decl_stmt|;
DECL|field|infoStream
name|PrintStream
name|infoStream
decl_stmt|;
DECL|field|similarity
name|Similarity
name|similarity
decl_stmt|;
DECL|field|docID
name|int
name|docID
decl_stmt|;
DECL|field|doc
name|Document
name|doc
decl_stmt|;
DECL|field|maxTermPrefix
name|String
name|maxTermPrefix
decl_stmt|;
comment|// deprecated
DECL|field|allowMinus1Position
name|boolean
name|allowMinus1Position
decl_stmt|;
comment|// Only called by asserts
DECL|method|testPoint
specifier|public
name|boolean
name|testPoint
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|docWriter
operator|.
name|writer
operator|.
name|testPoint
argument_list|(
name|name
argument_list|)
return|;
block|}
block|}
comment|/** Consumer returns this on each doc.  This holds any    *  state that must be flushed synchronized "in docID    *  order".  We gather these and flush them in order. */
DECL|class|DocWriter
specifier|abstract
specifier|static
class|class
name|DocWriter
block|{
DECL|field|next
name|DocWriter
name|next
decl_stmt|;
DECL|field|docID
name|int
name|docID
decl_stmt|;
DECL|method|finish
specifier|abstract
name|void
name|finish
parameter_list|()
throws|throws
name|IOException
function_decl|;
DECL|method|abort
specifier|abstract
name|void
name|abort
parameter_list|()
function_decl|;
DECL|method|sizeInBytes
specifier|abstract
name|long
name|sizeInBytes
parameter_list|()
function_decl|;
DECL|method|setNext
name|void
name|setNext
parameter_list|(
name|DocWriter
name|next
parameter_list|)
block|{
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/**    * The IndexingChain must define the {@link #getChain(DocumentsWriter)} method    * which returns the DocConsumer that the DocumentsWriter calls to process the    * documents.     */
DECL|class|IndexingChain
specifier|abstract
specifier|static
class|class
name|IndexingChain
block|{
DECL|method|getChain
specifier|abstract
name|DocConsumer
name|getChain
parameter_list|(
name|DocumentsWriter
name|documentsWriter
parameter_list|)
function_decl|;
block|}
DECL|field|DefaultIndexingChain
specifier|static
specifier|final
name|IndexingChain
name|DefaultIndexingChain
init|=
operator|new
name|IndexingChain
argument_list|()
block|{
name|DocConsumer
name|getChain
parameter_list|(
name|DocumentsWriter
name|documentsWriter
parameter_list|)
block|{
comment|/*       This is the current indexing chain:        DocConsumer / DocConsumerPerThread         --> code: DocFieldProcessor / DocFieldProcessorPerThread           --> DocFieldConsumer / DocFieldConsumerPerThread / DocFieldConsumerPerField             --> code: DocFieldConsumers / DocFieldConsumersPerThread / DocFieldConsumersPerField               --> code: DocInverter / DocInverterPerThread / DocInverterPerField                 --> InvertedDocConsumer / InvertedDocConsumerPerThread / InvertedDocConsumerPerField                   --> code: TermsHash / TermsHashPerThread / TermsHashPerField                     --> TermsHashConsumer / TermsHashConsumerPerThread / TermsHashConsumerPerField                       --> code: FreqProxTermsWriter / FreqProxTermsWriterPerThread / FreqProxTermsWriterPerField                       --> code: TermVectorsTermsWriter / TermVectorsTermsWriterPerThread / TermVectorsTermsWriterPerField                 --> InvertedDocEndConsumer / InvertedDocConsumerPerThread / InvertedDocConsumerPerField                   --> code: NormsWriter / NormsWriterPerThread / NormsWriterPerField               --> code: StoredFieldsWriter / StoredFieldsWriterPerThread / StoredFieldsWriterPerField     */
comment|// Build up indexing chain:
specifier|final
name|TermsHashConsumer
name|termVectorsWriter
init|=
operator|new
name|TermVectorsTermsWriter
argument_list|(
name|documentsWriter
argument_list|)
decl_stmt|;
specifier|final
name|TermsHashConsumer
name|freqProxWriter
init|=
operator|new
name|FreqProxTermsWriter
argument_list|()
decl_stmt|;
specifier|final
name|InvertedDocConsumer
name|termsHash
init|=
operator|new
name|TermsHash
argument_list|(
name|documentsWriter
argument_list|,
literal|true
argument_list|,
name|freqProxWriter
argument_list|,
operator|new
name|TermsHash
argument_list|(
name|documentsWriter
argument_list|,
literal|false
argument_list|,
name|termVectorsWriter
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|NormsWriter
name|normsWriter
init|=
operator|new
name|NormsWriter
argument_list|()
decl_stmt|;
specifier|final
name|DocInverter
name|docInverter
init|=
operator|new
name|DocInverter
argument_list|(
name|termsHash
argument_list|,
name|normsWriter
argument_list|)
decl_stmt|;
return|return
operator|new
name|DocFieldProcessor
argument_list|(
name|documentsWriter
argument_list|,
name|docInverter
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|consumer
specifier|final
name|DocConsumer
name|consumer
decl_stmt|;
comment|// Deletes done after the last flush; these are discarded
comment|// on abort
DECL|field|deletesInRAM
specifier|private
name|BufferedDeletes
name|deletesInRAM
init|=
operator|new
name|BufferedDeletes
argument_list|()
decl_stmt|;
comment|// Deletes done before the last flush; these are still
comment|// kept on abort
DECL|field|deletesFlushed
specifier|private
name|BufferedDeletes
name|deletesFlushed
init|=
operator|new
name|BufferedDeletes
argument_list|()
decl_stmt|;
comment|// The max number of delete terms that can be buffered before
comment|// they must be flushed to disk.
DECL|field|maxBufferedDeleteTerms
specifier|private
name|int
name|maxBufferedDeleteTerms
init|=
name|IndexWriter
operator|.
name|DEFAULT_MAX_BUFFERED_DELETE_TERMS
decl_stmt|;
comment|// How much RAM we can use before flushing.  This is 0 if
comment|// we are flushing by doc count instead.
DECL|field|ramBufferSize
specifier|private
name|long
name|ramBufferSize
init|=
call|(
name|long
call|)
argument_list|(
name|IndexWriter
operator|.
name|DEFAULT_RAM_BUFFER_SIZE_MB
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
decl_stmt|;
DECL|field|waitQueuePauseBytes
specifier|private
name|long
name|waitQueuePauseBytes
init|=
call|(
name|long
call|)
argument_list|(
name|ramBufferSize
operator|*
literal|0.1
argument_list|)
decl_stmt|;
DECL|field|waitQueueResumeBytes
specifier|private
name|long
name|waitQueueResumeBytes
init|=
call|(
name|long
call|)
argument_list|(
name|ramBufferSize
operator|*
literal|0.05
argument_list|)
decl_stmt|;
comment|// If we've allocated 5% over our RAM budget, we then
comment|// free down to 95%
DECL|field|freeTrigger
specifier|private
name|long
name|freeTrigger
init|=
call|(
name|long
call|)
argument_list|(
name|IndexWriter
operator|.
name|DEFAULT_RAM_BUFFER_SIZE_MB
operator|*
literal|1024
operator|*
literal|1024
operator|*
literal|1.05
argument_list|)
decl_stmt|;
DECL|field|freeLevel
specifier|private
name|long
name|freeLevel
init|=
call|(
name|long
call|)
argument_list|(
name|IndexWriter
operator|.
name|DEFAULT_RAM_BUFFER_SIZE_MB
operator|*
literal|1024
operator|*
literal|1024
operator|*
literal|0.95
argument_list|)
decl_stmt|;
comment|// Flush @ this number of docs.  If ramBufferSize is
comment|// non-zero we will flush by RAM usage instead.
DECL|field|maxBufferedDocs
specifier|private
name|int
name|maxBufferedDocs
init|=
name|IndexWriter
operator|.
name|DEFAULT_MAX_BUFFERED_DOCS
decl_stmt|;
DECL|field|flushedDocCount
specifier|private
name|int
name|flushedDocCount
decl_stmt|;
comment|// How many docs already flushed to index
DECL|method|updateFlushedDocCount
specifier|synchronized
name|void
name|updateFlushedDocCount
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|flushedDocCount
operator|+=
name|n
expr_stmt|;
block|}
DECL|method|getFlushedDocCount
specifier|synchronized
name|int
name|getFlushedDocCount
parameter_list|()
block|{
return|return
name|flushedDocCount
return|;
block|}
DECL|method|setFlushedDocCount
specifier|synchronized
name|void
name|setFlushedDocCount
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|flushedDocCount
operator|=
name|n
expr_stmt|;
block|}
DECL|field|closed
specifier|private
name|boolean
name|closed
decl_stmt|;
DECL|method|DocumentsWriter
name|DocumentsWriter
parameter_list|(
name|Directory
name|directory
parameter_list|,
name|IndexWriter
name|writer
parameter_list|,
name|IndexingChain
name|indexingChain
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
name|this
operator|.
name|writer
operator|=
name|writer
expr_stmt|;
name|this
operator|.
name|similarity
operator|=
name|writer
operator|.
name|getSimilarity
argument_list|()
expr_stmt|;
name|flushedDocCount
operator|=
name|writer
operator|.
name|maxDoc
argument_list|()
expr_stmt|;
name|consumer
operator|=
name|indexingChain
operator|.
name|getChain
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|consumer
operator|instanceof
name|DocFieldProcessor
condition|)
block|{
name|docFieldProcessor
operator|=
operator|(
name|DocFieldProcessor
operator|)
name|consumer
expr_stmt|;
block|}
block|}
comment|/** Returns true if any of the fields in the current    *  buffered docs have omitTermFreqAndPositions==false */
DECL|method|hasProx
name|boolean
name|hasProx
parameter_list|()
block|{
return|return
operator|(
name|docFieldProcessor
operator|!=
literal|null
operator|)
condition|?
name|docFieldProcessor
operator|.
name|fieldInfos
operator|.
name|hasProx
argument_list|()
else|:
literal|true
return|;
block|}
comment|/** If non-null, various details of indexing are printed    *  here. */
DECL|method|setInfoStream
specifier|synchronized
name|void
name|setInfoStream
parameter_list|(
name|PrintStream
name|infoStream
parameter_list|)
block|{
name|this
operator|.
name|infoStream
operator|=
name|infoStream
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|threadStates
index|[
name|i
index|]
operator|.
name|docState
operator|.
name|infoStream
operator|=
name|infoStream
expr_stmt|;
block|}
DECL|method|setMaxFieldLength
specifier|synchronized
name|void
name|setMaxFieldLength
parameter_list|(
name|int
name|maxFieldLength
parameter_list|)
block|{
name|this
operator|.
name|maxFieldLength
operator|=
name|maxFieldLength
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|threadStates
index|[
name|i
index|]
operator|.
name|docState
operator|.
name|maxFieldLength
operator|=
name|maxFieldLength
expr_stmt|;
block|}
DECL|method|setSimilarity
specifier|synchronized
name|void
name|setSimilarity
parameter_list|(
name|Similarity
name|similarity
parameter_list|)
block|{
name|this
operator|.
name|similarity
operator|=
name|similarity
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|threadStates
index|[
name|i
index|]
operator|.
name|docState
operator|.
name|similarity
operator|=
name|similarity
expr_stmt|;
block|}
DECL|method|setAllowMinus1Position
specifier|synchronized
name|void
name|setAllowMinus1Position
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|threadStates
index|[
name|i
index|]
operator|.
name|docState
operator|.
name|allowMinus1Position
operator|=
literal|true
expr_stmt|;
block|}
comment|/** Set how much RAM we can use before flushing. */
DECL|method|setRAMBufferSizeMB
specifier|synchronized
name|void
name|setRAMBufferSizeMB
parameter_list|(
name|double
name|mb
parameter_list|)
block|{
if|if
condition|(
name|mb
operator|==
name|IndexWriter
operator|.
name|DISABLE_AUTO_FLUSH
condition|)
block|{
name|ramBufferSize
operator|=
name|IndexWriter
operator|.
name|DISABLE_AUTO_FLUSH
expr_stmt|;
name|waitQueuePauseBytes
operator|=
literal|4
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
name|waitQueueResumeBytes
operator|=
literal|2
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
block|}
else|else
block|{
name|ramBufferSize
operator|=
call|(
name|long
call|)
argument_list|(
name|mb
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|waitQueuePauseBytes
operator|=
call|(
name|long
call|)
argument_list|(
name|ramBufferSize
operator|*
literal|0.1
argument_list|)
expr_stmt|;
name|waitQueueResumeBytes
operator|=
call|(
name|long
call|)
argument_list|(
name|ramBufferSize
operator|*
literal|0.05
argument_list|)
expr_stmt|;
name|freeTrigger
operator|=
call|(
name|long
call|)
argument_list|(
literal|1.05
operator|*
name|ramBufferSize
argument_list|)
expr_stmt|;
name|freeLevel
operator|=
call|(
name|long
call|)
argument_list|(
literal|0.95
operator|*
name|ramBufferSize
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getRAMBufferSizeMB
specifier|synchronized
name|double
name|getRAMBufferSizeMB
parameter_list|()
block|{
if|if
condition|(
name|ramBufferSize
operator|==
name|IndexWriter
operator|.
name|DISABLE_AUTO_FLUSH
condition|)
block|{
return|return
name|ramBufferSize
return|;
block|}
else|else
block|{
return|return
name|ramBufferSize
operator|/
literal|1024.
operator|/
literal|1024.
return|;
block|}
block|}
comment|/** Set max buffered docs, which means we will flush by    *  doc count instead of by RAM usage. */
DECL|method|setMaxBufferedDocs
name|void
name|setMaxBufferedDocs
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|maxBufferedDocs
operator|=
name|count
expr_stmt|;
block|}
DECL|method|getMaxBufferedDocs
name|int
name|getMaxBufferedDocs
parameter_list|()
block|{
return|return
name|maxBufferedDocs
return|;
block|}
comment|/** Get current segment name we are writing. */
DECL|method|getSegment
name|String
name|getSegment
parameter_list|()
block|{
return|return
name|segment
return|;
block|}
comment|/** Returns how many docs are currently buffered in RAM. */
DECL|method|getNumDocsInRAM
name|int
name|getNumDocsInRAM
parameter_list|()
block|{
return|return
name|numDocsInRAM
return|;
block|}
comment|/** Returns the current doc store segment we are writing    *  to.  This will be the same as segment when autoCommit    *  * is true. */
DECL|method|getDocStoreSegment
specifier|synchronized
name|String
name|getDocStoreSegment
parameter_list|()
block|{
return|return
name|docStoreSegment
return|;
block|}
comment|/** Returns the doc offset into the shared doc store for    *  the current buffered docs. */
DECL|method|getDocStoreOffset
name|int
name|getDocStoreOffset
parameter_list|()
block|{
return|return
name|docStoreOffset
return|;
block|}
comment|/** Closes the current open doc stores an returns the doc    *  store segment name.  This returns null if there are *    *  no buffered documents. */
DECL|method|closeDocStore
specifier|synchronized
name|String
name|closeDocStore
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|allThreadsIdle
argument_list|()
assert|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"closeDocStore: "
operator|+
name|openFiles
operator|.
name|size
argument_list|()
operator|+
literal|" files to flush to segment "
operator|+
name|docStoreSegment
operator|+
literal|" numDocs="
operator|+
name|numDocsInStore
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|initFlushState
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|closedFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
name|consumer
operator|.
name|closeDocStore
argument_list|(
name|flushState
argument_list|)
expr_stmt|;
assert|assert
literal|0
operator|==
name|openFiles
operator|.
name|size
argument_list|()
assert|;
name|String
name|s
init|=
name|docStoreSegment
decl_stmt|;
name|docStoreSegment
operator|=
literal|null
expr_stmt|;
name|docStoreOffset
operator|=
literal|0
expr_stmt|;
name|numDocsInStore
operator|=
literal|0
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|s
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|field|abortedFiles
specifier|private
name|Collection
name|abortedFiles
decl_stmt|;
comment|// List of files that were written before last abort()
DECL|field|flushState
specifier|private
name|SegmentWriteState
name|flushState
decl_stmt|;
DECL|method|abortedFiles
name|Collection
name|abortedFiles
parameter_list|()
block|{
return|return
name|abortedFiles
return|;
block|}
DECL|method|message
name|void
name|message
parameter_list|(
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|writer
operator|.
name|message
argument_list|(
literal|"DW: "
operator|+
name|message
argument_list|)
expr_stmt|;
block|}
DECL|field|openFiles
specifier|final
name|List
name|openFiles
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
DECL|field|closedFiles
specifier|final
name|List
name|closedFiles
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
comment|/* Returns Collection of files in use by this instance,    * including any flushed segments. */
DECL|method|openFiles
specifier|synchronized
name|List
name|openFiles
parameter_list|()
block|{
return|return
call|(
name|List
call|)
argument_list|(
operator|(
name|ArrayList
operator|)
name|openFiles
argument_list|)
operator|.
name|clone
argument_list|()
return|;
block|}
DECL|method|closedFiles
specifier|synchronized
name|List
name|closedFiles
parameter_list|()
block|{
return|return
call|(
name|List
call|)
argument_list|(
operator|(
name|ArrayList
operator|)
name|closedFiles
argument_list|)
operator|.
name|clone
argument_list|()
return|;
block|}
DECL|method|addOpenFile
specifier|synchronized
name|void
name|addOpenFile
parameter_list|(
name|String
name|name
parameter_list|)
block|{
assert|assert
operator|!
name|openFiles
operator|.
name|contains
argument_list|(
name|name
argument_list|)
assert|;
name|openFiles
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
DECL|method|removeOpenFile
specifier|synchronized
name|void
name|removeOpenFile
parameter_list|(
name|String
name|name
parameter_list|)
block|{
assert|assert
name|openFiles
operator|.
name|contains
argument_list|(
name|name
argument_list|)
assert|;
name|openFiles
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|closedFiles
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
DECL|method|setAborting
specifier|synchronized
name|void
name|setAborting
parameter_list|()
block|{
name|aborting
operator|=
literal|true
expr_stmt|;
block|}
comment|/** Called if we hit an exception at a bad time (when    *  updating the index files) and must discard all    *  currently buffered docs.  This resets our state,    *  discarding any docs added since last flush. */
DECL|method|abort
specifier|synchronized
name|void
name|abort
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"docWriter: now abort"
argument_list|)
expr_stmt|;
comment|// Forcefully remove waiting ThreadStates from line
name|waitQueue
operator|.
name|abort
argument_list|()
expr_stmt|;
comment|// Wait for all other threads to finish with
comment|// DocumentsWriter:
name|pauseAllThreads
argument_list|()
expr_stmt|;
try|try
block|{
assert|assert
literal|0
operator|==
name|waitQueue
operator|.
name|numWaiting
assert|;
name|waitQueue
operator|.
name|waitingBytes
operator|=
literal|0
expr_stmt|;
try|try
block|{
name|abortedFiles
operator|=
name|openFiles
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|abortedFiles
operator|=
literal|null
expr_stmt|;
block|}
name|deletesInRAM
operator|.
name|clear
argument_list|()
expr_stmt|;
name|openFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
try|try
block|{
name|threadStates
index|[
name|i
index|]
operator|.
name|consumer
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{           }
try|try
block|{
name|consumer
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{         }
name|docStoreSegment
operator|=
literal|null
expr_stmt|;
name|numDocsInStore
operator|=
literal|0
expr_stmt|;
name|docStoreOffset
operator|=
literal|0
expr_stmt|;
comment|// Reset all postings data
name|doAfterFlush
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|resumeAllThreads
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|aborting
operator|=
literal|false
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Reset after a flush */
DECL|method|doAfterFlush
specifier|private
name|void
name|doAfterFlush
parameter_list|()
throws|throws
name|IOException
block|{
comment|// All ThreadStates should be idle when we are called
assert|assert
name|allThreadsIdle
argument_list|()
assert|;
name|threadBindings
operator|.
name|clear
argument_list|()
expr_stmt|;
name|waitQueue
operator|.
name|reset
argument_list|()
expr_stmt|;
name|segment
operator|=
literal|null
expr_stmt|;
name|numDocsInRAM
operator|=
literal|0
expr_stmt|;
name|nextDocID
operator|=
literal|0
expr_stmt|;
name|bufferIsFull
operator|=
literal|false
expr_stmt|;
name|flushPending
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|threadStates
index|[
name|i
index|]
operator|.
name|doAfterFlush
argument_list|()
expr_stmt|;
name|numBytesUsed
operator|=
literal|0
expr_stmt|;
block|}
comment|// Returns true if an abort is in progress
DECL|method|pauseAllThreads
specifier|synchronized
name|boolean
name|pauseAllThreads
parameter_list|()
block|{
name|pauseThreads
operator|++
expr_stmt|;
while|while
condition|(
operator|!
name|allThreadsIdle
argument_list|()
condition|)
block|{
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// In 3.0 we will change this to throw
comment|// InterruptedException instead
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
return|return
name|aborting
return|;
block|}
DECL|method|resumeAllThreads
specifier|synchronized
name|void
name|resumeAllThreads
parameter_list|()
block|{
name|pauseThreads
operator|--
expr_stmt|;
assert|assert
name|pauseThreads
operator|>=
literal|0
assert|;
if|if
condition|(
literal|0
operator|==
name|pauseThreads
condition|)
name|notifyAll
argument_list|()
expr_stmt|;
block|}
DECL|method|allThreadsIdle
specifier|private
specifier|synchronized
name|boolean
name|allThreadsIdle
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|threadStates
index|[
name|i
index|]
operator|.
name|isIdle
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
DECL|method|initFlushState
specifier|synchronized
specifier|private
name|void
name|initFlushState
parameter_list|(
name|boolean
name|onlyDocStore
parameter_list|)
block|{
name|initSegmentName
argument_list|(
name|onlyDocStore
argument_list|)
expr_stmt|;
name|flushState
operator|=
operator|new
name|SegmentWriteState
argument_list|(
name|this
argument_list|,
name|directory
argument_list|,
name|segment
argument_list|,
name|docStoreSegment
argument_list|,
name|numDocsInRAM
argument_list|,
name|numDocsInStore
argument_list|,
name|writer
operator|.
name|getTermIndexInterval
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Flush all pending docs to a new segment */
DECL|method|flush
specifier|synchronized
name|int
name|flush
parameter_list|(
name|boolean
name|closeDocStore
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|allThreadsIdle
argument_list|()
assert|;
assert|assert
name|numDocsInRAM
operator|>
literal|0
assert|;
assert|assert
name|nextDocID
operator|==
name|numDocsInRAM
assert|;
assert|assert
name|waitQueue
operator|.
name|numWaiting
operator|==
literal|0
assert|;
assert|assert
name|waitQueue
operator|.
name|waitingBytes
operator|==
literal|0
assert|;
name|initFlushState
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|docStoreOffset
operator|=
name|numDocsInStore
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"flush postings as segment "
operator|+
name|flushState
operator|.
name|segmentName
operator|+
literal|" numDocs="
operator|+
name|numDocsInRAM
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|closeDocStore
condition|)
block|{
assert|assert
name|flushState
operator|.
name|docStoreSegmentName
operator|!=
literal|null
assert|;
assert|assert
name|flushState
operator|.
name|docStoreSegmentName
operator|.
name|equals
argument_list|(
name|flushState
operator|.
name|segmentName
argument_list|)
assert|;
name|closeDocStore
argument_list|()
expr_stmt|;
name|flushState
operator|.
name|numDocsInStore
operator|=
literal|0
expr_stmt|;
block|}
name|Collection
name|threads
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|threads
operator|.
name|add
argument_list|(
name|threadStates
index|[
name|i
index|]
operator|.
name|consumer
argument_list|)
expr_stmt|;
name|consumer
operator|.
name|flush
argument_list|(
name|threads
argument_list|,
name|flushState
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
specifier|final
name|long
name|newSegmentSize
init|=
name|segmentSize
argument_list|(
name|flushState
operator|.
name|segmentName
argument_list|)
decl_stmt|;
name|String
name|message
init|=
literal|"  oldRAMSize="
operator|+
name|numBytesUsed
operator|+
literal|" newFlushedSize="
operator|+
name|newSegmentSize
operator|+
literal|" docs/MB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|numDocsInRAM
operator|/
operator|(
name|newSegmentSize
operator|/
literal|1024.
operator|/
literal|1024.
operator|)
argument_list|)
operator|+
literal|" new/old="
operator|+
name|nf
operator|.
name|format
argument_list|(
literal|100.0
operator|*
name|newSegmentSize
operator|/
name|numBytesUsed
argument_list|)
operator|+
literal|"%"
decl_stmt|;
name|message
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|flushedDocCount
operator|+=
name|flushState
operator|.
name|numDocs
expr_stmt|;
name|doAfterFlush
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
assert|assert
name|waitQueue
operator|.
name|waitingBytes
operator|==
literal|0
assert|;
return|return
name|flushState
operator|.
name|numDocs
return|;
block|}
comment|/** Build compound file for the segment we just flushed */
DECL|method|createCompoundFile
name|void
name|createCompoundFile
parameter_list|(
name|String
name|segment
parameter_list|)
throws|throws
name|IOException
block|{
name|CompoundFileWriter
name|cfsWriter
init|=
operator|new
name|CompoundFileWriter
argument_list|(
name|directory
argument_list|,
name|segment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|COMPOUND_FILE_EXTENSION
argument_list|)
decl_stmt|;
name|Iterator
name|it
init|=
name|flushState
operator|.
name|flushedFiles
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
name|cfsWriter
operator|.
name|addFile
argument_list|(
operator|(
name|String
operator|)
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
comment|// Perform the merge
name|cfsWriter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Set flushPending if it is not already set and returns    *  whether it was set. This is used by IndexWriter to    *  trigger a single flush even when multiple threads are    *  trying to do so. */
DECL|method|setFlushPending
specifier|synchronized
name|boolean
name|setFlushPending
parameter_list|()
block|{
if|if
condition|(
name|flushPending
condition|)
return|return
literal|false
return|;
else|else
block|{
name|flushPending
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
DECL|method|clearFlushPending
specifier|synchronized
name|void
name|clearFlushPending
parameter_list|()
block|{
name|flushPending
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|pushDeletes
specifier|synchronized
name|void
name|pushDeletes
parameter_list|()
block|{
name|deletesFlushed
operator|.
name|update
argument_list|(
name|deletesInRAM
argument_list|)
expr_stmt|;
block|}
DECL|method|close
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
name|closed
operator|=
literal|true
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
DECL|method|initSegmentName
specifier|synchronized
name|void
name|initSegmentName
parameter_list|(
name|boolean
name|onlyDocStore
parameter_list|)
block|{
if|if
condition|(
name|segment
operator|==
literal|null
operator|&&
operator|(
operator|!
name|onlyDocStore
operator|||
name|docStoreSegment
operator|==
literal|null
operator|)
condition|)
block|{
name|segment
operator|=
name|writer
operator|.
name|newSegmentName
argument_list|()
expr_stmt|;
assert|assert
name|numDocsInRAM
operator|==
literal|0
assert|;
block|}
if|if
condition|(
name|docStoreSegment
operator|==
literal|null
condition|)
block|{
name|docStoreSegment
operator|=
name|segment
expr_stmt|;
assert|assert
name|numDocsInStore
operator|==
literal|0
assert|;
block|}
block|}
comment|/** Returns a free (idle) ThreadState that may be used for    * indexing this one document.  This call also pauses if a    * flush is pending.  If delTerm is non-null then we    * buffer this deleted term after the thread state has    * been acquired. */
DECL|method|getThreadState
specifier|synchronized
name|DocumentsWriterThreadState
name|getThreadState
parameter_list|(
name|Document
name|doc
parameter_list|,
name|Term
name|delTerm
parameter_list|)
throws|throws
name|IOException
block|{
comment|// First, find a thread state.  If this thread already
comment|// has affinity to a specific ThreadState, use that one
comment|// again.
name|DocumentsWriterThreadState
name|state
init|=
operator|(
name|DocumentsWriterThreadState
operator|)
name|threadBindings
operator|.
name|get
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
comment|// First time this thread has called us since last
comment|// flush.  Find the least loaded thread state:
name|DocumentsWriterThreadState
name|minThreadState
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|DocumentsWriterThreadState
name|ts
init|=
name|threadStates
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|minThreadState
operator|==
literal|null
operator|||
name|ts
operator|.
name|numThreads
operator|<
name|minThreadState
operator|.
name|numThreads
condition|)
name|minThreadState
operator|=
name|ts
expr_stmt|;
block|}
if|if
condition|(
name|minThreadState
operator|!=
literal|null
operator|&&
operator|(
name|minThreadState
operator|.
name|numThreads
operator|==
literal|0
operator|||
name|threadStates
operator|.
name|length
operator|>=
name|MAX_THREAD_STATE
operator|)
condition|)
block|{
name|state
operator|=
name|minThreadState
expr_stmt|;
name|state
operator|.
name|numThreads
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// Just create a new "private" thread state
name|DocumentsWriterThreadState
index|[]
name|newArray
init|=
operator|new
name|DocumentsWriterThreadState
index|[
literal|1
operator|+
name|threadStates
operator|.
name|length
index|]
decl_stmt|;
if|if
condition|(
name|threadStates
operator|.
name|length
operator|>
literal|0
condition|)
name|System
operator|.
name|arraycopy
argument_list|(
name|threadStates
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|threadStates
operator|.
name|length
argument_list|)
expr_stmt|;
name|state
operator|=
name|newArray
index|[
name|threadStates
operator|.
name|length
index|]
operator|=
operator|new
name|DocumentsWriterThreadState
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|threadStates
operator|=
name|newArray
expr_stmt|;
block|}
name|threadBindings
operator|.
name|put
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
comment|// Next, wait until my thread state is idle (in case
comment|// it's shared with other threads) and for threads to
comment|// not be paused nor a flush pending:
name|waitReady
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|// Allocate segment name if this is the first doc since
comment|// last flush:
name|initSegmentName
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|state
operator|.
name|isIdle
operator|=
literal|false
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|state
operator|.
name|docState
operator|.
name|docID
operator|=
name|nextDocID
expr_stmt|;
assert|assert
name|writer
operator|.
name|testPoint
argument_list|(
literal|"DocumentsWriter.ThreadState.init start"
argument_list|)
assert|;
if|if
condition|(
name|delTerm
operator|!=
literal|null
condition|)
block|{
name|addDeleteTerm
argument_list|(
name|delTerm
argument_list|,
name|state
operator|.
name|docState
operator|.
name|docID
argument_list|)
expr_stmt|;
name|state
operator|.
name|doFlushAfter
operator|=
name|timeToFlushDeletes
argument_list|()
expr_stmt|;
block|}
assert|assert
name|writer
operator|.
name|testPoint
argument_list|(
literal|"DocumentsWriter.ThreadState.init after delTerm"
argument_list|)
assert|;
name|nextDocID
operator|++
expr_stmt|;
name|numDocsInRAM
operator|++
expr_stmt|;
comment|// We must at this point commit to flushing to ensure we
comment|// always get N docs when we flush by doc count, even if
comment|//> 1 thread is adding documents:
if|if
condition|(
operator|!
name|flushPending
operator|&&
name|maxBufferedDocs
operator|!=
name|IndexWriter
operator|.
name|DISABLE_AUTO_FLUSH
operator|&&
name|numDocsInRAM
operator|>=
name|maxBufferedDocs
condition|)
block|{
name|flushPending
operator|=
literal|true
expr_stmt|;
name|state
operator|.
name|doFlushAfter
operator|=
literal|true
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// Forcefully idle this ThreadState:
name|state
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|doFlushAfter
condition|)
block|{
name|state
operator|.
name|doFlushAfter
operator|=
literal|false
expr_stmt|;
name|flushPending
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
return|return
name|state
return|;
block|}
comment|/** Returns true if the caller (IndexWriter) should now    * flush. */
DECL|method|addDocument
name|boolean
name|addDocument
parameter_list|(
name|Document
name|doc
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|updateDocument
argument_list|(
name|doc
argument_list|,
name|analyzer
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|updateDocument
name|boolean
name|updateDocument
parameter_list|(
name|Term
name|t
parameter_list|,
name|Document
name|doc
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|updateDocument
argument_list|(
name|doc
argument_list|,
name|analyzer
argument_list|,
name|t
argument_list|)
return|;
block|}
DECL|method|updateDocument
name|boolean
name|updateDocument
parameter_list|(
name|Document
name|doc
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|,
name|Term
name|delTerm
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
comment|// This call is synchronized but fast
specifier|final
name|DocumentsWriterThreadState
name|state
init|=
name|getThreadState
argument_list|(
name|doc
argument_list|,
name|delTerm
argument_list|)
decl_stmt|;
specifier|final
name|DocState
name|docState
init|=
name|state
operator|.
name|docState
decl_stmt|;
name|docState
operator|.
name|doc
operator|=
name|doc
expr_stmt|;
name|docState
operator|.
name|analyzer
operator|=
name|analyzer
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// This call is not synchronized and does all the
comment|// work
specifier|final
name|DocWriter
name|perDoc
init|=
name|state
operator|.
name|consumer
operator|.
name|processDocument
argument_list|()
decl_stmt|;
comment|// This call is synchronized but fast
name|finishDocument
argument_list|(
name|state
argument_list|,
name|perDoc
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|aborting
condition|)
block|{
name|state
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|skipDocWriter
operator|.
name|docID
operator|=
name|docState
operator|.
name|docID
expr_stmt|;
name|boolean
name|success2
init|=
literal|false
decl_stmt|;
try|try
block|{
name|waitQueue
operator|.
name|add
argument_list|(
name|skipDocWriter
argument_list|)
expr_stmt|;
name|success2
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success2
condition|)
block|{
name|state
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|state
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
comment|// If this thread state had decided to flush, we
comment|// must clear it so another thread can flush
if|if
condition|(
name|state
operator|.
name|doFlushAfter
condition|)
block|{
name|state
operator|.
name|doFlushAfter
operator|=
literal|false
expr_stmt|;
name|flushPending
operator|=
literal|false
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|// Immediately mark this document as deleted
comment|// since likely it was partially added.  This
comment|// keeps indexing as "all or none" (atomic) when
comment|// adding a document:
name|addDeleteDocID
argument_list|(
name|state
operator|.
name|docState
operator|.
name|docID
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|state
operator|.
name|doFlushAfter
operator|||
name|timeToFlushDeletes
argument_list|()
return|;
block|}
comment|// for testing
DECL|method|getNumBufferedDeleteTerms
specifier|synchronized
name|int
name|getNumBufferedDeleteTerms
parameter_list|()
block|{
return|return
name|deletesInRAM
operator|.
name|numTerms
return|;
block|}
comment|// for testing
DECL|method|getBufferedDeleteTerms
specifier|synchronized
name|HashMap
name|getBufferedDeleteTerms
parameter_list|()
block|{
return|return
name|deletesInRAM
operator|.
name|terms
return|;
block|}
comment|/** Called whenever a merge has completed and the merged segments had deletions */
DECL|method|remapDeletes
specifier|synchronized
name|void
name|remapDeletes
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|int
index|[]
index|[]
name|docMaps
parameter_list|,
name|int
index|[]
name|delCounts
parameter_list|,
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|,
name|int
name|mergeDocCount
parameter_list|)
block|{
if|if
condition|(
name|docMaps
operator|==
literal|null
condition|)
comment|// The merged segments had no deletes so docIDs did not change and we have nothing to do
return|return;
name|MergeDocIDRemapper
name|mapper
init|=
operator|new
name|MergeDocIDRemapper
argument_list|(
name|infos
argument_list|,
name|docMaps
argument_list|,
name|delCounts
argument_list|,
name|merge
argument_list|,
name|mergeDocCount
argument_list|)
decl_stmt|;
name|deletesInRAM
operator|.
name|remap
argument_list|(
name|mapper
argument_list|,
name|infos
argument_list|,
name|docMaps
argument_list|,
name|delCounts
argument_list|,
name|merge
argument_list|,
name|mergeDocCount
argument_list|)
expr_stmt|;
name|deletesFlushed
operator|.
name|remap
argument_list|(
name|mapper
argument_list|,
name|infos
argument_list|,
name|docMaps
argument_list|,
name|delCounts
argument_list|,
name|merge
argument_list|,
name|mergeDocCount
argument_list|)
expr_stmt|;
name|flushedDocCount
operator|-=
name|mapper
operator|.
name|docShift
expr_stmt|;
block|}
DECL|method|waitReady
specifier|synchronized
specifier|private
name|void
name|waitReady
parameter_list|(
name|DocumentsWriterThreadState
name|state
parameter_list|)
block|{
while|while
condition|(
operator|!
name|closed
operator|&&
operator|(
operator|(
name|state
operator|!=
literal|null
operator|&&
operator|!
name|state
operator|.
name|isIdle
operator|)
operator|||
name|pauseThreads
operator|!=
literal|0
operator|||
name|flushPending
operator|||
name|aborting
operator|)
condition|)
block|{
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// In 3.0 we will change this to throw
comment|// InterruptedException instead
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|closed
condition|)
throw|throw
operator|new
name|AlreadyClosedException
argument_list|(
literal|"this IndexWriter is closed"
argument_list|)
throw|;
block|}
DECL|method|bufferDeleteTerms
specifier|synchronized
name|boolean
name|bufferDeleteTerms
parameter_list|(
name|Term
index|[]
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
name|waitReady
argument_list|(
literal|null
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|terms
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|addDeleteTerm
argument_list|(
name|terms
index|[
name|i
index|]
argument_list|,
name|numDocsInRAM
argument_list|)
expr_stmt|;
return|return
name|timeToFlushDeletes
argument_list|()
return|;
block|}
DECL|method|bufferDeleteTerm
specifier|synchronized
name|boolean
name|bufferDeleteTerm
parameter_list|(
name|Term
name|term
parameter_list|)
throws|throws
name|IOException
block|{
name|waitReady
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|addDeleteTerm
argument_list|(
name|term
argument_list|,
name|numDocsInRAM
argument_list|)
expr_stmt|;
return|return
name|timeToFlushDeletes
argument_list|()
return|;
block|}
DECL|method|bufferDeleteQueries
specifier|synchronized
name|boolean
name|bufferDeleteQueries
parameter_list|(
name|Query
index|[]
name|queries
parameter_list|)
throws|throws
name|IOException
block|{
name|waitReady
argument_list|(
literal|null
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queries
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|addDeleteQuery
argument_list|(
name|queries
index|[
name|i
index|]
argument_list|,
name|numDocsInRAM
argument_list|)
expr_stmt|;
return|return
name|timeToFlushDeletes
argument_list|()
return|;
block|}
DECL|method|bufferDeleteQuery
specifier|synchronized
name|boolean
name|bufferDeleteQuery
parameter_list|(
name|Query
name|query
parameter_list|)
throws|throws
name|IOException
block|{
name|waitReady
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|addDeleteQuery
argument_list|(
name|query
argument_list|,
name|numDocsInRAM
argument_list|)
expr_stmt|;
return|return
name|timeToFlushDeletes
argument_list|()
return|;
block|}
DECL|method|deletesFull
specifier|synchronized
name|boolean
name|deletesFull
parameter_list|()
block|{
return|return
operator|(
name|ramBufferSize
operator|!=
name|IndexWriter
operator|.
name|DISABLE_AUTO_FLUSH
operator|&&
operator|(
name|deletesInRAM
operator|.
name|bytesUsed
operator|+
name|deletesFlushed
operator|.
name|bytesUsed
operator|+
name|numBytesUsed
operator|)
operator|>=
name|ramBufferSize
operator|)
operator|||
operator|(
name|maxBufferedDeleteTerms
operator|!=
name|IndexWriter
operator|.
name|DISABLE_AUTO_FLUSH
operator|&&
operator|(
operator|(
name|deletesInRAM
operator|.
name|size
argument_list|()
operator|+
name|deletesFlushed
operator|.
name|size
argument_list|()
operator|)
operator|>=
name|maxBufferedDeleteTerms
operator|)
operator|)
return|;
block|}
DECL|method|doApplyDeletes
specifier|synchronized
name|boolean
name|doApplyDeletes
parameter_list|()
block|{
comment|// Very similar to deletesFull(), except we don't count
comment|// numBytesAlloc, because we are checking whether
comment|// deletes (alone) are consuming too many resources now
comment|// and thus should be applied.  We apply deletes if RAM
comment|// usage is> 1/2 of our allowed RAM buffer, to prevent
comment|// too-frequent flushing of a long tail of tiny segments
comment|// when merges (which always apply deletes) are
comment|// infrequent.
return|return
operator|(
name|ramBufferSize
operator|!=
name|IndexWriter
operator|.
name|DISABLE_AUTO_FLUSH
operator|&&
operator|(
name|deletesInRAM
operator|.
name|bytesUsed
operator|+
name|deletesFlushed
operator|.
name|bytesUsed
operator|)
operator|>=
name|ramBufferSize
operator|/
literal|2
operator|)
operator|||
operator|(
name|maxBufferedDeleteTerms
operator|!=
name|IndexWriter
operator|.
name|DISABLE_AUTO_FLUSH
operator|&&
operator|(
operator|(
name|deletesInRAM
operator|.
name|size
argument_list|()
operator|+
name|deletesFlushed
operator|.
name|size
argument_list|()
operator|)
operator|>=
name|maxBufferedDeleteTerms
operator|)
operator|)
return|;
block|}
DECL|method|timeToFlushDeletes
specifier|synchronized
specifier|private
name|boolean
name|timeToFlushDeletes
parameter_list|()
block|{
return|return
operator|(
name|bufferIsFull
operator|||
name|deletesFull
argument_list|()
operator|)
operator|&&
name|setFlushPending
argument_list|()
return|;
block|}
DECL|method|setMaxBufferedDeleteTerms
name|void
name|setMaxBufferedDeleteTerms
parameter_list|(
name|int
name|maxBufferedDeleteTerms
parameter_list|)
block|{
name|this
operator|.
name|maxBufferedDeleteTerms
operator|=
name|maxBufferedDeleteTerms
expr_stmt|;
block|}
DECL|method|getMaxBufferedDeleteTerms
name|int
name|getMaxBufferedDeleteTerms
parameter_list|()
block|{
return|return
name|maxBufferedDeleteTerms
return|;
block|}
DECL|method|hasDeletes
specifier|synchronized
name|boolean
name|hasDeletes
parameter_list|()
block|{
return|return
name|deletesFlushed
operator|.
name|any
argument_list|()
return|;
block|}
DECL|method|applyDeletes
specifier|synchronized
name|boolean
name|applyDeletes
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|hasDeletes
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"apply "
operator|+
name|deletesFlushed
operator|.
name|numTerms
operator|+
literal|" buffered deleted terms and "
operator|+
name|deletesFlushed
operator|.
name|docIDs
operator|.
name|size
argument_list|()
operator|+
literal|" deleted docIDs and "
operator|+
name|deletesFlushed
operator|.
name|queries
operator|.
name|size
argument_list|()
operator|+
literal|" deleted queries on "
operator|+
operator|+
name|infos
operator|.
name|size
argument_list|()
operator|+
literal|" segments."
argument_list|)
expr_stmt|;
specifier|final
name|int
name|infosEnd
init|=
name|infos
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|docStart
init|=
literal|0
decl_stmt|;
name|boolean
name|any
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|infosEnd
condition|;
name|i
operator|++
control|)
block|{
comment|// Make sure we never attempt to apply deletes to
comment|// segment in external dir
assert|assert
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
operator|.
name|dir
operator|==
name|directory
assert|;
name|SegmentReader
name|reader
init|=
name|writer
operator|.
name|readerPool
operator|.
name|get
argument_list|(
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
try|try
block|{
name|any
operator||=
name|applyDeletes
argument_list|(
name|reader
argument_list|,
name|docStart
argument_list|)
expr_stmt|;
name|docStart
operator|+=
name|reader
operator|.
name|maxDoc
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writer
operator|.
name|readerPool
operator|.
name|release
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
name|deletesFlushed
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|any
return|;
block|}
comment|// Apply buffered delete terms, queries and docIDs to the
comment|// provided reader
DECL|method|applyDeletes
specifier|private
specifier|final
specifier|synchronized
name|boolean
name|applyDeletes
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|int
name|docIDStart
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
specifier|final
name|int
name|docEnd
init|=
name|docIDStart
operator|+
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
name|boolean
name|any
init|=
literal|false
decl_stmt|;
comment|// Delete by term
name|Iterator
name|iter
init|=
name|deletesFlushed
operator|.
name|terms
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|TermDocs
name|docs
init|=
name|reader
operator|.
name|termDocs
argument_list|()
decl_stmt|;
try|try
block|{
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
name|entry
init|=
operator|(
name|Entry
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|Term
name|term
init|=
operator|(
name|Term
operator|)
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|docs
operator|.
name|seek
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|int
name|limit
init|=
operator|(
operator|(
name|BufferedDeletes
operator|.
name|Num
operator|)
name|entry
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|getNum
argument_list|()
decl_stmt|;
while|while
condition|(
name|docs
operator|.
name|next
argument_list|()
condition|)
block|{
name|int
name|docID
init|=
name|docs
operator|.
name|doc
argument_list|()
decl_stmt|;
if|if
condition|(
name|docIDStart
operator|+
name|docID
operator|>=
name|limit
condition|)
break|break;
name|reader
operator|.
name|deleteDocument
argument_list|(
name|docID
argument_list|)
expr_stmt|;
name|any
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|docs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Delete by docID
name|iter
operator|=
name|deletesFlushed
operator|.
name|docIDs
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|docID
init|=
operator|(
operator|(
name|Integer
operator|)
name|iter
operator|.
name|next
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|docID
operator|>=
name|docIDStart
operator|&&
name|docID
operator|<
name|docEnd
condition|)
block|{
name|reader
operator|.
name|deleteDocument
argument_list|(
name|docID
operator|-
name|docIDStart
argument_list|)
expr_stmt|;
name|any
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Delete by query
name|IndexSearcher
name|searcher
init|=
operator|new
name|IndexSearcher
argument_list|(
name|reader
argument_list|)
decl_stmt|;
name|iter
operator|=
name|deletesFlushed
operator|.
name|queries
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
name|entry
init|=
operator|(
name|Entry
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|Query
name|query
init|=
operator|(
name|Query
operator|)
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|int
name|limit
init|=
operator|(
operator|(
name|Integer
operator|)
name|entry
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|QueryWeight
name|weight
init|=
name|query
operator|.
name|queryWeight
argument_list|(
name|searcher
argument_list|)
decl_stmt|;
name|Scorer
name|scorer
init|=
name|weight
operator|.
name|scorer
argument_list|(
name|reader
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|doc
init|=
name|scorer
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|long
operator|)
name|docIDStart
operator|)
operator|+
name|doc
operator|>=
name|limit
condition|)
break|break;
name|reader
operator|.
name|deleteDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|any
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|searcher
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|any
return|;
block|}
comment|// Buffer a term in bufferedDeleteTerms, which records the
comment|// current number of documents buffered in ram so that the
comment|// delete term will be applied to those documents as well
comment|// as the disk segments.
DECL|method|addDeleteTerm
specifier|synchronized
specifier|private
name|void
name|addDeleteTerm
parameter_list|(
name|Term
name|term
parameter_list|,
name|int
name|docCount
parameter_list|)
block|{
name|BufferedDeletes
operator|.
name|Num
name|num
init|=
operator|(
name|BufferedDeletes
operator|.
name|Num
operator|)
name|deletesInRAM
operator|.
name|terms
operator|.
name|get
argument_list|(
name|term
argument_list|)
decl_stmt|;
specifier|final
name|int
name|docIDUpto
init|=
name|flushedDocCount
operator|+
name|docCount
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|null
condition|)
name|deletesInRAM
operator|.
name|terms
operator|.
name|put
argument_list|(
name|term
argument_list|,
operator|new
name|BufferedDeletes
operator|.
name|Num
argument_list|(
name|docIDUpto
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|num
operator|.
name|setNum
argument_list|(
name|docIDUpto
argument_list|)
expr_stmt|;
name|deletesInRAM
operator|.
name|numTerms
operator|++
expr_stmt|;
name|deletesInRAM
operator|.
name|addBytesUsed
argument_list|(
name|BYTES_PER_DEL_TERM
operator|+
name|term
operator|.
name|text
operator|.
name|length
argument_list|()
operator|*
name|CHAR_NUM_BYTE
argument_list|)
expr_stmt|;
block|}
comment|// Buffer a specific docID for deletion.  Currently only
comment|// used when we hit a exception when adding a document
DECL|method|addDeleteDocID
specifier|synchronized
specifier|private
name|void
name|addDeleteDocID
parameter_list|(
name|int
name|docID
parameter_list|)
block|{
name|deletesInRAM
operator|.
name|docIDs
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
name|flushedDocCount
operator|+
name|docID
argument_list|)
argument_list|)
expr_stmt|;
name|deletesInRAM
operator|.
name|addBytesUsed
argument_list|(
name|BYTES_PER_DEL_DOCID
argument_list|)
expr_stmt|;
block|}
DECL|method|addDeleteQuery
specifier|synchronized
specifier|private
name|void
name|addDeleteQuery
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|docID
parameter_list|)
block|{
name|deletesInRAM
operator|.
name|queries
operator|.
name|put
argument_list|(
name|query
argument_list|,
operator|new
name|Integer
argument_list|(
name|flushedDocCount
operator|+
name|docID
argument_list|)
argument_list|)
expr_stmt|;
name|deletesInRAM
operator|.
name|addBytesUsed
argument_list|(
name|BYTES_PER_DEL_QUERY
argument_list|)
expr_stmt|;
block|}
DECL|method|doBalanceRAM
specifier|synchronized
name|boolean
name|doBalanceRAM
parameter_list|()
block|{
return|return
name|ramBufferSize
operator|!=
name|IndexWriter
operator|.
name|DISABLE_AUTO_FLUSH
operator|&&
operator|!
name|bufferIsFull
operator|&&
operator|(
name|numBytesUsed
operator|+
name|deletesInRAM
operator|.
name|bytesUsed
operator|+
name|deletesFlushed
operator|.
name|bytesUsed
operator|>=
name|ramBufferSize
operator|||
name|numBytesAlloc
operator|>=
name|freeTrigger
operator|)
return|;
block|}
comment|/** Does the synchronized work to finish/flush the    *  inverted document. */
DECL|method|finishDocument
specifier|private
name|void
name|finishDocument
parameter_list|(
name|DocumentsWriterThreadState
name|perThread
parameter_list|,
name|DocWriter
name|docWriter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|doBalanceRAM
argument_list|()
condition|)
comment|// Must call this w/o holding synchronized(this) else
comment|// we'll hit deadlock:
name|balanceRAM
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
assert|assert
name|docWriter
operator|==
literal|null
operator|||
name|docWriter
operator|.
name|docID
operator|==
name|perThread
operator|.
name|docState
operator|.
name|docID
assert|;
if|if
condition|(
name|aborting
condition|)
block|{
comment|// We are currently aborting, and another thread is
comment|// waiting for me to become idle.  We just forcefully
comment|// idle this threadState; it will be fully reset by
comment|// abort()
if|if
condition|(
name|docWriter
operator|!=
literal|null
condition|)
try|try
block|{
name|docWriter
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{           }
name|perThread
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|final
name|boolean
name|doPause
decl_stmt|;
if|if
condition|(
name|docWriter
operator|!=
literal|null
condition|)
name|doPause
operator|=
name|waitQueue
operator|.
name|add
argument_list|(
name|docWriter
argument_list|)
expr_stmt|;
else|else
block|{
name|skipDocWriter
operator|.
name|docID
operator|=
name|perThread
operator|.
name|docState
operator|.
name|docID
expr_stmt|;
name|doPause
operator|=
name|waitQueue
operator|.
name|add
argument_list|(
name|skipDocWriter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doPause
condition|)
name|waitForWaitQueue
argument_list|()
expr_stmt|;
if|if
condition|(
name|bufferIsFull
operator|&&
operator|!
name|flushPending
condition|)
block|{
name|flushPending
operator|=
literal|true
expr_stmt|;
name|perThread
operator|.
name|doFlushAfter
operator|=
literal|true
expr_stmt|;
block|}
name|perThread
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|waitForWaitQueue
specifier|synchronized
name|void
name|waitForWaitQueue
parameter_list|()
block|{
do|do
block|{
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// In 3.0 we will change this to throw
comment|// InterruptedException instead
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
do|while
condition|(
operator|!
name|waitQueue
operator|.
name|doResume
argument_list|()
condition|)
do|;
block|}
DECL|class|SkipDocWriter
specifier|private
specifier|static
class|class
name|SkipDocWriter
extends|extends
name|DocWriter
block|{
DECL|method|finish
name|void
name|finish
parameter_list|()
block|{     }
DECL|method|abort
name|void
name|abort
parameter_list|()
block|{     }
DECL|method|sizeInBytes
name|long
name|sizeInBytes
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|field|skipDocWriter
specifier|final
name|SkipDocWriter
name|skipDocWriter
init|=
operator|new
name|SkipDocWriter
argument_list|()
decl_stmt|;
DECL|method|getRAMUsed
name|long
name|getRAMUsed
parameter_list|()
block|{
return|return
name|numBytesUsed
operator|+
name|deletesInRAM
operator|.
name|bytesUsed
operator|+
name|deletesFlushed
operator|.
name|bytesUsed
return|;
block|}
DECL|field|numBytesAlloc
name|long
name|numBytesAlloc
decl_stmt|;
DECL|field|numBytesUsed
name|long
name|numBytesUsed
decl_stmt|;
DECL|field|nf
name|NumberFormat
name|nf
init|=
name|NumberFormat
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|// TODO FI: this is not flexible -- we can't hardwire
comment|// extensions in here:
DECL|method|segmentSize
specifier|private
name|long
name|segmentSize
parameter_list|(
name|String
name|segmentName
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Used only when infoStream != null
assert|assert
name|infoStream
operator|!=
literal|null
assert|;
name|long
name|size
init|=
name|directory
operator|.
name|fileLength
argument_list|(
name|segmentName
operator|+
literal|".tii"
argument_list|)
operator|+
name|directory
operator|.
name|fileLength
argument_list|(
name|segmentName
operator|+
literal|".tis"
argument_list|)
operator|+
name|directory
operator|.
name|fileLength
argument_list|(
name|segmentName
operator|+
literal|".frq"
argument_list|)
operator|+
name|directory
operator|.
name|fileLength
argument_list|(
name|segmentName
operator|+
literal|".prx"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|normFileName
init|=
name|segmentName
operator|+
literal|".nrm"
decl_stmt|;
if|if
condition|(
name|directory
operator|.
name|fileExists
argument_list|(
name|normFileName
argument_list|)
condition|)
name|size
operator|+=
name|directory
operator|.
name|fileLength
argument_list|(
name|normFileName
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
comment|// Coarse estimates used to measure RAM usage of buffered deletes
DECL|field|OBJECT_HEADER_BYTES
specifier|final
specifier|static
name|int
name|OBJECT_HEADER_BYTES
init|=
literal|8
decl_stmt|;
DECL|field|POINTER_NUM_BYTE
specifier|final
specifier|static
name|int
name|POINTER_NUM_BYTE
init|=
name|Constants
operator|.
name|JRE_IS_64BIT
condition|?
literal|8
else|:
literal|4
decl_stmt|;
DECL|field|INT_NUM_BYTE
specifier|final
specifier|static
name|int
name|INT_NUM_BYTE
init|=
literal|4
decl_stmt|;
DECL|field|CHAR_NUM_BYTE
specifier|final
specifier|static
name|int
name|CHAR_NUM_BYTE
init|=
literal|2
decl_stmt|;
comment|/* Rough logic: HashMap has an array[Entry] w/ varying      load factor (say 2 * POINTER).  Entry is object w/ Term      key, BufferedDeletes.Num val, int hash, Entry next      (OBJ_HEADER + 3*POINTER + INT).  Term is object w/      String field and String text (OBJ_HEADER + 2*POINTER).      We don't count Term's field since it's interned.      Term's text is String (OBJ_HEADER + 4*INT + POINTER +      OBJ_HEADER + string.length*CHAR).  BufferedDeletes.num is      OBJ_HEADER + INT. */
DECL|field|BYTES_PER_DEL_TERM
specifier|final
specifier|static
name|int
name|BYTES_PER_DEL_TERM
init|=
literal|8
operator|*
name|POINTER_NUM_BYTE
operator|+
literal|5
operator|*
name|OBJECT_HEADER_BYTES
operator|+
literal|6
operator|*
name|INT_NUM_BYTE
decl_stmt|;
comment|/* Rough logic: del docIDs are List<Integer>.  Say list      allocates ~2X size (2*POINTER).  Integer is OBJ_HEADER      + int */
DECL|field|BYTES_PER_DEL_DOCID
specifier|final
specifier|static
name|int
name|BYTES_PER_DEL_DOCID
init|=
literal|2
operator|*
name|POINTER_NUM_BYTE
operator|+
name|OBJECT_HEADER_BYTES
operator|+
name|INT_NUM_BYTE
decl_stmt|;
comment|/* Rough logic: HashMap has an array[Entry] w/ varying      load factor (say 2 * POINTER).  Entry is object w/      Query key, Integer val, int hash, Entry next      (OBJ_HEADER + 3*POINTER + INT).  Query we often      undercount (say 24 bytes).  Integer is OBJ_HEADER + INT. */
DECL|field|BYTES_PER_DEL_QUERY
specifier|final
specifier|static
name|int
name|BYTES_PER_DEL_QUERY
init|=
literal|5
operator|*
name|POINTER_NUM_BYTE
operator|+
literal|2
operator|*
name|OBJECT_HEADER_BYTES
operator|+
literal|2
operator|*
name|INT_NUM_BYTE
operator|+
literal|24
decl_stmt|;
comment|/* Initial chunks size of the shared byte[] blocks used to      store postings data */
DECL|field|BYTE_BLOCK_SHIFT
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_SHIFT
init|=
literal|15
decl_stmt|;
DECL|field|BYTE_BLOCK_SIZE
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_SIZE
init|=
literal|1
operator|<<
name|BYTE_BLOCK_SHIFT
decl_stmt|;
DECL|field|BYTE_BLOCK_MASK
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_MASK
init|=
name|BYTE_BLOCK_SIZE
operator|-
literal|1
decl_stmt|;
DECL|field|BYTE_BLOCK_NOT_MASK
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_NOT_MASK
init|=
operator|~
name|BYTE_BLOCK_MASK
decl_stmt|;
DECL|class|ByteBlockAllocator
specifier|private
class|class
name|ByteBlockAllocator
extends|extends
name|ByteBlockPool
operator|.
name|Allocator
block|{
DECL|field|freeByteBlocks
name|ArrayList
name|freeByteBlocks
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
comment|/* Allocate another byte[] from the shared pool */
DECL|method|getByteBlock
name|byte
index|[]
name|getByteBlock
parameter_list|(
name|boolean
name|trackAllocations
parameter_list|)
block|{
synchronized|synchronized
init|(
name|DocumentsWriter
operator|.
name|this
init|)
block|{
specifier|final
name|int
name|size
init|=
name|freeByteBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|b
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|size
condition|)
block|{
comment|// Always record a block allocated, even if
comment|// trackAllocations is false.  This is necessary
comment|// because this block will be shared between
comment|// things that don't track allocations (term
comment|// vectors) and things that do (freq/prox
comment|// postings).
name|numBytesAlloc
operator|+=
name|BYTE_BLOCK_SIZE
expr_stmt|;
name|b
operator|=
operator|new
name|byte
index|[
name|BYTE_BLOCK_SIZE
index|]
expr_stmt|;
block|}
else|else
name|b
operator|=
operator|(
name|byte
index|[]
operator|)
name|freeByteBlocks
operator|.
name|remove
argument_list|(
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|trackAllocations
condition|)
name|numBytesUsed
operator|+=
name|BYTE_BLOCK_SIZE
expr_stmt|;
assert|assert
name|numBytesUsed
operator|<=
name|numBytesAlloc
assert|;
return|return
name|b
return|;
block|}
block|}
comment|/* Return byte[]'s to the pool */
DECL|method|recycleByteBlocks
name|void
name|recycleByteBlocks
parameter_list|(
name|byte
index|[]
index|[]
name|blocks
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
synchronized|synchronized
init|(
name|DocumentsWriter
operator|.
name|this
init|)
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
name|freeByteBlocks
operator|.
name|add
argument_list|(
name|blocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Initial chunks size of the shared int[] blocks used to      store postings data */
DECL|field|INT_BLOCK_SHIFT
specifier|final
specifier|static
name|int
name|INT_BLOCK_SHIFT
init|=
literal|13
decl_stmt|;
DECL|field|INT_BLOCK_SIZE
specifier|final
specifier|static
name|int
name|INT_BLOCK_SIZE
init|=
literal|1
operator|<<
name|INT_BLOCK_SHIFT
decl_stmt|;
DECL|field|INT_BLOCK_MASK
specifier|final
specifier|static
name|int
name|INT_BLOCK_MASK
init|=
name|INT_BLOCK_SIZE
operator|-
literal|1
decl_stmt|;
DECL|field|freeIntBlocks
specifier|private
name|ArrayList
name|freeIntBlocks
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
comment|/* Allocate another int[] from the shared pool */
DECL|method|getIntBlock
specifier|synchronized
name|int
index|[]
name|getIntBlock
parameter_list|(
name|boolean
name|trackAllocations
parameter_list|)
block|{
specifier|final
name|int
name|size
init|=
name|freeIntBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
index|[]
name|b
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|size
condition|)
block|{
comment|// Always record a block allocated, even if
comment|// trackAllocations is false.  This is necessary
comment|// because this block will be shared between
comment|// things that don't track allocations (term
comment|// vectors) and things that do (freq/prox
comment|// postings).
name|numBytesAlloc
operator|+=
name|INT_BLOCK_SIZE
operator|*
name|INT_NUM_BYTE
expr_stmt|;
name|b
operator|=
operator|new
name|int
index|[
name|INT_BLOCK_SIZE
index|]
expr_stmt|;
block|}
else|else
name|b
operator|=
operator|(
name|int
index|[]
operator|)
name|freeIntBlocks
operator|.
name|remove
argument_list|(
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|trackAllocations
condition|)
name|numBytesUsed
operator|+=
name|INT_BLOCK_SIZE
operator|*
name|INT_NUM_BYTE
expr_stmt|;
assert|assert
name|numBytesUsed
operator|<=
name|numBytesAlloc
assert|;
return|return
name|b
return|;
block|}
DECL|method|bytesAllocated
specifier|synchronized
name|void
name|bytesAllocated
parameter_list|(
name|long
name|numBytes
parameter_list|)
block|{
name|numBytesAlloc
operator|+=
name|numBytes
expr_stmt|;
assert|assert
name|numBytesUsed
operator|<=
name|numBytesAlloc
assert|;
block|}
DECL|method|bytesUsed
specifier|synchronized
name|void
name|bytesUsed
parameter_list|(
name|long
name|numBytes
parameter_list|)
block|{
name|numBytesUsed
operator|+=
name|numBytes
expr_stmt|;
assert|assert
name|numBytesUsed
operator|<=
name|numBytesAlloc
assert|;
block|}
comment|/* Return int[]s to the pool */
DECL|method|recycleIntBlocks
specifier|synchronized
name|void
name|recycleIntBlocks
parameter_list|(
name|int
index|[]
index|[]
name|blocks
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
name|freeIntBlocks
operator|.
name|add
argument_list|(
name|blocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
DECL|field|byteBlockAllocator
name|ByteBlockAllocator
name|byteBlockAllocator
init|=
operator|new
name|ByteBlockAllocator
argument_list|()
decl_stmt|;
comment|/* Initial chunk size of the shared char[] blocks used to      store term text */
DECL|field|CHAR_BLOCK_SHIFT
specifier|final
specifier|static
name|int
name|CHAR_BLOCK_SHIFT
init|=
literal|14
decl_stmt|;
DECL|field|CHAR_BLOCK_SIZE
specifier|final
specifier|static
name|int
name|CHAR_BLOCK_SIZE
init|=
literal|1
operator|<<
name|CHAR_BLOCK_SHIFT
decl_stmt|;
DECL|field|CHAR_BLOCK_MASK
specifier|final
specifier|static
name|int
name|CHAR_BLOCK_MASK
init|=
name|CHAR_BLOCK_SIZE
operator|-
literal|1
decl_stmt|;
DECL|field|MAX_TERM_LENGTH
specifier|final
specifier|static
name|int
name|MAX_TERM_LENGTH
init|=
name|CHAR_BLOCK_SIZE
operator|-
literal|1
decl_stmt|;
DECL|field|freeCharBlocks
specifier|private
name|ArrayList
name|freeCharBlocks
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
comment|/* Allocate another char[] from the shared pool */
DECL|method|getCharBlock
specifier|synchronized
name|char
index|[]
name|getCharBlock
parameter_list|()
block|{
specifier|final
name|int
name|size
init|=
name|freeCharBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|char
index|[]
name|c
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|size
condition|)
block|{
name|numBytesAlloc
operator|+=
name|CHAR_BLOCK_SIZE
operator|*
name|CHAR_NUM_BYTE
expr_stmt|;
name|c
operator|=
operator|new
name|char
index|[
name|CHAR_BLOCK_SIZE
index|]
expr_stmt|;
block|}
else|else
name|c
operator|=
operator|(
name|char
index|[]
operator|)
name|freeCharBlocks
operator|.
name|remove
argument_list|(
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// We always track allocations of char blocks, for now,
comment|// because nothing that skips allocation tracking
comment|// (currently only term vectors) uses its own char
comment|// blocks.
name|numBytesUsed
operator|+=
name|CHAR_BLOCK_SIZE
operator|*
name|CHAR_NUM_BYTE
expr_stmt|;
assert|assert
name|numBytesUsed
operator|<=
name|numBytesAlloc
assert|;
return|return
name|c
return|;
block|}
comment|/* Return char[]s to the pool */
DECL|method|recycleCharBlocks
specifier|synchronized
name|void
name|recycleCharBlocks
parameter_list|(
name|char
index|[]
index|[]
name|blocks
parameter_list|,
name|int
name|numBlocks
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numBlocks
condition|;
name|i
operator|++
control|)
name|freeCharBlocks
operator|.
name|add
argument_list|(
name|blocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
DECL|method|toMB
name|String
name|toMB
parameter_list|(
name|long
name|v
parameter_list|)
block|{
return|return
name|nf
operator|.
name|format
argument_list|(
name|v
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
return|;
block|}
comment|/* We have three pools of RAM: Postings, byte blocks    * (holds freq/prox posting data) and char blocks (holds    * characters in the term).  Different docs require    * varying amount of storage from these three classes.    * For example, docs with many unique single-occurrence    * short terms will use up the Postings RAM and hardly any    * of the other two.  Whereas docs with very large terms    * will use alot of char blocks RAM and relatively less of    * the other two.  This method just frees allocations from    * the pools once we are over-budget, which balances the    * pools to match the current docs. */
DECL|method|balanceRAM
name|void
name|balanceRAM
parameter_list|()
block|{
comment|// We flush when we've used our target usage
specifier|final
name|long
name|flushTrigger
init|=
name|ramBufferSize
decl_stmt|;
specifier|final
name|long
name|deletesRAMUsed
init|=
name|deletesInRAM
operator|.
name|bytesUsed
operator|+
name|deletesFlushed
operator|.
name|bytesUsed
decl_stmt|;
if|if
condition|(
name|numBytesAlloc
operator|+
name|deletesRAMUsed
operator|>
name|freeTrigger
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"  RAM: now balance allocations: usedMB="
operator|+
name|toMB
argument_list|(
name|numBytesUsed
argument_list|)
operator|+
literal|" vs trigger="
operator|+
name|toMB
argument_list|(
name|flushTrigger
argument_list|)
operator|+
literal|" allocMB="
operator|+
name|toMB
argument_list|(
name|numBytesAlloc
argument_list|)
operator|+
literal|" deletesMB="
operator|+
name|toMB
argument_list|(
name|deletesRAMUsed
argument_list|)
operator|+
literal|" vs trigger="
operator|+
name|toMB
argument_list|(
name|freeTrigger
argument_list|)
operator|+
literal|" byteBlockFree="
operator|+
name|toMB
argument_list|(
name|byteBlockAllocator
operator|.
name|freeByteBlocks
operator|.
name|size
argument_list|()
operator|*
name|BYTE_BLOCK_SIZE
argument_list|)
operator|+
literal|" charBlockFree="
operator|+
name|toMB
argument_list|(
name|freeCharBlocks
operator|.
name|size
argument_list|()
operator|*
name|CHAR_BLOCK_SIZE
operator|*
name|CHAR_NUM_BYTE
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|long
name|startBytesAlloc
init|=
name|numBytesAlloc
operator|+
name|deletesRAMUsed
decl_stmt|;
name|int
name|iter
init|=
literal|0
decl_stmt|;
comment|// We free equally from each pool in 32 KB
comment|// chunks until we are below our threshold
comment|// (freeLevel)
name|boolean
name|any
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|numBytesAlloc
operator|+
name|deletesRAMUsed
operator|>
name|freeLevel
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
literal|0
operator|==
name|byteBlockAllocator
operator|.
name|freeByteBlocks
operator|.
name|size
argument_list|()
operator|&&
literal|0
operator|==
name|freeCharBlocks
operator|.
name|size
argument_list|()
operator|&&
literal|0
operator|==
name|freeIntBlocks
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|any
condition|)
block|{
comment|// Nothing else to free -- must flush now.
name|bufferIsFull
operator|=
name|numBytesUsed
operator|+
name|deletesRAMUsed
operator|>
name|flushTrigger
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|numBytesUsed
operator|>
name|flushTrigger
condition|)
name|message
argument_list|(
literal|"    nothing to free; now set bufferIsFull"
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"    nothing to free"
argument_list|)
expr_stmt|;
block|}
assert|assert
name|numBytesUsed
operator|<=
name|numBytesAlloc
assert|;
break|break;
block|}
if|if
condition|(
operator|(
literal|0
operator|==
name|iter
operator|%
literal|4
operator|)
operator|&&
name|byteBlockAllocator
operator|.
name|freeByteBlocks
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|byteBlockAllocator
operator|.
name|freeByteBlocks
operator|.
name|remove
argument_list|(
name|byteBlockAllocator
operator|.
name|freeByteBlocks
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|numBytesAlloc
operator|-=
name|BYTE_BLOCK_SIZE
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|1
operator|==
name|iter
operator|%
literal|4
operator|)
operator|&&
name|freeCharBlocks
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|freeCharBlocks
operator|.
name|remove
argument_list|(
name|freeCharBlocks
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|numBytesAlloc
operator|-=
name|CHAR_BLOCK_SIZE
operator|*
name|CHAR_NUM_BYTE
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|2
operator|==
name|iter
operator|%
literal|4
operator|)
operator|&&
name|freeIntBlocks
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|freeIntBlocks
operator|.
name|remove
argument_list|(
name|freeIntBlocks
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|numBytesAlloc
operator|-=
name|INT_BLOCK_SIZE
operator|*
name|INT_NUM_BYTE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
literal|3
operator|==
name|iter
operator|%
literal|4
operator|)
operator|&&
name|any
condition|)
comment|// Ask consumer to free any recycled state
name|any
operator|=
name|consumer
operator|.
name|freeRAM
argument_list|()
expr_stmt|;
name|iter
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"    after free: freedMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
operator|(
name|startBytesAlloc
operator|-
name|numBytesAlloc
operator|-
name|deletesRAMUsed
operator|)
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
operator|+
literal|" usedMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
operator|(
name|numBytesUsed
operator|+
name|deletesRAMUsed
operator|)
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
operator|+
literal|" allocMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|numBytesAlloc
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If we have not crossed the 100% mark, but have
comment|// crossed the 95% mark of RAM we are actually
comment|// using, go ahead and flush.  This prevents
comment|// over-allocating and then freeing, with every
comment|// flush.
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|numBytesUsed
operator|+
name|deletesRAMUsed
operator|>
name|flushTrigger
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
name|message
argument_list|(
literal|"  RAM: now flush @ usedMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|numBytesUsed
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
operator|+
literal|" allocMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|numBytesAlloc
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
operator|+
literal|" deletesMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|deletesRAMUsed
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
operator|+
literal|" triggerMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|flushTrigger
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
argument_list|)
expr_stmt|;
name|bufferIsFull
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|field|waitQueue
specifier|final
name|WaitQueue
name|waitQueue
init|=
operator|new
name|WaitQueue
argument_list|()
decl_stmt|;
DECL|class|WaitQueue
specifier|private
class|class
name|WaitQueue
block|{
DECL|field|waiting
name|DocWriter
index|[]
name|waiting
decl_stmt|;
DECL|field|nextWriteDocID
name|int
name|nextWriteDocID
decl_stmt|;
DECL|field|nextWriteLoc
name|int
name|nextWriteLoc
decl_stmt|;
DECL|field|numWaiting
name|int
name|numWaiting
decl_stmt|;
DECL|field|waitingBytes
name|long
name|waitingBytes
decl_stmt|;
DECL|method|WaitQueue
specifier|public
name|WaitQueue
parameter_list|()
block|{
name|waiting
operator|=
operator|new
name|DocWriter
index|[
literal|10
index|]
expr_stmt|;
block|}
DECL|method|reset
specifier|synchronized
name|void
name|reset
parameter_list|()
block|{
comment|// NOTE: nextWriteLoc doesn't need to be reset
assert|assert
name|numWaiting
operator|==
literal|0
assert|;
assert|assert
name|waitingBytes
operator|==
literal|0
assert|;
name|nextWriteDocID
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|doResume
specifier|synchronized
name|boolean
name|doResume
parameter_list|()
block|{
return|return
name|waitingBytes
operator|<=
name|waitQueueResumeBytes
return|;
block|}
DECL|method|doPause
specifier|synchronized
name|boolean
name|doPause
parameter_list|()
block|{
return|return
name|waitingBytes
operator|>
name|waitQueuePauseBytes
return|;
block|}
DECL|method|abort
specifier|synchronized
name|void
name|abort
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|waiting
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|DocWriter
name|doc
init|=
name|waiting
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|abort
argument_list|()
expr_stmt|;
name|waiting
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
name|waitingBytes
operator|=
literal|0
expr_stmt|;
assert|assert
name|count
operator|==
name|numWaiting
assert|;
name|numWaiting
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|writeDocument
specifier|private
name|void
name|writeDocument
parameter_list|(
name|DocWriter
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|doc
operator|==
name|skipDocWriter
operator|||
name|nextWriteDocID
operator|==
name|doc
operator|.
name|docID
assert|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|doc
operator|.
name|finish
argument_list|()
expr_stmt|;
name|nextWriteDocID
operator|++
expr_stmt|;
name|numDocsInStore
operator|++
expr_stmt|;
name|nextWriteLoc
operator|++
expr_stmt|;
assert|assert
name|nextWriteLoc
operator|<=
name|waiting
operator|.
name|length
assert|;
if|if
condition|(
name|nextWriteLoc
operator|==
name|waiting
operator|.
name|length
condition|)
name|nextWriteLoc
operator|=
literal|0
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
name|setAborting
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|add
specifier|synchronized
specifier|public
name|boolean
name|add
parameter_list|(
name|DocWriter
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|doc
operator|.
name|docID
operator|>=
name|nextWriteDocID
assert|;
if|if
condition|(
name|doc
operator|.
name|docID
operator|==
name|nextWriteDocID
condition|)
block|{
name|writeDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|doc
operator|=
name|waiting
index|[
name|nextWriteLoc
index|]
expr_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|numWaiting
operator|--
expr_stmt|;
name|waiting
index|[
name|nextWriteLoc
index|]
operator|=
literal|null
expr_stmt|;
name|waitingBytes
operator|-=
name|doc
operator|.
name|sizeInBytes
argument_list|()
expr_stmt|;
name|writeDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
else|else
block|{
comment|// I finished before documents that were added
comment|// before me.  This can easily happen when I am a
comment|// small doc and the docs before me were large, or,
comment|// just due to luck in the thread scheduling.  Just
comment|// add myself to the queue and when that large doc
comment|// finishes, it will flush me:
name|int
name|gap
init|=
name|doc
operator|.
name|docID
operator|-
name|nextWriteDocID
decl_stmt|;
if|if
condition|(
name|gap
operator|>=
name|waiting
operator|.
name|length
condition|)
block|{
comment|// Grow queue
name|DocWriter
index|[]
name|newArray
init|=
operator|new
name|DocWriter
index|[
name|ArrayUtil
operator|.
name|getNextSize
argument_list|(
name|gap
argument_list|)
index|]
decl_stmt|;
assert|assert
name|nextWriteLoc
operator|>=
literal|0
assert|;
name|System
operator|.
name|arraycopy
argument_list|(
name|waiting
argument_list|,
name|nextWriteLoc
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|waiting
operator|.
name|length
operator|-
name|nextWriteLoc
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|waiting
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
name|waiting
operator|.
name|length
operator|-
name|nextWriteLoc
argument_list|,
name|nextWriteLoc
argument_list|)
expr_stmt|;
name|nextWriteLoc
operator|=
literal|0
expr_stmt|;
name|waiting
operator|=
name|newArray
expr_stmt|;
name|gap
operator|=
name|doc
operator|.
name|docID
operator|-
name|nextWriteDocID
expr_stmt|;
block|}
name|int
name|loc
init|=
name|nextWriteLoc
operator|+
name|gap
decl_stmt|;
if|if
condition|(
name|loc
operator|>=
name|waiting
operator|.
name|length
condition|)
name|loc
operator|-=
name|waiting
operator|.
name|length
expr_stmt|;
comment|// We should only wrap one time
assert|assert
name|loc
operator|<
name|waiting
operator|.
name|length
assert|;
comment|// Nobody should be in my spot!
assert|assert
name|waiting
index|[
name|loc
index|]
operator|==
literal|null
assert|;
name|waiting
index|[
name|loc
index|]
operator|=
name|doc
expr_stmt|;
name|numWaiting
operator|++
expr_stmt|;
name|waitingBytes
operator|+=
name|doc
operator|.
name|sizeInBytes
argument_list|()
expr_stmt|;
block|}
return|return
name|doPause
argument_list|()
return|;
block|}
block|}
block|}
end_class
end_unit
