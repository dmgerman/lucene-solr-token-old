begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldSelector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Lock
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|LockObtainFailedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_comment
comment|/** IndexReader is an abstract class, providing an interface for accessing an  index.  Search of an index is done entirely through this abstract interface,  so that any subclass which implements it is searchable.<p> Concrete subclasses of IndexReader are usually constructed with a call to  one of the static<code>open()</code> methods, e.g. {@link #open(String)}.<p> For efficiency, in this API documents are often referred to via<i>document numbers</i>, non-negative integers which each name a unique  document in the index.  These document numbers are ephemeral--they may change  as documents are added to and deleted from an index.  Clients should thus not  rely on a given document having the same number between sessions.<p> An IndexReader can be opened on a directory for which an IndexWriter is  opened already, but it cannot be used to delete documents from the index then.   @author Doug Cutting  @version $Id$ */
end_comment
begin_class
DECL|class|IndexReader
specifier|public
specifier|abstract
class|class
name|IndexReader
block|{
DECL|class|FieldOption
specifier|public
specifier|static
specifier|final
class|class
name|FieldOption
block|{
DECL|field|option
specifier|private
name|String
name|option
decl_stmt|;
DECL|method|FieldOption
specifier|private
name|FieldOption
parameter_list|()
block|{ }
DECL|method|FieldOption
specifier|private
name|FieldOption
parameter_list|(
name|String
name|option
parameter_list|)
block|{
name|this
operator|.
name|option
operator|=
name|option
expr_stmt|;
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|option
return|;
block|}
comment|// all fields
DECL|field|ALL
specifier|public
specifier|static
specifier|final
name|FieldOption
name|ALL
init|=
operator|new
name|FieldOption
argument_list|(
literal|"ALL"
argument_list|)
decl_stmt|;
comment|// all indexed fields
DECL|field|INDEXED
specifier|public
specifier|static
specifier|final
name|FieldOption
name|INDEXED
init|=
operator|new
name|FieldOption
argument_list|(
literal|"INDEXED"
argument_list|)
decl_stmt|;
comment|// all fields that store payloads
DECL|field|STORES_PAYLOADS
specifier|public
specifier|static
specifier|final
name|FieldOption
name|STORES_PAYLOADS
init|=
operator|new
name|FieldOption
argument_list|(
literal|"STORES_PAYLOADS"
argument_list|)
decl_stmt|;
comment|// all fields which are not indexed
DECL|field|UNINDEXED
specifier|public
specifier|static
specifier|final
name|FieldOption
name|UNINDEXED
init|=
operator|new
name|FieldOption
argument_list|(
literal|"UNINDEXED"
argument_list|)
decl_stmt|;
comment|// all fields which are indexed with termvectors enables
DECL|field|INDEXED_WITH_TERMVECTOR
specifier|public
specifier|static
specifier|final
name|FieldOption
name|INDEXED_WITH_TERMVECTOR
init|=
operator|new
name|FieldOption
argument_list|(
literal|"INDEXED_WITH_TERMVECTOR"
argument_list|)
decl_stmt|;
comment|// all fields which are indexed but don't have termvectors enabled
DECL|field|INDEXED_NO_TERMVECTOR
specifier|public
specifier|static
specifier|final
name|FieldOption
name|INDEXED_NO_TERMVECTOR
init|=
operator|new
name|FieldOption
argument_list|(
literal|"INDEXED_NO_TERMVECTOR"
argument_list|)
decl_stmt|;
comment|// all fields where termvectors are enabled. Please note that only standard termvector fields are returned
DECL|field|TERMVECTOR
specifier|public
specifier|static
specifier|final
name|FieldOption
name|TERMVECTOR
init|=
operator|new
name|FieldOption
argument_list|(
literal|"TERMVECTOR"
argument_list|)
decl_stmt|;
comment|// all field with termvectors wiht positions enabled
DECL|field|TERMVECTOR_WITH_POSITION
specifier|public
specifier|static
specifier|final
name|FieldOption
name|TERMVECTOR_WITH_POSITION
init|=
operator|new
name|FieldOption
argument_list|(
literal|"TERMVECTOR_WITH_POSITION"
argument_list|)
decl_stmt|;
comment|// all fields where termvectors with offset position are set
DECL|field|TERMVECTOR_WITH_OFFSET
specifier|public
specifier|static
specifier|final
name|FieldOption
name|TERMVECTOR_WITH_OFFSET
init|=
operator|new
name|FieldOption
argument_list|(
literal|"TERMVECTOR_WITH_OFFSET"
argument_list|)
decl_stmt|;
comment|// all fields where termvectors with offset and position values set
DECL|field|TERMVECTOR_WITH_POSITION_OFFSET
specifier|public
specifier|static
specifier|final
name|FieldOption
name|TERMVECTOR_WITH_POSITION_OFFSET
init|=
operator|new
name|FieldOption
argument_list|(
literal|"TERMVECTOR_WITH_POSITION_OFFSET"
argument_list|)
decl_stmt|;
block|}
comment|/**    * Constructor used if IndexReader is not owner of its directory.     * This is used for IndexReaders that are used within other IndexReaders that take care or locking directories.    *     * @param directory Directory where IndexReader files reside.    */
DECL|method|IndexReader
specifier|protected
name|IndexReader
parameter_list|(
name|Directory
name|directory
parameter_list|)
block|{
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
block|}
comment|/**    * Constructor used if IndexReader is owner of its directory.    * If IndexReader is owner of its directory, it locks its directory in case of write operations.    *     * @param directory Directory where IndexReader files reside.    * @param segmentInfos Used for write-l    * @param closeDirectory    */
DECL|method|IndexReader
name|IndexReader
parameter_list|(
name|Directory
name|directory
parameter_list|,
name|SegmentInfos
name|segmentInfos
parameter_list|,
name|boolean
name|closeDirectory
parameter_list|)
block|{
name|init
argument_list|(
name|directory
argument_list|,
name|segmentInfos
argument_list|,
name|closeDirectory
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|init
name|void
name|init
parameter_list|(
name|Directory
name|directory
parameter_list|,
name|SegmentInfos
name|segmentInfos
parameter_list|,
name|boolean
name|closeDirectory
parameter_list|,
name|boolean
name|directoryOwner
parameter_list|)
block|{
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
name|this
operator|.
name|segmentInfos
operator|=
name|segmentInfos
expr_stmt|;
name|this
operator|.
name|directoryOwner
operator|=
name|directoryOwner
expr_stmt|;
name|this
operator|.
name|closeDirectory
operator|=
name|closeDirectory
expr_stmt|;
block|}
DECL|field|directory
specifier|private
name|Directory
name|directory
decl_stmt|;
DECL|field|directoryOwner
specifier|private
name|boolean
name|directoryOwner
decl_stmt|;
DECL|field|closeDirectory
specifier|private
name|boolean
name|closeDirectory
decl_stmt|;
DECL|field|deletionPolicy
specifier|private
name|IndexDeletionPolicy
name|deletionPolicy
decl_stmt|;
DECL|field|closed
specifier|private
name|boolean
name|closed
decl_stmt|;
comment|/**    * @throws AlreadyClosedException if this IndexReader is closed    */
DECL|method|ensureOpen
specifier|protected
specifier|final
name|void
name|ensureOpen
parameter_list|()
throws|throws
name|AlreadyClosedException
block|{
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|AlreadyClosedException
argument_list|(
literal|"this IndexReader is closed"
argument_list|)
throw|;
block|}
block|}
DECL|field|segmentInfos
specifier|private
name|SegmentInfos
name|segmentInfos
decl_stmt|;
DECL|field|writeLock
specifier|private
name|Lock
name|writeLock
decl_stmt|;
DECL|field|stale
specifier|private
name|boolean
name|stale
decl_stmt|;
DECL|field|hasChanges
specifier|private
name|boolean
name|hasChanges
decl_stmt|;
comment|/** Used by commit() to record pre-commit state in case    * rollback is necessary */
DECL|field|rollbackHasChanges
specifier|private
name|boolean
name|rollbackHasChanges
decl_stmt|;
DECL|field|rollbackSegmentInfos
specifier|private
name|SegmentInfos
name|rollbackSegmentInfos
decl_stmt|;
comment|/** Returns an IndexReader reading the index in an FSDirectory in the named    path.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    * @param path the path to the index directory */
DECL|method|open
specifier|public
specifier|static
name|IndexReader
name|open
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|FSDirectory
operator|.
name|getDirectory
argument_list|(
name|path
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Returns an IndexReader reading the index in an FSDirectory in the named    * path.    * @param path the path to the index directory    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|open
specifier|public
specifier|static
name|IndexReader
name|open
parameter_list|(
name|File
name|path
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|FSDirectory
operator|.
name|getDirectory
argument_list|(
name|path
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Returns an IndexReader reading the index in the given Directory.    * @param directory the index directory    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|open
specifier|public
specifier|static
name|IndexReader
name|open
parameter_list|(
specifier|final
name|Directory
name|directory
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|directory
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Expert: returns an IndexReader reading the index in the given    * Directory, with a custom {@link IndexDeletionPolicy}.    * @param directory the index directory    * @param deletionPolicy a custom deletion policy (only used    *  if you use this reader to perform deletes or to set    *  norms); see {@link IndexWriter} for details.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|open
specifier|public
specifier|static
name|IndexReader
name|open
parameter_list|(
specifier|final
name|Directory
name|directory
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|directory
argument_list|,
literal|false
argument_list|,
name|deletionPolicy
argument_list|)
return|;
block|}
DECL|method|open
specifier|private
specifier|static
name|IndexReader
name|open
parameter_list|(
specifier|final
name|Directory
name|directory
parameter_list|,
specifier|final
name|boolean
name|closeDirectory
parameter_list|,
specifier|final
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
operator|(
name|IndexReader
operator|)
operator|new
name|SegmentInfos
operator|.
name|FindSegmentsFile
argument_list|(
name|directory
argument_list|)
block|{
specifier|protected
name|Object
name|doBody
parameter_list|(
name|String
name|segmentFileName
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|SegmentInfos
name|infos
init|=
operator|new
name|SegmentInfos
argument_list|()
decl_stmt|;
name|infos
operator|.
name|read
argument_list|(
name|directory
argument_list|,
name|segmentFileName
argument_list|)
expr_stmt|;
name|IndexReader
name|reader
decl_stmt|;
if|if
condition|(
name|infos
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// index is optimized
name|reader
operator|=
name|SegmentReader
operator|.
name|get
argument_list|(
name|infos
argument_list|,
name|infos
operator|.
name|info
argument_list|(
literal|0
argument_list|)
argument_list|,
name|closeDirectory
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// To reduce the chance of hitting FileNotFound
comment|// (and having to retry), we open segments in
comment|// reverse because IndexWriter merges& deletes
comment|// the newest segments first.
name|IndexReader
index|[]
name|readers
init|=
operator|new
name|IndexReader
index|[
name|infos
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|infos
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
try|try
block|{
name|readers
index|[
name|i
index|]
operator|=
name|SegmentReader
operator|.
name|get
argument_list|(
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Close all readers we had opened:
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|infos
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|readers
index|[
name|i
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
name|reader
operator|=
operator|new
name|MultiReader
argument_list|(
name|directory
argument_list|,
name|infos
argument_list|,
name|closeDirectory
argument_list|,
name|readers
argument_list|)
expr_stmt|;
block|}
name|reader
operator|.
name|deletionPolicy
operator|=
name|deletionPolicy
expr_stmt|;
return|return
name|reader
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
comment|/** Returns the directory this index resides in.    */
DECL|method|directory
specifier|public
name|Directory
name|directory
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|directory
return|;
block|}
comment|/**    * Returns the time the index in the named directory was last modified.    * Do not use this to check whether the reader is still up-to-date, use    * {@link #isCurrent()} instead.     * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|lastModified
specifier|public
specifier|static
name|long
name|lastModified
parameter_list|(
name|String
name|directory
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|lastModified
argument_list|(
operator|new
name|File
argument_list|(
name|directory
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns the time the index in the named directory was last modified.     * Do not use this to check whether the reader is still up-to-date, use    * {@link #isCurrent()} instead.     * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|lastModified
specifier|public
specifier|static
name|long
name|lastModified
parameter_list|(
name|File
name|fileDirectory
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
operator|(
operator|(
name|Long
operator|)
operator|new
name|SegmentInfos
operator|.
name|FindSegmentsFile
argument_list|(
name|fileDirectory
argument_list|)
block|{
specifier|public
name|Object
name|doBody
parameter_list|(
name|String
name|segmentFileName
parameter_list|)
block|{
return|return
operator|new
name|Long
argument_list|(
name|FSDirectory
operator|.
name|fileModified
argument_list|(
name|fileDirectory
argument_list|,
name|segmentFileName
argument_list|)
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|()
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
comment|/**    * Returns the time the index in the named directory was last modified.     * Do not use this to check whether the reader is still up-to-date, use    * {@link #isCurrent()} instead.     * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|lastModified
specifier|public
specifier|static
name|long
name|lastModified
parameter_list|(
specifier|final
name|Directory
name|directory2
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
operator|(
operator|(
name|Long
operator|)
operator|new
name|SegmentInfos
operator|.
name|FindSegmentsFile
argument_list|(
name|directory2
argument_list|)
block|{
specifier|public
name|Object
name|doBody
parameter_list|(
name|String
name|segmentFileName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|Long
argument_list|(
name|directory2
operator|.
name|fileModified
argument_list|(
name|segmentFileName
argument_list|)
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|()
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
comment|/**    * Reads version number from segments files. The version number is    * initialized with a timestamp and then increased by one for each change of    * the index.    *     * @param directory where the index resides.    * @return version number.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|getCurrentVersion
specifier|public
specifier|static
name|long
name|getCurrentVersion
parameter_list|(
name|String
name|directory
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|getCurrentVersion
argument_list|(
operator|new
name|File
argument_list|(
name|directory
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Reads version number from segments files. The version number is    * initialized with a timestamp and then increased by one for each change of    * the index.    *     * @param directory where the index resides.    * @return version number.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|getCurrentVersion
specifier|public
specifier|static
name|long
name|getCurrentVersion
parameter_list|(
name|File
name|directory
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|Directory
name|dir
init|=
name|FSDirectory
operator|.
name|getDirectory
argument_list|(
name|directory
argument_list|)
decl_stmt|;
name|long
name|version
init|=
name|getCurrentVersion
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|version
return|;
block|}
comment|/**    * Reads version number from segments files. The version number is    * initialized with a timestamp and then increased by one for each change of    * the index.    *     * @param directory where the index resides.    * @return version number.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|getCurrentVersion
specifier|public
specifier|static
name|long
name|getCurrentVersion
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|SegmentInfos
operator|.
name|readCurrentVersion
argument_list|(
name|directory
argument_list|)
return|;
block|}
comment|/**    * Version number when this IndexReader was opened.    */
DECL|method|getVersion
specifier|public
name|long
name|getVersion
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|segmentInfos
operator|.
name|getVersion
argument_list|()
return|;
block|}
comment|/**    * Check whether this IndexReader is still using the    * current (i.e., most recently committed) version of the    * index.  If a writer has committed any changes to the    * index since this reader was opened, this will return    *<code>false</code>, in which case you must open a new    * IndexReader in order to see the changes.  See the    * description of the<a href="IndexWriter.html#autoCommit"><code>autoCommit</code></a>    * flag which controls when the {@link IndexWriter}    * actually commits changes to the index.    *     * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|isCurrent
specifier|public
name|boolean
name|isCurrent
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|SegmentInfos
operator|.
name|readCurrentVersion
argument_list|(
name|directory
argument_list|)
operator|==
name|segmentInfos
operator|.
name|getVersion
argument_list|()
return|;
block|}
comment|/**    * Checks is the index is optimized (if it has a single segment and no deletions)    * @return<code>true</code> if the index is optimized;<code>false</code> otherwise    */
DECL|method|isOptimized
specifier|public
name|boolean
name|isOptimized
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|segmentInfos
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|hasDeletions
argument_list|()
operator|==
literal|false
return|;
block|}
comment|/**    *  Return an array of term frequency vectors for the specified document.    *  The array contains a vector for each vectorized field in the document.    *  Each vector contains terms and frequencies for all terms in a given vectorized field.    *  If no such fields existed, the method returns null. The term vectors that are    * returned my either be of type TermFreqVector or of type TermPositionsVector if    * positions or offsets have been stored.    *     * @param docNumber document for which term frequency vectors are returned    * @return array of term frequency vectors. May be null if no term vectors have been    *  stored for the specified document.    * @throws IOException if index cannot be accessed    * @see org.apache.lucene.document.Field.TermVector    */
DECL|method|getTermFreqVectors
specifier|abstract
specifier|public
name|TermFreqVector
index|[]
name|getTermFreqVectors
parameter_list|(
name|int
name|docNumber
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    *  Return a term frequency vector for the specified document and field. The    *  returned vector contains terms and frequencies for the terms in    *  the specified field of this document, if the field had the storeTermVector    *  flag set. If termvectors had been stored with positions or offsets, a     *  TermPositionsVector is returned.    *     * @param docNumber document for which the term frequency vector is returned    * @param field field for which the term frequency vector is returned.    * @return term frequency vector May be null if field does not exist in the specified    * document or term vector was not stored.    * @throws IOException if index cannot be accessed    * @see org.apache.lucene.document.Field.TermVector    */
DECL|method|getTermFreqVector
specifier|abstract
specifier|public
name|TermFreqVector
name|getTermFreqVector
parameter_list|(
name|int
name|docNumber
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Returns<code>true</code> if an index exists at the specified directory.    * If the directory does not exist or if there is no index in it.    *<code>false</code> is returned.    * @param  directory the directory to check for an index    * @return<code>true</code> if an index exists;<code>false</code> otherwise    */
DECL|method|indexExists
specifier|public
specifier|static
name|boolean
name|indexExists
parameter_list|(
name|String
name|directory
parameter_list|)
block|{
return|return
name|indexExists
argument_list|(
operator|new
name|File
argument_list|(
name|directory
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns<code>true</code> if an index exists at the specified directory.    * If the directory does not exist or if there is no index in it.    * @param  directory the directory to check for an index    * @return<code>true</code> if an index exists;<code>false</code> otherwise    */
DECL|method|indexExists
specifier|public
specifier|static
name|boolean
name|indexExists
parameter_list|(
name|File
name|directory
parameter_list|)
block|{
return|return
name|SegmentInfos
operator|.
name|getCurrentSegmentGeneration
argument_list|(
name|directory
operator|.
name|list
argument_list|()
argument_list|)
operator|!=
operator|-
literal|1
return|;
block|}
comment|/**    * Returns<code>true</code> if an index exists at the specified directory.    * If the directory does not exist or if there is no index in it.    * @param  directory the directory to check for an index    * @return<code>true</code> if an index exists;<code>false</code> otherwise    * @throws IOException if there is a problem with accessing the index    */
DECL|method|indexExists
specifier|public
specifier|static
name|boolean
name|indexExists
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|SegmentInfos
operator|.
name|getCurrentSegmentGeneration
argument_list|(
name|directory
argument_list|)
operator|!=
operator|-
literal|1
return|;
block|}
comment|/** Returns the number of documents in this index. */
DECL|method|numDocs
specifier|public
specifier|abstract
name|int
name|numDocs
parameter_list|()
function_decl|;
comment|/** Returns one greater than the largest possible document number.    * This may be used to, e.g., determine how big to allocate an array which    * will have an element for every document number in an index.    */
DECL|method|maxDoc
specifier|public
specifier|abstract
name|int
name|maxDoc
parameter_list|()
function_decl|;
comment|/** Returns the stored fields of the<code>n</code><sup>th</sup><code>Document</code> in this index.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|document
specifier|public
name|Document
name|document
parameter_list|(
name|int
name|n
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|document
argument_list|(
name|n
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Get the {@link org.apache.lucene.document.Document} at the<code>n</code><sup>th</sup> position. The {@link org.apache.lucene.document.FieldSelector}    * may be used to determine what {@link org.apache.lucene.document.Field}s to load and how they should be loaded.    *     *<b>NOTE:</b> If this Reader (more specifically, the underlying<code>FieldsReader</code>) is closed before the lazy {@link org.apache.lucene.document.Field} is    * loaded an exception may be thrown.  If you want the value of a lazy {@link org.apache.lucene.document.Field} to be available after closing you must    * explicitly load it or fetch the Document again with a new loader.    *     *      * @param n Get the document at the<code>n</code><sup>th</sup> position    * @param fieldSelector The {@link org.apache.lucene.document.FieldSelector} to use to determine what Fields should be loaded on the Document.  May be null, in which case all Fields will be loaded.    * @return The stored fields of the {@link org.apache.lucene.document.Document} at the nth position    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    *     * @see org.apache.lucene.document.Fieldable    * @see org.apache.lucene.document.FieldSelector    * @see org.apache.lucene.document.SetBasedFieldSelector    * @see org.apache.lucene.document.LoadFirstFieldSelector    */
comment|//When we convert to JDK 1.5 make this Set<String>
DECL|method|document
specifier|public
specifier|abstract
name|Document
name|document
parameter_list|(
name|int
name|n
parameter_list|,
name|FieldSelector
name|fieldSelector
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
function_decl|;
comment|/** Returns true if document<i>n</i> has been deleted */
DECL|method|isDeleted
specifier|public
specifier|abstract
name|boolean
name|isDeleted
parameter_list|(
name|int
name|n
parameter_list|)
function_decl|;
comment|/** Returns true if any documents have been deleted */
DECL|method|hasDeletions
specifier|public
specifier|abstract
name|boolean
name|hasDeletions
parameter_list|()
function_decl|;
comment|/** Returns true if there are norms stored for this field. */
DECL|method|hasNorms
specifier|public
name|boolean
name|hasNorms
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
comment|// backward compatible implementation.
comment|// SegmentReader has an efficient implementation.
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|norms
argument_list|(
name|field
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/** Returns the byte-encoded normalization factor for the named field of    * every document.  This is used by the search code to score documents.    *    * @see org.apache.lucene.document.Field#setBoost(float)    */
DECL|method|norms
specifier|public
specifier|abstract
name|byte
index|[]
name|norms
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Reads the byte-encoded normalization factor for the named field of every    *  document.  This is used by the search code to score documents.    *    * @see org.apache.lucene.document.Field#setBoost(float)    */
DECL|method|norms
specifier|public
specifier|abstract
name|void
name|norms
parameter_list|(
name|String
name|field
parameter_list|,
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Expert: Resets the normalization factor for the named field of the named    * document.  The norm represents the product of the field's {@link    * org.apache.lucene.document.Fieldable#setBoost(float) boost} and its {@link Similarity#lengthNorm(String,    * int) length normalization}.  Thus, to preserve the length normalization    * values when resetting this, one should base the new value upon the old.    *    * @see #norms(String)    * @see Similarity#decodeNorm(byte)    * @throws StaleReaderException if the index has changed    *  since this reader was opened    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if there is a low-level IO error    */
DECL|method|setNorm
specifier|public
specifier|final
specifier|synchronized
name|void
name|setNorm
parameter_list|(
name|int
name|doc
parameter_list|,
name|String
name|field
parameter_list|,
name|byte
name|value
parameter_list|)
throws|throws
name|StaleReaderException
throws|,
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|directoryOwner
condition|)
name|acquireWriteLock
argument_list|()
expr_stmt|;
name|hasChanges
operator|=
literal|true
expr_stmt|;
name|doSetNorm
argument_list|(
name|doc
argument_list|,
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** Implements setNorm in subclass.*/
DECL|method|doSetNorm
specifier|protected
specifier|abstract
name|void
name|doSetNorm
parameter_list|(
name|int
name|doc
parameter_list|,
name|String
name|field
parameter_list|,
name|byte
name|value
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
function_decl|;
comment|/** Expert: Resets the normalization factor for the named field of the named    * document.    *    * @see #norms(String)    * @see Similarity#decodeNorm(byte)    *     * @throws StaleReaderException if the index has changed    *  since this reader was opened    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if there is a low-level IO error    */
DECL|method|setNorm
specifier|public
name|void
name|setNorm
parameter_list|(
name|int
name|doc
parameter_list|,
name|String
name|field
parameter_list|,
name|float
name|value
parameter_list|)
throws|throws
name|StaleReaderException
throws|,
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|setNorm
argument_list|(
name|doc
argument_list|,
name|field
argument_list|,
name|Similarity
operator|.
name|encodeNorm
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Returns an enumeration of all the terms in the index. The    * enumeration is ordered by Term.compareTo(). Each term is greater    * than all that precede it in the enumeration. Note that after    * calling terms(), {@link TermEnum#next()} must be called    * on the resulting enumeration before calling other methods such as    * {@link TermEnum#term()}.    * @throws IOException if there is a low-level IO error    */
DECL|method|terms
specifier|public
specifier|abstract
name|TermEnum
name|terms
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Returns an enumeration of all terms starting at a given term. If    * the given term does not exist, the enumeration is positioned at the    * first term greater than the supplied therm. The enumeration is    * ordered by Term.compareTo(). Each term is greater than all that    * precede it in the enumeration.    * @throws IOException if there is a low-level IO error    */
DECL|method|terms
specifier|public
specifier|abstract
name|TermEnum
name|terms
parameter_list|(
name|Term
name|t
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Returns the number of documents containing the term<code>t</code>.    * @throws IOException if there is a low-level IO error    */
DECL|method|docFreq
specifier|public
specifier|abstract
name|int
name|docFreq
parameter_list|(
name|Term
name|t
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Returns an enumeration of all the documents which contain    *<code>term</code>. For each document, the document number, the frequency of    * the term in that document is also provided, for use in search scoring.    * Thus, this method implements the mapping:    *<p><ul>    * Term&nbsp;&nbsp; =&gt;&nbsp;&nbsp;&lt;docNum, freq&gt;<sup>*</sup>    *</ul>    *<p>The enumeration is ordered by document number.  Each document number    * is greater than all that precede it in the enumeration.    * @throws IOException if there is a low-level IO error    */
DECL|method|termDocs
specifier|public
name|TermDocs
name|termDocs
parameter_list|(
name|Term
name|term
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|TermDocs
name|termDocs
init|=
name|termDocs
argument_list|()
decl_stmt|;
name|termDocs
operator|.
name|seek
argument_list|(
name|term
argument_list|)
expr_stmt|;
return|return
name|termDocs
return|;
block|}
comment|/** Returns an unpositioned {@link TermDocs} enumerator.    * @throws IOException if there is a low-level IO error    */
DECL|method|termDocs
specifier|public
specifier|abstract
name|TermDocs
name|termDocs
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Returns an enumeration of all the documents which contain    *<code>term</code>.  For each document, in addition to the document number    * and frequency of the term in that document, a list of all of the ordinal    * positions of the term in the document is available.  Thus, this method    * implements the mapping:    *    *<p><ul>    * Term&nbsp;&nbsp; =&gt;&nbsp;&nbsp;&lt;docNum, freq,    *&lt;pos<sub>1</sub>, pos<sub>2</sub>, ...    * pos<sub>freq-1</sub>&gt;    *&gt;<sup>*</sup>    *</ul>    *<p> This positional information faciliates phrase and proximity searching.    *<p>The enumeration is ordered by document number.  Each document number is    * greater than all that precede it in the enumeration.    * @throws IOException if there is a low-level IO error    */
DECL|method|termPositions
specifier|public
name|TermPositions
name|termPositions
parameter_list|(
name|Term
name|term
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|TermPositions
name|termPositions
init|=
name|termPositions
argument_list|()
decl_stmt|;
name|termPositions
operator|.
name|seek
argument_list|(
name|term
argument_list|)
expr_stmt|;
return|return
name|termPositions
return|;
block|}
comment|/** Returns an unpositioned {@link TermPositions} enumerator.    * @throws IOException if there is a low-level IO error    */
DECL|method|termPositions
specifier|public
specifier|abstract
name|TermPositions
name|termPositions
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * Tries to acquire the WriteLock on this directory.    * this method is only valid if this IndexReader is directory owner.    *     * @throws StaleReaderException if the index has changed    * since this reader was opened    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if there is a low-level IO error    */
DECL|method|acquireWriteLock
specifier|private
name|void
name|acquireWriteLock
parameter_list|()
throws|throws
name|StaleReaderException
throws|,
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|stale
condition|)
throw|throw
operator|new
name|StaleReaderException
argument_list|(
literal|"IndexReader out of date and no longer valid for delete, undelete, or setNorm operations"
argument_list|)
throw|;
if|if
condition|(
name|writeLock
operator|==
literal|null
condition|)
block|{
name|Lock
name|writeLock
init|=
name|directory
operator|.
name|makeLock
argument_list|(
name|IndexWriter
operator|.
name|WRITE_LOCK_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|writeLock
operator|.
name|obtain
argument_list|(
name|IndexWriter
operator|.
name|WRITE_LOCK_TIMEOUT
argument_list|)
condition|)
comment|// obtain write lock
throw|throw
operator|new
name|LockObtainFailedException
argument_list|(
literal|"Index locked for write: "
operator|+
name|writeLock
argument_list|)
throw|;
name|this
operator|.
name|writeLock
operator|=
name|writeLock
expr_stmt|;
comment|// we have to check whether index has changed since this reader was opened.
comment|// if so, this reader is no longer valid for deletion
if|if
condition|(
name|SegmentInfos
operator|.
name|readCurrentVersion
argument_list|(
name|directory
argument_list|)
operator|>
name|segmentInfos
operator|.
name|getVersion
argument_list|()
condition|)
block|{
name|stale
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|writeLock
operator|.
name|release
argument_list|()
expr_stmt|;
name|this
operator|.
name|writeLock
operator|=
literal|null
expr_stmt|;
throw|throw
operator|new
name|StaleReaderException
argument_list|(
literal|"IndexReader out of date and no longer valid for delete, undelete, or setNorm operations"
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Deletes the document numbered<code>docNum</code>.  Once a document is    * deleted it will not appear in TermDocs or TermPostitions enumerations.    * Attempts to read its field with the {@link #document}    * method will result in an error.  The presence of this document may still be    * reflected in the {@link #docFreq} statistic, though    * this will be corrected eventually as the index is further modified.    *    * @throws StaleReaderException if the index has changed    * since this reader was opened    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if there is a low-level IO error    */
DECL|method|deleteDocument
specifier|public
specifier|final
specifier|synchronized
name|void
name|deleteDocument
parameter_list|(
name|int
name|docNum
parameter_list|)
throws|throws
name|StaleReaderException
throws|,
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|directoryOwner
condition|)
name|acquireWriteLock
argument_list|()
expr_stmt|;
name|hasChanges
operator|=
literal|true
expr_stmt|;
name|doDelete
argument_list|(
name|docNum
argument_list|)
expr_stmt|;
block|}
comment|/** Implements deletion of the document numbered<code>docNum</code>.    * Applications should call {@link #deleteDocument(int)} or {@link #deleteDocuments(Term)}.    */
DECL|method|doDelete
specifier|protected
specifier|abstract
name|void
name|doDelete
parameter_list|(
name|int
name|docNum
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
function_decl|;
comment|/** Deletes all documents that have a given<code>term</code> indexed.    * This is useful if one uses a document field to hold a unique ID string for    * the document.  Then to delete such a document, one merely constructs a    * term with the appropriate field and the unique ID string as its text and    * passes it to this method.    * See {@link #deleteDocument(int)} for information about when this deletion will     * become effective.    *    * @return the number of documents deleted    * @throws StaleReaderException if the index has changed    *  since this reader was opened    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if there is a low-level IO error    */
DECL|method|deleteDocuments
specifier|public
specifier|final
name|int
name|deleteDocuments
parameter_list|(
name|Term
name|term
parameter_list|)
throws|throws
name|StaleReaderException
throws|,
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|TermDocs
name|docs
init|=
name|termDocs
argument_list|(
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
name|docs
operator|==
literal|null
condition|)
return|return
literal|0
return|;
name|int
name|n
init|=
literal|0
decl_stmt|;
try|try
block|{
while|while
condition|(
name|docs
operator|.
name|next
argument_list|()
condition|)
block|{
name|deleteDocument
argument_list|(
name|docs
operator|.
name|doc
argument_list|()
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|docs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
comment|/** Undeletes all documents currently marked as deleted in this index.    *    * @throws StaleReaderException if the index has changed    *  since this reader was opened    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|undeleteAll
specifier|public
specifier|final
specifier|synchronized
name|void
name|undeleteAll
parameter_list|()
throws|throws
name|StaleReaderException
throws|,
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|directoryOwner
condition|)
name|acquireWriteLock
argument_list|()
expr_stmt|;
name|hasChanges
operator|=
literal|true
expr_stmt|;
name|doUndeleteAll
argument_list|()
expr_stmt|;
block|}
comment|/** Implements actual undeleteAll() in subclass. */
DECL|method|doUndeleteAll
specifier|protected
specifier|abstract
name|void
name|doUndeleteAll
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
function_decl|;
comment|/**    * Should internally checkpoint state that will change    * during commit so that we can rollback if necessary.    */
DECL|method|startCommit
name|void
name|startCommit
parameter_list|()
block|{
if|if
condition|(
name|directoryOwner
condition|)
block|{
name|rollbackSegmentInfos
operator|=
operator|(
name|SegmentInfos
operator|)
name|segmentInfos
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
name|rollbackHasChanges
operator|=
name|hasChanges
expr_stmt|;
block|}
comment|/**    * Rolls back state to just before the commit (this is    * called by commit() if there is some exception while    * committing).    */
DECL|method|rollbackCommit
name|void
name|rollbackCommit
parameter_list|()
block|{
if|if
condition|(
name|directoryOwner
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segmentInfos
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// Rollback each segmentInfo.  Because the
comment|// SegmentReader holds a reference to the
comment|// SegmentInfo we can't [easily] just replace
comment|// segmentInfos, so we reset it in place instead:
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
operator|.
name|reset
argument_list|(
name|rollbackSegmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rollbackSegmentInfos
operator|=
literal|null
expr_stmt|;
block|}
name|hasChanges
operator|=
name|rollbackHasChanges
expr_stmt|;
block|}
comment|/**    * Commit changes resulting from delete, undeleteAll, or    * setNorm operations    *    * If an exception is hit, then either no changes or all    * changes will have been committed to the index    * (transactional semantics).    * @throws IOException if there is a low-level IO error    */
DECL|method|commit
specifier|protected
specifier|final
specifier|synchronized
name|void
name|commit
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|hasChanges
condition|)
block|{
if|if
condition|(
name|directoryOwner
condition|)
block|{
comment|// Default deleter (for backwards compatibility) is
comment|// KeepOnlyLastCommitDeleter:
name|IndexFileDeleter
name|deleter
init|=
operator|new
name|IndexFileDeleter
argument_list|(
name|directory
argument_list|,
name|deletionPolicy
operator|==
literal|null
condition|?
operator|new
name|KeepOnlyLastCommitDeletionPolicy
argument_list|()
else|:
name|deletionPolicy
argument_list|,
name|segmentInfos
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// Checkpoint the state we are about to change, in
comment|// case we have to roll back:
name|startCommit
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|doCommit
argument_list|()
expr_stmt|;
name|segmentInfos
operator|.
name|write
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// Rollback changes that were made to
comment|// SegmentInfos but failed to get [fully]
comment|// committed.  This way this reader instance
comment|// remains consistent (matched to what's
comment|// actually in the index):
name|rollbackCommit
argument_list|()
expr_stmt|;
comment|// Recompute deletable files& remove them (so
comment|// partially written .del files, etc, are
comment|// removed):
name|deleter
operator|.
name|refresh
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Have the deleter remove any now unreferenced
comment|// files due to this commit:
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|writeLock
operator|!=
literal|null
condition|)
block|{
name|writeLock
operator|.
name|release
argument_list|()
expr_stmt|;
comment|// release write lock
name|writeLock
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
name|doCommit
argument_list|()
expr_stmt|;
block|}
name|hasChanges
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Implements commit. */
DECL|method|doCommit
specifier|protected
specifier|abstract
name|void
name|doCommit
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * Closes files associated with this index.    * Also saves any new deletions to disk.    * No other methods should be called after this has been called.    * @throws IOException if there is a low-level IO error    */
DECL|method|close
specifier|public
specifier|final
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
name|commit
argument_list|()
expr_stmt|;
name|doClose
argument_list|()
expr_stmt|;
if|if
condition|(
name|directoryOwner
condition|)
name|closed
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|closeDirectory
condition|)
name|directory
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Implements close. */
DECL|method|doClose
specifier|protected
specifier|abstract
name|void
name|doClose
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Release the write lock, if needed. */
DECL|method|finalize
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
try|try
block|{
if|if
condition|(
name|writeLock
operator|!=
literal|null
condition|)
block|{
name|writeLock
operator|.
name|release
argument_list|()
expr_stmt|;
comment|// release write lock
name|writeLock
operator|=
literal|null
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get a list of unique field names that exist in this index and have the specified    * field option information.    * @param fldOption specifies which field option should be available for the returned fields    * @return Collection of Strings indicating the names of the fields.    * @see IndexReader.FieldOption    */
DECL|method|getFieldNames
specifier|public
specifier|abstract
name|Collection
name|getFieldNames
parameter_list|(
name|FieldOption
name|fldOption
parameter_list|)
function_decl|;
comment|/**    * Returns<code>true</code> iff the index in the named directory is    * currently locked.    * @param directory the directory to check for a lock    * @throws IOException if there is a low-level IO error    */
DECL|method|isLocked
specifier|public
specifier|static
name|boolean
name|isLocked
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|directory
operator|.
name|makeLock
argument_list|(
name|IndexWriter
operator|.
name|WRITE_LOCK_NAME
argument_list|)
operator|.
name|isLocked
argument_list|()
return|;
block|}
comment|/**    * Returns<code>true</code> iff the index in the named directory is    * currently locked.    * @param directory the directory to check for a lock    * @throws IOException if there is a low-level IO error    */
DECL|method|isLocked
specifier|public
specifier|static
name|boolean
name|isLocked
parameter_list|(
name|String
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
name|Directory
name|dir
init|=
name|FSDirectory
operator|.
name|getDirectory
argument_list|(
name|directory
argument_list|)
decl_stmt|;
name|boolean
name|result
init|=
name|isLocked
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Forcibly unlocks the index in the named directory.    *<P>    * Caution: this should only be used by failure recovery code,    * when it is known that no other process nor thread is in fact    * currently accessing this index.    */
DECL|method|unlock
specifier|public
specifier|static
name|void
name|unlock
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
name|directory
operator|.
name|makeLock
argument_list|(
name|IndexWriter
operator|.
name|WRITE_LOCK_NAME
argument_list|)
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
comment|/**    * Prints the filename and size of each file within a given compound file.    * Add the -extract flag to extract files to the current working directory.    * In order to make the extracted version of the index work, you have to copy    * the segments file from the compound index into the directory where the extracted files are stored.    * @param args Usage: org.apache.lucene.index.IndexReader [-extract]&lt;cfsfile&gt;    */
DECL|method|main
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|String
name|filename
init|=
literal|null
decl_stmt|;
name|boolean
name|extract
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-extract"
argument_list|)
condition|)
block|{
name|extract
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filename
operator|==
literal|null
condition|)
block|{
name|filename
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|filename
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Usage: org.apache.lucene.index.IndexReader [-extract]<cfsfile>"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Directory
name|dir
init|=
literal|null
decl_stmt|;
name|CompoundFileReader
name|cfr
init|=
literal|null
decl_stmt|;
try|try
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|String
name|dirname
init|=
name|file
operator|.
name|getAbsoluteFile
argument_list|()
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|filename
operator|=
name|file
operator|.
name|getName
argument_list|()
expr_stmt|;
name|dir
operator|=
name|FSDirectory
operator|.
name|getDirectory
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|cfr
operator|=
operator|new
name|CompoundFileReader
argument_list|(
name|dir
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|String
index|[]
name|files
init|=
name|cfr
operator|.
name|list
argument_list|()
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|files
argument_list|)
expr_stmt|;
comment|// sort the array of filename so that the output is more readable
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|files
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|long
name|len
init|=
name|cfr
operator|.
name|fileLength
argument_list|(
name|files
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|extract
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"extract "
operator|+
name|files
index|[
name|i
index|]
operator|+
literal|" with "
operator|+
name|len
operator|+
literal|" bytes to local directory..."
argument_list|)
expr_stmt|;
name|IndexInput
name|ii
init|=
name|cfr
operator|.
name|openInput
argument_list|(
name|files
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|FileOutputStream
name|f
init|=
operator|new
name|FileOutputStream
argument_list|(
name|files
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|// read and write with a small buffer, which is more effectiv than reading byte by byte
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|chunk
init|=
name|buffer
operator|.
name|length
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|bufLen
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|chunk
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|ii
operator|.
name|readBytes
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|bufLen
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|bufLen
argument_list|)
expr_stmt|;
name|len
operator|-=
name|bufLen
expr_stmt|;
block|}
name|f
operator|.
name|close
argument_list|()
expr_stmt|;
name|ii
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|files
index|[
name|i
index|]
operator|+
literal|": "
operator|+
name|len
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|ioe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
if|if
condition|(
name|dir
operator|!=
literal|null
condition|)
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|cfr
operator|!=
literal|null
condition|)
name|cfr
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|ioe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_class
end_unit
