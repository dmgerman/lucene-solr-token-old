begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Fieldable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Token
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|UnicodeUtil
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_comment
comment|/** Used by DocumentsWriter to hold data associated with a  *  single field in a single ThreadState, including the  *  Postings hash.  A document may have many occurrences for  *  a given field name; we gather all such occurrences here  *  (in docFields) so that we can process the entire field  *  at once. */
end_comment
begin_class
DECL|class|DocumentsWriterFieldData
specifier|final
class|class
name|DocumentsWriterFieldData
implements|implements
name|Comparable
block|{
DECL|field|threadState
specifier|final
name|DocumentsWriterThreadState
name|threadState
decl_stmt|;
DECL|field|fieldInfo
name|FieldInfo
name|fieldInfo
decl_stmt|;
DECL|field|fieldCount
name|int
name|fieldCount
decl_stmt|;
DECL|field|docFields
name|Fieldable
index|[]
name|docFields
init|=
operator|new
name|Fieldable
index|[
literal|1
index|]
decl_stmt|;
DECL|field|lastGen
name|int
name|lastGen
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|next
name|DocumentsWriterFieldData
name|next
decl_stmt|;
DECL|field|doNorms
name|boolean
name|doNorms
decl_stmt|;
DECL|field|doVectors
name|boolean
name|doVectors
decl_stmt|;
DECL|field|doVectorPositions
name|boolean
name|doVectorPositions
decl_stmt|;
DECL|field|doVectorOffsets
name|boolean
name|doVectorOffsets
decl_stmt|;
DECL|field|postingsCompacted
name|boolean
name|postingsCompacted
decl_stmt|;
DECL|field|numPostings
name|int
name|numPostings
decl_stmt|;
DECL|field|postingsHash
name|Posting
index|[]
name|postingsHash
decl_stmt|;
DECL|field|postingsHashSize
name|int
name|postingsHashSize
decl_stmt|;
DECL|field|postingsHashHalfSize
name|int
name|postingsHashHalfSize
decl_stmt|;
DECL|field|postingsHashMask
name|int
name|postingsHashMask
decl_stmt|;
DECL|field|position
name|int
name|position
decl_stmt|;
DECL|field|length
name|int
name|length
decl_stmt|;
DECL|field|offset
name|int
name|offset
decl_stmt|;
DECL|field|boost
name|float
name|boost
decl_stmt|;
DECL|field|postingsVectorsUpto
name|int
name|postingsVectorsUpto
decl_stmt|;
DECL|method|DocumentsWriterFieldData
specifier|public
name|DocumentsWriterFieldData
parameter_list|(
name|DocumentsWriterThreadState
name|threadState
parameter_list|,
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
name|this
operator|.
name|fieldInfo
operator|=
name|fieldInfo
expr_stmt|;
name|this
operator|.
name|threadState
operator|=
name|threadState
expr_stmt|;
block|}
DECL|method|resetPostingArrays
name|void
name|resetPostingArrays
parameter_list|()
block|{
if|if
condition|(
operator|!
name|postingsCompacted
condition|)
name|compactPostings
argument_list|()
expr_stmt|;
name|threadState
operator|.
name|docWriter
operator|.
name|recyclePostings
argument_list|(
name|this
operator|.
name|postingsHash
argument_list|,
name|numPostings
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|postingsHash
argument_list|,
literal|0
argument_list|,
name|postingsHash
operator|.
name|length
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|postingsCompacted
operator|=
literal|false
expr_stmt|;
name|numPostings
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|initPostingArrays
name|void
name|initPostingArrays
parameter_list|()
block|{
comment|// Target hash fill factor of<= 50%
comment|// NOTE: must be a power of two for hash collision
comment|// strategy to work correctly
name|postingsHashSize
operator|=
literal|4
expr_stmt|;
name|postingsHashHalfSize
operator|=
literal|2
expr_stmt|;
name|postingsHashMask
operator|=
name|postingsHashSize
operator|-
literal|1
expr_stmt|;
name|postingsHash
operator|=
operator|new
name|Posting
index|[
name|postingsHashSize
index|]
expr_stmt|;
block|}
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|fieldInfo
operator|.
name|name
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|DocumentsWriterFieldData
operator|)
name|o
operator|)
operator|.
name|fieldInfo
operator|.
name|name
argument_list|)
return|;
block|}
DECL|method|compactPostings
specifier|private
name|void
name|compactPostings
parameter_list|()
block|{
name|int
name|upto
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|postingsHashSize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|postingsHash
index|[
name|i
index|]
operator|!=
literal|null
condition|)
name|postingsHash
index|[
name|upto
operator|++
index|]
operator|=
name|postingsHash
index|[
name|i
index|]
expr_stmt|;
assert|assert
name|upto
operator|==
name|numPostings
assert|;
name|postingsCompacted
operator|=
literal|true
expr_stmt|;
block|}
comment|/** Collapse the hash table& sort in-place. */
DECL|method|sortPostings
specifier|public
name|Posting
index|[]
name|sortPostings
parameter_list|()
block|{
name|compactPostings
argument_list|()
expr_stmt|;
name|threadState
operator|.
name|doPostingSort
argument_list|(
name|postingsHash
argument_list|,
name|numPostings
argument_list|)
expr_stmt|;
return|return
name|postingsHash
return|;
block|}
comment|/** Process all occurrences of one field in the document. */
DECL|method|processField
specifier|public
name|void
name|processField
parameter_list|(
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|IOException
throws|,
name|AbortException
block|{
name|length
operator|=
literal|0
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|boost
operator|=
name|threadState
operator|.
name|docBoost
expr_stmt|;
specifier|final
name|int
name|maxFieldLength
init|=
name|threadState
operator|.
name|docWriter
operator|.
name|writer
operator|.
name|getMaxFieldLength
argument_list|()
decl_stmt|;
specifier|final
name|int
name|limit
init|=
name|fieldCount
decl_stmt|;
specifier|final
name|Fieldable
index|[]
name|docFieldsFinal
init|=
name|docFields
decl_stmt|;
name|boolean
name|doWriteVectors
init|=
literal|true
decl_stmt|;
comment|// Walk through all occurrences in this doc for this
comment|// field:
try|try
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|limit
condition|;
name|j
operator|++
control|)
block|{
name|Fieldable
name|field
init|=
name|docFieldsFinal
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|isIndexed
argument_list|()
condition|)
name|invertField
argument_list|(
name|field
argument_list|,
name|analyzer
argument_list|,
name|maxFieldLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|.
name|isStored
argument_list|()
condition|)
block|{
name|threadState
operator|.
name|numStoredFields
operator|++
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|threadState
operator|.
name|localFieldsWriter
operator|.
name|writeField
argument_list|(
name|fieldInfo
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
comment|// If we hit an exception inside
comment|// localFieldsWriter.writeField, the
comment|// contents of fdtLocal can be corrupt, so
comment|// we must discard all stored fields for
comment|// this document:
if|if
condition|(
operator|!
name|success
condition|)
name|threadState
operator|.
name|fdtLocal
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
name|docFieldsFinal
index|[
name|j
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|AbortException
name|ae
parameter_list|)
block|{
name|doWriteVectors
operator|=
literal|false
expr_stmt|;
throw|throw
name|ae
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|postingsVectorsUpto
operator|>
literal|0
condition|)
block|{
try|try
block|{
if|if
condition|(
name|doWriteVectors
condition|)
block|{
comment|// Add term vectors for this field
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|writeVectors
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// If we hit an exception inside
comment|// writeVectors, the contents of tvfLocal
comment|// can be corrupt, so we must discard all
comment|// term vectors for this document:
name|threadState
operator|.
name|numVectorFields
operator|=
literal|0
expr_stmt|;
name|threadState
operator|.
name|tvfLocal
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|postingsVectorsUpto
operator|>
name|threadState
operator|.
name|maxPostingsVectors
condition|)
name|threadState
operator|.
name|maxPostingsVectors
operator|=
name|postingsVectorsUpto
expr_stmt|;
name|postingsVectorsUpto
operator|=
literal|0
expr_stmt|;
name|threadState
operator|.
name|vectorsPool
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|field|offsetEnd
name|int
name|offsetEnd
decl_stmt|;
DECL|field|localToken
name|Token
name|localToken
init|=
operator|new
name|Token
argument_list|()
decl_stmt|;
comment|/* Invert one occurrence of one field in the document */
DECL|method|invertField
specifier|public
name|void
name|invertField
parameter_list|(
name|Fieldable
name|field
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|,
specifier|final
name|int
name|maxFieldLength
parameter_list|)
throws|throws
name|IOException
throws|,
name|AbortException
block|{
if|if
condition|(
name|length
operator|>
literal|0
condition|)
name|position
operator|+=
name|analyzer
operator|.
name|getPositionIncrementGap
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|field
operator|.
name|isTokenized
argument_list|()
condition|)
block|{
comment|// un-tokenized field
name|String
name|stringValue
init|=
name|field
operator|.
name|stringValue
argument_list|()
decl_stmt|;
specifier|final
name|int
name|valueLength
init|=
name|stringValue
operator|.
name|length
argument_list|()
decl_stmt|;
name|Token
name|token
init|=
name|localToken
decl_stmt|;
name|token
operator|.
name|clear
argument_list|()
expr_stmt|;
name|char
index|[]
name|termBuffer
init|=
name|token
operator|.
name|termBuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|termBuffer
operator|.
name|length
operator|<
name|valueLength
condition|)
name|termBuffer
operator|=
name|token
operator|.
name|resizeTermBuffer
argument_list|(
name|valueLength
argument_list|)
expr_stmt|;
name|stringValue
operator|.
name|getChars
argument_list|(
literal|0
argument_list|,
name|valueLength
argument_list|,
name|termBuffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|token
operator|.
name|setTermLength
argument_list|(
name|valueLength
argument_list|)
expr_stmt|;
name|token
operator|.
name|setStartOffset
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|token
operator|.
name|setEndOffset
argument_list|(
name|offset
operator|+
name|stringValue
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|addPosition
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|stringValue
operator|.
name|length
argument_list|()
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// tokenized field
specifier|final
name|TokenStream
name|stream
decl_stmt|;
specifier|final
name|TokenStream
name|streamValue
init|=
name|field
operator|.
name|tokenStreamValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|streamValue
operator|!=
literal|null
condition|)
name|stream
operator|=
name|streamValue
expr_stmt|;
else|else
block|{
comment|// the field does not have a TokenStream,
comment|// so we have to obtain one from the analyzer
specifier|final
name|Reader
name|reader
decl_stmt|;
comment|// find or make Reader
specifier|final
name|Reader
name|readerValue
init|=
name|field
operator|.
name|readerValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|readerValue
operator|!=
literal|null
condition|)
name|reader
operator|=
name|readerValue
expr_stmt|;
else|else
block|{
name|String
name|stringValue
init|=
name|field
operator|.
name|stringValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|stringValue
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field must have either TokenStream, String or Reader value"
argument_list|)
throw|;
name|threadState
operator|.
name|stringReader
operator|.
name|init
argument_list|(
name|stringValue
argument_list|)
expr_stmt|;
name|reader
operator|=
name|threadState
operator|.
name|stringReader
expr_stmt|;
block|}
comment|// Tokenize field and add to postingTable
name|stream
operator|=
name|analyzer
operator|.
name|reusableTokenStream
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
comment|// reset the TokenStream to the first token
name|stream
operator|.
name|reset
argument_list|()
expr_stmt|;
try|try
block|{
name|offsetEnd
operator|=
name|offset
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|Token
name|token
init|=
name|stream
operator|.
name|next
argument_list|(
name|localToken
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|==
literal|null
condition|)
break|break;
name|position
operator|+=
operator|(
name|token
operator|.
name|getPositionIncrement
argument_list|()
operator|-
literal|1
operator|)
expr_stmt|;
comment|// LUCENE-1255: don't allow negative positon
if|if
condition|(
name|position
operator|<
literal|0
condition|)
name|position
operator|=
literal|0
expr_stmt|;
name|addPosition
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|length
operator|>=
name|maxFieldLength
condition|)
block|{
if|if
condition|(
name|threadState
operator|.
name|docWriter
operator|.
name|infoStream
operator|!=
literal|null
condition|)
name|threadState
operator|.
name|docWriter
operator|.
name|infoStream
operator|.
name|println
argument_list|(
literal|"maxFieldLength "
operator|+
name|maxFieldLength
operator|+
literal|" reached for field "
operator|+
name|fieldInfo
operator|.
name|name
operator|+
literal|", ignoring following tokens"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|offset
operator|=
name|offsetEnd
operator|+
literal|1
expr_stmt|;
block|}
finally|finally
block|{
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|boost
operator|*=
name|field
operator|.
name|getBoost
argument_list|()
expr_stmt|;
block|}
comment|/** Only called when term vectors are enabled.  This    *  is called the first time we see a given term for    *  each document, to allocate a PostingVector    *  instance that is used to record data needed to    *  write the posting vectors. */
DECL|method|addNewVector
specifier|private
name|PostingVector
name|addNewVector
parameter_list|()
block|{
if|if
condition|(
name|postingsVectorsUpto
operator|==
name|threadState
operator|.
name|postingsVectors
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|newSize
decl_stmt|;
if|if
condition|(
name|threadState
operator|.
name|postingsVectors
operator|.
name|length
operator|<
literal|2
condition|)
name|newSize
operator|=
literal|2
expr_stmt|;
else|else
name|newSize
operator|=
call|(
name|int
call|)
argument_list|(
literal|1.5
operator|*
name|threadState
operator|.
name|postingsVectors
operator|.
name|length
argument_list|)
expr_stmt|;
name|PostingVector
index|[]
name|newArray
init|=
operator|new
name|PostingVector
index|[
name|newSize
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|threadState
operator|.
name|postingsVectors
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|threadState
operator|.
name|postingsVectors
operator|.
name|length
argument_list|)
expr_stmt|;
name|threadState
operator|.
name|postingsVectors
operator|=
name|newArray
expr_stmt|;
block|}
name|p
operator|.
name|vector
operator|=
name|threadState
operator|.
name|postingsVectors
index|[
name|postingsVectorsUpto
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|vector
operator|==
literal|null
condition|)
name|p
operator|.
name|vector
operator|=
name|threadState
operator|.
name|postingsVectors
index|[
name|postingsVectorsUpto
index|]
operator|=
operator|new
name|PostingVector
argument_list|()
expr_stmt|;
name|postingsVectorsUpto
operator|++
expr_stmt|;
specifier|final
name|PostingVector
name|v
init|=
name|p
operator|.
name|vector
decl_stmt|;
name|v
operator|.
name|p
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|doVectorPositions
condition|)
block|{
specifier|final
name|int
name|upto
init|=
name|threadState
operator|.
name|vectorsPool
operator|.
name|newSlice
argument_list|(
name|ByteBlockPool
operator|.
name|FIRST_LEVEL_SIZE
argument_list|)
decl_stmt|;
name|v
operator|.
name|posStart
operator|=
name|v
operator|.
name|posUpto
operator|=
name|threadState
operator|.
name|vectorsPool
operator|.
name|byteOffset
operator|+
name|upto
expr_stmt|;
block|}
if|if
condition|(
name|doVectorOffsets
condition|)
block|{
specifier|final
name|int
name|upto
init|=
name|threadState
operator|.
name|vectorsPool
operator|.
name|newSlice
argument_list|(
name|ByteBlockPool
operator|.
name|FIRST_LEVEL_SIZE
argument_list|)
decl_stmt|;
name|v
operator|.
name|offsetStart
operator|=
name|v
operator|.
name|offsetUpto
operator|=
name|threadState
operator|.
name|vectorsPool
operator|.
name|byteOffset
operator|+
name|upto
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
DECL|field|offsetStartCode
name|int
name|offsetStartCode
decl_stmt|;
DECL|field|offsetStart
name|int
name|offsetStart
decl_stmt|;
comment|// Current posting we are working on
DECL|field|p
name|Posting
name|p
decl_stmt|;
DECL|field|vector
name|PostingVector
name|vector
decl_stmt|;
comment|/** Test whether the text for current Posting p equals    *  current tokenText. */
DECL|method|postingEquals
name|boolean
name|postingEquals
parameter_list|(
specifier|final
name|char
index|[]
name|tokenText
parameter_list|,
specifier|final
name|int
name|tokenTextLen
parameter_list|)
block|{
specifier|final
name|char
index|[]
name|text
init|=
name|threadState
operator|.
name|charPool
operator|.
name|buffers
index|[
name|p
operator|.
name|textStart
operator|>>
name|DocumentsWriter
operator|.
name|CHAR_BLOCK_SHIFT
index|]
decl_stmt|;
assert|assert
name|text
operator|!=
literal|null
assert|;
name|int
name|pos
init|=
name|p
operator|.
name|textStart
operator|&
name|DocumentsWriter
operator|.
name|CHAR_BLOCK_MASK
decl_stmt|;
name|int
name|tokenPos
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|tokenPos
operator|<
name|tokenTextLen
condition|;
name|pos
operator|++
operator|,
name|tokenPos
operator|++
control|)
if|if
condition|(
name|tokenText
index|[
name|tokenPos
index|]
operator|!=
name|text
index|[
name|pos
index|]
condition|)
return|return
literal|false
return|;
return|return
literal|0xffff
operator|==
name|text
index|[
name|pos
index|]
return|;
block|}
comment|/** This is the hotspot of indexing: it's called once    *  for every term of every document.  Its job is to *    *  update the postings byte stream (Postings hash) *    *  based on the occurence of a single term. */
DECL|method|addPosition
specifier|private
name|void
name|addPosition
parameter_list|(
name|Token
name|token
parameter_list|)
throws|throws
name|AbortException
block|{
specifier|final
name|Payload
name|payload
init|=
name|token
operator|.
name|getPayload
argument_list|()
decl_stmt|;
comment|// Get the text of this term.  Term can either
comment|// provide a String token or offset into a char[]
comment|// array
specifier|final
name|char
index|[]
name|tokenText
init|=
name|token
operator|.
name|termBuffer
argument_list|()
decl_stmt|;
specifier|final
name|int
name|tokenTextLen
init|=
name|token
operator|.
name|termLength
argument_list|()
decl_stmt|;
name|int
name|code
init|=
literal|0
decl_stmt|;
comment|// Compute hashcode& replace any invalid UTF16 sequences
name|int
name|downto
init|=
name|tokenTextLen
decl_stmt|;
while|while
condition|(
name|downto
operator|>
literal|0
condition|)
block|{
name|char
name|ch
init|=
name|tokenText
index|[
operator|--
name|downto
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|>=
name|UnicodeUtil
operator|.
name|UNI_SUR_LOW_START
operator|&&
name|ch
operator|<=
name|UnicodeUtil
operator|.
name|UNI_SUR_LOW_END
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|downto
condition|)
block|{
comment|// Unpaired
name|ch
operator|=
name|tokenText
index|[
name|downto
index|]
operator|=
name|UnicodeUtil
operator|.
name|UNI_REPLACEMENT_CHAR
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|char
name|ch2
init|=
name|tokenText
index|[
name|downto
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|ch2
operator|>=
name|UnicodeUtil
operator|.
name|UNI_SUR_HIGH_START
operator|&&
name|ch2
operator|<=
name|UnicodeUtil
operator|.
name|UNI_SUR_HIGH_END
condition|)
block|{
comment|// OK: high followed by low.  This is a valid
comment|// surrogate pair.
name|code
operator|=
operator|(
operator|(
name|code
operator|*
literal|31
operator|)
operator|+
name|ch
operator|)
operator|*
literal|31
operator|+
name|ch2
expr_stmt|;
name|downto
operator|--
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|// Unpaired
name|ch
operator|=
name|tokenText
index|[
name|downto
index|]
operator|=
name|UnicodeUtil
operator|.
name|UNI_REPLACEMENT_CHAR
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|>=
name|UnicodeUtil
operator|.
name|UNI_SUR_HIGH_START
operator|&&
name|ch
operator|<=
name|UnicodeUtil
operator|.
name|UNI_SUR_HIGH_END
condition|)
comment|// Unpaired
name|ch
operator|=
name|tokenText
index|[
name|downto
index|]
operator|=
name|UnicodeUtil
operator|.
name|UNI_REPLACEMENT_CHAR
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|*
literal|31
operator|)
operator|+
name|ch
expr_stmt|;
block|}
comment|// System.out.println("  addPosition: field=" + fieldInfo.name + " buffer=" + new String(tokenText, 0, tokenTextLen) + " pos=" + position + " offsetStart=" + (offset+token.startOffset()) + " offsetEnd=" + (offset + token.endOffset()) + " docID=" + docID + " doPos=" + doVectorPositions + " doOffset=" + doVectorOffsets);
name|int
name|hashPos
init|=
name|code
operator|&
name|postingsHashMask
decl_stmt|;
assert|assert
operator|!
name|postingsCompacted
assert|;
comment|// Locate Posting in hash
name|p
operator|=
name|postingsHash
index|[
name|hashPos
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
operator|&&
operator|!
name|postingEquals
argument_list|(
name|tokenText
argument_list|,
name|tokenTextLen
argument_list|)
condition|)
block|{
comment|// Conflict: keep searching different locations in
comment|// the hash table.
specifier|final
name|int
name|inc
init|=
operator|(
operator|(
name|code
operator|>>
literal|8
operator|)
operator|+
name|code
operator|)
operator||
literal|1
decl_stmt|;
do|do
block|{
name|code
operator|+=
name|inc
expr_stmt|;
name|hashPos
operator|=
name|code
operator|&
name|postingsHashMask
expr_stmt|;
name|p
operator|=
name|postingsHash
index|[
name|hashPos
index|]
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
literal|null
operator|&&
operator|!
name|postingEquals
argument_list|(
name|tokenText
argument_list|,
name|tokenTextLen
argument_list|)
condition|)
do|;
block|}
specifier|final
name|int
name|proxCode
decl_stmt|;
comment|// If we hit an exception below, it's possible the
comment|// posting list or term vectors data will be
comment|// partially written and thus inconsistent if
comment|// flushed, so we have to abort all documents
comment|// since the last flush:
try|try
block|{
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
comment|// term seen since last flush
if|if
condition|(
name|threadState
operator|.
name|docID
operator|!=
name|p
operator|.
name|lastDocID
condition|)
block|{
comment|// term not yet seen in this doc
comment|// System.out.println("    seen before (new docID=" + docID + ") freqUpto=" + p.freqUpto +" proxUpto=" + p.proxUpto);
assert|assert
name|p
operator|.
name|docFreq
operator|>
literal|0
assert|;
comment|// Now that we know doc freq for previous doc,
comment|// write it& lastDocCode
name|freqUpto
operator|=
name|p
operator|.
name|freqUpto
operator|&
name|DocumentsWriter
operator|.
name|BYTE_BLOCK_MASK
expr_stmt|;
name|freq
operator|=
name|threadState
operator|.
name|postingsPool
operator|.
name|buffers
index|[
name|p
operator|.
name|freqUpto
operator|>>
name|DocumentsWriter
operator|.
name|BYTE_BLOCK_SHIFT
index|]
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|p
operator|.
name|docFreq
condition|)
name|writeFreqVInt
argument_list|(
name|p
operator|.
name|lastDocCode
operator||
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|writeFreqVInt
argument_list|(
name|p
operator|.
name|lastDocCode
argument_list|)
expr_stmt|;
name|writeFreqVInt
argument_list|(
name|p
operator|.
name|docFreq
argument_list|)
expr_stmt|;
block|}
name|p
operator|.
name|freqUpto
operator|=
name|freqUpto
operator|+
operator|(
name|p
operator|.
name|freqUpto
operator|&
name|DocumentsWriter
operator|.
name|BYTE_BLOCK_NOT_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|doVectors
condition|)
block|{
name|vector
operator|=
name|addNewVector
argument_list|()
expr_stmt|;
if|if
condition|(
name|doVectorOffsets
condition|)
block|{
name|offsetStartCode
operator|=
name|offsetStart
operator|=
name|offset
operator|+
name|token
operator|.
name|startOffset
argument_list|()
expr_stmt|;
name|offsetEnd
operator|=
name|offset
operator|+
name|token
operator|.
name|endOffset
argument_list|()
expr_stmt|;
block|}
block|}
name|proxCode
operator|=
name|position
expr_stmt|;
name|p
operator|.
name|docFreq
operator|=
literal|1
expr_stmt|;
comment|// Store code so we can write this after we're
comment|// done with this new doc
name|p
operator|.
name|lastDocCode
operator|=
operator|(
name|threadState
operator|.
name|docID
operator|-
name|p
operator|.
name|lastDocID
operator|)
operator|<<
literal|1
expr_stmt|;
name|p
operator|.
name|lastDocID
operator|=
name|threadState
operator|.
name|docID
expr_stmt|;
block|}
else|else
block|{
comment|// term already seen in this doc
comment|// System.out.println("    seen before (same docID=" + docID + ") proxUpto=" + p.proxUpto);
name|p
operator|.
name|docFreq
operator|++
expr_stmt|;
name|proxCode
operator|=
name|position
operator|-
name|p
operator|.
name|lastPosition
expr_stmt|;
if|if
condition|(
name|doVectors
condition|)
block|{
name|vector
operator|=
name|p
operator|.
name|vector
expr_stmt|;
if|if
condition|(
name|vector
operator|==
literal|null
condition|)
name|vector
operator|=
name|addNewVector
argument_list|()
expr_stmt|;
if|if
condition|(
name|doVectorOffsets
condition|)
block|{
name|offsetStart
operator|=
name|offset
operator|+
name|token
operator|.
name|startOffset
argument_list|()
expr_stmt|;
name|offsetEnd
operator|=
name|offset
operator|+
name|token
operator|.
name|endOffset
argument_list|()
expr_stmt|;
name|offsetStartCode
operator|=
name|offsetStart
operator|-
name|vector
operator|.
name|lastOffset
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// term not seen before
comment|// System.out.println("    never seen docID=" + docID);
comment|// Refill?
if|if
condition|(
literal|0
operator|==
name|threadState
operator|.
name|postingsFreeCount
condition|)
block|{
name|threadState
operator|.
name|docWriter
operator|.
name|getPostings
argument_list|(
name|threadState
operator|.
name|postingsFreeList
argument_list|)
expr_stmt|;
name|threadState
operator|.
name|postingsFreeCount
operator|=
name|threadState
operator|.
name|postingsFreeList
operator|.
name|length
expr_stmt|;
block|}
specifier|final
name|int
name|textLen1
init|=
literal|1
operator|+
name|tokenTextLen
decl_stmt|;
if|if
condition|(
name|textLen1
operator|+
name|threadState
operator|.
name|charPool
operator|.
name|byteUpto
operator|>
name|DocumentsWriter
operator|.
name|CHAR_BLOCK_SIZE
condition|)
block|{
if|if
condition|(
name|textLen1
operator|>
name|DocumentsWriter
operator|.
name|CHAR_BLOCK_SIZE
condition|)
block|{
comment|// Just skip this term, to remain as robust as
comment|// possible during indexing.  A TokenFilter
comment|// can be inserted into the analyzer chain if
comment|// other behavior is wanted (pruning the term
comment|// to a prefix, throwing an exception, etc).
if|if
condition|(
name|threadState
operator|.
name|maxTermPrefix
operator|==
literal|null
condition|)
name|threadState
operator|.
name|maxTermPrefix
operator|=
operator|new
name|String
argument_list|(
name|tokenText
argument_list|,
literal|0
argument_list|,
literal|30
argument_list|)
expr_stmt|;
comment|// Still increment position:
name|position
operator|++
expr_stmt|;
return|return;
block|}
name|threadState
operator|.
name|charPool
operator|.
name|nextBuffer
argument_list|()
expr_stmt|;
block|}
specifier|final
name|char
index|[]
name|text
init|=
name|threadState
operator|.
name|charPool
operator|.
name|buffer
decl_stmt|;
specifier|final
name|int
name|textUpto
init|=
name|threadState
operator|.
name|charPool
operator|.
name|byteUpto
decl_stmt|;
comment|// Pull next free Posting from free list
name|p
operator|=
name|threadState
operator|.
name|postingsFreeList
index|[
operator|--
name|threadState
operator|.
name|postingsFreeCount
index|]
expr_stmt|;
name|p
operator|.
name|textStart
operator|=
name|textUpto
operator|+
name|threadState
operator|.
name|charPool
operator|.
name|byteOffset
expr_stmt|;
name|threadState
operator|.
name|charPool
operator|.
name|byteUpto
operator|+=
name|textLen1
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|tokenText
argument_list|,
literal|0
argument_list|,
name|text
argument_list|,
name|textUpto
argument_list|,
name|tokenTextLen
argument_list|)
expr_stmt|;
name|text
index|[
name|textUpto
operator|+
name|tokenTextLen
index|]
operator|=
literal|0xffff
expr_stmt|;
assert|assert
name|postingsHash
index|[
name|hashPos
index|]
operator|==
literal|null
assert|;
name|postingsHash
index|[
name|hashPos
index|]
operator|=
name|p
expr_stmt|;
name|numPostings
operator|++
expr_stmt|;
if|if
condition|(
name|numPostings
operator|==
name|postingsHashHalfSize
condition|)
name|rehashPostings
argument_list|(
literal|2
operator|*
name|postingsHashSize
argument_list|)
expr_stmt|;
comment|// Init first slice for freq& prox streams
specifier|final
name|int
name|upto1
init|=
name|threadState
operator|.
name|postingsPool
operator|.
name|newSlice
argument_list|(
name|ByteBlockPool
operator|.
name|FIRST_LEVEL_SIZE
argument_list|)
decl_stmt|;
name|p
operator|.
name|freqStart
operator|=
name|p
operator|.
name|freqUpto
operator|=
name|threadState
operator|.
name|postingsPool
operator|.
name|byteOffset
operator|+
name|upto1
expr_stmt|;
specifier|final
name|int
name|upto2
init|=
name|threadState
operator|.
name|postingsPool
operator|.
name|newSlice
argument_list|(
name|ByteBlockPool
operator|.
name|FIRST_LEVEL_SIZE
argument_list|)
decl_stmt|;
name|p
operator|.
name|proxStart
operator|=
name|p
operator|.
name|proxUpto
operator|=
name|threadState
operator|.
name|postingsPool
operator|.
name|byteOffset
operator|+
name|upto2
expr_stmt|;
name|p
operator|.
name|lastDocCode
operator|=
name|threadState
operator|.
name|docID
operator|<<
literal|1
expr_stmt|;
name|p
operator|.
name|lastDocID
operator|=
name|threadState
operator|.
name|docID
expr_stmt|;
name|p
operator|.
name|docFreq
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|doVectors
condition|)
block|{
name|vector
operator|=
name|addNewVector
argument_list|()
expr_stmt|;
if|if
condition|(
name|doVectorOffsets
condition|)
block|{
name|offsetStart
operator|=
name|offsetStartCode
operator|=
name|offset
operator|+
name|token
operator|.
name|startOffset
argument_list|()
expr_stmt|;
name|offsetEnd
operator|=
name|offset
operator|+
name|token
operator|.
name|endOffset
argument_list|()
expr_stmt|;
block|}
block|}
name|proxCode
operator|=
name|position
expr_stmt|;
block|}
name|proxUpto
operator|=
name|p
operator|.
name|proxUpto
operator|&
name|DocumentsWriter
operator|.
name|BYTE_BLOCK_MASK
expr_stmt|;
name|prox
operator|=
name|threadState
operator|.
name|postingsPool
operator|.
name|buffers
index|[
name|p
operator|.
name|proxUpto
operator|>>
name|DocumentsWriter
operator|.
name|BYTE_BLOCK_SHIFT
index|]
expr_stmt|;
assert|assert
name|prox
operator|!=
literal|null
assert|;
if|if
condition|(
name|payload
operator|!=
literal|null
operator|&&
name|payload
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|writeProxVInt
argument_list|(
operator|(
name|proxCode
operator|<<
literal|1
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|writeProxVInt
argument_list|(
name|payload
operator|.
name|length
argument_list|)
expr_stmt|;
name|writeProxBytes
argument_list|(
name|payload
operator|.
name|data
argument_list|,
name|payload
operator|.
name|offset
argument_list|,
name|payload
operator|.
name|length
argument_list|)
expr_stmt|;
name|fieldInfo
operator|.
name|storePayloads
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|writeProxVInt
argument_list|(
name|proxCode
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|p
operator|.
name|proxUpto
operator|=
name|proxUpto
operator|+
operator|(
name|p
operator|.
name|proxUpto
operator|&
name|DocumentsWriter
operator|.
name|BYTE_BLOCK_NOT_MASK
operator|)
expr_stmt|;
name|p
operator|.
name|lastPosition
operator|=
name|position
operator|++
expr_stmt|;
if|if
condition|(
name|doVectorPositions
condition|)
block|{
name|posUpto
operator|=
name|vector
operator|.
name|posUpto
operator|&
name|DocumentsWriter
operator|.
name|BYTE_BLOCK_MASK
expr_stmt|;
name|pos
operator|=
name|threadState
operator|.
name|vectorsPool
operator|.
name|buffers
index|[
name|vector
operator|.
name|posUpto
operator|>>
name|DocumentsWriter
operator|.
name|BYTE_BLOCK_SHIFT
index|]
expr_stmt|;
name|writePosVInt
argument_list|(
name|proxCode
argument_list|)
expr_stmt|;
name|vector
operator|.
name|posUpto
operator|=
name|posUpto
operator|+
operator|(
name|vector
operator|.
name|posUpto
operator|&
name|DocumentsWriter
operator|.
name|BYTE_BLOCK_NOT_MASK
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|doVectorOffsets
condition|)
block|{
name|offsetUpto
operator|=
name|vector
operator|.
name|offsetUpto
operator|&
name|DocumentsWriter
operator|.
name|BYTE_BLOCK_MASK
expr_stmt|;
name|offsets
operator|=
name|threadState
operator|.
name|vectorsPool
operator|.
name|buffers
index|[
name|vector
operator|.
name|offsetUpto
operator|>>
name|DocumentsWriter
operator|.
name|BYTE_BLOCK_SHIFT
index|]
expr_stmt|;
name|writeOffsetVInt
argument_list|(
name|offsetStartCode
argument_list|)
expr_stmt|;
name|writeOffsetVInt
argument_list|(
name|offsetEnd
operator|-
name|offsetStart
argument_list|)
expr_stmt|;
name|vector
operator|.
name|lastOffset
operator|=
name|offsetEnd
expr_stmt|;
name|vector
operator|.
name|offsetUpto
operator|=
name|offsetUpto
operator|+
operator|(
name|vector
operator|.
name|offsetUpto
operator|&
name|DocumentsWriter
operator|.
name|BYTE_BLOCK_NOT_MASK
operator|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
operator|new
name|AbortException
argument_list|(
name|t
argument_list|,
name|threadState
operator|.
name|docWriter
argument_list|)
throw|;
block|}
block|}
comment|/** Write vInt into freq stream of current Posting */
DECL|method|writeFreqVInt
specifier|public
name|void
name|writeFreqVInt
parameter_list|(
name|int
name|i
parameter_list|)
block|{
while|while
condition|(
operator|(
name|i
operator|&
operator|~
literal|0x7F
operator|)
operator|!=
literal|0
condition|)
block|{
name|writeFreqByte
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|i
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|>>>=
literal|7
expr_stmt|;
block|}
name|writeFreqByte
argument_list|(
operator|(
name|byte
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
comment|/** Write vInt into prox stream of current Posting */
DECL|method|writeProxVInt
specifier|public
name|void
name|writeProxVInt
parameter_list|(
name|int
name|i
parameter_list|)
block|{
while|while
condition|(
operator|(
name|i
operator|&
operator|~
literal|0x7F
operator|)
operator|!=
literal|0
condition|)
block|{
name|writeProxByte
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|i
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|>>>=
literal|7
expr_stmt|;
block|}
name|writeProxByte
argument_list|(
operator|(
name|byte
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
comment|/** Write byte into freq stream of current Posting */
DECL|field|freq
name|byte
index|[]
name|freq
decl_stmt|;
DECL|field|freqUpto
name|int
name|freqUpto
decl_stmt|;
DECL|method|writeFreqByte
specifier|public
name|void
name|writeFreqByte
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
assert|assert
name|freq
operator|!=
literal|null
assert|;
if|if
condition|(
name|freq
index|[
name|freqUpto
index|]
operator|!=
literal|0
condition|)
block|{
name|freqUpto
operator|=
name|threadState
operator|.
name|postingsPool
operator|.
name|allocSlice
argument_list|(
name|freq
argument_list|,
name|freqUpto
argument_list|)
expr_stmt|;
name|freq
operator|=
name|threadState
operator|.
name|postingsPool
operator|.
name|buffer
expr_stmt|;
name|p
operator|.
name|freqUpto
operator|=
name|threadState
operator|.
name|postingsPool
operator|.
name|byteOffset
expr_stmt|;
block|}
name|freq
index|[
name|freqUpto
operator|++
index|]
operator|=
name|b
expr_stmt|;
block|}
comment|/** Write byte into prox stream of current Posting */
DECL|field|prox
name|byte
index|[]
name|prox
decl_stmt|;
DECL|field|proxUpto
name|int
name|proxUpto
decl_stmt|;
DECL|method|writeProxByte
specifier|public
name|void
name|writeProxByte
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
assert|assert
name|prox
operator|!=
literal|null
assert|;
if|if
condition|(
name|prox
index|[
name|proxUpto
index|]
operator|!=
literal|0
condition|)
block|{
name|proxUpto
operator|=
name|threadState
operator|.
name|postingsPool
operator|.
name|allocSlice
argument_list|(
name|prox
argument_list|,
name|proxUpto
argument_list|)
expr_stmt|;
name|prox
operator|=
name|threadState
operator|.
name|postingsPool
operator|.
name|buffer
expr_stmt|;
name|p
operator|.
name|proxUpto
operator|=
name|threadState
operator|.
name|postingsPool
operator|.
name|byteOffset
expr_stmt|;
assert|assert
name|prox
operator|!=
literal|null
assert|;
block|}
name|prox
index|[
name|proxUpto
operator|++
index|]
operator|=
name|b
expr_stmt|;
assert|assert
name|proxUpto
operator|!=
name|prox
operator|.
name|length
assert|;
block|}
comment|/** Currently only used to copy a payload into the prox    *  stream. */
DECL|method|writeProxBytes
specifier|public
name|void
name|writeProxBytes
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|final
name|int
name|offsetEnd
init|=
name|offset
operator|+
name|len
decl_stmt|;
while|while
condition|(
name|offset
operator|<
name|offsetEnd
condition|)
block|{
if|if
condition|(
name|prox
index|[
name|proxUpto
index|]
operator|!=
literal|0
condition|)
block|{
comment|// End marker
name|proxUpto
operator|=
name|threadState
operator|.
name|postingsPool
operator|.
name|allocSlice
argument_list|(
name|prox
argument_list|,
name|proxUpto
argument_list|)
expr_stmt|;
name|prox
operator|=
name|threadState
operator|.
name|postingsPool
operator|.
name|buffer
expr_stmt|;
name|p
operator|.
name|proxUpto
operator|=
name|threadState
operator|.
name|postingsPool
operator|.
name|byteOffset
expr_stmt|;
block|}
name|prox
index|[
name|proxUpto
operator|++
index|]
operator|=
name|b
index|[
name|offset
operator|++
index|]
expr_stmt|;
assert|assert
name|proxUpto
operator|!=
name|prox
operator|.
name|length
assert|;
block|}
block|}
comment|/** Write vInt into offsets stream of current    *  PostingVector */
DECL|method|writeOffsetVInt
specifier|public
name|void
name|writeOffsetVInt
parameter_list|(
name|int
name|i
parameter_list|)
block|{
while|while
condition|(
operator|(
name|i
operator|&
operator|~
literal|0x7F
operator|)
operator|!=
literal|0
condition|)
block|{
name|writeOffsetByte
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|i
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|>>>=
literal|7
expr_stmt|;
block|}
name|writeOffsetByte
argument_list|(
operator|(
name|byte
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
DECL|field|offsets
name|byte
index|[]
name|offsets
decl_stmt|;
DECL|field|offsetUpto
name|int
name|offsetUpto
decl_stmt|;
comment|/** Write byte into offsets stream of current    *  PostingVector */
DECL|method|writeOffsetByte
specifier|public
name|void
name|writeOffsetByte
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
assert|assert
name|offsets
operator|!=
literal|null
assert|;
if|if
condition|(
name|offsets
index|[
name|offsetUpto
index|]
operator|!=
literal|0
condition|)
block|{
name|offsetUpto
operator|=
name|threadState
operator|.
name|vectorsPool
operator|.
name|allocSlice
argument_list|(
name|offsets
argument_list|,
name|offsetUpto
argument_list|)
expr_stmt|;
name|offsets
operator|=
name|threadState
operator|.
name|vectorsPool
operator|.
name|buffer
expr_stmt|;
name|vector
operator|.
name|offsetUpto
operator|=
name|threadState
operator|.
name|vectorsPool
operator|.
name|byteOffset
expr_stmt|;
block|}
name|offsets
index|[
name|offsetUpto
operator|++
index|]
operator|=
name|b
expr_stmt|;
block|}
comment|/** Write vInt into pos stream of current    *  PostingVector */
DECL|method|writePosVInt
specifier|public
name|void
name|writePosVInt
parameter_list|(
name|int
name|i
parameter_list|)
block|{
while|while
condition|(
operator|(
name|i
operator|&
operator|~
literal|0x7F
operator|)
operator|!=
literal|0
condition|)
block|{
name|writePosByte
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|i
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|>>>=
literal|7
expr_stmt|;
block|}
name|writePosByte
argument_list|(
operator|(
name|byte
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
DECL|field|pos
name|byte
index|[]
name|pos
decl_stmt|;
DECL|field|posUpto
name|int
name|posUpto
decl_stmt|;
comment|/** Write byte into pos stream of current    *  PostingVector */
DECL|method|writePosByte
specifier|public
name|void
name|writePosByte
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
assert|assert
name|pos
operator|!=
literal|null
assert|;
if|if
condition|(
name|pos
index|[
name|posUpto
index|]
operator|!=
literal|0
condition|)
block|{
name|posUpto
operator|=
name|threadState
operator|.
name|vectorsPool
operator|.
name|allocSlice
argument_list|(
name|pos
argument_list|,
name|posUpto
argument_list|)
expr_stmt|;
name|pos
operator|=
name|threadState
operator|.
name|vectorsPool
operator|.
name|buffer
expr_stmt|;
name|vector
operator|.
name|posUpto
operator|=
name|threadState
operator|.
name|vectorsPool
operator|.
name|byteOffset
expr_stmt|;
block|}
name|pos
index|[
name|posUpto
operator|++
index|]
operator|=
name|b
expr_stmt|;
block|}
comment|/** Called when postings hash is too small (> 50%    *  occupied) or too large (< 20% occupied). */
DECL|method|rehashPostings
name|void
name|rehashPostings
parameter_list|(
specifier|final
name|int
name|newSize
parameter_list|)
block|{
specifier|final
name|int
name|newMask
init|=
name|newSize
operator|-
literal|1
decl_stmt|;
name|Posting
index|[]
name|newHash
init|=
operator|new
name|Posting
index|[
name|newSize
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|postingsHashSize
condition|;
name|i
operator|++
control|)
block|{
name|Posting
name|p0
init|=
name|postingsHash
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|p0
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|start
init|=
name|p0
operator|.
name|textStart
operator|&
name|DocumentsWriter
operator|.
name|CHAR_BLOCK_MASK
decl_stmt|;
specifier|final
name|char
index|[]
name|text
init|=
name|threadState
operator|.
name|charPool
operator|.
name|buffers
index|[
name|p0
operator|.
name|textStart
operator|>>
name|DocumentsWriter
operator|.
name|CHAR_BLOCK_SHIFT
index|]
decl_stmt|;
name|int
name|pos
init|=
name|start
decl_stmt|;
while|while
condition|(
name|text
index|[
name|pos
index|]
operator|!=
literal|0xffff
condition|)
name|pos
operator|++
expr_stmt|;
name|int
name|code
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pos
operator|>
name|start
condition|)
name|code
operator|=
operator|(
name|code
operator|*
literal|31
operator|)
operator|+
name|text
index|[
operator|--
name|pos
index|]
expr_stmt|;
name|int
name|hashPos
init|=
name|code
operator|&
name|newMask
decl_stmt|;
assert|assert
name|hashPos
operator|>=
literal|0
assert|;
if|if
condition|(
name|newHash
index|[
name|hashPos
index|]
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|inc
init|=
operator|(
operator|(
name|code
operator|>>
literal|8
operator|)
operator|+
name|code
operator|)
operator||
literal|1
decl_stmt|;
do|do
block|{
name|code
operator|+=
name|inc
expr_stmt|;
name|hashPos
operator|=
name|code
operator|&
name|newMask
expr_stmt|;
block|}
do|while
condition|(
name|newHash
index|[
name|hashPos
index|]
operator|!=
literal|null
condition|)
do|;
block|}
name|newHash
index|[
name|hashPos
index|]
operator|=
name|p0
expr_stmt|;
block|}
block|}
name|postingsHashMask
operator|=
name|newMask
expr_stmt|;
name|postingsHash
operator|=
name|newHash
expr_stmt|;
name|postingsHashSize
operator|=
name|newSize
expr_stmt|;
name|postingsHashHalfSize
operator|=
name|newSize
operator|>>
literal|1
expr_stmt|;
block|}
DECL|field|vectorSliceReader
specifier|final
name|ByteSliceReader
name|vectorSliceReader
init|=
operator|new
name|ByteSliceReader
argument_list|()
decl_stmt|;
comment|/** Called once per field per document if term vectors    *  are enabled, to write the vectors to *    *  RAMOutputStream, which is then quickly flushed to    *  * the real term vectors files in the Directory. */
DECL|method|writeVectors
name|void
name|writeVectors
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|fieldInfo
operator|.
name|storeTermVector
assert|;
assert|assert
name|threadState
operator|.
name|vectorFieldsInOrder
argument_list|(
name|fieldInfo
argument_list|)
assert|;
name|threadState
operator|.
name|vectorFieldNumbers
index|[
name|threadState
operator|.
name|numVectorFields
index|]
operator|=
name|fieldInfo
operator|.
name|number
expr_stmt|;
name|threadState
operator|.
name|vectorFieldPointers
index|[
name|threadState
operator|.
name|numVectorFields
index|]
operator|=
name|threadState
operator|.
name|tvfLocal
operator|.
name|getFilePointer
argument_list|()
expr_stmt|;
name|threadState
operator|.
name|numVectorFields
operator|++
expr_stmt|;
specifier|final
name|int
name|numPostingsVectors
init|=
name|postingsVectorsUpto
decl_stmt|;
specifier|final
name|PostingVector
index|[]
name|postingsVectors
init|=
name|threadState
operator|.
name|postingsVectors
decl_stmt|;
specifier|final
name|IndexOutput
name|tvfLocal
init|=
name|threadState
operator|.
name|tvfLocal
decl_stmt|;
name|threadState
operator|.
name|tvfLocal
operator|.
name|writeVInt
argument_list|(
name|numPostingsVectors
argument_list|)
expr_stmt|;
name|byte
name|bits
init|=
literal|0x0
decl_stmt|;
if|if
condition|(
name|doVectorPositions
condition|)
name|bits
operator||=
name|TermVectorsReader
operator|.
name|STORE_POSITIONS_WITH_TERMVECTOR
expr_stmt|;
if|if
condition|(
name|doVectorOffsets
condition|)
name|bits
operator||=
name|TermVectorsReader
operator|.
name|STORE_OFFSET_WITH_TERMVECTOR
expr_stmt|;
name|threadState
operator|.
name|tvfLocal
operator|.
name|writeByte
argument_list|(
name|bits
argument_list|)
expr_stmt|;
name|threadState
operator|.
name|doVectorSort
argument_list|(
name|postingsVectors
argument_list|,
name|numPostingsVectors
argument_list|)
expr_stmt|;
name|int
name|encoderUpto
init|=
literal|0
decl_stmt|;
name|int
name|lastTermBytesCount
init|=
literal|0
decl_stmt|;
specifier|final
name|ByteSliceReader
name|reader
init|=
name|vectorSliceReader
decl_stmt|;
specifier|final
name|char
index|[]
index|[]
name|charBuffers
init|=
name|threadState
operator|.
name|charPool
operator|.
name|buffers
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numPostingsVectors
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|PostingVector
name|vector
init|=
name|postingsVectors
index|[
name|j
index|]
decl_stmt|;
name|Posting
name|posting
init|=
name|vector
operator|.
name|p
decl_stmt|;
specifier|final
name|int
name|freq
init|=
name|posting
operator|.
name|docFreq
decl_stmt|;
specifier|final
name|char
index|[]
name|text2
init|=
name|charBuffers
index|[
name|posting
operator|.
name|textStart
operator|>>
name|DocumentsWriter
operator|.
name|CHAR_BLOCK_SHIFT
index|]
decl_stmt|;
specifier|final
name|int
name|start2
init|=
name|posting
operator|.
name|textStart
operator|&
name|DocumentsWriter
operator|.
name|CHAR_BLOCK_MASK
decl_stmt|;
comment|// We swap between two encoders to save copying
comment|// last Term's byte array
specifier|final
name|UnicodeUtil
operator|.
name|UTF8Result
name|utf8Result
init|=
name|threadState
operator|.
name|utf8Results
index|[
name|encoderUpto
index|]
decl_stmt|;
comment|// TODO: we could do this incrementally
name|UnicodeUtil
operator|.
name|UTF16toUTF8
argument_list|(
name|text2
argument_list|,
name|start2
argument_list|,
name|utf8Result
argument_list|)
expr_stmt|;
specifier|final
name|int
name|termBytesCount
init|=
name|utf8Result
operator|.
name|length
decl_stmt|;
comment|// TODO: UTF16toUTF8 could tell us this prefix
comment|// Compute common prefix between last term and
comment|// this term
name|int
name|prefix
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
specifier|final
name|byte
index|[]
name|lastTermBytes
init|=
name|threadState
operator|.
name|utf8Results
index|[
literal|1
operator|-
name|encoderUpto
index|]
operator|.
name|result
decl_stmt|;
specifier|final
name|byte
index|[]
name|termBytes
init|=
name|threadState
operator|.
name|utf8Results
index|[
name|encoderUpto
index|]
operator|.
name|result
decl_stmt|;
while|while
condition|(
name|prefix
operator|<
name|lastTermBytesCount
operator|&&
name|prefix
operator|<
name|termBytesCount
condition|)
block|{
if|if
condition|(
name|lastTermBytes
index|[
name|prefix
index|]
operator|!=
name|termBytes
index|[
name|prefix
index|]
condition|)
break|break;
name|prefix
operator|++
expr_stmt|;
block|}
block|}
name|encoderUpto
operator|=
literal|1
operator|-
name|encoderUpto
expr_stmt|;
name|lastTermBytesCount
operator|=
name|termBytesCount
expr_stmt|;
specifier|final
name|int
name|suffix
init|=
name|termBytesCount
operator|-
name|prefix
decl_stmt|;
name|tvfLocal
operator|.
name|writeVInt
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|tvfLocal
operator|.
name|writeVInt
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
name|tvfLocal
operator|.
name|writeBytes
argument_list|(
name|utf8Result
operator|.
name|result
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|tvfLocal
operator|.
name|writeVInt
argument_list|(
name|freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|doVectorPositions
condition|)
block|{
name|reader
operator|.
name|init
argument_list|(
name|threadState
operator|.
name|vectorsPool
argument_list|,
name|vector
operator|.
name|posStart
argument_list|,
name|vector
operator|.
name|posUpto
argument_list|)
expr_stmt|;
name|reader
operator|.
name|writeTo
argument_list|(
name|tvfLocal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doVectorOffsets
condition|)
block|{
name|reader
operator|.
name|init
argument_list|(
name|threadState
operator|.
name|vectorsPool
argument_list|,
name|vector
operator|.
name|offsetStart
argument_list|,
name|vector
operator|.
name|offsetUpto
argument_list|)
expr_stmt|;
name|reader
operator|.
name|writeTo
argument_list|(
name|tvfLocal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class
end_unit
