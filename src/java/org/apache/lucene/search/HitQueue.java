begin_unit
begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import
begin_class
DECL|class|HitQueue
specifier|final
class|class
name|HitQueue
extends|extends
name|PriorityQueue
argument_list|<
name|ScoreDoc
argument_list|>
block|{
DECL|field|prePopulate
specifier|private
name|boolean
name|prePopulate
decl_stmt|;
comment|/**    * Creates a new instance with<code>size</code> elements. If    *<code>prePopulate</code> is set to true, the queue will pre-populate itself    * with sentinel objects and set its {@link #size()} to<code>size</code>. In    * that case, you should not rely on {@link #size()} to get the number of    * actual elements that were added to the queue, but keep track yourself.<br>    *<b>NOTE:</b> in case<code>prePopulate</code> is true, you should pop    * elements from the queue using the following code example:    *     *<pre>    * PriorityQueue pq = new HitQueue(10, true); // pre-populate.    * ScoreDoc top = pq.top();    *     * // Add/Update one element.    * top.score = 1.0f;    * top.doc = 0;    * top = (ScoreDoc) pq.updateTop();    * int totalHits = 1;    *     * // Now pop only the elements that were *truly* inserted.    * // First, pop all the sentinel elements (there are pq.size() - totalHits).    * for (int i = pq.size() - totalHits; i&gt; 0; i--) pq.pop();    *     * // Now pop the truly added elements.    * ScoreDoc[] results = new ScoreDoc[totalHits];    * for (int i = totalHits - 1; i&gt;= 0; i--) {    *   results[i] = (ScoreDoc) pq.pop();    * }    *</pre>    *     *<p><b>NOTE</b>: This class pre-allocate a full array of    * length<code>size</code>.    *     * @param size    *          the requested size of this queue.    * @param prePopulate    *          specifies whether to pre-populate the queue with sentinel values.    * @see #getSentinelObject()    */
DECL|method|HitQueue
name|HitQueue
parameter_list|(
name|int
name|size
parameter_list|,
name|boolean
name|prePopulate
parameter_list|)
block|{
name|this
operator|.
name|prePopulate
operator|=
name|prePopulate
expr_stmt|;
name|initialize
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
comment|// Returns null if prePopulate is false.
annotation|@
name|Override
DECL|method|getSentinelObject
specifier|protected
name|ScoreDoc
name|getSentinelObject
parameter_list|()
block|{
comment|// Always set the doc Id to MAX_VALUE so that it won't be favored by
comment|// lessThan. This generally should not happen since if score is not NEG_INF,
comment|// TopScoreDocCollector will always add the object to the queue.
return|return
operator|!
name|prePopulate
condition|?
literal|null
else|:
operator|new
name|ScoreDoc
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|Float
operator|.
name|NEGATIVE_INFINITY
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|lessThan
specifier|protected
specifier|final
name|boolean
name|lessThan
parameter_list|(
name|ScoreDoc
name|hitA
parameter_list|,
name|ScoreDoc
name|hitB
parameter_list|)
block|{
if|if
condition|(
name|hitA
operator|.
name|score
operator|==
name|hitB
operator|.
name|score
condition|)
return|return
name|hitA
operator|.
name|doc
operator|>
name|hitB
operator|.
name|doc
return|;
else|else
return|return
name|hitA
operator|.
name|score
operator|<
name|hitB
operator|.
name|score
return|;
block|}
block|}
end_class
end_unit
