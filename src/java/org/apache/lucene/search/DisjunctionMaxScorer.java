begin_unit
begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package
begin_comment
comment|/**  * Copyright 2004 The Apache Software Foundation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_comment
comment|/**  * The Scorer for DisjunctionMaxQuery's.  The union of all documents generated by the the subquery scorers  * is generated in document number order.  The score for each document is the maximum of the scores computed  * by the subquery scorers that generate that document, plus tieBreakerMultiplier times the sum of the scores  * for the other subqueries that generate the document.  * @author Chuck Williams  */
end_comment
begin_class
DECL|class|DisjunctionMaxScorer
class|class
name|DisjunctionMaxScorer
extends|extends
name|Scorer
block|{
comment|/* The scorers for subqueries that have remaining docs, kept sorted by number of next doc. */
DECL|field|subScorers
specifier|private
name|ArrayList
name|subScorers
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
comment|/* Multiplier applied to non-maximum-scoring subqueries for a document as they are summed into the result. */
DECL|field|tieBreakerMultiplier
specifier|private
name|float
name|tieBreakerMultiplier
decl_stmt|;
DECL|field|more
specifier|private
name|boolean
name|more
init|=
literal|false
decl_stmt|;
comment|// True iff there is a next document
DECL|field|firstTime
specifier|private
name|boolean
name|firstTime
init|=
literal|true
decl_stmt|;
comment|// True iff next() has not yet been called
comment|/* Comparator to sort subScorers according to the document number of next document */
DECL|class|DisjunctionMaxClauseComparator
specifier|private
specifier|static
class|class
name|DisjunctionMaxClauseComparator
implements|implements
name|Comparator
block|{
comment|/* Scorers have all been positioned at their next document already */
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
name|Object
name|o1
parameter_list|,
name|Object
name|o2
parameter_list|)
block|{
if|if
condition|(
name|o1
operator|instanceof
name|Scorer
operator|&&
name|o2
operator|instanceof
name|Scorer
condition|)
block|{
name|Scorer
name|s1
init|=
operator|(
name|Scorer
operator|)
name|o1
decl_stmt|;
name|Scorer
name|s2
init|=
operator|(
name|Scorer
operator|)
name|o2
decl_stmt|;
return|return
name|s1
operator|.
name|doc
argument_list|()
operator|-
name|s2
operator|.
name|doc
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Objects not of the type 'Scorer'"
argument_list|)
throw|;
block|}
block|}
comment|/* Compatible equality */
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Scorer
name|s1
parameter_list|,
name|Scorer
name|s2
parameter_list|)
block|{
return|return
name|s1
operator|.
name|doc
argument_list|()
operator|==
name|s2
operator|.
name|doc
argument_list|()
return|;
block|}
block|}
comment|/* Fixed instance of the comparator to reuse */
DECL|field|subScorerComparator
specifier|private
specifier|static
name|DisjunctionMaxClauseComparator
name|subScorerComparator
init|=
operator|new
name|DisjunctionMaxClauseComparator
argument_list|()
decl_stmt|;
comment|/** Creates a new instance of DisjunctionMaxScorer      * @param similarity -- not used since our definition involves neither coord nor terms directly */
DECL|method|DisjunctionMaxScorer
specifier|public
name|DisjunctionMaxScorer
parameter_list|(
name|float
name|tieBreakerMultiplier
parameter_list|,
name|Similarity
name|similarity
parameter_list|)
block|{
name|super
argument_list|(
name|similarity
argument_list|)
expr_stmt|;
name|this
operator|.
name|tieBreakerMultiplier
operator|=
name|tieBreakerMultiplier
expr_stmt|;
block|}
comment|/** Add the scorer for a subquery      * @param scorer the scorer of a subquery of our associated DisjunctionMaxQuery      */
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|scorer
operator|.
name|next
argument_list|()
condition|)
block|{
comment|// Initialize and retain only if it produces docs
name|subScorers
operator|.
name|add
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
name|more
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/* First time initialization.  Sort subScorers. */
DECL|method|init
specifier|private
name|void
name|init
parameter_list|()
block|{
name|sortSubScorers
argument_list|()
expr_stmt|;
name|firstTime
operator|=
literal|false
expr_stmt|;
block|}
comment|/* Sort subScorers in order of document number of next document to be generated */
DECL|method|sortSubScorers
specifier|private
name|void
name|sortSubScorers
parameter_list|()
block|{
name|Scorer
index|[]
name|sorted
init|=
operator|(
name|Scorer
index|[]
operator|)
name|subScorers
operator|.
name|toArray
argument_list|(
operator|new
name|Scorer
index|[
name|subScorers
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|sorted
argument_list|,
name|subScorerComparator
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sorted
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|subScorers
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|sorted
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/** Generate the next document matching our associated DisjunctionMaxQuery.      * @return true iff there is a next document      */
DECL|method|next
specifier|public
name|boolean
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|more
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|firstTime
condition|)
block|{
name|init
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
comment|// more would have been false if no subScorers had any docs
block|}
comment|// Increment all generators that generated the last doc and incrementally re-sort.
name|int
name|lastdoc
init|=
operator|(
operator|(
name|Scorer
operator|)
name|subScorers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|doc
argument_list|()
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
operator|(
name|Scorer
operator|)
name|subScorers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|next
argument_list|()
condition|)
block|{
name|Scorer
name|s
init|=
operator|(
name|Scorer
operator|)
name|subScorers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|snextdoc
init|=
name|s
operator|.
name|doc
argument_list|()
decl_stmt|,
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
name|i
argument_list|<
name|subScorers
operator|.
name|size
operator|(
operator|)
operator|&&
name|snextdoc
argument_list|>
argument_list|(
operator|(
name|Scorer
operator|)
name|subScorers
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|doc
argument_list|()
condition|;
name|i
operator|++
control|)
name|subScorers
operator|.
name|set
argument_list|(
name|i
operator|-
literal|1
argument_list|,
name|subScorers
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|subScorers
operator|.
name|set
argument_list|(
name|i
operator|-
literal|1
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subScorers
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|subScorers
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
operator|(
name|more
operator|=
literal|false
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|(
operator|(
name|Scorer
operator|)
name|subScorers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|doc
argument_list|()
operator|==
name|lastdoc
condition|)
do|;
return|return
literal|true
return|;
block|}
comment|/** Determine the current document number.  Initially invalid, until {@link #next()} is called the first time.      * @return the document number of the currently generated document      */
DECL|method|doc
specifier|public
name|int
name|doc
parameter_list|()
block|{
return|return
operator|(
operator|(
name|Scorer
operator|)
name|subScorers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|doc
argument_list|()
return|;
block|}
comment|/** Determine the current document score.  Initially invalid, until {@link #next()} is called the first time.      * @return the score of the current generated document      */
DECL|method|score
specifier|public
name|float
name|score
parameter_list|()
throws|throws
name|IOException
block|{
name|float
name|max
init|=
operator|(
operator|(
name|Scorer
operator|)
name|subScorers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|score
argument_list|()
decl_stmt|,
name|sum
init|=
name|max
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|,
name|doc
init|=
operator|(
operator|(
name|Scorer
operator|)
name|subScorers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|doc
argument_list|()
init|;
name|i
operator|<
name|subScorers
operator|.
name|size
argument_list|()
operator|&&
operator|(
operator|(
name|Scorer
operator|)
name|subScorers
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|doc
argument_list|()
operator|==
name|doc
condition|;
name|i
operator|++
control|)
block|{
name|float
name|sub
init|=
operator|(
operator|(
name|Scorer
operator|)
name|subScorers
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|score
argument_list|()
decl_stmt|;
name|sum
operator|+=
name|sub
expr_stmt|;
name|max
operator|=
name|Math
operator|.
name|max
argument_list|(
name|max
argument_list|,
name|sub
argument_list|)
expr_stmt|;
block|}
return|return
name|max
operator|+
operator|(
name|sum
operator|-
name|max
operator|)
operator|*
name|tieBreakerMultiplier
return|;
block|}
comment|/** Advance to the first document beyond the current whose number is greater than or equal to target.      * @param target the minimum number of the next desired document      * @return true iff there is a document to be generated whose number is at least target      */
DECL|method|skipTo
specifier|public
name|boolean
name|skipTo
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|subScorers
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|Scorer
operator|)
name|subScorers
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|doc
argument_list|()
operator|<
name|target
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|Scorer
operator|)
name|subScorers
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|skipTo
argument_list|(
name|target
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
else|else
name|subScorers
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
literal|false
return|;
name|sortSubScorers
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/** Explain a score that we computed.  UNSUPPORTED -- see explanation capability in DisjunctionMaxQuery.      * @param doc the number of a document we scored      * @return the Explanation for our score      */
DECL|method|explain
specifier|public
name|Explanation
name|explain
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
end_class
begin_comment
comment|/***************************************************************************  Implementation notes from http://issues.apache.org/jira/browse/LUCENE-323    There is an issue with the MaxDisjunctionScorer in the .zip attachment, I'm  sorry I did not see this earlier when I posted on java-dev about this.   The problem is that MaxDisjunctionScorer uses bubble sort to keep the subscorer  sorted over the documents in the next() method (line 103), and this does not scale nicely  when the number of subscorers increases.  Supposing the number of subscores that match the document is N,  the amount of work to be done is proportional to (N*N) per document.  In DisjunctionSumScorer a priority queue is used, and there the amount of work is  proportional to (N log(N)) per document.  So I would recommend to rewrite MaxDisjunctionScorer to inherit from a new common  super class with DisjunctionSumScorer, sharing everything except the  advanceAfterCurrent() method (which could be abstract in the new superclass).  It's possible to be more aggressive in refactoring by initializing and adapting  the score per index document using different methods, but this would take N  extra method calls per document.   At the same time the name could be changed to DisjunctionMaxScorer  for consistency in the org.lucene.search package.   Regards,  Paul Elschot   Comment by Chuck Williams [14/Nov/05 11:55 PM]  The code only uses bubble sort for the incremental resorting of an already-sorted list. The initial sort is done with Arrays.sort() which is O(n*logn). The incremental resort is O(k*n) where k is the number of clauses that match the document last generated. Even if n is large, k will usually be small. Theoretically this is O(n^2) because k could be as high as n, but this is extremely unlikely especially when n is large. More likely is that k is bounded by a small constant, in which case the algorithm is O(n). It's like Quicksort in that regard -- there are outlier cases where it won't perform well, but it will perform better than most alternatives for the vast majority of cases.   Resorting the whole list every time would perform worse. The best algorithm would probably be to use the standard insert and delete operations on a heap (as in heap sort):     while top element generated last doc        heap remove it        generate it        heap insert it   This would yield total time O(k*logn), as with a PriorityQueue.   I don't think this is much of an issue to worry about, but the algorithm could be revised to use the heap sort operations if others think it is important.   Chuck  *********************************************************************/
end_comment
end_unit
