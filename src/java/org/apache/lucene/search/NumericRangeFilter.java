begin_unit
begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|NumericTokenStream
import|;
end_import
begin_comment
comment|// for javadocs
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|NumericField
import|;
end_import
begin_comment
comment|// for javadocs
end_comment
begin_comment
comment|/**  * Implementation of a {@link Filter} that implements<em>trie-based</em> range filtering  * for numeric values. For more information about the algorithm look into the docs of  * {@link NumericRangeQuery}.  *  *<p>This filter depends on a specific structure of terms in the index that can only be created  * by indexing using {@link NumericField} (expert: {@link NumericTokenStream}).  *  *<p><b>Please note:</b> This class has no constructor, you can create filters depending on the data type  * by using the static factories {@linkplain #newLongRange NumericRangeFilter.newLongRange()},  * {@linkplain #newIntRange NumericRangeFilter.newIntRange()}, {@linkplain #newDoubleRange NumericRangeFilter.newDoubleRange()},  * and {@linkplain #newFloatRange NumericRangeFilter.newFloatRange()}, e.g.:  *<pre>  * Filter f = NumericRangeFilter.newFloatRange(field,<a href="NumericRangeQuery.html#precisionStepDesc">precisionStep</a>,  *                                             new Float(0.3f), new Float(0.10f),  *                                             true, true);  *</pre>  *  *<p><font color="red"><b>NOTE:</b> This API is experimental and  * might change in incompatible ways in the next release.</font>  *  * @since 2.9  **/
end_comment
begin_class
DECL|class|NumericRangeFilter
specifier|public
specifier|final
class|class
name|NumericRangeFilter
extends|extends
name|MultiTermQueryWrapperFilter
block|{
DECL|method|NumericRangeFilter
specifier|private
name|NumericRangeFilter
parameter_list|(
specifier|final
name|NumericRangeQuery
name|query
parameter_list|)
block|{
name|super
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
comment|/**    * Factory that creates a<code>NumericRangeFilter</code>, that filters a<code>long</code>    * range using the given<a href="NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>.    * You can have half-open ranges (which are in fact&lt;/&le; or&gt;/&ge; queries)    * by setting the min or max value to<code>null</code>. By setting inclusive to false, it will    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.    */
DECL|method|newLongRange
specifier|public
specifier|static
name|NumericRangeFilter
name|newLongRange
parameter_list|(
specifier|final
name|String
name|field
parameter_list|,
specifier|final
name|int
name|precisionStep
parameter_list|,
name|Long
name|min
parameter_list|,
name|Long
name|max
parameter_list|,
specifier|final
name|boolean
name|minInclusive
parameter_list|,
specifier|final
name|boolean
name|maxInclusive
parameter_list|)
block|{
return|return
operator|new
name|NumericRangeFilter
argument_list|(
name|NumericRangeQuery
operator|.
name|newLongRange
argument_list|(
name|field
argument_list|,
name|precisionStep
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|minInclusive
argument_list|,
name|maxInclusive
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Factory that creates a<code>NumericRangeFilter</code>, that filters a<code>int</code>    * range using the given<a href="NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>.    * You can have half-open ranges (which are in fact&lt;/&le; or&gt;/&ge; queries)    * by setting the min or max value to<code>null</code>. By setting inclusive to false, it will    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.    */
DECL|method|newIntRange
specifier|public
specifier|static
name|NumericRangeFilter
name|newIntRange
parameter_list|(
specifier|final
name|String
name|field
parameter_list|,
specifier|final
name|int
name|precisionStep
parameter_list|,
name|Integer
name|min
parameter_list|,
name|Integer
name|max
parameter_list|,
specifier|final
name|boolean
name|minInclusive
parameter_list|,
specifier|final
name|boolean
name|maxInclusive
parameter_list|)
block|{
return|return
operator|new
name|NumericRangeFilter
argument_list|(
name|NumericRangeQuery
operator|.
name|newIntRange
argument_list|(
name|field
argument_list|,
name|precisionStep
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|minInclusive
argument_list|,
name|maxInclusive
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Factory that creates a<code>NumericRangeFilter</code>, that filters a<code>double</code>    * range using the given<a href="NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>.    * You can have half-open ranges (which are in fact&lt;/&le; or&gt;/&ge; queries)    * by setting the min or max value to<code>null</code>. By setting inclusive to false, it will    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.    */
DECL|method|newDoubleRange
specifier|public
specifier|static
name|NumericRangeFilter
name|newDoubleRange
parameter_list|(
specifier|final
name|String
name|field
parameter_list|,
specifier|final
name|int
name|precisionStep
parameter_list|,
name|Double
name|min
parameter_list|,
name|Double
name|max
parameter_list|,
specifier|final
name|boolean
name|minInclusive
parameter_list|,
specifier|final
name|boolean
name|maxInclusive
parameter_list|)
block|{
return|return
operator|new
name|NumericRangeFilter
argument_list|(
name|NumericRangeQuery
operator|.
name|newDoubleRange
argument_list|(
name|field
argument_list|,
name|precisionStep
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|minInclusive
argument_list|,
name|maxInclusive
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Factory that creates a<code>NumericRangeFilter</code>, that filters a<code>float</code>    * range using the given<a href="NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>.    * You can have half-open ranges (which are in fact&lt;/&le; or&gt;/&ge; queries)    * by setting the min or max value to<code>null</code>. By setting inclusive to false, it will    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.    */
DECL|method|newFloatRange
specifier|public
specifier|static
name|NumericRangeFilter
name|newFloatRange
parameter_list|(
specifier|final
name|String
name|field
parameter_list|,
specifier|final
name|int
name|precisionStep
parameter_list|,
name|Float
name|min
parameter_list|,
name|Float
name|max
parameter_list|,
specifier|final
name|boolean
name|minInclusive
parameter_list|,
specifier|final
name|boolean
name|maxInclusive
parameter_list|)
block|{
return|return
operator|new
name|NumericRangeFilter
argument_list|(
name|NumericRangeQuery
operator|.
name|newFloatRange
argument_list|(
name|field
argument_list|,
name|precisionStep
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|minInclusive
argument_list|,
name|maxInclusive
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns the field name for this filter */
DECL|method|getField
specifier|public
name|String
name|getField
parameter_list|()
block|{
return|return
operator|(
operator|(
name|NumericRangeQuery
operator|)
name|query
operator|)
operator|.
name|getField
argument_list|()
return|;
block|}
comment|/** Returns<code>true</code> if the lower endpoint is inclusive */
DECL|method|includesMin
specifier|public
name|boolean
name|includesMin
parameter_list|()
block|{
return|return
operator|(
operator|(
name|NumericRangeQuery
operator|)
name|query
operator|)
operator|.
name|includesMin
argument_list|()
return|;
block|}
comment|/** Returns<code>true</code> if the upper endpoint is inclusive */
DECL|method|includesMax
specifier|public
name|boolean
name|includesMax
parameter_list|()
block|{
return|return
operator|(
operator|(
name|NumericRangeQuery
operator|)
name|query
operator|)
operator|.
name|includesMax
argument_list|()
return|;
block|}
comment|/** Returns the lower value of this range filter */
DECL|method|getMin
specifier|public
name|Number
name|getMin
parameter_list|()
block|{
return|return
operator|(
operator|(
name|NumericRangeQuery
operator|)
name|query
operator|)
operator|.
name|getMin
argument_list|()
return|;
block|}
comment|/** Returns the upper value of this range filter */
DECL|method|getMax
specifier|public
name|Number
name|getMax
parameter_list|()
block|{
return|return
operator|(
operator|(
name|NumericRangeQuery
operator|)
name|query
operator|)
operator|.
name|getMax
argument_list|()
return|;
block|}
block|}
end_class
end_unit
