begin_unit
begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FieldValueHitQueue
operator|.
name|Entry
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import
begin_comment
comment|/**  * A {@link Collector} that sorts by {@link SortField} using  * {@link FieldComparator}s.  *<p/>  * See the {@link #create(org.apache.lucene.search.Sort, int, boolean, boolean, boolean, boolean)} method  * for instantiating a TopFieldCollector.  *   *<p><b>NOTE:</b> This API is experimental and might change in  * incompatible ways in the next release.</p>  */
end_comment
begin_class
DECL|class|TopFieldCollector
specifier|public
specifier|abstract
class|class
name|TopFieldCollector
extends|extends
name|TopDocsCollector
argument_list|<
name|Entry
argument_list|>
block|{
comment|// TODO: one optimization we could do is to pre-fill
comment|// the queue with sentinel value that guaranteed to
comment|// always compare lower than a real hit; this would
comment|// save having to check queueFull on each insert
comment|/*    * Implements a TopFieldCollector over one SortField criteria, without    * tracking document scores and maxScore.    */
DECL|class|OneComparatorNonScoringCollector
specifier|private
specifier|static
class|class
name|OneComparatorNonScoringCollector
extends|extends
name|TopFieldCollector
block|{
DECL|field|comparator
specifier|final
name|FieldComparator
name|comparator
decl_stmt|;
DECL|field|reverseMul
specifier|final
name|int
name|reverseMul
decl_stmt|;
DECL|method|OneComparatorNonScoringCollector
specifier|public
name|OneComparatorNonScoringCollector
parameter_list|(
name|FieldValueHitQueue
name|queue
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
expr_stmt|;
name|comparator
operator|=
name|queue
operator|.
name|getComparators
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
name|reverseMul
operator|=
name|queue
operator|.
name|getReverseMul
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
block|}
DECL|method|updateBottom
specifier|final
name|void
name|updateBottom
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
comment|// bottom.score is already set to Float.NaN in add().
name|bottom
operator|.
name|docID
operator|=
name|docBase
operator|+
name|doc
expr_stmt|;
name|bottom
operator|=
name|pq
operator|.
name|updateTop
argument_list|()
expr_stmt|;
block|}
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
if|if
condition|(
operator|(
name|reverseMul
operator|*
name|comparator
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
comment|// since docs are visited in doc Id order, if compare is 0, it means
comment|// this document is largest than anything else in the queue, and
comment|// therefore not competitive.
return|return;
block|}
comment|// This hit is competitive - replace bottom element in queue& adjustTop
name|comparator
operator|.
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|updateBottom
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
name|comparator
operator|.
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|Float
operator|.
name|NaN
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|setNextReader
specifier|public
name|void
name|setNextReader
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|int
name|docBase
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|docBase
operator|=
name|docBase
expr_stmt|;
name|comparator
operator|.
name|setNextReader
argument_list|(
name|reader
argument_list|,
name|docBase
argument_list|)
expr_stmt|;
block|}
DECL|method|setScorer
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|comparator
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Implements a TopFieldCollector over one SortField criteria, without    * tracking document scores and maxScore, and assumes out of orderness in doc    * Ids collection.    */
DECL|class|OutOfOrderOneComparatorNonScoringCollector
specifier|private
specifier|static
class|class
name|OutOfOrderOneComparatorNonScoringCollector
extends|extends
name|OneComparatorNonScoringCollector
block|{
DECL|method|OutOfOrderOneComparatorNonScoringCollector
specifier|public
name|OutOfOrderOneComparatorNonScoringCollector
parameter_list|(
name|FieldValueHitQueue
name|queue
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
expr_stmt|;
block|}
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
comment|// Fastmatch: return if this hit is not competitive
specifier|final
name|int
name|cmp
init|=
name|reverseMul
operator|*
name|comparator
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
operator|||
operator|(
name|cmp
operator|==
literal|0
operator|&&
name|doc
operator|+
name|docBase
operator|>
name|bottom
operator|.
name|docID
operator|)
condition|)
block|{
return|return;
block|}
comment|// This hit is competitive - replace bottom element in queue& adjustTop
name|comparator
operator|.
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|updateBottom
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
name|comparator
operator|.
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|Float
operator|.
name|NaN
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|acceptsDocsOutOfOrder
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/*    * Implements a TopFieldCollector over one SortField criteria, while tracking    * document scores but no maxScore.    */
DECL|class|OneComparatorScoringNoMaxScoreCollector
specifier|private
specifier|static
class|class
name|OneComparatorScoringNoMaxScoreCollector
extends|extends
name|OneComparatorNonScoringCollector
block|{
DECL|field|scorer
name|Scorer
name|scorer
decl_stmt|;
DECL|method|OneComparatorScoringNoMaxScoreCollector
specifier|public
name|OneComparatorScoringNoMaxScoreCollector
parameter_list|(
name|FieldValueHitQueue
name|queue
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
expr_stmt|;
block|}
DECL|method|updateBottom
specifier|final
name|void
name|updateBottom
parameter_list|(
name|int
name|doc
parameter_list|,
name|float
name|score
parameter_list|)
block|{
name|bottom
operator|.
name|docID
operator|=
name|docBase
operator|+
name|doc
expr_stmt|;
name|bottom
operator|.
name|score
operator|=
name|score
expr_stmt|;
name|bottom
operator|=
name|pq
operator|.
name|updateTop
argument_list|()
expr_stmt|;
block|}
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
if|if
condition|(
operator|(
name|reverseMul
operator|*
name|comparator
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
comment|// since docs are visited in doc Id order, if compare is 0, it means
comment|// this document is largest than anything else in the queue, and
comment|// therefore not competitive.
return|return;
block|}
comment|// Compute the score only if the hit is competitive.
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
comment|// This hit is competitive - replace bottom element in queue& adjustTop
name|comparator
operator|.
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|updateBottom
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Compute the score only if the hit is competitive.
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
name|comparator
operator|.
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|setScorer
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
name|comparator
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Implements a TopFieldCollector over one SortField criteria, while tracking    * document scores but no maxScore, and assumes out of orderness in doc Ids    * collection.    */
DECL|class|OutOfOrderOneComparatorScoringNoMaxScoreCollector
specifier|private
specifier|static
class|class
name|OutOfOrderOneComparatorScoringNoMaxScoreCollector
extends|extends
name|OneComparatorScoringNoMaxScoreCollector
block|{
DECL|method|OutOfOrderOneComparatorScoringNoMaxScoreCollector
specifier|public
name|OutOfOrderOneComparatorScoringNoMaxScoreCollector
parameter_list|(
name|FieldValueHitQueue
name|queue
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
expr_stmt|;
block|}
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
comment|// Fastmatch: return if this hit is not competitive
specifier|final
name|int
name|cmp
init|=
name|reverseMul
operator|*
name|comparator
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
operator|||
operator|(
name|cmp
operator|==
literal|0
operator|&&
name|doc
operator|+
name|docBase
operator|>
name|bottom
operator|.
name|docID
operator|)
condition|)
block|{
return|return;
block|}
comment|// Compute the score only if the hit is competitive.
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
comment|// This hit is competitive - replace bottom element in queue& adjustTop
name|comparator
operator|.
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|updateBottom
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Compute the score only if the hit is competitive.
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
name|comparator
operator|.
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|acceptsDocsOutOfOrder
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/*    * Implements a TopFieldCollector over one SortField criteria, with tracking    * document scores and maxScore.    */
DECL|class|OneComparatorScoringMaxScoreCollector
specifier|private
specifier|static
class|class
name|OneComparatorScoringMaxScoreCollector
extends|extends
name|OneComparatorNonScoringCollector
block|{
DECL|field|scorer
name|Scorer
name|scorer
decl_stmt|;
DECL|method|OneComparatorScoringMaxScoreCollector
specifier|public
name|OneComparatorScoringMaxScoreCollector
parameter_list|(
name|FieldValueHitQueue
name|queue
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
expr_stmt|;
comment|// Must set maxScore to NEG_INF, or otherwise Math.max always returns NaN.
name|maxScore
operator|=
name|Float
operator|.
name|NEGATIVE_INFINITY
expr_stmt|;
block|}
DECL|method|updateBottom
specifier|final
name|void
name|updateBottom
parameter_list|(
name|int
name|doc
parameter_list|,
name|float
name|score
parameter_list|)
block|{
name|bottom
operator|.
name|docID
operator|=
name|docBase
operator|+
name|doc
expr_stmt|;
name|bottom
operator|.
name|score
operator|=
name|score
expr_stmt|;
name|bottom
operator|=
name|pq
operator|.
name|updateTop
argument_list|()
expr_stmt|;
block|}
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
if|if
condition|(
name|score
operator|>
name|maxScore
condition|)
block|{
name|maxScore
operator|=
name|score
expr_stmt|;
block|}
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
if|if
condition|(
operator|(
name|reverseMul
operator|*
name|comparator
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
comment|// since docs are visited in doc Id order, if compare is 0, it means
comment|// this document is largest than anything else in the queue, and
comment|// therefore not competitive.
return|return;
block|}
comment|// This hit is competitive - replace bottom element in queue& adjustTop
name|comparator
operator|.
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|updateBottom
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
name|comparator
operator|.
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|setScorer
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
name|super
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Implements a TopFieldCollector over one SortField criteria, with tracking    * document scores and maxScore, and assumes out of orderness in doc Ids    * collection.    */
DECL|class|OutOfOrderOneComparatorScoringMaxScoreCollector
specifier|private
specifier|static
class|class
name|OutOfOrderOneComparatorScoringMaxScoreCollector
extends|extends
name|OneComparatorScoringMaxScoreCollector
block|{
DECL|method|OutOfOrderOneComparatorScoringMaxScoreCollector
specifier|public
name|OutOfOrderOneComparatorScoringMaxScoreCollector
parameter_list|(
name|FieldValueHitQueue
name|queue
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
expr_stmt|;
block|}
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
if|if
condition|(
name|score
operator|>
name|maxScore
condition|)
block|{
name|maxScore
operator|=
name|score
expr_stmt|;
block|}
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
comment|// Fastmatch: return if this hit is not competitive
specifier|final
name|int
name|cmp
init|=
name|reverseMul
operator|*
name|comparator
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
operator|||
operator|(
name|cmp
operator|==
literal|0
operator|&&
name|doc
operator|+
name|docBase
operator|>
name|bottom
operator|.
name|docID
operator|)
condition|)
block|{
return|return;
block|}
comment|// This hit is competitive - replace bottom element in queue& adjustTop
name|comparator
operator|.
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|updateBottom
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
name|comparator
operator|.
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|acceptsDocsOutOfOrder
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/*    * Implements a TopFieldCollector over multiple SortField criteria, without    * tracking document scores and maxScore.    */
DECL|class|MultiComparatorNonScoringCollector
specifier|private
specifier|static
class|class
name|MultiComparatorNonScoringCollector
extends|extends
name|TopFieldCollector
block|{
DECL|field|comparators
specifier|final
name|FieldComparator
index|[]
name|comparators
decl_stmt|;
DECL|field|reverseMul
specifier|final
name|int
index|[]
name|reverseMul
decl_stmt|;
DECL|method|MultiComparatorNonScoringCollector
specifier|public
name|MultiComparatorNonScoringCollector
parameter_list|(
name|FieldValueHitQueue
name|queue
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
expr_stmt|;
name|comparators
operator|=
name|queue
operator|.
name|getComparators
argument_list|()
expr_stmt|;
name|reverseMul
operator|=
name|queue
operator|.
name|getReverseMul
argument_list|()
expr_stmt|;
block|}
DECL|method|updateBottom
specifier|final
name|void
name|updateBottom
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
comment|// bottom.score is already set to Float.NaN in add().
name|bottom
operator|.
name|docID
operator|=
name|docBase
operator|+
name|doc
expr_stmt|;
name|bottom
operator|=
name|pq
operator|.
name|updateTop
argument_list|()
expr_stmt|;
block|}
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
comment|// Fastmatch: return if this hit is not competitive
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|c
init|=
name|reverseMul
index|[
name|i
index|]
operator|*
name|comparators
index|[
name|i
index|]
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
comment|// Definitely not competitive.
return|return;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
comment|// Definitely competitive.
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|comparators
operator|.
name|length
operator|-
literal|1
condition|)
block|{
comment|// Here c=0. If we're at the last comparator, this doc is not
comment|// competitive, since docs are visited in doc Id order, which means
comment|// this doc cannot compete with any other document in the queue.
return|return;
block|}
block|}
comment|// This hit is competitive - replace bottom element in queue& adjustTop
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
name|updateBottom
argument_list|(
name|doc
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|Float
operator|.
name|NaN
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|setNextReader
specifier|public
name|void
name|setNextReader
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|int
name|docBase
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|docBase
operator|=
name|docBase
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|setNextReader
argument_list|(
name|reader
argument_list|,
name|docBase
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setScorer
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
comment|// set the scorer on all comparators
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*    * Implements a TopFieldCollector over multiple SortField criteria, without    * tracking document scores and maxScore, and assumes out of orderness in doc    * Ids collection.    */
DECL|class|OutOfOrderMultiComparatorNonScoringCollector
specifier|private
specifier|static
class|class
name|OutOfOrderMultiComparatorNonScoringCollector
extends|extends
name|MultiComparatorNonScoringCollector
block|{
DECL|method|OutOfOrderMultiComparatorNonScoringCollector
specifier|public
name|OutOfOrderMultiComparatorNonScoringCollector
parameter_list|(
name|FieldValueHitQueue
name|queue
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
expr_stmt|;
block|}
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
comment|// Fastmatch: return if this hit is not competitive
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|c
init|=
name|reverseMul
index|[
name|i
index|]
operator|*
name|comparators
index|[
name|i
index|]
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
comment|// Definitely not competitive.
return|return;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
comment|// Definitely competitive.
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|comparators
operator|.
name|length
operator|-
literal|1
condition|)
block|{
comment|// This is the equals case.
if|if
condition|(
name|doc
operator|+
name|docBase
operator|>
name|bottom
operator|.
name|docID
condition|)
block|{
comment|// Definitely not competitive
return|return;
block|}
break|break;
block|}
block|}
comment|// This hit is competitive - replace bottom element in queue& adjustTop
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
name|updateBottom
argument_list|(
name|doc
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|Float
operator|.
name|NaN
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|acceptsDocsOutOfOrder
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/*    * Implements a TopFieldCollector over multiple SortField criteria, with    * tracking document scores and maxScore.    */
DECL|class|MultiComparatorScoringMaxScoreCollector
specifier|private
specifier|static
class|class
name|MultiComparatorScoringMaxScoreCollector
extends|extends
name|MultiComparatorNonScoringCollector
block|{
DECL|field|scorer
name|Scorer
name|scorer
decl_stmt|;
DECL|method|MultiComparatorScoringMaxScoreCollector
specifier|public
name|MultiComparatorScoringMaxScoreCollector
parameter_list|(
name|FieldValueHitQueue
name|queue
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
expr_stmt|;
comment|// Must set maxScore to NEG_INF, or otherwise Math.max always returns NaN.
name|maxScore
operator|=
name|Float
operator|.
name|NEGATIVE_INFINITY
expr_stmt|;
block|}
DECL|method|updateBottom
specifier|final
name|void
name|updateBottom
parameter_list|(
name|int
name|doc
parameter_list|,
name|float
name|score
parameter_list|)
block|{
name|bottom
operator|.
name|docID
operator|=
name|docBase
operator|+
name|doc
expr_stmt|;
name|bottom
operator|.
name|score
operator|=
name|score
expr_stmt|;
name|bottom
operator|=
name|pq
operator|.
name|updateTop
argument_list|()
expr_stmt|;
block|}
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
if|if
condition|(
name|score
operator|>
name|maxScore
condition|)
block|{
name|maxScore
operator|=
name|score
expr_stmt|;
block|}
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
comment|// Fastmatch: return if this hit is not competitive
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|c
init|=
name|reverseMul
index|[
name|i
index|]
operator|*
name|comparators
index|[
name|i
index|]
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
comment|// Definitely not competitive.
return|return;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
comment|// Definitely competitive.
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|comparators
operator|.
name|length
operator|-
literal|1
condition|)
block|{
comment|// Here c=0. If we're at the last comparator, this doc is not
comment|// competitive, since docs are visited in doc Id order, which means
comment|// this doc cannot compete with any other document in the queue.
return|return;
block|}
block|}
comment|// This hit is competitive - replace bottom element in queue& adjustTop
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
name|updateBottom
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|setScorer
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
name|super
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Implements a TopFieldCollector over multiple SortField criteria, with    * tracking document scores and maxScore, and assumes out of orderness in doc    * Ids collection.    */
DECL|class|OutOfOrderMultiComparatorScoringMaxScoreCollector
specifier|private
specifier|final
specifier|static
class|class
name|OutOfOrderMultiComparatorScoringMaxScoreCollector
extends|extends
name|MultiComparatorScoringMaxScoreCollector
block|{
DECL|method|OutOfOrderMultiComparatorScoringMaxScoreCollector
specifier|public
name|OutOfOrderMultiComparatorScoringMaxScoreCollector
parameter_list|(
name|FieldValueHitQueue
name|queue
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
expr_stmt|;
block|}
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
if|if
condition|(
name|score
operator|>
name|maxScore
condition|)
block|{
name|maxScore
operator|=
name|score
expr_stmt|;
block|}
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
comment|// Fastmatch: return if this hit is not competitive
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|c
init|=
name|reverseMul
index|[
name|i
index|]
operator|*
name|comparators
index|[
name|i
index|]
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
comment|// Definitely not competitive.
return|return;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
comment|// Definitely competitive.
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|comparators
operator|.
name|length
operator|-
literal|1
condition|)
block|{
comment|// This is the equals case.
if|if
condition|(
name|doc
operator|+
name|docBase
operator|>
name|bottom
operator|.
name|docID
condition|)
block|{
comment|// Definitely not competitive
return|return;
block|}
break|break;
block|}
block|}
comment|// This hit is competitive - replace bottom element in queue& adjustTop
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
name|updateBottom
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|acceptsDocsOutOfOrder
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/*    * Implements a TopFieldCollector over multiple SortField criteria, with    * tracking document scores and maxScore.    */
DECL|class|MultiComparatorScoringNoMaxScoreCollector
specifier|private
specifier|static
class|class
name|MultiComparatorScoringNoMaxScoreCollector
extends|extends
name|MultiComparatorNonScoringCollector
block|{
DECL|field|scorer
name|Scorer
name|scorer
decl_stmt|;
DECL|method|MultiComparatorScoringNoMaxScoreCollector
specifier|public
name|MultiComparatorScoringNoMaxScoreCollector
parameter_list|(
name|FieldValueHitQueue
name|queue
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
expr_stmt|;
block|}
DECL|method|updateBottom
specifier|final
name|void
name|updateBottom
parameter_list|(
name|int
name|doc
parameter_list|,
name|float
name|score
parameter_list|)
block|{
name|bottom
operator|.
name|docID
operator|=
name|docBase
operator|+
name|doc
expr_stmt|;
name|bottom
operator|.
name|score
operator|=
name|score
expr_stmt|;
name|bottom
operator|=
name|pq
operator|.
name|updateTop
argument_list|()
expr_stmt|;
block|}
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
comment|// Fastmatch: return if this hit is not competitive
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|c
init|=
name|reverseMul
index|[
name|i
index|]
operator|*
name|comparators
index|[
name|i
index|]
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
comment|// Definitely not competitive.
return|return;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
comment|// Definitely competitive.
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|comparators
operator|.
name|length
operator|-
literal|1
condition|)
block|{
comment|// Here c=0. If we're at the last comparator, this doc is not
comment|// competitive, since docs are visited in doc Id order, which means
comment|// this doc cannot compete with any other document in the queue.
return|return;
block|}
block|}
comment|// This hit is competitive - replace bottom element in queue& adjustTop
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
comment|// Compute score only if it is competitive.
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
name|updateBottom
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
comment|// Compute score only if it is competitive.
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|setScorer
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
name|super
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Implements a TopFieldCollector over multiple SortField criteria, with    * tracking document scores and maxScore, and assumes out of orderness in doc    * Ids collection.    */
DECL|class|OutOfOrderMultiComparatorScoringNoMaxScoreCollector
specifier|private
specifier|final
specifier|static
class|class
name|OutOfOrderMultiComparatorScoringNoMaxScoreCollector
extends|extends
name|MultiComparatorScoringNoMaxScoreCollector
block|{
DECL|method|OutOfOrderMultiComparatorScoringNoMaxScoreCollector
specifier|public
name|OutOfOrderMultiComparatorScoringNoMaxScoreCollector
parameter_list|(
name|FieldValueHitQueue
name|queue
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
expr_stmt|;
block|}
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
comment|// Fastmatch: return if this hit is not competitive
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|c
init|=
name|reverseMul
index|[
name|i
index|]
operator|*
name|comparators
index|[
name|i
index|]
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
comment|// Definitely not competitive.
return|return;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
comment|// Definitely competitive.
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|comparators
operator|.
name|length
operator|-
literal|1
condition|)
block|{
comment|// This is the equals case.
if|if
condition|(
name|doc
operator|+
name|docBase
operator|>
name|bottom
operator|.
name|docID
condition|)
block|{
comment|// Definitely not competitive
return|return;
block|}
break|break;
block|}
block|}
comment|// This hit is competitive - replace bottom element in queue& adjustTop
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
comment|// Compute score only if it is competitive.
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
name|updateBottom
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
comment|// Compute score only if it is competitive.
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|comparators
index|[
name|i
index|]
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|setScorer
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
name|super
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
block|}
DECL|method|acceptsDocsOutOfOrder
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
DECL|field|EMPTY_SCOREDOCS
specifier|private
specifier|static
specifier|final
name|ScoreDoc
index|[]
name|EMPTY_SCOREDOCS
init|=
operator|new
name|ScoreDoc
index|[
literal|0
index|]
decl_stmt|;
DECL|field|fillFields
specifier|private
specifier|final
name|boolean
name|fillFields
decl_stmt|;
comment|/*    * Stores the maximum score value encountered, needed for normalizing. If    * document scores are not tracked, this value is initialized to NaN.    */
DECL|field|maxScore
name|float
name|maxScore
init|=
name|Float
operator|.
name|NaN
decl_stmt|;
DECL|field|numHits
specifier|final
name|int
name|numHits
decl_stmt|;
DECL|field|bottom
name|FieldValueHitQueue
operator|.
name|Entry
name|bottom
init|=
literal|null
decl_stmt|;
DECL|field|queueFull
name|boolean
name|queueFull
decl_stmt|;
DECL|field|docBase
name|int
name|docBase
decl_stmt|;
comment|// Declaring the constructor private prevents extending this class by anyone
comment|// else. Note that the class cannot be final since it's extended by the
comment|// internal versions. If someone will define a constructor with any other
comment|// visibility, then anyone will be able to extend the class, which is not what
comment|// we want.
DECL|method|TopFieldCollector
specifier|private
name|TopFieldCollector
parameter_list|(
name|PriorityQueue
argument_list|<
name|Entry
argument_list|>
name|pq
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
block|{
name|super
argument_list|(
name|pq
argument_list|)
expr_stmt|;
name|this
operator|.
name|numHits
operator|=
name|numHits
expr_stmt|;
name|this
operator|.
name|fillFields
operator|=
name|fillFields
expr_stmt|;
block|}
comment|/**    * Creates a new {@link TopFieldCollector} from the given    * arguments.    *    *<p><b>NOTE</b>: The instances returned by this method    * pre-allocate a full array of length    *<code>numHits</code>.    *     * @param sort    *          the sort criteria (SortFields).    * @param numHits    *          the number of results to collect.    * @param fillFields    *          specifies whether the actual field values should be returned on    *          the results (FieldDoc).    * @param trackDocScores    *          specifies whether document scores should be tracked and set on the    *          results. Note that if set to false, then the results' scores will    *          be set to Float.NaN. Setting this to true affects performance, as    *          it incurs the score computation on each competitive result.    *          Therefore if document scores are not required by the application,    *          it is recommended to set it to false.    * @param trackMaxScore    *          specifies whether the query's maxScore should be tracked and set    *          on the resulting {@link TopDocs}. Note that if set to false,    *          {@link TopDocs#getMaxScore()} returns Float.NaN. Setting this to    *          true affects performance as it incurs the score computation on    *          each result. Also, setting this true automatically sets    *<code>trackDocScores</code> to true as well.    * @param docsScoredInOrder    *          specifies whether documents are scored in doc Id order or not by    *          the given {@link Scorer} in {@link #setScorer(Scorer)}.    * @return a {@link TopFieldCollector} instance which will sort the results by    *         the sort criteria.    * @throws IOException    */
DECL|method|create
specifier|public
specifier|static
name|TopFieldCollector
name|create
parameter_list|(
name|Sort
name|sort
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|,
name|boolean
name|trackDocScores
parameter_list|,
name|boolean
name|trackMaxScore
parameter_list|,
name|boolean
name|docsScoredInOrder
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|sort
operator|.
name|fields
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Sort must contain at least one field"
argument_list|)
throw|;
block|}
name|FieldValueHitQueue
name|queue
init|=
name|FieldValueHitQueue
operator|.
name|create
argument_list|(
name|sort
operator|.
name|fields
argument_list|,
name|numHits
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|.
name|getComparators
argument_list|()
operator|.
name|length
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|docsScoredInOrder
condition|)
block|{
if|if
condition|(
name|trackMaxScore
condition|)
block|{
return|return
operator|new
name|OneComparatorScoringMaxScoreCollector
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|trackDocScores
condition|)
block|{
return|return
operator|new
name|OneComparatorScoringNoMaxScoreCollector
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|OneComparatorNonScoringCollector
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|trackMaxScore
condition|)
block|{
return|return
operator|new
name|OutOfOrderOneComparatorScoringMaxScoreCollector
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|trackDocScores
condition|)
block|{
return|return
operator|new
name|OutOfOrderOneComparatorScoringNoMaxScoreCollector
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|OutOfOrderOneComparatorNonScoringCollector
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
return|;
block|}
block|}
block|}
comment|// multiple comparators.
if|if
condition|(
name|docsScoredInOrder
condition|)
block|{
if|if
condition|(
name|trackMaxScore
condition|)
block|{
return|return
operator|new
name|MultiComparatorScoringMaxScoreCollector
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|trackDocScores
condition|)
block|{
return|return
operator|new
name|MultiComparatorScoringNoMaxScoreCollector
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|MultiComparatorNonScoringCollector
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|trackMaxScore
condition|)
block|{
return|return
operator|new
name|OutOfOrderMultiComparatorScoringMaxScoreCollector
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|trackDocScores
condition|)
block|{
return|return
operator|new
name|OutOfOrderMultiComparatorScoringNoMaxScoreCollector
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|OutOfOrderMultiComparatorNonScoringCollector
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
return|;
block|}
block|}
block|}
DECL|method|add
specifier|final
name|void
name|add
parameter_list|(
name|int
name|slot
parameter_list|,
name|int
name|doc
parameter_list|,
name|float
name|score
parameter_list|)
block|{
name|bottom
operator|=
name|pq
operator|.
name|add
argument_list|(
operator|new
name|Entry
argument_list|(
name|slot
argument_list|,
name|docBase
operator|+
name|doc
argument_list|,
name|score
argument_list|)
argument_list|)
expr_stmt|;
name|queueFull
operator|=
name|totalHits
operator|==
name|numHits
expr_stmt|;
block|}
comment|/*    * Only the following callback methods need to be overridden since    * topDocs(int, int) calls them to return the results.    */
DECL|method|populateResults
specifier|protected
name|void
name|populateResults
parameter_list|(
name|ScoreDoc
index|[]
name|results
parameter_list|,
name|int
name|howMany
parameter_list|)
block|{
if|if
condition|(
name|fillFields
condition|)
block|{
comment|// avoid casting if unnecessary.
name|FieldValueHitQueue
name|queue
init|=
operator|(
name|FieldValueHitQueue
operator|)
name|pq
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|howMany
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|results
index|[
name|i
index|]
operator|=
name|queue
operator|.
name|fillFields
argument_list|(
operator|(
name|Entry
operator|)
name|queue
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
name|howMany
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|Entry
name|entry
init|=
name|pq
operator|.
name|pop
argument_list|()
decl_stmt|;
name|results
index|[
name|i
index|]
operator|=
operator|new
name|FieldDoc
argument_list|(
name|entry
operator|.
name|docID
argument_list|,
name|entry
operator|.
name|score
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|newTopDocs
specifier|protected
name|TopDocs
name|newTopDocs
parameter_list|(
name|ScoreDoc
index|[]
name|results
parameter_list|,
name|int
name|start
parameter_list|)
block|{
if|if
condition|(
name|results
operator|==
literal|null
condition|)
block|{
name|results
operator|=
name|EMPTY_SCOREDOCS
expr_stmt|;
comment|// Set maxScore to NaN, in case this is a maxScore tracking collector.
name|maxScore
operator|=
name|Float
operator|.
name|NaN
expr_stmt|;
block|}
comment|// If this is a maxScoring tracking collector and there were no results,
return|return
operator|new
name|TopFieldDocs
argument_list|(
name|totalHits
argument_list|,
name|results
argument_list|,
operator|(
operator|(
name|FieldValueHitQueue
operator|)
name|pq
operator|)
operator|.
name|getFields
argument_list|()
argument_list|,
name|maxScore
argument_list|)
return|;
block|}
DECL|method|acceptsDocsOutOfOrder
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
end_class
end_unit
