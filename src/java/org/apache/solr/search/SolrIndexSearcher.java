begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.search
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrInfoMBean
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrInfoRegistry
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|OpenBitSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import
begin_comment
comment|/**  * SolrIndexSearcher adds schema awareness and caching functionality  * over the lucene IndexSearcher.  *  * @version $Id$  * @since solr 0.9  */
end_comment
begin_comment
comment|// Since the internal reader in IndexSearcher is
end_comment
begin_comment
comment|// package protected, I can't get to it by inheritance.
end_comment
begin_comment
comment|// For now, I am using delgation and creating the
end_comment
begin_comment
comment|// IndexReader to pass to the searcher myself.
end_comment
begin_comment
comment|// NOTE: as of Lucene 1.9, this has changed!
end_comment
begin_class
DECL|class|SolrIndexSearcher
specifier|public
class|class
name|SolrIndexSearcher
extends|extends
name|Searcher
implements|implements
name|SolrInfoMBean
block|{
DECL|field|log
specifier|private
specifier|static
name|Logger
name|log
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|SolrIndexSearcher
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|core
specifier|private
specifier|final
name|SolrCore
name|core
decl_stmt|;
DECL|field|schema
specifier|private
specifier|final
name|IndexSchema
name|schema
decl_stmt|;
DECL|field|name
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|openTime
specifier|private
name|long
name|openTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
DECL|field|registerTime
specifier|private
name|long
name|registerTime
init|=
literal|0
decl_stmt|;
DECL|field|searcher
specifier|private
specifier|final
name|IndexSearcher
name|searcher
decl_stmt|;
DECL|field|reader
specifier|private
specifier|final
name|IndexReader
name|reader
decl_stmt|;
DECL|field|closeReader
specifier|private
specifier|final
name|boolean
name|closeReader
decl_stmt|;
DECL|field|queryResultWindowSize
specifier|private
specifier|final
name|int
name|queryResultWindowSize
decl_stmt|;
DECL|field|queryResultMaxDocsCached
specifier|private
specifier|final
name|int
name|queryResultMaxDocsCached
decl_stmt|;
DECL|field|useFilterForSortedQuery
specifier|private
specifier|final
name|boolean
name|useFilterForSortedQuery
decl_stmt|;
DECL|field|enableLazyFieldLoading
specifier|public
specifier|final
name|boolean
name|enableLazyFieldLoading
decl_stmt|;
DECL|field|cachingEnabled
specifier|private
specifier|final
name|boolean
name|cachingEnabled
decl_stmt|;
DECL|field|filterCache
specifier|private
specifier|final
name|SolrCache
name|filterCache
decl_stmt|;
DECL|field|queryResultCache
specifier|private
specifier|final
name|SolrCache
name|queryResultCache
decl_stmt|;
DECL|field|documentCache
specifier|private
specifier|final
name|SolrCache
name|documentCache
decl_stmt|;
DECL|field|optimizer
specifier|private
specifier|final
name|LuceneQueryOptimizer
name|optimizer
decl_stmt|;
DECL|field|HASHSET_INVERSE_LOAD_FACTOR
specifier|private
specifier|final
name|float
name|HASHSET_INVERSE_LOAD_FACTOR
decl_stmt|;
DECL|field|HASHDOCSET_MAXSIZE
specifier|private
specifier|final
name|int
name|HASHDOCSET_MAXSIZE
decl_stmt|;
comment|// map of generic caches - not synchronized since it's read-only after the constructor.
DECL|field|cacheMap
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|SolrCache
argument_list|>
name|cacheMap
decl_stmt|;
DECL|field|noGenericCaches
specifier|private
specifier|static
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|SolrCache
argument_list|>
name|noGenericCaches
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SolrCache
argument_list|>
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// list of all caches associated with this searcher.
DECL|field|cacheList
specifier|private
specifier|final
name|SolrCache
index|[]
name|cacheList
decl_stmt|;
DECL|field|noCaches
specifier|private
specifier|static
specifier|final
name|SolrCache
index|[]
name|noCaches
init|=
operator|new
name|SolrCache
index|[
literal|0
index|]
decl_stmt|;
comment|/** Creates a searcher searching the index in the named directory. */
DECL|method|SolrIndexSearcher
specifier|public
name|SolrIndexSearcher
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|path
parameter_list|,
name|boolean
name|enableCache
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|core
argument_list|,
name|schema
argument_list|,
name|name
argument_list|,
name|IndexReader
operator|.
name|open
argument_list|(
name|path
argument_list|)
argument_list|,
literal|true
argument_list|,
name|enableCache
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a searcher searching the index in the provided directory. */
DECL|method|SolrIndexSearcher
specifier|public
name|SolrIndexSearcher
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|String
name|name
parameter_list|,
name|Directory
name|directory
parameter_list|,
name|boolean
name|enableCache
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|core
argument_list|,
name|schema
argument_list|,
name|name
argument_list|,
name|IndexReader
operator|.
name|open
argument_list|(
name|directory
argument_list|)
argument_list|,
literal|true
argument_list|,
name|enableCache
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a searcher searching the provided index. */
DECL|method|SolrIndexSearcher
specifier|public
name|SolrIndexSearcher
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|String
name|name
parameter_list|,
name|IndexReader
name|r
parameter_list|,
name|boolean
name|enableCache
parameter_list|)
block|{
name|this
argument_list|(
name|core
argument_list|,
name|schema
argument_list|,
name|name
argument_list|,
name|r
argument_list|,
literal|false
argument_list|,
name|enableCache
argument_list|)
expr_stmt|;
block|}
DECL|method|SolrIndexSearcher
specifier|private
name|SolrIndexSearcher
parameter_list|(
name|SolrCore
name|core
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|String
name|name
parameter_list|,
name|IndexReader
name|r
parameter_list|,
name|boolean
name|closeReader
parameter_list|,
name|boolean
name|enableCache
parameter_list|)
block|{
name|this
operator|.
name|core
operator|=
name|core
expr_stmt|;
name|this
operator|.
name|schema
operator|=
name|schema
expr_stmt|;
name|this
operator|.
name|name
operator|=
literal|"Searcher@"
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|hashCode
argument_list|()
argument_list|)
operator|+
operator|(
name|name
operator|!=
literal|null
condition|?
literal|" "
operator|+
name|name
else|:
literal|""
operator|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Opening "
operator|+
name|this
operator|.
name|name
argument_list|)
expr_stmt|;
name|reader
operator|=
name|r
expr_stmt|;
name|searcher
operator|=
operator|new
name|IndexSearcher
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|this
operator|.
name|closeReader
operator|=
name|closeReader
expr_stmt|;
name|searcher
operator|.
name|setSimilarity
argument_list|(
name|schema
operator|.
name|getSimilarity
argument_list|()
argument_list|)
expr_stmt|;
name|SolrConfig
name|solrConfig
init|=
name|schema
operator|.
name|getSolrConfig
argument_list|()
decl_stmt|;
name|queryResultWindowSize
operator|=
name|solrConfig
operator|.
name|queryResultWindowSize
expr_stmt|;
name|queryResultMaxDocsCached
operator|=
name|solrConfig
operator|.
name|queryResultMaxDocsCached
expr_stmt|;
name|useFilterForSortedQuery
operator|=
name|solrConfig
operator|.
name|useFilterForSortedQuery
expr_stmt|;
name|enableLazyFieldLoading
operator|=
name|solrConfig
operator|.
name|enableLazyFieldLoading
expr_stmt|;
name|cachingEnabled
operator|=
name|enableCache
expr_stmt|;
if|if
condition|(
name|cachingEnabled
condition|)
block|{
name|ArrayList
argument_list|<
name|SolrCache
argument_list|>
name|clist
init|=
operator|new
name|ArrayList
argument_list|<
name|SolrCache
argument_list|>
argument_list|()
decl_stmt|;
name|filterCache
operator|=
name|solrConfig
operator|.
name|filterCacheConfig
operator|==
literal|null
condition|?
literal|null
else|:
name|solrConfig
operator|.
name|filterCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
name|clist
operator|.
name|add
argument_list|(
name|filterCache
argument_list|)
expr_stmt|;
name|queryResultCache
operator|=
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|==
literal|null
condition|?
literal|null
else|:
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|queryResultCache
operator|!=
literal|null
condition|)
name|clist
operator|.
name|add
argument_list|(
name|queryResultCache
argument_list|)
expr_stmt|;
name|documentCache
operator|=
name|solrConfig
operator|.
name|documentCacheConfig
operator|==
literal|null
condition|?
literal|null
else|:
name|solrConfig
operator|.
name|documentCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|documentCache
operator|!=
literal|null
condition|)
name|clist
operator|.
name|add
argument_list|(
name|documentCache
argument_list|)
expr_stmt|;
if|if
condition|(
name|solrConfig
operator|.
name|userCacheConfigs
operator|==
literal|null
condition|)
block|{
name|cacheMap
operator|=
name|noGenericCaches
expr_stmt|;
block|}
else|else
block|{
name|cacheMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SolrCache
argument_list|>
argument_list|(
name|solrConfig
operator|.
name|userCacheConfigs
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|CacheConfig
name|userCacheConfig
range|:
name|solrConfig
operator|.
name|userCacheConfigs
control|)
block|{
name|SolrCache
name|cache
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|userCacheConfig
operator|!=
literal|null
condition|)
name|cache
operator|=
name|userCacheConfig
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|cache
operator|!=
literal|null
condition|)
block|{
name|cacheMap
operator|.
name|put
argument_list|(
name|cache
operator|.
name|name
argument_list|()
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|clist
operator|.
name|add
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|cacheList
operator|=
name|clist
operator|.
name|toArray
argument_list|(
operator|new
name|SolrCache
index|[
name|clist
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|filterCache
operator|=
literal|null
expr_stmt|;
name|queryResultCache
operator|=
literal|null
expr_stmt|;
name|documentCache
operator|=
literal|null
expr_stmt|;
name|cacheMap
operator|=
name|noGenericCaches
expr_stmt|;
name|cacheList
operator|=
name|noCaches
expr_stmt|;
block|}
name|optimizer
operator|=
name|solrConfig
operator|.
name|filtOptEnabled
condition|?
operator|new
name|LuceneQueryOptimizer
argument_list|(
name|solrConfig
operator|.
name|filtOptCacheSize
argument_list|,
name|solrConfig
operator|.
name|filtOptThreshold
argument_list|)
else|:
literal|null
expr_stmt|;
comment|// for DocSets
name|HASHSET_INVERSE_LOAD_FACTOR
operator|=
name|solrConfig
operator|.
name|hashSetInverseLoadFactor
expr_stmt|;
name|HASHDOCSET_MAXSIZE
operator|=
name|solrConfig
operator|.
name|hashDocSetMaxSize
expr_stmt|;
comment|// register self
name|core
operator|.
name|getInfoRegistry
argument_list|()
operator|.
name|put
argument_list|(
name|this
operator|.
name|name
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
return|;
block|}
comment|/** Register sub-objects such as caches    */
DECL|method|register
specifier|public
name|void
name|register
parameter_list|()
block|{
for|for
control|(
name|SolrCache
name|cache
range|:
name|cacheList
control|)
block|{
name|cache
operator|.
name|setState
argument_list|(
name|SolrCache
operator|.
name|State
operator|.
name|LIVE
argument_list|)
expr_stmt|;
name|core
operator|.
name|getInfoRegistry
argument_list|()
operator|.
name|put
argument_list|(
name|cache
operator|.
name|name
argument_list|()
argument_list|,
name|cache
argument_list|)
expr_stmt|;
block|}
name|registerTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
comment|/**    * Free's resources associated with this searcher.    *    * In particular, the underlying reader and any cache's in use are closed.    */
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|// unregister first, so no management actions are tried on a closing searcher.
name|core
operator|.
name|getInfoRegistry
argument_list|()
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cachingEnabled
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Closing "
argument_list|)
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|SolrCache
name|cache
range|:
name|cacheList
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|fine
argument_list|(
literal|"Closing "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|searcher
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|closeReader
condition|)
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
for|for
control|(
name|SolrCache
name|cache
range|:
name|cacheList
control|)
block|{
name|cache
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Direct access to the IndexReader used by this searcher */
DECL|method|getReader
specifier|public
name|IndexReader
name|getReader
parameter_list|()
block|{
return|return
name|reader
return|;
block|}
comment|/** Direct access to the IndexSchema for use with this searcher */
DECL|method|getSchema
specifier|public
name|IndexSchema
name|getSchema
parameter_list|()
block|{
return|return
name|schema
return|;
block|}
comment|//
comment|// Set default regenerators on filter and query caches if they don't have any
comment|//
DECL|method|initRegenerators
specifier|public
specifier|static
name|void
name|initRegenerators
parameter_list|(
name|SolrConfig
name|solrConfig
parameter_list|)
block|{
if|if
condition|(
name|solrConfig
operator|.
name|filterCacheConfig
operator|!=
literal|null
operator|&&
name|solrConfig
operator|.
name|filterCacheConfig
operator|.
name|getRegenerator
argument_list|()
operator|==
literal|null
condition|)
block|{
name|solrConfig
operator|.
name|filterCacheConfig
operator|.
name|setRegenerator
argument_list|(
operator|new
name|CacheRegenerator
argument_list|()
block|{
specifier|public
name|boolean
name|regenerateItem
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|,
name|SolrCache
name|newCache
parameter_list|,
name|SolrCache
name|oldCache
parameter_list|,
name|Object
name|oldKey
parameter_list|,
name|Object
name|oldVal
parameter_list|)
throws|throws
name|IOException
block|{
name|newSearcher
operator|.
name|cacheDocSet
argument_list|(
operator|(
name|Query
operator|)
name|oldKey
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|!=
literal|null
operator|&&
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|.
name|getRegenerator
argument_list|()
operator|==
literal|null
condition|)
block|{
specifier|final
name|int
name|queryResultWindowSize
init|=
name|solrConfig
operator|.
name|queryResultWindowSize
decl_stmt|;
name|solrConfig
operator|.
name|queryResultCacheConfig
operator|.
name|setRegenerator
argument_list|(
operator|new
name|CacheRegenerator
argument_list|()
block|{
specifier|public
name|boolean
name|regenerateItem
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|,
name|SolrCache
name|newCache
parameter_list|,
name|SolrCache
name|oldCache
parameter_list|,
name|Object
name|oldKey
parameter_list|,
name|Object
name|oldVal
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryResultKey
name|key
init|=
operator|(
name|QueryResultKey
operator|)
name|oldKey
decl_stmt|;
name|int
name|nDocs
init|=
literal|1
decl_stmt|;
comment|// request 1 doc and let caching round up to the next window size...
comment|// unless the window size is<=1, in which case we will pick
comment|// the minimum of the number of documents requested last time and
comment|// a reasonable number such as 40.
comment|// TODO: make more configurable later...
if|if
condition|(
name|queryResultWindowSize
operator|<=
literal|1
condition|)
block|{
name|DocList
name|oldList
init|=
operator|(
name|DocList
operator|)
name|oldVal
decl_stmt|;
name|int
name|oldnDocs
init|=
name|oldList
operator|.
name|offset
argument_list|()
operator|+
name|oldList
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// 40 has factors of 2,4,5,10,20
name|nDocs
operator|=
name|Math
operator|.
name|min
argument_list|(
name|oldnDocs
argument_list|,
literal|40
argument_list|)
expr_stmt|;
block|}
name|DocListAndSet
name|ret
init|=
operator|new
name|DocListAndSet
argument_list|()
decl_stmt|;
name|int
name|flags
init|=
name|NO_CHECK_QCACHE
operator||
name|key
operator|.
name|nc_flags
decl_stmt|;
name|newSearcher
operator|.
name|getDocListC
argument_list|(
name|ret
argument_list|,
name|key
operator|.
name|query
argument_list|,
name|key
operator|.
name|filters
argument_list|,
literal|null
argument_list|,
name|key
operator|.
name|sort
argument_list|,
literal|0
argument_list|,
name|nDocs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|search
specifier|public
name|Hits
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
comment|// todo - when Solr starts accepting filters, need to
comment|// change this conditional check (filter!=null) and create a new filter
comment|// that ANDs them together if it already exists.
if|if
condition|(
name|optimizer
operator|==
literal|null
operator|||
name|filter
operator|!=
literal|null
operator|||
operator|!
operator|(
name|query
operator|instanceof
name|BooleanQuery
operator|)
condition|)
block|{
return|return
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|filter
argument_list|,
name|sort
argument_list|)
return|;
block|}
else|else
block|{
name|Query
index|[]
name|newQuery
init|=
operator|new
name|Query
index|[
literal|1
index|]
decl_stmt|;
name|Filter
index|[]
name|newFilter
init|=
operator|new
name|Filter
index|[
literal|1
index|]
decl_stmt|;
name|optimizer
operator|.
name|optimize
argument_list|(
operator|(
name|BooleanQuery
operator|)
name|query
argument_list|,
name|searcher
argument_list|,
literal|0
argument_list|,
name|newQuery
argument_list|,
name|newFilter
argument_list|)
expr_stmt|;
return|return
name|searcher
operator|.
name|search
argument_list|(
name|newQuery
index|[
literal|0
index|]
argument_list|,
name|newFilter
index|[
literal|0
index|]
argument_list|,
name|sort
argument_list|)
return|;
block|}
block|}
DECL|method|search
specifier|public
name|Hits
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|filter
argument_list|)
return|;
block|}
DECL|method|search
specifier|public
name|Hits
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|sort
argument_list|)
return|;
block|}
DECL|method|search
specifier|public
name|void
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|HitCollector
name|results
parameter_list|)
throws|throws
name|IOException
block|{
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
DECL|method|setSimilarity
specifier|public
name|void
name|setSimilarity
parameter_list|(
name|Similarity
name|similarity
parameter_list|)
block|{
name|searcher
operator|.
name|setSimilarity
argument_list|(
name|similarity
argument_list|)
expr_stmt|;
block|}
DECL|method|getSimilarity
specifier|public
name|Similarity
name|getSimilarity
parameter_list|()
block|{
return|return
name|searcher
operator|.
name|getSimilarity
argument_list|()
return|;
block|}
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|(
name|Term
name|term
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|searcher
operator|.
name|docFreq
argument_list|(
name|term
argument_list|)
return|;
block|}
comment|/* ********************** Document retrieval *************************/
comment|/* Future optimizations (yonik)    *    * If no cache is present:    *   - use NO_LOAD instead of LAZY_LOAD    *   - use LOAD_AND_BREAK if a single field is begin retrieved    */
comment|/**    * FieldSelector which loads the specified fields, and load all other    * field lazily.    */
DECL|class|SetNonLazyFieldSelector
class|class
name|SetNonLazyFieldSelector
implements|implements
name|FieldSelector
block|{
DECL|field|fieldsToLoad
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|fieldsToLoad
decl_stmt|;
DECL|method|SetNonLazyFieldSelector
name|SetNonLazyFieldSelector
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|toLoad
parameter_list|)
block|{
name|fieldsToLoad
operator|=
name|toLoad
expr_stmt|;
block|}
DECL|method|accept
specifier|public
name|FieldSelectorResult
name|accept
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
name|fieldsToLoad
operator|.
name|contains
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|FieldSelectorResult
operator|.
name|LOAD
return|;
else|else
return|return
name|FieldSelectorResult
operator|.
name|LAZY_LOAD
return|;
block|}
block|}
comment|/**    * Retrieve the {@link Document} instance corresponding to the document id.    */
DECL|method|doc
specifier|public
name|Document
name|doc
parameter_list|(
name|int
name|i
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|doc
argument_list|(
name|i
argument_list|,
operator|(
name|Set
argument_list|<
name|String
argument_list|>
operator|)
literal|null
argument_list|)
return|;
block|}
comment|/** Retrieve a {@link Document} using a {@link org.apache.lucene.document.FieldSelector}    * This method does not currently use the Solr document cache.    *     * @see IndexReader#document(int, FieldSelector) */
DECL|method|doc
specifier|public
name|Document
name|doc
parameter_list|(
name|int
name|n
parameter_list|,
name|FieldSelector
name|fieldSelector
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|.
name|document
argument_list|(
name|n
argument_list|,
name|fieldSelector
argument_list|)
return|;
block|}
comment|/**    * Retrieve the {@link Document} instance corresponding to the document id.    *    * Note: The document will have all fields accessable, but if a field    * filter is provided, only the provided fields will be loaded (the     * remainder will be available lazily).    */
DECL|method|doc
specifier|public
name|Document
name|doc
parameter_list|(
name|int
name|i
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|IOException
block|{
name|Document
name|d
decl_stmt|;
if|if
condition|(
name|documentCache
operator|!=
literal|null
condition|)
block|{
name|d
operator|=
operator|(
name|Document
operator|)
name|documentCache
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
literal|null
condition|)
return|return
name|d
return|;
block|}
if|if
condition|(
operator|!
name|enableLazyFieldLoading
operator|||
name|fields
operator|==
literal|null
condition|)
block|{
name|d
operator|=
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|.
name|document
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|.
name|document
argument_list|(
name|i
argument_list|,
operator|new
name|SetNonLazyFieldSelector
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|documentCache
operator|!=
literal|null
condition|)
block|{
name|documentCache
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
comment|/**    * Takes a list of docs (the doc ids actually), and reads them into an array     * of Documents.    */
DECL|method|readDocs
specifier|public
name|void
name|readDocs
parameter_list|(
name|Document
index|[]
name|docs
parameter_list|,
name|DocList
name|ids
parameter_list|)
throws|throws
name|IOException
block|{
name|readDocs
argument_list|(
name|docs
argument_list|,
name|ids
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Takes a list of docs (the doc ids actually) and a set of fields to load,    * and reads them into an array of Documents.    */
DECL|method|readDocs
specifier|public
name|void
name|readDocs
parameter_list|(
name|Document
index|[]
name|docs
parameter_list|,
name|DocList
name|ids
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|IOException
block|{
name|DocIterator
name|iter
init|=
name|ids
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
index|[]
name|idlist
init|=
operator|new
name|int
index|[
name|ids
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|pos
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|idlist
index|[
name|i
index|]
operator|=
name|iter
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
name|pos
operator|.
name|put
argument_list|(
name|idlist
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|idlist
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|docid
range|:
name|idlist
control|)
block|{
name|docs
index|[
name|pos
operator|.
name|get
argument_list|(
name|docid
argument_list|)
index|]
operator|=
name|doc
argument_list|(
name|docid
argument_list|,
name|fields
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ********************** end document retrieval *************************/
DECL|method|maxDoc
specifier|public
name|int
name|maxDoc
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|searcher
operator|.
name|maxDoc
argument_list|()
return|;
block|}
DECL|method|search
specifier|public
name|TopDocs
name|search
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|i
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|searcher
operator|.
name|search
argument_list|(
name|weight
argument_list|,
name|filter
argument_list|,
name|i
argument_list|)
return|;
block|}
DECL|method|search
specifier|public
name|void
name|search
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|HitCollector
name|hitCollector
parameter_list|)
throws|throws
name|IOException
block|{
name|searcher
operator|.
name|search
argument_list|(
name|weight
argument_list|,
name|filter
argument_list|,
name|hitCollector
argument_list|)
expr_stmt|;
block|}
DECL|method|rewrite
specifier|public
name|Query
name|rewrite
parameter_list|(
name|Query
name|original
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|searcher
operator|.
name|rewrite
argument_list|(
name|original
argument_list|)
return|;
block|}
DECL|method|explain
specifier|public
name|Explanation
name|explain
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|int
name|i
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|searcher
operator|.
name|explain
argument_list|(
name|weight
argument_list|,
name|i
argument_list|)
return|;
block|}
DECL|method|search
specifier|public
name|TopFieldDocs
name|search
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|i
parameter_list|,
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|searcher
operator|.
name|search
argument_list|(
name|weight
argument_list|,
name|filter
argument_list|,
name|i
argument_list|,
name|sort
argument_list|)
return|;
block|}
comment|////////////////////////////////////////////////////////////////////////////////
comment|////////////////////////////////////////////////////////////////////////////////
comment|////////////////////////////////////////////////////////////////////////////////
comment|/**    * Returns the first document number containing the term<code>t</code>    * Returns -1 if no document was found.    * This method is primarily intended for clients that want to fetch    * documents using a unique identifier."    * @param t    * @return the first document number containing the term    */
DECL|method|getFirstMatch
specifier|public
name|int
name|getFirstMatch
parameter_list|(
name|Term
name|t
parameter_list|)
throws|throws
name|IOException
block|{
name|TermDocs
name|tdocs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|tdocs
operator|=
name|reader
operator|.
name|termDocs
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tdocs
operator|.
name|next
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|tdocs
operator|.
name|doc
argument_list|()
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|tdocs
operator|!=
literal|null
condition|)
name|tdocs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Compute and cache the DocSet that matches a query.    * The normal usage is expected to be cacheDocSet(myQuery, null,false)    * meaning that Solr will determine if the Query warrants caching, and    * if so, will compute the DocSet that matches the Query and cache it.    * If the answer to the query is already cached, nothing further will be done.    *<p>    * If the optionalAnswer DocSet is provided, it should *not* be modified    * after this call.    *    * @param query           the lucene query that will act as the key    * @param optionalAnswer   the DocSet to be cached - if null, it will be computed.    * @param mustCache        if true, a best effort will be made to cache this entry.    *                         if false, heuristics may be used to determine if it should be cached.    */
DECL|method|cacheDocSet
specifier|public
name|void
name|cacheDocSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|optionalAnswer
parameter_list|,
name|boolean
name|mustCache
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Even if the cache is null, still compute the DocSet as it may serve to warm the Lucene
comment|// or OS disk cache.
if|if
condition|(
name|optionalAnswer
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|filterCache
operator|.
name|put
argument_list|(
name|query
argument_list|,
name|optionalAnswer
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Throw away the result, relying on the fact that getDocSet
comment|// will currently always cache what it found.  If getDocSet() starts
comment|// using heuristics about what to cache, and mustCache==true, (or if we
comment|// want this method to start using heuristics too) then
comment|// this needs to change.
name|getDocSet
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the set of document ids matching a query.    * This method is cache-aware and attempts to retrieve the answer from the cache if possible.    * If the answer was not cached, it may have been inserted into the cache as a result of this call.    * This method can handle negative queries.    *<p>    * The DocSet returned should<b>not</b> be modified.    */
DECL|method|getDocSet
specifier|public
name|DocSet
name|getDocSet
parameter_list|(
name|Query
name|query
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Get the absolute value (positive version) of this query.  If we
comment|// get back the same reference, we know it's positive.
name|Query
name|absQ
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|boolean
name|positive
init|=
name|query
operator|==
name|absQ
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|DocSet
name|absAnswer
init|=
operator|(
name|DocSet
operator|)
name|filterCache
operator|.
name|get
argument_list|(
name|absQ
argument_list|)
decl_stmt|;
if|if
condition|(
name|absAnswer
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|positive
condition|)
return|return
name|absAnswer
return|;
else|else
return|return
name|getPositiveDocSet
argument_list|(
name|matchAllDocsQuery
argument_list|)
operator|.
name|andNot
argument_list|(
name|absAnswer
argument_list|)
return|;
block|}
block|}
name|DocSet
name|absAnswer
init|=
name|getDocSetNC
argument_list|(
name|absQ
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|DocSet
name|answer
init|=
name|positive
condition|?
name|absAnswer
else|:
name|getPositiveDocSet
argument_list|(
name|matchAllDocsQuery
argument_list|)
operator|.
name|andNot
argument_list|(
name|absAnswer
argument_list|)
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
comment|// cache negative queries as positive
name|filterCache
operator|.
name|put
argument_list|(
name|absQ
argument_list|,
name|absAnswer
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|// only handle positive (non negative) queries
DECL|method|getPositiveDocSet
name|DocSet
name|getPositiveDocSet
parameter_list|(
name|Query
name|q
parameter_list|)
throws|throws
name|IOException
block|{
name|DocSet
name|answer
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
operator|(
name|DocSet
operator|)
name|filterCache
operator|.
name|get
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
return|return
name|answer
return|;
block|}
name|answer
operator|=
name|getDocSetNC
argument_list|(
name|q
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
name|filterCache
operator|.
name|put
argument_list|(
name|q
argument_list|,
name|answer
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
DECL|field|matchAllDocsQuery
specifier|private
specifier|static
name|Query
name|matchAllDocsQuery
init|=
operator|new
name|MatchAllDocsQuery
argument_list|()
decl_stmt|;
DECL|method|getDocSet
specifier|protected
name|DocSet
name|getDocSet
parameter_list|(
name|List
argument_list|<
name|Query
argument_list|>
name|queries
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|queries
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|queries
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return
name|getDocSet
argument_list|(
name|queries
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
name|DocSet
name|answer
init|=
literal|null
decl_stmt|;
name|boolean
index|[]
name|neg
init|=
operator|new
name|boolean
index|[
name|queries
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|DocSet
index|[]
name|sets
init|=
operator|new
name|DocSet
index|[
name|queries
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|smallestIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|smallestCount
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Query
name|q
init|=
name|queries
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Query
name|posQuery
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|sets
index|[
name|i
index|]
operator|=
name|getPositiveDocSet
argument_list|(
name|posQuery
argument_list|)
expr_stmt|;
comment|// Negative query if absolute value different from original
if|if
condition|(
name|q
operator|==
name|posQuery
condition|)
block|{
name|neg
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
comment|// keep track of the smallest positive set.
comment|// This optimization is only worth it if size() is cached, which it would
comment|// be if we don't do any set operations.
name|int
name|sz
init|=
name|sets
index|[
name|i
index|]
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|sz
operator|<
name|smallestCount
condition|)
block|{
name|smallestCount
operator|=
name|sz
expr_stmt|;
name|smallestIndex
operator|=
name|i
expr_stmt|;
name|answer
operator|=
name|sets
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|neg
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// if no positive queries, start off with all docs
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
name|answer
operator|=
name|getPositiveDocSet
argument_list|(
name|matchAllDocsQuery
argument_list|)
expr_stmt|;
comment|// do negative queries first to shrink set size
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|neg
index|[
name|i
index|]
condition|)
name|answer
operator|=
name|answer
operator|.
name|andNot
argument_list|(
name|sets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|neg
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|smallestIndex
condition|)
name|answer
operator|=
name|answer
operator|.
name|intersection
argument_list|(
name|sets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|// query must be positive
DECL|method|getDocSetNC
specifier|protected
name|DocSet
name|getDocSetNC
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
block|{
name|DocSetHitCollector
name|hc
init|=
operator|new
name|DocSetHitCollector
argument_list|(
name|HASHSET_INVERSE_LOAD_FACTOR
argument_list|,
name|HASHDOCSET_MAXSIZE
argument_list|,
name|maxDoc
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|instanceof
name|TermQuery
condition|)
block|{
name|Term
name|t
init|=
operator|(
operator|(
name|TermQuery
operator|)
name|query
operator|)
operator|.
name|getTerm
argument_list|()
decl_stmt|;
name|TermDocs
name|tdocs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|tdocs
operator|=
name|reader
operator|.
name|termDocs
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|tdocs
operator|.
name|next
argument_list|()
condition|)
name|hc
operator|.
name|collect
argument_list|(
name|tdocs
operator|.
name|doc
argument_list|()
argument_list|,
literal|0.0f
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|tdocs
operator|!=
literal|null
condition|)
name|tdocs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|hc
argument_list|)
expr_stmt|;
block|}
return|return
name|hc
operator|.
name|getDocSet
argument_list|()
return|;
block|}
else|else
block|{
comment|// FUTURE: if the filter is sorted by docid, could use skipTo (SkipQueryFilter)
specifier|final
name|DocSetHitCollector
name|hc
init|=
operator|new
name|DocSetHitCollector
argument_list|(
name|HASHSET_INVERSE_LOAD_FACTOR
argument_list|,
name|HASHDOCSET_MAXSIZE
argument_list|,
name|maxDoc
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|DocSet
name|filt
init|=
name|filter
decl_stmt|;
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
operator|new
name|HitCollector
argument_list|()
block|{
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|,
name|float
name|score
parameter_list|)
block|{
if|if
condition|(
name|filt
operator|.
name|exists
argument_list|(
name|doc
argument_list|)
condition|)
name|hc
operator|.
name|collect
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|hc
operator|.
name|getDocSet
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns the set of document ids matching both the query and the filter.    * This method is cache-aware and attempts to retrieve the answer from the cache if possible.    * If the answer was not cached, it may have been inserted into the cache as a result of this call.    *<p>    *    * @param query    * @param filter may be null    * @return DocSet meeting the specified criteria, should<b>not</b> be modified by the caller.    */
DECL|method|getDocSet
specifier|public
name|DocSet
name|getDocSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
return|return
name|getDocSet
argument_list|(
name|query
argument_list|)
return|;
comment|// Negative query if absolute value different from original
name|Query
name|absQ
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|boolean
name|positive
init|=
name|absQ
operator|==
name|query
decl_stmt|;
name|DocSet
name|first
decl_stmt|;
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|first
operator|=
operator|(
name|DocSet
operator|)
name|filterCache
operator|.
name|get
argument_list|(
name|absQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|null
condition|)
block|{
name|first
operator|=
name|getDocSetNC
argument_list|(
name|absQ
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|filterCache
operator|.
name|put
argument_list|(
name|absQ
argument_list|,
name|first
argument_list|)
expr_stmt|;
block|}
return|return
name|positive
condition|?
name|first
operator|.
name|intersection
argument_list|(
name|filter
argument_list|)
else|:
name|filter
operator|.
name|andNot
argument_list|(
name|first
argument_list|)
return|;
block|}
comment|// If there isn't a cache, then do a single filtered query if positive.
return|return
name|positive
condition|?
name|getDocSetNC
argument_list|(
name|absQ
argument_list|,
name|filter
argument_list|)
else|:
name|filter
operator|.
name|andNot
argument_list|(
name|getPositiveDocSet
argument_list|(
name|absQ
argument_list|)
argument_list|)
return|;
block|}
comment|/**   * Converts a filter into a DocSet.   * This method is not cache-aware and no caches are checked.   */
DECL|method|convertFilter
specifier|public
name|DocSet
name|convertFilter
parameter_list|(
name|Filter
name|lfilter
parameter_list|)
throws|throws
name|IOException
block|{
name|BitSet
name|bs
init|=
name|lfilter
operator|.
name|bits
argument_list|(
name|this
operator|.
name|reader
argument_list|)
decl_stmt|;
name|OpenBitSet
name|obs
init|=
operator|new
name|OpenBitSet
argument_list|(
name|bs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|bs
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|bs
operator|.
name|nextSetBit
argument_list|(
name|i
operator|+
literal|1
argument_list|)
control|)
block|{
name|obs
operator|.
name|fastSet
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|BitDocSet
argument_list|(
name|obs
argument_list|)
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>.    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocList meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocList
specifier|public
name|DocList
name|getDocList
parameter_list|(
name|Query
name|query
parameter_list|,
name|Query
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
name|filterList
operator|=
operator|new
name|ArrayList
argument_list|<
name|Query
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|filterList
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
return|return
name|getDocList
argument_list|(
name|query
argument_list|,
name|filterList
argument_list|,
name|lsort
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and the     * intersection of the<code>filterList</code>, sorted by<code>sort</code>.    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *    * @param query    * @param filterList may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocList meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocList
specifier|public
name|DocList
name|getDocList
parameter_list|(
name|Query
name|query
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|DocListAndSet
name|answer
init|=
operator|new
name|DocListAndSet
argument_list|()
decl_stmt|;
name|getDocListC
argument_list|(
name|answer
argument_list|,
name|query
argument_list|,
name|filterList
argument_list|,
literal|null
argument_list|,
name|lsort
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|answer
operator|.
name|docList
return|;
block|}
DECL|field|NO_CHECK_QCACHE
specifier|private
specifier|static
specifier|final
name|int
name|NO_CHECK_QCACHE
init|=
literal|0x80000000
decl_stmt|;
DECL|field|GET_DOCSET
specifier|private
specifier|static
specifier|final
name|int
name|GET_DOCSET
init|=
literal|0x40000000
decl_stmt|;
DECL|field|NO_CHECK_FILTERCACHE
specifier|private
specifier|static
specifier|final
name|int
name|NO_CHECK_FILTERCACHE
init|=
literal|0x20000000
decl_stmt|;
DECL|field|GET_SCORES
specifier|public
specifier|static
specifier|final
name|int
name|GET_SCORES
init|=
literal|0x01
decl_stmt|;
comment|/** getDocList version that uses+populates query and filter caches.    * This should only be called using either filterList or filter, but not both.    */
DECL|method|getDocListC
specifier|private
name|void
name|getDocListC
parameter_list|(
name|DocListAndSet
name|out
parameter_list|,
name|Query
name|query
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
parameter_list|,
name|DocSet
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryResultKey
name|key
init|=
literal|null
decl_stmt|;
name|int
name|maxDoc
init|=
name|offset
operator|+
name|len
decl_stmt|;
name|int
name|supersetMaxDoc
init|=
name|maxDoc
decl_stmt|;
name|DocList
name|superset
decl_stmt|;
comment|// we can try and look up the complete query in the cache.
comment|// we can't do that if filter!=null though (we don't want to
comment|// do hashCode() and equals() for a big DocSet).
if|if
condition|(
name|queryResultCache
operator|!=
literal|null
operator|&&
name|filter
operator|==
literal|null
condition|)
block|{
comment|// all of the current flags can be reused during warming,
comment|// so set all of them on the cache key.
name|key
operator|=
operator|new
name|QueryResultKey
argument_list|(
name|query
argument_list|,
name|filterList
argument_list|,
name|lsort
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NO_CHECK_QCACHE
operator|)
operator|==
literal|0
condition|)
block|{
name|superset
operator|=
operator|(
name|DocList
operator|)
name|queryResultCache
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|superset
operator|!=
literal|null
condition|)
block|{
comment|// check that the cache entry has scores recorded if we need them
if|if
condition|(
operator|(
name|flags
operator|&
name|GET_SCORES
operator|)
operator|==
literal|0
operator|||
name|superset
operator|.
name|hasScores
argument_list|()
condition|)
block|{
comment|// NOTE: subset() returns null if the DocList has fewer docs than
comment|// requested
name|out
operator|.
name|docList
operator|=
name|superset
operator|.
name|subset
argument_list|(
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|.
name|docList
operator|!=
literal|null
condition|)
block|{
comment|// found the docList in the cache... now check if we need the docset too.
comment|// OPT: possible future optimization - if the doclist contains all the matches,
comment|// use it to make the docset instead of rerunning the query.
if|if
condition|(
name|out
operator|.
name|docSet
operator|==
literal|null
operator|&&
operator|(
operator|(
name|flags
operator|&
name|GET_DOCSET
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|filterList
operator|==
literal|null
condition|)
block|{
name|out
operator|.
name|docSet
operator|=
name|getDocSet
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|Query
argument_list|>
name|newList
init|=
operator|new
name|ArrayList
argument_list|<
name|Query
argument_list|>
argument_list|(
name|filterList
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|newList
operator|.
name|add
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|newList
operator|.
name|addAll
argument_list|(
name|filterList
argument_list|)
expr_stmt|;
name|out
operator|.
name|docSet
operator|=
name|getDocSet
argument_list|(
name|newList
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
comment|// If we are going to generate the result, bump up to the
comment|// next resultWindowSize for better caching.
comment|// handle 0 special case as well as avoid idiv in the common case.
if|if
condition|(
name|maxDoc
operator|<
name|queryResultWindowSize
condition|)
block|{
name|supersetMaxDoc
operator|=
name|queryResultWindowSize
expr_stmt|;
block|}
else|else
block|{
name|supersetMaxDoc
operator|=
operator|(
operator|(
name|maxDoc
operator|-
literal|1
operator|)
operator|/
name|queryResultWindowSize
operator|+
literal|1
operator|)
operator|*
name|queryResultWindowSize
expr_stmt|;
block|}
block|}
comment|// OK, so now we need to generate an answer.
comment|// One way to do that would be to check if we have an unordered list
comment|// of results for the base query.  If so, we can apply the filters and then
comment|// sort by the resulting set.  This can only be used if:
comment|// - the sort doesn't contain score
comment|// - we don't want score returned.
comment|// check if we should try and use the filter cache
name|boolean
name|useFilterCache
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|GET_SCORES
operator||
name|NO_CHECK_FILTERCACHE
operator|)
operator|)
operator|==
literal|0
operator|&&
name|useFilterForSortedQuery
operator|&&
name|lsort
operator|!=
literal|null
operator|&&
name|filterCache
operator|!=
literal|null
condition|)
block|{
name|useFilterCache
operator|=
literal|true
expr_stmt|;
name|SortField
index|[]
name|sfields
init|=
name|lsort
operator|.
name|getSort
argument_list|()
decl_stmt|;
for|for
control|(
name|SortField
name|sf
range|:
name|sfields
control|)
block|{
if|if
condition|(
name|sf
operator|.
name|getType
argument_list|()
operator|==
name|SortField
operator|.
name|SCORE
condition|)
block|{
name|useFilterCache
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|useFilterCache
condition|)
block|{
comment|// now actually use the filter cache.
comment|// for large filters that match few documents, this may be
comment|// slower than simply re-executing the query.
if|if
condition|(
name|out
operator|.
name|docSet
operator|==
literal|null
condition|)
block|{
name|out
operator|.
name|docSet
operator|=
name|getDocSet
argument_list|(
name|query
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|DocSet
name|bigFilt
init|=
name|getDocSet
argument_list|(
name|filterList
argument_list|)
decl_stmt|;
if|if
condition|(
name|bigFilt
operator|!=
literal|null
condition|)
name|out
operator|.
name|docSet
operator|=
name|out
operator|.
name|docSet
operator|.
name|intersection
argument_list|(
name|bigFilt
argument_list|)
expr_stmt|;
block|}
comment|// todo: there could be a sortDocSet that could take a list of
comment|// the filters instead of anding them first...
comment|// perhaps there should be a multi-docset-iterator
name|superset
operator|=
name|sortDocSet
argument_list|(
name|out
operator|.
name|docSet
argument_list|,
name|lsort
argument_list|,
name|supersetMaxDoc
argument_list|)
expr_stmt|;
name|out
operator|.
name|docList
operator|=
name|superset
operator|.
name|subset
argument_list|(
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// do it the normal way...
name|DocSet
name|theFilt
init|=
name|filter
operator|!=
literal|null
condition|?
name|filter
else|:
name|getDocSet
argument_list|(
name|filterList
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|GET_DOCSET
operator|)
operator|!=
literal|0
condition|)
block|{
name|DocSet
name|qDocSet
init|=
name|getDocListAndSetNC
argument_list|(
name|out
argument_list|,
name|query
argument_list|,
name|theFilt
argument_list|,
name|lsort
argument_list|,
literal|0
argument_list|,
name|supersetMaxDoc
argument_list|,
name|flags
argument_list|)
decl_stmt|;
comment|// cache the docSet matching the query w/o filtering
if|if
condition|(
name|filterCache
operator|!=
literal|null
condition|)
name|filterCache
operator|.
name|put
argument_list|(
name|query
argument_list|,
name|qDocSet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|docList
operator|=
name|getDocListNC
argument_list|(
name|query
argument_list|,
name|theFilt
argument_list|,
name|lsort
argument_list|,
literal|0
argument_list|,
name|supersetMaxDoc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|superset
operator|=
name|out
operator|.
name|docList
expr_stmt|;
name|out
operator|.
name|docList
operator|=
name|superset
operator|.
name|subset
argument_list|(
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|// lastly, put the superset in the cache if the size is less than or equal
comment|// to queryResultMaxDocsCached
if|if
condition|(
name|key
operator|!=
literal|null
operator|&&
name|superset
operator|.
name|size
argument_list|()
operator|<=
name|queryResultMaxDocsCached
condition|)
block|{
name|queryResultCache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|superset
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getDocListNC
specifier|private
name|DocList
name|getDocListNC
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|lastDocRequested
init|=
name|offset
operator|+
name|len
decl_stmt|;
name|int
name|nDocsReturned
decl_stmt|;
name|int
name|totalHits
decl_stmt|;
name|float
name|maxScore
decl_stmt|;
name|int
index|[]
name|ids
decl_stmt|;
name|float
index|[]
name|scores
decl_stmt|;
name|query
operator|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|query
argument_list|)
expr_stmt|;
comment|// handle zero case...
if|if
condition|(
name|lastDocRequested
operator|<=
literal|0
condition|)
block|{
specifier|final
name|DocSet
name|filt
init|=
name|filter
decl_stmt|;
specifier|final
name|float
index|[]
name|topscore
init|=
operator|new
name|float
index|[]
block|{
name|Float
operator|.
name|NEGATIVE_INFINITY
block|}
decl_stmt|;
specifier|final
name|int
index|[]
name|numHits
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
operator|new
name|HitCollector
argument_list|()
block|{
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|,
name|float
name|score
parameter_list|)
block|{
if|if
condition|(
name|filt
operator|!=
literal|null
operator|&&
operator|!
name|filt
operator|.
name|exists
argument_list|(
name|doc
argument_list|)
condition|)
return|return;
name|numHits
index|[
literal|0
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|score
operator|>
name|topscore
index|[
literal|0
index|]
condition|)
name|topscore
index|[
literal|0
index|]
operator|=
name|score
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|nDocsReturned
operator|=
literal|0
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|new
name|float
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|totalHits
operator|=
name|numHits
index|[
literal|0
index|]
expr_stmt|;
name|maxScore
operator|=
name|totalHits
operator|>
literal|0
condition|?
name|topscore
index|[
literal|0
index|]
else|:
literal|0.0f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lsort
operator|!=
literal|null
condition|)
block|{
comment|// can't use TopDocs if there is a sort since it
comment|// will do automatic score normalization.
comment|// NOTE: this changed late in Lucene 1.9
specifier|final
name|DocSet
name|filt
init|=
name|filter
decl_stmt|;
specifier|final
name|int
index|[]
name|numHits
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|FieldSortedHitQueue
name|hq
init|=
operator|new
name|FieldSortedHitQueue
argument_list|(
name|reader
argument_list|,
name|lsort
operator|.
name|getSort
argument_list|()
argument_list|,
name|offset
operator|+
name|len
argument_list|)
decl_stmt|;
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
operator|new
name|HitCollector
argument_list|()
block|{
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|,
name|float
name|score
parameter_list|)
block|{
if|if
condition|(
name|filt
operator|!=
literal|null
operator|&&
operator|!
name|filt
operator|.
name|exists
argument_list|(
name|doc
argument_list|)
condition|)
return|return;
name|numHits
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|hq
operator|.
name|insert
argument_list|(
operator|new
name|FieldDoc
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|totalHits
operator|=
name|numHits
index|[
literal|0
index|]
expr_stmt|;
name|maxScore
operator|=
name|totalHits
operator|>
literal|0
condition|?
name|hq
operator|.
name|getMaxScore
argument_list|()
else|:
literal|0.0f
expr_stmt|;
name|nDocsReturned
operator|=
name|hq
operator|.
name|size
argument_list|()
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|(
name|flags
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
condition|?
operator|new
name|float
index|[
name|nDocsReturned
index|]
else|:
literal|null
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|nDocsReturned
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|FieldDoc
name|fieldDoc
init|=
operator|(
name|FieldDoc
operator|)
name|hq
operator|.
name|pop
argument_list|()
decl_stmt|;
comment|// fillFields is the point where score normalization happens
comment|// hq.fillFields(fieldDoc)
name|ids
index|[
name|i
index|]
operator|=
name|fieldDoc
operator|.
name|doc
expr_stmt|;
if|if
condition|(
name|scores
operator|!=
literal|null
condition|)
name|scores
index|[
name|i
index|]
operator|=
name|fieldDoc
operator|.
name|score
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// No Sort specified (sort by score descending)
comment|// This case could be done with TopDocs, but would currently require
comment|// getting a BitSet filter from a DocSet which may be inefficient.
specifier|final
name|DocSet
name|filt
init|=
name|filter
decl_stmt|;
specifier|final
name|ScorePriorityQueue
name|hq
init|=
operator|new
name|ScorePriorityQueue
argument_list|(
name|lastDocRequested
argument_list|)
decl_stmt|;
specifier|final
name|int
index|[]
name|numHits
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
operator|new
name|HitCollector
argument_list|()
block|{
name|float
name|minScore
init|=
name|Float
operator|.
name|NEGATIVE_INFINITY
decl_stmt|;
comment|// minimum score in the priority queue
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|,
name|float
name|score
parameter_list|)
block|{
if|if
condition|(
name|filt
operator|!=
literal|null
operator|&&
operator|!
name|filt
operator|.
name|exists
argument_list|(
name|doc
argument_list|)
condition|)
return|return;
if|if
condition|(
name|numHits
index|[
literal|0
index|]
operator|++
operator|<
name|lastDocRequested
operator|||
name|score
operator|>=
name|minScore
condition|)
block|{
comment|// TODO: if docs are always delivered in order, we could use "score>minScore"
comment|// instead of "score>=minScore" and avoid tiebreaking scores
comment|// in the priority queue.
comment|// but might BooleanScorer14 might still be used and deliver docs out-of-order?
name|hq
operator|.
name|insert
argument_list|(
operator|new
name|ScoreDoc
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
argument_list|)
expr_stmt|;
name|minScore
operator|=
operator|(
operator|(
name|ScoreDoc
operator|)
name|hq
operator|.
name|top
argument_list|()
operator|)
operator|.
name|score
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|totalHits
operator|=
name|numHits
index|[
literal|0
index|]
expr_stmt|;
name|nDocsReturned
operator|=
name|hq
operator|.
name|size
argument_list|()
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|(
name|flags
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
condition|?
operator|new
name|float
index|[
name|nDocsReturned
index|]
else|:
literal|null
expr_stmt|;
name|ScoreDoc
name|sdoc
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|nDocsReturned
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sdoc
operator|=
operator|(
name|ScoreDoc
operator|)
name|hq
operator|.
name|pop
argument_list|()
expr_stmt|;
name|ids
index|[
name|i
index|]
operator|=
name|sdoc
operator|.
name|doc
expr_stmt|;
if|if
condition|(
name|scores
operator|!=
literal|null
condition|)
name|scores
index|[
name|i
index|]
operator|=
name|sdoc
operator|.
name|score
expr_stmt|;
block|}
name|maxScore
operator|=
name|sdoc
operator|==
literal|null
condition|?
literal|0.0f
else|:
name|sdoc
operator|.
name|score
expr_stmt|;
block|}
name|int
name|sliceLen
init|=
name|Math
operator|.
name|min
argument_list|(
name|lastDocRequested
argument_list|,
name|nDocsReturned
argument_list|)
operator|-
name|offset
decl_stmt|;
if|if
condition|(
name|sliceLen
operator|<
literal|0
condition|)
name|sliceLen
operator|=
literal|0
expr_stmt|;
return|return
operator|new
name|DocSlice
argument_list|(
name|offset
argument_list|,
name|sliceLen
argument_list|,
name|ids
argument_list|,
name|scores
argument_list|,
name|totalHits
argument_list|,
name|maxScore
argument_list|)
return|;
comment|/**************** older implementation using TopDocs *******************         Filter lfilter=null;       if (filter != null) {         final BitSet bits = filter.getBits();   // avoid if possible         lfilter = new Filter() {           public BitSet bits(IndexReader reader)  {             return bits;           }         };       }        int lastDocRequested=offset+len;        // lucene doesn't allow 0 to be passed for nDocs       if (lastDocRequested==0) lastDocRequested=1;        // TopFieldDocs sortedDocs;  // use TopDocs so both versions can use it       TopDocs sortedDocs;       if (lsort!=null) {          sortedDocs = searcher.search(query, lfilter, lastDocRequested, lsort);       } else {          sortedDocs = searcher.search(query, lfilter, lastDocRequested);       }        int nDocsReturned = sortedDocs.scoreDocs.length;       int[] docs = new int[nDocsReturned];       for (int i=0; i<nDocsReturned; i++) {         docs[i] = sortedDocs.scoreDocs[i].doc;       }       float[] scores=null;       float maxScore=0.0f;       if ((flags& GET_SCORES) != 0) {         scores = new float[nDocsReturned];         for (int i=0; i<nDocsReturned; i++) {           scores[i] = sortedDocs.scoreDocs[i].score;         }         if (nDocsReturned>0) {           maxScore=sortedDocs.scoreDocs[0].score;         }       }       int sliceLen = Math.min(offset+len,nDocsReturned) - offset;       if (sliceLen< 0) sliceLen=0;       return new DocSlice(offset,sliceLen,docs,scores,sortedDocs.totalHits, maxScore);      **********************************************************************************/
block|}
comment|// the DocSet returned is for the query only, without any filtering... that way it may
comment|// be cached if desired.
DECL|method|getDocListAndSetNC
specifier|private
name|DocSet
name|getDocListAndSetNC
parameter_list|(
name|DocListAndSet
name|out
parameter_list|,
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|lastDocRequested
init|=
name|offset
operator|+
name|len
decl_stmt|;
name|int
name|nDocsReturned
decl_stmt|;
name|int
name|totalHits
decl_stmt|;
name|float
name|maxScore
decl_stmt|;
name|int
index|[]
name|ids
decl_stmt|;
name|float
index|[]
name|scores
decl_stmt|;
specifier|final
name|DocSetHitCollector
name|setHC
init|=
operator|new
name|DocSetHitCollector
argument_list|(
name|HASHSET_INVERSE_LOAD_FACTOR
argument_list|,
name|HASHDOCSET_MAXSIZE
argument_list|,
name|maxDoc
argument_list|()
argument_list|)
decl_stmt|;
name|query
operator|=
name|QueryUtils
operator|.
name|makeQueryable
argument_list|(
name|query
argument_list|)
expr_stmt|;
comment|// TODO: perhaps unify getDocListAndSetNC and getDocListNC without imposing a significant performance hit
comment|// Comment: gathering the set before the filter is applied allows one to cache
comment|// the resulting DocSet under the query.  The drawback is that it requires an
comment|// extra intersection with the filter at the end.  This will be a net win
comment|// for expensive queries.
comment|// Q: what if the final intersection results in a small set from two large
comment|// sets... it won't be a HashDocSet or other small set.  One way around
comment|// this would be to collect the resulting set as we go (the filter is
comment|// checked anyway).
comment|// handle zero case...
if|if
condition|(
name|lastDocRequested
operator|<=
literal|0
condition|)
block|{
specifier|final
name|DocSet
name|filt
init|=
name|filter
decl_stmt|;
specifier|final
name|float
index|[]
name|topscore
init|=
operator|new
name|float
index|[]
block|{
name|Float
operator|.
name|NEGATIVE_INFINITY
block|}
decl_stmt|;
specifier|final
name|int
index|[]
name|numHits
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
operator|new
name|HitCollector
argument_list|()
block|{
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|,
name|float
name|score
parameter_list|)
block|{
name|setHC
operator|.
name|collect
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|filt
operator|!=
literal|null
operator|&&
operator|!
name|filt
operator|.
name|exists
argument_list|(
name|doc
argument_list|)
condition|)
return|return;
name|numHits
index|[
literal|0
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|score
operator|>
name|topscore
index|[
literal|0
index|]
condition|)
name|topscore
index|[
literal|0
index|]
operator|=
name|score
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|nDocsReturned
operator|=
literal|0
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|new
name|float
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|totalHits
operator|=
name|numHits
index|[
literal|0
index|]
expr_stmt|;
name|maxScore
operator|=
name|totalHits
operator|>
literal|0
condition|?
name|topscore
index|[
literal|0
index|]
else|:
literal|0.0f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lsort
operator|!=
literal|null
condition|)
block|{
comment|// can't use TopDocs if there is a sort since it
comment|// will do automatic score normalization.
comment|// NOTE: this changed late in Lucene 1.9
specifier|final
name|DocSet
name|filt
init|=
name|filter
decl_stmt|;
specifier|final
name|int
index|[]
name|numHits
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|FieldSortedHitQueue
name|hq
init|=
operator|new
name|FieldSortedHitQueue
argument_list|(
name|reader
argument_list|,
name|lsort
operator|.
name|getSort
argument_list|()
argument_list|,
name|offset
operator|+
name|len
argument_list|)
decl_stmt|;
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
operator|new
name|HitCollector
argument_list|()
block|{
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|,
name|float
name|score
parameter_list|)
block|{
name|setHC
operator|.
name|collect
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|filt
operator|!=
literal|null
operator|&&
operator|!
name|filt
operator|.
name|exists
argument_list|(
name|doc
argument_list|)
condition|)
return|return;
name|numHits
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|hq
operator|.
name|insert
argument_list|(
operator|new
name|FieldDoc
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|totalHits
operator|=
name|numHits
index|[
literal|0
index|]
expr_stmt|;
name|maxScore
operator|=
name|totalHits
operator|>
literal|0
condition|?
name|hq
operator|.
name|getMaxScore
argument_list|()
else|:
literal|0.0f
expr_stmt|;
name|nDocsReturned
operator|=
name|hq
operator|.
name|size
argument_list|()
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|(
name|flags
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
condition|?
operator|new
name|float
index|[
name|nDocsReturned
index|]
else|:
literal|null
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|nDocsReturned
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|FieldDoc
name|fieldDoc
init|=
operator|(
name|FieldDoc
operator|)
name|hq
operator|.
name|pop
argument_list|()
decl_stmt|;
comment|// fillFields is the point where score normalization happens
comment|// hq.fillFields(fieldDoc)
name|ids
index|[
name|i
index|]
operator|=
name|fieldDoc
operator|.
name|doc
expr_stmt|;
if|if
condition|(
name|scores
operator|!=
literal|null
condition|)
name|scores
index|[
name|i
index|]
operator|=
name|fieldDoc
operator|.
name|score
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// No Sort specified (sort by score descending)
comment|// This case could be done with TopDocs, but would currently require
comment|// getting a BitSet filter from a DocSet which may be inefficient.
specifier|final
name|DocSet
name|filt
init|=
name|filter
decl_stmt|;
specifier|final
name|ScorePriorityQueue
name|hq
init|=
operator|new
name|ScorePriorityQueue
argument_list|(
name|lastDocRequested
argument_list|)
decl_stmt|;
specifier|final
name|int
index|[]
name|numHits
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
operator|new
name|HitCollector
argument_list|()
block|{
name|float
name|minScore
init|=
name|Float
operator|.
name|NEGATIVE_INFINITY
decl_stmt|;
comment|// minimum score in the priority queue
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|,
name|float
name|score
parameter_list|)
block|{
name|setHC
operator|.
name|collect
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|filt
operator|!=
literal|null
operator|&&
operator|!
name|filt
operator|.
name|exists
argument_list|(
name|doc
argument_list|)
condition|)
return|return;
if|if
condition|(
name|numHits
index|[
literal|0
index|]
operator|++
operator|<
name|lastDocRequested
operator|||
name|score
operator|>=
name|minScore
condition|)
block|{
comment|// if docs are always delivered in order, we could use "score>minScore"
comment|// but might BooleanScorer14 might still be used and deliver docs out-of-order?
name|hq
operator|.
name|insert
argument_list|(
operator|new
name|ScoreDoc
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
argument_list|)
expr_stmt|;
name|minScore
operator|=
operator|(
operator|(
name|ScoreDoc
operator|)
name|hq
operator|.
name|top
argument_list|()
operator|)
operator|.
name|score
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|totalHits
operator|=
name|numHits
index|[
literal|0
index|]
expr_stmt|;
name|nDocsReturned
operator|=
name|hq
operator|.
name|size
argument_list|()
expr_stmt|;
name|ids
operator|=
operator|new
name|int
index|[
name|nDocsReturned
index|]
expr_stmt|;
name|scores
operator|=
operator|(
name|flags
operator|&
name|GET_SCORES
operator|)
operator|!=
literal|0
condition|?
operator|new
name|float
index|[
name|nDocsReturned
index|]
else|:
literal|null
expr_stmt|;
name|ScoreDoc
name|sdoc
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|nDocsReturned
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sdoc
operator|=
operator|(
name|ScoreDoc
operator|)
name|hq
operator|.
name|pop
argument_list|()
expr_stmt|;
name|ids
index|[
name|i
index|]
operator|=
name|sdoc
operator|.
name|doc
expr_stmt|;
if|if
condition|(
name|scores
operator|!=
literal|null
condition|)
name|scores
index|[
name|i
index|]
operator|=
name|sdoc
operator|.
name|score
expr_stmt|;
block|}
name|maxScore
operator|=
name|sdoc
operator|==
literal|null
condition|?
literal|0.0f
else|:
name|sdoc
operator|.
name|score
expr_stmt|;
block|}
name|int
name|sliceLen
init|=
name|Math
operator|.
name|min
argument_list|(
name|lastDocRequested
argument_list|,
name|nDocsReturned
argument_list|)
operator|-
name|offset
decl_stmt|;
if|if
condition|(
name|sliceLen
operator|<
literal|0
condition|)
name|sliceLen
operator|=
literal|0
expr_stmt|;
name|out
operator|.
name|docList
operator|=
operator|new
name|DocSlice
argument_list|(
name|offset
argument_list|,
name|sliceLen
argument_list|,
name|ids
argument_list|,
name|scores
argument_list|,
name|totalHits
argument_list|,
name|maxScore
argument_list|)
expr_stmt|;
name|DocSet
name|qDocSet
init|=
name|setHC
operator|.
name|getDocSet
argument_list|()
decl_stmt|;
name|out
operator|.
name|docSet
operator|=
name|filter
operator|==
literal|null
condition|?
name|qDocSet
else|:
name|qDocSet
operator|.
name|intersection
argument_list|(
name|filter
argument_list|)
expr_stmt|;
return|return
name|qDocSet
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>.    * FUTURE: The returned DocList may be retrieved from a cache.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocList meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocList
specifier|public
name|DocList
name|getDocList
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|DocListAndSet
name|answer
init|=
operator|new
name|DocListAndSet
argument_list|()
decl_stmt|;
name|getDocListC
argument_list|(
name|answer
argument_list|,
name|query
argument_list|,
literal|null
argument_list|,
name|filter
argument_list|,
name|lsort
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|answer
operator|.
name|docList
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>.  Also returns the compete set of documents    * matching<code>query</code> and<code>filter</code> (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|Query
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
init|=
name|buildQueryList
argument_list|(
name|filter
argument_list|)
decl_stmt|;
return|return
name|getDocListAndSet
argument_list|(
name|query
argument_list|,
name|filterList
argument_list|,
name|lsort
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>.  Also returns the compete set of documents    * matching<code>query</code> and<code>filter</code> (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @param flags    user supplied flags for the result set    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|Query
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
init|=
name|buildQueryList
argument_list|(
name|filter
argument_list|)
decl_stmt|;
return|return
name|getDocListAndSet
argument_list|(
name|query
argument_list|,
name|filterList
argument_list|,
name|lsort
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
return|;
block|}
comment|/**    * A simple utility method for to build a filterList from a query    * @param filter    */
DECL|method|buildQueryList
specifier|private
name|List
argument_list|<
name|Query
argument_list|>
name|buildQueryList
parameter_list|(
name|Query
name|filter
parameter_list|)
block|{
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
name|filterList
operator|=
operator|new
name|ArrayList
argument_list|<
name|Query
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|filterList
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
return|return
name|filterList
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and the intersection     * of<code>filterList</code>, sorted by<code>sort</code>.      * Also returns the compete set of documents    * matching<code>query</code> and<code>filter</code>     * (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param query    * @param filterList   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|DocListAndSet
name|ret
init|=
operator|new
name|DocListAndSet
argument_list|()
decl_stmt|;
name|getDocListC
argument_list|(
name|ret
argument_list|,
name|query
argument_list|,
name|filterList
argument_list|,
literal|null
argument_list|,
name|lsort
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|GET_DOCSET
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and the intersection     * of<code>filterList</code>, sorted by<code>sort</code>.      * Also returns the compete set of documents    * matching<code>query</code> and<code>filter</code>     * (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may retrieve<code>filter</code> from    * the cache or make an insertion into the cache as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param query    * @param filterList   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @param flags    user supplied flags for the result set    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|List
argument_list|<
name|Query
argument_list|>
name|filterList
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|DocListAndSet
name|ret
init|=
operator|new
name|DocListAndSet
argument_list|()
decl_stmt|;
name|getDocListC
argument_list|(
name|ret
argument_list|,
name|query
argument_list|,
name|filterList
argument_list|,
literal|null
argument_list|,
name|lsort
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|flags
operator||=
name|GET_DOCSET
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>. Also returns the compete set of documents    * matching<code>query</code> and<code>filter</code> (regardless of<code>offset</code> and<code>len</code>).    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|DocListAndSet
name|ret
init|=
operator|new
name|DocListAndSet
argument_list|()
decl_stmt|;
name|getDocListC
argument_list|(
name|ret
argument_list|,
name|query
argument_list|,
literal|null
argument_list|,
name|filter
argument_list|,
name|lsort
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|GET_DOCSET
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * Returns documents matching both<code>query</code> and<code>filter</code>    * and sorted by<code>sort</code>.  Also returns the compete set of documents    * matching<code>query</code> and<code>filter</code> (regardless of<code>offset</code> and<code>len</code>).    *<p>    * This method is cache aware and may make an insertion into the cache     * as a result of this call.    *<p>    * FUTURE: The returned DocList may be retrieved from a cache.    *<p>    * The DocList and DocSet returned should<b>not</b> be modified.    *    * @param query    * @param filter   may be null    * @param lsort    criteria by which to sort (if null, query relevance is used)    * @param offset   offset into the list of documents to return    * @param len      maximum number of documents to return    * @param flags    user supplied flags for the result set    * @return DocListAndSet meeting the specified criteria, should<b>not</b> be modified by the caller.    * @throws IOException    */
DECL|method|getDocListAndSet
specifier|public
name|DocListAndSet
name|getDocListAndSet
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocSet
name|filter
parameter_list|,
name|Sort
name|lsort
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|DocListAndSet
name|ret
init|=
operator|new
name|DocListAndSet
argument_list|()
decl_stmt|;
name|getDocListC
argument_list|(
name|ret
argument_list|,
name|query
argument_list|,
literal|null
argument_list|,
name|filter
argument_list|,
name|lsort
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|flags
operator||=
name|GET_DOCSET
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
DECL|method|sortDocSet
specifier|protected
name|DocList
name|sortDocSet
parameter_list|(
name|DocSet
name|set
parameter_list|,
name|Sort
name|sort
parameter_list|,
name|int
name|nDocs
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FieldSortedHitQueue
name|hq
init|=
operator|new
name|FieldSortedHitQueue
argument_list|(
name|reader
argument_list|,
name|sort
operator|.
name|getSort
argument_list|()
argument_list|,
name|nDocs
argument_list|)
decl_stmt|;
name|DocIterator
name|iter
init|=
name|set
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|hits
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|doc
init|=
name|iter
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
name|hits
operator|++
expr_stmt|;
comment|// could just use set.size(), but that would be slower for a bitset
name|hq
operator|.
name|insert
argument_list|(
operator|new
name|FieldDoc
argument_list|(
name|doc
argument_list|,
literal|1.0f
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|numCollected
init|=
name|hq
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
index|[]
name|ids
init|=
operator|new
name|int
index|[
name|numCollected
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|numCollected
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|FieldDoc
name|fieldDoc
init|=
operator|(
name|FieldDoc
operator|)
name|hq
operator|.
name|pop
argument_list|()
decl_stmt|;
comment|// hq.fillFields(fieldDoc)  // optional, if we need that info
name|ids
index|[
name|i
index|]
operator|=
name|fieldDoc
operator|.
name|doc
expr_stmt|;
block|}
return|return
operator|new
name|DocSlice
argument_list|(
literal|0
argument_list|,
name|numCollected
argument_list|,
name|ids
argument_list|,
literal|null
argument_list|,
name|hits
argument_list|,
literal|0.0f
argument_list|)
return|;
block|}
comment|/**    * Returns the number of documents that match both<code>a</code> and<code>b</code>.    *<p>    * This method is cache-aware and may check as well as modify the cache.    *    * @param a    * @param b    * @return the numer of documents in the intersection between<code>a</code> and<code>b</code>.    * @throws IOException    */
DECL|method|numDocs
specifier|public
name|int
name|numDocs
parameter_list|(
name|Query
name|a
parameter_list|,
name|DocSet
name|b
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Negative query if absolute value different from original
name|Query
name|absQ
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|DocSet
name|positiveA
init|=
name|getPositiveDocSet
argument_list|(
name|absQ
argument_list|)
decl_stmt|;
return|return
name|a
operator|==
name|absQ
condition|?
name|b
operator|.
name|intersectionSize
argument_list|(
name|positiveA
argument_list|)
else|:
name|b
operator|.
name|andNotSize
argument_list|(
name|positiveA
argument_list|)
return|;
block|}
comment|/**    * Returns the number of documents that match both<code>a</code> and<code>b</code>.    *<p>    * This method is cache-aware and may check as well as modify the cache.    *    * @param a    * @param b    * @return the numer of documents in the intersection between<code>a</code> and<code>b</code>.    * @throws IOException    */
DECL|method|numDocs
specifier|public
name|int
name|numDocs
parameter_list|(
name|Query
name|a
parameter_list|,
name|Query
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|Query
name|absA
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|Query
name|absB
init|=
name|QueryUtils
operator|.
name|getAbs
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|DocSet
name|positiveA
init|=
name|getPositiveDocSet
argument_list|(
name|absA
argument_list|)
decl_stmt|;
name|DocSet
name|positiveB
init|=
name|getPositiveDocSet
argument_list|(
name|absB
argument_list|)
decl_stmt|;
comment|// Negative query if absolute value different from original
if|if
condition|(
name|a
operator|==
name|absA
condition|)
block|{
if|if
condition|(
name|b
operator|==
name|absB
condition|)
return|return
name|positiveA
operator|.
name|intersectionSize
argument_list|(
name|positiveB
argument_list|)
return|;
return|return
name|positiveA
operator|.
name|andNotSize
argument_list|(
name|positiveB
argument_list|)
return|;
block|}
if|if
condition|(
name|b
operator|==
name|absB
condition|)
return|return
name|positiveB
operator|.
name|andNotSize
argument_list|(
name|positiveA
argument_list|)
return|;
comment|// if both negative, we need to create a temp DocSet since we
comment|// don't have a counting method that takes three.
name|DocSet
name|all
init|=
name|getPositiveDocSet
argument_list|(
name|matchAllDocsQuery
argument_list|)
decl_stmt|;
comment|// -a -b == *:*.andNot(a).andNotSize(b) == *.*.andNotSize(a.union(b))
comment|// we use the last form since the intermediate DocSet should normally be smaller.
return|return
name|all
operator|.
name|andNotSize
argument_list|(
name|positiveA
operator|.
name|union
argument_list|(
name|positiveB
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Takes a list of docs (the doc ids actually), and returns an array     * of Documents containing all of the stored fields.    */
DECL|method|readDocs
specifier|public
name|Document
index|[]
name|readDocs
parameter_list|(
name|DocList
name|ids
parameter_list|)
throws|throws
name|IOException
block|{
name|Document
index|[]
name|docs
init|=
operator|new
name|Document
index|[
name|ids
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|readDocs
argument_list|(
name|docs
argument_list|,
name|ids
argument_list|)
expr_stmt|;
return|return
name|docs
return|;
block|}
comment|/**    * Warm this searcher based on an old one (primarily for auto-cache warming).    */
DECL|method|warm
specifier|public
name|void
name|warm
parameter_list|(
name|SolrIndexSearcher
name|old
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Make sure this is first!  filters can help queryResults execute!
name|boolean
name|logme
init|=
name|log
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|INFO
argument_list|)
decl_stmt|;
comment|// warm the caches in order...
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cacheList
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|logme
condition|)
name|log
operator|.
name|info
argument_list|(
literal|"autowarming "
operator|+
name|this
operator|+
literal|" from "
operator|+
name|old
operator|+
literal|"\n\t"
operator|+
name|old
operator|.
name|cacheList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|this
operator|.
name|cacheList
index|[
name|i
index|]
operator|.
name|warm
argument_list|(
name|this
argument_list|,
name|old
operator|.
name|cacheList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|logme
condition|)
name|log
operator|.
name|info
argument_list|(
literal|"autowarming result for "
operator|+
name|this
operator|+
literal|"\n\t"
operator|+
name|this
operator|.
name|cacheList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * return the named generic cache    */
DECL|method|getCache
specifier|public
name|SolrCache
name|getCache
parameter_list|(
name|String
name|cacheName
parameter_list|)
block|{
return|return
name|cacheMap
operator|.
name|get
argument_list|(
name|cacheName
argument_list|)
return|;
block|}
comment|/**    * lookup an entry in a generic cache    */
DECL|method|cacheLookup
specifier|public
name|Object
name|cacheLookup
parameter_list|(
name|String
name|cacheName
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
name|SolrCache
name|cache
init|=
name|cacheMap
operator|.
name|get
argument_list|(
name|cacheName
argument_list|)
decl_stmt|;
return|return
name|cache
operator|==
literal|null
condition|?
literal|null
else|:
name|cache
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**    * insert an entry in a generic cache    */
DECL|method|cacheInsert
specifier|public
name|Object
name|cacheInsert
parameter_list|(
name|String
name|cacheName
parameter_list|,
name|Object
name|key
parameter_list|,
name|Object
name|val
parameter_list|)
block|{
name|SolrCache
name|cache
init|=
name|cacheMap
operator|.
name|get
argument_list|(
name|cacheName
argument_list|)
decl_stmt|;
return|return
name|cache
operator|==
literal|null
condition|?
literal|null
else|:
name|cache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
return|;
block|}
comment|/////////////////////////////////////////////////////////////////////
comment|// SolrInfoMBean stuff: Statistics and Module Info
comment|/////////////////////////////////////////////////////////////////////
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|SolrIndexSearcher
operator|.
name|class
operator|.
name|getName
argument_list|()
return|;
block|}
DECL|method|getVersion
specifier|public
name|String
name|getVersion
parameter_list|()
block|{
return|return
name|SolrCore
operator|.
name|version
return|;
block|}
DECL|method|getDescription
specifier|public
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"index searcher"
return|;
block|}
DECL|method|getCategory
specifier|public
name|Category
name|getCategory
parameter_list|()
block|{
return|return
name|Category
operator|.
name|CORE
return|;
block|}
DECL|method|getSourceId
specifier|public
name|String
name|getSourceId
parameter_list|()
block|{
return|return
literal|"$Id$"
return|;
block|}
DECL|method|getSource
specifier|public
name|String
name|getSource
parameter_list|()
block|{
return|return
literal|"$URL$"
return|;
block|}
DECL|method|getDocs
specifier|public
name|URL
index|[]
name|getDocs
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|getStatistics
specifier|public
name|NamedList
name|getStatistics
parameter_list|()
block|{
name|NamedList
name|lst
init|=
operator|new
name|SimpleOrderedMap
argument_list|()
decl_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"caching"
argument_list|,
name|cachingEnabled
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"numDocs"
argument_list|,
name|reader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"maxDoc"
argument_list|,
name|reader
operator|.
name|maxDoc
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"readerImpl"
argument_list|,
name|reader
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"readerDir"
argument_list|,
name|reader
operator|.
name|directory
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"indexVersion"
argument_list|,
name|reader
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"openedAt"
argument_list|,
operator|new
name|Date
argument_list|(
name|openTime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|registerTime
operator|!=
literal|0
condition|)
name|lst
operator|.
name|add
argument_list|(
literal|"registeredAt"
argument_list|,
operator|new
name|Date
argument_list|(
name|registerTime
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|lst
return|;
block|}
block|}
end_class
begin_comment
comment|// Lucene's HitQueue isn't public, so here is our own.
end_comment
begin_class
DECL|class|ScorePriorityQueue
specifier|final
class|class
name|ScorePriorityQueue
extends|extends
name|PriorityQueue
block|{
DECL|method|ScorePriorityQueue
name|ScorePriorityQueue
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|initialize
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
DECL|method|lessThan
specifier|protected
specifier|final
name|boolean
name|lessThan
parameter_list|(
name|Object
name|o1
parameter_list|,
name|Object
name|o2
parameter_list|)
block|{
name|ScoreDoc
name|sd1
init|=
operator|(
name|ScoreDoc
operator|)
name|o1
decl_stmt|;
name|ScoreDoc
name|sd2
init|=
operator|(
name|ScoreDoc
operator|)
name|o2
decl_stmt|;
comment|// use index order as a tiebreaker to make sorts stable
return|return
name|sd1
operator|.
name|score
operator|<
name|sd2
operator|.
name|score
operator|||
operator|(
name|sd1
operator|.
name|score
operator|==
name|sd2
operator|.
name|score
operator|&&
name|sd1
operator|.
name|doc
operator|>
name|sd2
operator|.
name|doc
operator|)
return|;
block|}
block|}
end_class
end_unit
