begin_unit
begin_package
DECL|package|org.apache.solr.util
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
package|;
end_package
begin_comment
comment|/**  A variety of high efficiencly bit twiddling routines.  *  * @author yonik  * @version $Id$  */
end_comment
begin_class
DECL|class|BitUtil
specifier|public
class|class
name|BitUtil
block|{
comment|/** Returns the number of bits set in the long */
DECL|method|pop
specifier|public
specifier|static
name|int
name|pop
parameter_list|(
name|long
name|x
parameter_list|)
block|{
comment|/* Hacker's Delight 32 bit pop function:    * http://www.hackersdelight.org/HDcode/newCode/pop_arrayHS.cc    *   int pop(unsigned x) {      x = x - ((x>> 1)& 0x55555555);      x = (x& 0x33333333) + ((x>> 2)& 0x33333333);      x = (x + (x>> 4))& 0x0F0F0F0F;      x = x + (x>> 8);      x = x + (x>> 16);      return x& 0x0000003F;     }   ***/
comment|// 64 bit java version of the C function from above
name|x
operator|=
name|x
operator|-
operator|(
operator|(
name|x
operator|>>>
literal|1
operator|)
operator|&
literal|0x5555555555555555L
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0x3333333333333333L
operator|)
operator|+
operator|(
operator|(
name|x
operator|>>>
literal|2
operator|)
operator|&
literal|0x3333333333333333L
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|+
operator|(
name|x
operator|>>>
literal|4
operator|)
operator|)
operator|&
literal|0x0F0F0F0F0F0F0F0FL
expr_stmt|;
name|x
operator|=
name|x
operator|+
operator|(
name|x
operator|>>>
literal|8
operator|)
expr_stmt|;
name|x
operator|=
name|x
operator|+
operator|(
name|x
operator|>>>
literal|16
operator|)
expr_stmt|;
name|x
operator|=
name|x
operator|+
operator|(
name|x
operator|>>>
literal|32
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|x
operator|)
operator|&
literal|0x7F
return|;
block|}
comment|/*** Returns the number of set bits in an array of longs. */
DECL|method|pop_array
specifier|public
specifier|static
name|long
name|pop_array
parameter_list|(
name|long
name|A
index|[]
parameter_list|,
name|int
name|wordOffset
parameter_list|,
name|int
name|numWords
parameter_list|)
block|{
comment|/*     * Robert Harley and David Seal's bit counting algorithm, as documented     * in the revisions of Hacker's Delight     * http://www.hackersdelight.org/revisions.pdf     * http://www.hackersdelight.org/HDcode/newCode/pop_arrayHS.cc     *     * This function was adapted to Java, and extended to use 64 bit words.     * if only we had access to wider registers like SSE from java...     *     * This function can be transformed to compute the popcount of other functions     * on bitsets via something like this:     * sed 's/A\[\([^]]*\)\]/\(A[\1] \& B[\1]\)/g'     *     */
name|int
name|n
init|=
name|wordOffset
operator|+
name|numWords
decl_stmt|;
name|long
name|tot
init|=
literal|0
decl_stmt|,
name|tot8
init|=
literal|0
decl_stmt|;
name|long
name|ones
init|=
literal|0
decl_stmt|,
name|twos
init|=
literal|0
decl_stmt|,
name|fours
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|wordOffset
init|;
name|i
operator|<=
name|n
operator|-
literal|8
condition|;
name|i
operator|+=
literal|8
control|)
block|{
comment|/***  C macro from Hacker's Delight        #define CSA(h,l, a,b,c) \        {unsigned u = a ^ b; unsigned v = c; \        h = (a& b) | (u& v); l = u ^ v;}        ***/
name|long
name|twosA
decl_stmt|,
name|twosB
decl_stmt|,
name|foursA
decl_stmt|,
name|foursB
decl_stmt|,
name|eights
decl_stmt|;
comment|// CSA(twosA, ones, ones, A[i], A[i+1])
block|{
name|long
name|b
init|=
name|A
index|[
name|i
index|]
decl_stmt|,
name|c
init|=
name|A
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosA
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|// CSA(twosB, ones, ones, A[i+2], A[i+3])
block|{
name|long
name|b
init|=
name|A
index|[
name|i
operator|+
literal|2
index|]
decl_stmt|,
name|c
init|=
name|A
index|[
name|i
operator|+
literal|3
index|]
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosB
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|//CSA(foursA, twos, twos, twosA, twosB)
block|{
name|long
name|u
init|=
name|twos
operator|^
name|twosA
decl_stmt|;
name|foursA
operator|=
operator|(
name|twos
operator|&
name|twosA
operator|)
operator||
operator|(
name|u
operator|&
name|twosB
operator|)
expr_stmt|;
name|twos
operator|=
name|u
operator|^
name|twosB
expr_stmt|;
block|}
comment|//CSA(twosA, ones, ones, A[i+4], A[i+5])
block|{
name|long
name|b
init|=
name|A
index|[
name|i
operator|+
literal|4
index|]
decl_stmt|,
name|c
init|=
name|A
index|[
name|i
operator|+
literal|5
index|]
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosA
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|// CSA(twosB, ones, ones, A[i+6], A[i+7])
block|{
name|long
name|b
init|=
name|A
index|[
name|i
operator|+
literal|6
index|]
decl_stmt|,
name|c
init|=
name|A
index|[
name|i
operator|+
literal|7
index|]
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosB
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|//CSA(foursB, twos, twos, twosA, twosB)
block|{
name|long
name|u
init|=
name|twos
operator|^
name|twosA
decl_stmt|;
name|foursB
operator|=
operator|(
name|twos
operator|&
name|twosA
operator|)
operator||
operator|(
name|u
operator|&
name|twosB
operator|)
expr_stmt|;
name|twos
operator|=
name|u
operator|^
name|twosB
expr_stmt|;
block|}
comment|//CSA(eights, fours, fours, foursA, foursB)
block|{
name|long
name|u
init|=
name|fours
operator|^
name|foursA
decl_stmt|;
name|eights
operator|=
operator|(
name|fours
operator|&
name|foursA
operator|)
operator||
operator|(
name|u
operator|&
name|foursB
operator|)
expr_stmt|;
name|fours
operator|=
name|u
operator|^
name|foursB
expr_stmt|;
block|}
name|tot8
operator|+=
name|pop
argument_list|(
name|eights
argument_list|)
expr_stmt|;
block|}
comment|// handle trailing words in a binary-search manner...
comment|// derived from the loop above by setting specific elements to 0.
comment|// the original method in Hackers Delight used a simple for loop:
comment|//   for (i = i; i< n; i++)      // Add in the last elements
comment|//  tot = tot + pop(A[i]);
if|if
condition|(
name|i
operator|<=
name|n
operator|-
literal|4
condition|)
block|{
name|long
name|twosA
decl_stmt|,
name|twosB
decl_stmt|,
name|foursA
decl_stmt|,
name|eights
decl_stmt|;
block|{
name|long
name|b
init|=
name|A
index|[
name|i
index|]
decl_stmt|,
name|c
init|=
name|A
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosA
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
block|{
name|long
name|b
init|=
name|A
index|[
name|i
operator|+
literal|2
index|]
decl_stmt|,
name|c
init|=
name|A
index|[
name|i
operator|+
literal|3
index|]
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosB
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
block|{
name|long
name|u
init|=
name|twos
operator|^
name|twosA
decl_stmt|;
name|foursA
operator|=
operator|(
name|twos
operator|&
name|twosA
operator|)
operator||
operator|(
name|u
operator|&
name|twosB
operator|)
expr_stmt|;
name|twos
operator|=
name|u
operator|^
name|twosB
expr_stmt|;
block|}
name|eights
operator|=
name|fours
operator|&
name|foursA
expr_stmt|;
name|fours
operator|=
name|fours
operator|^
name|foursA
expr_stmt|;
name|tot8
operator|+=
name|pop
argument_list|(
name|eights
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
name|n
operator|-
literal|2
condition|)
block|{
name|long
name|b
init|=
name|A
index|[
name|i
index|]
decl_stmt|,
name|c
init|=
name|A
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|long
name|twosA
init|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
decl_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
name|long
name|foursA
init|=
name|twos
operator|&
name|twosA
decl_stmt|;
name|twos
operator|=
name|twos
operator|^
name|twosA
expr_stmt|;
name|long
name|eights
init|=
name|fours
operator|&
name|foursA
decl_stmt|;
name|fours
operator|=
name|fours
operator|^
name|foursA
expr_stmt|;
name|tot8
operator|+=
name|pop
argument_list|(
name|eights
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|tot
operator|+=
name|pop
argument_list|(
name|A
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|tot
operator|+=
operator|(
name|pop
argument_list|(
name|fours
argument_list|)
operator|<<
literal|2
operator|)
operator|+
operator|(
name|pop
argument_list|(
name|twos
argument_list|)
operator|<<
literal|1
operator|)
operator|+
name|pop
argument_list|(
name|ones
argument_list|)
operator|+
operator|(
name|tot8
operator|<<
literal|3
operator|)
expr_stmt|;
return|return
name|tot
return|;
block|}
comment|/** Returns the popcount or cardinality of the two sets after an intersection.    * Neither array is modified.    */
DECL|method|pop_intersect
specifier|public
specifier|static
name|long
name|pop_intersect
parameter_list|(
name|long
name|A
index|[]
parameter_list|,
name|long
name|B
index|[]
parameter_list|,
name|int
name|wordOffset
parameter_list|,
name|int
name|numWords
parameter_list|)
block|{
comment|// generated from pop_array via sed 's/A\[\([^]]*\)\]/\(A[\1] \& B[\1]\)/g'
name|int
name|n
init|=
name|wordOffset
operator|+
name|numWords
decl_stmt|;
name|long
name|tot
init|=
literal|0
decl_stmt|,
name|tot8
init|=
literal|0
decl_stmt|;
name|long
name|ones
init|=
literal|0
decl_stmt|,
name|twos
init|=
literal|0
decl_stmt|,
name|fours
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|wordOffset
init|;
name|i
operator|<=
name|n
operator|-
literal|8
condition|;
name|i
operator|+=
literal|8
control|)
block|{
name|long
name|twosA
decl_stmt|,
name|twosB
decl_stmt|,
name|foursA
decl_stmt|,
name|foursB
decl_stmt|,
name|eights
decl_stmt|;
comment|// CSA(twosA, ones, ones, (A[i]& B[i]), (A[i+1]& B[i+1]))
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
index|]
operator|&
name|B
index|[
name|i
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|1
index|]
operator|&
name|B
index|[
name|i
operator|+
literal|1
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosA
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|// CSA(twosB, ones, ones, (A[i+2]& B[i+2]), (A[i+3]& B[i+3]))
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|2
index|]
operator|&
name|B
index|[
name|i
operator|+
literal|2
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|3
index|]
operator|&
name|B
index|[
name|i
operator|+
literal|3
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosB
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|//CSA(foursA, twos, twos, twosA, twosB)
block|{
name|long
name|u
init|=
name|twos
operator|^
name|twosA
decl_stmt|;
name|foursA
operator|=
operator|(
name|twos
operator|&
name|twosA
operator|)
operator||
operator|(
name|u
operator|&
name|twosB
operator|)
expr_stmt|;
name|twos
operator|=
name|u
operator|^
name|twosB
expr_stmt|;
block|}
comment|//CSA(twosA, ones, ones, (A[i+4]& B[i+4]), (A[i+5]& B[i+5]))
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|4
index|]
operator|&
name|B
index|[
name|i
operator|+
literal|4
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|5
index|]
operator|&
name|B
index|[
name|i
operator|+
literal|5
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosA
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|// CSA(twosB, ones, ones, (A[i+6]& B[i+6]), (A[i+7]& B[i+7]))
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|6
index|]
operator|&
name|B
index|[
name|i
operator|+
literal|6
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|7
index|]
operator|&
name|B
index|[
name|i
operator|+
literal|7
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosB
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|//CSA(foursB, twos, twos, twosA, twosB)
block|{
name|long
name|u
init|=
name|twos
operator|^
name|twosA
decl_stmt|;
name|foursB
operator|=
operator|(
name|twos
operator|&
name|twosA
operator|)
operator||
operator|(
name|u
operator|&
name|twosB
operator|)
expr_stmt|;
name|twos
operator|=
name|u
operator|^
name|twosB
expr_stmt|;
block|}
comment|//CSA(eights, fours, fours, foursA, foursB)
block|{
name|long
name|u
init|=
name|fours
operator|^
name|foursA
decl_stmt|;
name|eights
operator|=
operator|(
name|fours
operator|&
name|foursA
operator|)
operator||
operator|(
name|u
operator|&
name|foursB
operator|)
expr_stmt|;
name|fours
operator|=
name|u
operator|^
name|foursB
expr_stmt|;
block|}
name|tot8
operator|+=
name|pop
argument_list|(
name|eights
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
name|n
operator|-
literal|4
condition|)
block|{
name|long
name|twosA
decl_stmt|,
name|twosB
decl_stmt|,
name|foursA
decl_stmt|,
name|eights
decl_stmt|;
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
index|]
operator|&
name|B
index|[
name|i
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|1
index|]
operator|&
name|B
index|[
name|i
operator|+
literal|1
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosA
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|2
index|]
operator|&
name|B
index|[
name|i
operator|+
literal|2
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|3
index|]
operator|&
name|B
index|[
name|i
operator|+
literal|3
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosB
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
block|{
name|long
name|u
init|=
name|twos
operator|^
name|twosA
decl_stmt|;
name|foursA
operator|=
operator|(
name|twos
operator|&
name|twosA
operator|)
operator||
operator|(
name|u
operator|&
name|twosB
operator|)
expr_stmt|;
name|twos
operator|=
name|u
operator|^
name|twosB
expr_stmt|;
block|}
name|eights
operator|=
name|fours
operator|&
name|foursA
expr_stmt|;
name|fours
operator|=
name|fours
operator|^
name|foursA
expr_stmt|;
name|tot8
operator|+=
name|pop
argument_list|(
name|eights
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
name|n
operator|-
literal|2
condition|)
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
index|]
operator|&
name|B
index|[
name|i
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|1
index|]
operator|&
name|B
index|[
name|i
operator|+
literal|1
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|long
name|twosA
init|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
decl_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
name|long
name|foursA
init|=
name|twos
operator|&
name|twosA
decl_stmt|;
name|twos
operator|=
name|twos
operator|^
name|twosA
expr_stmt|;
name|long
name|eights
init|=
name|fours
operator|&
name|foursA
decl_stmt|;
name|fours
operator|=
name|fours
operator|^
name|foursA
expr_stmt|;
name|tot8
operator|+=
name|pop
argument_list|(
name|eights
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|tot
operator|+=
name|pop
argument_list|(
operator|(
name|A
index|[
name|i
index|]
operator|&
name|B
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|tot
operator|+=
operator|(
name|pop
argument_list|(
name|fours
argument_list|)
operator|<<
literal|2
operator|)
operator|+
operator|(
name|pop
argument_list|(
name|twos
argument_list|)
operator|<<
literal|1
operator|)
operator|+
name|pop
argument_list|(
name|ones
argument_list|)
operator|+
operator|(
name|tot8
operator|<<
literal|3
operator|)
expr_stmt|;
return|return
name|tot
return|;
block|}
comment|/** Returns the popcount or cardinality of the union of two sets.     * Neither array is modified.     */
DECL|method|pop_union
specifier|public
specifier|static
name|long
name|pop_union
parameter_list|(
name|long
name|A
index|[]
parameter_list|,
name|long
name|B
index|[]
parameter_list|,
name|int
name|wordOffset
parameter_list|,
name|int
name|numWords
parameter_list|)
block|{
comment|// generated from pop_array via sed 's/A\[\([^]]*\)\]/\(A[\1] \| B[\1]\)/g'
name|int
name|n
init|=
name|wordOffset
operator|+
name|numWords
decl_stmt|;
name|long
name|tot
init|=
literal|0
decl_stmt|,
name|tot8
init|=
literal|0
decl_stmt|;
name|long
name|ones
init|=
literal|0
decl_stmt|,
name|twos
init|=
literal|0
decl_stmt|,
name|fours
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|wordOffset
init|;
name|i
operator|<=
name|n
operator|-
literal|8
condition|;
name|i
operator|+=
literal|8
control|)
block|{
comment|/***  C macro from Hacker's Delight         #define CSA(h,l, a,b,c) \         {unsigned u = a ^ b; unsigned v = c; \         h = (a& b) | (u& v); l = u ^ v;}         ***/
name|long
name|twosA
decl_stmt|,
name|twosB
decl_stmt|,
name|foursA
decl_stmt|,
name|foursB
decl_stmt|,
name|eights
decl_stmt|;
comment|// CSA(twosA, ones, ones, (A[i] | B[i]), (A[i+1] | B[i+1]))
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
index|]
operator||
name|B
index|[
name|i
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|1
index|]
operator||
name|B
index|[
name|i
operator|+
literal|1
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosA
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|// CSA(twosB, ones, ones, (A[i+2] | B[i+2]), (A[i+3] | B[i+3]))
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|2
index|]
operator||
name|B
index|[
name|i
operator|+
literal|2
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|3
index|]
operator||
name|B
index|[
name|i
operator|+
literal|3
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosB
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|//CSA(foursA, twos, twos, twosA, twosB)
block|{
name|long
name|u
init|=
name|twos
operator|^
name|twosA
decl_stmt|;
name|foursA
operator|=
operator|(
name|twos
operator|&
name|twosA
operator|)
operator||
operator|(
name|u
operator|&
name|twosB
operator|)
expr_stmt|;
name|twos
operator|=
name|u
operator|^
name|twosB
expr_stmt|;
block|}
comment|//CSA(twosA, ones, ones, (A[i+4] | B[i+4]), (A[i+5] | B[i+5]))
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|4
index|]
operator||
name|B
index|[
name|i
operator|+
literal|4
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|5
index|]
operator||
name|B
index|[
name|i
operator|+
literal|5
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosA
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|// CSA(twosB, ones, ones, (A[i+6] | B[i+6]), (A[i+7] | B[i+7]))
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|6
index|]
operator||
name|B
index|[
name|i
operator|+
literal|6
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|7
index|]
operator||
name|B
index|[
name|i
operator|+
literal|7
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosB
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|//CSA(foursB, twos, twos, twosA, twosB)
block|{
name|long
name|u
init|=
name|twos
operator|^
name|twosA
decl_stmt|;
name|foursB
operator|=
operator|(
name|twos
operator|&
name|twosA
operator|)
operator||
operator|(
name|u
operator|&
name|twosB
operator|)
expr_stmt|;
name|twos
operator|=
name|u
operator|^
name|twosB
expr_stmt|;
block|}
comment|//CSA(eights, fours, fours, foursA, foursB)
block|{
name|long
name|u
init|=
name|fours
operator|^
name|foursA
decl_stmt|;
name|eights
operator|=
operator|(
name|fours
operator|&
name|foursA
operator|)
operator||
operator|(
name|u
operator|&
name|foursB
operator|)
expr_stmt|;
name|fours
operator|=
name|u
operator|^
name|foursB
expr_stmt|;
block|}
name|tot8
operator|+=
name|pop
argument_list|(
name|eights
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
name|n
operator|-
literal|4
condition|)
block|{
name|long
name|twosA
decl_stmt|,
name|twosB
decl_stmt|,
name|foursA
decl_stmt|,
name|eights
decl_stmt|;
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
index|]
operator||
name|B
index|[
name|i
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|1
index|]
operator||
name|B
index|[
name|i
operator|+
literal|1
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosA
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|2
index|]
operator||
name|B
index|[
name|i
operator|+
literal|2
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|3
index|]
operator||
name|B
index|[
name|i
operator|+
literal|3
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosB
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
block|{
name|long
name|u
init|=
name|twos
operator|^
name|twosA
decl_stmt|;
name|foursA
operator|=
operator|(
name|twos
operator|&
name|twosA
operator|)
operator||
operator|(
name|u
operator|&
name|twosB
operator|)
expr_stmt|;
name|twos
operator|=
name|u
operator|^
name|twosB
expr_stmt|;
block|}
name|eights
operator|=
name|fours
operator|&
name|foursA
expr_stmt|;
name|fours
operator|=
name|fours
operator|^
name|foursA
expr_stmt|;
name|tot8
operator|+=
name|pop
argument_list|(
name|eights
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
name|n
operator|-
literal|2
condition|)
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
index|]
operator||
name|B
index|[
name|i
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|1
index|]
operator||
name|B
index|[
name|i
operator|+
literal|1
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|long
name|twosA
init|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
decl_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
name|long
name|foursA
init|=
name|twos
operator|&
name|twosA
decl_stmt|;
name|twos
operator|=
name|twos
operator|^
name|twosA
expr_stmt|;
name|long
name|eights
init|=
name|fours
operator|&
name|foursA
decl_stmt|;
name|fours
operator|=
name|fours
operator|^
name|foursA
expr_stmt|;
name|tot8
operator|+=
name|pop
argument_list|(
name|eights
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|tot
operator|+=
name|pop
argument_list|(
operator|(
name|A
index|[
name|i
index|]
operator||
name|B
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|tot
operator|+=
operator|(
name|pop
argument_list|(
name|fours
argument_list|)
operator|<<
literal|2
operator|)
operator|+
operator|(
name|pop
argument_list|(
name|twos
argument_list|)
operator|<<
literal|1
operator|)
operator|+
name|pop
argument_list|(
name|ones
argument_list|)
operator|+
operator|(
name|tot8
operator|<<
literal|3
operator|)
expr_stmt|;
return|return
name|tot
return|;
block|}
comment|/** Returns the popcount or cardinality of A& ~B    * Neither array is modified.    */
DECL|method|pop_andnot
specifier|public
specifier|static
name|long
name|pop_andnot
parameter_list|(
name|long
name|A
index|[]
parameter_list|,
name|long
name|B
index|[]
parameter_list|,
name|int
name|wordOffset
parameter_list|,
name|int
name|numWords
parameter_list|)
block|{
comment|// generated from pop_array via sed 's/A\[\([^]]*\)\]/\(A[\1] \& ~B[\1]\)/g'
name|int
name|n
init|=
name|wordOffset
operator|+
name|numWords
decl_stmt|;
name|long
name|tot
init|=
literal|0
decl_stmt|,
name|tot8
init|=
literal|0
decl_stmt|;
name|long
name|ones
init|=
literal|0
decl_stmt|,
name|twos
init|=
literal|0
decl_stmt|,
name|fours
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|wordOffset
init|;
name|i
operator|<=
name|n
operator|-
literal|8
condition|;
name|i
operator|+=
literal|8
control|)
block|{
comment|/***  C macro from Hacker's Delight        #define CSA(h,l, a,b,c) \        {unsigned u = a ^ b; unsigned v = c; \        h = (a& b) | (u& v); l = u ^ v;}        ***/
name|long
name|twosA
decl_stmt|,
name|twosB
decl_stmt|,
name|foursA
decl_stmt|,
name|foursB
decl_stmt|,
name|eights
decl_stmt|;
comment|// CSA(twosA, ones, ones, (A[i]& ~B[i]), (A[i+1]& ~B[i+1]))
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
index|]
operator|&
operator|~
name|B
index|[
name|i
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|1
index|]
operator|&
operator|~
name|B
index|[
name|i
operator|+
literal|1
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosA
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|// CSA(twosB, ones, ones, (A[i+2]& ~B[i+2]), (A[i+3]& ~B[i+3]))
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|2
index|]
operator|&
operator|~
name|B
index|[
name|i
operator|+
literal|2
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|3
index|]
operator|&
operator|~
name|B
index|[
name|i
operator|+
literal|3
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosB
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|//CSA(foursA, twos, twos, twosA, twosB)
block|{
name|long
name|u
init|=
name|twos
operator|^
name|twosA
decl_stmt|;
name|foursA
operator|=
operator|(
name|twos
operator|&
name|twosA
operator|)
operator||
operator|(
name|u
operator|&
name|twosB
operator|)
expr_stmt|;
name|twos
operator|=
name|u
operator|^
name|twosB
expr_stmt|;
block|}
comment|//CSA(twosA, ones, ones, (A[i+4]& ~B[i+4]), (A[i+5]& ~B[i+5]))
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|4
index|]
operator|&
operator|~
name|B
index|[
name|i
operator|+
literal|4
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|5
index|]
operator|&
operator|~
name|B
index|[
name|i
operator|+
literal|5
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosA
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|// CSA(twosB, ones, ones, (A[i+6]& ~B[i+6]), (A[i+7]& ~B[i+7]))
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|6
index|]
operator|&
operator|~
name|B
index|[
name|i
operator|+
literal|6
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|7
index|]
operator|&
operator|~
name|B
index|[
name|i
operator|+
literal|7
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosB
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|//CSA(foursB, twos, twos, twosA, twosB)
block|{
name|long
name|u
init|=
name|twos
operator|^
name|twosA
decl_stmt|;
name|foursB
operator|=
operator|(
name|twos
operator|&
name|twosA
operator|)
operator||
operator|(
name|u
operator|&
name|twosB
operator|)
expr_stmt|;
name|twos
operator|=
name|u
operator|^
name|twosB
expr_stmt|;
block|}
comment|//CSA(eights, fours, fours, foursA, foursB)
block|{
name|long
name|u
init|=
name|fours
operator|^
name|foursA
decl_stmt|;
name|eights
operator|=
operator|(
name|fours
operator|&
name|foursA
operator|)
operator||
operator|(
name|u
operator|&
name|foursB
operator|)
expr_stmt|;
name|fours
operator|=
name|u
operator|^
name|foursB
expr_stmt|;
block|}
name|tot8
operator|+=
name|pop
argument_list|(
name|eights
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
name|n
operator|-
literal|4
condition|)
block|{
name|long
name|twosA
decl_stmt|,
name|twosB
decl_stmt|,
name|foursA
decl_stmt|,
name|eights
decl_stmt|;
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
index|]
operator|&
operator|~
name|B
index|[
name|i
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|1
index|]
operator|&
operator|~
name|B
index|[
name|i
operator|+
literal|1
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosA
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|2
index|]
operator|&
operator|~
name|B
index|[
name|i
operator|+
literal|2
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|3
index|]
operator|&
operator|~
name|B
index|[
name|i
operator|+
literal|3
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosB
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
block|{
name|long
name|u
init|=
name|twos
operator|^
name|twosA
decl_stmt|;
name|foursA
operator|=
operator|(
name|twos
operator|&
name|twosA
operator|)
operator||
operator|(
name|u
operator|&
name|twosB
operator|)
expr_stmt|;
name|twos
operator|=
name|u
operator|^
name|twosB
expr_stmt|;
block|}
name|eights
operator|=
name|fours
operator|&
name|foursA
expr_stmt|;
name|fours
operator|=
name|fours
operator|^
name|foursA
expr_stmt|;
name|tot8
operator|+=
name|pop
argument_list|(
name|eights
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
name|n
operator|-
literal|2
condition|)
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
index|]
operator|&
operator|~
name|B
index|[
name|i
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|1
index|]
operator|&
operator|~
name|B
index|[
name|i
operator|+
literal|1
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|long
name|twosA
init|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
decl_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
name|long
name|foursA
init|=
name|twos
operator|&
name|twosA
decl_stmt|;
name|twos
operator|=
name|twos
operator|^
name|twosA
expr_stmt|;
name|long
name|eights
init|=
name|fours
operator|&
name|foursA
decl_stmt|;
name|fours
operator|=
name|fours
operator|^
name|foursA
expr_stmt|;
name|tot8
operator|+=
name|pop
argument_list|(
name|eights
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|tot
operator|+=
name|pop
argument_list|(
operator|(
name|A
index|[
name|i
index|]
operator|&
operator|~
name|B
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|tot
operator|+=
operator|(
name|pop
argument_list|(
name|fours
argument_list|)
operator|<<
literal|2
operator|)
operator|+
operator|(
name|pop
argument_list|(
name|twos
argument_list|)
operator|<<
literal|1
operator|)
operator|+
name|pop
argument_list|(
name|ones
argument_list|)
operator|+
operator|(
name|tot8
operator|<<
literal|3
operator|)
expr_stmt|;
return|return
name|tot
return|;
block|}
DECL|method|pop_xor
specifier|public
specifier|static
name|long
name|pop_xor
parameter_list|(
name|long
name|A
index|[]
parameter_list|,
name|long
name|B
index|[]
parameter_list|,
name|int
name|wordOffset
parameter_list|,
name|int
name|numWords
parameter_list|)
block|{
name|int
name|n
init|=
name|wordOffset
operator|+
name|numWords
decl_stmt|;
name|long
name|tot
init|=
literal|0
decl_stmt|,
name|tot8
init|=
literal|0
decl_stmt|;
name|long
name|ones
init|=
literal|0
decl_stmt|,
name|twos
init|=
literal|0
decl_stmt|,
name|fours
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|wordOffset
init|;
name|i
operator|<=
name|n
operator|-
literal|8
condition|;
name|i
operator|+=
literal|8
control|)
block|{
comment|/***  C macro from Hacker's Delight        #define CSA(h,l, a,b,c) \        {unsigned u = a ^ b; unsigned v = c; \        h = (a& b) | (u& v); l = u ^ v;}        ***/
name|long
name|twosA
decl_stmt|,
name|twosB
decl_stmt|,
name|foursA
decl_stmt|,
name|foursB
decl_stmt|,
name|eights
decl_stmt|;
comment|// CSA(twosA, ones, ones, (A[i] ^ B[i]), (A[i+1] ^ B[i+1]))
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
index|]
operator|^
name|B
index|[
name|i
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|1
index|]
operator|^
name|B
index|[
name|i
operator|+
literal|1
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosA
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|// CSA(twosB, ones, ones, (A[i+2] ^ B[i+2]), (A[i+3] ^ B[i+3]))
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|2
index|]
operator|^
name|B
index|[
name|i
operator|+
literal|2
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|3
index|]
operator|^
name|B
index|[
name|i
operator|+
literal|3
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosB
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|//CSA(foursA, twos, twos, twosA, twosB)
block|{
name|long
name|u
init|=
name|twos
operator|^
name|twosA
decl_stmt|;
name|foursA
operator|=
operator|(
name|twos
operator|&
name|twosA
operator|)
operator||
operator|(
name|u
operator|&
name|twosB
operator|)
expr_stmt|;
name|twos
operator|=
name|u
operator|^
name|twosB
expr_stmt|;
block|}
comment|//CSA(twosA, ones, ones, (A[i+4] ^ B[i+4]), (A[i+5] ^ B[i+5]))
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|4
index|]
operator|^
name|B
index|[
name|i
operator|+
literal|4
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|5
index|]
operator|^
name|B
index|[
name|i
operator|+
literal|5
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosA
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|// CSA(twosB, ones, ones, (A[i+6] ^ B[i+6]), (A[i+7] ^ B[i+7]))
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|6
index|]
operator|^
name|B
index|[
name|i
operator|+
literal|6
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|7
index|]
operator|^
name|B
index|[
name|i
operator|+
literal|7
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosB
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
comment|//CSA(foursB, twos, twos, twosA, twosB)
block|{
name|long
name|u
init|=
name|twos
operator|^
name|twosA
decl_stmt|;
name|foursB
operator|=
operator|(
name|twos
operator|&
name|twosA
operator|)
operator||
operator|(
name|u
operator|&
name|twosB
operator|)
expr_stmt|;
name|twos
operator|=
name|u
operator|^
name|twosB
expr_stmt|;
block|}
comment|//CSA(eights, fours, fours, foursA, foursB)
block|{
name|long
name|u
init|=
name|fours
operator|^
name|foursA
decl_stmt|;
name|eights
operator|=
operator|(
name|fours
operator|&
name|foursA
operator|)
operator||
operator|(
name|u
operator|&
name|foursB
operator|)
expr_stmt|;
name|fours
operator|=
name|u
operator|^
name|foursB
expr_stmt|;
block|}
name|tot8
operator|+=
name|pop
argument_list|(
name|eights
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
name|n
operator|-
literal|4
condition|)
block|{
name|long
name|twosA
decl_stmt|,
name|twosB
decl_stmt|,
name|foursA
decl_stmt|,
name|eights
decl_stmt|;
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
index|]
operator|^
name|B
index|[
name|i
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|1
index|]
operator|^
name|B
index|[
name|i
operator|+
literal|1
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosA
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|2
index|]
operator|^
name|B
index|[
name|i
operator|+
literal|2
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|3
index|]
operator|^
name|B
index|[
name|i
operator|+
literal|3
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|twosB
operator|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
expr_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
block|}
block|{
name|long
name|u
init|=
name|twos
operator|^
name|twosA
decl_stmt|;
name|foursA
operator|=
operator|(
name|twos
operator|&
name|twosA
operator|)
operator||
operator|(
name|u
operator|&
name|twosB
operator|)
expr_stmt|;
name|twos
operator|=
name|u
operator|^
name|twosB
expr_stmt|;
block|}
name|eights
operator|=
name|fours
operator|&
name|foursA
expr_stmt|;
name|fours
operator|=
name|fours
operator|^
name|foursA
expr_stmt|;
name|tot8
operator|+=
name|pop
argument_list|(
name|eights
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
name|n
operator|-
literal|2
condition|)
block|{
name|long
name|b
init|=
operator|(
name|A
index|[
name|i
index|]
operator|^
name|B
index|[
name|i
index|]
operator|)
decl_stmt|,
name|c
init|=
operator|(
name|A
index|[
name|i
operator|+
literal|1
index|]
operator|^
name|B
index|[
name|i
operator|+
literal|1
index|]
operator|)
decl_stmt|;
name|long
name|u
init|=
name|ones
operator|^
name|b
decl_stmt|;
name|long
name|twosA
init|=
operator|(
name|ones
operator|&
name|b
operator|)
operator||
operator|(
name|u
operator|&
name|c
operator|)
decl_stmt|;
name|ones
operator|=
name|u
operator|^
name|c
expr_stmt|;
name|long
name|foursA
init|=
name|twos
operator|&
name|twosA
decl_stmt|;
name|twos
operator|=
name|twos
operator|^
name|twosA
expr_stmt|;
name|long
name|eights
init|=
name|fours
operator|&
name|foursA
decl_stmt|;
name|fours
operator|=
name|fours
operator|^
name|foursA
expr_stmt|;
name|tot8
operator|+=
name|pop
argument_list|(
name|eights
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|tot
operator|+=
name|pop
argument_list|(
operator|(
name|A
index|[
name|i
index|]
operator|^
name|B
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|tot
operator|+=
operator|(
name|pop
argument_list|(
name|fours
argument_list|)
operator|<<
literal|2
operator|)
operator|+
operator|(
name|pop
argument_list|(
name|twos
argument_list|)
operator|<<
literal|1
operator|)
operator|+
name|pop
argument_list|(
name|ones
argument_list|)
operator|+
operator|(
name|tot8
operator|<<
literal|3
operator|)
expr_stmt|;
return|return
name|tot
return|;
block|}
comment|/* python code to generate ntzTable   def ntz(val):     if val==0: return 8     i=0     while (val&0x01)==0:       i = i+1       val>>= 1     return i   print ','.join([ str(ntz(i)) for i in range(256) ])   ***/
comment|/** table of number of trailing zeros in a byte */
DECL|field|ntzTable
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|ntzTable
init|=
block|{
literal|8
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|7
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
comment|/** Returns number of trailing zeros in the 64 bit long value. */
DECL|method|ntz
specifier|public
specifier|static
name|int
name|ntz
parameter_list|(
name|long
name|val
parameter_list|)
block|{
comment|// A full binary search to determine the low byte was slower than
comment|// a linear search for nextSetBit().  This is most likely because
comment|// the implementation of nextSetBit() shifts bits to the right, increasing
comment|// the probability that the first non-zero byte is in the rhs.
comment|//
comment|// This implementation does a single binary search at the top level only
comment|// so that all other bit shifting can be done on ints instead of longs to
comment|// remain friendly to 32 bit architectures.  In addition, the case of a
comment|// non-zero first byte is checked for first because it is the most common
comment|// in dense bit arrays.
name|int
name|lower
init|=
operator|(
name|int
operator|)
name|val
decl_stmt|;
name|int
name|lowByte
init|=
name|lower
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|lowByte
operator|!=
literal|0
condition|)
return|return
name|ntzTable
index|[
name|lowByte
index|]
return|;
if|if
condition|(
name|lower
operator|!=
literal|0
condition|)
block|{
name|lowByte
operator|=
operator|(
name|lower
operator|>>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|lowByte
operator|!=
literal|0
condition|)
return|return
name|ntzTable
index|[
name|lowByte
index|]
operator|+
literal|8
return|;
name|lowByte
operator|=
operator|(
name|lower
operator|>>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|lowByte
operator|!=
literal|0
condition|)
return|return
name|ntzTable
index|[
name|lowByte
index|]
operator|+
literal|16
return|;
comment|// no need to mask off low byte for the last byte in the 32 bit word
comment|// no need to check for zero on the last byte either.
return|return
name|ntzTable
index|[
name|lower
operator|>>>
literal|24
index|]
operator|+
literal|24
return|;
block|}
else|else
block|{
comment|// grab upper 32 bits
name|int
name|upper
init|=
call|(
name|int
call|)
argument_list|(
name|val
operator|>>
literal|32
argument_list|)
decl_stmt|;
name|lowByte
operator|=
name|upper
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|lowByte
operator|!=
literal|0
condition|)
return|return
name|ntzTable
index|[
name|lowByte
index|]
operator|+
literal|32
return|;
name|lowByte
operator|=
operator|(
name|upper
operator|>>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|lowByte
operator|!=
literal|0
condition|)
return|return
name|ntzTable
index|[
name|lowByte
index|]
operator|+
literal|40
return|;
name|lowByte
operator|=
operator|(
name|upper
operator|>>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|lowByte
operator|!=
literal|0
condition|)
return|return
name|ntzTable
index|[
name|lowByte
index|]
operator|+
literal|48
return|;
comment|// no need to mask off low byte for the last byte in the 32 bit word
comment|// no need to check for zero on the last byte either.
return|return
name|ntzTable
index|[
name|upper
operator|>>>
literal|24
index|]
operator|+
literal|56
return|;
block|}
block|}
comment|/** returns 0 based index of first set bit    * (only works for x!=0)    *<br/> This is an alternate implementation of ntz()    */
DECL|method|ntz2
specifier|public
specifier|static
name|int
name|ntz2
parameter_list|(
name|long
name|x
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|y
init|=
operator|(
name|int
operator|)
name|x
decl_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
block|{
name|n
operator|+=
literal|32
expr_stmt|;
name|y
operator|=
call|(
name|int
call|)
argument_list|(
name|x
operator|>>>
literal|32
argument_list|)
expr_stmt|;
block|}
comment|// the only 64 bit shift necessary
if|if
condition|(
operator|(
name|y
operator|&
literal|0x0000FFFF
operator|)
operator|==
literal|0
condition|)
block|{
name|n
operator|+=
literal|16
expr_stmt|;
name|y
operator|>>>=
literal|16
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|y
operator|&
literal|0x000000FF
operator|)
operator|==
literal|0
condition|)
block|{
name|n
operator|+=
literal|8
expr_stmt|;
name|y
operator|>>>=
literal|8
expr_stmt|;
block|}
return|return
operator|(
name|ntzTable
index|[
name|y
operator|&
literal|0xff
index|]
operator|)
operator|+
name|n
return|;
block|}
comment|/** returns 0 based index of first set bit    *<br/> This is an alternate implementation of ntz()    */
DECL|method|ntz3
specifier|public
specifier|static
name|int
name|ntz3
parameter_list|(
name|long
name|x
parameter_list|)
block|{
comment|// another implementation taken from Hackers Delight, extended to 64 bits
comment|// and converted to Java.
comment|// Many 32 bit ntz algorithms are at http://www.hackersdelight.org/HDcode/ntz.cc
name|int
name|n
init|=
literal|1
decl_stmt|;
comment|// do the first step as a long, all others as ints.
name|int
name|y
init|=
operator|(
name|int
operator|)
name|x
decl_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
block|{
name|n
operator|+=
literal|32
expr_stmt|;
name|y
operator|=
call|(
name|int
call|)
argument_list|(
name|x
operator|>>>
literal|32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|y
operator|&
literal|0x0000FFFF
operator|)
operator|==
literal|0
condition|)
block|{
name|n
operator|+=
literal|16
expr_stmt|;
name|y
operator|>>>=
literal|16
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|y
operator|&
literal|0x000000FF
operator|)
operator|==
literal|0
condition|)
block|{
name|n
operator|+=
literal|8
expr_stmt|;
name|y
operator|>>>=
literal|8
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|y
operator|&
literal|0x0000000F
operator|)
operator|==
literal|0
condition|)
block|{
name|n
operator|+=
literal|4
expr_stmt|;
name|y
operator|>>>=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|y
operator|&
literal|0x00000003
operator|)
operator|==
literal|0
condition|)
block|{
name|n
operator|+=
literal|2
expr_stmt|;
name|y
operator|>>>=
literal|2
expr_stmt|;
block|}
return|return
name|n
operator|-
operator|(
name|y
operator|&
literal|1
operator|)
return|;
block|}
comment|/** returns true if v is a power of two or zero*/
DECL|method|isPowerOfTwo
specifier|public
specifier|static
name|boolean
name|isPowerOfTwo
parameter_list|(
name|int
name|v
parameter_list|)
block|{
return|return
operator|(
operator|(
name|v
operator|&
operator|(
name|v
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
return|;
block|}
comment|/** returns true if v is a power of two or zero*/
DECL|method|isPowerOfTwo
specifier|public
specifier|static
name|boolean
name|isPowerOfTwo
parameter_list|(
name|long
name|v
parameter_list|)
block|{
return|return
operator|(
operator|(
name|v
operator|&
operator|(
name|v
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
return|;
block|}
comment|/** returns the next highest power of two, or the current value if it's already a power of two or zero*/
DECL|method|nextHighestPowerOfTwo
specifier|public
specifier|static
name|int
name|nextHighestPowerOfTwo
parameter_list|(
name|int
name|v
parameter_list|)
block|{
name|v
operator|--
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|1
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|2
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|4
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|8
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|16
expr_stmt|;
name|v
operator|++
expr_stmt|;
return|return
name|v
return|;
block|}
comment|/** returns the next highest power of two, or the current value if it's already a power of two or zero*/
DECL|method|nextHighestPowerOfTwo
specifier|public
specifier|static
name|long
name|nextHighestPowerOfTwo
parameter_list|(
name|long
name|v
parameter_list|)
block|{
name|v
operator|--
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|1
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|2
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|4
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|8
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|16
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|32
expr_stmt|;
name|v
operator|++
expr_stmt|;
return|return
name|v
return|;
block|}
block|}
end_class
end_unit
