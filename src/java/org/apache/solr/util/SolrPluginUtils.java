begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.util
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|ParseException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|QueryParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
operator|.
name|Occur
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LogByteSizeMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocumentList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|AppendedSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|DefaultSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|StrUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|highlight
operator|.
name|SolrHighlighter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|response
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|DocumentBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import
begin_comment
comment|/**  *<p>Utilities that may be of use to RequestHandlers.</p>  *  *<p>  * Many of these functions have code that was stolen/mutated from  * StandardRequestHandler.  *</p>  *  *<p>:TODO: refactor StandardRequestHandler to use these utilities</p>  *  *<p>:TODO: Many "standard" functionality methods are not cognisant of  * default parameter settings.    */
end_comment
begin_class
DECL|class|SolrPluginUtils
specifier|public
class|class
name|SolrPluginUtils
block|{
DECL|field|log
specifier|final
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SolrPluginUtils
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Set defaults on a SolrQueryRequest.    *    * RequestHandlers can use this method to ensure their defaults are    * visible to other components such as the response writer    */
DECL|method|setDefaults
specifier|public
specifier|static
name|void
name|setDefaults
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrParams
name|defaults
parameter_list|)
block|{
name|setDefaults
argument_list|(
name|req
argument_list|,
name|defaults
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set default-ish params on a SolrQueryRequest.    *    * RequestHandlers can use this method to ensure their defaults and    * overrides are visible to other components such as the response writer    *    * @param req The request whose params we are interested i    * @param defaults values to be used if no values are specified in the request params    * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.    * @param invariants values which will be used instead of any request, or default values, regardless of context.    */
DECL|method|setDefaults
specifier|public
specifier|static
name|void
name|setDefaults
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrParams
name|defaults
parameter_list|,
name|SolrParams
name|appends
parameter_list|,
name|SolrParams
name|invariants
parameter_list|)
block|{
name|SolrParams
name|p
init|=
name|req
operator|.
name|getParams
argument_list|()
decl_stmt|;
if|if
condition|(
name|defaults
operator|!=
literal|null
condition|)
block|{
name|p
operator|=
operator|new
name|DefaultSolrParams
argument_list|(
name|p
argument_list|,
name|defaults
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|appends
operator|!=
literal|null
condition|)
block|{
name|p
operator|=
operator|new
name|AppendedSolrParams
argument_list|(
name|p
argument_list|,
name|appends
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|invariants
operator|!=
literal|null
condition|)
block|{
name|p
operator|=
operator|new
name|DefaultSolrParams
argument_list|(
name|invariants
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|req
operator|.
name|setParams
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/**    * standard param for field list    *    * @deprecated Use org.apache.solr.common.params.CommonParams.FL.    */
annotation|@
name|Deprecated
DECL|field|FL
specifier|public
specifier|static
name|String
name|FL
init|=
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
operator|.
name|FL
decl_stmt|;
comment|/**    * SolrIndexSearch.numDocs(Query,Query) freaks out if the filtering    * query is null, so we use this workarround.    */
DECL|method|numDocs
specifier|public
specifier|static
name|int
name|numDocs
parameter_list|(
name|SolrIndexSearcher
name|s
parameter_list|,
name|Query
name|q
parameter_list|,
name|Query
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|(
literal|null
operator|==
name|f
operator|)
condition|?
name|s
operator|.
name|getDocSet
argument_list|(
name|q
argument_list|)
operator|.
name|size
argument_list|()
else|:
name|s
operator|.
name|numDocs
argument_list|(
name|q
argument_list|,
name|f
argument_list|)
return|;
block|}
comment|/**    * Returns the param, or the default if it's empty or not specified.    * @deprecated use SolrParam.get(String,String)    */
DECL|method|getParam
specifier|public
specifier|static
name|String
name|getParam
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
name|param
parameter_list|,
name|String
name|def
parameter_list|)
block|{
name|String
name|v
init|=
name|req
operator|.
name|getParam
argument_list|(
name|param
argument_list|)
decl_stmt|;
comment|// Note: parameters passed but given only white-space value are
comment|// considered equivalent to passing nothing for that parameter.
if|if
condition|(
literal|null
operator|==
name|v
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|v
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|def
return|;
block|}
return|return
name|v
return|;
block|}
comment|/**    * Treats the param value as a Number, returns the default if nothing is    * there or if it's not a number.    * @deprecated use SolrParam.getFloat(String,float)    */
DECL|method|getNumberParam
specifier|public
specifier|static
name|Number
name|getNumberParam
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
name|param
parameter_list|,
name|Number
name|def
parameter_list|)
block|{
name|Number
name|r
init|=
name|def
decl_stmt|;
name|String
name|v
init|=
name|req
operator|.
name|getParam
argument_list|(
name|param
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|v
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|v
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|r
return|;
block|}
try|try
block|{
name|r
operator|=
operator|new
name|Float
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
comment|/* :NOOP" */
block|}
return|return
name|r
return|;
block|}
comment|/**    * Treats parameter value as a boolean.  The string 'false' is false;     * any other non-empty string is true.    * @deprecated use SolrParam.getBool(String,boolean)    */
DECL|method|getBooleanParam
specifier|public
specifier|static
name|boolean
name|getBooleanParam
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
name|param
parameter_list|,
name|boolean
name|def
parameter_list|)
block|{
name|String
name|v
init|=
name|req
operator|.
name|getParam
argument_list|(
name|param
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|v
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|v
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|def
return|;
block|}
return|return
operator|!
literal|"false"
operator|.
name|equals
argument_list|(
name|v
operator|.
name|trim
argument_list|()
argument_list|)
return|;
block|}
DECL|field|splitList
specifier|private
specifier|final
specifier|static
name|Pattern
name|splitList
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|",| "
argument_list|)
decl_stmt|;
comment|/** Split a value that may contain a comma, space of bar separated list. */
DECL|method|split
specifier|public
specifier|static
name|String
index|[]
name|split
parameter_list|(
name|String
name|value
parameter_list|)
block|{
return|return
name|splitList
operator|.
name|split
argument_list|(
name|value
operator|.
name|trim
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Assumes the standard query param of "fl" to specify the return fields    * @see #setReturnFields(String,SolrQueryResponse)    */
DECL|method|setReturnFields
specifier|public
specifier|static
name|int
name|setReturnFields
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|res
parameter_list|)
block|{
return|return
name|setReturnFields
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
operator|.
name|FL
argument_list|)
argument_list|,
name|res
argument_list|)
return|;
block|}
comment|/**    * Given a space seperated list of field names, sets the field list on the    * SolrQueryResponse.    *    * @return bitfield of SolrIndexSearcher flags that need to be set    */
DECL|method|setReturnFields
specifier|public
specifier|static
name|int
name|setReturnFields
parameter_list|(
name|String
name|fl
parameter_list|,
name|SolrQueryResponse
name|res
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fl
operator|!=
literal|null
condition|)
block|{
comment|// TODO - this could become more efficient if widely used.
comment|// TODO - should field order be maintained?
name|String
index|[]
name|flst
init|=
name|split
argument_list|(
name|fl
argument_list|)
decl_stmt|;
if|if
condition|(
name|flst
operator|.
name|length
operator|>
literal|0
operator|&&
operator|!
operator|(
name|flst
operator|.
name|length
operator|==
literal|1
operator|&&
name|flst
index|[
literal|0
index|]
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fname
range|:
name|flst
control|)
block|{
if|if
condition|(
literal|"score"
operator|.
name|equalsIgnoreCase
argument_list|(
name|fname
argument_list|)
condition|)
name|flags
operator||=
name|SolrIndexSearcher
operator|.
name|GET_SCORES
expr_stmt|;
name|set
operator|.
name|add
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
name|res
operator|.
name|setReturnFields
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|flags
return|;
block|}
comment|/**    * Pre-fetch documents into the index searcher's document cache.    *    * This is an entirely optional step which you might want to perform for    * the following reasons:    *    *<ul>    *<li>Locates the document-retrieval costs in one spot, which helps    *     detailed performance measurement</li>    *       *<li>Determines a priori what fields will be needed to be fetched by    *     various subtasks, like response writing and highlighting.  This    *     minimizes the chance that many needed fields will be loaded lazily.    *     (it is more efficient to load all the field we require normally).</li>    *</ul>    *    * If lazy field loading is disabled, this method does nothing.    */
DECL|method|optimizePreFetchDocs
specifier|public
specifier|static
name|void
name|optimizePreFetchDocs
parameter_list|(
name|DocList
name|docs
parameter_list|,
name|Query
name|query
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|res
parameter_list|)
throws|throws
name|IOException
block|{
name|SolrIndexSearcher
name|searcher
init|=
name|req
operator|.
name|getSearcher
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|searcher
operator|.
name|enableLazyFieldLoading
condition|)
block|{
comment|// nothing to do
return|return;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|fieldFilter
init|=
literal|null
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|returnFields
init|=
name|res
operator|.
name|getReturnFields
argument_list|()
decl_stmt|;
if|if
condition|(
name|returnFields
operator|!=
literal|null
condition|)
block|{
comment|// copy return fields list
name|fieldFilter
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|returnFields
argument_list|)
expr_stmt|;
comment|// add highlight fields
name|SolrHighlighter
name|highligher
init|=
name|req
operator|.
name|getCore
argument_list|()
operator|.
name|getHighlighter
argument_list|()
decl_stmt|;
if|if
condition|(
name|highligher
operator|.
name|isHighlightingEnabled
argument_list|(
name|req
operator|.
name|getParams
argument_list|()
argument_list|)
condition|)
block|{
for|for
control|(
name|String
name|field
range|:
name|highligher
operator|.
name|getHighlightFields
argument_list|(
name|query
argument_list|,
name|req
argument_list|,
literal|null
argument_list|)
control|)
name|fieldFilter
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
comment|// fetch unique key if one exists.
name|SchemaField
name|keyField
init|=
name|req
operator|.
name|getSearcher
argument_list|()
operator|.
name|getSchema
argument_list|()
operator|.
name|getUniqueKeyField
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|keyField
condition|)
name|fieldFilter
operator|.
name|add
argument_list|(
name|keyField
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// get documents
name|DocIterator
name|iter
init|=
name|docs
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|searcher
operator|.
name|doc
argument_list|(
name|iter
operator|.
name|nextDoc
argument_list|()
argument_list|,
name|fieldFilter
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    *<p>    * Returns a NamedList containing many "standard" pieces of debugging    * information.    *</p>    *    *<ul>    *<li>rawquerystring - the 'q' param exactly as specified by the client    *</li>    *<li>querystring - the 'q' param after any preprocessing done by the plugin    *</li>    *<li>parsedquery - the main query executed formated by the Solr    *     QueryParsing utils class (which knows about field types)    *</li>    *<li>parsedquery_toString - the main query executed formated by it's    *     own toString method (in case it has internal state Solr    *     doesn't know about)    *</li>    *<li>expain - the list of score explanations for each document in    *     results against query.    *</li>    *<li>otherQuery - the query string specified in 'explainOther' query param.    *</li>    *<li>explainOther - the list of score explanations for each document in    *     results against 'otherQuery'    *</li>    *</ul>    *    * @param req the request we are dealing with    * @param userQuery the users query as a string, after any basic    *                  preprocessing has been done    * @param query the query built from the userQuery    *              (and perhaps other clauses) that identifies the main    *              result set of the response.    * @param results the main result set of the response    * @deprecated Use doStandardDebug(SolrQueryRequest,String,Query,DocList) with setDefaults    */
DECL|method|doStandardDebug
specifier|public
specifier|static
name|NamedList
name|doStandardDebug
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
name|userQuery
parameter_list|,
name|Query
name|query
parameter_list|,
name|DocList
name|results
parameter_list|,
name|CommonParams
name|params
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|debug
init|=
name|getParam
argument_list|(
name|req
argument_list|,
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
operator|.
name|DEBUG_QUERY
argument_list|,
name|params
operator|.
name|debugQuery
argument_list|)
decl_stmt|;
name|NamedList
name|dbg
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|debug
operator|!=
literal|null
condition|)
block|{
name|dbg
operator|=
operator|new
name|SimpleOrderedMap
argument_list|()
expr_stmt|;
comment|/* userQuery may have been pre-processes .. expose that */
name|dbg
operator|.
name|add
argument_list|(
literal|"rawquerystring"
argument_list|,
name|req
operator|.
name|getQueryString
argument_list|()
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"querystring"
argument_list|,
name|userQuery
argument_list|)
expr_stmt|;
comment|/* QueryParsing.toString isn't perfect, use it to see converted        * values, use regular toString to see any attributes of the        * underlying Query it may have missed.        */
name|dbg
operator|.
name|add
argument_list|(
literal|"parsedquery"
argument_list|,
name|QueryParsing
operator|.
name|toString
argument_list|(
name|query
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"parsedquery_toString"
argument_list|,
name|query
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"explain"
argument_list|,
name|getExplainList
argument_list|(
name|query
argument_list|,
name|results
argument_list|,
name|req
operator|.
name|getSearcher
argument_list|()
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|otherQueryS
init|=
name|req
operator|.
name|getParam
argument_list|(
literal|"explainOther"
argument_list|)
decl_stmt|;
if|if
condition|(
name|otherQueryS
operator|!=
literal|null
operator|&&
name|otherQueryS
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|DocList
name|otherResults
init|=
name|doSimpleQuery
argument_list|(
name|otherQueryS
argument_list|,
name|req
operator|.
name|getSearcher
argument_list|()
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"otherQuery"
argument_list|,
name|otherQueryS
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"explainOther"
argument_list|,
name|getExplainList
argument_list|(
name|query
argument_list|,
name|otherResults
argument_list|,
name|req
operator|.
name|getSearcher
argument_list|()
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dbg
return|;
block|}
comment|/**    *<p>    * Returns a NamedList containing many "standard" pieces of debugging    * information.    *</p>    *    *<ul>    *<li>rawquerystring - the 'q' param exactly as specified by the client    *</li>    *<li>querystring - the 'q' param after any preprocessing done by the plugin    *</li>    *<li>parsedquery - the main query executed formated by the Solr    *     QueryParsing utils class (which knows about field types)    *</li>    *<li>parsedquery_toString - the main query executed formated by it's    *     own toString method (in case it has internal state Solr    *     doesn't know about)    *</li>    *<li>expain - the list of score explanations for each document in    *     results against query.    *</li>    *<li>otherQuery - the query string specified in 'explainOther' query param.    *</li>    *<li>explainOther - the list of score explanations for each document in    *     results against 'otherQuery'    *</li>    *</ul>    *    * @param req the request we are dealing with    * @param userQuery the users query as a string, after any basic    *                  preprocessing has been done    * @param query the query built from the userQuery    *              (and perhaps other clauses) that identifies the main    *              result set of the response.    * @param results the main result set of the response    */
DECL|method|doStandardDebug
specifier|public
specifier|static
name|NamedList
name|doStandardDebug
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
name|userQuery
parameter_list|,
name|Query
name|query
parameter_list|,
name|DocList
name|results
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|debug
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
operator|.
name|DEBUG_QUERY
argument_list|)
decl_stmt|;
name|NamedList
name|dbg
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|debug
operator|!=
literal|null
condition|)
block|{
name|dbg
operator|=
operator|new
name|SimpleOrderedMap
argument_list|()
expr_stmt|;
comment|/* userQuery may have been pre-processes .. expose that */
name|dbg
operator|.
name|add
argument_list|(
literal|"rawquerystring"
argument_list|,
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
operator|.
name|Q
argument_list|)
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"querystring"
argument_list|,
name|userQuery
argument_list|)
expr_stmt|;
comment|/* QueryParsing.toString isn't perfect, use it to see converted        * values, use regular toString to see any attributes of the        * underlying Query it may have missed.        */
name|dbg
operator|.
name|add
argument_list|(
literal|"parsedquery"
argument_list|,
name|QueryParsing
operator|.
name|toString
argument_list|(
name|query
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"parsedquery_toString"
argument_list|,
name|query
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"explain"
argument_list|,
name|getExplainList
argument_list|(
name|query
argument_list|,
name|results
argument_list|,
name|req
operator|.
name|getSearcher
argument_list|()
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|otherQueryS
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
operator|.
name|EXPLAIN_OTHER
argument_list|)
decl_stmt|;
if|if
condition|(
name|otherQueryS
operator|!=
literal|null
operator|&&
name|otherQueryS
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|DocList
name|otherResults
init|=
name|doSimpleQuery
argument_list|(
name|otherQueryS
argument_list|,
name|req
operator|.
name|getSearcher
argument_list|()
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"otherQuery"
argument_list|,
name|otherQueryS
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"explainOther"
argument_list|,
name|getExplainList
argument_list|(
name|query
argument_list|,
name|otherResults
argument_list|,
name|req
operator|.
name|getSearcher
argument_list|()
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dbg
return|;
block|}
comment|/**    * Generates an list of Explanations for each item in a list of docs.    *    * @param query The Query you want explanations in the context of    * @param docs The Documents you want explained relative that query    */
DECL|method|getExplainList
specifier|public
specifier|static
name|NamedList
name|getExplainList
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocList
name|docs
parameter_list|,
name|SolrIndexSearcher
name|searcher
parameter_list|,
name|IndexSchema
name|schema
parameter_list|)
throws|throws
name|IOException
block|{
name|NamedList
name|explainList
init|=
operator|new
name|SimpleOrderedMap
argument_list|()
decl_stmt|;
name|DocIterator
name|iterator
init|=
name|docs
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|id
init|=
name|iterator
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
name|Explanation
name|explain
init|=
name|searcher
operator|.
name|explain
argument_list|(
name|query
argument_list|,
name|id
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
name|searcher
operator|.
name|doc
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|String
name|strid
init|=
name|schema
operator|.
name|printableUniqueKey
argument_list|(
name|doc
argument_list|)
decl_stmt|;
comment|// String docname = "";
comment|// if (strid != null) docname="id="+strid+",";
comment|// docname = docname + "internal_docid="+id;
name|explainList
operator|.
name|add
argument_list|(
name|strid
argument_list|,
literal|"\n"
operator|+
name|explain
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|explainList
return|;
block|}
comment|/**    * Executes a basic query in lucene syntax    */
DECL|method|doSimpleQuery
specifier|public
specifier|static
name|DocList
name|doSimpleQuery
parameter_list|(
name|String
name|sreq
parameter_list|,
name|SolrIndexSearcher
name|searcher
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|limit
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|commands
init|=
name|StrUtils
operator|.
name|splitSmart
argument_list|(
name|sreq
argument_list|,
literal|';'
argument_list|)
decl_stmt|;
name|String
name|qs
init|=
name|commands
operator|.
name|size
argument_list|()
operator|>=
literal|1
condition|?
name|commands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
else|:
literal|""
decl_stmt|;
name|Query
name|query
init|=
name|QueryParsing
operator|.
name|parseQuery
argument_list|(
name|qs
argument_list|,
name|schema
argument_list|)
decl_stmt|;
comment|// If the first non-query, non-filter command is a simple sort on an indexed field, then
comment|// we can use the Lucene sort ability.
name|Sort
name|sort
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|commands
operator|.
name|size
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|sort
operator|=
name|QueryParsing
operator|.
name|parseSort
argument_list|(
name|commands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|schema
argument_list|)
expr_stmt|;
block|}
name|DocList
name|results
init|=
name|searcher
operator|.
name|getDocList
argument_list|(
name|query
argument_list|,
operator|(
name|DocSet
operator|)
literal|null
argument_list|,
name|sort
argument_list|,
name|start
argument_list|,
name|limit
argument_list|)
decl_stmt|;
return|return
name|results
return|;
block|}
comment|/**    * Given a string containing fieldNames and boost info,    * converts it to a Map from field name to boost info.    *    *<p>    * Doesn't care if boost info is negative, you're on your own.    *</p>    *<p>    * Doesn't care if boost info is missing, again: you're on your own.    *</p>    *    * @param in a String like "fieldOne^2.3 fieldTwo fieldThree^-0.4"    * @return Map of fieldOne =&gt; 2.3, fieldTwo =&gt; null, fieldThree =&gt; -0.4    */
DECL|method|parseFieldBoosts
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|parseFieldBoosts
parameter_list|(
name|String
name|in
parameter_list|)
block|{
return|return
name|parseFieldBoosts
argument_list|(
operator|new
name|String
index|[]
block|{
name|in
block|}
argument_list|)
return|;
block|}
comment|/**    * Like<code>parseFieldBoosts(String)</code>, but parses all the strings    * in the provided array (which may be null).    *    * @param fieldLists an array of Strings eg.<code>{"fieldOne^2.3", "fieldTwo", fieldThree^-0.4}</code>    * @return Map of fieldOne =&gt; 2.3, fieldTwo =&gt; null, fieldThree =&gt; -0.4    */
DECL|method|parseFieldBoosts
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|parseFieldBoosts
parameter_list|(
name|String
index|[]
name|fieldLists
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|fieldLists
operator|||
literal|0
operator|==
name|fieldLists
operator|.
name|length
condition|)
block|{
return|return
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
argument_list|()
return|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|out
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
argument_list|(
literal|7
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|in
range|:
name|fieldLists
control|)
block|{
if|if
condition|(
literal|null
operator|==
name|in
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|in
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
continue|continue;
name|String
index|[]
name|bb
init|=
name|in
operator|.
name|trim
argument_list|()
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|bb
control|)
block|{
name|String
index|[]
name|bbb
init|=
name|s
operator|.
name|split
argument_list|(
literal|"\\^"
argument_list|)
decl_stmt|;
name|out
operator|.
name|put
argument_list|(
name|bbb
index|[
literal|0
index|]
argument_list|,
literal|1
operator|==
name|bbb
operator|.
name|length
condition|?
literal|null
else|:
name|Float
operator|.
name|valueOf
argument_list|(
name|bbb
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|out
return|;
block|}
comment|/**    * Given a string containing functions with optional boosts, returns    * an array of Queries representing those functions with the specified    * boosts.    *<p>    * NOTE: intra-function whitespace is not allowed.    *</p>    * @see #parseFieldBoosts    * @deprecated    */
DECL|method|parseFuncs
specifier|public
specifier|static
name|List
argument_list|<
name|Query
argument_list|>
name|parseFuncs
parameter_list|(
name|IndexSchema
name|s
parameter_list|,
name|String
name|in
parameter_list|)
throws|throws
name|ParseException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|ff
init|=
name|parseFieldBoosts
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Query
argument_list|>
name|funcs
init|=
operator|new
name|ArrayList
argument_list|<
name|Query
argument_list|>
argument_list|(
name|ff
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|ff
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Query
name|fq
init|=
name|QueryParsing
operator|.
name|parseFunction
argument_list|(
name|f
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|Float
name|b
init|=
name|ff
operator|.
name|get
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|b
condition|)
block|{
name|fq
operator|.
name|setBoost
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|funcs
operator|.
name|add
argument_list|(
name|fq
argument_list|)
expr_stmt|;
block|}
return|return
name|funcs
return|;
block|}
comment|/**    * Checks the number of optional clauses in the query, and compares it    * with the specification string to determine the proper value to use.    *    *<p>    * Details about the specification format can be found    *<a href="doc-files/min-should-match.html">here</a>    *</p>    *    *<p>A few important notes...</p>    *<ul>    *<li>    * If the calculations based on the specification determine that no    * optional clauses are needed, BooleanQuerysetMinMumberShouldMatch    * will never be called, but the usual rules about BooleanQueries    * still apply at search time (a BooleanQuery containing no required    * clauses must still match at least one optional clause)    *<li>    *<li>    * No matter what number the calculation arrives at,    * BooleanQuery.setMinShouldMatch() will never be called with a    * value greater then the number of optional clauses (or less then 1)    *</li>    *</ul>    *    *<p>:TODO: should optimize the case where number is same    * as clauses to just make them all "required"    *</p>    */
DECL|method|setMinShouldMatch
specifier|public
specifier|static
name|void
name|setMinShouldMatch
parameter_list|(
name|BooleanQuery
name|q
parameter_list|,
name|String
name|spec
parameter_list|)
block|{
name|int
name|optionalClauses
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BooleanClause
name|c
range|:
operator|(
name|List
argument_list|<
name|BooleanClause
argument_list|>
operator|)
name|q
operator|.
name|clauses
argument_list|()
control|)
block|{
if|if
condition|(
name|c
operator|.
name|getOccur
argument_list|()
operator|==
name|Occur
operator|.
name|SHOULD
condition|)
block|{
name|optionalClauses
operator|++
expr_stmt|;
block|}
block|}
name|int
name|msm
init|=
name|calculateMinShouldMatch
argument_list|(
name|optionalClauses
argument_list|,
name|spec
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|msm
condition|)
block|{
name|q
operator|.
name|setMinimumNumberShouldMatch
argument_list|(
name|msm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * helper exposed for UnitTests    * @see #setMinShouldMatch    */
DECL|method|calculateMinShouldMatch
specifier|static
name|int
name|calculateMinShouldMatch
parameter_list|(
name|int
name|optionalClauseCount
parameter_list|,
name|String
name|spec
parameter_list|)
block|{
name|int
name|result
init|=
name|optionalClauseCount
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|<
name|spec
operator|.
name|indexOf
argument_list|(
literal|"<"
argument_list|)
condition|)
block|{
comment|/* we have conditional spec(s) */
for|for
control|(
name|String
name|s
range|:
name|spec
operator|.
name|trim
argument_list|()
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
control|)
block|{
name|String
index|[]
name|parts
init|=
name|s
operator|.
name|split
argument_list|(
literal|"<"
argument_list|)
decl_stmt|;
name|int
name|upperBound
init|=
operator|(
operator|new
name|Integer
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|optionalClauseCount
operator|<=
name|upperBound
condition|)
block|{
return|return
name|result
return|;
block|}
else|else
block|{
name|result
operator|=
name|calculateMinShouldMatch
argument_list|(
name|optionalClauseCount
argument_list|,
name|parts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/* otherwise, simple expresion */
if|if
condition|(
operator|-
literal|1
operator|<
name|spec
operator|.
name|indexOf
argument_list|(
literal|"%"
argument_list|)
condition|)
block|{
comment|/* percentage */
name|int
name|percent
init|=
operator|new
name|Integer
argument_list|(
name|spec
operator|.
name|replace
argument_list|(
literal|"%"
argument_list|,
literal|""
argument_list|)
argument_list|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|float
name|calc
init|=
operator|(
name|result
operator|*
name|percent
operator|)
operator|/
literal|100f
decl_stmt|;
name|result
operator|=
name|calc
operator|<
literal|0
condition|?
name|result
operator|+
operator|(
name|int
operator|)
name|calc
else|:
operator|(
name|int
operator|)
name|calc
expr_stmt|;
block|}
else|else
block|{
name|int
name|calc
init|=
operator|(
operator|new
name|Integer
argument_list|(
name|spec
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|result
operator|=
name|calc
operator|<
literal|0
condition|?
name|result
operator|+
name|calc
else|:
name|calc
expr_stmt|;
block|}
return|return
operator|(
name|optionalClauseCount
operator|<
name|result
condition|?
name|optionalClauseCount
else|:
operator|(
name|result
operator|<
literal|0
condition|?
literal|0
else|:
name|result
operator|)
operator|)
return|;
block|}
comment|/**    * Recursively walks the "from" query pulling out sub-queries and    * adding them to the "to" query.    *    *<p>    * Boosts are multiplied as needed.  Sub-BooleanQueryies which are not    * optional will not be flattened.  From will be mangled durring the walk,    * so do not attempt to reuse it.    *</p>    */
DECL|method|flattenBooleanQuery
specifier|public
specifier|static
name|void
name|flattenBooleanQuery
parameter_list|(
name|BooleanQuery
name|to
parameter_list|,
name|BooleanQuery
name|from
parameter_list|)
block|{
for|for
control|(
name|BooleanClause
name|clause
range|:
operator|(
name|List
argument_list|<
name|BooleanClause
argument_list|>
operator|)
name|from
operator|.
name|clauses
argument_list|()
control|)
block|{
name|Query
name|cq
init|=
name|clause
operator|.
name|getQuery
argument_list|()
decl_stmt|;
name|cq
operator|.
name|setBoost
argument_list|(
name|cq
operator|.
name|getBoost
argument_list|()
operator|*
name|from
operator|.
name|getBoost
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cq
operator|instanceof
name|BooleanQuery
operator|&&
operator|!
name|clause
operator|.
name|isRequired
argument_list|()
operator|&&
operator|!
name|clause
operator|.
name|isProhibited
argument_list|()
condition|)
block|{
comment|/* we can recurse */
name|flattenBooleanQuery
argument_list|(
name|to
argument_list|,
operator|(
name|BooleanQuery
operator|)
name|cq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to
operator|.
name|add
argument_list|(
name|clause
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Escapes all special characters except '"', '-', and '+'    *    * @see QueryParser#escape    */
DECL|method|partialEscape
specifier|public
specifier|static
name|CharSequence
name|partialEscape
parameter_list|(
name|CharSequence
name|s
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'!'
operator|||
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|':'
operator|||
name|c
operator|==
literal|'^'
operator|||
name|c
operator|==
literal|'['
operator|||
name|c
operator|==
literal|']'
operator|||
name|c
operator|==
literal|'{'
operator|||
name|c
operator|==
literal|'}'
operator|||
name|c
operator|==
literal|'~'
operator|||
name|c
operator|==
literal|'*'
operator|||
name|c
operator|==
literal|'?'
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
return|;
block|}
comment|// Pattern to detect dangling operator(s) at end of query
comment|// \s+[-+\s]+$
DECL|field|DANGLING_OP_PATTERN
specifier|private
specifier|final
specifier|static
name|Pattern
name|DANGLING_OP_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\s+[-+\\s]+$"
argument_list|)
decl_stmt|;
comment|// Pattern to detect consecutive + and/or - operators
comment|// \s+[+-](?:\s*[+-]+)+
DECL|field|CONSECUTIVE_OP_PATTERN
specifier|private
specifier|final
specifier|static
name|Pattern
name|CONSECUTIVE_OP_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\s+[+-](?:\\s*[+-]+)+"
argument_list|)
decl_stmt|;
comment|/**    * Strips operators that are used illegally, otherwise reuturns it's    * input.  Some examples of illegal user queries are: "chocolate +-    * chip", "chocolate - - chip", and "chocolate chip -".    */
DECL|method|stripIllegalOperators
specifier|public
specifier|static
name|CharSequence
name|stripIllegalOperators
parameter_list|(
name|CharSequence
name|s
parameter_list|)
block|{
name|String
name|temp
init|=
name|CONSECUTIVE_OP_PATTERN
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
return|return
name|DANGLING_OP_PATTERN
operator|.
name|matcher
argument_list|(
name|temp
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|""
argument_list|)
return|;
block|}
comment|/**    * Returns it's input if there is an even (ie: balanced) number of    * '"' characters -- otherwise returns a String in which all '"'    * characters are striped out.    */
DECL|method|stripUnbalancedQuotes
specifier|public
specifier|static
name|CharSequence
name|stripUnbalancedQuotes
parameter_list|(
name|CharSequence
name|s
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'\"'
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|0
operator|==
operator|(
name|count
operator|&
literal|1
operator|)
condition|)
block|{
return|return
name|s
return|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
operator|.
name|replace
argument_list|(
literal|"\""
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**    * A subclass of SolrQueryParser that supports aliasing fields for    * constructing DisjunctionMaxQueries.    */
DECL|class|DisjunctionMaxQueryParser
specifier|public
specifier|static
class|class
name|DisjunctionMaxQueryParser
extends|extends
name|SolrQueryParser
block|{
comment|/** A simple container for storing alias info      * @see #aliases      */
DECL|class|Alias
specifier|protected
specifier|static
class|class
name|Alias
block|{
DECL|field|tie
specifier|public
name|float
name|tie
decl_stmt|;
DECL|field|fields
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|fields
decl_stmt|;
block|}
comment|/**      * Where we store a map from field name we expect to see in our query      * string, to Alias object containing the fields to use in our      * DisjunctionMaxQuery and the tiebreaker to use.      */
DECL|field|aliases
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|Alias
argument_list|>
name|aliases
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Alias
argument_list|>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
DECL|method|DisjunctionMaxQueryParser
specifier|public
name|DisjunctionMaxQueryParser
parameter_list|(
name|QParser
name|qp
parameter_list|,
name|String
name|defaultField
parameter_list|)
block|{
name|super
argument_list|(
name|qp
argument_list|,
name|defaultField
argument_list|)
expr_stmt|;
comment|// don't trust that our parent class won't ever change it's default
name|setDefaultOperator
argument_list|(
name|QueryParser
operator|.
name|Operator
operator|.
name|OR
argument_list|)
expr_stmt|;
block|}
DECL|method|DisjunctionMaxQueryParser
specifier|public
name|DisjunctionMaxQueryParser
parameter_list|(
name|IndexSchema
name|s
parameter_list|,
name|String
name|defaultField
parameter_list|)
block|{
name|super
argument_list|(
name|s
argument_list|,
name|defaultField
argument_list|)
expr_stmt|;
comment|// don't trust that our parent class won't ever change it's default
name|setDefaultOperator
argument_list|(
name|QueryParser
operator|.
name|Operator
operator|.
name|OR
argument_list|)
expr_stmt|;
block|}
DECL|method|DisjunctionMaxQueryParser
specifier|public
name|DisjunctionMaxQueryParser
parameter_list|(
name|IndexSchema
name|s
parameter_list|)
block|{
name|this
argument_list|(
name|s
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add an alias to this query parser.      *      * @param field the field name that should trigger alias mapping      * @param fieldBoosts the mapping from fieldname to boost value that      *                    should be used to build up the clauses of the      *                    DisjunctionMaxQuery.      * @param tiebreaker to the tiebreaker to be used in the      *                   DisjunctionMaxQuery      * @see SolrPluginUtils#parseFieldBoosts      */
DECL|method|addAlias
specifier|public
name|void
name|addAlias
parameter_list|(
name|String
name|field
parameter_list|,
name|float
name|tiebreaker
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|fieldBoosts
parameter_list|)
block|{
name|Alias
name|a
init|=
operator|new
name|Alias
argument_list|()
decl_stmt|;
name|a
operator|.
name|tie
operator|=
name|tiebreaker
expr_stmt|;
name|a
operator|.
name|fields
operator|=
name|fieldBoosts
expr_stmt|;
name|aliases
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
comment|/**      * Delegates to the super class unless the field has been specified      * as an alias -- in which case we recurse on each of      * the aliased fields, and the results are composed into a      * DisjunctionMaxQuery.  (so yes: aliases which point at other      * aliases should work)      */
DECL|method|getFieldQuery
specifier|protected
name|Query
name|getFieldQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|queryText
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|aliases
operator|.
name|containsKey
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|Alias
name|a
init|=
name|aliases
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|DisjunctionMaxQuery
name|q
init|=
operator|new
name|DisjunctionMaxQuery
argument_list|(
name|a
operator|.
name|tie
argument_list|)
decl_stmt|;
comment|/* we might not get any valid queries from delegation,          * in which case we should return null          */
name|boolean
name|ok
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|a
operator|.
name|fields
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Query
name|sub
init|=
name|getFieldQuery
argument_list|(
name|f
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|sub
condition|)
block|{
if|if
condition|(
literal|null
operator|!=
name|a
operator|.
name|fields
operator|.
name|get
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|sub
operator|.
name|setBoost
argument_list|(
name|a
operator|.
name|fields
operator|.
name|get
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|q
operator|.
name|add
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|ok
condition|?
name|q
else|:
literal|null
return|;
block|}
else|else
block|{
try|try
block|{
return|return
name|super
operator|.
name|getFieldQuery
argument_list|(
name|field
argument_list|,
name|queryText
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
block|}
comment|/**    * Determines the correct Sort based on the request parameter "sort"    *    * @return null if no sort is specified.    */
DECL|method|getSort
specifier|public
specifier|static
name|Sort
name|getSort
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|)
block|{
name|String
name|sort
init|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
operator|.
name|SORT
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|sort
operator|||
name|sort
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|SolrException
name|sortE
init|=
literal|null
decl_stmt|;
name|Sort
name|ss
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ss
operator|=
name|QueryParsing
operator|.
name|parseSort
argument_list|(
name|sort
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|sortE
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|null
operator|==
name|ss
operator|)
operator|||
operator|(
literal|null
operator|!=
name|sortE
operator|)
condition|)
block|{
comment|/* we definitely had some sort of sort string from the user,        * but no SortSpec came out of it        */
name|SolrCore
operator|.
name|log
operator|.
name|warn
argument_list|(
literal|"Invalid sort \""
operator|+
name|sort
operator|+
literal|"\" was specified, ignoring"
argument_list|,
name|sortE
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|ss
return|;
block|}
comment|/**    * Builds a list of Query objects that should be used to filter results    * @see CommonParams#FQ    * @return null if no filter queries    */
DECL|method|parseFilterQueries
specifier|public
specifier|static
name|List
argument_list|<
name|Query
argument_list|>
name|parseFilterQueries
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|)
throws|throws
name|ParseException
block|{
return|return
name|parseQueryStrings
argument_list|(
name|req
argument_list|,
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|getParams
argument_list|(
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
operator|.
name|FQ
argument_list|)
argument_list|)
return|;
block|}
comment|/** Turns an array of query strings into a List of Query objects.    *    * @return null if no queries are generated    */
DECL|method|parseQueryStrings
specifier|public
specifier|static
name|List
argument_list|<
name|Query
argument_list|>
name|parseQueryStrings
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
index|[]
name|queries
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
literal|null
operator|==
name|queries
operator|||
literal|0
operator|==
name|queries
operator|.
name|length
condition|)
return|return
literal|null
return|;
name|List
argument_list|<
name|Query
argument_list|>
name|out
init|=
operator|new
name|ArrayList
argument_list|<
name|Query
argument_list|>
argument_list|(
name|queries
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|q
range|:
name|queries
control|)
block|{
if|if
condition|(
literal|null
operator|!=
name|q
operator|&&
literal|0
operator|!=
name|q
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
condition|)
block|{
name|out
operator|.
name|add
argument_list|(
name|QParser
operator|.
name|getParser
argument_list|(
name|q
argument_list|,
literal|null
argument_list|,
name|req
argument_list|)
operator|.
name|getQuery
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|out
return|;
block|}
comment|/**    * A CacheRegenerator that can be used whenever the items in the cache    * are not dependant on the current searcher.    *    *<p>    * Flat out copies the oldKey=&gt;oldVal pair into the newCache    *</p>    */
DECL|class|IdentityRegenerator
specifier|public
specifier|static
class|class
name|IdentityRegenerator
implements|implements
name|CacheRegenerator
block|{
DECL|method|regenerateItem
specifier|public
name|boolean
name|regenerateItem
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|,
name|SolrCache
name|newCache
parameter_list|,
name|SolrCache
name|oldCache
parameter_list|,
name|Object
name|oldKey
parameter_list|,
name|Object
name|oldVal
parameter_list|)
throws|throws
name|IOException
block|{
name|newCache
operator|.
name|put
argument_list|(
name|oldKey
argument_list|,
name|oldVal
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Convert a DocList to a SolrDocumentList    *    * The optional param "ids" is populated with the lucene document id    * for each SolrDocument.    *    * @param docs The {@link org.apache.solr.search.DocList} to convert    * @param searcher The {@link org.apache.solr.search.SolrIndexSearcher} to use to load the docs from the Lucene index    * @param fields The names of the Fields to load    * @param ids A map to store the ids of the docs    * @return The new {@link org.apache.solr.common.SolrDocumentList} containing all the loaded docs    * @throws java.io.IOException if there was a problem loading the docs    * @since solr 1.4    */
DECL|method|docListToSolrDocumentList
specifier|public
specifier|static
name|SolrDocumentList
name|docListToSolrDocumentList
parameter_list|(
name|DocList
name|docs
parameter_list|,
name|SolrIndexSearcher
name|searcher
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|,
name|Map
argument_list|<
name|SolrDocument
argument_list|,
name|Integer
argument_list|>
name|ids
parameter_list|)
throws|throws
name|IOException
block|{
name|DocumentBuilder
name|db
init|=
operator|new
name|DocumentBuilder
argument_list|(
name|searcher
operator|.
name|getSchema
argument_list|()
argument_list|)
decl_stmt|;
name|SolrDocumentList
name|list
init|=
operator|new
name|SolrDocumentList
argument_list|()
decl_stmt|;
name|list
operator|.
name|setNumFound
argument_list|(
name|docs
operator|.
name|matches
argument_list|()
argument_list|)
expr_stmt|;
name|list
operator|.
name|setMaxScore
argument_list|(
name|docs
operator|.
name|maxScore
argument_list|()
argument_list|)
expr_stmt|;
name|list
operator|.
name|setStart
argument_list|(
name|docs
operator|.
name|offset
argument_list|()
argument_list|)
expr_stmt|;
name|DocIterator
name|dit
init|=
name|docs
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|dit
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|docid
init|=
name|dit
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
name|Document
name|luceneDoc
init|=
name|searcher
operator|.
name|doc
argument_list|(
name|docid
argument_list|,
name|fields
argument_list|)
decl_stmt|;
name|SolrDocument
name|doc
init|=
operator|new
name|SolrDocument
argument_list|()
decl_stmt|;
name|db
operator|.
name|loadStoredFields
argument_list|(
name|doc
argument_list|,
name|luceneDoc
argument_list|)
expr_stmt|;
comment|// this may be removed if XMLWriter gets patched to
comment|// include score from doc iterator in solrdoclist
if|if
condition|(
name|docs
operator|.
name|hasScores
argument_list|()
condition|)
block|{
name|doc
operator|.
name|addField
argument_list|(
literal|"score"
argument_list|,
name|dit
operator|.
name|score
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doc
operator|.
name|addField
argument_list|(
literal|"score"
argument_list|,
literal|0.0f
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ids
operator|!=
literal|null
condition|)
block|{
name|ids
operator|.
name|put
argument_list|(
name|doc
argument_list|,
operator|new
name|Integer
argument_list|(
name|docid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
comment|/**    * Given a SolrQueryResponse replace the DocList if it is in the result.      * Otherwise add it to the response    *     * @since solr 1.4    */
DECL|method|addOrReplaceResults
specifier|public
specifier|static
name|void
name|addOrReplaceResults
parameter_list|(
name|SolrQueryResponse
name|rsp
parameter_list|,
name|SolrDocumentList
name|docs
parameter_list|)
block|{
name|NamedList
name|vals
init|=
name|rsp
operator|.
name|getValues
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
name|vals
operator|.
name|indexOf
argument_list|(
literal|"response"
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Replacing DocList with SolrDocumentList "
operator|+
name|docs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|vals
operator|.
name|setVal
argument_list|(
name|idx
argument_list|,
name|docs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Adding SolrDocumentList response"
operator|+
name|docs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|vals
operator|.
name|add
argument_list|(
literal|"response"
argument_list|,
name|docs
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|invokeSetters
specifier|public
specifier|static
name|void
name|invokeSetters
parameter_list|(
name|Object
name|bean
parameter_list|,
name|NamedList
name|initArgs
parameter_list|)
block|{
if|if
condition|(
name|initArgs
operator|==
literal|null
condition|)
return|return;
name|Class
name|clazz
init|=
name|bean
operator|.
name|getClass
argument_list|()
decl_stmt|;
name|Method
index|[]
name|methods
init|=
name|clazz
operator|.
name|getMethods
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|iterator
init|=
name|initArgs
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|setterName
init|=
literal|"set"
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|Character
operator|.
name|toUpperCase
argument_list|(
name|key
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|+
name|key
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|Method
name|method
init|=
literal|null
decl_stmt|;
try|try
block|{
for|for
control|(
name|Method
name|m
range|:
name|methods
control|)
block|{
if|if
condition|(
name|m
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|setterName
argument_list|)
operator|&&
name|m
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|method
operator|=
name|m
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|method
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"no setter corrresponding to '"
operator|+
name|key
operator|+
literal|"' in "
operator|+
name|clazz
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|Class
name|pClazz
init|=
name|method
operator|.
name|getParameterTypes
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|Object
name|val
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|method
operator|.
name|invoke
argument_list|(
name|bean
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e1
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error invoking setter "
operator|+
name|setterName
operator|+
literal|"on class : "
operator|+
name|clazz
operator|.
name|getName
argument_list|()
argument_list|,
name|e1
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e1
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error invoking setter "
operator|+
name|setterName
operator|+
literal|"on class : "
operator|+
name|clazz
operator|.
name|getName
argument_list|()
argument_list|,
name|e1
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class
end_unit
