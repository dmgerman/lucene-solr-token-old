begin_unit
begin_comment
comment|/**  * Copyright 2006 The Apache Software Foundation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.util
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Token
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|ParseException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|QueryParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
operator|.
name|Occur
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|highlight
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|DefaultSolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import
begin_comment
comment|/**  *<p>Utilities that may be of use to RequestHandlers.</p>  *  *<p>  * Many of these functions have code that was stolen/mutated from  * StandardRequestHandler.  *</p>  *  *<p>:TODO: refactor StandardRequestHandler to use these utilities</p>  *  *<p>:TODO: Many "standard" functionality methods are not cognisant of  * default parameter settings.    */
end_comment
begin_class
DECL|class|SolrPluginUtils
specifier|public
class|class
name|SolrPluginUtils
block|{
comment|/** set defaults on a SolrQueryRequest */
DECL|method|setDefaults
specifier|public
specifier|static
name|void
name|setDefaults
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrParams
name|defaults
parameter_list|)
block|{
name|SolrParams
name|p
init|=
name|req
operator|.
name|getParams
argument_list|()
decl_stmt|;
if|if
condition|(
name|defaults
operator|!=
literal|null
condition|)
block|{
name|p
operator|=
operator|new
name|DefaultSolrParams
argument_list|(
name|p
argument_list|,
name|defaults
argument_list|)
expr_stmt|;
comment|// set params so they will be visible to other components such as the response writer
name|req
operator|.
name|setParams
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** standard param for field list */
annotation|@
name|Deprecated
DECL|field|FL
specifier|public
specifier|static
name|String
name|FL
init|=
name|SolrParams
operator|.
name|FL
decl_stmt|;
comment|/**    * SolrIndexSearch.numDocs(Query,Query) freaks out if the filtering    * query is null, so we use this workarround.    */
DECL|method|numDocs
specifier|public
specifier|static
name|int
name|numDocs
parameter_list|(
name|SolrIndexSearcher
name|s
parameter_list|,
name|Query
name|q
parameter_list|,
name|Query
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|(
literal|null
operator|==
name|f
operator|)
condition|?
name|s
operator|.
name|getDocSet
argument_list|(
name|q
argument_list|)
operator|.
name|size
argument_list|()
else|:
name|s
operator|.
name|numDocs
argument_list|(
name|q
argument_list|,
name|f
argument_list|)
return|;
block|}
comment|/**    * Returns the param, or the default if it's empty or not specified.    */
DECL|method|getParam
specifier|public
specifier|static
name|String
name|getParam
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
name|param
parameter_list|,
name|String
name|def
parameter_list|)
block|{
name|String
name|v
init|=
name|req
operator|.
name|getParam
argument_list|(
name|param
argument_list|)
decl_stmt|;
comment|// Note: parameters passed but given only white-space value are
comment|// considered equvalent to passing nothing for that parameter.
if|if
condition|(
literal|null
operator|==
name|v
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|v
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|def
return|;
block|}
return|return
name|v
return|;
block|}
comment|/**    * Treats the param value as a Number, returns the default if nothing is    * there or if it's not a number.    */
DECL|method|getNumberParam
specifier|public
specifier|static
name|Number
name|getNumberParam
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
name|param
parameter_list|,
name|Number
name|def
parameter_list|)
block|{
name|Number
name|r
init|=
name|def
decl_stmt|;
name|String
name|v
init|=
name|req
operator|.
name|getParam
argument_list|(
name|param
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|v
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|v
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|r
return|;
block|}
try|try
block|{
name|r
operator|=
operator|new
name|Float
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
comment|/* :NOOP" */
block|}
return|return
name|r
return|;
block|}
comment|/**    * Treats parameter value as a boolean.  The string 'false' is false;     * any other non-empty string is true.    */
DECL|method|getBooleanParam
specifier|public
specifier|static
name|boolean
name|getBooleanParam
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
name|param
parameter_list|,
name|boolean
name|def
parameter_list|)
block|{
name|String
name|v
init|=
name|req
operator|.
name|getParam
argument_list|(
name|param
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|v
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|v
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|def
return|;
block|}
return|return
operator|!
literal|"false"
operator|.
name|equals
argument_list|(
name|v
operator|.
name|trim
argument_list|()
argument_list|)
return|;
block|}
DECL|field|splitList
specifier|private
specifier|final
specifier|static
name|Pattern
name|splitList
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|",| "
argument_list|)
decl_stmt|;
comment|/** Split a value that may contain a comma, space of bar separated list. */
DECL|method|split
specifier|public
specifier|static
name|String
index|[]
name|split
parameter_list|(
name|String
name|value
parameter_list|)
block|{
return|return
name|splitList
operator|.
name|split
argument_list|(
name|value
operator|.
name|trim
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Assumes the standard query param of "fl" to specify the return fields    * @see #setReturnFields(String,SolrQueryResponse)    */
DECL|method|setReturnFields
specifier|public
specifier|static
name|int
name|setReturnFields
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|res
parameter_list|)
block|{
return|return
name|setReturnFields
argument_list|(
name|req
operator|.
name|getParam
argument_list|(
name|FL
argument_list|)
argument_list|,
name|res
argument_list|)
return|;
block|}
comment|/**    * Given a space seperated list of field names, sets the field list on the    * SolrQueryResponse.    *    * @return bitfield of SolrIndexSearcher flags that need to be set    */
DECL|method|setReturnFields
specifier|public
specifier|static
name|int
name|setReturnFields
parameter_list|(
name|String
name|fl
parameter_list|,
name|SolrQueryResponse
name|res
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fl
operator|!=
literal|null
condition|)
block|{
comment|// TODO - this could become more efficient if widely used.
comment|// TODO - should field order be maintained?
name|String
index|[]
name|flst
init|=
name|split
argument_list|(
name|fl
argument_list|)
decl_stmt|;
if|if
condition|(
name|flst
operator|.
name|length
operator|>
literal|0
operator|&&
operator|!
operator|(
name|flst
operator|.
name|length
operator|==
literal|1
operator|&&
name|flst
index|[
literal|0
index|]
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fname
range|:
name|flst
control|)
block|{
if|if
condition|(
literal|"score"
operator|.
name|equalsIgnoreCase
argument_list|(
name|fname
argument_list|)
condition|)
name|flags
operator||=
name|SolrIndexSearcher
operator|.
name|GET_SCORES
expr_stmt|;
name|set
operator|.
name|add
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
name|res
operator|.
name|setReturnFields
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|flags
return|;
block|}
comment|/**    *<p>    * Returns a NamedList containing many "standard" pieces of debugging    * information.    *</p>    *    *<ul>    *<li>rawquerystring - the 'q' param exactly as specified by the client    *</li>    *<li>querystring - the 'q' param after any preprocessing done by the plugin    *</li>    *<li>parsedquery - the main query executed formated by the Solr    *     QueryParsing utils class (which knows about field types)    *</li>    *<li>parsedquery_toString - the main query executed formated by it's    *     own toString method (in case it has internal state Solr    *     doesn't know about)    *</li>    *<li>expain - the list of score explanations for each document in    *     results against query.    *</li>    *<li>otherQuery - the query string specified in 'explainOther' query param.    *</li>    *<li>explainOther - the list of score explanations for each document in    *     results against 'otherQuery'    *</li>    *</ul>    *    * @param req the request we are dealing with    * @param userQuery the users query as a string, after any basic    *                  preprocessing has been done    * @param query the query built from the userQuery    *              (and perhaps other clauses) that identifies the main    *              result set of the response.    * @param results the main result set of the response    */
DECL|method|doStandardDebug
specifier|public
specifier|static
name|NamedList
name|doStandardDebug
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
name|userQuery
parameter_list|,
name|Query
name|query
parameter_list|,
name|DocList
name|results
parameter_list|,
name|CommonParams
name|params
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|debug
init|=
name|getParam
argument_list|(
name|req
argument_list|,
name|SolrParams
operator|.
name|DEBUG_QUERY
argument_list|,
name|params
operator|.
name|debugQuery
argument_list|)
decl_stmt|;
name|NamedList
name|dbg
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|debug
operator|!=
literal|null
condition|)
block|{
name|dbg
operator|=
operator|new
name|NamedList
argument_list|()
expr_stmt|;
comment|/* userQuery may have been pre-processes .. expose that */
name|dbg
operator|.
name|add
argument_list|(
literal|"rawquerystring"
argument_list|,
name|req
operator|.
name|getQueryString
argument_list|()
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"querystring"
argument_list|,
name|userQuery
argument_list|)
expr_stmt|;
comment|/* QueryParsing.toString isn't perfect, use it to see converted        * values, use regular toString to see any attributes of the        * underlying Query it may have missed.        */
name|dbg
operator|.
name|add
argument_list|(
literal|"parsedquery"
argument_list|,
name|QueryParsing
operator|.
name|toString
argument_list|(
name|query
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"parsedquery_toString"
argument_list|,
name|query
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"explain"
argument_list|,
name|getExplainList
argument_list|(
name|query
argument_list|,
name|results
argument_list|,
name|req
operator|.
name|getSearcher
argument_list|()
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|otherQueryS
init|=
name|req
operator|.
name|getParam
argument_list|(
literal|"explainOther"
argument_list|)
decl_stmt|;
if|if
condition|(
name|otherQueryS
operator|!=
literal|null
operator|&&
name|otherQueryS
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|DocList
name|otherResults
init|=
name|doSimpleQuery
argument_list|(
name|otherQueryS
argument_list|,
name|req
operator|.
name|getSearcher
argument_list|()
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"otherQuery"
argument_list|,
name|otherQueryS
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"explainOther"
argument_list|,
name|getExplainList
argument_list|(
name|query
argument_list|,
name|otherResults
argument_list|,
name|req
operator|.
name|getSearcher
argument_list|()
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dbg
return|;
block|}
comment|/**    *<p>    * Returns a NamedList containing many "standard" pieces of debugging    * information.    *</p>    *    *<ul>    *<li>rawquerystring - the 'q' param exactly as specified by the client    *</li>    *<li>querystring - the 'q' param after any preprocessing done by the plugin    *</li>    *<li>parsedquery - the main query executed formated by the Solr    *     QueryParsing utils class (which knows about field types)    *</li>    *<li>parsedquery_toString - the main query executed formated by it's    *     own toString method (in case it has internal state Solr    *     doesn't know about)    *</li>    *<li>expain - the list of score explanations for each document in    *     results against query.    *</li>    *<li>otherQuery - the query string specified in 'explainOther' query param.    *</li>    *<li>explainOther - the list of score explanations for each document in    *     results against 'otherQuery'    *</li>    *</ul>    *    * @param req the request we are dealing with    * @param userQuery the users query as a string, after any basic    *                  preprocessing has been done    * @param query the query built from the userQuery    *              (and perhaps other clauses) that identifies the main    *              result set of the response.    * @param results the main result set of the response    */
DECL|method|doStandardDebug
specifier|public
specifier|static
name|NamedList
name|doStandardDebug
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|String
name|userQuery
parameter_list|,
name|Query
name|query
parameter_list|,
name|DocList
name|results
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|debug
init|=
name|req
operator|.
name|getParam
argument_list|(
name|SolrParams
operator|.
name|DEBUG_QUERY
argument_list|)
decl_stmt|;
name|NamedList
name|dbg
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|debug
operator|!=
literal|null
condition|)
block|{
name|dbg
operator|=
operator|new
name|NamedList
argument_list|()
expr_stmt|;
comment|/* userQuery may have been pre-processes .. expose that */
name|dbg
operator|.
name|add
argument_list|(
literal|"rawquerystring"
argument_list|,
name|req
operator|.
name|getQueryString
argument_list|()
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"querystring"
argument_list|,
name|userQuery
argument_list|)
expr_stmt|;
comment|/* QueryParsing.toString isn't perfect, use it to see converted        * values, use regular toString to see any attributes of the        * underlying Query it may have missed.        */
name|dbg
operator|.
name|add
argument_list|(
literal|"parsedquery"
argument_list|,
name|QueryParsing
operator|.
name|toString
argument_list|(
name|query
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"parsedquery_toString"
argument_list|,
name|query
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"explain"
argument_list|,
name|getExplainList
argument_list|(
name|query
argument_list|,
name|results
argument_list|,
name|req
operator|.
name|getSearcher
argument_list|()
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|otherQueryS
init|=
name|req
operator|.
name|getParam
argument_list|(
literal|"explainOther"
argument_list|)
decl_stmt|;
if|if
condition|(
name|otherQueryS
operator|!=
literal|null
operator|&&
name|otherQueryS
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|DocList
name|otherResults
init|=
name|doSimpleQuery
argument_list|(
name|otherQueryS
argument_list|,
name|req
operator|.
name|getSearcher
argument_list|()
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"otherQuery"
argument_list|,
name|otherQueryS
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|add
argument_list|(
literal|"explainOther"
argument_list|,
name|getExplainList
argument_list|(
name|query
argument_list|,
name|otherResults
argument_list|,
name|req
operator|.
name|getSearcher
argument_list|()
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dbg
return|;
block|}
comment|/**    * Generates an list of Explanations for each item in a list of docs.    *    * @param query The Query you want explanations in the context of    * @param docs The Documents you want explained relative that query    */
DECL|method|getExplainList
specifier|public
specifier|static
name|NamedList
name|getExplainList
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocList
name|docs
parameter_list|,
name|SolrIndexSearcher
name|searcher
parameter_list|,
name|IndexSchema
name|schema
parameter_list|)
throws|throws
name|IOException
block|{
name|NamedList
name|explainList
init|=
operator|new
name|NamedList
argument_list|()
decl_stmt|;
name|DocIterator
name|iterator
init|=
name|docs
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|id
init|=
name|iterator
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
name|Explanation
name|explain
init|=
name|searcher
operator|.
name|explain
argument_list|(
name|query
argument_list|,
name|id
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
name|searcher
operator|.
name|doc
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|String
name|strid
init|=
name|schema
operator|.
name|printableUniqueKey
argument_list|(
name|doc
argument_list|)
decl_stmt|;
name|String
name|docname
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|strid
operator|!=
literal|null
condition|)
name|docname
operator|=
literal|"id="
operator|+
name|strid
operator|+
literal|","
expr_stmt|;
name|docname
operator|=
name|docname
operator|+
literal|"internal_docid="
operator|+
name|id
expr_stmt|;
name|explainList
operator|.
name|add
argument_list|(
name|docname
argument_list|,
literal|"\n"
operator|+
name|explain
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|explainList
return|;
block|}
comment|/**    * Executes a basic query in lucene syntax    */
DECL|method|doSimpleQuery
specifier|public
specifier|static
name|DocList
name|doSimpleQuery
parameter_list|(
name|String
name|sreq
parameter_list|,
name|SolrIndexSearcher
name|searcher
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|limit
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|commands
init|=
name|StrUtils
operator|.
name|splitSmart
argument_list|(
name|sreq
argument_list|,
literal|';'
argument_list|)
decl_stmt|;
name|String
name|qs
init|=
name|commands
operator|.
name|size
argument_list|()
operator|>=
literal|1
condition|?
name|commands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
else|:
literal|""
decl_stmt|;
name|Query
name|query
init|=
name|QueryParsing
operator|.
name|parseQuery
argument_list|(
name|qs
argument_list|,
name|schema
argument_list|)
decl_stmt|;
comment|// If the first non-query, non-filter command is a simple sort on an indexed field, then
comment|// we can use the Lucene sort ability.
name|Sort
name|sort
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|commands
operator|.
name|size
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|QueryParsing
operator|.
name|SortSpec
name|sortSpec
init|=
name|QueryParsing
operator|.
name|parseSort
argument_list|(
name|commands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|schema
argument_list|)
decl_stmt|;
if|if
condition|(
name|sortSpec
operator|!=
literal|null
condition|)
block|{
name|sort
operator|=
name|sortSpec
operator|.
name|getSort
argument_list|()
expr_stmt|;
if|if
condition|(
name|sortSpec
operator|.
name|getCount
argument_list|()
operator|>=
literal|0
condition|)
block|{
name|limit
operator|=
name|sortSpec
operator|.
name|getCount
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|DocList
name|results
init|=
name|searcher
operator|.
name|getDocList
argument_list|(
name|query
argument_list|,
operator|(
name|DocSet
operator|)
literal|null
argument_list|,
name|sort
argument_list|,
name|start
argument_list|,
name|limit
argument_list|)
decl_stmt|;
return|return
name|results
return|;
block|}
comment|/**    * Given a string containing fieldNames and boost info,    * converts it to a Map from field name to boost info.    *    *<p>    * Doesn't care if boost info is negative, you're on your own.    *</p>    *<p>    * Doesn't care if boost info is missing, again: you're on your own.    *</p>    *    * @param in a String like "fieldOne^2.3 fieldTwo fieldThree^-0.4"    * @return Map of fieldOne =&gt; 2.3, fieldTwo =&gt; null, fieldThree =&gt; -0.4    */
DECL|method|parseFieldBoosts
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|parseFieldBoosts
parameter_list|(
name|String
name|in
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|in
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|in
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
block|{
return|return
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
argument_list|()
return|;
block|}
name|String
index|[]
name|bb
init|=
name|in
operator|.
name|trim
argument_list|()
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|out
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
argument_list|(
literal|7
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|bb
control|)
block|{
name|String
index|[]
name|bbb
init|=
name|s
operator|.
name|split
argument_list|(
literal|"\\^"
argument_list|)
decl_stmt|;
name|out
operator|.
name|put
argument_list|(
name|bbb
index|[
literal|0
index|]
argument_list|,
literal|1
operator|==
name|bbb
operator|.
name|length
condition|?
literal|null
else|:
name|Float
operator|.
name|valueOf
argument_list|(
name|bbb
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
comment|/**    * Given a string containing functions with optional boosts, returns    * an array of Queries representing those functions with the specified    * boosts.    *<p>    * NOTE: intra-function whitespace is not allowed.    *</p>    * @see #parseFieldBoosts    */
DECL|method|parseFuncs
specifier|public
specifier|static
name|List
argument_list|<
name|Query
argument_list|>
name|parseFuncs
parameter_list|(
name|IndexSchema
name|s
parameter_list|,
name|String
name|in
parameter_list|)
throws|throws
name|ParseException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|ff
init|=
name|parseFieldBoosts
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Query
argument_list|>
name|funcs
init|=
operator|new
name|ArrayList
argument_list|<
name|Query
argument_list|>
argument_list|(
name|ff
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|ff
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Query
name|fq
init|=
name|QueryParsing
operator|.
name|parseFunction
argument_list|(
name|f
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|Float
name|b
init|=
name|ff
operator|.
name|get
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|b
condition|)
block|{
name|fq
operator|.
name|setBoost
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|funcs
operator|.
name|add
argument_list|(
name|fq
argument_list|)
expr_stmt|;
block|}
return|return
name|funcs
return|;
block|}
comment|/**    * Checks the number of optional clauses in the query, and compares it    * with the specification string to determine the proper value to use.    *    *<p>    * Details about the specification format can be found    *<a href="doc-files/min-should-match.html">here</a>    *</p>    *    *<p>A few important notes...</p>    *<ul>    *<li>    * If the calculations based on the specification determine that no    * optional clauses are needed, BooleanQuerysetMinMumberShouldMatch    * will never be called, but the usual rules about BooleanQueries    * still apply at search time (a BooleanQuery containing no required    * clauses must still match at least one optional clause)    *<li>    *<li>    * No matter what number the calculation arrives at,    * BooleanQuery.setMinShouldMatch() will never be called with a    * value greater then the number of optional clauses (or less then 1)    *</li>    *</ul>    *    *<p>:TODO: should optimize the case where number is same    * as clauses to just make them all "required"    *</p>    */
DECL|method|setMinShouldMatch
specifier|public
specifier|static
name|void
name|setMinShouldMatch
parameter_list|(
name|BooleanQuery
name|q
parameter_list|,
name|String
name|spec
parameter_list|)
block|{
name|int
name|optionalClauses
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BooleanClause
name|c
range|:
name|q
operator|.
name|getClauses
argument_list|()
control|)
block|{
if|if
condition|(
name|c
operator|.
name|getOccur
argument_list|()
operator|==
name|Occur
operator|.
name|SHOULD
condition|)
block|{
name|optionalClauses
operator|++
expr_stmt|;
block|}
block|}
name|int
name|msm
init|=
name|calculateMinShouldMatch
argument_list|(
name|optionalClauses
argument_list|,
name|spec
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|msm
condition|)
block|{
name|q
operator|.
name|setMinimumNumberShouldMatch
argument_list|(
name|msm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * helper exposed for UnitTests    * @see #setMinShouldMatch    */
DECL|method|calculateMinShouldMatch
specifier|static
name|int
name|calculateMinShouldMatch
parameter_list|(
name|int
name|optionalClauseCount
parameter_list|,
name|String
name|spec
parameter_list|)
block|{
name|int
name|result
init|=
name|optionalClauseCount
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|<
name|spec
operator|.
name|indexOf
argument_list|(
literal|"<"
argument_list|)
condition|)
block|{
comment|/* we have conditional spec(s) */
for|for
control|(
name|String
name|s
range|:
name|spec
operator|.
name|trim
argument_list|()
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
control|)
block|{
name|String
index|[]
name|parts
init|=
name|s
operator|.
name|split
argument_list|(
literal|"<"
argument_list|)
decl_stmt|;
name|int
name|upperBound
init|=
operator|(
operator|new
name|Integer
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|optionalClauseCount
operator|<=
name|upperBound
condition|)
block|{
return|return
name|result
return|;
block|}
else|else
block|{
name|result
operator|=
name|calculateMinShouldMatch
argument_list|(
name|optionalClauseCount
argument_list|,
name|parts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/* otherwise, simple expresion */
if|if
condition|(
operator|-
literal|1
operator|<
name|spec
operator|.
name|indexOf
argument_list|(
literal|"%"
argument_list|)
condition|)
block|{
comment|/* percentage */
name|int
name|percent
init|=
operator|new
name|Integer
argument_list|(
name|spec
operator|.
name|replace
argument_list|(
literal|"%"
argument_list|,
literal|""
argument_list|)
argument_list|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|float
name|calc
init|=
operator|(
name|result
operator|*
name|percent
operator|)
operator|/
literal|100f
decl_stmt|;
name|result
operator|=
name|calc
operator|<
literal|0
condition|?
name|result
operator|+
operator|(
name|int
operator|)
name|calc
else|:
operator|(
name|int
operator|)
name|calc
expr_stmt|;
block|}
else|else
block|{
name|int
name|calc
init|=
operator|(
operator|new
name|Integer
argument_list|(
name|spec
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|result
operator|=
name|calc
operator|<
literal|0
condition|?
name|result
operator|+
name|calc
else|:
name|calc
expr_stmt|;
block|}
return|return
operator|(
name|optionalClauseCount
operator|<
name|result
condition|?
name|optionalClauseCount
else|:
operator|(
name|result
operator|<
literal|0
condition|?
literal|0
else|:
name|result
operator|)
operator|)
return|;
block|}
comment|/**    * Recursively walks the "from" query pulling out sub-queries and    * adding them to the "to" query.    *    *<p>    * Boosts are multiplied as needed.  Sub-BooleanQueryies which are not    * optional will not be flattened.  From will be mangled durring the walk,    * so do not attempt to reuse it.    *</p>    */
DECL|method|flattenBooleanQuery
specifier|public
specifier|static
name|void
name|flattenBooleanQuery
parameter_list|(
name|BooleanQuery
name|to
parameter_list|,
name|BooleanQuery
name|from
parameter_list|)
block|{
name|BooleanClause
index|[]
name|c
init|=
name|from
operator|.
name|getClauses
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|c
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Query
name|ci
init|=
name|c
index|[
name|i
index|]
operator|.
name|getQuery
argument_list|()
decl_stmt|;
name|ci
operator|.
name|setBoost
argument_list|(
name|ci
operator|.
name|getBoost
argument_list|()
operator|*
name|from
operator|.
name|getBoost
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|instanceof
name|BooleanQuery
operator|&&
operator|!
name|c
index|[
name|i
index|]
operator|.
name|isRequired
argument_list|()
operator|&&
operator|!
name|c
index|[
name|i
index|]
operator|.
name|isProhibited
argument_list|()
condition|)
block|{
comment|/* we can recurse */
name|flattenBooleanQuery
argument_list|(
name|to
argument_list|,
operator|(
name|BooleanQuery
operator|)
name|ci
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to
operator|.
name|add
argument_list|(
name|c
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Escapes all special characters except '"', '-', and '+'    *    * @see QueryParser#escape    */
DECL|method|partialEscape
specifier|public
specifier|static
name|CharSequence
name|partialEscape
parameter_list|(
name|CharSequence
name|s
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'!'
operator|||
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|':'
operator|||
name|c
operator|==
literal|'^'
operator|||
name|c
operator|==
literal|'['
operator|||
name|c
operator|==
literal|']'
operator|||
name|c
operator|==
literal|'{'
operator|||
name|c
operator|==
literal|'}'
operator|||
name|c
operator|==
literal|'~'
operator|||
name|c
operator|==
literal|'*'
operator|||
name|c
operator|==
literal|'?'
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
return|;
block|}
comment|/**    * Returns it's input if there is an even (ie: balanced) number of    * '"' characters -- otherwise returns a String in which all '"'    * characters are striped out.    */
DECL|method|stripUnbalancedQuotes
specifier|public
specifier|static
name|CharSequence
name|stripUnbalancedQuotes
parameter_list|(
name|CharSequence
name|s
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'\"'
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|0
operator|==
operator|(
name|count
operator|&
literal|1
operator|)
condition|)
block|{
return|return
name|s
return|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
operator|.
name|replace
argument_list|(
literal|"\""
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**    * A subclass of SolrQueryParser that supports aliasing fields for    * constructing DisjunctionMaxQueries.    */
DECL|class|DisjunctionMaxQueryParser
specifier|public
specifier|static
class|class
name|DisjunctionMaxQueryParser
extends|extends
name|SolrQueryParser
block|{
comment|/** A simple container for storing alias info      * @see #aliases      */
DECL|class|Alias
specifier|protected
specifier|static
class|class
name|Alias
block|{
DECL|field|tie
specifier|public
name|float
name|tie
decl_stmt|;
DECL|field|fields
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|fields
decl_stmt|;
block|}
comment|/**      * Where we store a map from field name we expect to see in our query      * string, to Alias object containing the fields to use in our      * DisjunctionMaxQuery and the tiebreaker to use.      */
DECL|field|aliases
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|Alias
argument_list|>
name|aliases
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Alias
argument_list|>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
DECL|method|DisjunctionMaxQueryParser
specifier|public
name|DisjunctionMaxQueryParser
parameter_list|(
name|IndexSchema
name|s
parameter_list|,
name|String
name|defaultField
parameter_list|)
block|{
name|super
argument_list|(
name|s
argument_list|,
name|defaultField
argument_list|)
expr_stmt|;
block|}
DECL|method|DisjunctionMaxQueryParser
specifier|public
name|DisjunctionMaxQueryParser
parameter_list|(
name|IndexSchema
name|s
parameter_list|)
block|{
name|this
argument_list|(
name|s
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add an alias to this query parser.      *      * @param field the field name that should trigger alias mapping      * @param fieldBoosts the mapping from fieldname to boost value that      *                    should be used to build up the clauses of the      *                    DisjunctionMaxQuery.      * @param tiebreaker to the tiebreaker to be used in the      *                   DisjunctionMaxQuery      * @see SolrPluginUtils#parseFieldBoosts      */
DECL|method|addAlias
specifier|public
name|void
name|addAlias
parameter_list|(
name|String
name|field
parameter_list|,
name|float
name|tiebreaker
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|fieldBoosts
parameter_list|)
block|{
name|Alias
name|a
init|=
operator|new
name|Alias
argument_list|()
decl_stmt|;
name|a
operator|.
name|tie
operator|=
name|tiebreaker
expr_stmt|;
name|a
operator|.
name|fields
operator|=
name|fieldBoosts
expr_stmt|;
name|aliases
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
comment|/**      * Delegates to the super class unless the field has been specified      * as an alias -- in which case we recurse on each of      * the aliased fields, and the results are composed into a      * DisjunctionMaxQuery.  (so yes: aliases which point at other      * aliases should work)      */
DECL|method|getFieldQuery
specifier|protected
name|Query
name|getFieldQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|queryText
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|aliases
operator|.
name|containsKey
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|Alias
name|a
init|=
name|aliases
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|DisjunctionMaxQuery
name|q
init|=
operator|new
name|DisjunctionMaxQuery
argument_list|(
name|a
operator|.
name|tie
argument_list|)
decl_stmt|;
comment|/* we might not get any valid queries from delegation,          * in which we should return null          */
name|boolean
name|ok
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|a
operator|.
name|fields
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Query
name|sub
init|=
name|getFieldQuery
argument_list|(
name|f
argument_list|,
name|queryText
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|sub
condition|)
block|{
if|if
condition|(
literal|null
operator|!=
name|a
operator|.
name|fields
operator|.
name|get
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|sub
operator|.
name|setBoost
argument_list|(
name|a
operator|.
name|fields
operator|.
name|get
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|q
operator|.
name|add
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|ok
condition|?
name|q
else|:
literal|null
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|getFieldQuery
argument_list|(
name|field
argument_list|,
name|queryText
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Determines the correct Sort based on the request parameter "sort"    *    * @return null if no sort is specified.    */
DECL|method|getSort
specifier|public
specifier|static
name|Sort
name|getSort
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|)
block|{
name|String
name|sort
init|=
name|req
operator|.
name|getParam
argument_list|(
literal|"sort"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|sort
operator|||
name|sort
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|SolrException
name|sortE
init|=
literal|null
decl_stmt|;
name|QueryParsing
operator|.
name|SortSpec
name|ss
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ss
operator|=
name|QueryParsing
operator|.
name|parseSort
argument_list|(
name|sort
argument_list|,
name|req
operator|.
name|getSchema
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|sortE
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|null
operator|==
name|ss
operator|)
operator|||
operator|(
literal|null
operator|!=
name|sortE
operator|)
condition|)
block|{
comment|/* we definitely had some sort of sort string from the user,        * but no SortSpec came out of it        */
name|SolrCore
operator|.
name|log
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"Invalid sort \""
operator|+
name|sort
operator|+
literal|"\" was specified, ignoring"
argument_list|,
name|sortE
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|ss
operator|.
name|getSort
argument_list|()
return|;
block|}
comment|/**    * A CacheRegenerator that can be used whenever the items in the cache    * are not dependant on the current searcher.    *    *<p>    * Flat out copies the oldKey=&gt;oldVal pair into the newCache    *</p>    */
DECL|class|IdentityRegenerator
specifier|public
specifier|static
class|class
name|IdentityRegenerator
implements|implements
name|CacheRegenerator
block|{
DECL|method|regenerateItem
specifier|public
name|boolean
name|regenerateItem
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|,
name|SolrCache
name|newCache
parameter_list|,
name|SolrCache
name|oldCache
parameter_list|,
name|Object
name|oldKey
parameter_list|,
name|Object
name|oldVal
parameter_list|)
throws|throws
name|IOException
block|{
name|newCache
operator|.
name|put
argument_list|(
name|oldKey
argument_list|,
name|oldVal
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
end_class
begin_comment
comment|/**   * Helper class which creates a single TokenStream out of values from a   * multi-valued field.  */
end_comment
begin_class
DECL|class|MultiValueTokenStream
class|class
name|MultiValueTokenStream
extends|extends
name|TokenStream
block|{
DECL|field|fieldName
specifier|private
name|String
name|fieldName
decl_stmt|;
DECL|field|values
specifier|private
name|String
index|[]
name|values
decl_stmt|;
DECL|field|analyzer
specifier|private
name|Analyzer
name|analyzer
decl_stmt|;
DECL|field|curIndex
specifier|private
name|int
name|curIndex
decl_stmt|;
comment|// next index into the values array
DECL|field|curOffset
specifier|private
name|int
name|curOffset
decl_stmt|;
comment|// offset into concatenated string
DECL|field|currentStream
specifier|private
name|TokenStream
name|currentStream
decl_stmt|;
comment|// tokenStream currently being iterated
DECL|field|orderTokenOffsets
specifier|private
name|boolean
name|orderTokenOffsets
decl_stmt|;
comment|/** Constructs a TokenStream for consecutively-analyzed field values    *    * @param fieldName name of the field    * @param values array of field data    * @param analyzer analyzer instance    */
DECL|method|MultiValueTokenStream
specifier|public
name|MultiValueTokenStream
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|String
index|[]
name|values
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|,
name|boolean
name|orderTokenOffsets
parameter_list|)
block|{
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
name|this
operator|.
name|values
operator|=
name|values
expr_stmt|;
name|this
operator|.
name|analyzer
operator|=
name|analyzer
expr_stmt|;
name|curIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|curOffset
operator|=
literal|0
expr_stmt|;
name|currentStream
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|orderTokenOffsets
operator|=
name|orderTokenOffsets
expr_stmt|;
block|}
comment|/** Returns the next token in the stream, or null at EOS. */
DECL|method|next
specifier|public
name|Token
name|next
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|extra
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|currentStream
operator|==
literal|null
condition|)
block|{
name|curIndex
operator|++
expr_stmt|;
if|if
condition|(
name|curIndex
operator|<
name|values
operator|.
name|length
condition|)
block|{
name|currentStream
operator|=
name|analyzer
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
operator|new
name|StringReader
argument_list|(
name|values
index|[
name|curIndex
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|orderTokenOffsets
condition|)
name|currentStream
operator|=
operator|new
name|TokenOrderingFilter
argument_list|(
name|currentStream
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|// add extra space between multiple values
if|if
condition|(
name|curIndex
operator|>
literal|0
condition|)
name|extra
operator|=
name|analyzer
operator|.
name|getPositionIncrementGap
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
name|Token
name|nextToken
init|=
name|currentStream
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextToken
operator|==
literal|null
condition|)
block|{
name|curOffset
operator|+=
name|values
index|[
name|curIndex
index|]
operator|.
name|length
argument_list|()
expr_stmt|;
name|currentStream
operator|=
literal|null
expr_stmt|;
return|return
name|next
argument_list|()
return|;
block|}
comment|// create an modified token which is the offset into the concatenated
comment|// string of all values
name|Token
name|offsetToken
init|=
operator|new
name|Token
argument_list|(
name|nextToken
operator|.
name|termText
argument_list|()
argument_list|,
name|nextToken
operator|.
name|startOffset
argument_list|()
operator|+
name|curOffset
argument_list|,
name|nextToken
operator|.
name|endOffset
argument_list|()
operator|+
name|curOffset
argument_list|)
decl_stmt|;
name|offsetToken
operator|.
name|setPositionIncrement
argument_list|(
name|nextToken
operator|.
name|getPositionIncrement
argument_list|()
operator|+
name|extra
operator|*
literal|10
argument_list|)
expr_stmt|;
return|return
name|offsetToken
return|;
block|}
comment|/**    * Returns all values as a single String into which the Tokens index with    * their offsets.    */
DECL|method|asSingleValue
specifier|public
name|String
name|asSingleValue
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|str
range|:
name|values
control|)
name|sb
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class
begin_comment
comment|/**  * A simple modification of SimpleFragmenter which additionally creates new  * fragments when an unusually-large position increment is encountered  * (this behaves much better in the presence of multi-valued fields).  */
end_comment
begin_class
DECL|class|GapFragmenter
class|class
name|GapFragmenter
extends|extends
name|SimpleFragmenter
block|{
DECL|field|INCREMENT_THRESHOLD
specifier|public
specifier|static
specifier|final
name|int
name|INCREMENT_THRESHOLD
init|=
literal|50
decl_stmt|;
DECL|field|fragOffsetAccum
specifier|protected
name|int
name|fragOffsetAccum
init|=
literal|0
decl_stmt|;
DECL|method|GapFragmenter
specifier|public
name|GapFragmenter
parameter_list|()
block|{   }
DECL|method|GapFragmenter
specifier|public
name|GapFragmenter
parameter_list|(
name|int
name|fragsize
parameter_list|)
block|{
name|super
argument_list|(
name|fragsize
argument_list|)
expr_stmt|;
block|}
comment|/* (non-Javadoc)    * @see org.apache.lucene.search.highlight.TextFragmenter#start(java.lang.String)    */
DECL|method|start
specifier|public
name|void
name|start
parameter_list|(
name|String
name|originalText
parameter_list|)
block|{
name|fragOffsetAccum
operator|=
literal|0
expr_stmt|;
block|}
comment|/* (non-Javadoc)    * @see org.apache.lucene.search.highlight.TextFragmenter#isNewFragment(org.apache.lucene.analysis.Token)    */
DECL|method|isNewFragment
specifier|public
name|boolean
name|isNewFragment
parameter_list|(
name|Token
name|token
parameter_list|)
block|{
name|boolean
name|isNewFrag
init|=
name|token
operator|.
name|endOffset
argument_list|()
operator|>=
name|fragOffsetAccum
operator|+
name|getFragmentSize
argument_list|()
operator|||
name|token
operator|.
name|getPositionIncrement
argument_list|()
operator|>
name|INCREMENT_THRESHOLD
decl_stmt|;
if|if
condition|(
name|isNewFrag
condition|)
block|{
name|fragOffsetAccum
operator|+=
name|token
operator|.
name|endOffset
argument_list|()
operator|-
name|fragOffsetAccum
expr_stmt|;
block|}
return|return
name|isNewFrag
return|;
block|}
block|}
end_class
begin_comment
comment|/** Orders Tokens in a window first by their startOffset ascending.  * endOffset is currently ignored.  * This is meant to work around fickleness in the highlighter only.  It  * can mess up token positions and should not be used for indexing or querying.  */
end_comment
begin_class
DECL|class|TokenOrderingFilter
class|class
name|TokenOrderingFilter
extends|extends
name|TokenFilter
block|{
DECL|field|windowSize
specifier|private
specifier|final
name|int
name|windowSize
decl_stmt|;
DECL|field|queue
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|Token
argument_list|>
name|queue
init|=
operator|new
name|LinkedList
argument_list|<
name|Token
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|done
specifier|private
name|boolean
name|done
init|=
literal|false
decl_stmt|;
DECL|method|TokenOrderingFilter
specifier|protected
name|TokenOrderingFilter
parameter_list|(
name|TokenStream
name|input
parameter_list|,
name|int
name|windowSize
parameter_list|)
block|{
name|super
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|this
operator|.
name|windowSize
operator|=
name|windowSize
expr_stmt|;
block|}
DECL|method|next
specifier|public
name|Token
name|next
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
operator|!
name|done
operator|&&
name|queue
operator|.
name|size
argument_list|()
operator|<
name|windowSize
condition|)
block|{
name|Token
name|newTok
init|=
name|input
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|newTok
operator|==
literal|null
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
comment|// reverse iterating for better efficiency since we know the
comment|// list is already sorted, and most token start offsets will be too.
name|ListIterator
argument_list|<
name|Token
argument_list|>
name|iter
init|=
name|queue
operator|.
name|listIterator
argument_list|(
name|queue
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasPrevious
argument_list|()
condition|)
block|{
if|if
condition|(
name|newTok
operator|.
name|startOffset
argument_list|()
operator|>=
name|iter
operator|.
name|previous
argument_list|()
operator|.
name|startOffset
argument_list|()
condition|)
block|{
comment|// insertion will be before what next() would return (what
comment|// we just compared against), so move back one so the insertion
comment|// will be after.
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|iter
operator|.
name|add
argument_list|(
name|newTok
argument_list|)
expr_stmt|;
block|}
return|return
name|queue
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|queue
operator|.
name|removeFirst
argument_list|()
return|;
block|}
block|}
end_class
end_unit
