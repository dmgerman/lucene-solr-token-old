begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.request
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Fieldable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|TextField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|DocList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_comment
comment|/**  * @author yonik  * @version $Id$  */
end_comment
begin_class
DECL|class|JSONResponseWriter
specifier|public
class|class
name|JSONResponseWriter
implements|implements
name|QueryResponseWriter
block|{
DECL|field|CONTENT_TYPE_JSON_UTF8
specifier|static
name|String
name|CONTENT_TYPE_JSON_UTF8
init|=
literal|"text/x-json; charset=UTF-8"
decl_stmt|;
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
name|NamedList
name|n
parameter_list|)
block|{   }
DECL|method|write
specifier|public
name|void
name|write
parameter_list|(
name|Writer
name|writer
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|)
throws|throws
name|IOException
block|{
name|JSONWriter
name|w
init|=
operator|new
name|JSONWriter
argument_list|(
name|writer
argument_list|,
name|req
argument_list|,
name|rsp
argument_list|)
decl_stmt|;
name|w
operator|.
name|writeResponse
argument_list|()
expr_stmt|;
block|}
DECL|method|getContentType
specifier|public
name|String
name|getContentType
parameter_list|(
name|SolrQueryRequest
name|request
parameter_list|,
name|SolrQueryResponse
name|response
parameter_list|)
block|{
comment|// using the text/plain allows this to be viewed in the browser easily
return|return
name|CONTENT_TYPE_TEXT_UTF8
return|;
block|}
block|}
end_class
begin_class
DECL|class|JSONWriter
class|class
name|JSONWriter
extends|extends
name|TextResponseWriter
block|{
comment|// cache the calendar instance in case we are writing many dates...
DECL|field|cal
specifier|private
name|Calendar
name|cal
decl_stmt|;
DECL|field|namedListStyle
specifier|private
name|String
name|namedListStyle
decl_stmt|;
DECL|field|wrapperFunction
specifier|private
name|String
name|wrapperFunction
decl_stmt|;
DECL|field|JSON_NL_STYLE
specifier|private
specifier|static
specifier|final
name|String
name|JSON_NL_STYLE
init|=
literal|"json.nl"
decl_stmt|;
DECL|field|JSON_NL_MAP
specifier|private
specifier|static
specifier|final
name|String
name|JSON_NL_MAP
init|=
literal|"map"
decl_stmt|;
DECL|field|JSON_NL_FLAT
specifier|private
specifier|static
specifier|final
name|String
name|JSON_NL_FLAT
init|=
literal|"flat"
decl_stmt|;
DECL|field|JSON_NL_ARROFARR
specifier|private
specifier|static
specifier|final
name|String
name|JSON_NL_ARROFARR
init|=
literal|"arrarr"
decl_stmt|;
DECL|field|JSON_NL_ARROFMAP
specifier|private
specifier|static
specifier|final
name|String
name|JSON_NL_ARROFMAP
init|=
literal|"arrmap"
decl_stmt|;
DECL|field|JSON_WRAPPER_FUNCTION
specifier|private
specifier|static
specifier|final
name|String
name|JSON_WRAPPER_FUNCTION
init|=
literal|"json.wrf"
decl_stmt|;
DECL|method|JSONWriter
specifier|public
name|JSONWriter
parameter_list|(
name|Writer
name|writer
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|)
block|{
name|super
argument_list|(
name|writer
argument_list|,
name|req
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
name|namedListStyle
operator|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|JSON_NL_STYLE
argument_list|,
name|JSON_NL_FLAT
argument_list|)
operator|.
name|intern
argument_list|()
expr_stmt|;
name|wrapperFunction
operator|=
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|JSON_WRAPPER_FUNCTION
argument_list|)
expr_stmt|;
block|}
DECL|method|writeResponse
specifier|public
name|void
name|writeResponse
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|wrapperFunction
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|write
argument_list|(
name|wrapperFunction
operator|+
literal|"("
argument_list|)
expr_stmt|;
block|}
name|writeNamedList
argument_list|(
literal|null
argument_list|,
name|rsp
operator|.
name|getValues
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrapperFunction
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|write
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeKey
specifier|protected
name|void
name|writeKey
parameter_list|(
name|String
name|fname
parameter_list|,
name|boolean
name|needsEscaping
parameter_list|)
throws|throws
name|IOException
block|{
name|writeStr
argument_list|(
literal|null
argument_list|,
name|fname
argument_list|,
name|needsEscaping
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
block|}
comment|/** Represents a NamedList directly as a JSON Object (essentially a Map)    * Map null to "" and name mangle any repeated keys to avoid repeats in the    * output.    */
DECL|method|writeNamedListAsMapMangled
specifier|protected
name|void
name|writeNamedListAsMapMangled
parameter_list|(
name|String
name|name
parameter_list|,
name|NamedList
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|sz
init|=
name|val
operator|.
name|size
argument_list|()
decl_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|incLevel
argument_list|()
expr_stmt|;
comment|// In JSON objects (maps) we can't have null keys or duplicates...
comment|// map null to "" and append a qualifier to duplicates.
comment|//
comment|// a=123,a=456 will be mapped to {a=1,a__1=456}
comment|// Disad: this is ambiguous since a real key could be called a__1
comment|//
comment|// Another possible mapping could aggregate multiple keys to an array:
comment|// a=123,a=456 maps to a=[123,456]
comment|// Disad: this is ambiguous with a real single value that happens to be an array
comment|//
comment|// Both of these mappings have ambiguities.
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|repeats
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|String
name|key
init|=
name|val
operator|.
name|getName
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
name|key
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
name|repeats
operator|.
name|put
argument_list|(
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|Integer
name|repeatCount
init|=
name|repeats
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|repeatCount
operator|==
literal|null
condition|)
block|{
name|repeats
operator|.
name|put
argument_list|(
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|newKey
init|=
name|key
decl_stmt|;
name|int
name|newCount
init|=
name|repeatCount
decl_stmt|;
do|do
block|{
comment|// avoid generated key clashing with a real key
name|newKey
operator|=
name|key
operator|+
literal|' '
operator|+
operator|(
operator|++
name|newCount
operator|)
expr_stmt|;
name|repeatCount
operator|=
name|repeats
operator|.
name|get
argument_list|(
name|newKey
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|repeatCount
operator|!=
literal|null
condition|)
do|;
name|repeats
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|newCount
argument_list|)
expr_stmt|;
name|key
operator|=
name|newKey
expr_stmt|;
block|}
block|}
name|indent
argument_list|()
expr_stmt|;
name|writeKey
argument_list|(
name|key
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|writeVal
argument_list|(
name|key
argument_list|,
name|val
operator|.
name|getVal
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|decLevel
argument_list|()
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
comment|/** Represents a NamedList directly as a JSON Object (essentially a Map)    * repeating any keys if they are repeated in the NamedList.  null is mapped    * to "".    */
DECL|method|writeNamedListAsMapWithDups
specifier|protected
name|void
name|writeNamedListAsMapWithDups
parameter_list|(
name|String
name|name
parameter_list|,
name|NamedList
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|sz
init|=
name|val
operator|.
name|size
argument_list|()
decl_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|incLevel
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|writer
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|String
name|key
init|=
name|val
operator|.
name|getName
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
name|key
operator|=
literal|""
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|writeKey
argument_list|(
name|key
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|writeVal
argument_list|(
name|key
argument_list|,
name|val
operator|.
name|getVal
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|decLevel
argument_list|()
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
comment|// Represents a NamedList directly as an array of JSON objects...
comment|// NamedList("a"=1,"b"=2,null=3) => [{"a":1},{"b":2},3]
DECL|method|writeNamedListAsArrMap
specifier|protected
name|void
name|writeNamedListAsArrMap
parameter_list|(
name|String
name|name
parameter_list|,
name|NamedList
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|sz
init|=
name|val
operator|.
name|size
argument_list|()
decl_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|incLevel
argument_list|()
expr_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|String
name|key
init|=
name|val
operator|.
name|getName
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|indent
argument_list|()
expr_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
name|writeVal
argument_list|(
literal|null
argument_list|,
name|val
operator|.
name|getVal
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|write
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|writeKey
argument_list|(
name|key
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|writeVal
argument_list|(
name|key
argument_list|,
name|val
operator|.
name|getVal
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
block|}
name|decLevel
argument_list|()
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
comment|// Represents a NamedList directly as an array of JSON objects...
comment|// NamedList("a"=1,"b"=2,null=3) => [["a",1],["b",2],[null,3]]
DECL|method|writeNamedListAsArrArr
specifier|protected
name|void
name|writeNamedListAsArrArr
parameter_list|(
name|String
name|name
parameter_list|,
name|NamedList
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|sz
init|=
name|val
operator|.
name|size
argument_list|()
decl_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|incLevel
argument_list|()
expr_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|String
name|key
init|=
name|val
operator|.
name|getName
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|indent
argument_list|()
expr_stmt|;
comment|/*** if key is null, just write value???       if (key==null) {         writeVal(null,val.getVal(i));       } else {      ***/
name|writer
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|incLevel
argument_list|()
expr_stmt|;
name|writeStr
argument_list|(
literal|null
argument_list|,
name|key
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|writeVal
argument_list|(
name|key
argument_list|,
name|val
operator|.
name|getVal
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|decLevel
argument_list|()
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|decLevel
argument_list|()
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
comment|// Represents a NamedList directly as an array with keys/values
comment|// interleaved.
comment|// NamedList("a"=1,"b"=2,null=3) => ["a",1,"b",2,null,3]
DECL|method|writeNamedListAsFlat
specifier|protected
name|void
name|writeNamedListAsFlat
parameter_list|(
name|String
name|name
parameter_list|,
name|NamedList
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|sz
init|=
name|val
operator|.
name|size
argument_list|()
decl_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|incLevel
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|writer
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|String
name|key
init|=
name|val
operator|.
name|getName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|indent
argument_list|()
expr_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
name|writeNull
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeStr
argument_list|(
literal|null
argument_list|,
name|key
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|writeVal
argument_list|(
name|key
argument_list|,
name|val
operator|.
name|getVal
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|decLevel
argument_list|()
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
DECL|method|writeNamedList
specifier|public
name|void
name|writeNamedList
parameter_list|(
name|String
name|name
parameter_list|,
name|NamedList
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|val
operator|instanceof
name|SimpleOrderedMap
condition|)
block|{
name|writeNamedListAsMapWithDups
argument_list|(
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|namedListStyle
operator|==
name|JSON_NL_FLAT
condition|)
block|{
name|writeNamedListAsFlat
argument_list|(
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|namedListStyle
operator|==
name|JSON_NL_MAP
condition|)
block|{
name|writeNamedListAsMapWithDups
argument_list|(
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|namedListStyle
operator|==
name|JSON_NL_ARROFARR
condition|)
block|{
name|writeNamedListAsArrArr
argument_list|(
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|namedListStyle
operator|==
name|JSON_NL_ARROFMAP
condition|)
block|{
name|writeNamedListAsArrMap
argument_list|(
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|MultiValueField
specifier|private
specifier|static
class|class
name|MultiValueField
block|{
DECL|field|sfield
specifier|final
name|SchemaField
name|sfield
decl_stmt|;
DECL|field|fields
specifier|final
name|ArrayList
argument_list|<
name|Fieldable
argument_list|>
name|fields
decl_stmt|;
DECL|method|MultiValueField
name|MultiValueField
parameter_list|(
name|SchemaField
name|sfield
parameter_list|,
name|Fieldable
name|firstVal
parameter_list|)
block|{
name|this
operator|.
name|sfield
operator|=
name|sfield
expr_stmt|;
name|this
operator|.
name|fields
operator|=
operator|new
name|ArrayList
argument_list|<
name|Fieldable
argument_list|>
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|this
operator|.
name|fields
operator|.
name|add
argument_list|(
name|firstVal
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeDoc
specifier|public
name|void
name|writeDoc
parameter_list|(
name|String
name|name
parameter_list|,
name|Collection
argument_list|<
name|Fieldable
argument_list|>
name|fields
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|returnFields
parameter_list|,
name|Map
name|pseudoFields
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|write
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|incLevel
argument_list|()
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|MultiValueField
argument_list|>
name|multi
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|MultiValueField
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Fieldable
name|ff
range|:
name|fields
control|)
block|{
name|String
name|fname
init|=
name|ff
operator|.
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
name|returnFields
operator|!=
literal|null
operator|&&
operator|!
name|returnFields
operator|.
name|contains
argument_list|(
name|fname
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// if the field is multivalued, it may have other values further on... so
comment|// build up a list for each multi-valued field.
name|SchemaField
name|sf
init|=
name|schema
operator|.
name|getField
argument_list|(
name|fname
argument_list|)
decl_stmt|;
if|if
condition|(
name|sf
operator|.
name|multiValued
argument_list|()
condition|)
block|{
name|MultiValueField
name|mf
init|=
name|multi
operator|.
name|get
argument_list|(
name|fname
argument_list|)
decl_stmt|;
if|if
condition|(
name|mf
operator|==
literal|null
condition|)
block|{
name|mf
operator|=
operator|new
name|MultiValueField
argument_list|(
name|sf
argument_list|,
name|ff
argument_list|)
expr_stmt|;
name|multi
operator|.
name|put
argument_list|(
name|fname
argument_list|,
name|mf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mf
operator|.
name|fields
operator|.
name|add
argument_list|(
name|ff
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// not multi-valued, so write it immediately.
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|indent
argument_list|()
expr_stmt|;
name|writeKey
argument_list|(
name|fname
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|sf
operator|.
name|write
argument_list|(
name|this
argument_list|,
name|fname
argument_list|,
name|ff
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|MultiValueField
name|mvf
range|:
name|multi
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|indent
argument_list|()
expr_stmt|;
name|writeKey
argument_list|(
name|mvf
operator|.
name|sfield
operator|.
name|getName
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|boolean
name|indentArrElems
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|doIndent
condition|)
block|{
comment|// heuristic... TextField is probably the only field type likely to be long enough
comment|// to warrant indenting individual values.
name|indentArrElems
operator|=
operator|(
name|mvf
operator|.
name|sfield
operator|.
name|getType
argument_list|()
operator|instanceof
name|TextField
operator|)
expr_stmt|;
block|}
name|writer
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|boolean
name|firstArrElem
init|=
literal|true
decl_stmt|;
name|incLevel
argument_list|()
expr_stmt|;
for|for
control|(
name|Fieldable
name|ff
range|:
name|mvf
operator|.
name|fields
control|)
block|{
if|if
condition|(
name|firstArrElem
condition|)
block|{
name|firstArrElem
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indentArrElems
condition|)
name|indent
argument_list|()
expr_stmt|;
name|mvf
operator|.
name|sfield
operator|.
name|write
argument_list|(
name|this
argument_list|,
literal|null
argument_list|,
name|ff
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|decLevel
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pseudoFields
operator|!=
literal|null
operator|&&
name|pseudoFields
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|writeMap
argument_list|(
literal|null
argument_list|,
name|pseudoFields
argument_list|,
literal|true
argument_list|,
name|first
argument_list|)
expr_stmt|;
block|}
name|decLevel
argument_list|()
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
comment|// reusable map to store the "score" pseudo-field.
comment|// if a Doc can ever contain another doc, this optimization would have to go.
DECL|field|scoreMap
specifier|private
specifier|final
name|HashMap
name|scoreMap
init|=
operator|new
name|HashMap
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|method|writeDoc
specifier|public
name|void
name|writeDoc
parameter_list|(
name|String
name|name
parameter_list|,
name|Document
name|doc
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|returnFields
parameter_list|,
name|float
name|score
parameter_list|,
name|boolean
name|includeScore
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
name|other
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|includeScore
condition|)
block|{
name|other
operator|=
name|scoreMap
expr_stmt|;
name|scoreMap
operator|.
name|put
argument_list|(
literal|"score"
argument_list|,
name|score
argument_list|)
expr_stmt|;
block|}
name|writeDoc
argument_list|(
name|name
argument_list|,
call|(
name|List
argument_list|<
name|Fieldable
argument_list|>
call|)
argument_list|(
name|doc
operator|.
name|getFields
argument_list|()
argument_list|)
argument_list|,
name|returnFields
argument_list|,
name|other
argument_list|)
expr_stmt|;
block|}
DECL|method|writeDocList
specifier|public
name|void
name|writeDocList
parameter_list|(
name|String
name|name
parameter_list|,
name|DocList
name|ids
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|,
name|Map
name|otherFields
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|includeScore
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|fields
operator|!=
literal|null
condition|)
block|{
name|includeScore
operator|=
name|fields
operator|.
name|contains
argument_list|(
literal|"score"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
operator|(
name|fields
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|includeScore
operator|)
operator|||
name|fields
operator|.
name|contains
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|fields
operator|=
literal|null
expr_stmt|;
comment|// null means return all stored fields
block|}
block|}
name|int
name|sz
init|=
name|ids
operator|.
name|size
argument_list|()
decl_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|incLevel
argument_list|()
expr_stmt|;
name|writeKey
argument_list|(
literal|"numFound"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|writeInt
argument_list|(
literal|null
argument_list|,
name|ids
operator|.
name|matches
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|writeKey
argument_list|(
literal|"start"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|writeInt
argument_list|(
literal|null
argument_list|,
name|ids
operator|.
name|offset
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|includeScore
condition|)
block|{
name|writer
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|writeKey
argument_list|(
literal|"maxScore"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|writeFloat
argument_list|(
literal|null
argument_list|,
name|ids
operator|.
name|maxScore
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
comment|// indent();
name|writeKey
argument_list|(
literal|"docs"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|incLevel
argument_list|()
expr_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
name|SolrIndexSearcher
name|searcher
init|=
name|req
operator|.
name|getSearcher
argument_list|()
decl_stmt|;
name|DocIterator
name|iterator
init|=
name|ids
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|int
name|id
init|=
name|iterator
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
name|Document
name|doc
init|=
name|searcher
operator|.
name|doc
argument_list|(
name|id
argument_list|,
name|fields
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|indent
argument_list|()
expr_stmt|;
name|writeDoc
argument_list|(
literal|null
argument_list|,
name|doc
argument_list|,
name|fields
argument_list|,
operator|(
name|includeScore
condition|?
name|iterator
operator|.
name|score
argument_list|()
else|:
literal|0.0f
operator|)
argument_list|,
name|includeScore
argument_list|)
expr_stmt|;
block|}
name|decLevel
argument_list|()
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|otherFields
operator|!=
literal|null
condition|)
block|{
name|writeMap
argument_list|(
literal|null
argument_list|,
name|otherFields
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|decLevel
argument_list|()
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
DECL|method|writeStr
specifier|public
name|void
name|writeStr
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|val
parameter_list|,
name|boolean
name|needsEscaping
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|write
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
comment|// it might be more efficient to use a stringbuilder or write substrings
comment|// if writing chars to the stream is slow.
if|if
condition|(
name|needsEscaping
condition|)
block|{
comment|/* http://www.ietf.org/internet-drafts/draft-crockford-jsonorg-json-04.txt       All Unicode characters may be placed within       the quotation marks except for the characters which must be       escaped: quotation mark, reverse solidus, and the control       characters (U+0000 through U+001F).      */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|val
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
init|=
name|val
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
name|writer
operator|.
name|write
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|writer
operator|.
name|write
argument_list|(
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|writer
operator|.
name|write
argument_list|(
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|writer
operator|.
name|write
argument_list|(
literal|"\\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|writer
operator|.
name|write
argument_list|(
literal|"\\b"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|writer
operator|.
name|write
argument_list|(
literal|"\\f"
argument_list|)
expr_stmt|;
break|break;
comment|// case '/':
default|default:
block|{
if|if
condition|(
name|ch
operator|<=
literal|0x1F
condition|)
block|{
name|unicodeEscape
argument_list|(
name|writer
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|writer
operator|.
name|write
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|write
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
DECL|method|writeMap
specifier|public
name|void
name|writeMap
parameter_list|(
name|String
name|name
parameter_list|,
name|Map
name|val
parameter_list|,
name|boolean
name|excludeOuter
parameter_list|,
name|boolean
name|isFirstVal
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|excludeOuter
condition|)
block|{
name|writer
operator|.
name|write
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|incLevel
argument_list|()
expr_stmt|;
name|isFirstVal
operator|=
literal|true
expr_stmt|;
block|}
name|boolean
name|doIndent
init|=
name|excludeOuter
operator|||
name|val
operator|.
name|size
argument_list|()
operator|>
literal|1
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
name|entry
range|:
operator|(
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|>
operator|)
name|val
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
name|e
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|k
init|=
name|e
operator|==
literal|null
condition|?
literal|""
else|:
name|e
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Object
name|v
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|isFirstVal
condition|)
block|{
name|isFirstVal
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doIndent
condition|)
name|indent
argument_list|()
expr_stmt|;
name|writeKey
argument_list|(
name|k
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|writeVal
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|excludeOuter
condition|)
block|{
name|decLevel
argument_list|()
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeArray
specifier|public
name|void
name|writeArray
parameter_list|(
name|String
name|name
parameter_list|,
name|Object
index|[]
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|writeArray
argument_list|(
name|name
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|writeArray
specifier|public
name|void
name|writeArray
parameter_list|(
name|String
name|name
parameter_list|,
name|Collection
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|int
name|sz
init|=
name|val
operator|.
name|size
argument_list|()
decl_stmt|;
name|incLevel
argument_list|()
expr_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|val
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sz
operator|>
literal|1
condition|)
name|indent
argument_list|()
expr_stmt|;
name|writeVal
argument_list|(
literal|null
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
name|decLevel
argument_list|()
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Primitive types
comment|//
DECL|method|writeNull
specifier|public
name|void
name|writeNull
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|write
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
block|}
DECL|method|writeInt
specifier|public
name|void
name|writeInt
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|write
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
DECL|method|writeLong
specifier|public
name|void
name|writeLong
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|write
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
DECL|method|writeBool
specifier|public
name|void
name|writeBool
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|write
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
DECL|method|writeFloat
specifier|public
name|void
name|writeFloat
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|write
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
DECL|method|writeDouble
specifier|public
name|void
name|writeDouble
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|write
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
comment|// TODO: refactor this out to a DateUtils class or something...
DECL|method|writeDate
specifier|public
name|void
name|writeDate
parameter_list|(
name|String
name|name
parameter_list|,
name|Date
name|val
parameter_list|)
throws|throws
name|IOException
block|{
comment|// using a stringBuilder for numbers can be nice since
comment|// a temporary string isn't used (it's added directly to the
comment|// builder's buffer.
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|cal
operator|==
literal|null
condition|)
name|cal
operator|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"GMT"
argument_list|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|setTime
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|int
name|i
init|=
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|i
operator|=
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|// 0 based, so add 1
if|if
condition|(
name|i
operator|<
literal|10
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|i
operator|=
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|10
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
name|i
operator|=
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|)
expr_stmt|;
comment|// 24 hour time format
if|if
condition|(
name|i
operator|<
literal|10
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|i
operator|=
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|10
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|i
operator|=
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|SECOND
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|10
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MILLISECOND
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|100
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|10
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// handle canonical format specifying fractional
comment|// seconds shall not end in '0'.  Given the slowness of
comment|// integer div/mod, simply checking the last character
comment|// is probably the fastest way to check.
name|int
name|lastIdx
init|=
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|sb
operator|.
name|charAt
argument_list|(
name|lastIdx
argument_list|)
operator|==
literal|'0'
condition|)
block|{
name|lastIdx
operator|--
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|charAt
argument_list|(
name|lastIdx
argument_list|)
operator|==
literal|'0'
condition|)
block|{
name|lastIdx
operator|--
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|lastIdx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
literal|'Z'
argument_list|)
expr_stmt|;
name|writeDate
argument_list|(
name|name
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|writeDate
specifier|public
name|void
name|writeDate
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|writeStr
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|unicodeEscape
specifier|protected
specifier|static
name|void
name|unicodeEscape
parameter_list|(
name|Appendable
name|sb
parameter_list|,
name|int
name|ch
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|str
init|=
name|Integer
operator|.
name|toHexString
argument_list|(
name|ch
operator|&
literal|0xffff
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|str
operator|.
name|length
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\\u000"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\\u00"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\\u0"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sb
operator|.
name|append
argument_list|(
literal|"\\u"
argument_list|)
expr_stmt|;
break|break;
block|}
name|sb
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
end_class
begin_class
DECL|class|PythonWriter
class|class
name|PythonWriter
extends|extends
name|JSONWriter
block|{
DECL|method|PythonWriter
specifier|public
name|PythonWriter
parameter_list|(
name|Writer
name|writer
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|)
block|{
name|super
argument_list|(
name|writer
argument_list|,
name|req
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeNull
specifier|public
name|void
name|writeNull
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|write
argument_list|(
literal|"None"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeBool
specifier|public
name|void
name|writeBool
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|write
argument_list|(
name|val
condition|?
literal|"True"
else|:
literal|"False"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeBool
specifier|public
name|void
name|writeBool
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|writeBool
argument_list|(
name|name
argument_list|,
name|val
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'t'
argument_list|)
expr_stmt|;
block|}
comment|/* optionally use a unicode python string if necessary */
annotation|@
name|Override
DECL|method|writeStr
specifier|public
name|void
name|writeStr
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|val
parameter_list|,
name|boolean
name|needsEscaping
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|needsEscaping
condition|)
block|{
name|writer
operator|.
name|write
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// use python unicode strings...
comment|// python doesn't tolerate newlines in strings in it's eval(), so we must escape them.
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|val
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|needUnicode
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|val
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
init|=
name|val
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\\'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\\t"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// we don't strictly have to escape these chars, but it will probably increase
comment|// portability to stick to visible ascii
if|if
condition|(
name|ch
argument_list|<
literal|' '
operator|||
name|ch
argument_list|>
literal|127
condition|)
block|{
name|unicodeEscape
argument_list|(
name|sb
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|needUnicode
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|writer
operator|.
name|write
argument_list|(
name|needUnicode
condition|?
literal|"u'"
else|:
literal|"'"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|append
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
comment|/*   old version that always used unicode   public void writeStr(String name, String val, boolean needsEscaping) throws IOException {     // use python unicode strings...     // python doesn't tolerate newlines in strings in it's eval(), so we must escape them.     writer.write("u'");     // it might be more efficient to use a stringbuilder or write substrings     // if writing chars to the stream is slow.     if (needsEscaping) {       for (int i=0; i<val.length(); i++) {         char ch = val.charAt(i);         switch(ch) {           case '\'':           case '\\': writer.write('\\'); writer.write(ch); break;           case '\r': writer.write("\\r"); break;           case '\n': writer.write("\\n"); break;           default:             // we don't strictly have to escape these chars, but it will probably increase             // portability to stick to visible ascii             if (ch<' ' || ch>127) {               unicodeChar(ch);             } else {               writer.write(ch);             }         }       }     } else {       writer.write(val);     }     writer.write('\'');   }   */
block|}
end_class
begin_class
DECL|class|RubyWriter
class|class
name|RubyWriter
extends|extends
name|JSONWriter
block|{
DECL|method|RubyWriter
specifier|public
name|RubyWriter
parameter_list|(
name|Writer
name|writer
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|)
block|{
name|super
argument_list|(
name|writer
argument_list|,
name|req
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeNull
specifier|public
name|void
name|writeNull
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|write
argument_list|(
literal|"nil"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeKey
specifier|protected
name|void
name|writeKey
parameter_list|(
name|String
name|fname
parameter_list|,
name|boolean
name|needsEscaping
parameter_list|)
throws|throws
name|IOException
block|{
name|writeStr
argument_list|(
literal|null
argument_list|,
name|fname
argument_list|,
name|needsEscaping
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|"=>"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeStr
specifier|public
name|void
name|writeStr
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|val
parameter_list|,
name|boolean
name|needsEscaping
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Ruby doesn't do unicode escapes... so let the servlet container write raw UTF-8
comment|// bytes into the string.
comment|//
comment|// Use single quoted strings for safety since no evaluation is done within them.
comment|// Also, there are very few escapes recognized in a single quoted string, so
comment|// only escape the backslash and single quote.
name|writer
operator|.
name|write
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
comment|// it might be more efficient to use a stringbuilder or write substrings
comment|// if writing chars to the stream is slow.
if|if
condition|(
name|needsEscaping
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|val
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
init|=
name|val
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\\'
case|:
name|writer
operator|.
name|write
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
default|default:
name|writer
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|writer
operator|.
name|write
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|write
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
block|}
end_class
end_unit
