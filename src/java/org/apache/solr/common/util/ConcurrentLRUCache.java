begin_unit
begin_package
DECL|package|org.apache.solr.common.util
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import
begin_comment
comment|/**  * A LRU cache implementation based upon ConcurrentHashMap and other techniques to reduce  * contention and synchronization overhead to utilize multiple CPU cores more effectively.  *<p/>  * Note that the implementation does not follow a true LRU (least-recently-used) eviction  * strategy. Instead it strives to remove least recently used items but when the initial  * cleanup does not remove enough items to reach the 'acceptableWaterMark' limit, it can  * remove more items forcefully regardless of access order.  *  * @version $Id$  * @since solr 1.4  */
end_comment
begin_class
DECL|class|ConcurrentLRUCache
specifier|public
class|class
name|ConcurrentLRUCache
block|{
DECL|field|map
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|Object
argument_list|,
name|CacheEntry
argument_list|>
name|map
decl_stmt|;
DECL|field|upperWaterMark
DECL|field|lowerWaterMark
specifier|private
specifier|final
name|int
name|upperWaterMark
decl_stmt|,
name|lowerWaterMark
decl_stmt|;
DECL|field|stop
specifier|private
specifier|volatile
name|boolean
name|stop
init|=
literal|false
decl_stmt|;
DECL|field|markAndSweepLock
specifier|private
specifier|final
name|ReentrantLock
name|markAndSweepLock
init|=
operator|new
name|ReentrantLock
argument_list|(
literal|true
argument_list|)
decl_stmt|;
DECL|field|isCleaning
specifier|private
specifier|volatile
name|boolean
name|isCleaning
init|=
literal|false
decl_stmt|;
DECL|field|newThreadForCleanup
specifier|private
specifier|final
name|boolean
name|newThreadForCleanup
decl_stmt|;
DECL|field|islive
specifier|private
specifier|volatile
name|boolean
name|islive
init|=
literal|true
decl_stmt|;
DECL|field|stats
specifier|private
specifier|final
name|Stats
name|stats
init|=
operator|new
name|Stats
argument_list|()
decl_stmt|;
DECL|field|acceptableWaterMark
specifier|private
specifier|final
name|int
name|acceptableWaterMark
decl_stmt|;
DECL|method|ConcurrentLRUCache
specifier|public
name|ConcurrentLRUCache
parameter_list|(
name|int
name|upperWaterMark
parameter_list|,
specifier|final
name|int
name|lowerWaterMark
parameter_list|,
name|int
name|acceptableWatermark
parameter_list|,
name|int
name|initialSize
parameter_list|,
name|boolean
name|runCleanupThread
parameter_list|,
name|boolean
name|runNewThreadForCleanup
parameter_list|,
specifier|final
name|int
name|delay
parameter_list|)
block|{
if|if
condition|(
name|upperWaterMark
operator|<
literal|1
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"upperWaterMark must be> 0"
argument_list|)
throw|;
if|if
condition|(
name|lowerWaterMark
operator|>=
name|upperWaterMark
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"lowerWaterMark must be< upperWaterMark"
argument_list|)
throw|;
name|map
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|Object
argument_list|,
name|CacheEntry
argument_list|>
argument_list|(
name|initialSize
argument_list|)
expr_stmt|;
name|newThreadForCleanup
operator|=
name|runNewThreadForCleanup
expr_stmt|;
name|this
operator|.
name|upperWaterMark
operator|=
name|upperWaterMark
expr_stmt|;
name|this
operator|.
name|lowerWaterMark
operator|=
name|lowerWaterMark
expr_stmt|;
name|this
operator|.
name|acceptableWaterMark
operator|=
name|acceptableWatermark
expr_stmt|;
if|if
condition|(
name|runCleanupThread
condition|)
block|{
operator|new
name|Thread
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|stop
condition|)
break|break;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|delay
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|/*no op*/
block|}
name|markAndSweep
argument_list|()
expr_stmt|;
block|}
block|}
block|}
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setAlive
specifier|public
name|void
name|setAlive
parameter_list|(
name|boolean
name|live
parameter_list|)
block|{
name|islive
operator|=
name|live
expr_stmt|;
block|}
DECL|method|get
specifier|public
name|Object
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|CacheEntry
name|e
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|islive
condition|)
name|stats
operator|.
name|missCounter
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|islive
condition|)
name|e
operator|.
name|lastAccessed
operator|=
name|stats
operator|.
name|accessCounter
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
name|e
operator|.
name|value
return|;
block|}
DECL|method|remove
specifier|public
name|Object
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|CacheEntry
name|cacheEntry
init|=
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|cacheEntry
operator|!=
literal|null
condition|)
block|{
name|stats
operator|.
name|size
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
return|return
name|cacheEntry
operator|.
name|value
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|put
specifier|public
name|Object
name|put
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|CacheEntry
name|e
init|=
operator|new
name|CacheEntry
argument_list|(
name|key
argument_list|,
name|val
argument_list|,
name|stats
operator|.
name|accessCounter
operator|.
name|incrementAndGet
argument_list|()
argument_list|)
decl_stmt|;
name|CacheEntry
name|oldCacheEntry
init|=
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldCacheEntry
operator|==
literal|null
condition|)
block|{
name|stats
operator|.
name|size
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|islive
condition|)
block|{
name|stats
operator|.
name|putCounter
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|stats
operator|.
name|nonLivePutCounter
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|// Check if we need to clear out old entries from the cache.
comment|// isCleaning variable is checked instead of markAndSweepLock.isLocked()
comment|// for performance because every put invokation will check until
comment|// the size is back to an acceptable level.
comment|//
comment|// There is a race between the check and the call to markAndSweep, but
comment|// it's unimportant because markAndSweep actually aquires the lock or returns if it can't.
if|if
condition|(
name|stats
operator|.
name|size
operator|.
name|get
argument_list|()
operator|>
name|upperWaterMark
operator|&&
operator|!
name|isCleaning
condition|)
block|{
if|if
condition|(
name|newThreadForCleanup
condition|)
block|{
operator|new
name|Thread
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
name|markAndSweep
argument_list|()
expr_stmt|;
block|}
block|}
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|markAndSweep
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|oldCacheEntry
operator|==
literal|null
condition|?
literal|null
else|:
name|oldCacheEntry
operator|.
name|value
return|;
block|}
comment|/**    * Removes items from the cache to bring the size down    * to an acceptable value ('acceptableWaterMark').    *<p/>    * It is done in two stages. In the first stage, least recently used items are evicted.    * If, after the first stage, the cache size is still greater than 'acceptableSize'    * config parameter, the second stage takes over.    *<p/>    * The second stage is more intensive and tries to bring down the cache size    * to the 'minSize' config parameter.    */
DECL|method|markAndSweep
specifier|public
name|void
name|markAndSweep
parameter_list|()
block|{
if|if
condition|(
operator|!
name|markAndSweepLock
operator|.
name|tryLock
argument_list|()
condition|)
return|return;
try|try
block|{
name|isCleaning
operator|=
literal|true
expr_stmt|;
name|int
name|size
init|=
name|stats
operator|.
name|size
operator|.
name|get
argument_list|()
decl_stmt|;
name|long
name|currentLatestAccessed
init|=
name|stats
operator|.
name|accessCounter
operator|.
name|get
argument_list|()
decl_stmt|;
name|int
name|itemsToBeRemoved
init|=
name|size
operator|-
name|lowerWaterMark
decl_stmt|;
name|int
name|itemsRemoved
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|itemsToBeRemoved
operator|<
literal|1
condition|)
return|return;
comment|// currentLatestAccessed is the counter value of the item accessed most recently
comment|// therefore remove all items whose last accessed counter is less than (currentLatestAccessed - lowerWaterMark)
name|long
name|removeOlderThan
init|=
name|currentLatestAccessed
operator|-
name|lowerWaterMark
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|CacheEntry
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|lastAccessed
operator|<=
name|removeOlderThan
operator|&&
name|itemsRemoved
operator|<
name|itemsToBeRemoved
condition|)
block|{
name|evictEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Since the removal of items in the above loop depends on the value of the lastAccessed variable,
comment|// between the time we recorded the number of items to be removed and the actual removal process,
comment|// some items may graduate above the removeOlderThan value and escape eviction.
comment|// Therefore, we again check if the size less than acceptableWaterMark, if not we remove items forcefully
comment|// using a method which does not depend on the value of lastAccessed but can be more costly to run
name|size
operator|=
name|stats
operator|.
name|size
operator|.
name|get
argument_list|()
expr_stmt|;
comment|// In the first attempt, try to use a simple algorithm to remove old entries
comment|// If the size of the cache is<= acceptableWatermark then return
if|if
condition|(
name|size
operator|<=
name|acceptableWaterMark
condition|)
return|return;
comment|// Remove items until size becomes lower than acceptableWaterMark
name|itemsToBeRemoved
operator|=
name|size
operator|-
name|acceptableWaterMark
expr_stmt|;
name|TreeSet
argument_list|<
name|CacheEntry
argument_list|>
name|tree
init|=
operator|new
name|TreeSet
argument_list|<
name|CacheEntry
argument_list|>
argument_list|()
decl_stmt|;
comment|// This loop may remove a few newer items because we try to forcefully fill a
comment|// bucket of fixed size and remove them even if they have become newer in the meantime
comment|// The caveat is that this may lead to more cache misses because we may have removed
comment|// an item which was used very recently (against the philosophy of LRU)
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|CacheEntry
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|CacheEntry
name|v
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|v
operator|.
name|lastAccessedCopy
operator|=
name|v
operator|.
name|lastAccessed
expr_stmt|;
if|if
condition|(
name|tree
operator|.
name|size
argument_list|()
operator|<
name|itemsToBeRemoved
condition|)
block|{
name|tree
operator|.
name|add
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|v
operator|.
name|lastAccessedCopy
operator|<
name|tree
operator|.
name|first
argument_list|()
operator|.
name|lastAccessedCopy
condition|)
block|{
name|tree
operator|.
name|remove
argument_list|(
name|tree
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
name|tree
operator|.
name|add
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|CacheEntry
name|sortCacheEntry
range|:
name|tree
control|)
name|evictEntry
argument_list|(
name|sortCacheEntry
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|isCleaning
operator|=
literal|false
expr_stmt|;
name|markAndSweepLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|evictEntry
specifier|private
name|void
name|evictEntry
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|Object
name|o
init|=
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
return|return;
name|stats
operator|.
name|size
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
name|stats
operator|.
name|evictionCounter
operator|++
expr_stmt|;
block|}
DECL|method|getLatestAccessedItems
specifier|public
name|Map
name|getLatestAccessedItems
parameter_list|(
name|long
name|n
parameter_list|)
block|{
name|markAndSweepLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|Map
name|result
init|=
operator|new
name|LinkedHashMap
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|CacheEntry
argument_list|>
name|tree
init|=
operator|new
name|TreeSet
argument_list|<
name|CacheEntry
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|CacheEntry
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|CacheEntry
name|ce
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ce
operator|.
name|lastAccessedCopy
operator|=
name|ce
operator|.
name|lastAccessed
expr_stmt|;
if|if
condition|(
name|tree
operator|.
name|size
argument_list|()
operator|<
name|n
condition|)
block|{
name|tree
operator|.
name|add
argument_list|(
name|ce
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ce
operator|.
name|lastAccessedCopy
operator|>
name|tree
operator|.
name|last
argument_list|()
operator|.
name|lastAccessedCopy
condition|)
block|{
name|tree
operator|.
name|remove
argument_list|(
name|tree
operator|.
name|last
argument_list|()
argument_list|)
expr_stmt|;
name|tree
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|markAndSweepLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|CacheEntry
name|e
range|:
name|tree
control|)
block|{
name|result
operator|.
name|put
argument_list|(
name|e
operator|.
name|key
argument_list|,
name|e
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|stats
operator|.
name|size
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|getMap
specifier|public
name|Map
argument_list|<
name|Object
argument_list|,
name|CacheEntry
argument_list|>
name|getMap
parameter_list|()
block|{
return|return
name|map
return|;
block|}
DECL|class|CacheEntry
specifier|private
specifier|static
class|class
name|CacheEntry
implements|implements
name|Comparable
argument_list|<
name|CacheEntry
argument_list|>
block|{
DECL|field|key
DECL|field|value
name|Object
name|key
decl_stmt|,
name|value
decl_stmt|;
DECL|field|lastAccessed
specifier|volatile
name|long
name|lastAccessed
init|=
literal|0
decl_stmt|;
DECL|field|lastAccessedCopy
name|long
name|lastAccessedCopy
init|=
literal|0
decl_stmt|;
DECL|method|CacheEntry
specifier|public
name|CacheEntry
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|,
name|long
name|lastAccessed
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|this
operator|.
name|lastAccessed
operator|=
name|lastAccessed
expr_stmt|;
block|}
DECL|method|setLastAccessed
specifier|public
name|void
name|setLastAccessed
parameter_list|(
name|long
name|lastAccessed
parameter_list|)
block|{
name|this
operator|.
name|lastAccessed
operator|=
name|lastAccessed
expr_stmt|;
block|}
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|CacheEntry
name|that
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|lastAccessedCopy
operator|==
name|that
operator|.
name|lastAccessedCopy
condition|)
return|return
literal|0
return|;
return|return
name|this
operator|.
name|lastAccessedCopy
operator|<
name|that
operator|.
name|lastAccessedCopy
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|value
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|value
operator|.
name|equals
argument_list|(
name|obj
argument_list|)
return|;
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"key: "
operator|+
name|key
operator|+
literal|" value: "
operator|+
name|value
operator|+
literal|" lastAccessed:"
operator|+
name|lastAccessed
return|;
block|}
block|}
DECL|method|destroy
specifier|public
name|void
name|destroy
parameter_list|()
block|{
name|stop
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|getStats
specifier|public
name|Stats
name|getStats
parameter_list|()
block|{
return|return
name|stats
return|;
block|}
DECL|method|finalize
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
name|destroy
argument_list|()
expr_stmt|;
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
block|}
DECL|class|Stats
specifier|public
specifier|static
class|class
name|Stats
block|{
DECL|field|accessCounter
specifier|private
specifier|final
name|AtomicLong
name|accessCounter
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|,
DECL|field|putCounter
name|putCounter
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|,
DECL|field|nonLivePutCounter
name|nonLivePutCounter
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|,
DECL|field|missCounter
name|missCounter
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|size
specifier|private
specifier|final
name|AtomicInteger
name|size
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|evictionCounter
specifier|private
name|long
name|evictionCounter
init|=
literal|0
decl_stmt|;
DECL|method|getCumulativeLookups
specifier|public
name|long
name|getCumulativeLookups
parameter_list|()
block|{
return|return
operator|(
name|accessCounter
operator|.
name|get
argument_list|()
operator|-
name|putCounter
operator|.
name|get
argument_list|()
operator|-
name|nonLivePutCounter
operator|.
name|get
argument_list|()
operator|)
operator|+
name|missCounter
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|getCumulativeHits
specifier|public
name|long
name|getCumulativeHits
parameter_list|()
block|{
return|return
name|accessCounter
operator|.
name|get
argument_list|()
operator|-
name|putCounter
operator|.
name|get
argument_list|()
operator|-
name|nonLivePutCounter
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|getCumulativePuts
specifier|public
name|long
name|getCumulativePuts
parameter_list|()
block|{
return|return
name|putCounter
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|getCumulativeEvictions
specifier|public
name|long
name|getCumulativeEvictions
parameter_list|()
block|{
return|return
name|evictionCounter
return|;
block|}
DECL|method|getCurrentSize
specifier|public
name|int
name|getCurrentSize
parameter_list|()
block|{
return|return
name|size
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|getCumulativeNonLivePuts
specifier|public
name|long
name|getCumulativeNonLivePuts
parameter_list|()
block|{
return|return
name|nonLivePutCounter
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|getCumulativeMisses
specifier|public
name|long
name|getCumulativeMisses
parameter_list|()
block|{
return|return
name|missCounter
operator|.
name|get
argument_list|()
return|;
block|}
block|}
block|}
end_class
end_unit
