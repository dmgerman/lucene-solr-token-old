begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.schema
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Fieldable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|QueryParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|ResourceLoader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|DOMUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|Config
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrResourceLoader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analysis
operator|.
name|CharFilterFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analysis
operator|.
name|TokenFilterFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analysis
operator|.
name|TokenizerChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analysis
operator|.
name|TokenizerFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrQueryParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|plugin
operator|.
name|AbstractPluginLoader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|plugin
operator|.
name|SolrCoreAware
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|*
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPath
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathConstants
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathExpressionException
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathFactory
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import
begin_comment
comment|/**  *<code>IndexSchema</code> contains information about the valid fields in an index  * and the types of those fields.  *  * @version $Id$  */
end_comment
begin_class
DECL|class|IndexSchema
specifier|public
specifier|final
class|class
name|IndexSchema
block|{
DECL|field|DEFAULT_SCHEMA_FILE
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_SCHEMA_FILE
init|=
literal|"schema.xml"
decl_stmt|;
DECL|field|log
specifier|final
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|IndexSchema
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|solrConfig
specifier|private
specifier|final
name|SolrConfig
name|solrConfig
decl_stmt|;
DECL|field|resourceName
specifier|private
specifier|final
name|String
name|resourceName
decl_stmt|;
DECL|field|name
specifier|private
name|String
name|name
decl_stmt|;
DECL|field|version
specifier|private
name|float
name|version
decl_stmt|;
DECL|field|loader
specifier|private
specifier|final
name|SolrResourceLoader
name|loader
decl_stmt|;
comment|/**    * Constructs a schema using the specified file name using the normal    * Config path directory searching rules.    *    * @see Config#openResource    * @deprecated Use {@link #IndexSchema(SolrConfig, String, InputStream)} instead.    */
annotation|@
name|Deprecated
DECL|method|IndexSchema
specifier|public
name|IndexSchema
parameter_list|(
name|SolrConfig
name|solrConfig
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|this
argument_list|(
name|solrConfig
argument_list|,
name|name
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs a schema using the specified resource name and stream.    * If the is stream is null, the resource loader will load the schema resource by name.    * @see SolrResourceLoader#openSchema    * By default, this follows the normal config path directory searching rules.    * @see Config#openResource    */
DECL|method|IndexSchema
specifier|public
name|IndexSchema
parameter_list|(
name|SolrConfig
name|solrConfig
parameter_list|,
name|String
name|name
parameter_list|,
name|InputStream
name|is
parameter_list|)
block|{
name|this
operator|.
name|solrConfig
operator|=
name|solrConfig
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|null
condition|)
name|name
operator|=
name|DEFAULT_SCHEMA_FILE
expr_stmt|;
name|this
operator|.
name|resourceName
operator|=
name|name
expr_stmt|;
name|loader
operator|=
name|solrConfig
operator|.
name|getResourceLoader
argument_list|()
expr_stmt|;
name|InputStream
name|lis
init|=
name|is
decl_stmt|;
if|if
condition|(
name|lis
operator|==
literal|null
condition|)
name|lis
operator|=
name|loader
operator|.
name|openSchema
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|readSchema
argument_list|(
name|lis
argument_list|)
expr_stmt|;
if|if
condition|(
name|lis
operator|!=
name|is
condition|)
block|{
try|try
block|{
name|lis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|xio
parameter_list|)
block|{}
comment|// ignore
block|}
name|loader
operator|.
name|inform
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated -- get access to SolrConfig some other way...    */
DECL|method|getSolrConfig
specifier|public
name|SolrConfig
name|getSolrConfig
parameter_list|()
block|{
return|return
name|solrConfig
return|;
block|}
comment|/**    * @since solr 1.4    */
DECL|method|getResourceLoader
specifier|public
name|SolrResourceLoader
name|getResourceLoader
parameter_list|()
block|{
return|return
name|loader
return|;
block|}
comment|/** Gets the name of the resource used to instantiate this schema. */
DECL|method|getResourceName
specifier|public
name|String
name|getResourceName
parameter_list|()
block|{
return|return
name|resourceName
return|;
block|}
comment|/** Gets the name of the schema as specified in the schema resource. */
DECL|method|getSchemaName
specifier|public
name|String
name|getSchemaName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|getVersion
name|float
name|getVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
comment|/**    * Direct access to the InputStream for the schemaFile used by this instance.    * @see Config#openResource    * @deprecated Use {@link #getSolrConfig()} and open a resource input stream    *             for {@link #getResourceName()} instead.    */
annotation|@
name|Deprecated
DECL|method|getInputStream
specifier|public
name|InputStream
name|getInputStream
parameter_list|()
block|{
return|return
name|loader
operator|.
name|openResource
argument_list|(
name|resourceName
argument_list|)
return|;
block|}
comment|/** Gets the name of the schema file.    * @deprecated Use {@link #getResourceName()} instead.    */
annotation|@
name|Deprecated
DECL|method|getSchemaFile
specifier|public
name|String
name|getSchemaFile
parameter_list|()
block|{
return|return
name|resourceName
return|;
block|}
comment|/** The Name of this schema (as specified in the schema file)    * @deprecated Use {@link #getSchemaName()} instead.    */
annotation|@
name|Deprecated
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|field|fields
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|SchemaField
argument_list|>
name|fields
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SchemaField
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|fieldTypes
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
name|fieldTypes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|fieldsWithDefaultValue
specifier|private
specifier|final
name|List
argument_list|<
name|SchemaField
argument_list|>
name|fieldsWithDefaultValue
init|=
operator|new
name|ArrayList
argument_list|<
name|SchemaField
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|requiredFields
specifier|private
specifier|final
name|Collection
argument_list|<
name|SchemaField
argument_list|>
name|requiredFields
init|=
operator|new
name|HashSet
argument_list|<
name|SchemaField
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Provides direct access to the Map containing all explicit    * (ie: non-dynamic) fields in the index, keyed on field name.    *    *<p>    * Modifying this Map (or any item in it) will affect the real schema    *</p>    *     *<p>    * NOTE: this function is not thread safe.  However, it is safe to use within the standard    *<code>inform( SolrCore core )</code> function for<code>SolrCoreAware</code> classes.    * Outside<code>inform</code>, this could potentially throw a ConcurrentModificationException    *</p>    */
DECL|method|getFields
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|SchemaField
argument_list|>
name|getFields
parameter_list|()
block|{
return|return
name|fields
return|;
block|}
comment|/**    * Provides direct access to the Map containing all Field Types    * in the index, keyed on field type name.    *    *<p>    * Modifying this Map (or any item in it) will affect the real schema.  However if you     * make any modifications, be sure to call {@link IndexSchema#refreshAnalyzers()} to    * update the Analyzers for the registered fields.    *</p>    *     *<p>    * NOTE: this function is not thread safe.  However, it is safe to use within the standard    *<code>inform( SolrCore core )</code> function for<code>SolrCoreAware</code> classes.    * Outside<code>inform</code>, this could potentially throw a ConcurrentModificationException    *</p>    */
DECL|method|getFieldTypes
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
name|getFieldTypes
parameter_list|()
block|{
return|return
name|fieldTypes
return|;
block|}
comment|/**    * Provides direct access to the List containing all fields with a default value    */
DECL|method|getFieldsWithDefaultValue
specifier|public
name|List
argument_list|<
name|SchemaField
argument_list|>
name|getFieldsWithDefaultValue
parameter_list|()
block|{
return|return
name|fieldsWithDefaultValue
return|;
block|}
comment|/**    * Provides direct access to the List containing all required fields.  This    * list contains all fields with default values.    */
DECL|method|getRequiredFields
specifier|public
name|Collection
argument_list|<
name|SchemaField
argument_list|>
name|getRequiredFields
parameter_list|()
block|{
return|return
name|requiredFields
return|;
block|}
DECL|field|similarityFactory
specifier|private
name|SimilarityFactory
name|similarityFactory
decl_stmt|;
comment|/**    * Returns the Similarity used for this index    */
DECL|method|getSimilarity
specifier|public
name|Similarity
name|getSimilarity
parameter_list|()
block|{
return|return
name|similarityFactory
operator|.
name|getSimilarity
argument_list|()
return|;
block|}
comment|/**    * Returns the SimilarityFactory used for this index    */
DECL|method|getSimilarityFactory
specifier|public
name|SimilarityFactory
name|getSimilarityFactory
parameter_list|()
block|{
return|return
name|similarityFactory
return|;
block|}
DECL|field|analyzer
specifier|private
name|Analyzer
name|analyzer
decl_stmt|;
comment|/**    * Returns the Analyzer used when indexing documents for this index    *    *<p>    * This Analyzer is field (and dynamic field) name aware, and delegates to    * a field specific Analyzer based on the field type.    *</p>    */
DECL|method|getAnalyzer
specifier|public
name|Analyzer
name|getAnalyzer
parameter_list|()
block|{
return|return
name|analyzer
return|;
block|}
DECL|field|queryAnalyzer
specifier|private
name|Analyzer
name|queryAnalyzer
decl_stmt|;
comment|/**    * Returns the Analyzer used when searching this index    *    *<p>    * This Analyzer is field (and dynamic field) name aware, and delegates to    * a field specific Analyzer based on the field type.    *</p>    */
DECL|method|getQueryAnalyzer
specifier|public
name|Analyzer
name|getQueryAnalyzer
parameter_list|()
block|{
return|return
name|queryAnalyzer
return|;
block|}
DECL|field|defaultSearchFieldName
specifier|private
name|String
name|defaultSearchFieldName
init|=
literal|null
decl_stmt|;
DECL|field|queryParserDefaultOperator
specifier|private
name|String
name|queryParserDefaultOperator
init|=
literal|"OR"
decl_stmt|;
comment|/**    * A SolrQueryParser linked to this IndexSchema for field datatype    * information, and populated with default options from the    *&lt;solrQueryParser&gt; configuration for this IndexSchema.    *    * @param defaultField if non-null overrides the schema default    * @deprecated    */
DECL|method|getSolrQueryParser
specifier|public
name|SolrQueryParser
name|getSolrQueryParser
parameter_list|(
name|String
name|defaultField
parameter_list|)
block|{
name|SolrQueryParser
name|qp
init|=
operator|new
name|SolrQueryParser
argument_list|(
name|this
argument_list|,
name|defaultField
argument_list|)
decl_stmt|;
name|String
name|operator
init|=
name|getQueryParserDefaultOperator
argument_list|()
decl_stmt|;
name|qp
operator|.
name|setDefaultOperator
argument_list|(
literal|"AND"
operator|.
name|equals
argument_list|(
name|operator
argument_list|)
condition|?
name|QueryParser
operator|.
name|Operator
operator|.
name|AND
else|:
name|QueryParser
operator|.
name|Operator
operator|.
name|OR
argument_list|)
expr_stmt|;
return|return
name|qp
return|;
block|}
comment|/**    * Name of the default search field specified in the schema file    */
DECL|method|getDefaultSearchFieldName
specifier|public
name|String
name|getDefaultSearchFieldName
parameter_list|()
block|{
return|return
name|defaultSearchFieldName
return|;
block|}
comment|/**    * default operator ("AND" or "OR") for QueryParser    * @deprecated use getSolrQueryParser().getDefaultOperator()    */
annotation|@
name|Deprecated
DECL|method|getQueryParserDefaultOperator
specifier|public
name|String
name|getQueryParserDefaultOperator
parameter_list|()
block|{
return|return
name|queryParserDefaultOperator
return|;
block|}
DECL|field|uniqueKeyField
specifier|private
name|SchemaField
name|uniqueKeyField
decl_stmt|;
comment|/**    * Unique Key field specified in the schema file    * @return null if this schema has no unique key field    */
DECL|method|getUniqueKeyField
specifier|public
name|SchemaField
name|getUniqueKeyField
parameter_list|()
block|{
return|return
name|uniqueKeyField
return|;
block|}
DECL|field|uniqueKeyFieldName
specifier|private
name|String
name|uniqueKeyFieldName
decl_stmt|;
DECL|field|uniqueKeyFieldType
specifier|private
name|FieldType
name|uniqueKeyFieldType
decl_stmt|;
comment|/**    * The raw (field type encoded) value of the Unique Key field for    * the specified Document    * @return null if this schema has no unique key field    * @see #printableUniqueKey    */
DECL|method|getUniqueKeyField
specifier|public
name|Fieldable
name|getUniqueKeyField
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
name|doc
parameter_list|)
block|{
return|return
name|doc
operator|.
name|getFieldable
argument_list|(
name|uniqueKeyFieldName
argument_list|)
return|;
comment|// this should return null if name is null
block|}
comment|/**    * The printable value of the Unique Key field for    * the specified Document    * @return null if this schema has no unique key field    */
DECL|method|printableUniqueKey
specifier|public
name|String
name|printableUniqueKey
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
name|doc
parameter_list|)
block|{
name|Fieldable
name|f
init|=
name|doc
operator|.
name|getFieldable
argument_list|(
name|uniqueKeyFieldName
argument_list|)
decl_stmt|;
return|return
name|f
operator|==
literal|null
condition|?
literal|null
else|:
name|uniqueKeyFieldType
operator|.
name|toExternal
argument_list|(
name|f
argument_list|)
return|;
block|}
DECL|method|getIndexedField
specifier|private
name|SchemaField
name|getIndexedField
parameter_list|(
name|String
name|fname
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|getFields
argument_list|()
operator|.
name|get
argument_list|(
name|fname
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unknown field '"
operator|+
name|fname
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|f
operator|.
name|indexed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"'"
operator|+
name|fname
operator|+
literal|"' is not an indexed field:"
operator|+
name|f
argument_list|)
throw|;
block|}
return|return
name|f
return|;
block|}
comment|/**    * This will re-create the Analyzers.  If you make any modifications to    * the Field map ({@link IndexSchema#getFields()}, this function is required    * to synch the internally cached field analyzers.    *     * @since solr 1.3    */
DECL|method|refreshAnalyzers
specifier|public
name|void
name|refreshAnalyzers
parameter_list|()
block|{
name|analyzer
operator|=
operator|new
name|SolrIndexAnalyzer
argument_list|()
expr_stmt|;
name|queryAnalyzer
operator|=
operator|new
name|SolrQueryAnalyzer
argument_list|()
expr_stmt|;
block|}
DECL|class|SolrIndexAnalyzer
specifier|private
class|class
name|SolrIndexAnalyzer
extends|extends
name|Analyzer
block|{
DECL|field|analyzers
specifier|protected
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|analyzers
decl_stmt|;
DECL|method|SolrIndexAnalyzer
name|SolrIndexAnalyzer
parameter_list|()
block|{
name|analyzers
operator|=
name|analyzerCache
argument_list|()
expr_stmt|;
block|}
DECL|method|analyzerCache
specifier|protected
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|analyzerCache
parameter_list|()
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|cache
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SchemaField
name|f
range|:
name|getFields
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|Analyzer
name|analyzer
init|=
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getAnalyzer
argument_list|()
decl_stmt|;
name|cache
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
return|return
name|cache
return|;
block|}
DECL|method|getAnalyzer
specifier|protected
name|Analyzer
name|getAnalyzer
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Analyzer
name|analyzer
init|=
name|analyzers
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
return|return
name|analyzer
operator|!=
literal|null
condition|?
name|analyzer
else|:
name|getDynamicFieldType
argument_list|(
name|fieldName
argument_list|)
operator|.
name|getAnalyzer
argument_list|()
return|;
block|}
DECL|method|tokenStream
specifier|public
name|TokenStream
name|tokenStream
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
return|return
name|getAnalyzer
argument_list|(
name|fieldName
argument_list|)
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
name|reader
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getPositionIncrementGap
specifier|public
name|int
name|getPositionIncrementGap
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
name|getAnalyzer
argument_list|(
name|fieldName
argument_list|)
operator|.
name|getPositionIncrementGap
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
block|}
DECL|class|SolrQueryAnalyzer
specifier|private
class|class
name|SolrQueryAnalyzer
extends|extends
name|SolrIndexAnalyzer
block|{
annotation|@
name|Override
DECL|method|analyzerCache
specifier|protected
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|analyzerCache
parameter_list|()
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|cache
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SchemaField
name|f
range|:
name|getFields
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|Analyzer
name|analyzer
init|=
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getQueryAnalyzer
argument_list|()
decl_stmt|;
name|cache
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
return|return
name|cache
return|;
block|}
annotation|@
name|Override
DECL|method|getAnalyzer
specifier|protected
name|Analyzer
name|getAnalyzer
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Analyzer
name|analyzer
init|=
name|analyzers
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
return|return
name|analyzer
operator|!=
literal|null
condition|?
name|analyzer
else|:
name|getDynamicFieldType
argument_list|(
name|fieldName
argument_list|)
operator|.
name|getQueryAnalyzer
argument_list|()
return|;
block|}
block|}
DECL|method|readSchema
specifier|private
name|void
name|readSchema
parameter_list|(
name|InputStream
name|is
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Reading Solr Schema"
argument_list|)
expr_stmt|;
try|try
block|{
comment|// pass the config resource loader to avoid building an empty one for no reason:
comment|// in the current case though, the stream is valid so we wont load the resource by name
name|Config
name|schemaConf
init|=
operator|new
name|Config
argument_list|(
name|loader
argument_list|,
literal|"schema"
argument_list|,
name|is
argument_list|,
literal|"/schema/"
argument_list|)
decl_stmt|;
name|Document
name|document
init|=
name|schemaConf
operator|.
name|getDocument
argument_list|()
decl_stmt|;
specifier|final
name|XPath
name|xpath
init|=
name|schemaConf
operator|.
name|getXPath
argument_list|()
decl_stmt|;
name|Node
name|nd
init|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"/schema/@name"
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|nd
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"schema has no name!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|nd
operator|.
name|getNodeValue
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Schema name="
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
name|version
operator|=
name|schemaConf
operator|.
name|getFloat
argument_list|(
literal|"/schema/@version"
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
specifier|final
name|IndexSchema
name|schema
init|=
name|this
decl_stmt|;
name|AbstractPluginLoader
argument_list|<
name|FieldType
argument_list|>
name|fieldLoader
init|=
operator|new
name|AbstractPluginLoader
argument_list|<
name|FieldType
argument_list|>
argument_list|(
literal|"[schema.xml] fieldType"
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|FieldType
name|create
parameter_list|(
name|ResourceLoader
name|loader
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|className
parameter_list|,
name|Node
name|node
parameter_list|)
throws|throws
name|Exception
block|{
name|FieldType
name|ft
init|=
operator|(
name|FieldType
operator|)
name|loader
operator|.
name|newInstance
argument_list|(
name|className
argument_list|)
decl_stmt|;
name|ft
operator|.
name|setTypeName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|String
name|expression
init|=
literal|"./analyzer[@type='query']"
decl_stmt|;
name|Node
name|anode
init|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|node
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
decl_stmt|;
name|Analyzer
name|queryAnalyzer
init|=
name|readAnalyzer
argument_list|(
name|anode
argument_list|)
decl_stmt|;
comment|// An analyzer without a type specified, or with type="index"
name|expression
operator|=
literal|"./analyzer[not(@type)] | ./analyzer[@type='index']"
expr_stmt|;
name|anode
operator|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|node
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
expr_stmt|;
name|Analyzer
name|analyzer
init|=
name|readAnalyzer
argument_list|(
name|anode
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryAnalyzer
operator|==
literal|null
condition|)
name|queryAnalyzer
operator|=
name|analyzer
expr_stmt|;
if|if
condition|(
name|analyzer
operator|==
literal|null
condition|)
name|analyzer
operator|=
name|queryAnalyzer
expr_stmt|;
if|if
condition|(
name|analyzer
operator|!=
literal|null
condition|)
block|{
name|ft
operator|.
name|setAnalyzer
argument_list|(
name|analyzer
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setQueryAnalyzer
argument_list|(
name|queryAnalyzer
argument_list|)
expr_stmt|;
block|}
return|return
name|ft
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|init
parameter_list|(
name|FieldType
name|plugin
parameter_list|,
name|Node
name|node
parameter_list|)
throws|throws
name|Exception
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|params
init|=
name|DOMUtil
operator|.
name|toMapExcept
argument_list|(
name|node
operator|.
name|getAttributes
argument_list|()
argument_list|,
literal|"name"
argument_list|,
literal|"class"
argument_list|)
decl_stmt|;
name|plugin
operator|.
name|setArgs
argument_list|(
name|schema
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|FieldType
name|register
parameter_list|(
name|String
name|name
parameter_list|,
name|FieldType
name|plugin
parameter_list|)
throws|throws
name|Exception
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"fieldtype defined: "
operator|+
name|plugin
argument_list|)
expr_stmt|;
return|return
name|fieldTypes
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|plugin
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|String
name|expression
init|=
literal|"/schema/types/fieldtype | /schema/types/fieldType"
decl_stmt|;
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
name|fieldLoader
operator|.
name|load
argument_list|(
name|loader
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
comment|// Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|explicitRequiredProp
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|DynamicField
argument_list|>
name|dFields
init|=
operator|new
name|ArrayList
argument_list|<
name|DynamicField
argument_list|>
argument_list|()
decl_stmt|;
name|expression
operator|=
literal|"/schema/fields/field | /schema/fields/dynamicField"
expr_stmt|;
name|nodes
operator|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|,
literal|"field definition"
argument_list|)
decl_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"reading field def "
operator|+
name|name
argument_list|)
expr_stmt|;
name|String
name|type
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"type"
argument_list|,
literal|"field "
operator|+
name|name
argument_list|)
decl_stmt|;
name|FieldType
name|ft
init|=
name|fieldTypes
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ft
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Unknown fieldtype '"
operator|+
name|type
operator|+
literal|"' specified on field "
operator|+
name|name
argument_list|,
literal|false
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
name|DOMUtil
operator|.
name|toMapExcept
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|,
literal|"type"
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|get
argument_list|(
literal|"required"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|explicitRequiredProp
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|Boolean
operator|.
name|valueOf
argument_list|(
name|args
operator|.
name|get
argument_list|(
literal|"required"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SchemaField
name|f
init|=
name|SchemaField
operator|.
name|create
argument_list|(
name|name
argument_list|,
name|ft
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getNodeName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"field"
argument_list|)
condition|)
block|{
name|SchemaField
name|old
init|=
name|fields
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"[schema.xml] Duplicate field definition for '"
operator|+
name|f
operator|.
name|getName
argument_list|()
operator|+
literal|"' ignoring: "
operator|+
name|old
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Throwable
name|t
init|=
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
decl_stmt|;
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|SolrConfig
operator|.
name|severeErrors
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"field defined: "
operator|+
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|getDefaultValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
name|name
operator|+
literal|" contains default value: "
operator|+
name|f
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
name|fieldsWithDefaultValue
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|isRequired
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
name|name
operator|+
literal|" is required in this schema"
argument_list|)
expr_stmt|;
name|requiredFields
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|getNodeName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"dynamicField"
argument_list|)
condition|)
block|{
comment|// make sure nothing else has the same path
name|boolean
name|dup
init|=
literal|false
decl_stmt|;
for|for
control|(
name|DynamicField
name|df
range|:
name|dFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|regex
operator|.
name|equals
argument_list|(
name|f
operator|.
name|name
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"[schema.xml] Duplicate DynamicField definition for '"
operator|+
name|f
operator|.
name|getName
argument_list|()
operator|+
literal|"' ignoring: "
operator|+
name|f
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Throwable
name|t
init|=
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
decl_stmt|;
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|SolrConfig
operator|.
name|severeErrors
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|dup
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|dup
condition|)
block|{
name|dFields
operator|.
name|add
argument_list|(
operator|new
name|DynamicField
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"dynamic field defined: "
operator|+
name|f
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// we should never get here
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown field type"
argument_list|)
throw|;
block|}
block|}
comment|//fields with default values are by definition required
comment|//add them to required fields, and we only have to loop once
comment|// in DocumentBuilder.getDoc()
name|requiredFields
operator|.
name|addAll
argument_list|(
name|getFieldsWithDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// OK, now sort the dynamic fields largest to smallest size so we don't get
comment|// any false matches.  We want to act like a compiler tool and try and match
comment|// the largest string possible.
name|Collections
operator|.
name|sort
argument_list|(
name|dFields
argument_list|)
expr_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"Dynamic Field Ordering:"
operator|+
name|dFields
argument_list|)
expr_stmt|;
comment|// stuff it in a normal array for faster access
name|dynamicFields
operator|=
operator|(
name|DynamicField
index|[]
operator|)
name|dFields
operator|.
name|toArray
argument_list|(
operator|new
name|DynamicField
index|[
name|dFields
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|Node
name|node
init|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"/schema/similarity"
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|similarityFactory
operator|=
operator|new
name|SimilarityFactory
argument_list|()
block|{
specifier|public
name|Similarity
name|getSimilarity
parameter_list|()
block|{
return|return
name|Similarity
operator|.
name|getDefault
argument_list|()
return|;
block|}
block|}
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"using default similarity"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|Object
name|obj
init|=
name|loader
operator|.
name|newInstance
argument_list|(
operator|(
operator|(
name|Element
operator|)
name|node
operator|)
operator|.
name|getAttribute
argument_list|(
literal|"class"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|obj
operator|instanceof
name|SimilarityFactory
condition|)
block|{
comment|// configure a factory, get a similarity back
name|SolrParams
name|params
init|=
name|SolrParams
operator|.
name|toSolrParams
argument_list|(
name|DOMUtil
operator|.
name|childNodesToNamedList
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
name|similarityFactory
operator|=
operator|(
name|SimilarityFactory
operator|)
name|obj
expr_stmt|;
name|similarityFactory
operator|.
name|init
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// just like always, assume it's a Similarlity and get an ClassCastException - reasonable error handling
name|similarityFactory
operator|=
operator|new
name|SimilarityFactory
argument_list|()
block|{
specifier|public
name|Similarity
name|getSimilarity
parameter_list|()
block|{
return|return
operator|(
name|Similarity
operator|)
name|obj
return|;
block|}
block|}
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"using similarity factory"
operator|+
name|similarityFactory
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"/schema/defaultSearchField/text()"
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"no default search field specified in schema."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|defaultSearchFieldName
operator|=
name|node
operator|.
name|getNodeValue
argument_list|()
operator|.
name|trim
argument_list|()
expr_stmt|;
comment|// throw exception if specified, but not found or not indexed
if|if
condition|(
name|defaultSearchFieldName
operator|!=
literal|null
condition|)
block|{
name|SchemaField
name|defaultSearchField
init|=
name|getFields
argument_list|()
operator|.
name|get
argument_list|(
name|defaultSearchFieldName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|defaultSearchField
operator|==
literal|null
operator|)
operator|||
operator|!
name|defaultSearchField
operator|.
name|indexed
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
literal|"default search field '"
operator|+
name|defaultSearchFieldName
operator|+
literal|"' not defined or not indexed"
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"default search field is "
operator|+
name|defaultSearchFieldName
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"/schema/solrQueryParser/@defaultOperator"
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"using default query parser operator (OR)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queryParserDefaultOperator
operator|=
name|node
operator|.
name|getNodeValue
argument_list|()
operator|.
name|trim
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"query parser default operator is "
operator|+
name|queryParserDefaultOperator
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"/schema/uniqueKey/text()"
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"no uniqueKey specified in schema."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uniqueKeyField
operator|=
name|getIndexedField
argument_list|(
name|node
operator|.
name|getNodeValue
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|uniqueKeyFieldName
operator|=
name|uniqueKeyField
operator|.
name|getName
argument_list|()
expr_stmt|;
name|uniqueKeyFieldType
operator|=
name|uniqueKeyField
operator|.
name|getType
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"unique key field: "
operator|+
name|uniqueKeyFieldName
argument_list|)
expr_stmt|;
comment|// Unless the uniqueKeyField is marked 'required=false' then make sure it exists
if|if
condition|(
name|Boolean
operator|.
name|FALSE
operator|!=
name|explicitRequiredProp
operator|.
name|get
argument_list|(
name|uniqueKeyFieldName
argument_list|)
condition|)
block|{
name|uniqueKeyField
operator|.
name|required
operator|=
literal|true
expr_stmt|;
name|requiredFields
operator|.
name|add
argument_list|(
name|uniqueKeyField
argument_list|)
expr_stmt|;
block|}
block|}
comment|/////////////// parse out copyField commands ///////////////
comment|// Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();
comment|// expression = "/schema/copyField";
name|dynamicCopyFields
operator|=
operator|new
name|DynamicCopy
index|[]
block|{}
expr_stmt|;
name|expression
operator|=
literal|"//copyField"
expr_stmt|;
name|nodes
operator|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|source
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"source"
argument_list|,
literal|"copyField definition"
argument_list|)
decl_stmt|;
name|String
name|dest
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"dest"
argument_list|,
literal|"copyField definition"
argument_list|)
decl_stmt|;
name|String
name|maxChars
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"maxChars"
argument_list|)
decl_stmt|;
name|int
name|maxCharsInt
init|=
name|CopyField
operator|.
name|UNLIMITED
decl_stmt|;
if|if
condition|(
name|maxChars
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|maxCharsInt
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|maxChars
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Couldn't parse maxChars attribute for copyField from "
operator|+
name|source
operator|+
literal|" to "
operator|+
name|dest
operator|+
literal|" as integer. The whole field will be copied."
argument_list|)
expr_stmt|;
block|}
block|}
name|registerCopyField
argument_list|(
name|source
argument_list|,
name|dest
argument_list|,
name|maxCharsInt
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|SchemaField
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|copyFieldTargetCounts
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|>
literal|1
operator|&&
operator|!
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|multiValued
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Field "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|name
operator|+
literal|" is not multivalued "
operator|+
literal|"and destination for multiple copyFields ("
operator|+
name|entry
operator|.
name|getValue
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|SolrConfig
operator|.
name|severeErrors
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// unexpected exception...
name|SolrConfig
operator|.
name|severeErrors
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Schema Parsing Failed"
argument_list|,
name|e
argument_list|,
literal|false
argument_list|)
throw|;
block|}
comment|// create the field analyzers
name|refreshAnalyzers
argument_list|()
expr_stmt|;
block|}
DECL|method|registerCopyField
specifier|public
name|void
name|registerCopyField
parameter_list|(
name|String
name|source
parameter_list|,
name|String
name|dest
parameter_list|)
block|{
name|registerCopyField
argument_list|(
name|source
argument_list|,
name|dest
argument_list|,
name|CopyField
operator|.
name|UNLIMITED
argument_list|)
expr_stmt|;
block|}
comment|/**    *<p>    * NOTE: this function is not thread safe.  However, it is safe to use within the standard    *<code>inform( SolrCore core )</code> function for<code>SolrCoreAware</code> classes.    * Outside<code>inform</code>, this could potentially throw a ConcurrentModificationException    *</p>    *     * @see SolrCoreAware    */
DECL|method|registerCopyField
specifier|public
name|void
name|registerCopyField
parameter_list|(
name|String
name|source
parameter_list|,
name|String
name|dest
parameter_list|,
name|int
name|maxChars
parameter_list|)
block|{
name|boolean
name|sourceIsPattern
init|=
name|isWildCard
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|boolean
name|destIsPattern
init|=
name|isWildCard
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"copyField source='"
operator|+
name|source
operator|+
literal|"' dest='"
operator|+
name|dest
operator|+
literal|"' maxChars='"
operator|+
name|maxChars
argument_list|)
expr_stmt|;
name|SchemaField
name|d
init|=
name|getFieldOrNull
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"copyField destination :'"
operator|+
name|dest
operator|+
literal|"' does not exist"
argument_list|)
throw|;
block|}
if|if
condition|(
name|sourceIsPattern
condition|)
block|{
if|if
condition|(
name|destIsPattern
condition|)
block|{
name|DynamicField
name|df
init|=
literal|null
decl_stmt|;
for|for
control|(
name|DynamicField
name|dd
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|dd
operator|.
name|regex
operator|.
name|equals
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|df
operator|=
name|dd
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|df
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"copyField dynamic destination must match a dynamicField."
argument_list|)
throw|;
block|}
name|registerDynamicCopyField
argument_list|(
operator|new
name|DynamicDestCopy
argument_list|(
name|source
argument_list|,
name|df
argument_list|,
name|maxChars
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|registerDynamicCopyField
argument_list|(
operator|new
name|DynamicCopy
argument_list|(
name|source
argument_list|,
name|d
argument_list|,
name|maxChars
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|destIsPattern
condition|)
block|{
name|String
name|msg
init|=
literal|"copyField only supports a dynamic destination if the source is also dynamic"
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
else|else
block|{
comment|// retrieve the field to force an exception if it doesn't exist
name|SchemaField
name|f
init|=
name|getField
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|CopyField
argument_list|>
name|copyFieldList
init|=
name|copyFieldsMap
operator|.
name|get
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|copyFieldList
operator|==
literal|null
condition|)
block|{
name|copyFieldList
operator|=
operator|new
name|ArrayList
argument_list|<
name|CopyField
argument_list|>
argument_list|()
expr_stmt|;
name|copyFieldsMap
operator|.
name|put
argument_list|(
name|source
argument_list|,
name|copyFieldList
argument_list|)
expr_stmt|;
block|}
name|copyFieldList
operator|.
name|add
argument_list|(
operator|new
name|CopyField
argument_list|(
name|f
argument_list|,
name|d
argument_list|,
name|maxChars
argument_list|)
argument_list|)
expr_stmt|;
name|copyFieldTargetCounts
operator|.
name|put
argument_list|(
name|d
argument_list|,
operator|(
name|copyFieldTargetCounts
operator|.
name|containsKey
argument_list|(
name|d
argument_list|)
condition|?
name|copyFieldTargetCounts
operator|.
name|get
argument_list|(
name|d
argument_list|)
operator|+
literal|1
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|registerDynamicCopyField
specifier|private
name|void
name|registerDynamicCopyField
parameter_list|(
name|DynamicCopy
name|dcopy
parameter_list|)
block|{
if|if
condition|(
name|dynamicCopyFields
operator|==
literal|null
condition|)
block|{
name|dynamicCopyFields
operator|=
operator|new
name|DynamicCopy
index|[]
block|{
name|dcopy
block|}
expr_stmt|;
block|}
else|else
block|{
name|DynamicCopy
index|[]
name|temp
init|=
operator|new
name|DynamicCopy
index|[
name|dynamicCopyFields
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|dynamicCopyFields
argument_list|,
literal|0
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|dynamicCopyFields
operator|.
name|length
argument_list|)
expr_stmt|;
name|temp
index|[
name|temp
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|dcopy
expr_stmt|;
name|dynamicCopyFields
operator|=
name|temp
expr_stmt|;
block|}
name|log
operator|.
name|trace
argument_list|(
literal|"Dynamic Copy Field:"
operator|+
name|dcopy
argument_list|)
expr_stmt|;
block|}
DECL|method|append
specifier|private
specifier|static
name|Object
index|[]
name|append
parameter_list|(
name|Object
index|[]
name|orig
parameter_list|,
name|Object
name|item
parameter_list|)
block|{
name|Object
index|[]
name|newArr
init|=
operator|(
name|Object
index|[]
operator|)
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
operator|.
name|newInstance
argument_list|(
name|orig
operator|.
name|getClass
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|orig
operator|.
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|,
name|newArr
argument_list|,
literal|0
argument_list|,
name|orig
operator|.
name|length
argument_list|)
expr_stmt|;
name|newArr
index|[
name|orig
operator|.
name|length
index|]
operator|=
name|item
expr_stmt|;
return|return
name|newArr
return|;
block|}
comment|//
comment|//<analyzer><tokenizer class="...."/><tokenizer class="...." arg="....">
comment|//
comment|//
DECL|method|readAnalyzer
specifier|private
name|Analyzer
name|readAnalyzer
parameter_list|(
name|Node
name|node
parameter_list|)
throws|throws
name|XPathExpressionException
block|{
comment|// parent node used to be passed in as "fieldtype"
comment|// if (!fieldtype.hasChildNodes()) return null;
comment|// Node node = DOMUtil.getChild(fieldtype,"analyzer");
if|if
condition|(
name|node
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|analyzerName
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"class"
argument_list|)
decl_stmt|;
if|if
condition|(
name|analyzerName
operator|!=
literal|null
condition|)
block|{
return|return
operator|(
name|Analyzer
operator|)
name|loader
operator|.
name|newInstance
argument_list|(
name|analyzerName
argument_list|)
return|;
block|}
name|XPath
name|xpath
init|=
name|XPathFactory
operator|.
name|newInstance
argument_list|()
operator|.
name|newXPath
argument_list|()
decl_stmt|;
comment|// Load the CharFilters
comment|// --------------------------------------------------------------------------------
specifier|final
name|ArrayList
argument_list|<
name|CharFilterFactory
argument_list|>
name|charFilters
init|=
operator|new
name|ArrayList
argument_list|<
name|CharFilterFactory
argument_list|>
argument_list|()
decl_stmt|;
name|AbstractPluginLoader
argument_list|<
name|CharFilterFactory
argument_list|>
name|charFilterLoader
init|=
operator|new
name|AbstractPluginLoader
argument_list|<
name|CharFilterFactory
argument_list|>
argument_list|(
literal|"[schema.xml] analyzer/charFilter"
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|init
parameter_list|(
name|CharFilterFactory
name|plugin
parameter_list|,
name|Node
name|node
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|plugin
operator|!=
literal|null
condition|)
block|{
name|plugin
operator|.
name|init
argument_list|(
name|DOMUtil
operator|.
name|toMapExcept
argument_list|(
name|node
operator|.
name|getAttributes
argument_list|()
argument_list|,
literal|"class"
argument_list|)
argument_list|)
expr_stmt|;
name|charFilters
operator|.
name|add
argument_list|(
name|plugin
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|CharFilterFactory
name|register
parameter_list|(
name|String
name|name
parameter_list|,
name|CharFilterFactory
name|plugin
parameter_list|)
throws|throws
name|Exception
block|{
return|return
literal|null
return|;
comment|// used for map registration
block|}
block|}
decl_stmt|;
name|charFilterLoader
operator|.
name|load
argument_list|(
name|solrConfig
operator|.
name|getResourceLoader
argument_list|()
argument_list|,
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"./charFilter"
argument_list|,
name|node
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
argument_list|)
expr_stmt|;
comment|// Load the Tokenizer
comment|// Although an analyzer only allows a single Tokenizer, we load a list to make sure
comment|// the configuration is ok
comment|// --------------------------------------------------------------------------------
specifier|final
name|ArrayList
argument_list|<
name|TokenizerFactory
argument_list|>
name|tokenizers
init|=
operator|new
name|ArrayList
argument_list|<
name|TokenizerFactory
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|AbstractPluginLoader
argument_list|<
name|TokenizerFactory
argument_list|>
name|tokenizerLoader
init|=
operator|new
name|AbstractPluginLoader
argument_list|<
name|TokenizerFactory
argument_list|>
argument_list|(
literal|"[schema.xml] analyzer/tokenizer"
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|init
parameter_list|(
name|TokenizerFactory
name|plugin
parameter_list|,
name|Node
name|node
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|tokenizers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"The schema defines multiple tokenizers for: "
operator|+
name|node
argument_list|)
throw|;
block|}
name|plugin
operator|.
name|init
argument_list|(
name|DOMUtil
operator|.
name|toMapExcept
argument_list|(
name|node
operator|.
name|getAttributes
argument_list|()
argument_list|,
literal|"class"
argument_list|)
argument_list|)
expr_stmt|;
name|tokenizers
operator|.
name|add
argument_list|(
name|plugin
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|TokenizerFactory
name|register
parameter_list|(
name|String
name|name
parameter_list|,
name|TokenizerFactory
name|plugin
parameter_list|)
throws|throws
name|Exception
block|{
return|return
literal|null
return|;
comment|// used for map registration
block|}
block|}
decl_stmt|;
name|tokenizerLoader
operator|.
name|load
argument_list|(
name|loader
argument_list|,
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"./tokenizer"
argument_list|,
name|node
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
argument_list|)
expr_stmt|;
comment|// Make sure something was loaded
if|if
condition|(
name|tokenizers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"analyzer without class or tokenizer& filter list"
argument_list|)
throw|;
block|}
comment|// Load the Filters
comment|// --------------------------------------------------------------------------------
specifier|final
name|ArrayList
argument_list|<
name|TokenFilterFactory
argument_list|>
name|filters
init|=
operator|new
name|ArrayList
argument_list|<
name|TokenFilterFactory
argument_list|>
argument_list|()
decl_stmt|;
name|AbstractPluginLoader
argument_list|<
name|TokenFilterFactory
argument_list|>
name|filterLoader
init|=
operator|new
name|AbstractPluginLoader
argument_list|<
name|TokenFilterFactory
argument_list|>
argument_list|(
literal|"[schema.xml] analyzer/filter"
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|init
parameter_list|(
name|TokenFilterFactory
name|plugin
parameter_list|,
name|Node
name|node
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|plugin
operator|!=
literal|null
condition|)
block|{
name|plugin
operator|.
name|init
argument_list|(
name|DOMUtil
operator|.
name|toMapExcept
argument_list|(
name|node
operator|.
name|getAttributes
argument_list|()
argument_list|,
literal|"class"
argument_list|)
argument_list|)
expr_stmt|;
name|filters
operator|.
name|add
argument_list|(
name|plugin
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|TokenFilterFactory
name|register
parameter_list|(
name|String
name|name
parameter_list|,
name|TokenFilterFactory
name|plugin
parameter_list|)
throws|throws
name|Exception
block|{
return|return
literal|null
return|;
comment|// used for map registration
block|}
block|}
decl_stmt|;
name|filterLoader
operator|.
name|load
argument_list|(
name|loader
argument_list|,
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"./filter"
argument_list|,
name|node
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|TokenizerChain
argument_list|(
name|charFilters
operator|.
name|toArray
argument_list|(
operator|new
name|CharFilterFactory
index|[
name|charFilters
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|tokenizers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|filters
operator|.
name|toArray
argument_list|(
operator|new
name|TokenFilterFactory
index|[
name|filters
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
empty_stmt|;
DECL|class|DynamicReplacement
specifier|static
specifier|abstract
class|class
name|DynamicReplacement
implements|implements
name|Comparable
argument_list|<
name|DynamicReplacement
argument_list|>
block|{
DECL|field|STARTS_WITH
specifier|final
specifier|static
name|int
name|STARTS_WITH
init|=
literal|1
decl_stmt|;
DECL|field|ENDS_WITH
specifier|final
specifier|static
name|int
name|ENDS_WITH
init|=
literal|2
decl_stmt|;
DECL|field|regex
specifier|final
name|String
name|regex
decl_stmt|;
DECL|field|type
specifier|final
name|int
name|type
decl_stmt|;
DECL|field|str
specifier|final
name|String
name|str
decl_stmt|;
DECL|method|DynamicReplacement
specifier|protected
name|DynamicReplacement
parameter_list|(
name|String
name|regex
parameter_list|)
block|{
name|this
operator|.
name|regex
operator|=
name|regex
expr_stmt|;
if|if
condition|(
name|regex
operator|.
name|startsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|type
operator|=
name|ENDS_WITH
expr_stmt|;
name|str
operator|=
name|regex
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regex
operator|.
name|endsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|type
operator|=
name|STARTS_WITH
expr_stmt|;
name|str
operator|=
name|regex
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|regex
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"dynamic field name must start or end with *"
argument_list|)
throw|;
block|}
block|}
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|STARTS_WITH
operator|&&
name|name
operator|.
name|startsWith
argument_list|(
name|str
argument_list|)
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|ENDS_WITH
operator|&&
name|name
operator|.
name|endsWith
argument_list|(
name|str
argument_list|)
condition|)
return|return
literal|true
return|;
else|else
return|return
literal|false
return|;
block|}
comment|/**      * Sort order is based on length of regex.  Longest comes first.      * @param other The object to compare to.      * @return a negative integer, zero, or a positive integer      * as this object is less than, equal to, or greater than      * the specified object.      */
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|DynamicReplacement
name|other
parameter_list|)
block|{
return|return
name|other
operator|.
name|regex
operator|.
name|length
argument_list|()
operator|-
name|regex
operator|.
name|length
argument_list|()
return|;
block|}
block|}
comment|//
comment|// Instead of storing a type, this could be implemented as a hierarchy
comment|// with a virtual matches().
comment|// Given how often a search will be done, however, speed is the overriding
comment|// concern and I'm not sure which is faster.
comment|//
DECL|class|DynamicField
specifier|final
specifier|static
class|class
name|DynamicField
extends|extends
name|DynamicReplacement
block|{
DECL|field|prototype
specifier|final
name|SchemaField
name|prototype
decl_stmt|;
DECL|method|DynamicField
name|DynamicField
parameter_list|(
name|SchemaField
name|prototype
parameter_list|)
block|{
name|super
argument_list|(
name|prototype
operator|.
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|prototype
operator|=
name|prototype
expr_stmt|;
block|}
DECL|method|makeSchemaField
name|SchemaField
name|makeSchemaField
parameter_list|(
name|String
name|name
parameter_list|)
block|{
comment|// could have a cache instead of returning a new one each time, but it might
comment|// not be worth it.
comment|// Actually, a higher level cache could be worth it to avoid too many
comment|// .startsWith() and .endsWith() comparisons.  it depends on how many
comment|// dynamic fields there are.
return|return
operator|new
name|SchemaField
argument_list|(
name|prototype
argument_list|,
name|name
argument_list|)
return|;
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|prototype
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|class|DynamicCopy
specifier|static
class|class
name|DynamicCopy
extends|extends
name|DynamicReplacement
block|{
DECL|field|targetField
specifier|final
name|SchemaField
name|targetField
decl_stmt|;
DECL|field|maxChars
specifier|final
name|int
name|maxChars
decl_stmt|;
DECL|method|DynamicCopy
name|DynamicCopy
parameter_list|(
name|String
name|regex
parameter_list|,
name|SchemaField
name|targetField
parameter_list|)
block|{
name|this
argument_list|(
name|regex
argument_list|,
name|targetField
argument_list|,
name|CopyField
operator|.
name|UNLIMITED
argument_list|)
expr_stmt|;
block|}
DECL|method|DynamicCopy
name|DynamicCopy
parameter_list|(
name|String
name|regex
parameter_list|,
name|SchemaField
name|targetField
parameter_list|,
name|int
name|maxChars
parameter_list|)
block|{
name|super
argument_list|(
name|regex
argument_list|)
expr_stmt|;
name|this
operator|.
name|targetField
operator|=
name|targetField
expr_stmt|;
name|this
operator|.
name|maxChars
operator|=
name|maxChars
expr_stmt|;
block|}
DECL|method|getTargetField
specifier|public
name|SchemaField
name|getTargetField
parameter_list|(
name|String
name|sourceField
parameter_list|)
block|{
return|return
name|targetField
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|targetField
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|class|DynamicDestCopy
specifier|static
class|class
name|DynamicDestCopy
extends|extends
name|DynamicCopy
block|{
DECL|field|dynamic
specifier|final
name|DynamicField
name|dynamic
decl_stmt|;
DECL|field|dtype
specifier|final
name|int
name|dtype
decl_stmt|;
DECL|field|dstr
specifier|final
name|String
name|dstr
decl_stmt|;
DECL|method|DynamicDestCopy
name|DynamicDestCopy
parameter_list|(
name|String
name|source
parameter_list|,
name|DynamicField
name|dynamic
parameter_list|)
block|{
name|this
argument_list|(
name|source
argument_list|,
name|dynamic
argument_list|,
name|CopyField
operator|.
name|UNLIMITED
argument_list|)
expr_stmt|;
block|}
DECL|method|DynamicDestCopy
name|DynamicDestCopy
parameter_list|(
name|String
name|source
parameter_list|,
name|DynamicField
name|dynamic
parameter_list|,
name|int
name|maxChars
parameter_list|)
block|{
name|super
argument_list|(
name|source
argument_list|,
name|dynamic
operator|.
name|prototype
argument_list|,
name|maxChars
argument_list|)
expr_stmt|;
name|this
operator|.
name|dynamic
operator|=
name|dynamic
expr_stmt|;
name|String
name|dest
init|=
name|dynamic
operator|.
name|regex
decl_stmt|;
if|if
condition|(
name|dest
operator|.
name|startsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|dtype
operator|=
name|ENDS_WITH
expr_stmt|;
name|dstr
operator|=
name|dest
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dest
operator|.
name|endsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|dtype
operator|=
name|STARTS_WITH
expr_stmt|;
name|dstr
operator|=
name|dest
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|dest
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"dynamic copyField destination name must start or end with *"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getTargetField
specifier|public
name|SchemaField
name|getTargetField
parameter_list|(
name|String
name|sourceField
parameter_list|)
block|{
name|String
name|dyn
init|=
operator|(
name|type
operator|==
name|STARTS_WITH
operator|)
condition|?
name|sourceField
operator|.
name|substring
argument_list|(
name|str
operator|.
name|length
argument_list|()
argument_list|)
else|:
name|sourceField
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|sourceField
operator|.
name|length
argument_list|()
operator|-
name|str
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|name
init|=
operator|(
name|dtype
operator|==
name|STARTS_WITH
operator|)
condition|?
operator|(
name|dstr
operator|+
name|dyn
operator|)
else|:
operator|(
name|dyn
operator|+
name|dstr
operator|)
decl_stmt|;
return|return
name|dynamic
operator|.
name|makeSchemaField
argument_list|(
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|targetField
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|field|dynamicFields
specifier|private
name|DynamicField
index|[]
name|dynamicFields
decl_stmt|;
DECL|method|getDynamicFieldPrototypes
specifier|public
name|SchemaField
index|[]
name|getDynamicFieldPrototypes
parameter_list|()
block|{
name|SchemaField
index|[]
name|df
init|=
operator|new
name|SchemaField
index|[
name|dynamicFields
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dynamicFields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|df
index|[
name|i
index|]
operator|=
name|dynamicFields
index|[
name|i
index|]
operator|.
name|prototype
expr_stmt|;
block|}
return|return
name|df
return|;
block|}
DECL|method|getDynamicPattern
specifier|public
name|String
name|getDynamicPattern
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|df
operator|.
name|regex
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Does the schema have the specified field defined explicitly, i.e.    * not as a result of a copyField declaration with a wildcard?  We    * consider it explicitly defined if it matches a field or dynamicField    * declaration.    * @param fieldName    * @return true if explicitly declared in the schema.    */
DECL|method|hasExplicitField
specifier|public
name|boolean
name|hasExplicitField
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
name|fields
operator|.
name|containsKey
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Is the specified field dynamic or not.    * @param fieldName    * @return true if the specified field is dynamic    */
DECL|method|isDynamicField
specifier|public
name|boolean
name|isDynamicField
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
name|fields
operator|.
name|containsKey
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns the SchemaField that should be used for the specified field name, or    * null if none exists.    *    * @param fieldName may be an explicitly defined field, or a name that    * matches a dynamic field.    * @see #getFieldType    */
DECL|method|getFieldOrNull
specifier|public
name|SchemaField
name|getFieldOrNull
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
return|return
name|f
return|;
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|df
operator|.
name|makeSchemaField
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
return|return
name|f
return|;
block|}
comment|/**    * Returns the SchemaField that should be used for the specified field name    *    * @param fieldName may be an explicitly defined field, or a name that    * matches a dynamic field.    * @throws SolrException if no such field exists    * @see #getFieldType    */
DECL|method|getField
specifier|public
name|SchemaField
name|getField
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
return|return
name|f
return|;
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|df
operator|.
name|makeSchemaField
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
comment|// Hmmm, default field could also be implemented with a dynamic field of "*".
comment|// It would have to be special-cased and only used if nothing else matched.
comment|/***  REMOVED -YCS     if (defaultFieldType != null) return new SchemaField(fieldName,defaultFieldType);     ***/
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"undefined field "
operator|+
name|fieldName
argument_list|)
throw|;
block|}
comment|/**    * Returns the FieldType for the specified field name.    *    *<p>    * This method exists because it can be more efficient then    * {@link #getField} for dynamic fields if a full SchemaField isn't needed.    *</p>    *    * @param fieldName may be an explicitly created field, or a name that    * excercies a dynamic field.    * @throws SolrException if no such field exists    * @see #getField(String)    * @see #getFieldTypeNoEx    */
DECL|method|getFieldType
specifier|public
name|FieldType
name|getFieldType
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
return|return
name|f
operator|.
name|getType
argument_list|()
return|;
return|return
name|getDynamicFieldType
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
comment|/**    * Returns the FieldType for the specified field name.    *    *<p>    * This method exists because it can be more efficient then    * {@link #getField} for dynamic fields if a full SchemaField isn't needed.    *</p>    *    * @param fieldName may be an explicitly created field, or a name that    * excercies a dynamic field.    * @return null if field is not defined.    * @see #getField(String)    * @see #getFieldTypeNoEx    */
DECL|method|getFieldTypeNoEx
specifier|public
name|FieldType
name|getFieldTypeNoEx
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
return|return
name|f
operator|.
name|getType
argument_list|()
return|;
return|return
name|dynFieldType
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
comment|/**    * Returns the FieldType of the best matching dynamic field for    * the specified field name    *    * @param fieldName may be an explicitly created field, or a name that    * excercies a dynamic field.    * @throws SolrException if no such field exists    * @see #getField(String)    * @see #getFieldTypeNoEx    */
DECL|method|getDynamicFieldType
specifier|public
name|FieldType
name|getDynamicFieldType
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|df
operator|.
name|prototype
operator|.
name|getType
argument_list|()
return|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"undefined field "
operator|+
name|fieldName
argument_list|)
throw|;
block|}
DECL|method|dynFieldType
specifier|private
name|FieldType
name|dynFieldType
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|df
operator|.
name|prototype
operator|.
name|getType
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
empty_stmt|;
DECL|field|copyFieldsMap
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CopyField
argument_list|>
argument_list|>
name|copyFieldsMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CopyField
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|dynamicCopyFields
specifier|private
name|DynamicCopy
index|[]
name|dynamicCopyFields
decl_stmt|;
comment|/**    * keys are all fields copied to, count is num of copyField    * directives that target them.    */
DECL|field|copyFieldTargetCounts
specifier|private
name|Map
argument_list|<
name|SchemaField
argument_list|,
name|Integer
argument_list|>
name|copyFieldTargetCounts
init|=
operator|new
name|HashMap
argument_list|<
name|SchemaField
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Get all copy fields, both the static and the dynamic ones.    * @param destField    * @return Array of fields copied into this field    */
DECL|method|getCopySources
specifier|public
name|SchemaField
index|[]
name|getCopySources
parameter_list|(
name|String
name|destField
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|getField
argument_list|(
name|destField
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isCopyFieldTarget
argument_list|(
name|f
argument_list|)
condition|)
block|{
return|return
operator|new
name|SchemaField
index|[
literal|0
index|]
return|;
block|}
name|List
argument_list|<
name|SchemaField
argument_list|>
name|sf
init|=
operator|new
name|ArrayList
argument_list|<
name|SchemaField
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|CopyField
argument_list|>
argument_list|>
name|cfs
range|:
name|copyFieldsMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|CopyField
name|copyField
range|:
name|cfs
operator|.
name|getValue
argument_list|()
control|)
block|{
if|if
condition|(
name|copyField
operator|.
name|getDestination
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|destField
argument_list|)
condition|)
block|{
name|sf
operator|.
name|add
argument_list|(
name|copyField
operator|.
name|getSource
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|sf
operator|.
name|toArray
argument_list|(
operator|new
name|SchemaField
index|[
name|sf
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Get all copy fields, both the static and the dynamic ones.    *     * @param sourceField    * @return Array of fields to copy to.    * @deprecated Use {@link #getCopyFieldsList(String)} instead.    */
annotation|@
name|Deprecated
DECL|method|getCopyFields
specifier|public
name|SchemaField
index|[]
name|getCopyFields
parameter_list|(
name|String
name|sourceField
parameter_list|)
block|{
comment|// This is the List that holds all the results, dynamic or not.
name|List
argument_list|<
name|SchemaField
argument_list|>
name|matchCopyFields
init|=
operator|new
name|ArrayList
argument_list|<
name|SchemaField
argument_list|>
argument_list|()
decl_stmt|;
comment|// Get the dynamic results into the list.
for|for
control|(
name|DynamicCopy
name|dynamicCopy
range|:
name|dynamicCopyFields
control|)
block|{
if|if
condition|(
name|dynamicCopy
operator|.
name|matches
argument_list|(
name|sourceField
argument_list|)
condition|)
block|{
name|matchCopyFields
operator|.
name|add
argument_list|(
name|dynamicCopy
operator|.
name|getTargetField
argument_list|(
name|sourceField
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Get the fixed ones, if there are any and add them.
specifier|final
name|List
argument_list|<
name|CopyField
argument_list|>
name|copyFields
init|=
name|copyFieldsMap
operator|.
name|get
argument_list|(
name|sourceField
argument_list|)
decl_stmt|;
if|if
condition|(
name|copyFields
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Iterator
argument_list|<
name|CopyField
argument_list|>
name|it
init|=
name|copyFields
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|matchCopyFields
operator|.
name|add
argument_list|(
name|it
operator|.
name|next
argument_list|()
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Construct the results by transforming the list into an array.
return|return
name|matchCopyFields
operator|.
name|toArray
argument_list|(
operator|new
name|SchemaField
index|[
name|matchCopyFields
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Get all copy fields for a specified source field, both static    * and dynamic ones.    * @param sourceField    * @return List of CopyFields to copy to.    * @since solr 1.4    */
comment|// This is useful when we need the maxSize param of each CopyField
DECL|method|getCopyFieldsList
specifier|public
name|List
argument_list|<
name|CopyField
argument_list|>
name|getCopyFieldsList
parameter_list|(
specifier|final
name|String
name|sourceField
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|CopyField
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|CopyField
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|DynamicCopy
name|dynamicCopy
range|:
name|dynamicCopyFields
control|)
block|{
if|if
condition|(
name|dynamicCopy
operator|.
name|matches
argument_list|(
name|sourceField
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
operator|new
name|CopyField
argument_list|(
name|getField
argument_list|(
name|sourceField
argument_list|)
argument_list|,
name|dynamicCopy
operator|.
name|getTargetField
argument_list|(
name|sourceField
argument_list|)
argument_list|,
name|dynamicCopy
operator|.
name|maxChars
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|CopyField
argument_list|>
name|fixedCopyFields
init|=
name|copyFieldsMap
operator|.
name|get
argument_list|(
name|sourceField
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixedCopyFields
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|addAll
argument_list|(
name|fixedCopyFields
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Check if a field is used as the destination of a copyField operation     *     * @since solr 1.3    */
DECL|method|isCopyFieldTarget
specifier|public
name|boolean
name|isCopyFieldTarget
parameter_list|(
name|SchemaField
name|f
parameter_list|)
block|{
return|return
name|copyFieldTargetCounts
operator|.
name|containsKey
argument_list|(
name|f
argument_list|)
return|;
block|}
comment|/**    * Is the given field name a wildcard?  I.e. does it begin or end with *?    * @param name    * @return true/false    */
DECL|method|isWildCard
specifier|private
specifier|static
name|boolean
name|isWildCard
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|startsWith
argument_list|(
literal|"*"
argument_list|)
operator|||
name|name
operator|.
name|endsWith
argument_list|(
literal|"*"
argument_list|)
return|;
block|}
block|}
end_class
end_unit
