begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.schema
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Fieldable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DefaultSimilarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|QueryParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|Config
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analysis
operator|.
name|TokenFilterFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analysis
operator|.
name|TokenizerChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analysis
operator|.
name|TokenizerFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrQueryParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|DOMUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NamedNodeMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPath
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathConstants
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathExpressionException
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathFactory
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import
begin_comment
comment|/**  *<code>IndexSchema</code> contains information about the valid fields in an index  * and the types of those fields.  *  * @author yonik  * @version $Id$  */
end_comment
begin_class
DECL|class|IndexSchema
specifier|public
specifier|final
class|class
name|IndexSchema
block|{
DECL|field|log
specifier|final
specifier|static
name|Logger
name|log
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|IndexSchema
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|schemaFile
specifier|private
specifier|final
name|String
name|schemaFile
decl_stmt|;
DECL|field|name
specifier|private
name|String
name|name
decl_stmt|;
DECL|field|version
specifier|private
name|float
name|version
decl_stmt|;
comment|/**    * Constructs a schema using the specified file name using the normal    * Config path directory searching rules.    *    * @see Config#openResource    */
DECL|method|IndexSchema
specifier|public
name|IndexSchema
parameter_list|(
name|String
name|schemaFile
parameter_list|)
block|{
name|this
operator|.
name|schemaFile
operator|=
name|schemaFile
expr_stmt|;
name|readConfig
argument_list|()
expr_stmt|;
block|}
comment|/**    * Direct acess to the InputStream for the schemaFile used by this instance.    *    * @see Config#openResource    */
DECL|method|getInputStream
specifier|public
name|InputStream
name|getInputStream
parameter_list|()
block|{
return|return
name|Config
operator|.
name|openResource
argument_list|(
name|schemaFile
argument_list|)
return|;
block|}
DECL|method|getVersion
name|float
name|getVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
comment|/** The Name of this schema (as specified in the schema file) */
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|field|fields
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|SchemaField
argument_list|>
name|fields
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SchemaField
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|fieldTypes
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
name|fieldTypes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|fieldsWithDefaultValue
specifier|private
specifier|final
name|List
argument_list|<
name|SchemaField
argument_list|>
name|fieldsWithDefaultValue
init|=
operator|new
name|ArrayList
argument_list|<
name|SchemaField
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|requiredFields
specifier|private
specifier|final
name|Collection
argument_list|<
name|SchemaField
argument_list|>
name|requiredFields
init|=
operator|new
name|HashSet
argument_list|<
name|SchemaField
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Provides direct access to the Map containing all explicit    * (ie: non-dynamic) fields in the index, keyed on field name.    *    *<p>    * Modifying this Map (or any item in it) will affect the real schema    *</p>    */
DECL|method|getFields
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|SchemaField
argument_list|>
name|getFields
parameter_list|()
block|{
return|return
name|fields
return|;
block|}
comment|/**    * Provides direct access to the Map containing all Field Types    * in the index, keyed on fild type name.    *    *<p>    * Modifying this Map (or any item in it) will affect the real schema    *</p>    */
DECL|method|getFieldTypes
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
name|getFieldTypes
parameter_list|()
block|{
return|return
name|fieldTypes
return|;
block|}
comment|/**    * Provides direct access to the List containing all fields with a default value    */
DECL|method|getFieldsWithDefaultValue
specifier|public
name|List
argument_list|<
name|SchemaField
argument_list|>
name|getFieldsWithDefaultValue
parameter_list|()
block|{
return|return
name|fieldsWithDefaultValue
return|;
block|}
comment|/**    * Provides direct access to the List containing all required fields.  This    * list contains all fields with default values.    */
DECL|method|getRequiredFields
specifier|public
name|Collection
argument_list|<
name|SchemaField
argument_list|>
name|getRequiredFields
parameter_list|()
block|{
return|return
name|requiredFields
return|;
block|}
DECL|field|similarity
specifier|private
name|Similarity
name|similarity
decl_stmt|;
comment|/**    * Returns the Similarity used for this index    */
DECL|method|getSimilarity
specifier|public
name|Similarity
name|getSimilarity
parameter_list|()
block|{
return|return
name|similarity
return|;
block|}
DECL|field|analyzer
specifier|private
name|Analyzer
name|analyzer
decl_stmt|;
comment|/**    * Returns the Analyzer used when indexing documents for this index    *    *<p>    * This Analyzer is field (and dynamic field) name aware, and delegates to    * a field specific Analyzer based on the field type.    *</p>    */
DECL|method|getAnalyzer
specifier|public
name|Analyzer
name|getAnalyzer
parameter_list|()
block|{
return|return
name|analyzer
return|;
block|}
DECL|field|queryAnalyzer
specifier|private
name|Analyzer
name|queryAnalyzer
decl_stmt|;
comment|/**    * Returns the Analyzer used when searching this index    *    *<p>    * This Analyzer is field (and dynamic field) name aware, and delegates to    * a field specific Analyzer based on the field type.    *</p>    */
DECL|method|getQueryAnalyzer
specifier|public
name|Analyzer
name|getQueryAnalyzer
parameter_list|()
block|{
return|return
name|queryAnalyzer
return|;
block|}
DECL|field|defaultSearchFieldName
specifier|private
name|String
name|defaultSearchFieldName
init|=
literal|null
decl_stmt|;
DECL|field|queryParserDefaultOperator
specifier|private
name|String
name|queryParserDefaultOperator
init|=
literal|"OR"
decl_stmt|;
comment|/**    * A SolrQueryParser linked to this IndexSchema for field datatype    * information, and populated with default options from the    *&lt;solrQueryParser&gt; configuration for this IndexSchema.    *    * @param defaultField if non-null overrides the schema default    */
DECL|method|getSolrQueryParser
specifier|public
name|SolrQueryParser
name|getSolrQueryParser
parameter_list|(
name|String
name|defaultField
parameter_list|)
block|{
name|SolrQueryParser
name|qp
init|=
operator|new
name|SolrQueryParser
argument_list|(
name|this
argument_list|,
name|defaultField
argument_list|)
decl_stmt|;
name|String
name|operator
init|=
name|getQueryParserDefaultOperator
argument_list|()
decl_stmt|;
name|qp
operator|.
name|setDefaultOperator
argument_list|(
literal|"AND"
operator|.
name|equals
argument_list|(
name|operator
argument_list|)
condition|?
name|QueryParser
operator|.
name|Operator
operator|.
name|AND
else|:
name|QueryParser
operator|.
name|Operator
operator|.
name|OR
argument_list|)
expr_stmt|;
return|return
name|qp
return|;
block|}
comment|/**    * Name of the default search field specified in the schema file    * @deprecated use getSolrQueryParser().getField()    */
DECL|method|getDefaultSearchFieldName
specifier|public
name|String
name|getDefaultSearchFieldName
parameter_list|()
block|{
return|return
name|defaultSearchFieldName
return|;
block|}
comment|/**    * default operator ("AND" or "OR") for QueryParser    * @deprecated use getSolrQueryParser().getDefaultOperator()    */
DECL|method|getQueryParserDefaultOperator
specifier|public
name|String
name|getQueryParserDefaultOperator
parameter_list|()
block|{
return|return
name|queryParserDefaultOperator
return|;
block|}
DECL|field|uniqueKeyField
specifier|private
name|SchemaField
name|uniqueKeyField
decl_stmt|;
comment|/**    * Unique Key field specified in the schema file    * @return null if this schema has no unique key field    */
DECL|method|getUniqueKeyField
specifier|public
name|SchemaField
name|getUniqueKeyField
parameter_list|()
block|{
return|return
name|uniqueKeyField
return|;
block|}
DECL|field|uniqueKeyFieldName
specifier|private
name|String
name|uniqueKeyFieldName
decl_stmt|;
DECL|field|uniqueKeyFieldType
specifier|private
name|FieldType
name|uniqueKeyFieldType
decl_stmt|;
comment|/**    * The raw (field type encoded) value of the Unique Key field for    * the specified Document    * @return null if this schema has no unique key field    * @see #printableUniqueKey    */
DECL|method|getUniqueKeyField
specifier|public
name|Fieldable
name|getUniqueKeyField
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
name|doc
parameter_list|)
block|{
return|return
name|doc
operator|.
name|getFieldable
argument_list|(
name|uniqueKeyFieldName
argument_list|)
return|;
comment|// this should return null if name is null
block|}
comment|/**    * The printable value of the Unique Key field for    * the specified Document    * @return null if this schema has no unique key field    */
DECL|method|printableUniqueKey
specifier|public
name|String
name|printableUniqueKey
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
name|doc
parameter_list|)
block|{
name|Fieldable
name|f
init|=
name|doc
operator|.
name|getFieldable
argument_list|(
name|uniqueKeyFieldName
argument_list|)
decl_stmt|;
return|return
name|f
operator|==
literal|null
condition|?
literal|null
else|:
name|uniqueKeyFieldType
operator|.
name|toExternal
argument_list|(
name|f
argument_list|)
return|;
block|}
DECL|method|getIndexedField
specifier|private
name|SchemaField
name|getIndexedField
parameter_list|(
name|String
name|fname
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|getFields
argument_list|()
operator|.
name|get
argument_list|(
name|fname
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unknown field '"
operator|+
name|fname
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|f
operator|.
name|indexed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"'"
operator|+
name|fname
operator|+
literal|"' is not an indexed field:"
operator|+
name|f
argument_list|)
throw|;
block|}
return|return
name|f
return|;
block|}
DECL|class|SolrIndexAnalyzer
specifier|private
class|class
name|SolrIndexAnalyzer
extends|extends
name|Analyzer
block|{
DECL|field|analyzers
specifier|protected
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|analyzers
decl_stmt|;
DECL|method|SolrIndexAnalyzer
name|SolrIndexAnalyzer
parameter_list|()
block|{
name|analyzers
operator|=
name|analyzerCache
argument_list|()
expr_stmt|;
block|}
DECL|method|analyzerCache
specifier|protected
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|analyzerCache
parameter_list|()
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|cache
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SchemaField
name|f
range|:
name|getFields
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|Analyzer
name|analyzer
init|=
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getAnalyzer
argument_list|()
decl_stmt|;
name|cache
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
return|return
name|cache
return|;
block|}
DECL|method|getAnalyzer
specifier|protected
name|Analyzer
name|getAnalyzer
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Analyzer
name|analyzer
init|=
name|analyzers
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
return|return
name|analyzer
operator|!=
literal|null
condition|?
name|analyzer
else|:
name|getDynamicFieldType
argument_list|(
name|fieldName
argument_list|)
operator|.
name|getAnalyzer
argument_list|()
return|;
block|}
DECL|method|tokenStream
specifier|public
name|TokenStream
name|tokenStream
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
return|return
name|getAnalyzer
argument_list|(
name|fieldName
argument_list|)
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
name|reader
argument_list|)
return|;
block|}
DECL|method|getPositionIncrementGap
specifier|public
name|int
name|getPositionIncrementGap
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
name|getAnalyzer
argument_list|(
name|fieldName
argument_list|)
operator|.
name|getPositionIncrementGap
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
block|}
DECL|class|SolrQueryAnalyzer
specifier|private
class|class
name|SolrQueryAnalyzer
extends|extends
name|SolrIndexAnalyzer
block|{
DECL|method|analyzerCache
specifier|protected
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|analyzerCache
parameter_list|()
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|cache
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SchemaField
name|f
range|:
name|getFields
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|Analyzer
name|analyzer
init|=
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getQueryAnalyzer
argument_list|()
decl_stmt|;
name|cache
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
return|return
name|cache
return|;
block|}
DECL|method|getAnalyzer
specifier|protected
name|Analyzer
name|getAnalyzer
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Analyzer
name|analyzer
init|=
name|analyzers
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
return|return
name|analyzer
operator|!=
literal|null
condition|?
name|analyzer
else|:
name|getDynamicFieldType
argument_list|(
name|fieldName
argument_list|)
operator|.
name|getQueryAnalyzer
argument_list|()
return|;
block|}
block|}
DECL|method|readConfig
specifier|private
name|void
name|readConfig
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Reading Solr Schema"
argument_list|)
expr_stmt|;
try|try
block|{
comment|/***       DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();       Document document = builder.parse(getInputStream());       ***/
name|Config
name|config
init|=
operator|new
name|Config
argument_list|(
literal|"schema"
argument_list|,
name|getInputStream
argument_list|()
argument_list|,
literal|"/schema/"
argument_list|)
decl_stmt|;
name|Document
name|document
init|=
name|config
operator|.
name|getDocument
argument_list|()
decl_stmt|;
name|XPath
name|xpath
init|=
name|config
operator|.
name|getXPath
argument_list|()
decl_stmt|;
name|Node
name|nd
init|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"/schema/@name"
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|nd
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"schema has no name!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|nd
operator|.
name|getNodeValue
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Schema name="
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
name|version
operator|=
name|config
operator|.
name|getFloat
argument_list|(
literal|"/schema/@version"
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
name|String
name|expression
init|=
literal|"/schema/types/fieldtype | /schema/types/fieldType"
decl_stmt|;
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|,
literal|"fieldtype error"
argument_list|)
decl_stmt|;
name|log
operator|.
name|finest
argument_list|(
literal|"reading fieldtype "
operator|+
name|name
argument_list|)
expr_stmt|;
name|String
name|clsName
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"class"
argument_list|,
literal|"fieldtype error"
argument_list|)
decl_stmt|;
name|FieldType
name|ft
init|=
operator|(
name|FieldType
operator|)
name|Config
operator|.
name|newInstance
argument_list|(
name|clsName
argument_list|)
decl_stmt|;
name|ft
operator|.
name|setTypeName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|expression
operator|=
literal|"./analyzer[@type='query']"
expr_stmt|;
name|Node
name|anode
init|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|node
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
decl_stmt|;
name|Analyzer
name|queryAnalyzer
init|=
name|readAnalyzer
argument_list|(
name|anode
argument_list|)
decl_stmt|;
comment|// An analyzer without a type specified, or with type="index"
name|expression
operator|=
literal|"./analyzer[not(@type)] | ./analyzer[@type='index']"
expr_stmt|;
name|anode
operator|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|node
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
expr_stmt|;
name|Analyzer
name|analyzer
init|=
name|readAnalyzer
argument_list|(
name|anode
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryAnalyzer
operator|==
literal|null
condition|)
name|queryAnalyzer
operator|=
name|analyzer
expr_stmt|;
if|if
condition|(
name|analyzer
operator|==
literal|null
condition|)
name|analyzer
operator|=
name|queryAnalyzer
expr_stmt|;
if|if
condition|(
name|analyzer
operator|!=
literal|null
condition|)
block|{
name|ft
operator|.
name|setAnalyzer
argument_list|(
name|analyzer
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setQueryAnalyzer
argument_list|(
name|queryAnalyzer
argument_list|)
expr_stmt|;
block|}
name|ft
operator|.
name|setArgs
argument_list|(
name|this
argument_list|,
name|DOMUtil
operator|.
name|toMapExcept
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|,
literal|"class"
argument_list|)
argument_list|)
expr_stmt|;
name|FieldType
name|old
init|=
name|fieldTypes
operator|.
name|put
argument_list|(
name|ft
operator|.
name|typeName
argument_list|,
name|ft
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"[schema.xml] Duplicate fieldType definition for '"
operator|+
name|ft
operator|.
name|typeName
operator|+
literal|"' ignoring: "
operator|+
name|old
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Throwable
name|t
init|=
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
decl_stmt|;
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|SolrConfig
operator|.
name|severeErrors
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|finest
argument_list|(
literal|"fieldtype defined: "
operator|+
name|ft
argument_list|)
expr_stmt|;
block|}
comment|// Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|explicitRequiredProp
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|DynamicField
argument_list|>
name|dFields
init|=
operator|new
name|ArrayList
argument_list|<
name|DynamicField
argument_list|>
argument_list|()
decl_stmt|;
name|expression
operator|=
literal|"/schema/fields/field | /schema/fields/dynamicField"
expr_stmt|;
name|nodes
operator|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|,
literal|"field definition"
argument_list|)
decl_stmt|;
name|log
operator|.
name|finest
argument_list|(
literal|"reading field def "
operator|+
name|name
argument_list|)
expr_stmt|;
name|String
name|type
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"type"
argument_list|,
literal|"field "
operator|+
name|name
argument_list|)
decl_stmt|;
name|String
name|val
decl_stmt|;
name|FieldType
name|ft
init|=
name|fieldTypes
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ft
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Unknown fieldtype '"
operator|+
name|type
operator|+
literal|"'"
argument_list|,
literal|false
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
name|DOMUtil
operator|.
name|toMapExcept
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|,
literal|"type"
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|get
argument_list|(
literal|"required"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|explicitRequiredProp
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|Boolean
operator|.
name|valueOf
argument_list|(
name|args
operator|.
name|get
argument_list|(
literal|"required"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SchemaField
name|f
init|=
name|SchemaField
operator|.
name|create
argument_list|(
name|name
argument_list|,
name|ft
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getNodeName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"field"
argument_list|)
condition|)
block|{
name|SchemaField
name|old
init|=
name|fields
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"[schema.xml] Duplicate field definition for '"
operator|+
name|f
operator|.
name|getName
argument_list|()
operator|+
literal|"' ignoring: "
operator|+
name|old
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Throwable
name|t
init|=
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
decl_stmt|;
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|SolrConfig
operator|.
name|severeErrors
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|fine
argument_list|(
literal|"field defined: "
operator|+
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|getDefaultValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|fine
argument_list|(
name|name
operator|+
literal|" contains default value: "
operator|+
name|f
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
name|fieldsWithDefaultValue
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|isRequired
argument_list|()
condition|)
block|{
name|log
operator|.
name|fine
argument_list|(
name|name
operator|+
literal|" is required in this schema"
argument_list|)
expr_stmt|;
name|requiredFields
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|getNodeName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"dynamicField"
argument_list|)
condition|)
block|{
comment|// make sure nothing else has the same path
name|boolean
name|dup
init|=
literal|false
decl_stmt|;
for|for
control|(
name|DynamicField
name|df
range|:
name|dFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|regex
operator|.
name|equals
argument_list|(
name|f
operator|.
name|name
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"[schema.xml] Duplicate DynamicField definition for '"
operator|+
name|f
operator|.
name|getName
argument_list|()
operator|+
literal|"' ignoring: "
operator|+
name|f
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Throwable
name|t
init|=
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
decl_stmt|;
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|SolrConfig
operator|.
name|severeErrors
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|dup
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|dup
condition|)
block|{
name|dFields
operator|.
name|add
argument_list|(
operator|new
name|DynamicField
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|fine
argument_list|(
literal|"dynamic field defined: "
operator|+
name|f
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// we should never get here
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown field type"
argument_list|)
throw|;
block|}
block|}
comment|//fields with default values are by definition required
comment|//add them to required fields, and we only have to loop once
comment|// in DocumentBuilder.getDoc()
name|requiredFields
operator|.
name|addAll
argument_list|(
name|getFieldsWithDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// OK, now sort the dynamic fields largest to smallest size so we don't get
comment|// any false matches.  We want to act like a compiler tool and try and match
comment|// the largest string possible.
name|Collections
operator|.
name|sort
argument_list|(
name|dFields
argument_list|)
expr_stmt|;
name|log
operator|.
name|finest
argument_list|(
literal|"Dynamic Field Ordering:"
operator|+
name|dFields
argument_list|)
expr_stmt|;
comment|// stuff it in a normal array for faster access
name|dynamicFields
operator|=
operator|(
name|DynamicField
index|[]
operator|)
name|dFields
operator|.
name|toArray
argument_list|(
operator|new
name|DynamicField
index|[
name|dFields
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|Node
name|node
init|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"/schema/similarity/@class"
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|similarity
operator|=
operator|new
name|DefaultSimilarity
argument_list|()
expr_stmt|;
name|log
operator|.
name|fine
argument_list|(
literal|"using default similarity"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|similarity
operator|=
operator|(
name|Similarity
operator|)
name|Config
operator|.
name|newInstance
argument_list|(
name|node
operator|.
name|getNodeValue
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|fine
argument_list|(
literal|"using similarity "
operator|+
name|similarity
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"/schema/defaultSearchField/text()"
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"no default search field specified in schema."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|defaultSearchFieldName
operator|=
name|node
operator|.
name|getNodeValue
argument_list|()
operator|.
name|trim
argument_list|()
expr_stmt|;
comment|// throw exception if specified, but not found or not indexed
if|if
condition|(
name|defaultSearchFieldName
operator|!=
literal|null
condition|)
name|getIndexedField
argument_list|(
name|defaultSearchFieldName
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"default search field is "
operator|+
name|defaultSearchFieldName
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"/schema/solrQueryParser/@defaultOperator"
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|fine
argument_list|(
literal|"using default query parser operator (OR)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queryParserDefaultOperator
operator|=
name|node
operator|.
name|getNodeValue
argument_list|()
operator|.
name|trim
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"query parser default operator is "
operator|+
name|queryParserDefaultOperator
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"/schema/uniqueKey/text()"
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"no uniqueKey specified in schema."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uniqueKeyField
operator|=
name|getIndexedField
argument_list|(
name|node
operator|.
name|getNodeValue
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|uniqueKeyFieldName
operator|=
name|uniqueKeyField
operator|.
name|getName
argument_list|()
expr_stmt|;
name|uniqueKeyFieldType
operator|=
name|uniqueKeyField
operator|.
name|getType
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"unique key field: "
operator|+
name|uniqueKeyFieldName
argument_list|)
expr_stmt|;
comment|// Unless the uniqueKeyField is marked 'required=false' then make sure it exists
if|if
condition|(
name|Boolean
operator|.
name|FALSE
operator|!=
name|explicitRequiredProp
operator|.
name|get
argument_list|(
name|uniqueKeyFieldName
argument_list|)
condition|)
block|{
name|uniqueKeyField
operator|.
name|required
operator|=
literal|true
expr_stmt|;
name|requiredFields
operator|.
name|add
argument_list|(
name|uniqueKeyField
argument_list|)
expr_stmt|;
block|}
block|}
comment|/////////////// parse out copyField commands ///////////////
comment|// Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();
comment|// expression = "/schema/copyField";
name|ArrayList
argument_list|<
name|DynamicCopy
argument_list|>
name|dCopies
init|=
operator|new
name|ArrayList
argument_list|<
name|DynamicCopy
argument_list|>
argument_list|()
decl_stmt|;
name|expression
operator|=
literal|"//copyField"
expr_stmt|;
name|nodes
operator|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|source
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"source"
argument_list|,
literal|"copyField definition"
argument_list|)
decl_stmt|;
name|String
name|dest
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"dest"
argument_list|,
literal|"copyField definition"
argument_list|)
decl_stmt|;
name|boolean
name|sourceIsPattern
init|=
name|isWildCard
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|boolean
name|destIsPattern
init|=
name|isWildCard
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|log
operator|.
name|fine
argument_list|(
literal|"copyField source='"
operator|+
name|source
operator|+
literal|"' dest='"
operator|+
name|dest
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|SchemaField
name|d
init|=
name|getField
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceIsPattern
condition|)
block|{
if|if
condition|(
name|destIsPattern
condition|)
block|{
name|DynamicField
name|df
init|=
literal|null
decl_stmt|;
for|for
control|(
name|DynamicField
name|dd
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|dd
operator|.
name|regex
operator|.
name|equals
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|df
operator|=
name|dd
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|df
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"copyField dynamic destination must match a dynamicField."
argument_list|)
throw|;
block|}
name|dCopies
operator|.
name|add
argument_list|(
operator|new
name|DynamicDestCopy
argument_list|(
name|source
argument_list|,
name|df
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dCopies
operator|.
name|add
argument_list|(
operator|new
name|DynamicCopy
argument_list|(
name|source
argument_list|,
name|d
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|destIsPattern
condition|)
block|{
name|String
name|msg
init|=
literal|"copyField only supports a dynamic destination if the source is also dynamic"
decl_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|msg
argument_list|)
throw|;
block|}
else|else
block|{
comment|// retrieve the field to force an exception if it doesn't exist
name|SchemaField
name|f
init|=
name|getField
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|SchemaField
index|[]
name|destArr
init|=
name|copyFields
operator|.
name|get
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|destArr
operator|==
literal|null
condition|)
block|{
name|destArr
operator|=
operator|new
name|SchemaField
index|[]
block|{
name|d
block|}
expr_stmt|;
block|}
else|else
block|{
name|destArr
operator|=
operator|(
name|SchemaField
index|[]
operator|)
name|append
argument_list|(
name|destArr
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
name|copyFields
operator|.
name|put
argument_list|(
name|source
argument_list|,
name|destArr
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|finest
argument_list|(
literal|"Dynamic Copied Fields:"
operator|+
name|dCopies
argument_list|)
expr_stmt|;
comment|// stuff it in a normal array for faster access
name|dynamicCopyFields
operator|=
operator|(
name|DynamicCopy
index|[]
operator|)
name|dCopies
operator|.
name|toArray
argument_list|(
operator|new
name|DynamicCopy
index|[
name|dCopies
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|SolrConfig
operator|.
name|severeErrors
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// unexpected exception...
name|SolrConfig
operator|.
name|severeErrors
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Schema Parsing Failed"
argument_list|,
name|e
argument_list|,
literal|false
argument_list|)
throw|;
block|}
name|analyzer
operator|=
operator|new
name|SolrIndexAnalyzer
argument_list|()
expr_stmt|;
name|queryAnalyzer
operator|=
operator|new
name|SolrQueryAnalyzer
argument_list|()
expr_stmt|;
block|}
DECL|method|append
specifier|private
specifier|static
name|Object
index|[]
name|append
parameter_list|(
name|Object
index|[]
name|orig
parameter_list|,
name|Object
name|item
parameter_list|)
block|{
name|Object
index|[]
name|newArr
init|=
operator|(
name|Object
index|[]
operator|)
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
operator|.
name|newInstance
argument_list|(
name|orig
operator|.
name|getClass
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|orig
operator|.
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|,
name|newArr
argument_list|,
literal|0
argument_list|,
name|orig
operator|.
name|length
argument_list|)
expr_stmt|;
name|newArr
index|[
name|orig
operator|.
name|length
index|]
operator|=
name|item
expr_stmt|;
return|return
name|newArr
return|;
block|}
comment|//
comment|//<analyzer><tokenizer class="...."/><tokenizer class="...." arg="....">
comment|//
comment|//
DECL|method|readAnalyzer
specifier|private
name|Analyzer
name|readAnalyzer
parameter_list|(
name|Node
name|node
parameter_list|)
throws|throws
name|XPathExpressionException
block|{
comment|// parent node used to be passed in as "fieldtype"
comment|// if (!fieldtype.hasChildNodes()) return null;
comment|// Node node = DOMUtil.getChild(fieldtype,"analyzer");
if|if
condition|(
name|node
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|analyzerName
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"class"
argument_list|)
decl_stmt|;
if|if
condition|(
name|analyzerName
operator|!=
literal|null
condition|)
block|{
return|return
operator|(
name|Analyzer
operator|)
name|Config
operator|.
name|newInstance
argument_list|(
name|analyzerName
argument_list|)
return|;
block|}
name|XPath
name|xpath
init|=
name|XPathFactory
operator|.
name|newInstance
argument_list|()
operator|.
name|newXPath
argument_list|()
decl_stmt|;
name|Node
name|tokNode
init|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"./tokenizer"
argument_list|,
name|node
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
decl_stmt|;
name|NodeList
name|nList
init|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"./filter"
argument_list|,
name|node
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"analyzer without class or tokenizer& filter list"
argument_list|)
throw|;
block|}
name|TokenizerFactory
name|tfac
init|=
name|readTokenizerFactory
argument_list|(
name|tokNode
argument_list|)
decl_stmt|;
comment|/******     // oops, getChildNodes() includes text (newlines, etc) in addition     // to the actual child elements     NodeList nList = node.getChildNodes();     TokenizerFactory tfac = readTokenizerFactory(nList.item(0));      if (tfac==null) {        throw new SolrException( SolrException.StatusCode.SERVER_ERROR,"TokenizerFactory must be specified first in analyzer");      }     ******/
name|ArrayList
argument_list|<
name|TokenFilterFactory
argument_list|>
name|filters
init|=
operator|new
name|ArrayList
argument_list|<
name|TokenFilterFactory
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nList
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|TokenFilterFactory
name|filt
init|=
name|readTokenFilterFactory
argument_list|(
name|nList
operator|.
name|item
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|filt
operator|!=
literal|null
condition|)
name|filters
operator|.
name|add
argument_list|(
name|filt
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|TokenizerChain
argument_list|(
name|tfac
argument_list|,
name|filters
operator|.
name|toArray
argument_list|(
operator|new
name|TokenFilterFactory
index|[
name|filters
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
empty_stmt|;
comment|//<tokenizer class="solr.StandardFilterFactory"/>
DECL|method|readTokenizerFactory
specifier|private
name|TokenizerFactory
name|readTokenizerFactory
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
comment|// if (node.getNodeName() != "tokenizer") return null;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"class"
argument_list|,
literal|"tokenizer"
argument_list|)
decl_stmt|;
name|TokenizerFactory
name|tfac
init|=
operator|(
name|TokenizerFactory
operator|)
name|Config
operator|.
name|newInstance
argument_list|(
name|className
argument_list|)
decl_stmt|;
name|tfac
operator|.
name|init
argument_list|(
name|DOMUtil
operator|.
name|toMapExcept
argument_list|(
name|attrs
argument_list|,
literal|"class"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tfac
return|;
block|}
comment|//<tokenizer class="solr.StandardFilterFactory"/>
DECL|method|readTokenFilterFactory
specifier|private
name|TokenFilterFactory
name|readTokenFilterFactory
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
comment|// if (node.getNodeName() != "filter") return null;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"class"
argument_list|,
literal|"token filter"
argument_list|)
decl_stmt|;
name|TokenFilterFactory
name|tfac
init|=
operator|(
name|TokenFilterFactory
operator|)
name|Config
operator|.
name|newInstance
argument_list|(
name|className
argument_list|)
decl_stmt|;
name|tfac
operator|.
name|init
argument_list|(
name|DOMUtil
operator|.
name|toMapExcept
argument_list|(
name|attrs
argument_list|,
literal|"class"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tfac
return|;
block|}
DECL|class|DynamicReplacement
specifier|static
specifier|abstract
class|class
name|DynamicReplacement
implements|implements
name|Comparable
argument_list|<
name|DynamicReplacement
argument_list|>
block|{
DECL|field|STARTS_WITH
specifier|final
specifier|static
name|int
name|STARTS_WITH
init|=
literal|1
decl_stmt|;
DECL|field|ENDS_WITH
specifier|final
specifier|static
name|int
name|ENDS_WITH
init|=
literal|2
decl_stmt|;
DECL|field|regex
specifier|final
name|String
name|regex
decl_stmt|;
DECL|field|type
specifier|final
name|int
name|type
decl_stmt|;
DECL|field|str
specifier|final
name|String
name|str
decl_stmt|;
DECL|method|DynamicReplacement
specifier|protected
name|DynamicReplacement
parameter_list|(
name|String
name|regex
parameter_list|)
block|{
name|this
operator|.
name|regex
operator|=
name|regex
expr_stmt|;
if|if
condition|(
name|regex
operator|.
name|startsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|type
operator|=
name|ENDS_WITH
expr_stmt|;
name|str
operator|=
name|regex
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regex
operator|.
name|endsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|type
operator|=
name|STARTS_WITH
expr_stmt|;
name|str
operator|=
name|regex
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|regex
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"dynamic field name must start or end with *"
argument_list|)
throw|;
block|}
block|}
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|STARTS_WITH
operator|&&
name|name
operator|.
name|startsWith
argument_list|(
name|str
argument_list|)
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|ENDS_WITH
operator|&&
name|name
operator|.
name|endsWith
argument_list|(
name|str
argument_list|)
condition|)
return|return
literal|true
return|;
else|else
return|return
literal|false
return|;
block|}
comment|/**      * Sort order is based on length of regex.  Longest comes first.      * @param other The object to compare to.      * @return a negative integer, zero, or a positive integer      * as this object is less than, equal to, or greater than      * the specified object.      */
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|DynamicReplacement
name|other
parameter_list|)
block|{
return|return
name|other
operator|.
name|regex
operator|.
name|length
argument_list|()
operator|-
name|regex
operator|.
name|length
argument_list|()
return|;
block|}
block|}
comment|//
comment|// Instead of storing a type, this could be implemented as a hierarchy
comment|// with a virtual matches().
comment|// Given how often a search will be done, however, speed is the overriding
comment|// concern and I'm not sure which is faster.
comment|//
DECL|class|DynamicField
specifier|final
specifier|static
class|class
name|DynamicField
extends|extends
name|DynamicReplacement
block|{
DECL|field|prototype
specifier|final
name|SchemaField
name|prototype
decl_stmt|;
DECL|method|DynamicField
name|DynamicField
parameter_list|(
name|SchemaField
name|prototype
parameter_list|)
block|{
name|super
argument_list|(
name|prototype
operator|.
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|prototype
operator|=
name|prototype
expr_stmt|;
block|}
DECL|method|makeSchemaField
name|SchemaField
name|makeSchemaField
parameter_list|(
name|String
name|name
parameter_list|)
block|{
comment|// could have a cache instead of returning a new one each time, but it might
comment|// not be worth it.
comment|// Actually, a higher level cache could be worth it to avoid too many
comment|// .startsWith() and .endsWith() comparisons.  it depends on how many
comment|// dynamic fields there are.
return|return
operator|new
name|SchemaField
argument_list|(
name|prototype
argument_list|,
name|name
argument_list|)
return|;
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|prototype
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|class|DynamicCopy
specifier|static
class|class
name|DynamicCopy
extends|extends
name|DynamicReplacement
block|{
DECL|field|targetField
specifier|final
name|SchemaField
name|targetField
decl_stmt|;
DECL|method|DynamicCopy
name|DynamicCopy
parameter_list|(
name|String
name|regex
parameter_list|,
name|SchemaField
name|targetField
parameter_list|)
block|{
name|super
argument_list|(
name|regex
argument_list|)
expr_stmt|;
name|this
operator|.
name|targetField
operator|=
name|targetField
expr_stmt|;
block|}
DECL|method|getTargetField
specifier|public
name|SchemaField
name|getTargetField
parameter_list|(
name|String
name|sourceField
parameter_list|)
block|{
return|return
name|targetField
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|targetField
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|class|DynamicDestCopy
specifier|static
class|class
name|DynamicDestCopy
extends|extends
name|DynamicCopy
block|{
DECL|field|dynamic
specifier|final
name|DynamicField
name|dynamic
decl_stmt|;
DECL|field|dtype
specifier|final
name|int
name|dtype
decl_stmt|;
DECL|field|dstr
specifier|final
name|String
name|dstr
decl_stmt|;
DECL|method|DynamicDestCopy
name|DynamicDestCopy
parameter_list|(
name|String
name|source
parameter_list|,
name|DynamicField
name|dynamic
parameter_list|)
block|{
name|super
argument_list|(
name|source
argument_list|,
name|dynamic
operator|.
name|prototype
argument_list|)
expr_stmt|;
name|this
operator|.
name|dynamic
operator|=
name|dynamic
expr_stmt|;
name|String
name|dest
init|=
name|dynamic
operator|.
name|regex
decl_stmt|;
if|if
condition|(
name|dest
operator|.
name|startsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|dtype
operator|=
name|ENDS_WITH
expr_stmt|;
name|dstr
operator|=
name|dest
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dest
operator|.
name|endsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|dtype
operator|=
name|STARTS_WITH
expr_stmt|;
name|dstr
operator|=
name|dest
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|dest
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"dynamic copyField destination name must start or end with *"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getTargetField
specifier|public
name|SchemaField
name|getTargetField
parameter_list|(
name|String
name|sourceField
parameter_list|)
block|{
name|String
name|dyn
init|=
operator|(
name|type
operator|==
name|STARTS_WITH
operator|)
condition|?
name|sourceField
operator|.
name|substring
argument_list|(
name|str
operator|.
name|length
argument_list|()
argument_list|)
else|:
name|sourceField
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|sourceField
operator|.
name|length
argument_list|()
operator|-
name|str
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|name
init|=
operator|(
name|dtype
operator|==
name|STARTS_WITH
operator|)
condition|?
operator|(
name|dstr
operator|+
name|dyn
operator|)
else|:
operator|(
name|dyn
operator|+
name|dstr
operator|)
decl_stmt|;
return|return
name|dynamic
operator|.
name|makeSchemaField
argument_list|(
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|targetField
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|field|dynamicFields
specifier|private
name|DynamicField
index|[]
name|dynamicFields
decl_stmt|;
comment|/**    * Does the schema have the specified field defined explicitly, i.e.    * not as a result of a copyField declaration with a wildcard?  We    * consider it explicitly defined if it matches a field or dynamicField    * declaration.    * @param fieldName    * @return true if explicitly declared in the schema.    */
DECL|method|hasExplicitField
specifier|public
name|boolean
name|hasExplicitField
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
name|fields
operator|.
name|containsKey
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns the SchemaField that should be used for the specified field name, or    * null if none exists.    *    * @param fieldName may be an explicitly defined field, or a name that    * matches a dynamic field.    * @see #getFieldType    */
DECL|method|getFieldOrNull
specifier|public
name|SchemaField
name|getFieldOrNull
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
return|return
name|f
return|;
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|df
operator|.
name|makeSchemaField
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
return|return
name|f
return|;
block|}
comment|/**    * Returns the SchemaField that should be used for the specified field name    *    * @param fieldName may be an explicitly defined field, or a name that    * matches a dynamic field.    * @throws SolrException if no such field exists    * @see #getFieldType    */
DECL|method|getField
specifier|public
name|SchemaField
name|getField
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
return|return
name|f
return|;
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|df
operator|.
name|makeSchemaField
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
comment|// Hmmm, default field could also be implemented with a dynamic field of "*".
comment|// It would have to be special-cased and only used if nothing else matched.
comment|/***  REMOVED -YCS     if (defaultFieldType != null) return new SchemaField(fieldName,defaultFieldType);     ***/
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"undefined field "
operator|+
name|fieldName
argument_list|)
throw|;
block|}
comment|/**    * Returns the FieldType for the specified field name.    *    *<p>    * This method exists because it can be more efficient then    * {@link #getField} for dynamic fields if a full SchemaField isn't needed.    *</p>    *    * @param fieldName may be an explicitly created field, or a name that    * excercies a dynamic field.    * @throws SolrException if no such field exists    * @see #getField(String)    * @see #getFieldTypeNoEx    */
DECL|method|getFieldType
specifier|public
name|FieldType
name|getFieldType
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
return|return
name|f
operator|.
name|getType
argument_list|()
return|;
return|return
name|getDynamicFieldType
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
comment|/**    * Returns the FieldType for the specified field name.    *    *<p>    * This method exists because it can be more efficient then    * {@link #getField} for dynamic fields if a full SchemaField isn't needed.    *</p>    *    * @param fieldName may be an explicitly created field, or a name that    * excercies a dynamic field.    * @return null if field is not defined.    * @see #getField(String)    * @see #getFieldTypeNoEx    */
DECL|method|getFieldTypeNoEx
specifier|public
name|FieldType
name|getFieldTypeNoEx
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
return|return
name|f
operator|.
name|getType
argument_list|()
return|;
return|return
name|dynFieldType
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
comment|/**    * Returns the FieldType of the best matching dynamic field for    * the specified field name    *    * @param fieldName may be an explicitly created field, or a name that    * excercies a dynamic field.    * @throws SolrException if no such field exists    * @see #getField(String)    * @see #getFieldTypeNoEx    */
DECL|method|getDynamicFieldType
specifier|public
name|FieldType
name|getDynamicFieldType
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|df
operator|.
name|prototype
operator|.
name|getType
argument_list|()
return|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"undefined field "
operator|+
name|fieldName
argument_list|)
throw|;
block|}
DECL|method|dynFieldType
specifier|private
name|FieldType
name|dynFieldType
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|df
operator|.
name|prototype
operator|.
name|getType
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
empty_stmt|;
DECL|field|copyFields
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|SchemaField
index|[]
argument_list|>
name|copyFields
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SchemaField
index|[]
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|dynamicCopyFields
specifier|private
name|DynamicCopy
index|[]
name|dynamicCopyFields
decl_stmt|;
comment|/**    * Get all copy fields, both the static and the dynamic ones.    * @param sourceField    * @return Array of fields to copy to.    */
DECL|method|getCopyFields
specifier|public
name|SchemaField
index|[]
name|getCopyFields
parameter_list|(
name|String
name|sourceField
parameter_list|)
block|{
comment|// Get the dynamic ones into a list.
name|List
argument_list|<
name|SchemaField
argument_list|>
name|matchCopyFields
init|=
operator|new
name|ArrayList
argument_list|<
name|SchemaField
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|DynamicCopy
name|dynamicCopy
range|:
name|dynamicCopyFields
control|)
block|{
if|if
condition|(
name|dynamicCopy
operator|.
name|matches
argument_list|(
name|sourceField
argument_list|)
condition|)
block|{
name|matchCopyFields
operator|.
name|add
argument_list|(
name|dynamicCopy
operator|.
name|getTargetField
argument_list|(
name|sourceField
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Get the fixed ones, if there are any.
name|SchemaField
index|[]
name|fixedCopyFields
init|=
name|copyFields
operator|.
name|get
argument_list|(
name|sourceField
argument_list|)
decl_stmt|;
name|boolean
name|appendFixed
init|=
name|copyFields
operator|.
name|containsKey
argument_list|(
name|sourceField
argument_list|)
decl_stmt|;
comment|// Construct the results by concatenating dynamic and fixed into a results array.
name|SchemaField
index|[]
name|results
init|=
operator|new
name|SchemaField
index|[
name|matchCopyFields
operator|.
name|size
argument_list|()
operator|+
operator|(
name|appendFixed
condition|?
name|fixedCopyFields
operator|.
name|length
else|:
literal|0
operator|)
index|]
decl_stmt|;
name|matchCopyFields
operator|.
name|toArray
argument_list|(
name|results
argument_list|)
expr_stmt|;
if|if
condition|(
name|appendFixed
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|fixedCopyFields
argument_list|,
literal|0
argument_list|,
name|results
argument_list|,
name|matchCopyFields
operator|.
name|size
argument_list|()
argument_list|,
name|fixedCopyFields
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
comment|/**    * Is the given field name a wildcard?  I.e. does it begin or end with *?    * @param name    * @return true/false    */
DECL|method|isWildCard
specifier|private
specifier|static
name|boolean
name|isWildCard
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|startsWith
argument_list|(
literal|"*"
argument_list|)
operator|||
name|name
operator|.
name|endsWith
argument_list|(
literal|"*"
argument_list|)
return|;
block|}
block|}
end_class
end_unit
