begin_unit
begin_comment
comment|/**  * Copyright 2006 The Apache Software Foundation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.schema
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DefaultSimilarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|Config
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analysis
operator|.
name|TokenFilterFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analysis
operator|.
name|TokenizerChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|analysis
operator|.
name|TokenizerFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|DOMUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NamedNodeMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPath
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathConstants
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathExpressionException
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathFactory
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import
begin_comment
comment|/**  *<code>IndexSchema</code> contains information about the valid fields in an index  * and the types of those fields.  *  * @author yonik  * @version $Id$  */
end_comment
begin_class
DECL|class|IndexSchema
specifier|public
specifier|final
class|class
name|IndexSchema
block|{
DECL|field|log
specifier|final
specifier|static
name|Logger
name|log
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|IndexSchema
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|schemaFile
specifier|private
specifier|final
name|String
name|schemaFile
decl_stmt|;
DECL|field|name
specifier|private
name|String
name|name
decl_stmt|;
DECL|field|version
specifier|private
name|float
name|version
decl_stmt|;
DECL|method|IndexSchema
specifier|public
name|IndexSchema
parameter_list|(
name|String
name|schemaFile
parameter_list|)
block|{
name|this
operator|.
name|schemaFile
operator|=
name|schemaFile
expr_stmt|;
name|readConfig
argument_list|()
expr_stmt|;
block|}
DECL|method|getInputStream
specifier|public
name|InputStream
name|getInputStream
parameter_list|()
block|{
return|return
name|Config
operator|.
name|openResource
argument_list|(
name|schemaFile
argument_list|)
return|;
block|}
DECL|method|getVersion
name|float
name|getVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|field|fields
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|SchemaField
argument_list|>
name|fields
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SchemaField
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|fieldTypes
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
name|fieldTypes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|getFields
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|SchemaField
argument_list|>
name|getFields
parameter_list|()
block|{
return|return
name|fields
return|;
block|}
DECL|method|getFieldTypes
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
name|getFieldTypes
parameter_list|()
block|{
return|return
name|fieldTypes
return|;
block|}
DECL|field|similarity
specifier|private
name|Similarity
name|similarity
decl_stmt|;
DECL|method|getSimilarity
specifier|public
name|Similarity
name|getSimilarity
parameter_list|()
block|{
return|return
name|similarity
return|;
block|}
DECL|field|analyzer
specifier|private
name|Analyzer
name|analyzer
decl_stmt|;
DECL|method|getAnalyzer
specifier|public
name|Analyzer
name|getAnalyzer
parameter_list|()
block|{
return|return
name|analyzer
return|;
block|}
DECL|field|queryAnalyzer
specifier|private
name|Analyzer
name|queryAnalyzer
decl_stmt|;
DECL|method|getQueryAnalyzer
specifier|public
name|Analyzer
name|getQueryAnalyzer
parameter_list|()
block|{
return|return
name|queryAnalyzer
return|;
block|}
DECL|field|defaultSearchFieldName
specifier|private
name|String
name|defaultSearchFieldName
init|=
literal|null
decl_stmt|;
DECL|method|getDefaultSearchFieldName
specifier|public
name|String
name|getDefaultSearchFieldName
parameter_list|()
block|{
return|return
name|defaultSearchFieldName
return|;
block|}
DECL|field|uniqueKeyField
specifier|private
name|SchemaField
name|uniqueKeyField
decl_stmt|;
DECL|method|getUniqueKeyField
specifier|public
name|SchemaField
name|getUniqueKeyField
parameter_list|()
block|{
return|return
name|uniqueKeyField
return|;
block|}
DECL|field|uniqueKeyFieldName
specifier|private
name|String
name|uniqueKeyFieldName
decl_stmt|;
DECL|field|uniqueKeyFieldType
specifier|private
name|FieldType
name|uniqueKeyFieldType
decl_stmt|;
DECL|method|getUniqueKeyField
specifier|public
name|Field
name|getUniqueKeyField
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
name|doc
parameter_list|)
block|{
return|return
name|doc
operator|.
name|getField
argument_list|(
name|uniqueKeyFieldName
argument_list|)
return|;
comment|// this should return null if name is null
block|}
DECL|method|printableUniqueKey
specifier|public
name|String
name|printableUniqueKey
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
name|doc
parameter_list|)
block|{
name|Field
name|f
init|=
name|doc
operator|.
name|getField
argument_list|(
name|uniqueKeyFieldName
argument_list|)
decl_stmt|;
return|return
name|f
operator|==
literal|null
condition|?
literal|null
else|:
name|uniqueKeyFieldType
operator|.
name|toExternal
argument_list|(
name|f
argument_list|)
return|;
block|}
DECL|method|getIndexedField
specifier|private
name|SchemaField
name|getIndexedField
parameter_list|(
name|String
name|fname
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|getFields
argument_list|()
operator|.
name|get
argument_list|(
name|fname
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unknown field '"
operator|+
name|fname
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|f
operator|.
name|indexed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"'"
operator|+
name|fname
operator|+
literal|"' is not an indexed field:"
operator|+
name|f
argument_list|)
throw|;
block|}
return|return
name|f
return|;
block|}
DECL|class|SolrIndexAnalyzer
specifier|private
class|class
name|SolrIndexAnalyzer
extends|extends
name|Analyzer
block|{
DECL|field|analyzers
specifier|protected
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|analyzers
decl_stmt|;
DECL|method|SolrIndexAnalyzer
name|SolrIndexAnalyzer
parameter_list|()
block|{
name|analyzers
operator|=
name|analyzerCache
argument_list|()
expr_stmt|;
block|}
DECL|method|analyzerCache
specifier|protected
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|analyzerCache
parameter_list|()
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|cache
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SchemaField
name|f
range|:
name|getFields
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|Analyzer
name|analyzer
init|=
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getAnalyzer
argument_list|()
decl_stmt|;
name|cache
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
return|return
name|cache
return|;
block|}
DECL|method|getAnalyzer
specifier|protected
name|Analyzer
name|getAnalyzer
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Analyzer
name|analyzer
init|=
name|analyzers
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
return|return
name|analyzer
operator|!=
literal|null
condition|?
name|analyzer
else|:
name|getDynamicFieldType
argument_list|(
name|fieldName
argument_list|)
operator|.
name|getAnalyzer
argument_list|()
return|;
block|}
DECL|method|tokenStream
specifier|public
name|TokenStream
name|tokenStream
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
return|return
name|getAnalyzer
argument_list|(
name|fieldName
argument_list|)
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
name|reader
argument_list|)
return|;
block|}
DECL|method|getPositionIncrementGap
specifier|public
name|int
name|getPositionIncrementGap
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
name|getAnalyzer
argument_list|(
name|fieldName
argument_list|)
operator|.
name|getPositionIncrementGap
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
block|}
DECL|class|SolrQueryAnalyzer
specifier|private
class|class
name|SolrQueryAnalyzer
extends|extends
name|SolrIndexAnalyzer
block|{
DECL|method|analyzerCache
specifier|protected
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|analyzerCache
parameter_list|()
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|cache
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SchemaField
name|f
range|:
name|getFields
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|Analyzer
name|analyzer
init|=
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getQueryAnalyzer
argument_list|()
decl_stmt|;
name|cache
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
return|return
name|cache
return|;
block|}
DECL|method|getAnalyzer
specifier|protected
name|Analyzer
name|getAnalyzer
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Analyzer
name|analyzer
init|=
name|analyzers
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
return|return
name|analyzer
operator|!=
literal|null
condition|?
name|analyzer
else|:
name|getDynamicFieldType
argument_list|(
name|fieldName
argument_list|)
operator|.
name|getQueryAnalyzer
argument_list|()
return|;
block|}
block|}
DECL|method|readConfig
specifier|private
name|void
name|readConfig
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Reading Solr Schema"
argument_list|)
expr_stmt|;
try|try
block|{
comment|/***       DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();       Document document = builder.parse(getInputStream());       ***/
name|Config
name|config
init|=
operator|new
name|Config
argument_list|(
literal|"schema"
argument_list|,
name|getInputStream
argument_list|()
argument_list|,
literal|"/schema/"
argument_list|)
decl_stmt|;
name|Document
name|document
init|=
name|config
operator|.
name|getDocument
argument_list|()
decl_stmt|;
name|XPath
name|xpath
init|=
name|config
operator|.
name|getXPath
argument_list|()
decl_stmt|;
name|Node
name|nd
init|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"/schema/@name"
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|nd
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"schema has no name!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|nd
operator|.
name|getNodeValue
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Schema name="
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
name|version
operator|=
name|config
operator|.
name|getFloat
argument_list|(
literal|"/schema/@version"
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
name|String
name|expression
init|=
literal|"/schema/types/fieldtype"
decl_stmt|;
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|,
literal|"fieldtype error"
argument_list|)
decl_stmt|;
name|log
operator|.
name|finest
argument_list|(
literal|"reading fieldtype "
operator|+
name|name
argument_list|)
expr_stmt|;
name|String
name|clsName
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"class"
argument_list|,
literal|"fieldtype error"
argument_list|)
decl_stmt|;
name|FieldType
name|ft
init|=
operator|(
name|FieldType
operator|)
name|Config
operator|.
name|newInstance
argument_list|(
name|clsName
argument_list|)
decl_stmt|;
name|ft
operator|.
name|setTypeName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|expression
operator|=
literal|"./analyzer[@type='query']"
expr_stmt|;
name|Node
name|anode
init|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|node
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
decl_stmt|;
name|Analyzer
name|queryAnalyzer
init|=
name|readAnalyzer
argument_list|(
name|anode
argument_list|)
decl_stmt|;
comment|// An analyzer without a type specified, or with type="index"
name|expression
operator|=
literal|"./analyzer[not(@type)] | ./analyzer[@type='index']"
expr_stmt|;
name|anode
operator|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|node
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
expr_stmt|;
name|Analyzer
name|analyzer
init|=
name|readAnalyzer
argument_list|(
name|anode
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryAnalyzer
operator|==
literal|null
condition|)
name|queryAnalyzer
operator|=
name|analyzer
expr_stmt|;
if|if
condition|(
name|analyzer
operator|==
literal|null
condition|)
name|analyzer
operator|=
name|queryAnalyzer
expr_stmt|;
if|if
condition|(
name|analyzer
operator|!=
literal|null
condition|)
block|{
name|ft
operator|.
name|setAnalyzer
argument_list|(
name|analyzer
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setQueryAnalyzer
argument_list|(
name|queryAnalyzer
argument_list|)
expr_stmt|;
block|}
name|ft
operator|.
name|setArgs
argument_list|(
name|this
argument_list|,
name|DOMUtil
operator|.
name|toMapExcept
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|,
literal|"class"
argument_list|)
argument_list|)
expr_stmt|;
name|fieldTypes
operator|.
name|put
argument_list|(
name|ft
operator|.
name|typeName
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|log
operator|.
name|finest
argument_list|(
literal|"fieldtype defined: "
operator|+
name|ft
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|DynamicField
argument_list|>
name|dFields
init|=
operator|new
name|ArrayList
argument_list|<
name|DynamicField
argument_list|>
argument_list|()
decl_stmt|;
name|expression
operator|=
literal|"/schema/fields/field | /schema/fields/dynamicField"
expr_stmt|;
name|nodes
operator|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|,
literal|"field definition"
argument_list|)
decl_stmt|;
name|log
operator|.
name|finest
argument_list|(
literal|"reading field def "
operator|+
name|name
argument_list|)
expr_stmt|;
name|String
name|type
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"type"
argument_list|,
literal|"field "
operator|+
name|name
argument_list|)
decl_stmt|;
name|String
name|val
decl_stmt|;
name|FieldType
name|ft
init|=
name|fieldTypes
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ft
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
literal|400
argument_list|,
literal|"Unknown fieldtype '"
operator|+
name|type
operator|+
literal|"'"
argument_list|,
literal|false
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
init|=
name|DOMUtil
operator|.
name|toMapExcept
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|,
literal|"type"
argument_list|)
decl_stmt|;
name|SchemaField
name|f
init|=
name|SchemaField
operator|.
name|create
argument_list|(
name|name
argument_list|,
name|ft
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getNodeName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"field"
argument_list|)
condition|)
block|{
name|fields
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|log
operator|.
name|fine
argument_list|(
literal|"field defined: "
operator|+
name|f
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|getNodeName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"dynamicField"
argument_list|)
condition|)
block|{
name|dFields
operator|.
name|add
argument_list|(
operator|new
name|DynamicField
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|fine
argument_list|(
literal|"dynamic field defined: "
operator|+
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we should never get here
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown field type"
argument_list|)
throw|;
block|}
block|}
comment|// OK, now sort the dynamic fields largest to smallest size so we don't get
comment|// any false matches.  We want to act like a compiler tool and try and match
comment|// the largest string possible.
name|Collections
operator|.
name|sort
argument_list|(
name|dFields
argument_list|,
operator|new
name|Comparator
argument_list|<
name|DynamicField
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|DynamicField
name|a
parameter_list|,
name|DynamicField
name|b
parameter_list|)
block|{
comment|// swap natural ordering to get biggest first.
comment|// The sort is stable, so elements of the same size should
comment|// be
if|if
condition|(
name|a
operator|.
name|regex
operator|.
name|length
argument_list|()
operator|<
name|b
operator|.
name|regex
operator|.
name|length
argument_list|()
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|.
name|regex
operator|.
name|length
argument_list|()
operator|>
name|b
operator|.
name|regex
operator|.
name|length
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|log
operator|.
name|finest
argument_list|(
literal|"Dynamic Field Ordering:"
operator|+
name|dFields
argument_list|)
expr_stmt|;
comment|// stuff it in a normal array for faster access
name|dynamicFields
operator|=
operator|(
name|DynamicField
index|[]
operator|)
name|dFields
operator|.
name|toArray
argument_list|(
operator|new
name|DynamicField
index|[
name|dFields
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|Node
name|node
init|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"/schema/similarity/@class"
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|similarity
operator|=
operator|new
name|DefaultSimilarity
argument_list|()
expr_stmt|;
name|log
operator|.
name|fine
argument_list|(
literal|"using default similarity"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|similarity
operator|=
operator|(
name|Similarity
operator|)
name|Config
operator|.
name|newInstance
argument_list|(
name|node
operator|.
name|getNodeValue
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|fine
argument_list|(
literal|"using similarity "
operator|+
name|similarity
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"/schema/defaultSearchField/text()"
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"no default search field specified in schema."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|defName
init|=
name|node
operator|.
name|getNodeValue
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|defaultSearchFieldName
operator|=
name|getIndexedField
argument_list|(
name|defName
argument_list|)
operator|!=
literal|null
condition|?
name|defName
else|:
literal|null
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"default search field is "
operator|+
name|defName
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"/schema/uniqueKey/text()"
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"no uniqueKey specified in schema."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uniqueKeyField
operator|=
name|getIndexedField
argument_list|(
name|node
operator|.
name|getNodeValue
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|uniqueKeyFieldName
operator|=
name|uniqueKeyField
operator|.
name|getName
argument_list|()
expr_stmt|;
name|uniqueKeyFieldType
operator|=
name|uniqueKeyField
operator|.
name|getType
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"unique key field: "
operator|+
name|uniqueKeyFieldName
argument_list|)
expr_stmt|;
block|}
comment|/////////////// parse out copyField commands ///////////////
comment|// Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();
comment|// expression = "/schema/copyField";
name|expression
operator|=
literal|"//copyField"
expr_stmt|;
name|nodes
operator|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
name|expression
argument_list|,
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|source
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"source"
argument_list|,
literal|"copyField definition"
argument_list|)
decl_stmt|;
name|String
name|dest
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"dest"
argument_list|,
literal|"copyField definition"
argument_list|)
decl_stmt|;
name|log
operator|.
name|fine
argument_list|(
literal|"copyField source='"
operator|+
name|source
operator|+
literal|"' dest='"
operator|+
name|dest
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|SchemaField
name|f
init|=
name|getField
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|SchemaField
name|d
init|=
name|getField
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|SchemaField
index|[]
name|destArr
init|=
name|copyFields
operator|.
name|get
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|destArr
operator|==
literal|null
condition|)
block|{
name|destArr
operator|=
operator|new
name|SchemaField
index|[]
block|{
name|d
block|}
expr_stmt|;
block|}
else|else
block|{
name|destArr
operator|=
operator|(
name|SchemaField
index|[]
operator|)
name|append
argument_list|(
name|destArr
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
name|copyFields
operator|.
name|put
argument_list|(
name|source
argument_list|,
name|destArr
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// unexpected exception...
throw|throw
operator|new
name|SolrException
argument_list|(
literal|1
argument_list|,
literal|"Schema Parsing Failed"
argument_list|,
name|e
argument_list|,
literal|false
argument_list|)
throw|;
block|}
name|analyzer
operator|=
operator|new
name|SolrIndexAnalyzer
argument_list|()
expr_stmt|;
name|queryAnalyzer
operator|=
operator|new
name|SolrQueryAnalyzer
argument_list|()
expr_stmt|;
block|}
DECL|method|append
specifier|private
specifier|static
name|Object
index|[]
name|append
parameter_list|(
name|Object
index|[]
name|orig
parameter_list|,
name|Object
name|item
parameter_list|)
block|{
name|Object
index|[]
name|newArr
init|=
operator|(
name|Object
index|[]
operator|)
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
operator|.
name|newInstance
argument_list|(
name|orig
operator|.
name|getClass
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|orig
operator|.
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|,
name|newArr
argument_list|,
literal|0
argument_list|,
name|orig
operator|.
name|length
argument_list|)
expr_stmt|;
name|newArr
index|[
name|orig
operator|.
name|length
index|]
operator|=
name|item
expr_stmt|;
return|return
name|newArr
return|;
block|}
comment|//
comment|//<analyzer><tokenizer class="...."/><tokenizer class="...." arg="....">
comment|//
comment|//
DECL|method|readAnalyzer
specifier|private
name|Analyzer
name|readAnalyzer
parameter_list|(
name|Node
name|node
parameter_list|)
throws|throws
name|XPathExpressionException
block|{
comment|// parent node used to be passed in as "fieldtype"
comment|// if (!fieldtype.hasChildNodes()) return null;
comment|// Node node = DOMUtil.getChild(fieldtype,"analyzer");
if|if
condition|(
name|node
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|analyzerName
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"class"
argument_list|)
decl_stmt|;
if|if
condition|(
name|analyzerName
operator|!=
literal|null
condition|)
block|{
return|return
operator|(
name|Analyzer
operator|)
name|Config
operator|.
name|newInstance
argument_list|(
name|analyzerName
argument_list|)
return|;
block|}
name|XPath
name|xpath
init|=
name|XPathFactory
operator|.
name|newInstance
argument_list|()
operator|.
name|newXPath
argument_list|()
decl_stmt|;
name|Node
name|tokNode
init|=
operator|(
name|Node
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"./tokenizer"
argument_list|,
name|node
argument_list|,
name|XPathConstants
operator|.
name|NODE
argument_list|)
decl_stmt|;
name|NodeList
name|nList
init|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"./filter"
argument_list|,
name|node
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
literal|1
argument_list|,
literal|"analyzer without class or tokenizer& filter list"
argument_list|)
throw|;
block|}
name|TokenizerFactory
name|tfac
init|=
name|readTokenizerFactory
argument_list|(
name|tokNode
argument_list|)
decl_stmt|;
comment|/******     // oops, getChildNodes() includes text (newlines, etc) in addition     // to the actual child elements     NodeList nList = node.getChildNodes();     TokenizerFactory tfac = readTokenizerFactory(nList.item(0));      if (tfac==null) {        throw new SolrException(1,"TokenizerFactory must be specified first in analyzer");      }     ******/
name|ArrayList
argument_list|<
name|TokenFilterFactory
argument_list|>
name|filters
init|=
operator|new
name|ArrayList
argument_list|<
name|TokenFilterFactory
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nList
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|TokenFilterFactory
name|filt
init|=
name|readTokenFilterFactory
argument_list|(
name|nList
operator|.
name|item
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|filt
operator|!=
literal|null
condition|)
name|filters
operator|.
name|add
argument_list|(
name|filt
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|TokenizerChain
argument_list|(
name|tfac
argument_list|,
name|filters
operator|.
name|toArray
argument_list|(
operator|new
name|TokenFilterFactory
index|[
name|filters
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
empty_stmt|;
comment|//<tokenizer class="solr.StandardFilterFactory"/>
DECL|method|readTokenizerFactory
specifier|private
name|TokenizerFactory
name|readTokenizerFactory
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
comment|// if (node.getNodeName() != "tokenizer") return null;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"class"
argument_list|,
literal|"tokenizer"
argument_list|)
decl_stmt|;
name|TokenizerFactory
name|tfac
init|=
operator|(
name|TokenizerFactory
operator|)
name|Config
operator|.
name|newInstance
argument_list|(
name|className
argument_list|)
decl_stmt|;
name|tfac
operator|.
name|init
argument_list|(
name|DOMUtil
operator|.
name|toMapExcept
argument_list|(
name|attrs
argument_list|,
literal|"class"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tfac
return|;
block|}
comment|//<tokenizer class="solr.StandardFilterFactory"/>
DECL|method|readTokenFilterFactory
specifier|private
name|TokenFilterFactory
name|readTokenFilterFactory
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
comment|// if (node.getNodeName() != "filter") return null;
name|NamedNodeMap
name|attrs
init|=
name|node
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|attrs
argument_list|,
literal|"class"
argument_list|,
literal|"token filter"
argument_list|)
decl_stmt|;
name|TokenFilterFactory
name|tfac
init|=
operator|(
name|TokenFilterFactory
operator|)
name|Config
operator|.
name|newInstance
argument_list|(
name|className
argument_list|)
decl_stmt|;
name|tfac
operator|.
name|init
argument_list|(
name|DOMUtil
operator|.
name|toMapExcept
argument_list|(
name|attrs
argument_list|,
literal|"class"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tfac
return|;
block|}
comment|//
comment|// Instead of storing a type, this could be implemented as a hierarchy
comment|// with a virtual matches().
comment|// Given how often a search will be done, however, speed is the overriding
comment|// concern and I'm not sure which is faster.
comment|//
DECL|class|DynamicField
specifier|final
specifier|static
class|class
name|DynamicField
block|{
DECL|field|STARTS_WITH
specifier|final
specifier|static
name|int
name|STARTS_WITH
init|=
literal|1
decl_stmt|;
DECL|field|ENDS_WITH
specifier|final
specifier|static
name|int
name|ENDS_WITH
init|=
literal|2
decl_stmt|;
DECL|field|regex
specifier|final
name|String
name|regex
decl_stmt|;
DECL|field|type
specifier|final
name|int
name|type
decl_stmt|;
DECL|field|prototype
specifier|final
name|SchemaField
name|prototype
decl_stmt|;
DECL|field|str
specifier|final
name|String
name|str
decl_stmt|;
DECL|method|DynamicField
name|DynamicField
parameter_list|(
name|SchemaField
name|prototype
parameter_list|)
block|{
name|this
operator|.
name|regex
operator|=
name|prototype
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|regex
operator|.
name|startsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|type
operator|=
name|ENDS_WITH
expr_stmt|;
name|str
operator|=
name|regex
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regex
operator|.
name|endsWith
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|type
operator|=
name|STARTS_WITH
expr_stmt|;
name|str
operator|=
name|regex
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|regex
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"dynamic field name must start or end with *"
argument_list|)
throw|;
block|}
name|this
operator|.
name|prototype
operator|=
name|prototype
expr_stmt|;
block|}
DECL|method|matches
name|boolean
name|matches
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|STARTS_WITH
operator|&&
name|name
operator|.
name|startsWith
argument_list|(
name|str
argument_list|)
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|ENDS_WITH
operator|&&
name|name
operator|.
name|endsWith
argument_list|(
name|str
argument_list|)
condition|)
return|return
literal|true
return|;
else|else
return|return
literal|false
return|;
block|}
DECL|method|makeSchemaField
name|SchemaField
name|makeSchemaField
parameter_list|(
name|String
name|name
parameter_list|)
block|{
comment|// could have a cache instead of returning a new one each time, but it might
comment|// not be worth it.
comment|// Actually, a higher level cache could be worth it to avoid too many
comment|// .startsWith() and .endsWith() comparisons.  it depends on how many
comment|// dynamic fields there are.
return|return
operator|new
name|SchemaField
argument_list|(
name|prototype
argument_list|,
name|name
argument_list|)
return|;
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|prototype
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|field|dynamicFields
specifier|private
name|DynamicField
index|[]
name|dynamicFields
decl_stmt|;
comment|// get a field, and if not statically defined, check dynamic fields.
DECL|method|getField
specifier|public
name|SchemaField
name|getField
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
return|return
name|f
return|;
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|df
operator|.
name|makeSchemaField
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
comment|// Hmmm, default field could also be implemented with a dynamic field of "*".
comment|// It would have to be special-cased and only used if nothing else matched.
comment|/***  REMOVED -YCS     if (defaultFieldType != null) return new SchemaField(fieldName,defaultFieldType);     ***/
throw|throw
operator|new
name|SolrException
argument_list|(
literal|1
argument_list|,
literal|"undefined field "
operator|+
name|fieldName
argument_list|)
throw|;
block|}
comment|// This method exists because it can be more efficient for dynamic fields
comment|// if a full SchemaField isn't needed.
DECL|method|getFieldType
specifier|public
name|FieldType
name|getFieldType
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
return|return
name|f
operator|.
name|getType
argument_list|()
return|;
return|return
name|getDynamicFieldType
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
comment|/**    * return null instead of throwing an exception if    * the field is undefined.    */
DECL|method|getFieldTypeNoEx
specifier|public
name|FieldType
name|getFieldTypeNoEx
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|SchemaField
name|f
init|=
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
return|return
name|f
operator|.
name|getType
argument_list|()
return|;
return|return
name|dynFieldType
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
DECL|method|getDynamicFieldType
specifier|public
name|FieldType
name|getDynamicFieldType
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|df
operator|.
name|prototype
operator|.
name|getType
argument_list|()
return|;
block|}
throw|throw
operator|new
name|SolrException
argument_list|(
literal|400
argument_list|,
literal|"undefined field "
operator|+
name|fieldName
argument_list|)
throw|;
block|}
DECL|method|dynFieldType
specifier|private
name|FieldType
name|dynFieldType
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
for|for
control|(
name|DynamicField
name|df
range|:
name|dynamicFields
control|)
block|{
if|if
condition|(
name|df
operator|.
name|matches
argument_list|(
name|fieldName
argument_list|)
condition|)
return|return
name|df
operator|.
name|prototype
operator|.
name|getType
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
empty_stmt|;
DECL|field|copyFields
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|SchemaField
index|[]
argument_list|>
name|copyFields
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SchemaField
index|[]
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|getCopyFields
specifier|public
name|SchemaField
index|[]
name|getCopyFields
parameter_list|(
name|String
name|sourceField
parameter_list|)
block|{
return|return
name|copyFields
operator|.
name|get
argument_list|(
name|sourceField
argument_list|)
return|;
block|}
block|}
end_class
end_unit
