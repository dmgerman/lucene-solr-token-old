begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.core
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
operator|.
name|EchoParamStyle
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|DOMUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|admin
operator|.
name|ShowFileRequestHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|handler
operator|.
name|component
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|highlight
operator|.
name|DefaultSolrHighlighter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|highlight
operator|.
name|SolrHighlighter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|QParserPlugin
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|ValueSourceParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|DirectUpdateHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrIndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|UpdateHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|LogUpdateProcessorFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|RunUpdateProcessorFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|UpdateRequestProcessorChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|UpdateRequestProcessorFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|RefCounted
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|plugin
operator|.
name|AbstractPluginLoader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|plugin
operator|.
name|NamedListPluginLoader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|plugin
operator|.
name|SolrCoreAware
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathConstants
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPath
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathExpressionException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import
begin_comment
comment|/**  * @version $Id$  */
end_comment
begin_class
DECL|class|SolrCore
specifier|public
specifier|final
class|class
name|SolrCore
implements|implements
name|SolrInfoMBean
block|{
DECL|field|version
specifier|public
specifier|static
specifier|final
name|String
name|version
init|=
literal|"1.0"
decl_stmt|;
DECL|field|log
specifier|public
specifier|static
name|Logger
name|log
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|SolrCore
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|name
specifier|private
name|String
name|name
decl_stmt|;
DECL|field|logid
specifier|private
name|String
name|logid
decl_stmt|;
comment|// used to show what name is set
DECL|field|coreDescriptor
specifier|private
specifier|final
name|CoreDescriptor
name|coreDescriptor
decl_stmt|;
DECL|field|solrConfig
specifier|private
specifier|final
name|SolrConfig
name|solrConfig
decl_stmt|;
DECL|field|schema
specifier|private
specifier|final
name|IndexSchema
name|schema
decl_stmt|;
DECL|field|dataDir
specifier|private
specifier|final
name|String
name|dataDir
decl_stmt|;
DECL|field|updateHandler
specifier|private
specifier|final
name|UpdateHandler
name|updateHandler
decl_stmt|;
DECL|field|startTime
specifier|private
specifier|final
name|long
name|startTime
decl_stmt|;
DECL|field|reqHandlers
specifier|private
specifier|final
name|RequestHandlers
name|reqHandlers
decl_stmt|;
DECL|field|highlighter
specifier|private
specifier|final
name|SolrHighlighter
name|highlighter
decl_stmt|;
DECL|field|searchComponents
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|SearchComponent
argument_list|>
name|searchComponents
decl_stmt|;
DECL|field|updateProcessorChains
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|UpdateRequestProcessorChain
argument_list|>
name|updateProcessorChains
decl_stmt|;
DECL|field|infoRegistry
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|SolrInfoMBean
argument_list|>
name|infoRegistry
decl_stmt|;
DECL|method|getStartTime
specifier|public
name|long
name|getStartTime
parameter_list|()
block|{
return|return
name|startTime
return|;
block|}
comment|/**    * @deprecated Use {@link CoreContainer#getCore(String)} instead.    */
annotation|@
name|Deprecated
DECL|field|instance
specifier|private
specifier|static
name|SolrCore
name|instance
decl_stmt|;
DECL|field|boolean_query_max_clause_count
specifier|static
name|int
name|boolean_query_max_clause_count
init|=
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
comment|// only change the BooleanQuery maxClauseCount once for ALL cores...
DECL|method|booleanQueryMaxClauseCount
name|void
name|booleanQueryMaxClauseCount
parameter_list|()
block|{
synchronized|synchronized
init|(
name|SolrCore
operator|.
name|class
init|)
block|{
if|if
condition|(
name|boolean_query_max_clause_count
operator|==
name|Integer
operator|.
name|MIN_VALUE
condition|)
block|{
name|boolean_query_max_clause_count
operator|=
name|solrConfig
operator|.
name|booleanQueryMaxClauseCount
expr_stmt|;
name|BooleanQuery
operator|.
name|setMaxClauseCount
argument_list|(
name|boolean_query_max_clause_count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|boolean_query_max_clause_count
operator|!=
name|solrConfig
operator|.
name|booleanQueryMaxClauseCount
condition|)
block|{
name|log
operator|.
name|fine
argument_list|(
literal|"BooleanQuery.maxClauseCount= "
operator|+
name|boolean_query_max_clause_count
operator|+
literal|", ignoring "
operator|+
name|solrConfig
operator|.
name|booleanQueryMaxClauseCount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * The SolrResourceLoader used to load all resources for this core.    * @since solr 1.3    */
DECL|method|getResourceLoader
specifier|public
name|SolrResourceLoader
name|getResourceLoader
parameter_list|()
block|{
return|return
name|solrConfig
operator|.
name|getResourceLoader
argument_list|()
return|;
block|}
comment|/**    * Gets the configuration resource name used by this core instance.    * @since solr 1.3    */
DECL|method|getConfigResource
specifier|public
name|String
name|getConfigResource
parameter_list|()
block|{
return|return
name|solrConfig
operator|.
name|getResourceName
argument_list|()
return|;
block|}
comment|/**    * Gets the configuration resource name used by this core instance.    * @deprecated Use {@link #getConfigResource()} instead.    */
annotation|@
name|Deprecated
DECL|method|getConfigFile
specifier|public
name|String
name|getConfigFile
parameter_list|()
block|{
return|return
name|solrConfig
operator|.
name|getResourceName
argument_list|()
return|;
block|}
comment|/**    * Gets the configuration object used by this core instance.    */
DECL|method|getSolrConfig
specifier|public
name|SolrConfig
name|getSolrConfig
parameter_list|()
block|{
return|return
name|solrConfig
return|;
block|}
comment|/**    * Gets the schema resource name used by this core instance.    * @since solr 1.3    */
DECL|method|getSchemaResource
specifier|public
name|String
name|getSchemaResource
parameter_list|()
block|{
return|return
name|schema
operator|.
name|getResourceName
argument_list|()
return|;
block|}
comment|/**    * Gets the schema resource name used by this core instance.    * @deprecated Use {@link #getSchemaResource()} instead.    */
annotation|@
name|Deprecated
DECL|method|getSchemaFile
specifier|public
name|String
name|getSchemaFile
parameter_list|()
block|{
return|return
name|schema
operator|.
name|getResourceName
argument_list|()
return|;
block|}
comment|/**    * Gets the schema object used by this core instance.    */
DECL|method|getSchema
specifier|public
name|IndexSchema
name|getSchema
parameter_list|()
block|{
return|return
name|schema
return|;
block|}
DECL|method|getDataDir
specifier|public
name|String
name|getDataDir
parameter_list|()
block|{
return|return
name|dataDir
return|;
block|}
DECL|method|getIndexDir
specifier|public
name|String
name|getIndexDir
parameter_list|()
block|{
return|return
name|dataDir
operator|+
literal|"index/"
return|;
block|}
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|setName
specifier|public
name|void
name|setName
parameter_list|(
name|String
name|v
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|v
expr_stmt|;
name|this
operator|.
name|logid
operator|=
operator|(
name|v
operator|==
literal|null
operator|)
condition|?
literal|""
else|:
operator|(
literal|"["
operator|+
name|v
operator|+
literal|"] "
operator|)
expr_stmt|;
block|}
DECL|method|getLogId
specifier|public
name|String
name|getLogId
parameter_list|()
block|{
return|return
name|this
operator|.
name|logid
return|;
block|}
comment|/**    * @return the Info Registry map which contains SolrInfoMBean objects keyed by name    * @since solr 1.3    */
DECL|method|getInfoRegistry
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|SolrInfoMBean
argument_list|>
name|getInfoRegistry
parameter_list|()
block|{
return|return
name|infoRegistry
return|;
block|}
DECL|method|parseListener
specifier|public
name|List
argument_list|<
name|SolrEventListener
argument_list|>
name|parseListener
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|List
argument_list|<
name|SolrEventListener
argument_list|>
name|lst
init|=
operator|new
name|ArrayList
argument_list|<
name|SolrEventListener
argument_list|>
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
name|logid
operator|+
literal|"Searching for listeners: "
operator|+
name|path
argument_list|)
expr_stmt|;
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|solrConfig
operator|.
name|evaluate
argument_list|(
name|path
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|className
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|node
argument_list|,
literal|"class"
argument_list|)
decl_stmt|;
name|SolrEventListener
name|listener
init|=
name|createEventListener
argument_list|(
name|className
argument_list|)
decl_stmt|;
name|listener
operator|.
name|init
argument_list|(
name|DOMUtil
operator|.
name|childNodesToNamedList
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|logid
operator|+
literal|"Added SolrEventListener: "
operator|+
name|listener
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|lst
return|;
block|}
DECL|field|firstSearcherListeners
name|List
argument_list|<
name|SolrEventListener
argument_list|>
name|firstSearcherListeners
decl_stmt|;
DECL|field|newSearcherListeners
name|List
argument_list|<
name|SolrEventListener
argument_list|>
name|newSearcherListeners
decl_stmt|;
DECL|method|parseListeners
specifier|private
name|void
name|parseListeners
parameter_list|()
block|{
name|firstSearcherListeners
operator|=
name|parseListener
argument_list|(
literal|"//listener[@event=\"firstSearcher\"]"
argument_list|)
expr_stmt|;
name|newSearcherListeners
operator|=
name|parseListener
argument_list|(
literal|"//listener[@event=\"newSearcher\"]"
argument_list|)
expr_stmt|;
block|}
comment|/**    * NOTE: this function is not thread safe.  However, it is safe to call within the    *<code>inform( SolrCore core )</code> function for<code>SolrCoreAware</code> classes.    * Outside<code>inform</code>, this could potentially throw a ConcurrentModificationException    *     * @see SolrCoreAware    */
DECL|method|registerFirstSearcherListener
specifier|public
name|void
name|registerFirstSearcherListener
parameter_list|(
name|SolrEventListener
name|listener
parameter_list|)
block|{
name|firstSearcherListeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|/**    * NOTE: this function is not thread safe.  However, it is safe to call within the    *<code>inform( SolrCore core )</code> function for<code>SolrCoreAware</code> classes.    * Outside<code>inform</code>, this could potentially throw a ConcurrentModificationException    *     * @see SolrCoreAware    */
DECL|method|registerNewSearcherListener
specifier|public
name|void
name|registerNewSearcherListener
parameter_list|(
name|SolrEventListener
name|listener
parameter_list|)
block|{
name|newSearcherListeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|/**    * NOTE: this function is not thread safe.  However, it is safe to call within the    *<code>inform( SolrCore core )</code> function for<code>SolrCoreAware</code> classes.    * Outside<code>inform</code>, this could potentially throw a ConcurrentModificationException    *     * @see SolrCoreAware    */
DECL|method|registerResponseWriter
specifier|public
name|void
name|registerResponseWriter
parameter_list|(
name|String
name|name
parameter_list|,
name|QueryResponseWriter
name|responseWriter
parameter_list|)
block|{
name|responseWriters
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|responseWriter
argument_list|)
expr_stmt|;
block|}
comment|// gets a non-caching searcher
DECL|method|newSearcher
specifier|public
name|SolrIndexSearcher
name|newSearcher
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|newSearcher
argument_list|(
name|name
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// gets a non-caching searcher
DECL|method|newSearcher
specifier|public
name|SolrIndexSearcher
name|newSearcher
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|readOnly
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|SolrIndexSearcher
argument_list|(
name|this
argument_list|,
name|schema
argument_list|,
literal|"main"
argument_list|,
name|IndexReader
operator|.
name|open
argument_list|(
name|FSDirectory
operator|.
name|getDirectory
argument_list|(
name|getIndexDir
argument_list|()
argument_list|)
argument_list|,
name|readOnly
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// protect via synchronized(SolrCore.class)
DECL|field|dirs
specifier|private
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|dirs
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// currently only called with SolrCore.class lock held
DECL|method|initIndex
name|void
name|initIndex
parameter_list|()
block|{
try|try
block|{
name|File
name|dirFile
init|=
operator|new
name|File
argument_list|(
name|getIndexDir
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|indexExists
init|=
name|dirFile
operator|.
name|canRead
argument_list|()
decl_stmt|;
name|boolean
name|firstTime
init|=
name|dirs
operator|.
name|add
argument_list|(
name|dirFile
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|removeLocks
init|=
name|solrConfig
operator|.
name|getBool
argument_list|(
literal|"mainIndex/unlockOnStartup"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexExists
operator|&&
name|firstTime
operator|&&
name|removeLocks
condition|)
block|{
comment|// to remove locks, the directory must already exist... so we create it
comment|// if it didn't exist already...
name|Directory
name|dir
init|=
name|SolrIndexWriter
operator|.
name|getDirectory
argument_list|(
name|getIndexDir
argument_list|()
argument_list|,
name|solrConfig
operator|.
name|mainIndexConfig
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|!=
literal|null
operator|&&
name|IndexWriter
operator|.
name|isLocked
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
name|logid
operator|+
literal|"WARNING: Solr index directory '"
operator|+
name|getIndexDir
argument_list|()
operator|+
literal|"' is locked.  Unlocking..."
argument_list|)
expr_stmt|;
name|IndexWriter
operator|.
name|unlock
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Create the index if it doesn't exist.
if|if
condition|(
operator|!
name|indexExists
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
name|logid
operator|+
literal|"Solr index directory '"
operator|+
name|dirFile
operator|+
literal|"' doesn't exist."
operator|+
literal|" Creating new index..."
argument_list|)
expr_stmt|;
name|SolrIndexWriter
name|writer
init|=
operator|new
name|SolrIndexWriter
argument_list|(
literal|"SolrCore.initIndex"
argument_list|,
name|getIndexDir
argument_list|()
argument_list|,
literal|true
argument_list|,
name|schema
argument_list|,
name|solrConfig
operator|.
name|mainIndexConfig
argument_list|)
decl_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Creates an instance by trying a constructor that accepts a SolrCore before    *  trying the default (no arg) constructor.    *@param className the instance class to create    *@cast the class or interface that the instance should extend or implement    *@param msg a message helping compose the exception error if any occurs.    *@return the desired instance    *@throws SolrException if the object could not be instantiated    */
DECL|method|createInstance
specifier|private
parameter_list|<
name|T
extends|extends
name|Object
parameter_list|>
name|T
name|createInstance
parameter_list|(
name|String
name|className
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|cast
parameter_list|,
name|String
name|msg
parameter_list|)
block|{
name|Class
name|clazz
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|msg
operator|==
literal|null
condition|)
name|msg
operator|=
literal|"SolrCore Object"
expr_stmt|;
try|try
block|{
try|try
block|{
name|clazz
operator|=
name|solrConfig
operator|.
name|getResourceLoader
argument_list|()
operator|.
name|findClass
argument_list|(
name|className
argument_list|)
expr_stmt|;
if|if
condition|(
name|cast
operator|!=
literal|null
operator|&&
operator|!
name|cast
operator|.
name|isAssignableFrom
argument_list|(
name|clazz
argument_list|)
condition|)
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error Instantiating "
operator|+
name|msg
operator|+
literal|", "
operator|+
name|className
operator|+
literal|" is not a "
operator|+
name|cast
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
name|cons
init|=
name|clazz
operator|.
name|getConstructor
argument_list|(
operator|new
name|Class
index|[]
block|{
name|SolrCore
operator|.
name|class
block|}
argument_list|)
decl_stmt|;
return|return
operator|(
name|T
operator|)
name|cons
operator|.
name|newInstance
argument_list|(
operator|new
name|Object
index|[]
block|{
name|this
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|xnomethod
parameter_list|)
block|{
return|return
operator|(
name|T
operator|)
name|clazz
operator|.
name|newInstance
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error Instantiating "
operator|+
name|msg
operator|+
literal|", "
operator|+
name|className
operator|+
literal|" failed to instantiate "
operator|+
name|cast
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|createEventListener
specifier|public
name|SolrEventListener
name|createEventListener
parameter_list|(
name|String
name|className
parameter_list|)
block|{
return|return
name|createInstance
argument_list|(
name|className
argument_list|,
name|SolrEventListener
operator|.
name|class
argument_list|,
literal|"Event Listener"
argument_list|)
return|;
block|}
DECL|method|createRequestHandler
specifier|public
name|SolrRequestHandler
name|createRequestHandler
parameter_list|(
name|String
name|className
parameter_list|)
block|{
return|return
name|createInstance
argument_list|(
name|className
argument_list|,
name|SolrRequestHandler
operator|.
name|class
argument_list|,
literal|"Request Handler"
argument_list|)
return|;
block|}
DECL|method|createUpdateHandler
specifier|private
name|UpdateHandler
name|createUpdateHandler
parameter_list|(
name|String
name|className
parameter_list|)
block|{
return|return
name|createInstance
argument_list|(
name|className
argument_list|,
name|UpdateHandler
operator|.
name|class
argument_list|,
literal|"Update Handler"
argument_list|)
return|;
block|}
DECL|method|createHighlighter
specifier|private
name|SolrHighlighter
name|createHighlighter
parameter_list|(
name|String
name|className
parameter_list|)
block|{
return|return
name|createInstance
argument_list|(
name|className
argument_list|,
name|SolrHighlighter
operator|.
name|class
argument_list|,
literal|"Highlighter"
argument_list|)
return|;
block|}
comment|/**     * @return the last core initialized.  If you are using multiple cores,     * this is not a function to use.    *     * @deprecated Use {@link CoreContainer#getCore(String)} instead.    */
annotation|@
name|Deprecated
DECL|method|getSolrCore
specifier|public
specifier|static
name|SolrCore
name|getSolrCore
parameter_list|()
block|{
synchronized|synchronized
init|(
name|SolrCore
operator|.
name|class
init|)
block|{
if|if
condition|(
name|instance
operator|==
literal|null
condition|)
block|{
try|try
block|{
comment|// sets 'instance' to the latest solr core
name|instance
operator|=
operator|new
name|SolrCore
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
operator|new
name|SolrConfig
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|xany
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"error creating core"
argument_list|,
name|xany
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|instance
return|;
block|}
comment|/**    *     * @param dataDir    * @param schema    * @throws SAXException     * @throws IOException     * @throws ParserConfigurationException     *     * @since solr 1.0    */
DECL|method|SolrCore
specifier|public
name|SolrCore
parameter_list|(
name|String
name|dataDir
parameter_list|,
name|IndexSchema
name|schema
parameter_list|)
throws|throws
name|ParserConfigurationException
throws|,
name|IOException
throws|,
name|SAXException
block|{
name|this
argument_list|(
literal|null
argument_list|,
name|dataDir
argument_list|,
operator|new
name|SolrConfig
argument_list|()
argument_list|,
name|schema
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a new core and register it in the list of cores.    * If a core with the same name already exists, it will be stopped and replaced by this one.    *@param dataDir the index directory    *@param config a solr config instance    *@param schema a solr schema instance    *    *@since solr 1.3    */
DECL|method|SolrCore
specifier|public
name|SolrCore
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|dataDir
parameter_list|,
name|SolrConfig
name|config
parameter_list|,
name|IndexSchema
name|schema
parameter_list|,
name|CoreDescriptor
name|cd
parameter_list|)
block|{
synchronized|synchronized
init|(
name|SolrCore
operator|.
name|class
init|)
block|{
name|coreDescriptor
operator|=
name|cd
expr_stmt|;
comment|// this is for backward compatibility (and also the reason
comment|// the sync block is needed)
name|instance
operator|=
name|this
expr_stmt|;
comment|// set singleton
name|this
operator|.
name|setName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SolrResourceLoader
name|loader
init|=
name|config
operator|.
name|getResourceLoader
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataDir
operator|==
literal|null
condition|)
name|dataDir
operator|=
name|config
operator|.
name|get
argument_list|(
literal|"dataDir"
argument_list|,
name|loader
operator|.
name|getInstanceDir
argument_list|()
operator|+
literal|"data/"
argument_list|)
expr_stmt|;
name|dataDir
operator|=
name|SolrResourceLoader
operator|.
name|normalizeDir
argument_list|(
name|dataDir
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|logid
operator|+
literal|"Opening new SolrCore at "
operator|+
name|loader
operator|.
name|getInstanceDir
argument_list|()
operator|+
literal|", dataDir="
operator|+
name|dataDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|schema
operator|==
literal|null
condition|)
block|{
name|schema
operator|=
operator|new
name|IndexSchema
argument_list|(
name|config
argument_list|,
name|IndexSchema
operator|.
name|DEFAULT_SCHEMA_FILE
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|//Initialize JMX
if|if
condition|(
name|config
operator|.
name|jmxConfig
operator|.
name|enabled
condition|)
block|{
name|infoRegistry
operator|=
operator|new
name|JmxMonitoredMap
argument_list|<
name|String
argument_list|,
name|SolrInfoMBean
argument_list|>
argument_list|(
name|name
argument_list|,
name|config
operator|.
name|jmxConfig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"JMX monitoring not detected for core: "
operator|+
name|name
argument_list|)
expr_stmt|;
name|infoRegistry
operator|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|SolrInfoMBean
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|schema
operator|=
name|schema
expr_stmt|;
name|this
operator|.
name|dataDir
operator|=
name|dataDir
expr_stmt|;
name|this
operator|.
name|solrConfig
operator|=
name|config
expr_stmt|;
name|this
operator|.
name|startTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxWarmingSearchers
operator|=
name|config
operator|.
name|getInt
argument_list|(
literal|"query/maxWarmingSearchers"
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|booleanQueryMaxClauseCount
argument_list|()
expr_stmt|;
name|parseListeners
argument_list|()
expr_stmt|;
name|initIndex
argument_list|()
expr_stmt|;
name|initWriters
argument_list|()
expr_stmt|;
name|initQParsers
argument_list|()
expr_stmt|;
name|initValueSourceParsers
argument_list|()
expr_stmt|;
name|this
operator|.
name|searchComponents
operator|=
name|loadSearchComponents
argument_list|(
name|config
argument_list|)
expr_stmt|;
comment|// Processors initialized before the handlers
name|updateProcessorChains
operator|=
name|loadUpdateProcessorChains
argument_list|()
expr_stmt|;
name|reqHandlers
operator|=
operator|new
name|RequestHandlers
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|reqHandlers
operator|.
name|initHandlersFromConfig
argument_list|(
name|solrConfig
argument_list|)
expr_stmt|;
name|highlighter
operator|=
name|createHighlighter
argument_list|(
name|solrConfig
operator|.
name|get
argument_list|(
literal|"highlighting/@class"
argument_list|,
name|DefaultSolrHighlighter
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|highlighter
operator|.
name|initalize
argument_list|(
name|solrConfig
argument_list|)
expr_stmt|;
comment|// Handle things that should eventually go away
name|initDeprecatedSupport
argument_list|()
expr_stmt|;
specifier|final
name|CountDownLatch
name|latch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
try|try
block|{
comment|// cause the executor to stall so firstSearcher events won't fire
comment|// until after inform() has been called for all components.
comment|// searchExecutor must be single-threaded for this to work
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Open the searcher *before* the update handler so we don't end up opening
comment|// one in the middle.
comment|// With lockless commits in Lucene now, this probably shouldn't be an issue anymore
name|getSearcher
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|updateHandler
operator|=
name|createUpdateHandler
argument_list|(
name|solrConfig
operator|.
name|get
argument_list|(
literal|"updateHandler/@class"
argument_list|,
name|DirectUpdateHandler
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|infoRegistry
operator|.
name|put
argument_list|(
literal|"updateHandler"
argument_list|,
name|updateHandler
argument_list|)
expr_stmt|;
comment|// Finally tell anyone who wants to know
name|loader
operator|.
name|inform
argument_list|(
name|loader
argument_list|)
expr_stmt|;
name|loader
operator|.
name|inform
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// allow firstSearcher events to fire
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
comment|// end synchronized
name|infoRegistry
operator|.
name|put
argument_list|(
literal|"core"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * Load the request processors configured in solrconfig.xml    */
DECL|method|loadUpdateProcessorChains
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|UpdateRequestProcessorChain
argument_list|>
name|loadUpdateProcessorChains
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|UpdateRequestProcessorChain
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|UpdateRequestProcessorChain
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|String
name|parsingErrorText
init|=
literal|"Parsing Update Request Processor Chain"
decl_stmt|;
name|UpdateRequestProcessorChain
name|def
init|=
literal|null
decl_stmt|;
comment|// This is kinda ugly, but at least it keeps the xpath logic in one place
comment|// away from the Processors themselves.
name|XPath
name|xpath
init|=
name|solrConfig
operator|.
name|getXPath
argument_list|()
decl_stmt|;
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|solrConfig
operator|.
name|evaluate
argument_list|(
literal|"updateRequestProcessorChain"
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
name|boolean
name|requireName
init|=
name|nodes
operator|.
name|getLength
argument_list|()
operator|>
literal|1
decl_stmt|;
if|if
condition|(
name|nodes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|node
argument_list|,
literal|"name"
argument_list|,
name|requireName
condition|?
name|parsingErrorText
else|:
literal|null
argument_list|)
decl_stmt|;
name|boolean
name|isDefault
init|=
literal|"true"
operator|.
name|equals
argument_list|(
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|node
argument_list|,
literal|"default"
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
name|NodeList
name|links
init|=
literal|null
decl_stmt|;
try|try
block|{
name|links
operator|=
operator|(
name|NodeList
operator|)
name|xpath
operator|.
name|evaluate
argument_list|(
literal|"processor"
argument_list|,
name|node
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|XPathExpressionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error reading processors"
argument_list|,
name|e
argument_list|,
literal|false
argument_list|)
throw|;
block|}
if|if
condition|(
name|links
operator|==
literal|null
operator|||
name|links
operator|.
name|getLength
argument_list|()
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"updateRequestProcessorChain require at least one processor"
argument_list|)
throw|;
block|}
comment|// keep a list of the factories...
specifier|final
name|ArrayList
argument_list|<
name|UpdateRequestProcessorFactory
argument_list|>
name|factories
init|=
operator|new
name|ArrayList
argument_list|<
name|UpdateRequestProcessorFactory
argument_list|>
argument_list|(
name|links
operator|.
name|getLength
argument_list|()
argument_list|)
decl_stmt|;
comment|// Load and initialize the plugin chain
name|AbstractPluginLoader
argument_list|<
name|UpdateRequestProcessorFactory
argument_list|>
name|loader
init|=
operator|new
name|AbstractPluginLoader
argument_list|<
name|UpdateRequestProcessorFactory
argument_list|>
argument_list|(
literal|"processor chain"
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|init
parameter_list|(
name|UpdateRequestProcessorFactory
name|plugin
parameter_list|,
name|Node
name|node
parameter_list|)
throws|throws
name|Exception
block|{
name|plugin
operator|.
name|init
argument_list|(
operator|(
name|node
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|DOMUtil
operator|.
name|childNodesToNamedList
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|UpdateRequestProcessorFactory
name|register
parameter_list|(
name|String
name|name
parameter_list|,
name|UpdateRequestProcessorFactory
name|plugin
parameter_list|)
throws|throws
name|Exception
block|{
name|factories
operator|.
name|add
argument_list|(
name|plugin
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
name|loader
operator|.
name|load
argument_list|(
name|solrConfig
operator|.
name|getResourceLoader
argument_list|()
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|UpdateRequestProcessorChain
name|chain
init|=
operator|new
name|UpdateRequestProcessorChain
argument_list|(
name|factories
operator|.
name|toArray
argument_list|(
operator|new
name|UpdateRequestProcessorFactory
index|[
name|factories
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|isDefault
operator|||
name|nodes
operator|.
name|getLength
argument_list|()
operator|==
literal|1
condition|)
block|{
name|def
operator|=
name|chain
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|def
operator|==
literal|null
condition|)
block|{
comment|// construct the default chain
name|UpdateRequestProcessorFactory
index|[]
name|factories
init|=
operator|new
name|UpdateRequestProcessorFactory
index|[]
block|{
operator|new
name|RunUpdateProcessorFactory
argument_list|()
block|,
operator|new
name|LogUpdateProcessorFactory
argument_list|()
block|}
decl_stmt|;
name|def
operator|=
operator|new
name|UpdateRequestProcessorChain
argument_list|(
name|factories
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|def
argument_list|)
expr_stmt|;
return|return
name|map
return|;
block|}
comment|/**    * @return an update processor registered to the given name.  Throw an exception if this chain is undefined    */
DECL|method|getUpdateProcessingChain
specifier|public
name|UpdateRequestProcessorChain
name|getUpdateProcessingChain
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
name|UpdateRequestProcessorChain
name|chain
init|=
name|updateProcessorChains
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|chain
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"unknown UpdateRequestProcessorChain: "
operator|+
name|name
argument_list|)
throw|;
block|}
return|return
name|chain
return|;
block|}
comment|// this core current usage count
DECL|field|refCount
specifier|private
specifier|final
name|AtomicInteger
name|refCount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|method|open
specifier|final
name|void
name|open
parameter_list|()
block|{
name|refCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/**    * Close all resources allocated by the core...    *<ul>    *<li>searcher</li>    *<li>updateHandler</li>    *<li>all CloseHooks will be notified</li>    *<li>All MBeans will be unregistered from MBeanServer if JMX was enabled    *</li>    *</ul>    *<p>    * This should always be called when the core is obtained through {@link CoreContainer#getCore} or {@link CoreContainer#getAdminCore}    *</p>    *<p>    * The actual close is performed if the core usage count is 1.    * (A core is created with a usage count of 1).    * If usage count is> 1, the usage count is decreased by 1.    * If usage count is&lt; 0, this is an error and a runtime exception     * is thrown.    *</p>    */
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
name|int
name|count
init|=
name|refCount
operator|.
name|decrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
comment|//throw new RuntimeException("Too many closes on " + this);
name|log
operator|.
name|severe
argument_list|(
literal|"Too many close {count:"
operator|+
name|count
operator|+
literal|"} on "
operator|+
name|this
operator|+
literal|". Please report this exception to solr-user@lucene.apache.org"
argument_list|)
expr_stmt|;
return|return;
block|}
name|log
operator|.
name|info
argument_list|(
name|logid
operator|+
literal|" CLOSING SolrCore "
operator|+
name|this
argument_list|)
expr_stmt|;
try|try
block|{
name|infoRegistry
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|closeSearcher
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|searcherExecutor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|updateHandler
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|closeHooks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|CloseHook
name|hook
range|:
name|closeHooks
control|)
block|{
name|hook
operator|.
name|close
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Current core usage count. */
DECL|method|getOpenCount
specifier|public
name|int
name|getOpenCount
parameter_list|()
block|{
return|return
name|refCount
operator|.
name|get
argument_list|()
return|;
block|}
comment|/** Whether this core is closed. */
DECL|method|isClosed
specifier|public
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|refCount
operator|.
name|get
argument_list|()
operator|<=
literal|0
return|;
block|}
DECL|method|finalize
specifier|protected
name|void
name|finalize
parameter_list|()
block|{
if|if
condition|(
name|getOpenCount
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|log
operator|.
name|severe
argument_list|(
literal|"REFCOUNT ERROR: unreferenced "
operator|+
name|this
operator|+
literal|" ("
operator|+
name|getName
argument_list|()
operator|+
literal|") has a reference count of "
operator|+
name|getOpenCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|closeHooks
specifier|private
name|List
argument_list|<
name|CloseHook
argument_list|>
name|closeHooks
init|=
literal|null
decl_stmt|;
comment|/**     * Add a close callback hook     */
DECL|method|addCloseHook
specifier|public
name|void
name|addCloseHook
parameter_list|(
name|CloseHook
name|hook
parameter_list|)
block|{
if|if
condition|(
name|closeHooks
operator|==
literal|null
condition|)
block|{
name|closeHooks
operator|=
operator|new
name|ArrayList
argument_list|<
name|CloseHook
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|closeHooks
operator|.
name|add
argument_list|(
name|hook
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns a Request object based on the admin/pingQuery section    * of the Solr config file.    *     * @deprecated use {@link org.apache.solr.handler.PingRequestHandler} instead    */
annotation|@
name|Deprecated
DECL|method|getPingQueryRequest
specifier|public
name|SolrQueryRequest
name|getPingQueryRequest
parameter_list|()
block|{
return|return
name|solrConfig
operator|.
name|getPingQueryRequest
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|////////////////////////////////////////////////////////////////////////////////
comment|// Request Handler
comment|////////////////////////////////////////////////////////////////////////////////
comment|/**    * Get the request handler registered to a given name.      *     * This function is thread safe.    */
DECL|method|getRequestHandler
specifier|public
name|SolrRequestHandler
name|getRequestHandler
parameter_list|(
name|String
name|handlerName
parameter_list|)
block|{
return|return
name|reqHandlers
operator|.
name|get
argument_list|(
name|handlerName
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifieable Map containing the registered handlers    */
DECL|method|getRequestHandlers
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|SolrRequestHandler
argument_list|>
name|getRequestHandlers
parameter_list|()
block|{
return|return
name|reqHandlers
operator|.
name|getRequestHandlers
argument_list|()
return|;
block|}
comment|/**    * Get the SolrHighlighter    */
DECL|method|getHighlighter
specifier|public
name|SolrHighlighter
name|getHighlighter
parameter_list|()
block|{
return|return
name|highlighter
return|;
block|}
comment|/**    * Registers a handler at the specified location.  If one exists there, it will be replaced.    * To remove a handler, register<code>null</code> at its path    *     * Once registered the handler can be accessed through:    *<pre>    *   http://${host}:${port}/${context}/${handlerName}    * or:      *   http://${host}:${port}/${context}/select?qt=${handlerName}    *</pre>      *     * Handlers<em>must</em> be initalized before getting registered.  Registered    * handlers can immediatly accept requests.    *     * This call is thread safe.    *      * @return the previous<code>SolrRequestHandler</code> registered to this name<code>null</code> if none.    */
DECL|method|registerRequestHandler
specifier|public
name|SolrRequestHandler
name|registerRequestHandler
parameter_list|(
name|String
name|handlerName
parameter_list|,
name|SolrRequestHandler
name|handler
parameter_list|)
block|{
return|return
name|reqHandlers
operator|.
name|register
argument_list|(
name|handlerName
argument_list|,
name|handler
argument_list|)
return|;
block|}
comment|/**    * Register the default search components    */
DECL|method|loadSearchComponents
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|SearchComponent
argument_list|>
name|loadSearchComponents
parameter_list|(
name|SolrConfig
name|config
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|SearchComponent
argument_list|>
name|components
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SearchComponent
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|xpath
init|=
literal|"searchComponent"
decl_stmt|;
name|NamedListPluginLoader
argument_list|<
name|SearchComponent
argument_list|>
name|loader
init|=
operator|new
name|NamedListPluginLoader
argument_list|<
name|SearchComponent
argument_list|>
argument_list|(
name|xpath
argument_list|,
name|components
argument_list|)
decl_stmt|;
name|loader
operator|.
name|load
argument_list|(
name|config
operator|.
name|getResourceLoader
argument_list|()
argument_list|,
operator|(
name|NodeList
operator|)
name|config
operator|.
name|evaluate
argument_list|(
name|xpath
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
extends|extends
name|SearchComponent
argument_list|>
argument_list|>
name|standardcomponents
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
extends|extends
name|SearchComponent
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|standardcomponents
operator|.
name|put
argument_list|(
name|QueryComponent
operator|.
name|COMPONENT_NAME
argument_list|,
name|QueryComponent
operator|.
name|class
argument_list|)
expr_stmt|;
name|standardcomponents
operator|.
name|put
argument_list|(
name|FacetComponent
operator|.
name|COMPONENT_NAME
argument_list|,
name|FacetComponent
operator|.
name|class
argument_list|)
expr_stmt|;
name|standardcomponents
operator|.
name|put
argument_list|(
name|MoreLikeThisComponent
operator|.
name|COMPONENT_NAME
argument_list|,
name|MoreLikeThisComponent
operator|.
name|class
argument_list|)
expr_stmt|;
name|standardcomponents
operator|.
name|put
argument_list|(
name|HighlightComponent
operator|.
name|COMPONENT_NAME
argument_list|,
name|HighlightComponent
operator|.
name|class
argument_list|)
expr_stmt|;
name|standardcomponents
operator|.
name|put
argument_list|(
name|DebugComponent
operator|.
name|COMPONENT_NAME
argument_list|,
name|DebugComponent
operator|.
name|class
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
extends|extends
name|SearchComponent
argument_list|>
argument_list|>
name|entry
range|:
name|standardcomponents
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|components
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|SearchComponent
name|comp
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|comp
operator|.
name|init
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// default components initialized with nothing
name|components
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|comp
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrConfig
operator|.
name|severeErrors
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|components
return|;
block|}
comment|/**    * @return a Search Component registered to a given name.  Throw an exception if the component is undefined    */
DECL|method|getSearchComponent
specifier|public
name|SearchComponent
name|getSearchComponent
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|SearchComponent
name|component
init|=
name|searchComponents
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|component
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Unknown Search Component: "
operator|+
name|name
argument_list|)
throw|;
block|}
return|return
name|component
return|;
block|}
comment|/**    * Accessor for all the Search Components    * @return An unmodifiable Map of Search Components    */
DECL|method|getSearchComponents
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|SearchComponent
argument_list|>
name|getSearchComponents
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|searchComponents
argument_list|)
return|;
block|}
comment|////////////////////////////////////////////////////////////////////////////////
comment|// Update Handler
comment|////////////////////////////////////////////////////////////////////////////////
comment|/**    * RequestHandlers need access to the updateHandler so they can all talk to the    * same RAM indexer.      */
DECL|method|getUpdateHandler
specifier|public
name|UpdateHandler
name|getUpdateHandler
parameter_list|()
block|{
return|return
name|updateHandler
return|;
block|}
comment|////////////////////////////////////////////////////////////////////////////////
comment|// Searcher Control
comment|////////////////////////////////////////////////////////////////////////////////
comment|// The current searcher used to service queries.
comment|// Don't access this directly!!!! use getSearcher() to
comment|// get it (and it will increment the ref count at the same time)
DECL|field|_searcher
specifier|private
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|_searcher
decl_stmt|;
comment|// All of the open searchers.  Don't access this directly.
comment|// protected by synchronizing on searcherLock.
DECL|field|_searchers
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
argument_list|>
name|_searchers
init|=
operator|new
name|LinkedList
argument_list|<
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|searcherExecutor
specifier|final
name|ExecutorService
name|searcherExecutor
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
decl_stmt|;
DECL|field|onDeckSearchers
specifier|private
name|int
name|onDeckSearchers
decl_stmt|;
comment|// number of searchers preparing
DECL|field|searcherLock
specifier|private
name|Object
name|searcherLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|// the sync object for the searcher
DECL|field|maxWarmingSearchers
specifier|private
specifier|final
name|int
name|maxWarmingSearchers
decl_stmt|;
comment|// max number of on-deck searchers allowed
comment|/**   * Return a registered {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; with   * the reference count incremented.  It<b>must</b> be decremented when no longer needed.   * This method should not be called from SolrCoreAware.inform() since it can result   * in a deadlock if useColdSearcher==false.    */
DECL|method|getSearcher
specifier|public
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|getSearcher
parameter_list|()
block|{
try|try
block|{
return|return
name|getSearcher
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**   * Return the newest {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; with   * the reference count incremented.  It<b>must</b> be decremented when no longer needed.   * If no searcher is currently open, then if openNew==true a new searcher will be opened,   * or null is returned if openNew==false.   */
DECL|method|getNewestSearcher
specifier|public
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|getNewestSearcher
parameter_list|(
name|boolean
name|openNew
parameter_list|)
block|{
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
name|_searchers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|openNew
condition|)
return|return
literal|null
return|;
comment|// Not currently implemented since simply calling getSearcher during inform()
comment|// can result in a deadlock.  Right now, solr always opens a searcher first
comment|// before calling inform() anyway, so this should never happen.
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|newest
init|=
name|_searchers
operator|.
name|getLast
argument_list|()
decl_stmt|;
name|newest
operator|.
name|incref
argument_list|()
expr_stmt|;
return|return
name|newest
return|;
block|}
block|}
comment|/**    * Get a {@link SolrIndexSearcher} or start the process of creating a new one.    *<p>    * The registered searcher is the default searcher used to service queries.    * A searcher will normally be registered after all of the warming    * and event handlers (newSearcher or firstSearcher events) have run.    * In the case where there is no registered searcher, the newly created searcher will    * be registered before running the event handlers (a slow searcher is better than no searcher).    *    *<p>    * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,    * see newSearcher(String name, boolean readOnly).    *    *<p>    * If<tt>forceNew==true</tt> then    *  A new searcher will be opened and registered regardless of whether there is already    *    a registered searcher or other searchers in the process of being created.    *<p>    * If<tt>forceNew==false</tt> then:<ul>    *<li>If a searcher is already registered, that searcher will be returned</li>    *<li>If no searcher is currently registered, but at least one is in the process of being created, then    * this call will block until the first searcher is registered</li>    *<li>If no searcher is currently registered, and no searchers in the process of being registered, a new    * searcher will be created.</li>    *</ul>    *<p>    * If<tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with    * the reference count incremented.  It<b>must</b> be decremented when no longer needed.    *<p>    * If<tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,    * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to    *<tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time    * this method returned.    *<p>    * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.    * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.    * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.    * @throws IOException    */
DECL|method|getSearcher
specifier|public
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|getSearcher
parameter_list|(
name|boolean
name|forceNew
parameter_list|,
name|boolean
name|returnSearcher
parameter_list|,
specifier|final
name|Future
index|[]
name|waitSearcher
parameter_list|)
throws|throws
name|IOException
block|{
comment|// it may take some time to open an index.... we may need to make
comment|// sure that two threads aren't trying to open one at the same time
comment|// if it isn't necessary.
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
comment|// see if we can return the current searcher
if|if
condition|(
name|_searcher
operator|!=
literal|null
operator|&&
operator|!
name|forceNew
condition|)
block|{
if|if
condition|(
name|returnSearcher
condition|)
block|{
name|_searcher
operator|.
name|incref
argument_list|()
expr_stmt|;
return|return
name|_searcher
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// check to see if we can wait for someone else's searcher to be set
if|if
condition|(
name|onDeckSearchers
operator|>
literal|0
operator|&&
operator|!
name|forceNew
operator|&&
name|_searcher
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|searcherLock
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
name|SolrException
operator|.
name|toStr
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check again: see if we can return right now
if|if
condition|(
name|_searcher
operator|!=
literal|null
operator|&&
operator|!
name|forceNew
condition|)
block|{
if|if
condition|(
name|returnSearcher
condition|)
block|{
name|_searcher
operator|.
name|incref
argument_list|()
expr_stmt|;
return|return
name|_searcher
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// At this point, we know we need to open a new searcher...
comment|// first: increment count to signal other threads that we are
comment|//        opening a new searcher.
name|onDeckSearchers
operator|++
expr_stmt|;
if|if
condition|(
name|onDeckSearchers
operator|<
literal|1
condition|)
block|{
comment|// should never happen... just a sanity check
name|log
operator|.
name|severe
argument_list|(
name|logid
operator|+
literal|"ERROR!!! onDeckSearchers is "
operator|+
name|onDeckSearchers
argument_list|)
expr_stmt|;
name|onDeckSearchers
operator|=
literal|1
expr_stmt|;
comment|// reset
block|}
elseif|else
if|if
condition|(
name|onDeckSearchers
operator|>
name|maxWarmingSearchers
condition|)
block|{
name|onDeckSearchers
operator|--
expr_stmt|;
name|String
name|msg
init|=
literal|"Error opening new searcher. exceeded limit of maxWarmingSearchers="
operator|+
name|maxWarmingSearchers
operator|+
literal|", try again later."
decl_stmt|;
name|log
operator|.
name|warning
argument_list|(
name|logid
operator|+
literal|""
operator|+
name|msg
argument_list|)
expr_stmt|;
comment|// HTTP 503==service unavailable, or 409==Conflict
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
name|msg
argument_list|,
literal|true
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|onDeckSearchers
operator|>
literal|1
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
name|logid
operator|+
literal|"PERFORMANCE WARNING: Overlapping onDeckSearchers="
operator|+
name|onDeckSearchers
argument_list|)
expr_stmt|;
block|}
block|}
comment|// open the index synchronously
comment|// if this fails, we need to decrement onDeckSearchers again.
name|SolrIndexSearcher
name|tmp
decl_stmt|;
try|try
block|{
name|tmp
operator|=
operator|new
name|SolrIndexSearcher
argument_list|(
name|this
argument_list|,
name|schema
argument_list|,
literal|"main"
argument_list|,
name|IndexReader
operator|.
name|open
argument_list|(
name|FSDirectory
operator|.
name|getDirectory
argument_list|(
name|getIndexDir
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
name|onDeckSearchers
operator|--
expr_stmt|;
comment|// notify another waiter to continue... it may succeed
comment|// and wake any others.
name|searcherLock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
comment|// need to close the searcher here??? we shouldn't have to.
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|th
argument_list|)
throw|;
block|}
specifier|final
name|SolrIndexSearcher
name|newSearcher
init|=
name|tmp
decl_stmt|;
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|currSearcherHolder
init|=
literal|null
decl_stmt|;
specifier|final
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|newSearchHolder
init|=
name|newHolder
argument_list|(
name|newSearcher
argument_list|)
decl_stmt|;
if|if
condition|(
name|returnSearcher
condition|)
name|newSearchHolder
operator|.
name|incref
argument_list|()
expr_stmt|;
comment|// a signal to decrement onDeckSearchers if something goes wrong.
specifier|final
name|boolean
index|[]
name|decrementOnDeckCount
init|=
operator|new
name|boolean
index|[
literal|1
index|]
decl_stmt|;
name|decrementOnDeckCount
index|[
literal|0
index|]
operator|=
literal|true
expr_stmt|;
try|try
block|{
name|boolean
name|alreadyRegistered
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
name|_searchers
operator|.
name|add
argument_list|(
name|newSearchHolder
argument_list|)
expr_stmt|;
if|if
condition|(
name|_searcher
operator|==
literal|null
condition|)
block|{
comment|// if there isn't a current searcher then we may
comment|// want to register this one before warming is complete instead of waiting.
if|if
condition|(
name|solrConfig
operator|.
name|getBool
argument_list|(
literal|"query/useColdSearcher"
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|registerSearcher
argument_list|(
name|newSearchHolder
argument_list|)
expr_stmt|;
name|decrementOnDeckCount
index|[
literal|0
index|]
operator|=
literal|false
expr_stmt|;
name|alreadyRegistered
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// get a reference to the current searcher for purposes of autowarming.
name|currSearcherHolder
operator|=
name|_searcher
expr_stmt|;
name|currSearcherHolder
operator|.
name|incref
argument_list|()
expr_stmt|;
block|}
block|}
specifier|final
name|SolrIndexSearcher
name|currSearcher
init|=
name|currSearcherHolder
operator|==
literal|null
condition|?
literal|null
else|:
name|currSearcherHolder
operator|.
name|get
argument_list|()
decl_stmt|;
comment|//
comment|// Note! if we registered the new searcher (but didn't increment it's
comment|// reference count because returnSearcher==false, it's possible for
comment|// someone else to register another searcher, and thus cause newSearcher
comment|// to close while we are warming.
comment|//
comment|// Should we protect against that by incrementing the reference count?
comment|// Maybe we should just let it fail?   After all, if returnSearcher==false
comment|// and newSearcher has been de-registered, what's the point of continuing?
comment|//
name|Future
name|future
init|=
literal|null
decl_stmt|;
comment|// warm the new searcher based on the current searcher.
comment|// should this go before the other event handlers or after?
if|if
condition|(
name|currSearcher
operator|!=
literal|null
condition|)
block|{
name|future
operator|=
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|newSearcher
operator|.
name|warm
argument_list|(
name|currSearcher
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currSearcher
operator|==
literal|null
operator|&&
name|firstSearcherListeners
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|future
operator|=
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
for|for
control|(
name|SolrEventListener
name|listener
range|:
name|firstSearcherListeners
control|)
block|{
name|listener
operator|.
name|newSearcher
argument_list|(
name|newSearcher
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currSearcher
operator|!=
literal|null
operator|&&
name|newSearcherListeners
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|future
operator|=
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
for|for
control|(
name|SolrEventListener
name|listener
range|:
name|newSearcherListeners
control|)
block|{
name|listener
operator|.
name|newSearcher
argument_list|(
name|newSearcher
argument_list|,
name|currSearcher
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// WARNING: this code assumes a single threaded executor (that all tasks
comment|// queued will finish first).
specifier|final
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|currSearcherHolderF
init|=
name|currSearcherHolder
decl_stmt|;
if|if
condition|(
operator|!
name|alreadyRegistered
condition|)
block|{
name|future
operator|=
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
comment|// signal that we no longer need to decrement
comment|// the count *before* registering the searcher since
comment|// registerSearcher will decrement even if it errors.
name|decrementOnDeckCount
index|[
literal|0
index|]
operator|=
literal|false
expr_stmt|;
name|registerSearcher
argument_list|(
name|newSearchHolder
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// we are all done with the old searcher we used
comment|// for warming...
if|if
condition|(
name|currSearcherHolderF
operator|!=
literal|null
condition|)
name|currSearcherHolderF
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|waitSearcher
operator|!=
literal|null
condition|)
block|{
name|waitSearcher
index|[
literal|0
index|]
operator|=
name|future
expr_stmt|;
block|}
comment|// Return the searcher as the warming tasks run in parallel
comment|// callers may wait on the waitSearcher future returned.
return|return
name|returnSearcher
condition|?
name|newSearchHolder
else|:
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|currSearcherHolder
operator|!=
literal|null
condition|)
name|currSearcherHolder
operator|.
name|decref
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
name|decrementOnDeckCount
index|[
literal|0
index|]
condition|)
block|{
name|onDeckSearchers
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|onDeckSearchers
operator|<
literal|0
condition|)
block|{
comment|// sanity check... should never happen
name|log
operator|.
name|severe
argument_list|(
name|logid
operator|+
literal|"ERROR!!! onDeckSearchers after decrement="
operator|+
name|onDeckSearchers
argument_list|)
expr_stmt|;
name|onDeckSearchers
operator|=
literal|0
expr_stmt|;
comment|// try and recover
block|}
comment|// if we failed, we need to wake up at least one waiter to continue the process
name|searcherLock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
comment|// since the indexreader was already opened, assume we can continue on
comment|// even though we got an exception.
return|return
name|returnSearcher
condition|?
name|newSearchHolder
else|:
literal|null
return|;
block|}
block|}
DECL|method|newHolder
specifier|private
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|newHolder
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|)
block|{
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|holder
init|=
operator|new
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
argument_list|(
name|newSearcher
argument_list|)
block|{
specifier|public
name|void
name|close
parameter_list|()
block|{
try|try
block|{
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
comment|// it's possible for someone to get a reference via the _searchers queue
comment|// and increment the refcount while RefCounted.close() is being called.
comment|// we check the refcount again to see if this has happened and abort the close.
comment|// This relies on the RefCounted class allowing close() to be called every
comment|// time the counter hits zero.
if|if
condition|(
name|refcount
operator|.
name|get
argument_list|()
operator|>
literal|0
condition|)
return|return;
name|_searchers
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|resource
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|severe
argument_list|(
literal|"Error closing searcher:"
operator|+
name|SolrException
operator|.
name|toStr
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|holder
operator|.
name|incref
argument_list|()
expr_stmt|;
comment|// set ref count to 1 to account for this._searcher
return|return
name|holder
return|;
block|}
comment|// Take control of newSearcherHolder (which should have a reference count of at
comment|// least 1 already.  If the caller wishes to use the newSearcherHolder directly
comment|// after registering it, then they should increment the reference count *before*
comment|// calling this method.
comment|//
comment|// onDeckSearchers will also be decremented (it should have been incremented
comment|// as a result of opening a new searcher).
DECL|method|registerSearcher
specifier|private
name|void
name|registerSearcher
parameter_list|(
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|newSearcherHolder
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
try|try
block|{
if|if
condition|(
name|_searcher
operator|!=
literal|null
condition|)
block|{
name|_searcher
operator|.
name|decref
argument_list|()
expr_stmt|;
comment|// dec refcount for this._searcher
name|_searcher
operator|=
literal|null
expr_stmt|;
block|}
name|_searcher
operator|=
name|newSearcherHolder
expr_stmt|;
name|SolrIndexSearcher
name|newSearcher
init|=
name|newSearcherHolder
operator|.
name|get
argument_list|()
decl_stmt|;
name|newSearcher
operator|.
name|register
argument_list|()
expr_stmt|;
comment|// register subitems (caches)
name|log
operator|.
name|info
argument_list|(
name|logid
operator|+
literal|"Registered new searcher "
operator|+
name|newSearcher
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|log
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// wake up anyone waiting for a searcher
comment|// even in the face of errors.
name|onDeckSearchers
operator|--
expr_stmt|;
name|searcherLock
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|closeSearcher
specifier|public
name|void
name|closeSearcher
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
name|logid
operator|+
literal|"Closing main searcher on request."
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
name|_searcher
operator|!=
literal|null
condition|)
block|{
name|_searcher
operator|.
name|decref
argument_list|()
expr_stmt|;
comment|// dec refcount for this._searcher
name|_searcher
operator|=
literal|null
expr_stmt|;
comment|// isClosed() does check this
name|infoRegistry
operator|.
name|remove
argument_list|(
literal|"currentSearcher"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|execute
specifier|public
name|void
name|execute
parameter_list|(
name|SolrRequestHandler
name|handler
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|)
block|{
if|if
condition|(
name|handler
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
name|logid
operator|+
literal|"Null Request Handler '"
operator|+
name|req
operator|.
name|getQueryType
argument_list|()
operator|+
literal|"' :"
operator|+
name|req
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Null Request Handler '"
operator|+
name|req
operator|.
name|getQueryType
argument_list|()
operator|+
literal|"'"
argument_list|,
literal|true
argument_list|)
throw|;
block|}
comment|// setup response header and handle request
specifier|final
name|NamedList
argument_list|<
name|Object
argument_list|>
name|responseHeader
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|rsp
operator|.
name|add
argument_list|(
literal|"responseHeader"
argument_list|,
name|responseHeader
argument_list|)
expr_stmt|;
name|NamedList
name|toLog
init|=
name|rsp
operator|.
name|getToLog
argument_list|()
decl_stmt|;
comment|//toLog.add("core", getName());
name|toLog
operator|.
name|add
argument_list|(
literal|"webapp"
argument_list|,
name|req
operator|.
name|getContext
argument_list|()
operator|.
name|get
argument_list|(
literal|"webapp"
argument_list|)
argument_list|)
expr_stmt|;
name|toLog
operator|.
name|add
argument_list|(
literal|"path"
argument_list|,
name|req
operator|.
name|getContext
argument_list|()
operator|.
name|get
argument_list|(
literal|"path"
argument_list|)
argument_list|)
expr_stmt|;
name|toLog
operator|.
name|add
argument_list|(
literal|"params"
argument_list|,
literal|"{"
operator|+
name|req
operator|.
name|getParamString
argument_list|()
operator|+
literal|"}"
argument_list|)
expr_stmt|;
name|handler
operator|.
name|handleRequest
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
name|setResponseHeaderValues
argument_list|(
name|handler
argument_list|,
name|req
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toLog
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|toLog
operator|.
name|getName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Object
name|val
init|=
name|toLog
operator|.
name|getVal
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|name
argument_list|)
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
operator|.
name|append
argument_list|(
name|val
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
name|logid
operator|+
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|/*log.info(logid+"" + req.getContext().get("path") + " "             + req.getParamString()+ " 0 "+        (int)(rsp.getEndTime() - req.getStartTime()));*/
block|}
comment|/**    * @deprecated Use {@link #execute(SolrRequestHandler, SolrQueryRequest, SolrQueryResponse)} instead.     */
annotation|@
name|Deprecated
DECL|method|execute
specifier|public
name|void
name|execute
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|)
block|{
name|SolrRequestHandler
name|handler
init|=
name|getRequestHandler
argument_list|(
name|req
operator|.
name|getQueryType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|handler
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
name|logid
operator|+
literal|"Unknown Request Handler '"
operator|+
name|req
operator|.
name|getQueryType
argument_list|()
operator|+
literal|"' :"
operator|+
name|req
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Unknown Request Handler '"
operator|+
name|req
operator|.
name|getQueryType
argument_list|()
operator|+
literal|"'"
argument_list|,
literal|true
argument_list|)
throw|;
block|}
name|execute
argument_list|(
name|handler
argument_list|,
name|req
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
block|}
DECL|method|setResponseHeaderValues
specifier|protected
name|void
name|setResponseHeaderValues
parameter_list|(
name|SolrRequestHandler
name|handler
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|)
block|{
comment|// TODO should check that responseHeader has not been replaced by handler
name|NamedList
name|responseHeader
init|=
name|rsp
operator|.
name|getResponseHeader
argument_list|()
decl_stmt|;
specifier|final
name|int
name|qtime
init|=
call|(
name|int
call|)
argument_list|(
name|rsp
operator|.
name|getEndTime
argument_list|()
operator|-
name|req
operator|.
name|getStartTime
argument_list|()
argument_list|)
decl_stmt|;
name|responseHeader
operator|.
name|add
argument_list|(
literal|"status"
argument_list|,
name|rsp
operator|.
name|getException
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
literal|500
argument_list|)
expr_stmt|;
name|responseHeader
operator|.
name|add
argument_list|(
literal|"QTime"
argument_list|,
name|qtime
argument_list|)
expr_stmt|;
name|rsp
operator|.
name|getToLog
argument_list|()
operator|.
name|add
argument_list|(
literal|"status"
argument_list|,
name|rsp
operator|.
name|getException
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
literal|500
argument_list|)
expr_stmt|;
name|rsp
operator|.
name|getToLog
argument_list|()
operator|.
name|add
argument_list|(
literal|"QTime"
argument_list|,
name|qtime
argument_list|)
expr_stmt|;
name|SolrParams
name|params
init|=
name|req
operator|.
name|getParams
argument_list|()
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|getBool
argument_list|(
name|CommonParams
operator|.
name|HEADER_ECHO_HANDLER
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|responseHeader
operator|.
name|add
argument_list|(
literal|"handler"
argument_list|,
name|handler
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Values for echoParams... false/true/all or false/explicit/all ???
name|String
name|ep
init|=
name|params
operator|.
name|get
argument_list|(
name|CommonParams
operator|.
name|HEADER_ECHO_PARAMS
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|ep
operator|!=
literal|null
condition|)
block|{
name|EchoParamStyle
name|echoParams
init|=
name|EchoParamStyle
operator|.
name|get
argument_list|(
name|ep
argument_list|)
decl_stmt|;
if|if
condition|(
name|echoParams
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Invalid value '"
operator|+
name|ep
operator|+
literal|"' for "
operator|+
name|CommonParams
operator|.
name|HEADER_ECHO_PARAMS
operator|+
literal|" parameter, use '"
operator|+
name|EchoParamStyle
operator|.
name|EXPLICIT
operator|+
literal|"' or '"
operator|+
name|EchoParamStyle
operator|.
name|ALL
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
name|echoParams
operator|==
name|EchoParamStyle
operator|.
name|EXPLICIT
condition|)
block|{
name|responseHeader
operator|.
name|add
argument_list|(
literal|"params"
argument_list|,
name|req
operator|.
name|getOriginalParams
argument_list|()
operator|.
name|toNamedList
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|echoParams
operator|==
name|EchoParamStyle
operator|.
name|ALL
condition|)
block|{
name|responseHeader
operator|.
name|add
argument_list|(
literal|"params"
argument_list|,
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|toNamedList
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|log
specifier|final
specifier|public
specifier|static
name|void
name|log
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
DECL|field|defaultResponseWriter
specifier|private
name|QueryResponseWriter
name|defaultResponseWriter
decl_stmt|;
DECL|field|responseWriters
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|QueryResponseWriter
argument_list|>
name|responseWriters
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|QueryResponseWriter
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Configure the query response writers. There will always be a default writer; additional     * writers may also be configured. */
DECL|method|initWriters
specifier|private
name|void
name|initWriters
parameter_list|()
block|{
name|String
name|xpath
init|=
literal|"queryResponseWriter"
decl_stmt|;
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|solrConfig
operator|.
name|evaluate
argument_list|(
name|xpath
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
name|NamedListPluginLoader
argument_list|<
name|QueryResponseWriter
argument_list|>
name|loader
init|=
operator|new
name|NamedListPluginLoader
argument_list|<
name|QueryResponseWriter
argument_list|>
argument_list|(
literal|"[solrconfig.xml] "
operator|+
name|xpath
argument_list|,
name|responseWriters
argument_list|)
decl_stmt|;
name|defaultResponseWriter
operator|=
name|loader
operator|.
name|load
argument_list|(
name|solrConfig
operator|.
name|getResourceLoader
argument_list|()
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
comment|// configure the default response writer; this one should never be null
if|if
condition|(
name|defaultResponseWriter
operator|==
literal|null
condition|)
block|{
name|defaultResponseWriter
operator|=
name|responseWriters
operator|.
name|get
argument_list|(
literal|"standard"
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaultResponseWriter
operator|==
literal|null
condition|)
block|{
name|defaultResponseWriter
operator|=
operator|new
name|XMLResponseWriter
argument_list|()
expr_stmt|;
block|}
block|}
comment|// make JSON response writers available by default
if|if
condition|(
name|responseWriters
operator|.
name|get
argument_list|(
literal|"json"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|responseWriters
operator|.
name|put
argument_list|(
literal|"json"
argument_list|,
operator|new
name|JSONResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|responseWriters
operator|.
name|get
argument_list|(
literal|"python"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|responseWriters
operator|.
name|put
argument_list|(
literal|"python"
argument_list|,
operator|new
name|PythonResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|responseWriters
operator|.
name|get
argument_list|(
literal|"ruby"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|responseWriters
operator|.
name|put
argument_list|(
literal|"ruby"
argument_list|,
operator|new
name|RubyResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|responseWriters
operator|.
name|get
argument_list|(
literal|"raw"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|responseWriters
operator|.
name|put
argument_list|(
literal|"raw"
argument_list|,
operator|new
name|RawResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|responseWriters
operator|.
name|get
argument_list|(
literal|"javabin"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|responseWriters
operator|.
name|put
argument_list|(
literal|"javabin"
argument_list|,
operator|new
name|BinaryResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Finds a writer by name, or returns the default writer if not found. */
DECL|method|getQueryResponseWriter
specifier|public
specifier|final
name|QueryResponseWriter
name|getQueryResponseWriter
parameter_list|(
name|String
name|writerName
parameter_list|)
block|{
if|if
condition|(
name|writerName
operator|!=
literal|null
condition|)
block|{
name|QueryResponseWriter
name|writer
init|=
name|responseWriters
operator|.
name|get
argument_list|(
name|writerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
return|return
name|writer
return|;
block|}
block|}
return|return
name|defaultResponseWriter
return|;
block|}
comment|/** Returns the appropriate writer for a request. If the request specifies a writer via the    * 'wt' parameter, attempts to find that one; otherwise return the default writer.    */
DECL|method|getQueryResponseWriter
specifier|public
specifier|final
name|QueryResponseWriter
name|getQueryResponseWriter
parameter_list|(
name|SolrQueryRequest
name|request
parameter_list|)
block|{
return|return
name|getQueryResponseWriter
argument_list|(
name|request
operator|.
name|getParam
argument_list|(
literal|"wt"
argument_list|)
argument_list|)
return|;
block|}
DECL|field|qParserPlugins
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|QParserPlugin
argument_list|>
name|qParserPlugins
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|QParserPlugin
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Configure the query parsers. */
DECL|method|initQParsers
specifier|private
name|void
name|initQParsers
parameter_list|()
block|{
name|String
name|xpath
init|=
literal|"queryParser"
decl_stmt|;
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|solrConfig
operator|.
name|evaluate
argument_list|(
name|xpath
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
name|NamedListPluginLoader
argument_list|<
name|QParserPlugin
argument_list|>
name|loader
init|=
operator|new
name|NamedListPluginLoader
argument_list|<
name|QParserPlugin
argument_list|>
argument_list|(
literal|"[solrconfig.xml] "
operator|+
name|xpath
argument_list|,
name|qParserPlugins
argument_list|)
decl_stmt|;
name|loader
operator|.
name|load
argument_list|(
name|solrConfig
operator|.
name|getResourceLoader
argument_list|()
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
comment|// default parsers
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|QParserPlugin
operator|.
name|standardPlugins
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
try|try
block|{
name|String
name|name
init|=
operator|(
name|String
operator|)
name|QParserPlugin
operator|.
name|standardPlugins
index|[
name|i
index|]
decl_stmt|;
name|Class
argument_list|<
name|QParserPlugin
argument_list|>
name|clazz
init|=
operator|(
name|Class
argument_list|<
name|QParserPlugin
argument_list|>
operator|)
name|QParserPlugin
operator|.
name|standardPlugins
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|QParserPlugin
name|plugin
init|=
name|clazz
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|qParserPlugins
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|plugin
argument_list|)
expr_stmt|;
name|plugin
operator|.
name|init
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|getQueryPlugin
specifier|public
name|QParserPlugin
name|getQueryPlugin
parameter_list|(
name|String
name|parserName
parameter_list|)
block|{
name|QParserPlugin
name|plugin
init|=
name|qParserPlugins
operator|.
name|get
argument_list|(
name|parserName
argument_list|)
decl_stmt|;
if|if
condition|(
name|plugin
operator|!=
literal|null
condition|)
return|return
name|plugin
return|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Unknown query type '"
operator|+
name|parserName
operator|+
literal|"'"
argument_list|)
throw|;
block|}
DECL|field|valueSourceParsers
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|ValueSourceParser
argument_list|>
name|valueSourceParsers
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ValueSourceParser
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Configure the ValueSource (function) plugins */
DECL|method|initValueSourceParsers
specifier|private
name|void
name|initValueSourceParsers
parameter_list|()
block|{
name|String
name|xpath
init|=
literal|"valueSourceParser"
decl_stmt|;
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|solrConfig
operator|.
name|evaluate
argument_list|(
name|xpath
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
name|NamedListPluginLoader
argument_list|<
name|ValueSourceParser
argument_list|>
name|loader
init|=
operator|new
name|NamedListPluginLoader
argument_list|<
name|ValueSourceParser
argument_list|>
argument_list|(
literal|"[solrconfig.xml] "
operator|+
name|xpath
argument_list|,
name|valueSourceParsers
argument_list|)
decl_stmt|;
name|loader
operator|.
name|load
argument_list|(
name|solrConfig
operator|.
name|getResourceLoader
argument_list|()
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
comment|// default value source parsers
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ValueSourceParser
argument_list|>
name|entry
range|:
name|ValueSourceParser
operator|.
name|standardValueSourceParsers
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
name|String
name|name
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ValueSourceParser
name|valueSourceParser
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|valueSourceParsers
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|valueSourceParser
argument_list|)
expr_stmt|;
name|valueSourceParser
operator|.
name|init
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|getValueSourceParser
specifier|public
name|ValueSourceParser
name|getValueSourceParser
parameter_list|(
name|String
name|parserName
parameter_list|)
block|{
return|return
name|valueSourceParsers
operator|.
name|get
argument_list|(
name|parserName
argument_list|)
return|;
block|}
comment|/**    * Manage anything that should be taken care of in case configs change    */
DECL|method|initDeprecatedSupport
specifier|private
name|void
name|initDeprecatedSupport
parameter_list|()
block|{
comment|// TODO -- this should be removed in deprecation release...
name|String
name|gettable
init|=
name|solrConfig
operator|.
name|get
argument_list|(
literal|"admin/gettableFiles"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|gettable
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"solrconfig.xml uses deprecated<admin/gettableFiles>, Please "
operator|+
literal|"update your config to use the ShowFileRequestHandler."
argument_list|)
expr_stmt|;
if|if
condition|(
name|getRequestHandler
argument_list|(
literal|"/admin/file"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|NamedList
argument_list|<
name|String
argument_list|>
name|invariants
init|=
operator|new
name|NamedList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Hide everything...
name|Set
argument_list|<
name|String
argument_list|>
name|hide
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|File
name|configdir
init|=
operator|new
name|File
argument_list|(
name|solrConfig
operator|.
name|getResourceLoader
argument_list|()
operator|.
name|getConfigDir
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|configdir
operator|.
name|list
argument_list|()
control|)
block|{
name|hide
operator|.
name|add
argument_list|(
name|file
operator|.
name|toUpperCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// except the "gettable" list
name|StringTokenizer
name|st
init|=
operator|new
name|StringTokenizer
argument_list|(
name|gettable
argument_list|)
decl_stmt|;
while|while
condition|(
name|st
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|hide
operator|.
name|remove
argument_list|(
name|st
operator|.
name|nextToken
argument_list|()
operator|.
name|toUpperCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|s
range|:
name|hide
control|)
block|{
name|invariants
operator|.
name|add
argument_list|(
name|ShowFileRequestHandler
operator|.
name|HIDDEN
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|NamedList
argument_list|<
name|Object
argument_list|>
name|args
init|=
operator|new
name|NamedList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|args
operator|.
name|add
argument_list|(
literal|"invariants"
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|ShowFileRequestHandler
name|handler
init|=
operator|new
name|ShowFileRequestHandler
argument_list|()
decl_stmt|;
name|handler
operator|.
name|init
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|reqHandlers
operator|.
name|register
argument_list|(
literal|"/admin/file"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|log
operator|.
name|warning
argument_list|(
literal|"adding ShowFileRequestHandler with hidden files: "
operator|+
name|hide
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getCoreDescriptor
specifier|public
name|CoreDescriptor
name|getCoreDescriptor
parameter_list|()
block|{
return|return
name|coreDescriptor
return|;
block|}
comment|/////////////////////////////////////////////////////////////////////
comment|// SolrInfoMBean stuff: Statistics and Module Info
comment|/////////////////////////////////////////////////////////////////////
DECL|method|getVersion
specifier|public
name|String
name|getVersion
parameter_list|()
block|{
return|return
name|SolrCore
operator|.
name|version
return|;
block|}
DECL|method|getDescription
specifier|public
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"SolrCore"
return|;
block|}
DECL|method|getCategory
specifier|public
name|Category
name|getCategory
parameter_list|()
block|{
return|return
name|Category
operator|.
name|CORE
return|;
block|}
DECL|method|getSourceId
specifier|public
name|String
name|getSourceId
parameter_list|()
block|{
return|return
literal|"$Id$"
return|;
block|}
DECL|method|getSource
specifier|public
name|String
name|getSource
parameter_list|()
block|{
return|return
literal|"$URL$"
return|;
block|}
DECL|method|getDocs
specifier|public
name|URL
index|[]
name|getDocs
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|getStatistics
specifier|public
name|NamedList
name|getStatistics
parameter_list|()
block|{
name|NamedList
name|lst
init|=
operator|new
name|SimpleOrderedMap
argument_list|()
decl_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"coreName"
argument_list|,
name|name
operator|==
literal|null
condition|?
literal|"(null)"
else|:
name|name
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"startTime"
argument_list|,
operator|new
name|Date
argument_list|(
name|startTime
argument_list|)
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"refCount"
argument_list|,
name|getOpenCount
argument_list|()
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
literal|"aliases"
argument_list|,
name|getCoreDescriptor
argument_list|()
operator|.
name|getCoreContainer
argument_list|()
operator|.
name|getCoreNames
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|lst
return|;
block|}
block|}
end_class
end_unit
