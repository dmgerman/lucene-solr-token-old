begin_unit
begin_comment
comment|/**  * Copyright 2006 The Apache Software Foundation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.core
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrRequestHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|DOMUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|RefCounted
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|StrUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|XML
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|xmlpull
operator|.
name|v1
operator|.
name|XmlPullParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|xmlpull
operator|.
name|v1
operator|.
name|XmlPullParserException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|xmlpull
operator|.
name|v1
operator|.
name|XmlPullParserFactory
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathConstants
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import
begin_comment
comment|/**  * @author yonik  * @version $Id: SolrCore.java,v 1.47 2006/01/10 05:04:44 yonik Exp $  */
end_comment
begin_class
DECL|class|SolrCore
specifier|public
specifier|final
class|class
name|SolrCore
block|{
DECL|field|cvsId
specifier|public
specifier|static
specifier|final
name|String
name|cvsId
init|=
literal|"$Id: SolrCore.java,v 1.47 2006/01/10 05:04:44 yonik Exp $"
decl_stmt|;
DECL|field|cvsSource
specifier|public
specifier|static
specifier|final
name|String
name|cvsSource
init|=
literal|"$Source: /cvs/main/searching/solr/solarcore/src/solr/SolrCore.java,v $"
decl_stmt|;
DECL|field|cvsTag
specifier|public
specifier|static
specifier|final
name|String
name|cvsTag
init|=
literal|"$Name:  $"
decl_stmt|;
DECL|field|version
specifier|public
specifier|static
specifier|final
name|String
name|version
init|=
literal|"1.0"
decl_stmt|;
DECL|field|log
specifier|public
specifier|static
name|Logger
name|log
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|SolrCore
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|schema
specifier|private
specifier|final
name|IndexSchema
name|schema
decl_stmt|;
DECL|field|index_path
specifier|private
specifier|final
name|String
name|index_path
decl_stmt|;
DECL|field|updateHandler
specifier|private
specifier|final
name|UpdateHandler
name|updateHandler
decl_stmt|;
DECL|field|mainIndexConfig
specifier|public
specifier|static
name|SolrIndexConfig
name|mainIndexConfig
init|=
operator|new
name|SolrIndexConfig
argument_list|(
literal|"mainIndex"
argument_list|)
decl_stmt|;
static|static
block|{
name|BooleanQuery
operator|.
name|setMaxClauseCount
argument_list|(
name|SolrConfig
operator|.
name|config
operator|.
name|getInt
argument_list|(
literal|"query/maxBooleanClauses"
argument_list|,
name|BooleanQuery
operator|.
name|getMaxClauseCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|parseListener
specifier|public
specifier|static
name|List
argument_list|<
name|SolrEventListener
argument_list|>
name|parseListener
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|List
argument_list|<
name|SolrEventListener
argument_list|>
name|lst
init|=
operator|new
name|ArrayList
argument_list|<
name|SolrEventListener
argument_list|>
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Searching for listeners: "
operator|+
name|path
argument_list|)
expr_stmt|;
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|SolrConfig
operator|.
name|config
operator|.
name|evaluate
argument_list|(
name|path
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|className
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|node
argument_list|,
literal|"class"
argument_list|)
decl_stmt|;
name|SolrEventListener
name|listener
init|=
operator|(
name|SolrEventListener
operator|)
name|Config
operator|.
name|newInstance
argument_list|(
name|className
argument_list|)
decl_stmt|;
name|listener
operator|.
name|init
argument_list|(
name|DOMUtil
operator|.
name|childNodesToNamedList
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"added SolrEventListener: "
operator|+
name|listener
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|lst
return|;
block|}
DECL|field|firstSearcherListeners
name|List
argument_list|<
name|SolrEventListener
argument_list|>
name|firstSearcherListeners
decl_stmt|;
DECL|field|newSearcherListeners
name|List
argument_list|<
name|SolrEventListener
argument_list|>
name|newSearcherListeners
decl_stmt|;
DECL|method|parseListeners
specifier|private
name|void
name|parseListeners
parameter_list|()
block|{
name|firstSearcherListeners
operator|=
name|parseListener
argument_list|(
literal|"//listener[@event=\"firstSearcher\"]"
argument_list|)
expr_stmt|;
name|newSearcherListeners
operator|=
name|parseListener
argument_list|(
literal|"//listener[@event=\"newSearcher\"]"
argument_list|)
expr_stmt|;
block|}
DECL|method|getSchema
specifier|public
name|IndexSchema
name|getSchema
parameter_list|()
block|{
return|return
name|schema
return|;
block|}
DECL|method|getDir
specifier|public
name|String
name|getDir
parameter_list|()
block|{
return|return
name|index_path
return|;
block|}
DECL|field|reqHandlers
specifier|private
specifier|final
name|RequestHandlers
name|reqHandlers
init|=
operator|new
name|RequestHandlers
argument_list|(
name|SolrConfig
operator|.
name|config
argument_list|)
decl_stmt|;
DECL|method|getRequestHandler
specifier|public
name|SolrRequestHandler
name|getRequestHandler
parameter_list|(
name|String
name|handlerName
parameter_list|)
block|{
return|return
name|reqHandlers
operator|.
name|get
argument_list|(
name|handlerName
argument_list|)
return|;
block|}
comment|// TODO - what about a master that not might have a searcher normally open?
annotation|@
name|Deprecated
DECL|method|maxDoc
specifier|public
name|int
name|maxDoc
parameter_list|()
block|{
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|holder
init|=
literal|null
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
try|try
block|{
name|holder
operator|=
name|getSearcher
argument_list|()
expr_stmt|;
name|SolrIndexSearcher
name|searcher
init|=
name|holder
operator|.
name|get
argument_list|()
decl_stmt|;
name|num
operator|=
name|searcher
operator|.
name|maxDoc
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|holder
operator|!=
literal|null
condition|)
name|holder
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
comment|// gets a non-caching searcher
DECL|method|newSearcher
specifier|public
name|SolrIndexSearcher
name|newSearcher
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|SolrIndexSearcher
argument_list|(
name|schema
argument_list|,
name|name
argument_list|,
name|getDir
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|initIndex
name|void
name|initIndex
parameter_list|()
block|{
try|try
block|{
name|File
name|dirFile
init|=
operator|new
name|File
argument_list|(
name|getDir
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|indexExists
init|=
name|dirFile
operator|.
name|canRead
argument_list|()
decl_stmt|;
name|boolean
name|removeLocks
init|=
name|SolrConfig
operator|.
name|config
operator|.
name|getBool
argument_list|(
literal|"mainIndex/unlockOnStartup"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|removeLocks
condition|)
block|{
comment|// to remove locks, the directory must already exist... so we create it
comment|// if it didn't exist already...
name|Directory
name|dir
init|=
name|FSDirectory
operator|.
name|getDirectory
argument_list|(
name|dirFile
argument_list|,
operator|!
name|indexExists
argument_list|)
decl_stmt|;
if|if
condition|(
name|IndexReader
operator|.
name|isLocked
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"WARNING: Solr index directory '"
operator|+
name|getDir
argument_list|()
operator|+
literal|"' is locked.  Unlocking..."
argument_list|)
expr_stmt|;
name|IndexReader
operator|.
name|unlock
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Create the index if it doesn't exist. Note that indexExists was tested *before*
comment|// lock removal, since that will result in the creation of the directory.
if|if
condition|(
operator|!
name|indexExists
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"Solr index directory '"
operator|+
name|dirFile
operator|+
literal|"' doesn't exist."
operator|+
literal|" Creating new index..."
argument_list|)
expr_stmt|;
name|SolrIndexWriter
name|writer
init|=
operator|new
name|SolrIndexWriter
argument_list|(
literal|"SolrCore.initIndex"
argument_list|,
name|getDir
argument_list|()
argument_list|,
literal|true
argument_list|,
name|schema
argument_list|,
name|mainIndexConfig
argument_list|)
decl_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|createUpdateHandler
specifier|private
name|UpdateHandler
name|createUpdateHandler
parameter_list|(
name|String
name|className
parameter_list|)
block|{
try|try
block|{
name|Class
name|handlerClass
init|=
name|Config
operator|.
name|findClass
argument_list|(
name|className
argument_list|)
decl_stmt|;
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
name|cons
init|=
name|handlerClass
operator|.
name|getConstructor
argument_list|(
operator|new
name|Class
index|[]
block|{
name|SolrCore
operator|.
name|class
block|}
argument_list|)
decl_stmt|;
return|return
operator|(
name|UpdateHandler
operator|)
name|cons
operator|.
name|newInstance
argument_list|(
operator|new
name|Object
index|[]
block|{
name|this
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
literal|500
argument_list|,
literal|"Error Instantiating Update Handler "
operator|+
name|className
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|// Singleton for now...
DECL|field|core
specifier|private
specifier|static
name|SolrCore
name|core
decl_stmt|;
DECL|method|getSolrCore
specifier|public
specifier|static
name|SolrCore
name|getSolrCore
parameter_list|()
block|{
synchronized|synchronized
init|(
name|SolrCore
operator|.
name|class
init|)
block|{
if|if
condition|(
name|core
operator|==
literal|null
condition|)
name|core
operator|=
operator|new
name|SolrCore
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|core
return|;
block|}
block|}
DECL|method|SolrCore
specifier|public
name|SolrCore
parameter_list|(
name|String
name|index_path
parameter_list|,
name|IndexSchema
name|schema
parameter_list|)
block|{
synchronized|synchronized
init|(
name|SolrCore
operator|.
name|class
init|)
block|{
comment|// this is for backward compatibility (and also the reason
comment|// the sync block is needed)
name|core
operator|=
name|this
expr_stmt|;
comment|// set singleton
try|try
block|{
if|if
condition|(
name|index_path
operator|==
literal|null
condition|)
block|{
name|index_path
operator|=
name|SolrConfig
operator|.
name|config
operator|.
name|get
argument_list|(
literal|"indexDir"
argument_list|,
literal|"index"
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Opening new SolrCore at "
operator|+
name|index_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|schema
operator|==
literal|null
condition|)
block|{
name|schema
operator|=
operator|new
name|IndexSchema
argument_list|(
literal|"schema.xml"
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|schema
operator|=
name|schema
expr_stmt|;
name|this
operator|.
name|index_path
operator|=
name|index_path
expr_stmt|;
name|parseListeners
argument_list|()
expr_stmt|;
name|initIndex
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Open the searcher *before* the handler so we don't end up opening
comment|// one in the middle.
name|getSearcher
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|updateHandler
operator|=
name|createUpdateHandler
argument_list|(
name|SolrConfig
operator|.
name|config
operator|.
name|get
argument_list|(
literal|"updateHandler/@class"
argument_list|,
name|DirectUpdateHandler
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{         }
block|}
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"CLOSING SolrCore!"
argument_list|)
expr_stmt|;
try|try
block|{
name|closeSearcher
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|searcherExecutor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|updateHandler
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|finalizer
name|void
name|finalizer
parameter_list|()
block|{
name|close
argument_list|()
expr_stmt|;
block|}
comment|////////////////////////////////////////////////////////////////////////////////
comment|// Searcher Control
comment|////////////////////////////////////////////////////////////////////////////////
comment|// The current searcher used to service queries.
comment|// Don't access this directly!!!! use getSearcher() to
comment|// get it (and it will increment the ref count at the same time)
DECL|field|_searcher
specifier|private
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|_searcher
decl_stmt|;
DECL|field|searcherExecutor
specifier|final
name|ExecutorService
name|searcherExecutor
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
decl_stmt|;
DECL|field|onDeckSearchers
specifier|private
name|int
name|onDeckSearchers
decl_stmt|;
comment|// number of searchers preparing
DECL|field|searcherLock
specifier|private
name|Object
name|searcherLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|// the sync object for the searcher
DECL|method|getSearcher
specifier|public
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|getSearcher
parameter_list|()
block|{
try|try
block|{
return|return
name|getSearcher
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Get a {@link SolrIndexSearcher} or start the process of creating a new one.    *<p>    * The registered searcher is the default searcher used to service queries.    * A searcher will normally be registered after all of the warming    * and event handlers (newSearcher or firstSearcher events) have run.    * In the case where there is no registered searcher, the newly created searcher will    * be registered before running the event handlers (a slow searcher is better than no searcher).    *    *<p>    * If<tt>forceNew==true</tt> then    *  A new searcher will be opened and registered irregardless if there is already    *    a registered searcher or other searchers in the process of being created.    *<p>    * If<tt>forceNew==false</tt> then:<ul>    *<li>If a searcher is already registered, that searcher will be returned</li>    *<li>If no searcher is currently registered, but at least one is in the process of being created, then    * this call will block until the first searcher is registered</li>    *<li>If no searcher is currently registered, and no searchers in the process of being registered, a new    * searcher will be created.</li>    *</ul>    *<p>    * If<tt>returnSearcher==true</tt> then a {@link RefCounted}&lt{@link SolrIndexSearcher}&gt will be returned with    * the reference count incremented.  It<b>must</b> be decremented when no longer needed.    *<p>    * If<tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,    * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to    *<tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time    * this method returned.    *<p>    * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.    * @param returnSearcher     if true, returns a {@link&ltSolrIndexSearcher&gt} holder with the refcount already incremented.    * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.    * @return    * @throws IOException    */
DECL|method|getSearcher
specifier|public
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|getSearcher
parameter_list|(
name|boolean
name|forceNew
parameter_list|,
name|boolean
name|returnSearcher
parameter_list|,
specifier|final
name|Future
index|[]
name|waitSearcher
parameter_list|)
throws|throws
name|IOException
block|{
comment|// it may take some time to open an index.... we may need to make
comment|// sure that two threads aren't trying to open one at the same time
comment|// if it isn't necessary.
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
comment|// see if we can return the current searcher
if|if
condition|(
name|_searcher
operator|!=
literal|null
operator|&&
operator|!
name|forceNew
condition|)
block|{
if|if
condition|(
name|returnSearcher
condition|)
block|{
name|_searcher
operator|.
name|incref
argument_list|()
expr_stmt|;
return|return
name|_searcher
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// check to see if we can wait for someone elses searcher to be set
if|if
condition|(
name|onDeckSearchers
operator|>
literal|0
operator|&&
operator|!
name|forceNew
operator|&&
name|_searcher
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|searcherLock
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
name|SolrException
operator|.
name|toStr
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check again: see if we can return right now
if|if
condition|(
name|_searcher
operator|!=
literal|null
operator|&&
operator|!
name|forceNew
condition|)
block|{
if|if
condition|(
name|returnSearcher
condition|)
block|{
name|_searcher
operator|.
name|incref
argument_list|()
expr_stmt|;
return|return
name|_searcher
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// At this point, we know we need to open a new searcher...
comment|// first: increment count to signal other threads that we are
comment|//        opening a new searcher.
name|onDeckSearchers
operator|++
expr_stmt|;
block|}
comment|// open the index synchronously
comment|// if this fails, we need to decrement onDeckSearchers again.
name|SolrIndexSearcher
name|tmp
decl_stmt|;
try|try
block|{
if|if
condition|(
name|onDeckSearchers
operator|<
literal|1
condition|)
block|{
comment|// should never happen... just a sanity check
name|log
operator|.
name|severe
argument_list|(
literal|"ERROR!!! onDeckSearchers is "
operator|+
name|onDeckSearchers
argument_list|)
expr_stmt|;
comment|// reset to 1 (don't bother synchronizing)
name|onDeckSearchers
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|onDeckSearchers
operator|>
literal|1
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"PERFORMANCE WARNING: Overlapping onDeckSearchers="
operator|+
name|onDeckSearchers
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
operator|new
name|SolrIndexSearcher
argument_list|(
name|schema
argument_list|,
literal|"main"
argument_list|,
name|index_path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
name|onDeckSearchers
operator|--
expr_stmt|;
comment|// notify another waiter to continue... it may succeed
comment|// and wake any others.
name|searcherLock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
comment|// need to close the searcher here??? we shouldn't have to.
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|th
argument_list|)
throw|;
block|}
specifier|final
name|SolrIndexSearcher
name|newSearcher
init|=
name|tmp
decl_stmt|;
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|currSearcherHolder
init|=
literal|null
decl_stmt|;
specifier|final
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|newSearchHolder
init|=
name|newHolder
argument_list|(
name|newSearcher
argument_list|)
decl_stmt|;
if|if
condition|(
name|returnSearcher
condition|)
name|newSearchHolder
operator|.
name|incref
argument_list|()
expr_stmt|;
comment|// a signal to decrement onDeckSearchers if something goes wrong.
specifier|final
name|boolean
index|[]
name|decrementOnDeckCount
init|=
operator|new
name|boolean
index|[
literal|1
index|]
decl_stmt|;
name|decrementOnDeckCount
index|[
literal|0
index|]
operator|=
literal|true
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
name|_searcher
operator|==
literal|null
condition|)
block|{
comment|// if there isn't a current searcher then register this one
comment|// before warming is complete instead of waiting.
name|registerSearcher
argument_list|(
name|newSearchHolder
argument_list|)
expr_stmt|;
name|decrementOnDeckCount
index|[
literal|0
index|]
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// get a reference to the current searcher for purposes of autowarming.
name|currSearcherHolder
operator|=
name|_searcher
expr_stmt|;
name|currSearcherHolder
operator|.
name|incref
argument_list|()
expr_stmt|;
block|}
block|}
specifier|final
name|SolrIndexSearcher
name|currSearcher
init|=
name|currSearcherHolder
operator|==
literal|null
condition|?
literal|null
else|:
name|currSearcherHolder
operator|.
name|get
argument_list|()
decl_stmt|;
comment|//
comment|// Note! if we registered the new searcher (but didn't increment it's
comment|// reference count because returnSearcher==false, it's possible for
comment|// someone else to register another searcher, and thus cause newSearcher
comment|// to close while we are warming.
comment|//
comment|// Should we protect against that by incrementing the reference count?
comment|// Maybe we should just let it fail?   After all, if returnSearcher==false
comment|// and newSearcher has been de-registered, what's the point of continuing?
comment|//
name|Future
name|future
init|=
literal|null
decl_stmt|;
comment|// warm the new searcher based on the current searcher.
comment|// should this go before the other event handlers or after?
if|if
condition|(
name|currSearcher
operator|!=
literal|null
condition|)
block|{
name|future
operator|=
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|newSearcher
operator|.
name|warm
argument_list|(
name|currSearcher
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currSearcher
operator|==
literal|null
operator|&&
name|firstSearcherListeners
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|future
operator|=
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
for|for
control|(
name|SolrEventListener
name|listener
range|:
name|firstSearcherListeners
control|)
block|{
name|listener
operator|.
name|newSearcher
argument_list|(
name|newSearcher
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currSearcher
operator|!=
literal|null
operator|&&
name|newSearcherListeners
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|future
operator|=
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
for|for
control|(
name|SolrEventListener
name|listener
range|:
name|newSearcherListeners
control|)
block|{
name|listener
operator|.
name|newSearcher
argument_list|(
name|newSearcher
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// WARNING: this code assumes a single threaded executor (that all tasks
comment|// queued will finish first).
specifier|final
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|currSearcherHolderF
init|=
name|currSearcherHolder
decl_stmt|;
name|Future
name|finalFuture
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|currSearcherHolder
operator|!=
literal|null
condition|)
block|{
name|finalFuture
operator|=
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
comment|// signal that we no longer need to decrement
comment|// the count *before* registering the searcher since
comment|// registertSearcher will decrement even if it errors.
name|decrementOnDeckCount
index|[
literal|0
index|]
operator|=
literal|false
expr_stmt|;
name|registerSearcher
argument_list|(
name|newSearchHolder
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// we are all done with the old searcher we used
comment|// for warming...
name|currSearcherHolderF
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|waitSearcher
operator|!=
literal|null
condition|)
block|{
name|waitSearcher
index|[
literal|0
index|]
operator|=
name|finalFuture
expr_stmt|;
block|}
comment|// Return the searcher as the warming tasks run in parallel
comment|// callers may wait on the waitSearcher future returned.
return|return
name|returnSearcher
condition|?
name|newSearchHolder
else|:
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|currSearcherHolder
operator|!=
literal|null
condition|)
name|currSearcherHolder
operator|.
name|decref
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
name|decrementOnDeckCount
index|[
literal|0
index|]
condition|)
block|{
name|onDeckSearchers
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|onDeckSearchers
operator|<
literal|0
condition|)
block|{
comment|// sanity check... should never happen
name|log
operator|.
name|severe
argument_list|(
literal|"ERROR!!! onDeckSearchers after decrement="
operator|+
name|onDeckSearchers
argument_list|)
expr_stmt|;
name|onDeckSearchers
operator|=
literal|0
expr_stmt|;
comment|// try and recover
block|}
comment|// if we failed, we need to wake up at least one waiter to continue the process
name|searcherLock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
comment|// since the indexreader was already opened, assume we can continue on
comment|// even though we got an exception.
return|return
name|returnSearcher
condition|?
name|newSearchHolder
else|:
literal|null
return|;
block|}
block|}
DECL|method|newHolder
specifier|private
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|newHolder
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|)
block|{
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|holder
init|=
operator|new
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
argument_list|(
name|newSearcher
argument_list|)
block|{
specifier|public
name|void
name|close
parameter_list|()
block|{
try|try
block|{
name|resource
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|severe
argument_list|(
literal|"Error closing searcher:"
operator|+
name|SolrException
operator|.
name|toStr
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|holder
operator|.
name|incref
argument_list|()
expr_stmt|;
comment|// set ref count to 1 to account for this._searcher
return|return
name|holder
return|;
block|}
comment|// Take control of newSearcherHolder (which should have a reference count of at
comment|// least 1 already.  If the caller wishes to use the newSearcherHolder directly
comment|// after registering it, then they should increment the reference count *before*
comment|// calling this method.
comment|//
comment|// onDeckSearchers will also be decremented (it should have been incremented
comment|// as a result of opening a new searcher).
DECL|method|registerSearcher
specifier|private
name|void
name|registerSearcher
parameter_list|(
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|newSearcherHolder
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
try|try
block|{
if|if
condition|(
name|_searcher
operator|!=
literal|null
condition|)
block|{
name|_searcher
operator|.
name|decref
argument_list|()
expr_stmt|;
comment|// dec refcount for this._searcher
name|_searcher
operator|=
literal|null
expr_stmt|;
block|}
name|_searcher
operator|=
name|newSearcherHolder
expr_stmt|;
name|SolrIndexSearcher
name|newSearcher
init|=
name|newSearcherHolder
operator|.
name|get
argument_list|()
decl_stmt|;
name|SolrInfoRegistry
operator|.
name|getRegistry
argument_list|()
operator|.
name|put
argument_list|(
literal|"currentSearcher"
argument_list|,
name|newSearcher
argument_list|)
expr_stmt|;
name|newSearcher
operator|.
name|register
argument_list|()
expr_stmt|;
comment|// register subitems (caches)
name|log
operator|.
name|info
argument_list|(
literal|"Registered new searcher "
operator|+
name|newSearcher
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|log
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// wake up anyone waiting for a searcher
comment|// even in the face of errors.
name|onDeckSearchers
operator|--
expr_stmt|;
name|searcherLock
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|closeSearcher
specifier|public
name|void
name|closeSearcher
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Closing main searcher on request."
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
name|_searcher
operator|!=
literal|null
condition|)
block|{
name|_searcher
operator|.
name|decref
argument_list|()
expr_stmt|;
comment|// dec refcount for this._searcher
name|_searcher
operator|=
literal|null
expr_stmt|;
name|SolrInfoRegistry
operator|.
name|getRegistry
argument_list|()
operator|.
name|remove
argument_list|(
literal|"currentSearcher"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|execute
specifier|public
name|void
name|execute
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|)
block|{
name|SolrRequestHandler
name|handler
init|=
name|getRequestHandler
argument_list|(
name|req
operator|.
name|getQueryType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|handler
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"Unknown Request Handler '"
operator|+
name|req
operator|.
name|getQueryType
argument_list|()
operator|+
literal|"' :"
operator|+
name|req
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
literal|400
argument_list|,
literal|"Unknown Request Handler '"
operator|+
name|req
operator|.
name|getQueryType
argument_list|()
operator|+
literal|"'"
argument_list|,
literal|true
argument_list|)
throw|;
block|}
name|handler
operator|.
name|handleRequest
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|req
operator|.
name|getParamString
argument_list|()
operator|+
literal|" 0 "
operator|+
call|(
name|int
call|)
argument_list|(
name|rsp
operator|.
name|getEndTime
argument_list|()
operator|-
name|req
operator|.
name|getStartTime
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|field|factory
name|XmlPullParserFactory
name|factory
decl_stmt|;
block|{
try|try
block|{
name|factory
operator|=
name|XmlPullParserFactory
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|XmlPullParserException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|factory
operator|.
name|setNamespaceAware
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|findNextTag
specifier|private
name|int
name|findNextTag
parameter_list|(
name|XmlPullParser
name|xpp
parameter_list|,
name|String
name|tag
parameter_list|)
throws|throws
name|XmlPullParserException
throws|,
name|IOException
block|{
name|int
name|eventType
decl_stmt|;
while|while
condition|(
operator|(
name|eventType
operator|=
name|xpp
operator|.
name|next
argument_list|()
operator|)
operator|!=
name|XmlPullParser
operator|.
name|END_DOCUMENT
condition|)
block|{
if|if
condition|(
name|eventType
operator|==
name|XmlPullParser
operator|.
name|START_TAG
condition|)
block|{
if|if
condition|(
name|tag
operator|.
name|equals
argument_list|(
name|xpp
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
break|break;
block|}
block|}
return|return
name|eventType
return|;
block|}
DECL|method|update
specifier|public
name|void
name|update
parameter_list|(
name|Reader
name|reader
parameter_list|,
name|Writer
name|writer
parameter_list|)
block|{
comment|// TODO: add param to specify maximum time to commit?
comment|// todo - might be nice to separate command parsing w/ a factory
comment|// then new commands could be added w/o risk to old ones
name|XmlPullParser
name|xpp
init|=
literal|null
decl_stmt|;
try|try
block|{
name|xpp
operator|=
name|factory
operator|.
name|newPullParser
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|XmlPullParserException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
name|xpp
operator|.
name|setInput
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|xpp
operator|.
name|nextTag
argument_list|()
expr_stmt|;
name|String
name|currTag
init|=
name|xpp
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"add"
operator|.
name|equals
argument_list|(
name|currTag
argument_list|)
condition|)
block|{
name|log
operator|.
name|finest
argument_list|(
literal|"SolrCore.update(add)"
argument_list|)
expr_stmt|;
name|AddUpdateCommand
name|cmd
init|=
operator|new
name|AddUpdateCommand
argument_list|()
decl_stmt|;
name|cmd
operator|.
name|allowDups
operator|=
literal|false
expr_stmt|;
comment|// the default
name|int
name|status
init|=
literal|0
decl_stmt|;
name|boolean
name|pendingAttr
init|=
literal|false
decl_stmt|,
name|committedAttr
init|=
literal|false
decl_stmt|;
name|int
name|attrcount
init|=
name|xpp
operator|.
name|getAttributeCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attrcount
condition|;
name|i
operator|++
control|)
block|{
name|String
name|attrName
init|=
name|xpp
operator|.
name|getAttributeName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|attrVal
init|=
name|xpp
operator|.
name|getAttributeValue
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"allowDups"
operator|.
name|equals
argument_list|(
name|attrName
argument_list|)
condition|)
block|{
name|cmd
operator|.
name|allowDups
operator|=
name|StrUtils
operator|.
name|parseBoolean
argument_list|(
name|attrVal
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"overwritePending"
operator|.
name|equals
argument_list|(
name|attrName
argument_list|)
condition|)
block|{
name|cmd
operator|.
name|overwritePending
operator|=
name|StrUtils
operator|.
name|parseBoolean
argument_list|(
name|attrVal
argument_list|)
expr_stmt|;
name|pendingAttr
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"overwriteCommitted"
operator|.
name|equals
argument_list|(
name|attrName
argument_list|)
condition|)
block|{
name|cmd
operator|.
name|overwriteCommitted
operator|=
name|StrUtils
operator|.
name|parseBoolean
argument_list|(
name|attrVal
argument_list|)
expr_stmt|;
name|committedAttr
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"Unknown attribute id in add:"
operator|+
name|attrName
argument_list|)
expr_stmt|;
block|}
block|}
comment|//set defaults for committed and pending based on allowDups value
if|if
condition|(
operator|!
name|pendingAttr
condition|)
name|cmd
operator|.
name|overwritePending
operator|=
operator|!
name|cmd
operator|.
name|allowDups
expr_stmt|;
if|if
condition|(
operator|!
name|committedAttr
condition|)
name|cmd
operator|.
name|overwriteCommitted
operator|=
operator|!
name|cmd
operator|.
name|allowDups
expr_stmt|;
name|DocumentBuilder
name|builder
init|=
operator|new
name|DocumentBuilder
argument_list|(
name|schema
argument_list|)
decl_stmt|;
name|int
name|eventType
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// this may be our second time through the loop in the case
comment|// that there are multiple docs in the add... so make sure that
comment|// objects can handle that.
name|cmd
operator|.
name|id
operator|=
literal|null
expr_stmt|;
comment|// reset the id for this add
if|if
condition|(
name|eventType
operator|!=
literal|0
condition|)
block|{
name|eventType
operator|=
name|xpp
operator|.
name|getEventType
argument_list|()
expr_stmt|;
if|if
condition|(
name|eventType
operator|==
name|XmlPullParser
operator|.
name|END_DOCUMENT
condition|)
break|break;
block|}
comment|// eventType = xpp.next();
name|eventType
operator|=
name|xpp
operator|.
name|nextTag
argument_list|()
expr_stmt|;
if|if
condition|(
name|eventType
operator|==
name|XmlPullParser
operator|.
name|END_TAG
operator|||
name|eventType
operator|==
name|XmlPullParser
operator|.
name|END_DOCUMENT
condition|)
break|break;
comment|// should match</add>
try|try
block|{
name|readDoc
argument_list|(
name|builder
argument_list|,
name|xpp
argument_list|)
expr_stmt|;
name|builder
operator|.
name|endDoc
argument_list|()
expr_stmt|;
name|cmd
operator|.
name|doc
operator|=
name|builder
operator|.
name|getDoc
argument_list|()
expr_stmt|;
name|log
operator|.
name|finest
argument_list|(
literal|"adding doc..."
argument_list|)
expr_stmt|;
name|updateHandler
operator|.
name|addDoc
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"add "
operator|+
name|status
operator|+
literal|" "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|"<result status=\""
operator|+
name|status
operator|+
literal|"\"></result>"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|log
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"add "
operator|+
name|e
operator|.
name|code
operator|+
literal|" "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
argument_list|)
expr_stmt|;
name|writeResult
argument_list|(
name|writer
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// we may not have finised reading the XML for this cmd,
comment|// so eat any unused input up till "</add>"
name|eventType
operator|=
name|xpp
operator|.
name|getEventType
argument_list|()
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|eventType
operator|==
name|XmlPullParser
operator|.
name|END_DOCUMENT
operator|||
operator|(
name|eventType
operator|==
name|XmlPullParser
operator|.
name|END_TAG
operator|&&
literal|"add"
operator|.
name|equals
argument_list|(
name|xpp
operator|.
name|getName
argument_list|()
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
name|eventType
operator|=
name|xpp
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/***       while (findNextTag(xpp,"doc") != XmlPullParser.END_DOCUMENT) {         readDoc(builder,xpp);         Document doc = builder.endDoc();         indexWriter.addDocument(doc);         docsAdded++;       }       ***/
block|}
comment|// end add
elseif|else
if|if
condition|(
literal|"commit"
operator|.
name|equals
argument_list|(
name|currTag
argument_list|)
operator|||
literal|"optimize"
operator|.
name|equals
argument_list|(
name|currTag
argument_list|)
condition|)
block|{
name|log
operator|.
name|finest
argument_list|(
literal|"parsing "
operator|+
name|currTag
argument_list|)
expr_stmt|;
try|try
block|{
name|CommitUpdateCommand
name|cmd
init|=
operator|new
name|CommitUpdateCommand
argument_list|(
literal|"optimize"
operator|.
name|equals
argument_list|(
name|currTag
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|sawWaitSearcher
init|=
literal|false
decl_stmt|,
name|sawWaitFlush
init|=
literal|false
decl_stmt|;
name|int
name|attrcount
init|=
name|xpp
operator|.
name|getAttributeCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attrcount
condition|;
name|i
operator|++
control|)
block|{
name|String
name|attrName
init|=
name|xpp
operator|.
name|getAttributeName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|attrVal
init|=
name|xpp
operator|.
name|getAttributeValue
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"waitFlush"
operator|.
name|equals
argument_list|(
name|attrName
argument_list|)
condition|)
block|{
name|cmd
operator|.
name|waitFlush
operator|=
name|StrUtils
operator|.
name|parseBoolean
argument_list|(
name|attrVal
argument_list|)
expr_stmt|;
name|sawWaitFlush
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"waitSearcher"
operator|.
name|equals
argument_list|(
name|attrName
argument_list|)
condition|)
block|{
name|cmd
operator|.
name|waitSearcher
operator|=
name|StrUtils
operator|.
name|parseBoolean
argument_list|(
name|attrVal
argument_list|)
expr_stmt|;
name|sawWaitSearcher
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"unexpected attribute commit/@"
operator|+
name|attrName
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If waitFlush is specified and waitSearcher wasn't, then
comment|// clear waitSearcher.
if|if
condition|(
name|sawWaitFlush
operator|&&
operator|!
name|sawWaitSearcher
condition|)
block|{
name|cmd
operator|.
name|waitSearcher
operator|=
literal|false
expr_stmt|;
block|}
name|updateHandler
operator|.
name|commit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"optimize"
operator|.
name|equals
argument_list|(
name|currTag
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"optimize 0 "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"commit 0 "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|eventType
init|=
name|xpp
operator|.
name|nextTag
argument_list|()
decl_stmt|;
if|if
condition|(
name|eventType
operator|==
name|XmlPullParser
operator|.
name|END_TAG
condition|)
break|break;
comment|// match</commit>
block|}
name|writer
operator|.
name|write
argument_list|(
literal|"<result status=\"0\"></result>"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|log
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"optimize"
operator|.
name|equals
argument_list|(
name|currTag
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"optimize "
operator|+
name|e
operator|.
name|code
operator|+
literal|" "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"commit "
operator|+
name|e
operator|.
name|code
operator|+
literal|" "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
argument_list|)
expr_stmt|;
block|}
name|writeResult
argument_list|(
name|writer
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|"Exception during commit/optimize"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|writeResult
argument_list|(
name|writer
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// end commit
elseif|else
if|if
condition|(
literal|"delete"
operator|.
name|equals
argument_list|(
name|currTag
argument_list|)
condition|)
block|{
name|log
operator|.
name|finest
argument_list|(
literal|"parsing delete"
argument_list|)
expr_stmt|;
try|try
block|{
name|DeleteUpdateCommand
name|cmd
init|=
operator|new
name|DeleteUpdateCommand
argument_list|()
decl_stmt|;
name|cmd
operator|.
name|fromPending
operator|=
literal|true
expr_stmt|;
name|cmd
operator|.
name|fromCommitted
operator|=
literal|true
expr_stmt|;
name|int
name|attrcount
init|=
name|xpp
operator|.
name|getAttributeCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attrcount
condition|;
name|i
operator|++
control|)
block|{
name|String
name|attrName
init|=
name|xpp
operator|.
name|getAttributeName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|attrVal
init|=
name|xpp
operator|.
name|getAttributeValue
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"fromPending"
operator|.
name|equals
argument_list|(
name|attrName
argument_list|)
condition|)
block|{
name|cmd
operator|.
name|fromPending
operator|=
name|StrUtils
operator|.
name|parseBoolean
argument_list|(
name|attrVal
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"fromCommitted"
operator|.
name|equals
argument_list|(
name|attrName
argument_list|)
condition|)
block|{
name|cmd
operator|.
name|fromCommitted
operator|=
name|StrUtils
operator|.
name|parseBoolean
argument_list|(
name|attrVal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"unexpected attribute delete/@"
operator|+
name|attrName
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|eventType
init|=
name|xpp
operator|.
name|nextTag
argument_list|()
decl_stmt|;
name|currTag
operator|=
name|xpp
operator|.
name|getName
argument_list|()
expr_stmt|;
name|String
name|val
init|=
name|xpp
operator|.
name|nextText
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"id"
operator|.
name|equals
argument_list|(
name|currTag
argument_list|)
condition|)
block|{
name|cmd
operator|.
name|id
operator|=
name|val
expr_stmt|;
name|updateHandler
operator|.
name|delete
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"delete(id "
operator|+
name|val
operator|+
literal|") 0 "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"query"
operator|.
name|equals
argument_list|(
name|currTag
argument_list|)
condition|)
block|{
name|cmd
operator|.
name|query
operator|=
name|val
expr_stmt|;
name|updateHandler
operator|.
name|deleteByQuery
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"deleteByQuery(query "
operator|+
name|val
operator|+
literal|") 0 "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"unexpected XML tag /delete/"
operator|+
name|currTag
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
literal|400
argument_list|,
literal|"unexpected XML tag /delete/"
operator|+
name|currTag
argument_list|)
throw|;
block|}
name|writer
operator|.
name|write
argument_list|(
literal|"<result status=\"0\"></result>"
argument_list|)
expr_stmt|;
while|while
condition|(
name|xpp
operator|.
name|nextTag
argument_list|()
operator|!=
name|XmlPullParser
operator|.
name|END_TAG
condition|)
empty_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|log
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"delete "
operator|+
name|e
operator|.
name|code
operator|+
literal|" "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
argument_list|)
expr_stmt|;
name|writeResult
argument_list|(
name|writer
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|writeResult
argument_list|(
name|writer
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// end delete
block|}
catch|catch
parameter_list|(
name|XmlPullParserException
name|e
parameter_list|)
block|{
name|log
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|writeResult
argument_list|(
name|writer
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|writeResult
argument_list|(
name|writer
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|log
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"update "
operator|+
name|e
operator|.
name|code
operator|+
literal|" "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
argument_list|)
expr_stmt|;
name|writeResult
argument_list|(
name|writer
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|log
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|writeResult
argument_list|(
name|writer
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|readDoc
specifier|private
name|void
name|readDoc
parameter_list|(
name|DocumentBuilder
name|builder
parameter_list|,
name|XmlPullParser
name|xpp
parameter_list|)
throws|throws
name|IOException
throws|,
name|XmlPullParserException
block|{
comment|// xpp should be at<doc> at this point
name|builder
operator|.
name|startDoc
argument_list|()
expr_stmt|;
name|int
name|attrcount
init|=
name|xpp
operator|.
name|getAttributeCount
argument_list|()
decl_stmt|;
name|float
name|docBoost
init|=
literal|1.0f
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attrcount
condition|;
name|i
operator|++
control|)
block|{
name|String
name|attrName
init|=
name|xpp
operator|.
name|getAttributeName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|attrVal
init|=
name|xpp
operator|.
name|getAttributeValue
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"boost"
operator|.
name|equals
argument_list|(
name|attrName
argument_list|)
condition|)
block|{
name|docBoost
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|attrVal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"Unknown attribute doc/@"
operator|+
name|attrName
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|docBoost
operator|!=
literal|1.0f
condition|)
name|builder
operator|.
name|setBoost
argument_list|(
name|docBoost
argument_list|)
expr_stmt|;
comment|// while (findNextTag(xpp,"field") != XmlPullParser.END_DOCUMENT) {
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|eventType
init|=
name|xpp
operator|.
name|nextTag
argument_list|()
decl_stmt|;
if|if
condition|(
name|eventType
operator|==
name|XmlPullParser
operator|.
name|END_TAG
condition|)
break|break;
comment|//</doc>
name|String
name|tname
init|=
name|xpp
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// System.out.println("FIELD READER AT TAG " + tname);
if|if
condition|(
operator|!
literal|"field"
operator|.
name|equals
argument_list|(
name|tname
argument_list|)
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"unexpected XML tag doc/"
operator|+
name|tname
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
literal|400
argument_list|,
literal|"unexpected XML tag doc/"
operator|+
name|tname
argument_list|)
throw|;
block|}
comment|//
comment|// get field name and parse field attributes
comment|//
name|attrcount
operator|=
name|xpp
operator|.
name|getAttributeCount
argument_list|()
expr_stmt|;
name|String
name|name
init|=
literal|null
decl_stmt|;
name|float
name|boost
init|=
literal|1.0f
decl_stmt|;
name|boolean
name|isNull
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attrcount
condition|;
name|i
operator|++
control|)
block|{
name|String
name|attrName
init|=
name|xpp
operator|.
name|getAttributeName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|attrVal
init|=
name|xpp
operator|.
name|getAttributeValue
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"name"
operator|.
name|equals
argument_list|(
name|attrName
argument_list|)
condition|)
block|{
name|name
operator|=
name|attrVal
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"boost"
operator|.
name|equals
argument_list|(
name|attrName
argument_list|)
condition|)
block|{
name|boost
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|attrVal
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"null"
operator|.
name|equals
argument_list|(
name|attrName
argument_list|)
condition|)
block|{
name|isNull
operator|=
name|StrUtils
operator|.
name|parseBoolean
argument_list|(
name|attrVal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"Unknown attribute doc/field/@"
operator|+
name|attrName
argument_list|)
expr_stmt|;
block|}
block|}
comment|// now get the field value
name|String
name|val
init|=
name|xpp
operator|.
name|nextText
argument_list|()
decl_stmt|;
comment|// todo... text event for<field></field>???
comment|// need this line for isNull???
comment|// Don't add fields marked as null (for now at least)
if|if
condition|(
operator|!
name|isNull
condition|)
block|{
if|if
condition|(
name|docBoost
operator|!=
literal|1.0f
condition|)
block|{
name|builder
operator|.
name|addField
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
name|docBoost
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|.
name|addField
argument_list|(
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|// do I have to do a nextTag here to read the end_tag?
block|}
comment|// end field loop
block|}
DECL|method|log
specifier|final
specifier|public
specifier|static
name|void
name|log
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
DECL|method|writeResult
specifier|final
specifier|static
name|void
name|writeResult
parameter_list|(
name|Writer
name|out
parameter_list|,
name|SolrException
name|e
parameter_list|)
block|{
try|try
block|{
name|XML
operator|.
name|writeXML
argument_list|(
name|out
argument_list|,
literal|"result"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
literal|"status"
argument_list|,
name|e
operator|.
name|code
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ee
parameter_list|)
block|{
name|log
operator|.
name|severe
argument_list|(
literal|"Error writing to putput stream: "
operator|+
name|ee
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeResult
specifier|final
specifier|static
name|void
name|writeResult
parameter_list|(
name|Writer
name|out
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
try|try
block|{
name|XML
operator|.
name|writeXML
argument_list|(
name|out
argument_list|,
literal|"result"
argument_list|,
name|SolrException
operator|.
name|toStr
argument_list|(
name|e
argument_list|)
argument_list|,
literal|"status"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ee
parameter_list|)
block|{
name|log
operator|.
name|severe
argument_list|(
literal|"Error writing to putput stream: "
operator|+
name|ee
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
