begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.solr.core
package|package
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathConstants
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|SolrParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
operator|.
name|EchoParamStyle
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|DOMUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|NamedList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|util
operator|.
name|SimpleOrderedMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|highlight
operator|.
name|SolrHighlighter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|JSONResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|PythonResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|QueryResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|RubyResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrQueryResponse
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|SolrRequestHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|request
operator|.
name|XMLResponseWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|IndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|DirectUpdateHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|SolrIndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|UpdateHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|ChainedUpdateProcessorFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|update
operator|.
name|processor
operator|.
name|UpdateRequestProcessorFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|RefCounted
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|plugin
operator|.
name|AbstractPluginLoader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|plugin
operator|.
name|NamedListPluginLoader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import
begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import
begin_comment
comment|/**  * @version $Id$  */
end_comment
begin_class
DECL|class|SolrCore
specifier|public
specifier|final
class|class
name|SolrCore
block|{
DECL|field|version
specifier|public
specifier|static
specifier|final
name|String
name|version
init|=
literal|"1.0"
decl_stmt|;
DECL|field|log
specifier|public
specifier|static
name|Logger
name|log
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|SolrCore
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|schema
specifier|private
specifier|final
name|IndexSchema
name|schema
decl_stmt|;
DECL|field|dataDir
specifier|private
specifier|final
name|String
name|dataDir
decl_stmt|;
DECL|field|index_path
specifier|private
specifier|final
name|String
name|index_path
decl_stmt|;
DECL|field|updateHandler
specifier|private
specifier|final
name|UpdateHandler
name|updateHandler
decl_stmt|;
DECL|field|startTime
specifier|private
specifier|final
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
DECL|field|reqHandlers
specifier|private
specifier|final
name|RequestHandlers
name|reqHandlers
decl_stmt|;
DECL|field|highlighter
specifier|private
specifier|final
name|SolrHighlighter
name|highlighter
decl_stmt|;
DECL|field|updateProcessors
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|UpdateRequestProcessorFactory
argument_list|>
name|updateProcessors
decl_stmt|;
DECL|method|getStartTime
specifier|public
name|long
name|getStartTime
parameter_list|()
block|{
return|return
name|startTime
return|;
block|}
annotation|@
name|Deprecated
DECL|field|instance
specifier|private
specifier|static
name|SolrCore
name|instance
decl_stmt|;
DECL|field|boolean_query_max_clause_count
specifier|static
name|int
name|boolean_query_max_clause_count
init|=
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
comment|// only change the BooleanQuery maxClauseCount once for ALL cores...
DECL|method|booleanQueryMaxClauseCount
name|void
name|booleanQueryMaxClauseCount
parameter_list|()
block|{
synchronized|synchronized
init|(
name|SolrCore
operator|.
name|class
init|)
block|{
if|if
condition|(
name|boolean_query_max_clause_count
operator|==
name|Integer
operator|.
name|MIN_VALUE
condition|)
block|{
name|boolean_query_max_clause_count
operator|=
name|solrConfig
operator|.
name|booleanQueryMaxClauseCount
expr_stmt|;
name|BooleanQuery
operator|.
name|setMaxClauseCount
argument_list|(
name|boolean_query_max_clause_count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|boolean_query_max_clause_count
operator|!=
name|solrConfig
operator|.
name|booleanQueryMaxClauseCount
condition|)
name|log
operator|.
name|fine
argument_list|(
literal|"BooleanQuery.maxClauseCount= "
operator|+
name|boolean_query_max_clause_count
operator|+
literal|", ignoring "
operator|+
name|solrConfig
operator|.
name|booleanQueryMaxClauseCount
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getSolrConfig
specifier|public
name|SolrConfig
name|getSolrConfig
parameter_list|()
block|{
return|return
name|solrConfig
return|;
block|}
DECL|method|getConfigFile
specifier|public
name|String
name|getConfigFile
parameter_list|()
block|{
return|return
name|solrConfig
operator|.
name|configFile
return|;
block|}
DECL|method|getSchemaFile
specifier|public
name|String
name|getSchemaFile
parameter_list|()
block|{
return|return
name|schema
operator|.
name|getSchemaFile
argument_list|()
return|;
block|}
comment|/** The configuration used by this core (to load resources, find classes, etc). */
DECL|field|solrConfig
specifier|private
specifier|final
name|SolrConfig
name|solrConfig
decl_stmt|;
DECL|field|infoRegistry
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|SolrInfoMBean
argument_list|>
name|infoRegistry
init|=
operator|new
name|java
operator|.
name|util
operator|.
name|HashMap
argument_list|<
name|String
argument_list|,
name|SolrInfoMBean
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * @since solr 1.3    */
DECL|method|getInfoRegistry
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|SolrInfoMBean
argument_list|>
name|getInfoRegistry
parameter_list|()
block|{
return|return
name|infoRegistry
return|;
block|}
DECL|method|parseListener
specifier|public
name|List
argument_list|<
name|SolrEventListener
argument_list|>
name|parseListener
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|List
argument_list|<
name|SolrEventListener
argument_list|>
name|lst
init|=
operator|new
name|ArrayList
argument_list|<
name|SolrEventListener
argument_list|>
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Searching for listeners: "
operator|+
name|path
argument_list|)
expr_stmt|;
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|solrConfig
operator|.
name|evaluate
argument_list|(
name|path
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|className
init|=
name|DOMUtil
operator|.
name|getAttr
argument_list|(
name|node
argument_list|,
literal|"class"
argument_list|)
decl_stmt|;
name|SolrEventListener
name|listener
init|=
operator|(
name|SolrEventListener
operator|)
name|solrConfig
operator|.
name|newInstance
argument_list|(
name|className
argument_list|)
decl_stmt|;
name|listener
operator|.
name|init
argument_list|(
name|DOMUtil
operator|.
name|childNodesToNamedList
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|lst
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"added SolrEventListener: "
operator|+
name|listener
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|lst
return|;
block|}
DECL|field|firstSearcherListeners
name|List
argument_list|<
name|SolrEventListener
argument_list|>
name|firstSearcherListeners
decl_stmt|;
DECL|field|newSearcherListeners
name|List
argument_list|<
name|SolrEventListener
argument_list|>
name|newSearcherListeners
decl_stmt|;
DECL|method|parseListeners
specifier|private
name|void
name|parseListeners
parameter_list|()
block|{
name|firstSearcherListeners
operator|=
name|parseListener
argument_list|(
literal|"//listener[@event=\"firstSearcher\"]"
argument_list|)
expr_stmt|;
name|newSearcherListeners
operator|=
name|parseListener
argument_list|(
literal|"//listener[@event=\"newSearcher\"]"
argument_list|)
expr_stmt|;
block|}
DECL|method|getSchema
specifier|public
name|IndexSchema
name|getSchema
parameter_list|()
block|{
return|return
name|schema
return|;
block|}
DECL|method|getDataDir
specifier|public
name|String
name|getDataDir
parameter_list|()
block|{
return|return
name|dataDir
return|;
block|}
DECL|method|getIndexDir
specifier|public
name|String
name|getIndexDir
parameter_list|()
block|{
return|return
name|index_path
return|;
block|}
comment|// gets a non-caching searcher
DECL|method|newSearcher
specifier|public
name|SolrIndexSearcher
name|newSearcher
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|SolrIndexSearcher
argument_list|(
name|this
argument_list|,
name|schema
argument_list|,
name|name
argument_list|,
name|getIndexDir
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|initIndex
name|void
name|initIndex
parameter_list|()
block|{
try|try
block|{
name|File
name|dirFile
init|=
operator|new
name|File
argument_list|(
name|getIndexDir
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|indexExists
init|=
name|dirFile
operator|.
name|canRead
argument_list|()
decl_stmt|;
name|boolean
name|removeLocks
init|=
name|solrConfig
operator|.
name|getBool
argument_list|(
literal|"mainIndex/unlockOnStartup"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|removeLocks
condition|)
block|{
comment|// to remove locks, the directory must already exist... so we create it
comment|// if it didn't exist already...
name|Directory
name|dir
init|=
name|FSDirectory
operator|.
name|getDirectory
argument_list|(
name|dirFile
argument_list|,
operator|!
name|indexExists
argument_list|)
decl_stmt|;
if|if
condition|(
name|IndexReader
operator|.
name|isLocked
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"WARNING: Solr index directory '"
operator|+
name|getIndexDir
argument_list|()
operator|+
literal|"' is locked.  Unlocking..."
argument_list|)
expr_stmt|;
name|IndexReader
operator|.
name|unlock
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Create the index if it doesn't exist. Note that indexExists was tested *before*
comment|// lock removal, since that will result in the creation of the directory.
if|if
condition|(
operator|!
name|indexExists
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"Solr index directory '"
operator|+
name|dirFile
operator|+
literal|"' doesn't exist."
operator|+
literal|" Creating new index..."
argument_list|)
expr_stmt|;
name|SolrIndexWriter
name|writer
init|=
operator|new
name|SolrIndexWriter
argument_list|(
literal|"SolrCore.initIndex"
argument_list|,
name|getIndexDir
argument_list|()
argument_list|,
literal|true
argument_list|,
name|schema
argument_list|,
name|solrConfig
operator|.
name|mainIndexConfig
argument_list|)
decl_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Creates an instance by trying a constructor that accepts a SolrCore before    *  trying the default (no arg) constructor.    *@param className the instance class to create    *@cast the class or interface that the instance should extend or implement    *@param msg a message helping compose the exception error if any occurs.    *@return the desired instance    *@throws SolrException if the object could not be instantiated    */
DECL|method|createInstance
specifier|private
parameter_list|<
name|T
extends|extends
name|Object
parameter_list|>
name|T
name|createInstance
parameter_list|(
name|String
name|className
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|cast
parameter_list|,
name|String
name|msg
parameter_list|)
block|{
name|Class
name|clazz
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|msg
operator|==
literal|null
condition|)
name|msg
operator|=
literal|"SolrCore Object"
expr_stmt|;
try|try
block|{
try|try
block|{
name|clazz
operator|=
name|solrConfig
operator|.
name|findClass
argument_list|(
name|className
argument_list|)
expr_stmt|;
if|if
condition|(
name|cast
operator|!=
literal|null
operator|&&
operator|!
name|cast
operator|.
name|isAssignableFrom
argument_list|(
name|clazz
argument_list|)
condition|)
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error Instantiating "
operator|+
name|msg
operator|+
literal|", "
operator|+
name|className
operator|+
literal|" is not a "
operator|+
name|cast
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
name|cons
init|=
name|clazz
operator|.
name|getConstructor
argument_list|(
operator|new
name|Class
index|[]
block|{
name|SolrCore
operator|.
name|class
block|}
argument_list|)
decl_stmt|;
return|return
operator|(
name|T
operator|)
name|cons
operator|.
name|newInstance
argument_list|(
operator|new
name|Object
index|[]
block|{
name|this
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|xnomethod
parameter_list|)
block|{
return|return
operator|(
name|T
operator|)
name|clazz
operator|.
name|newInstance
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVER_ERROR
argument_list|,
literal|"Error Instantiating "
operator|+
name|msg
operator|+
literal|", "
operator|+
name|className
operator|+
literal|" failed to instantiate "
operator|+
name|cast
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|createEventListener
specifier|public
name|SolrEventListener
name|createEventListener
parameter_list|(
name|String
name|className
parameter_list|)
block|{
return|return
name|createInstance
argument_list|(
name|className
argument_list|,
name|SolrEventListener
operator|.
name|class
argument_list|,
literal|"Event Listener"
argument_list|)
return|;
block|}
DECL|method|createRequestHandler
specifier|public
name|SolrRequestHandler
name|createRequestHandler
parameter_list|(
name|String
name|className
parameter_list|)
block|{
return|return
name|createInstance
argument_list|(
name|className
argument_list|,
name|SolrRequestHandler
operator|.
name|class
argument_list|,
literal|"Request Handler"
argument_list|)
return|;
block|}
DECL|method|createUpdateHandler
specifier|private
name|UpdateHandler
name|createUpdateHandler
parameter_list|(
name|String
name|className
parameter_list|)
block|{
return|return
name|createInstance
argument_list|(
name|className
argument_list|,
name|UpdateHandler
operator|.
name|class
argument_list|,
literal|"Update Handler"
argument_list|)
return|;
block|}
comment|/**     * @return the last core initalized.  If you are using multiple cores,     * this is not a function to use.    */
annotation|@
name|Deprecated
DECL|method|getSolrCore
specifier|public
specifier|static
name|SolrCore
name|getSolrCore
parameter_list|()
block|{
return|return
name|instance
return|;
block|}
comment|/**    * Creates a new core and register it in the list of cores.    * If a core with the same name already exists, it will be stopped and replaced by this one.    *@param dataDir the index directory    *@param config a solr config instance    *@param schema a solr schema instance    */
DECL|method|SolrCore
specifier|public
name|SolrCore
parameter_list|(
name|String
name|dataDir
parameter_list|,
name|SolrConfig
name|config
parameter_list|,
name|IndexSchema
name|schema
parameter_list|)
block|{
synchronized|synchronized
init|(
name|SolrCore
operator|.
name|class
init|)
block|{
comment|// this is for backward compatibility (and also the reason
comment|// the sync block is needed)
name|instance
operator|=
name|this
expr_stmt|;
comment|// set singleton
if|if
condition|(
name|dataDir
operator|==
literal|null
condition|)
block|{
name|dataDir
operator|=
name|config
operator|.
name|get
argument_list|(
literal|"dataDir"
argument_list|,
name|config
operator|.
name|getInstanceDir
argument_list|()
operator|+
literal|"data"
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Opening new SolrCore at "
operator|+
name|config
operator|.
name|getInstanceDir
argument_list|()
operator|+
literal|", dataDir="
operator|+
name|dataDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|schema
operator|==
literal|null
condition|)
block|{
name|schema
operator|=
operator|new
name|IndexSchema
argument_list|(
name|config
argument_list|,
literal|"schema.xml"
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|schema
operator|=
name|schema
expr_stmt|;
name|this
operator|.
name|dataDir
operator|=
name|dataDir
expr_stmt|;
name|this
operator|.
name|index_path
operator|=
name|dataDir
operator|+
literal|"/"
operator|+
literal|"index"
expr_stmt|;
name|this
operator|.
name|solrConfig
operator|=
name|config
expr_stmt|;
name|this
operator|.
name|maxWarmingSearchers
operator|=
name|config
operator|.
name|getInt
argument_list|(
literal|"query/maxWarmingSearchers"
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|booleanQueryMaxClauseCount
argument_list|()
expr_stmt|;
name|parseListeners
argument_list|()
expr_stmt|;
name|initIndex
argument_list|()
expr_stmt|;
name|initWriters
argument_list|()
expr_stmt|;
comment|// Processors initialized before the handlers
name|updateProcessors
operator|=
name|loadUpdateProcessors
argument_list|()
expr_stmt|;
name|reqHandlers
operator|=
operator|new
name|RequestHandlers
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|reqHandlers
operator|.
name|initHandlersFromConfig
argument_list|(
name|solrConfig
argument_list|)
expr_stmt|;
comment|// TODO? could select the highlighter implementation
name|highlighter
operator|=
operator|new
name|SolrHighlighter
argument_list|()
expr_stmt|;
name|highlighter
operator|.
name|initalize
argument_list|(
name|solrConfig
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Open the searcher *before* the handler so we don't end up opening
comment|// one in the middle.
name|getSearcher
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|updateHandler
operator|=
name|createUpdateHandler
argument_list|(
name|solrConfig
operator|.
name|get
argument_list|(
literal|"updateHandler/@class"
argument_list|,
name|DirectUpdateHandler
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Load the request processors configured in solrconfig.xml    */
DECL|method|loadUpdateProcessors
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|UpdateRequestProcessorFactory
argument_list|>
name|loadUpdateProcessors
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|UpdateRequestProcessorFactory
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|UpdateRequestProcessorFactory
argument_list|>
argument_list|()
decl_stmt|;
comment|// If this is a more general use-case, this could be a regular type
specifier|final
name|SolrCore
name|thiscore
init|=
name|this
decl_stmt|;
name|AbstractPluginLoader
argument_list|<
name|UpdateRequestProcessorFactory
argument_list|>
name|loader
init|=
operator|new
name|AbstractPluginLoader
argument_list|<
name|UpdateRequestProcessorFactory
argument_list|>
argument_list|(
literal|"updateRequestProcessor"
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|init
parameter_list|(
name|UpdateRequestProcessorFactory
name|plugin
parameter_list|,
name|Node
name|node
parameter_list|)
throws|throws
name|Exception
block|{
name|plugin
operator|.
name|init
argument_list|(
name|thiscore
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|UpdateRequestProcessorFactory
name|register
parameter_list|(
name|String
name|name
parameter_list|,
name|UpdateRequestProcessorFactory
name|plugin
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|map
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|plugin
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|solrConfig
operator|.
name|evaluate
argument_list|(
literal|"updateRequestProcessor/factory"
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
name|UpdateRequestProcessorFactory
name|def
init|=
name|loader
operator|.
name|load
argument_list|(
name|solrConfig
argument_list|,
name|nodes
argument_list|)
decl_stmt|;
if|if
condition|(
name|def
operator|==
literal|null
condition|)
block|{
name|def
operator|=
operator|new
name|ChainedUpdateProcessorFactory
argument_list|()
expr_stmt|;
comment|// the default
name|def
operator|.
name|init
argument_list|(
name|thiscore
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|def
argument_list|)
expr_stmt|;
return|return
name|map
return|;
block|}
comment|/**    * @return an update processor registered to the given name.  Throw an exception if this factory is undefined    */
DECL|method|getUpdateProcessorFactory
specifier|public
name|UpdateRequestProcessorFactory
name|getUpdateProcessorFactory
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|UpdateRequestProcessorFactory
name|factory
init|=
name|updateProcessors
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|factory
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"unknown UpdateProcessorFactory: "
operator|+
name|name
argument_list|)
throw|;
block|}
return|return
name|factory
return|;
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"CLOSING SolrCore!"
argument_list|)
expr_stmt|;
try|try
block|{
name|closeSearcher
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|searcherExecutor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|updateHandler
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|finalize
specifier|protected
name|void
name|finalize
parameter_list|()
block|{
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Returns a Request object based on the admin/pingQuery section    * of the Solr config file.    */
DECL|method|getPingQueryRequest
specifier|public
name|SolrQueryRequest
name|getPingQueryRequest
parameter_list|()
block|{
return|return
name|solrConfig
operator|.
name|getPingQueryRequest
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|////////////////////////////////////////////////////////////////////////////////
comment|// Request Handler
comment|////////////////////////////////////////////////////////////////////////////////
comment|/**    * Get the request handler registered to a given name.      *     * This function is thread safe.    */
DECL|method|getRequestHandler
specifier|public
name|SolrRequestHandler
name|getRequestHandler
parameter_list|(
name|String
name|handlerName
parameter_list|)
block|{
return|return
name|reqHandlers
operator|.
name|get
argument_list|(
name|handlerName
argument_list|)
return|;
block|}
comment|/**    * Returns an unmodifieable Map containing the registered handlers    */
DECL|method|getRequestHandlers
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|SolrRequestHandler
argument_list|>
name|getRequestHandlers
parameter_list|()
block|{
return|return
name|reqHandlers
operator|.
name|getRequestHandlers
argument_list|()
return|;
block|}
comment|/**    * Get the SolrHighlighter    */
DECL|method|getHighlighter
specifier|public
name|SolrHighlighter
name|getHighlighter
parameter_list|()
block|{
return|return
name|highlighter
return|;
block|}
comment|/**    * Registers a handler at the specified location.  If one exists there, it will be replaced.    * To remove a handler, register<code>null</code> at its path    *     * Once registered the handler can be accessed through:    *<pre>    *   http://${host}:${port}/${context}/${handlerName}    * or:      *   http://${host}:${port}/${context}/select?qt=${handlerName}    *</pre>      *     * Handlers<em>must</em> be initalized before getting registered.  Registered    * handlers can immediatly accept requests.    *     * This call is thread safe.    *      * @return the previous<code>SolrRequestHandler</code> registered to this name<code>null</code> if none.    */
DECL|method|registerRequestHandler
specifier|public
name|SolrRequestHandler
name|registerRequestHandler
parameter_list|(
name|String
name|handlerName
parameter_list|,
name|SolrRequestHandler
name|handler
parameter_list|)
block|{
return|return
name|reqHandlers
operator|.
name|register
argument_list|(
name|handlerName
argument_list|,
name|handler
argument_list|)
return|;
block|}
comment|////////////////////////////////////////////////////////////////////////////////
comment|// Update Handler
comment|////////////////////////////////////////////////////////////////////////////////
comment|/**    * RequestHandlers need access to the updateHandler so they can all talk to the    * same RAM indexer.      */
DECL|method|getUpdateHandler
specifier|public
name|UpdateHandler
name|getUpdateHandler
parameter_list|()
block|{
return|return
name|updateHandler
return|;
block|}
comment|////////////////////////////////////////////////////////////////////////////////
comment|// Searcher Control
comment|////////////////////////////////////////////////////////////////////////////////
comment|// The current searcher used to service queries.
comment|// Don't access this directly!!!! use getSearcher() to
comment|// get it (and it will increment the ref count at the same time)
DECL|field|_searcher
specifier|private
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|_searcher
decl_stmt|;
DECL|field|searcherExecutor
specifier|final
name|ExecutorService
name|searcherExecutor
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
decl_stmt|;
DECL|field|onDeckSearchers
specifier|private
name|int
name|onDeckSearchers
decl_stmt|;
comment|// number of searchers preparing
DECL|field|searcherLock
specifier|private
name|Object
name|searcherLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|// the sync object for the searcher
DECL|field|maxWarmingSearchers
specifier|private
specifier|final
name|int
name|maxWarmingSearchers
decl_stmt|;
comment|// max number of on-deck searchers allowed
DECL|method|getSearcher
specifier|public
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|getSearcher
parameter_list|()
block|{
try|try
block|{
return|return
name|getSearcher
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|log
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Get a {@link SolrIndexSearcher} or start the process of creating a new one.    *<p>    * The registered searcher is the default searcher used to service queries.    * A searcher will normally be registered after all of the warming    * and event handlers (newSearcher or firstSearcher events) have run.    * In the case where there is no registered searcher, the newly created searcher will    * be registered before running the event handlers (a slow searcher is better than no searcher).    *    *<p>    * If<tt>forceNew==true</tt> then    *  A new searcher will be opened and registered regardless of whether there is already    *    a registered searcher or other searchers in the process of being created.    *<p>    * If<tt>forceNew==false</tt> then:<ul>    *<li>If a searcher is already registered, that searcher will be returned</li>    *<li>If no searcher is currently registered, but at least one is in the process of being created, then    * this call will block until the first searcher is registered</li>    *<li>If no searcher is currently registered, and no searchers in the process of being registered, a new    * searcher will be created.</li>    *</ul>    *<p>    * If<tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with    * the reference count incremented.  It<b>must</b> be decremented when no longer needed.    *<p>    * If<tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,    * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to    *<tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time    * this method returned.    *<p>    * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.    * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.    * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.    * @throws IOException    */
DECL|method|getSearcher
specifier|public
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|getSearcher
parameter_list|(
name|boolean
name|forceNew
parameter_list|,
name|boolean
name|returnSearcher
parameter_list|,
specifier|final
name|Future
index|[]
name|waitSearcher
parameter_list|)
throws|throws
name|IOException
block|{
comment|// it may take some time to open an index.... we may need to make
comment|// sure that two threads aren't trying to open one at the same time
comment|// if it isn't necessary.
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
comment|// see if we can return the current searcher
if|if
condition|(
name|_searcher
operator|!=
literal|null
operator|&&
operator|!
name|forceNew
condition|)
block|{
if|if
condition|(
name|returnSearcher
condition|)
block|{
name|_searcher
operator|.
name|incref
argument_list|()
expr_stmt|;
return|return
name|_searcher
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// check to see if we can wait for someone else's searcher to be set
if|if
condition|(
name|onDeckSearchers
operator|>
literal|0
operator|&&
operator|!
name|forceNew
operator|&&
name|_searcher
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|searcherLock
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
name|SolrException
operator|.
name|toStr
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check again: see if we can return right now
if|if
condition|(
name|_searcher
operator|!=
literal|null
operator|&&
operator|!
name|forceNew
condition|)
block|{
if|if
condition|(
name|returnSearcher
condition|)
block|{
name|_searcher
operator|.
name|incref
argument_list|()
expr_stmt|;
return|return
name|_searcher
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// At this point, we know we need to open a new searcher...
comment|// first: increment count to signal other threads that we are
comment|//        opening a new searcher.
name|onDeckSearchers
operator|++
expr_stmt|;
if|if
condition|(
name|onDeckSearchers
operator|<
literal|1
condition|)
block|{
comment|// should never happen... just a sanity check
name|log
operator|.
name|severe
argument_list|(
literal|"ERROR!!! onDeckSearchers is "
operator|+
name|onDeckSearchers
argument_list|)
expr_stmt|;
name|onDeckSearchers
operator|=
literal|1
expr_stmt|;
comment|// reset
block|}
elseif|else
if|if
condition|(
name|onDeckSearchers
operator|>
name|maxWarmingSearchers
condition|)
block|{
name|onDeckSearchers
operator|--
expr_stmt|;
name|String
name|msg
init|=
literal|"Error opening new searcher. exceeded limit of maxWarmingSearchers="
operator|+
name|maxWarmingSearchers
operator|+
literal|", try again later."
decl_stmt|;
name|log
operator|.
name|warning
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|// HTTP 503==service unavailable, or 409==Conflict
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|SERVICE_UNAVAILABLE
argument_list|,
name|msg
argument_list|,
literal|true
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|onDeckSearchers
operator|>
literal|1
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"PERFORMANCE WARNING: Overlapping onDeckSearchers="
operator|+
name|onDeckSearchers
argument_list|)
expr_stmt|;
block|}
block|}
comment|// open the index synchronously
comment|// if this fails, we need to decrement onDeckSearchers again.
name|SolrIndexSearcher
name|tmp
decl_stmt|;
try|try
block|{
name|tmp
operator|=
operator|new
name|SolrIndexSearcher
argument_list|(
name|this
argument_list|,
name|schema
argument_list|,
literal|"main"
argument_list|,
name|index_path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
name|onDeckSearchers
operator|--
expr_stmt|;
comment|// notify another waiter to continue... it may succeed
comment|// and wake any others.
name|searcherLock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
comment|// need to close the searcher here??? we shouldn't have to.
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|th
argument_list|)
throw|;
block|}
specifier|final
name|SolrIndexSearcher
name|newSearcher
init|=
name|tmp
decl_stmt|;
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|currSearcherHolder
init|=
literal|null
decl_stmt|;
specifier|final
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|newSearchHolder
init|=
name|newHolder
argument_list|(
name|newSearcher
argument_list|)
decl_stmt|;
if|if
condition|(
name|returnSearcher
condition|)
name|newSearchHolder
operator|.
name|incref
argument_list|()
expr_stmt|;
comment|// a signal to decrement onDeckSearchers if something goes wrong.
specifier|final
name|boolean
index|[]
name|decrementOnDeckCount
init|=
operator|new
name|boolean
index|[
literal|1
index|]
decl_stmt|;
name|decrementOnDeckCount
index|[
literal|0
index|]
operator|=
literal|true
expr_stmt|;
try|try
block|{
name|boolean
name|alreadyRegistered
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
name|_searcher
operator|==
literal|null
condition|)
block|{
comment|// if there isn't a current searcher then we may
comment|// want to register this one before warming is complete instead of waiting.
if|if
condition|(
name|solrConfig
operator|.
name|getBool
argument_list|(
literal|"query/useColdSearcher"
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|registerSearcher
argument_list|(
name|newSearchHolder
argument_list|)
expr_stmt|;
name|decrementOnDeckCount
index|[
literal|0
index|]
operator|=
literal|false
expr_stmt|;
name|alreadyRegistered
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// get a reference to the current searcher for purposes of autowarming.
name|currSearcherHolder
operator|=
name|_searcher
expr_stmt|;
name|currSearcherHolder
operator|.
name|incref
argument_list|()
expr_stmt|;
block|}
block|}
specifier|final
name|SolrIndexSearcher
name|currSearcher
init|=
name|currSearcherHolder
operator|==
literal|null
condition|?
literal|null
else|:
name|currSearcherHolder
operator|.
name|get
argument_list|()
decl_stmt|;
comment|//
comment|// Note! if we registered the new searcher (but didn't increment it's
comment|// reference count because returnSearcher==false, it's possible for
comment|// someone else to register another searcher, and thus cause newSearcher
comment|// to close while we are warming.
comment|//
comment|// Should we protect against that by incrementing the reference count?
comment|// Maybe we should just let it fail?   After all, if returnSearcher==false
comment|// and newSearcher has been de-registered, what's the point of continuing?
comment|//
name|Future
name|future
init|=
literal|null
decl_stmt|;
comment|// warm the new searcher based on the current searcher.
comment|// should this go before the other event handlers or after?
if|if
condition|(
name|currSearcher
operator|!=
literal|null
condition|)
block|{
name|future
operator|=
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|newSearcher
operator|.
name|warm
argument_list|(
name|currSearcher
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currSearcher
operator|==
literal|null
operator|&&
name|firstSearcherListeners
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|future
operator|=
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
for|for
control|(
name|SolrEventListener
name|listener
range|:
name|firstSearcherListeners
control|)
block|{
name|listener
operator|.
name|newSearcher
argument_list|(
name|newSearcher
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currSearcher
operator|!=
literal|null
operator|&&
name|newSearcherListeners
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|future
operator|=
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
for|for
control|(
name|SolrEventListener
name|listener
range|:
name|newSearcherListeners
control|)
block|{
name|listener
operator|.
name|newSearcher
argument_list|(
name|newSearcher
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// WARNING: this code assumes a single threaded executor (that all tasks
comment|// queued will finish first).
specifier|final
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|currSearcherHolderF
init|=
name|currSearcherHolder
decl_stmt|;
if|if
condition|(
operator|!
name|alreadyRegistered
condition|)
block|{
name|future
operator|=
name|searcherExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|()
block|{
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
comment|// signal that we no longer need to decrement
comment|// the count *before* registering the searcher since
comment|// registerSearcher will decrement even if it errors.
name|decrementOnDeckCount
index|[
literal|0
index|]
operator|=
literal|false
expr_stmt|;
name|registerSearcher
argument_list|(
name|newSearchHolder
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// we are all done with the old searcher we used
comment|// for warming...
if|if
condition|(
name|currSearcherHolderF
operator|!=
literal|null
condition|)
name|currSearcherHolderF
operator|.
name|decref
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|waitSearcher
operator|!=
literal|null
condition|)
block|{
name|waitSearcher
index|[
literal|0
index|]
operator|=
name|future
expr_stmt|;
block|}
comment|// Return the searcher as the warming tasks run in parallel
comment|// callers may wait on the waitSearcher future returned.
return|return
name|returnSearcher
condition|?
name|newSearchHolder
else|:
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|currSearcherHolder
operator|!=
literal|null
condition|)
name|currSearcherHolder
operator|.
name|decref
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
name|decrementOnDeckCount
index|[
literal|0
index|]
condition|)
block|{
name|onDeckSearchers
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|onDeckSearchers
operator|<
literal|0
condition|)
block|{
comment|// sanity check... should never happen
name|log
operator|.
name|severe
argument_list|(
literal|"ERROR!!! onDeckSearchers after decrement="
operator|+
name|onDeckSearchers
argument_list|)
expr_stmt|;
name|onDeckSearchers
operator|=
literal|0
expr_stmt|;
comment|// try and recover
block|}
comment|// if we failed, we need to wake up at least one waiter to continue the process
name|searcherLock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
comment|// since the indexreader was already opened, assume we can continue on
comment|// even though we got an exception.
return|return
name|returnSearcher
condition|?
name|newSearchHolder
else|:
literal|null
return|;
block|}
block|}
DECL|method|newHolder
specifier|private
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|newHolder
parameter_list|(
name|SolrIndexSearcher
name|newSearcher
parameter_list|)
block|{
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|holder
init|=
operator|new
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
argument_list|(
name|newSearcher
argument_list|)
block|{
specifier|public
name|void
name|close
parameter_list|()
block|{
try|try
block|{
name|resource
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|severe
argument_list|(
literal|"Error closing searcher:"
operator|+
name|SolrException
operator|.
name|toStr
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|holder
operator|.
name|incref
argument_list|()
expr_stmt|;
comment|// set ref count to 1 to account for this._searcher
return|return
name|holder
return|;
block|}
comment|// Take control of newSearcherHolder (which should have a reference count of at
comment|// least 1 already.  If the caller wishes to use the newSearcherHolder directly
comment|// after registering it, then they should increment the reference count *before*
comment|// calling this method.
comment|//
comment|// onDeckSearchers will also be decremented (it should have been incremented
comment|// as a result of opening a new searcher).
DECL|method|registerSearcher
specifier|private
name|void
name|registerSearcher
parameter_list|(
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|newSearcherHolder
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
try|try
block|{
if|if
condition|(
name|_searcher
operator|!=
literal|null
condition|)
block|{
name|_searcher
operator|.
name|decref
argument_list|()
expr_stmt|;
comment|// dec refcount for this._searcher
name|_searcher
operator|=
literal|null
expr_stmt|;
block|}
name|_searcher
operator|=
name|newSearcherHolder
expr_stmt|;
name|SolrIndexSearcher
name|newSearcher
init|=
name|newSearcherHolder
operator|.
name|get
argument_list|()
decl_stmt|;
name|newSearcher
operator|.
name|register
argument_list|()
expr_stmt|;
comment|// register subitems (caches)
name|log
operator|.
name|info
argument_list|(
literal|"Registered new searcher "
operator|+
name|newSearcher
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|log
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// wake up anyone waiting for a searcher
comment|// even in the face of errors.
name|onDeckSearchers
operator|--
expr_stmt|;
name|searcherLock
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|closeSearcher
specifier|public
name|void
name|closeSearcher
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Closing main searcher on request."
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|searcherLock
init|)
block|{
if|if
condition|(
name|_searcher
operator|!=
literal|null
condition|)
block|{
name|_searcher
operator|.
name|decref
argument_list|()
expr_stmt|;
comment|// dec refcount for this._searcher
name|_searcher
operator|=
literal|null
expr_stmt|;
name|infoRegistry
operator|.
name|remove
argument_list|(
literal|"currentSearcher"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|execute
specifier|public
name|void
name|execute
parameter_list|(
name|SolrRequestHandler
name|handler
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|)
block|{
if|if
condition|(
name|handler
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"Null Request Handler '"
operator|+
name|req
operator|.
name|getQueryType
argument_list|()
operator|+
literal|"' :"
operator|+
name|req
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Null Request Handler '"
operator|+
name|req
operator|.
name|getQueryType
argument_list|()
operator|+
literal|"'"
argument_list|,
literal|true
argument_list|)
throw|;
block|}
comment|// setup response header and handle request
specifier|final
name|NamedList
argument_list|<
name|Object
argument_list|>
name|responseHeader
init|=
operator|new
name|SimpleOrderedMap
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|rsp
operator|.
name|add
argument_list|(
literal|"responseHeader"
argument_list|,
name|responseHeader
argument_list|)
expr_stmt|;
name|handler
operator|.
name|handleRequest
argument_list|(
name|req
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
name|setResponseHeaderValues
argument_list|(
name|handler
argument_list|,
name|responseHeader
argument_list|,
name|req
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|req
operator|.
name|getContext
argument_list|()
operator|.
name|get
argument_list|(
literal|"path"
argument_list|)
operator|+
literal|" "
operator|+
name|req
operator|.
name|getParamString
argument_list|()
operator|+
literal|" 0 "
operator|+
call|(
name|int
call|)
argument_list|(
name|rsp
operator|.
name|getEndTime
argument_list|()
operator|-
name|req
operator|.
name|getStartTime
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Deprecated
DECL|method|execute
specifier|public
name|void
name|execute
parameter_list|(
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|)
block|{
name|SolrRequestHandler
name|handler
init|=
name|getRequestHandler
argument_list|(
name|req
operator|.
name|getQueryType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|handler
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warning
argument_list|(
literal|"Unknown Request Handler '"
operator|+
name|req
operator|.
name|getQueryType
argument_list|()
operator|+
literal|"' :"
operator|+
name|req
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Unknown Request Handler '"
operator|+
name|req
operator|.
name|getQueryType
argument_list|()
operator|+
literal|"'"
argument_list|,
literal|true
argument_list|)
throw|;
block|}
name|execute
argument_list|(
name|handler
argument_list|,
name|req
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
block|}
DECL|method|setResponseHeaderValues
specifier|protected
name|void
name|setResponseHeaderValues
parameter_list|(
name|SolrRequestHandler
name|handler
parameter_list|,
name|NamedList
argument_list|<
name|Object
argument_list|>
name|responseHeader
parameter_list|,
name|SolrQueryRequest
name|req
parameter_list|,
name|SolrQueryResponse
name|rsp
parameter_list|)
block|{
comment|// TODO should check that responseHeader has not been replaced by handler
specifier|final
name|int
name|qtime
init|=
call|(
name|int
call|)
argument_list|(
name|rsp
operator|.
name|getEndTime
argument_list|()
operator|-
name|req
operator|.
name|getStartTime
argument_list|()
argument_list|)
decl_stmt|;
name|responseHeader
operator|.
name|add
argument_list|(
literal|"status"
argument_list|,
name|rsp
operator|.
name|getException
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
literal|500
argument_list|)
expr_stmt|;
name|responseHeader
operator|.
name|add
argument_list|(
literal|"QTime"
argument_list|,
name|qtime
argument_list|)
expr_stmt|;
name|SolrParams
name|params
init|=
name|req
operator|.
name|getParams
argument_list|()
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|getBool
argument_list|(
name|CommonParams
operator|.
name|HEADER_ECHO_HANDLER
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|responseHeader
operator|.
name|add
argument_list|(
literal|"handler"
argument_list|,
name|handler
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Values for echoParams... false/true/all or false/explicit/all ???
name|String
name|ep
init|=
name|params
operator|.
name|get
argument_list|(
name|CommonParams
operator|.
name|HEADER_ECHO_PARAMS
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|ep
operator|!=
literal|null
condition|)
block|{
name|EchoParamStyle
name|echoParams
init|=
name|EchoParamStyle
operator|.
name|get
argument_list|(
name|ep
argument_list|)
decl_stmt|;
if|if
condition|(
name|echoParams
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SolrException
argument_list|(
name|SolrException
operator|.
name|ErrorCode
operator|.
name|BAD_REQUEST
argument_list|,
literal|"Invalid value '"
operator|+
name|ep
operator|+
literal|"' for "
operator|+
name|CommonParams
operator|.
name|HEADER_ECHO_PARAMS
operator|+
literal|" parameter, use '"
operator|+
name|EchoParamStyle
operator|.
name|EXPLICIT
operator|+
literal|"' or '"
operator|+
name|EchoParamStyle
operator|.
name|ALL
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
name|echoParams
operator|==
name|EchoParamStyle
operator|.
name|EXPLICIT
condition|)
block|{
name|responseHeader
operator|.
name|add
argument_list|(
literal|"params"
argument_list|,
name|req
operator|.
name|getOriginalParams
argument_list|()
operator|.
name|toNamedList
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|echoParams
operator|==
name|EchoParamStyle
operator|.
name|ALL
condition|)
block|{
name|responseHeader
operator|.
name|add
argument_list|(
literal|"params"
argument_list|,
name|req
operator|.
name|getParams
argument_list|()
operator|.
name|toNamedList
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|log
specifier|final
specifier|public
specifier|static
name|void
name|log
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SolrException
operator|.
name|logOnce
argument_list|(
name|log
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
DECL|field|defaultResponseWriter
specifier|private
name|QueryResponseWriter
name|defaultResponseWriter
decl_stmt|;
DECL|field|responseWriters
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|QueryResponseWriter
argument_list|>
name|responseWriters
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|QueryResponseWriter
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Configure the query response writers. There will always be a default writer; additional     * writers may also be configured. */
DECL|method|initWriters
specifier|private
name|void
name|initWriters
parameter_list|()
block|{
name|String
name|xpath
init|=
literal|"queryResponseWriter"
decl_stmt|;
name|NodeList
name|nodes
init|=
operator|(
name|NodeList
operator|)
name|solrConfig
operator|.
name|evaluate
argument_list|(
name|xpath
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
name|NamedListPluginLoader
argument_list|<
name|QueryResponseWriter
argument_list|>
name|loader
init|=
operator|new
name|NamedListPluginLoader
argument_list|<
name|QueryResponseWriter
argument_list|>
argument_list|(
literal|"[solrconfig.xml] "
operator|+
name|xpath
argument_list|,
name|responseWriters
argument_list|)
decl_stmt|;
name|defaultResponseWriter
operator|=
name|loader
operator|.
name|load
argument_list|(
name|solrConfig
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
comment|// configure the default response writer; this one should never be null
if|if
condition|(
name|defaultResponseWriter
operator|==
literal|null
condition|)
block|{
name|defaultResponseWriter
operator|=
name|responseWriters
operator|.
name|get
argument_list|(
literal|"standard"
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaultResponseWriter
operator|==
literal|null
condition|)
block|{
name|defaultResponseWriter
operator|=
operator|new
name|XMLResponseWriter
argument_list|()
expr_stmt|;
block|}
block|}
comment|// make JSON response writers available by default
if|if
condition|(
name|responseWriters
operator|.
name|get
argument_list|(
literal|"json"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|responseWriters
operator|.
name|put
argument_list|(
literal|"json"
argument_list|,
operator|new
name|JSONResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|responseWriters
operator|.
name|get
argument_list|(
literal|"python"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|responseWriters
operator|.
name|put
argument_list|(
literal|"python"
argument_list|,
operator|new
name|PythonResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|responseWriters
operator|.
name|get
argument_list|(
literal|"ruby"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|responseWriters
operator|.
name|put
argument_list|(
literal|"ruby"
argument_list|,
operator|new
name|RubyResponseWriter
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Finds a writer by name, or returns the default writer if not found. */
DECL|method|getQueryResponseWriter
specifier|public
specifier|final
name|QueryResponseWriter
name|getQueryResponseWriter
parameter_list|(
name|String
name|writerName
parameter_list|)
block|{
if|if
condition|(
name|writerName
operator|!=
literal|null
condition|)
block|{
name|QueryResponseWriter
name|writer
init|=
name|responseWriters
operator|.
name|get
argument_list|(
name|writerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
return|return
name|writer
return|;
block|}
block|}
return|return
name|defaultResponseWriter
return|;
block|}
comment|/** Returns the appropriate writer for a request. If the request specifies a writer via the    * 'wt' parameter, attempts to find that one; otherwise return the default writer.    */
DECL|method|getQueryResponseWriter
specifier|public
specifier|final
name|QueryResponseWriter
name|getQueryResponseWriter
parameter_list|(
name|SolrQueryRequest
name|request
parameter_list|)
block|{
return|return
name|getQueryResponseWriter
argument_list|(
name|request
operator|.
name|getParam
argument_list|(
literal|"wt"
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class
end_unit
