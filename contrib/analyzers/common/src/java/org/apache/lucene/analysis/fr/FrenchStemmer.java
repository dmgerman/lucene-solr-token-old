begin_unit
begin_package
DECL|package|org.apache.lucene.analysis.fr
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|fr
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  * A stemmer for French words.   *<p>  * The algorithm is based on the work of  * Dr Martin Porter on his snowball project<br>  * refer to http://snowball.sourceforge.net/french/stemmer.html<br>  * (French stemming algorithm) for details  *</p>  */
end_comment
begin_class
DECL|class|FrenchStemmer
specifier|public
class|class
name|FrenchStemmer
block|{
comment|/**      * Buffer for the terms while stemming them.      */
DECL|field|sb
specifier|private
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
comment|/**      * A temporary buffer, used to reconstruct R2      */
DECL|field|tb
specifier|private
name|StringBuffer
name|tb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
comment|/** 	 * Region R0 is equal to the whole buffer 	 */
DECL|field|R0
specifier|private
name|String
name|R0
decl_stmt|;
comment|/** 	 * Region RV 	 * "If the word begins with two vowels, RV is the region after the third letter, 	 * otherwise the region after the first vowel not at the beginning of the word, 	 * or the end of the word if these positions cannot be found." 	 */
DECL|field|RV
specifier|private
name|String
name|RV
decl_stmt|;
comment|/** 	 * Region R1 	 * "R1 is the region after the first non-vowel following a vowel 	 * or is the null region at the end of the word if there is no such non-vowel" 	 */
DECL|field|R1
specifier|private
name|String
name|R1
decl_stmt|;
comment|/** 	 * Region R2 	 * "R2 is the region after the first non-vowel in R1 following a vowel 	 * or is the null region at the end of the word if there is no such non-vowel" 	 */
DECL|field|R2
specifier|private
name|String
name|R2
decl_stmt|;
comment|/** 	 * Set to true if we need to perform step 2 	 */
DECL|field|suite
specifier|private
name|boolean
name|suite
decl_stmt|;
comment|/** 	 * Set to true if the buffer was modified 	 */
DECL|field|modified
specifier|private
name|boolean
name|modified
decl_stmt|;
comment|/**      * Stems the given term to a unique<tt>discriminator</tt>.      *      * @param term  java.langString The term that should be stemmed      * @return java.lang.String  Discriminator for<tt>term</tt>      */
DECL|method|stem
specifier|protected
name|String
name|stem
parameter_list|(
name|String
name|term
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isStemmable
argument_list|(
name|term
argument_list|)
condition|)
block|{
return|return
name|term
return|;
block|}
comment|// Use lowercase for medium stemming.
name|term
operator|=
name|term
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
comment|// Reset the StringBuffer.
name|sb
operator|.
name|delete
argument_list|(
literal|0
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|term
argument_list|)
expr_stmt|;
comment|// reset the booleans
name|modified
operator|=
literal|false
expr_stmt|;
name|suite
operator|=
literal|false
expr_stmt|;
name|sb
operator|=
name|treatVowels
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|setStrings
argument_list|()
expr_stmt|;
name|step1
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|modified
operator|||
name|suite
condition|)
block|{
if|if
condition|(
name|RV
operator|!=
literal|null
condition|)
block|{
name|suite
operator|=
name|step2a
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|suite
condition|)
name|step2b
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|modified
operator|||
name|suite
condition|)
name|step3
argument_list|()
expr_stmt|;
else|else
name|step4
argument_list|()
expr_stmt|;
name|step5
argument_list|()
expr_stmt|;
name|step6
argument_list|()
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** 	 * Sets the search region Strings<br> 	 * it needs to be done each time the buffer was modified 	 */
DECL|method|setStrings
specifier|private
name|void
name|setStrings
parameter_list|()
block|{
comment|// set the strings
name|R0
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
name|RV
operator|=
name|retrieveRV
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|R1
operator|=
name|retrieveR
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|R1
operator|!=
literal|null
condition|)
block|{
name|tb
operator|.
name|delete
argument_list|(
literal|0
argument_list|,
name|tb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|tb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|R1
argument_list|)
expr_stmt|;
name|R2
operator|=
name|retrieveR
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
else|else
name|R2
operator|=
literal|null
expr_stmt|;
block|}
comment|/** 	 * First step of the Porter Algorithm<br> 	 * refer to http://snowball.sourceforge.net/french/stemmer.html for an explanation 	 */
DECL|method|step1
specifier|private
name|void
name|step1
parameter_list|( )
block|{
name|String
index|[]
name|suffix
init|=
block|{
literal|"ances"
block|,
literal|"iqUes"
block|,
literal|"ismes"
block|,
literal|"ables"
block|,
literal|"istes"
block|,
literal|"ance"
block|,
literal|"iqUe"
block|,
literal|"isme"
block|,
literal|"able"
block|,
literal|"iste"
block|}
decl_stmt|;
name|deleteFrom
argument_list|(
name|R2
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|replaceFrom
argument_list|(
name|R2
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"logies"
block|,
literal|"logie"
block|}
argument_list|,
literal|"log"
argument_list|)
expr_stmt|;
name|replaceFrom
argument_list|(
name|R2
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"usions"
block|,
literal|"utions"
block|,
literal|"usion"
block|,
literal|"ution"
block|}
argument_list|,
literal|"u"
argument_list|)
expr_stmt|;
name|replaceFrom
argument_list|(
name|R2
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ences"
block|,
literal|"ence"
block|}
argument_list|,
literal|"ent"
argument_list|)
expr_stmt|;
name|String
index|[]
name|search
init|=
block|{
literal|"atrices"
block|,
literal|"ateurs"
block|,
literal|"ations"
block|,
literal|"atrice"
block|,
literal|"ateur"
block|,
literal|"ation"
block|}
decl_stmt|;
name|deleteButSuffixFromElseReplace
argument_list|(
name|R2
argument_list|,
name|search
argument_list|,
literal|"ic"
argument_list|,
literal|true
argument_list|,
name|R0
argument_list|,
literal|"iqU"
argument_list|)
expr_stmt|;
name|deleteButSuffixFromElseReplace
argument_list|(
name|R2
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ements"
block|,
literal|"ement"
block|}
argument_list|,
literal|"eus"
argument_list|,
literal|false
argument_list|,
name|R0
argument_list|,
literal|"eux"
argument_list|)
expr_stmt|;
name|deleteButSuffixFrom
argument_list|(
name|R2
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ements"
block|,
literal|"ement"
block|}
argument_list|,
literal|"ativ"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|deleteButSuffixFrom
argument_list|(
name|R2
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ements"
block|,
literal|"ement"
block|}
argument_list|,
literal|"iv"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|deleteButSuffixFrom
argument_list|(
name|R2
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ements"
block|,
literal|"ement"
block|}
argument_list|,
literal|"abl"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|deleteButSuffixFrom
argument_list|(
name|R2
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ements"
block|,
literal|"ement"
block|}
argument_list|,
literal|"iqU"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|deleteFromIfTestVowelBeforeIn
argument_list|(
name|R1
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"issements"
block|,
literal|"issement"
block|}
argument_list|,
literal|false
argument_list|,
name|R0
argument_list|)
expr_stmt|;
name|deleteFrom
argument_list|(
name|RV
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ements"
block|,
literal|"ement"
block|}
argument_list|)
expr_stmt|;
name|deleteButSuffixFromElseReplace
argument_list|(
name|R2
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"itÃ©s"
block|,
literal|"itÃ©"
block|}
argument_list|,
literal|"abil"
argument_list|,
literal|false
argument_list|,
name|R0
argument_list|,
literal|"abl"
argument_list|)
expr_stmt|;
name|deleteButSuffixFromElseReplace
argument_list|(
name|R2
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"itÃ©s"
block|,
literal|"itÃ©"
block|}
argument_list|,
literal|"ic"
argument_list|,
literal|false
argument_list|,
name|R0
argument_list|,
literal|"iqU"
argument_list|)
expr_stmt|;
name|deleteButSuffixFrom
argument_list|(
name|R2
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"itÃ©s"
block|,
literal|"itÃ©"
block|}
argument_list|,
literal|"iv"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|String
index|[]
name|autre
init|=
block|{
literal|"ifs"
block|,
literal|"ives"
block|,
literal|"if"
block|,
literal|"ive"
block|}
decl_stmt|;
name|deleteButSuffixFromElseReplace
argument_list|(
name|R2
argument_list|,
name|autre
argument_list|,
literal|"icat"
argument_list|,
literal|false
argument_list|,
name|R0
argument_list|,
literal|"iqU"
argument_list|)
expr_stmt|;
name|deleteButSuffixFromElseReplace
argument_list|(
name|R2
argument_list|,
name|autre
argument_list|,
literal|"at"
argument_list|,
literal|true
argument_list|,
name|R2
argument_list|,
literal|"iqU"
argument_list|)
expr_stmt|;
name|replaceFrom
argument_list|(
name|R0
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"eaux"
block|}
argument_list|,
literal|"eau"
argument_list|)
expr_stmt|;
name|replaceFrom
argument_list|(
name|R1
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"aux"
block|}
argument_list|,
literal|"al"
argument_list|)
expr_stmt|;
name|deleteButSuffixFromElseReplace
argument_list|(
name|R2
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"euses"
block|,
literal|"euse"
block|}
argument_list|,
literal|""
argument_list|,
literal|true
argument_list|,
name|R1
argument_list|,
literal|"eux"
argument_list|)
expr_stmt|;
name|deleteFrom
argument_list|(
name|R2
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"eux"
block|}
argument_list|)
expr_stmt|;
comment|// if one of the next steps is performed, we will need to perform step2a
name|boolean
name|temp
init|=
literal|false
decl_stmt|;
name|temp
operator|=
name|replaceFrom
argument_list|(
name|RV
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"amment"
block|}
argument_list|,
literal|"ant"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|true
condition|)
name|suite
operator|=
literal|true
expr_stmt|;
name|temp
operator|=
name|replaceFrom
argument_list|(
name|RV
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"emment"
block|}
argument_list|,
literal|"ent"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|true
condition|)
name|suite
operator|=
literal|true
expr_stmt|;
name|temp
operator|=
name|deleteFromIfTestVowelBeforeIn
argument_list|(
name|RV
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ments"
block|,
literal|"ment"
block|}
argument_list|,
literal|true
argument_list|,
name|RV
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|true
condition|)
name|suite
operator|=
literal|true
expr_stmt|;
block|}
comment|/** 	 * Second step (A) of the Porter Algorithm<br> 	 * Will be performed if nothing changed from the first step 	 * or changed were done in the amment, emment, ments or ment suffixes<br> 	 * refer to http://snowball.sourceforge.net/french/stemmer.html for an explanation 	 * 	 * @return boolean - true if something changed in the StringBuffer 	 */
DECL|method|step2a
specifier|private
name|boolean
name|step2a
parameter_list|()
block|{
name|String
index|[]
name|search
init|=
block|{
literal|"Ã®mes"
block|,
literal|"Ã®tes"
block|,
literal|"iraIent"
block|,
literal|"irait"
block|,
literal|"irais"
block|,
literal|"irai"
block|,
literal|"iras"
block|,
literal|"ira"
block|,
literal|"irent"
block|,
literal|"iriez"
block|,
literal|"irez"
block|,
literal|"irions"
block|,
literal|"irons"
block|,
literal|"iront"
block|,
literal|"issaIent"
block|,
literal|"issais"
block|,
literal|"issantes"
block|,
literal|"issante"
block|,
literal|"issants"
block|,
literal|"issant"
block|,
literal|"issait"
block|,
literal|"issais"
block|,
literal|"issions"
block|,
literal|"issons"
block|,
literal|"issiez"
block|,
literal|"issez"
block|,
literal|"issent"
block|,
literal|"isses"
block|,
literal|"isse"
block|,
literal|"ir"
block|,
literal|"is"
block|,
literal|"Ã®t"
block|,
literal|"it"
block|,
literal|"ies"
block|,
literal|"ie"
block|,
literal|"i"
block|}
decl_stmt|;
return|return
name|deleteFromIfTestVowelBeforeIn
argument_list|(
name|RV
argument_list|,
name|search
argument_list|,
literal|false
argument_list|,
name|RV
argument_list|)
return|;
block|}
comment|/** 	 * Second step (B) of the Porter Algorithm<br> 	 * Will be performed if step 2 A was performed unsuccessfully<br> 	 * refer to http://snowball.sourceforge.net/french/stemmer.html for an explanation 	 */
DECL|method|step2b
specifier|private
name|void
name|step2b
parameter_list|()
block|{
name|String
index|[]
name|suffix
init|=
block|{
literal|"eraIent"
block|,
literal|"erais"
block|,
literal|"erait"
block|,
literal|"erai"
block|,
literal|"eras"
block|,
literal|"erions"
block|,
literal|"eriez"
block|,
literal|"erons"
block|,
literal|"eront"
block|,
literal|"erez"
block|,
literal|"Ã¨rent"
block|,
literal|"era"
block|,
literal|"Ã©es"
block|,
literal|"iez"
block|,
literal|"Ã©e"
block|,
literal|"Ã©s"
block|,
literal|"er"
block|,
literal|"ez"
block|,
literal|"Ã©"
block|}
decl_stmt|;
name|deleteFrom
argument_list|(
name|RV
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|String
index|[]
name|search
init|=
block|{
literal|"assions"
block|,
literal|"assiez"
block|,
literal|"assent"
block|,
literal|"asses"
block|,
literal|"asse"
block|,
literal|"aIent"
block|,
literal|"antes"
block|,
literal|"aIent"
block|,
literal|"Aient"
block|,
literal|"ante"
block|,
literal|"Ã¢mes"
block|,
literal|"Ã¢tes"
block|,
literal|"ants"
block|,
literal|"ant"
block|,
literal|"ait"
block|,
literal|"aÃ®t"
block|,
literal|"ais"
block|,
literal|"Ait"
block|,
literal|"AÃ®t"
block|,
literal|"Ais"
block|,
literal|"Ã¢t"
block|,
literal|"as"
block|,
literal|"ai"
block|,
literal|"Ai"
block|,
literal|"a"
block|}
decl_stmt|;
name|deleteButSuffixFrom
argument_list|(
name|RV
argument_list|,
name|search
argument_list|,
literal|"e"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|deleteFrom
argument_list|(
name|R2
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ions"
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Third step of the Porter Algorithm<br> 	 * refer to http://snowball.sourceforge.net/french/stemmer.html for an explanation 	 */
DECL|method|step3
specifier|private
name|void
name|step3
parameter_list|()
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|char
name|ch
init|=
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'Y'
condition|)
block|{
name|sb
operator|.
name|setCharAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
name|setStrings
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'Ã§'
condition|)
block|{
name|sb
operator|.
name|setCharAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
name|setStrings
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** 	 * Fourth step of the Porter Algorithm<br> 	 * refer to http://snowball.sourceforge.net/french/stemmer.html for an explanation 	 */
DECL|method|step4
specifier|private
name|void
name|step4
parameter_list|()
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
name|char
name|ch
init|=
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'s'
condition|)
block|{
name|char
name|b
init|=
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|'a'
operator|&&
name|b
operator|!=
literal|'i'
operator|&&
name|b
operator|!=
literal|'o'
operator|&&
name|b
operator|!=
literal|'u'
operator|&&
name|b
operator|!=
literal|'Ã¨'
operator|&&
name|b
operator|!=
literal|'s'
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|setStrings
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|boolean
name|found
init|=
name|deleteFromIfPrecededIn
argument_list|(
name|R2
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ion"
block|}
argument_list|,
name|RV
argument_list|,
literal|"s"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|found
operator|=
name|deleteFromIfPrecededIn
argument_list|(
name|R2
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ion"
block|}
argument_list|,
name|RV
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
name|replaceFrom
argument_list|(
name|RV
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"IÃ¨re"
block|,
literal|"iÃ¨re"
block|,
literal|"Ier"
block|,
literal|"ier"
block|}
argument_list|,
literal|"i"
argument_list|)
expr_stmt|;
name|deleteFrom
argument_list|(
name|RV
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"e"
block|}
argument_list|)
expr_stmt|;
name|deleteFromIfPrecededIn
argument_list|(
name|RV
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"Ã«"
block|}
argument_list|,
name|R0
argument_list|,
literal|"gu"
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Fifth step of the Porter Algorithm<br> 	 * refer to http://snowball.sourceforge.net/french/stemmer.html for an explanation 	 */
DECL|method|step5
specifier|private
name|void
name|step5
parameter_list|()
block|{
if|if
condition|(
name|R0
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|R0
operator|.
name|endsWith
argument_list|(
literal|"enn"
argument_list|)
operator|||
name|R0
operator|.
name|endsWith
argument_list|(
literal|"onn"
argument_list|)
operator|||
name|R0
operator|.
name|endsWith
argument_list|(
literal|"ett"
argument_list|)
operator|||
name|R0
operator|.
name|endsWith
argument_list|(
literal|"ell"
argument_list|)
operator|||
name|R0
operator|.
name|endsWith
argument_list|(
literal|"eill"
argument_list|)
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|setStrings
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** 	 * Sixth (and last!) step of the Porter Algorithm<br> 	 * refer to http://snowball.sourceforge.net/french/stemmer.html for an explanation 	 */
DECL|method|step6
specifier|private
name|void
name|step6
parameter_list|()
block|{
if|if
condition|(
name|R0
operator|!=
literal|null
operator|&&
name|R0
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|boolean
name|seenVowel
init|=
literal|false
decl_stmt|;
name|boolean
name|seenConson
init|=
literal|false
decl_stmt|;
name|int
name|pos
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|R0
operator|.
name|length
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>
operator|-
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|char
name|ch
init|=
name|R0
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|isVowel
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|seenVowel
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'Ã©'
operator|||
name|ch
operator|==
literal|'Ã¨'
condition|)
block|{
name|pos
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|seenVowel
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|seenVowel
condition|)
break|break;
else|else
name|seenConson
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pos
operator|>
operator|-
literal|1
operator|&&
name|seenConson
operator|&&
operator|!
name|seenVowel
condition|)
name|sb
operator|.
name|setCharAt
argument_list|(
name|pos
argument_list|,
literal|'e'
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Delete a suffix searched in zone "source" if zone "from" contains prefix + search string 	 * 	 * @param source java.lang.String - the primary source zone for search 	 * @param search java.lang.String[] - the strings to search for suppression 	 * @param from java.lang.String - the secondary source zone for search 	 * @param prefix java.lang.String - the prefix to add to the search string to test 	 * @return boolean - true if modified 	 */
DECL|method|deleteFromIfPrecededIn
specifier|private
name|boolean
name|deleteFromIfPrecededIn
parameter_list|(
name|String
name|source
parameter_list|,
name|String
index|[]
name|search
parameter_list|,
name|String
name|from
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|source
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|search
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|source
operator|.
name|endsWith
argument_list|(
name|search
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|from
operator|!=
literal|null
operator|&&
name|from
operator|.
name|endsWith
argument_list|(
name|prefix
operator|+
name|search
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
name|search
index|[
name|i
index|]
operator|.
name|length
argument_list|()
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
name|setStrings
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|found
return|;
block|}
comment|/** 	 * Delete a suffix searched in zone "source" if the preceding letter is (or isn't) a vowel 	 * 	 * @param source java.lang.String - the primary source zone for search 	 * @param search java.lang.String[] - the strings to search for suppression 	 * @param vowel boolean - true if we need a vowel before the search string 	 * @param from java.lang.String - the secondary source zone for search (where vowel could be) 	 * @return boolean - true if modified 	 */
DECL|method|deleteFromIfTestVowelBeforeIn
specifier|private
name|boolean
name|deleteFromIfTestVowelBeforeIn
parameter_list|(
name|String
name|source
parameter_list|,
name|String
index|[]
name|search
parameter_list|,
name|boolean
name|vowel
parameter_list|,
name|String
name|from
parameter_list|)
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|source
operator|!=
literal|null
operator|&&
name|from
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|search
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|source
operator|.
name|endsWith
argument_list|(
name|search
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|search
index|[
name|i
index|]
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|)
operator|<=
name|from
operator|.
name|length
argument_list|()
condition|)
block|{
name|boolean
name|test
init|=
name|isVowel
argument_list|(
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
operator|(
name|search
index|[
name|i
index|]
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|test
operator|==
name|vowel
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
name|search
index|[
name|i
index|]
operator|.
name|length
argument_list|()
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
name|setStrings
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
return|return
name|found
return|;
block|}
comment|/** 	 * Delete a suffix searched in zone "source" if preceded by the prefix 	 * 	 * @param source java.lang.String - the primary source zone for search 	 * @param search java.lang.String[] - the strings to search for suppression 	 * @param prefix java.lang.String - the prefix to add to the search string to test 	 * @param without boolean - true if it will be deleted even without prefix found 	 */
DECL|method|deleteButSuffixFrom
specifier|private
name|void
name|deleteButSuffixFrom
parameter_list|(
name|String
name|source
parameter_list|,
name|String
index|[]
name|search
parameter_list|,
name|String
name|prefix
parameter_list|,
name|boolean
name|without
parameter_list|)
block|{
if|if
condition|(
name|source
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|search
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|source
operator|.
name|endsWith
argument_list|(
name|prefix
operator|+
name|search
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
operator|(
name|prefix
operator|.
name|length
argument_list|()
operator|+
name|search
index|[
name|i
index|]
operator|.
name|length
argument_list|()
operator|)
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
name|setStrings
argument_list|()
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|without
operator|&&
name|source
operator|.
name|endsWith
argument_list|(
name|search
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
name|search
index|[
name|i
index|]
operator|.
name|length
argument_list|()
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
name|setStrings
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/** 	 * Delete a suffix searched in zone "source" if preceded by prefix<br> 	 * or replace it with the replace string if preceded by the prefix in the zone "from"<br> 	 * or delete the suffix if specified 	 * 	 * @param source java.lang.String - the primary source zone for search 	 * @param search java.lang.String[] - the strings to search for suppression 	 * @param prefix java.lang.String - the prefix to add to the search string to test 	 * @param without boolean - true if it will be deleted even without prefix found 	 */
DECL|method|deleteButSuffixFromElseReplace
specifier|private
name|void
name|deleteButSuffixFromElseReplace
parameter_list|(
name|String
name|source
parameter_list|,
name|String
index|[]
name|search
parameter_list|,
name|String
name|prefix
parameter_list|,
name|boolean
name|without
parameter_list|,
name|String
name|from
parameter_list|,
name|String
name|replace
parameter_list|)
block|{
if|if
condition|(
name|source
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|search
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|source
operator|.
name|endsWith
argument_list|(
name|prefix
operator|+
name|search
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
operator|(
name|prefix
operator|.
name|length
argument_list|()
operator|+
name|search
index|[
name|i
index|]
operator|.
name|length
argument_list|()
operator|)
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
name|setStrings
argument_list|()
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|from
operator|!=
literal|null
operator|&&
name|from
operator|.
name|endsWith
argument_list|(
name|prefix
operator|+
name|search
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|sb
operator|.
name|replace
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
operator|(
name|prefix
operator|.
name|length
argument_list|()
operator|+
name|search
index|[
name|i
index|]
operator|.
name|length
argument_list|()
operator|)
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|,
name|replace
argument_list|)
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
name|setStrings
argument_list|()
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|without
operator|&&
name|source
operator|.
name|endsWith
argument_list|(
name|search
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
name|search
index|[
name|i
index|]
operator|.
name|length
argument_list|()
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
name|setStrings
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/** 	 * Replace a search string with another within the source zone 	 * 	 * @param source java.lang.String - the source zone for search 	 * @param search java.lang.String[] - the strings to search for replacement 	 * @param replace java.lang.String - the replacement string 	 */
DECL|method|replaceFrom
specifier|private
name|boolean
name|replaceFrom
parameter_list|(
name|String
name|source
parameter_list|,
name|String
index|[]
name|search
parameter_list|,
name|String
name|replace
parameter_list|)
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|source
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|search
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|source
operator|.
name|endsWith
argument_list|(
name|search
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|sb
operator|.
name|replace
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
name|search
index|[
name|i
index|]
operator|.
name|length
argument_list|()
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|,
name|replace
argument_list|)
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
name|setStrings
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|found
return|;
block|}
comment|/** 	 * Delete a search string within the source zone 	 * 	 * @param source the source zone for search 	 * @param suffix the strings to search for suppression 	 */
DECL|method|deleteFrom
specifier|private
name|void
name|deleteFrom
parameter_list|(
name|String
name|source
parameter_list|,
name|String
index|[]
name|suffix
parameter_list|)
block|{
if|if
condition|(
name|source
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|suffix
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|source
operator|.
name|endsWith
argument_list|(
name|suffix
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
name|suffix
index|[
name|i
index|]
operator|.
name|length
argument_list|()
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
name|setStrings
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/** 	 * Test if a char is a french vowel, including accentuated ones 	 * 	 * @param ch the char to test 	 * @return boolean - true if the char is a vowel 	 */
DECL|method|isVowel
specifier|private
name|boolean
name|isVowel
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'e'
case|:
case|case
literal|'i'
case|:
case|case
literal|'o'
case|:
case|case
literal|'u'
case|:
case|case
literal|'y'
case|:
case|case
literal|'Ã¢'
case|:
case|case
literal|'Ã '
case|:
case|case
literal|'Ã«'
case|:
case|case
literal|'Ã©'
case|:
case|case
literal|'Ãª'
case|:
case|case
literal|'Ã¨'
case|:
case|case
literal|'Ã¯'
case|:
case|case
literal|'Ã®'
case|:
case|case
literal|'Ã´'
case|:
case|case
literal|'Ã¼'
case|:
case|case
literal|'Ã¹'
case|:
case|case
literal|'Ã»'
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/** 	 * Retrieve the "R zone" (1 or 2 depending on the buffer) and return the corresponding string<br> 	 * "R is the region after the first non-vowel following a vowel 	 * or is the null region at the end of the word if there is no such non-vowel"<br> 	 * @param buffer java.lang.StringBuffer - the in buffer 	 * @return java.lang.String - the resulting string 	 */
DECL|method|retrieveR
specifier|private
name|String
name|retrieveR
parameter_list|(
name|StringBuffer
name|buffer
parameter_list|)
block|{
name|int
name|len
init|=
name|buffer
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|len
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|isVowel
argument_list|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
block|{
name|pos
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pos
operator|>
operator|-
literal|1
condition|)
block|{
name|int
name|consonne
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
name|pos
init|;
name|c
operator|<
name|len
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isVowel
argument_list|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
block|{
name|consonne
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|consonne
operator|>
operator|-
literal|1
operator|&&
operator|(
name|consonne
operator|+
literal|1
operator|)
operator|<
name|len
condition|)
return|return
name|buffer
operator|.
name|substring
argument_list|(
name|consonne
operator|+
literal|1
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
literal|null
return|;
block|}
else|else
return|return
literal|null
return|;
block|}
comment|/** 	 * Retrieve the "RV zone" from a buffer an return the corresponding string<br> 	 * "If the word begins with two vowels, RV is the region after the third letter, 	 * otherwise the region after the first vowel not at the beginning of the word, 	 * or the end of the word if these positions cannot be found."<br> 	 * @param buffer java.lang.StringBuffer - the in buffer 	 * @return java.lang.String - the resulting string 	 */
DECL|method|retrieveRV
specifier|private
name|String
name|retrieveRV
parameter_list|(
name|StringBuffer
name|buffer
parameter_list|)
block|{
name|int
name|len
init|=
name|buffer
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|buffer
operator|.
name|length
argument_list|()
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|isVowel
argument_list|(
name|buffer
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|isVowel
argument_list|(
name|buffer
operator|.
name|charAt
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|buffer
operator|.
name|substring
argument_list|(
literal|3
argument_list|,
name|len
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|1
init|;
name|c
operator|<
name|len
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|isVowel
argument_list|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
block|{
name|pos
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pos
operator|+
literal|1
operator|<
name|len
condition|)
return|return
name|buffer
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
literal|null
return|;
block|}
block|}
else|else
return|return
literal|null
return|;
block|}
comment|/** 	 * Turns u and i preceded AND followed by a vowel to UpperCase<br> 	 * Turns y preceded OR followed by a vowel to UpperCase<br> 	 * Turns u preceded by q to UpperCase<br>      *      * @param buffer java.util.StringBuffer - the buffer to treat      * @return java.util.StringBuffer - the treated buffer      */
DECL|method|treatVowels
specifier|private
name|StringBuffer
name|treatVowels
parameter_list|(
name|StringBuffer
name|buffer
parameter_list|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|buffer
operator|.
name|length
argument_list|()
condition|;
name|c
operator|++
control|)
block|{
name|char
name|ch
init|=
name|buffer
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
comment|// first char
block|{
if|if
condition|(
name|buffer
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'y'
operator|&&
name|isVowel
argument_list|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'Y'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|buffer
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
comment|// last char
block|{
if|if
condition|(
name|ch
operator|==
literal|'u'
operator|&&
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|-
literal|1
argument_list|)
operator|==
literal|'q'
condition|)
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'U'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'y'
operator|&&
name|isVowel
argument_list|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|-
literal|1
argument_list|)
argument_list|)
condition|)
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'Y'
argument_list|)
expr_stmt|;
block|}
else|else
comment|// other cases
block|{
if|if
condition|(
name|ch
operator|==
literal|'u'
condition|)
block|{
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|-
literal|1
argument_list|)
operator|==
literal|'q'
condition|)
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'U'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isVowel
argument_list|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|-
literal|1
argument_list|)
argument_list|)
operator|&&
name|isVowel
argument_list|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'U'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|isVowel
argument_list|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|-
literal|1
argument_list|)
argument_list|)
operator|&&
name|isVowel
argument_list|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'y'
condition|)
block|{
if|if
condition|(
name|isVowel
argument_list|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|-
literal|1
argument_list|)
argument_list|)
operator|||
name|isVowel
argument_list|(
name|buffer
operator|.
name|charAt
argument_list|(
name|c
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
name|buffer
operator|.
name|setCharAt
argument_list|(
name|c
argument_list|,
literal|'Y'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|buffer
return|;
block|}
comment|/**      * Checks a term if it can be processed correctly.      *      * @return boolean - true if, and only if, the given term consists in letters.      */
DECL|method|isStemmable
specifier|private
name|boolean
name|isStemmable
parameter_list|(
name|String
name|term
parameter_list|)
block|{
name|boolean
name|upper
init|=
literal|false
decl_stmt|;
name|int
name|first
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|term
operator|.
name|length
argument_list|()
condition|;
name|c
operator|++
control|)
block|{
comment|// Discard terms that contain non-letter characters.
if|if
condition|(
operator|!
name|Character
operator|.
name|isLetter
argument_list|(
name|term
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Discard terms that contain multiple uppercase letters.
if|if
condition|(
name|Character
operator|.
name|isUpperCase
argument_list|(
name|term
operator|.
name|charAt
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|upper
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// First encountered uppercase letter, set flag and save
comment|// position.
else|else
block|{
name|first
operator|=
name|c
expr_stmt|;
name|upper
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|// Discard the term if it contains a single uppercase letter that
comment|// is not starting the term.
if|if
condition|(
name|first
operator|>
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
end_class
end_unit
