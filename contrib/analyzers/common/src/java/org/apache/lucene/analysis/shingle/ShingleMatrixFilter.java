begin_unit
begin_package
DECL|package|org.apache.lucene.analysis.shingle
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|shingle
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Token
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|miscellaneous
operator|.
name|EmptyTokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|payloads
operator|.
name|PayloadHelper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|FlagsAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|OffsetAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|PayloadAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|PositionIncrementAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|TermAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|TypeAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Payload
import|;
end_import
begin_comment
comment|/**  *<p>A ShingleMatrixFilter constructs shingles (token n-grams) from a token stream.  * In other words, it creates combinations of tokens as a single token.  *  *<p>For example, the sentence "please divide this sentence into shingles"  * might be tokenized into shingles "please divide", "divide this",  * "this sentence", "sentence into", and "into shingles".  *  *<p>Using a shingle filter at index and query time can in some instances  * be used to replace phrase queries, especially them with 0 slop.  *  *<p>Without a spacer character  * it can be used to handle composition and decomposition of words  * such as searching for "multi dimensional" instead of "multidimensional".  * It is a rather common human problem at query time  * in several languages, notably the northern Germanic branch.  *  *<p>Shingles are amongst many things also known to solve problems  * in spell checking, language detection and document clustering.  *  *<p>This filter is backed by a three dimensional column oriented matrix  * used to create permutations of the second dimension, the rows,  * and leaves the third, the z-axis, for for multi token synonyms.  *  *<p>In order to use this filter you need to define a way of positioning  * the input stream tokens in the matrix. This is done using a  * {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.TokenSettingsCodec}.  * There are three simple implementations for demonstrational purposes,  * see {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.OneDimensionalNonWeightedTokenSettingsCodec},  * {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.TwoDimensionalNonWeightedSynonymTokenSettingsCodec}  * and {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.SimpleThreeDimensionalTokenSettingsCodec}.  *  *<p>Consider this token matrix:  *<pre>  *  Token[column][row][z-axis]{  *    {{hello}, {greetings, and, salutations}},  *    {{world}, {earth}, {tellus}}  *  };  *</pre>  *  * It would produce the following 2-3 gram sized shingles:  *  *<pre>  * "hello_world"  * "greetings_and"  * "greetings_and_salutations"  * "and_salutations"  * "and_salutations_world"  * "salutations_world"  * "hello_earth"  * "and_salutations_earth"  * "salutations_earth"  * "hello_tellus"  * "and_salutations_tellus"  * "salutations_tellus"  *</pre>  *  *<p>This implementation can be rather heap demanding  * if (maximum shingle size - minimum shingle size) is a great number and the stream contains many columns,  * or if each column contains a great number of rows.  *  *<p>The problem is that in order avoid producing duplicates  * the filter needs to keep track of any shingle already produced and returned to the consumer.  *  * There is a bit of resource management to handle this  * but it would of course be much better if the filter was written  * so it never created the same shingle more than once in the first place.  *  *<p>The filter also has basic support for calculating weights for the shingles  * based on the weights of the tokens from the input stream, output shingle size, etc.  * See {@link #calculateShingleWeight(org.apache.lucene.analysis.Token, java.util.List, int, java.util.List, java.util.List)}.  *<p/>  *<b>NOTE:</b> This filter might not behave correctly if used with custom Attributes, i.e. Attributes other than  * the ones located in org.apache.lucene.analysis.tokenattributes.  */
end_comment
begin_class
DECL|class|ShingleMatrixFilter
specifier|public
specifier|final
class|class
name|ShingleMatrixFilter
extends|extends
name|TokenStream
block|{
DECL|field|defaultSpacerCharacter
specifier|public
specifier|static
name|Character
name|defaultSpacerCharacter
init|=
operator|new
name|Character
argument_list|(
literal|'_'
argument_list|)
decl_stmt|;
DECL|field|defaultSettingsCodec
specifier|public
specifier|static
name|TokenSettingsCodec
name|defaultSettingsCodec
init|=
operator|new
name|OneDimensionalNonWeightedTokenSettingsCodec
argument_list|()
decl_stmt|;
DECL|field|ignoringSinglePrefixOrSuffixShingleByDefault
specifier|public
specifier|static
name|boolean
name|ignoringSinglePrefixOrSuffixShingleByDefault
init|=
literal|false
decl_stmt|;
comment|/**    * Strategy used to code and decode meta data of the tokens from the input stream    * regarding how to position the tokens in the matrix, set and retreive weight, et c.    */
DECL|class|TokenSettingsCodec
specifier|public
specifier|static
specifier|abstract
class|class
name|TokenSettingsCodec
block|{
comment|/**      * Retrieves information on how a {@link org.apache.lucene.analysis.Token} is to be inserted to a {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.Matrix}.      * @param token      * @return {@link ShingleMatrixFilter.TokenPositioner}      * @throws IOException      */
DECL|method|getTokenPositioner
specifier|public
specifier|abstract
name|TokenPositioner
name|getTokenPositioner
parameter_list|(
name|Token
name|token
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Sets information on how a {@link org.apache.lucene.analysis.Token} is to be inserted to a {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.Matrix}.      *      * @param token      * @param tokenPositioner      */
DECL|method|setTokenPositioner
specifier|public
specifier|abstract
name|void
name|setTokenPositioner
parameter_list|(
name|Token
name|token
parameter_list|,
name|ShingleMatrixFilter
operator|.
name|TokenPositioner
name|tokenPositioner
parameter_list|)
function_decl|;
comment|/**      * Have this method return 1f in order to 'disable' weights.      * @param token      * @return the weight of parameter token      */
DECL|method|getWeight
specifier|public
specifier|abstract
name|float
name|getWeight
parameter_list|(
name|Token
name|token
parameter_list|)
function_decl|;
comment|/**      * Have this method do nothing in order to 'disable' weights.      * @param token      * @param weight      */
DECL|method|setWeight
specifier|public
specifier|abstract
name|void
name|setWeight
parameter_list|(
name|Token
name|token
parameter_list|,
name|float
name|weight
parameter_list|)
function_decl|;
block|}
comment|/**    * Used to describe how a {@link org.apache.lucene.analysis.Token} is to be inserted to a {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter.Matrix}.    * @see org.apache.lucene.analysis.shingle.ShingleMatrixFilter.TokenSettingsCodec#getTokenPositioner(org.apache.lucene.analysis.Token)    * @see org.apache.lucene.analysis.shingle.ShingleMatrixFilter.TokenSettingsCodec#setTokenPositioner(org.apache.lucene.analysis.Token,org.apache.lucene.analysis.shingle.ShingleMatrixFilter.TokenPositioner)    */
DECL|class|TokenPositioner
specifier|public
specifier|static
class|class
name|TokenPositioner
block|{
DECL|field|newColumn
specifier|public
specifier|static
specifier|final
name|TokenPositioner
name|newColumn
init|=
operator|new
name|TokenPositioner
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|newRow
specifier|public
specifier|static
specifier|final
name|TokenPositioner
name|newRow
init|=
operator|new
name|TokenPositioner
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|field|sameRow
specifier|public
specifier|static
specifier|final
name|TokenPositioner
name|sameRow
init|=
operator|new
name|TokenPositioner
argument_list|(
literal|2
argument_list|)
decl_stmt|;
DECL|field|index
specifier|private
specifier|final
name|int
name|index
decl_stmt|;
DECL|method|TokenPositioner
specifier|private
name|TokenPositioner
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
block|}
DECL|method|getIndex
specifier|public
name|int
name|getIndex
parameter_list|()
block|{
return|return
name|index
return|;
block|}
block|}
comment|// filter instance settings variables
DECL|field|settingsCodec
specifier|private
name|TokenSettingsCodec
name|settingsCodec
decl_stmt|;
DECL|field|minimumShingleSize
specifier|private
name|int
name|minimumShingleSize
decl_stmt|;
DECL|field|maximumShingleSize
specifier|private
name|int
name|maximumShingleSize
decl_stmt|;
DECL|field|ignoringSinglePrefixOrSuffixShingle
specifier|private
name|boolean
name|ignoringSinglePrefixOrSuffixShingle
init|=
literal|false
decl_stmt|;
DECL|field|spacerCharacter
specifier|private
name|Character
name|spacerCharacter
init|=
name|defaultSpacerCharacter
decl_stmt|;
DECL|field|input
specifier|private
name|TokenStream
name|input
decl_stmt|;
DECL|field|termAtt
specifier|private
name|TermAttribute
name|termAtt
decl_stmt|;
DECL|field|posIncrAtt
specifier|private
name|PositionIncrementAttribute
name|posIncrAtt
decl_stmt|;
DECL|field|payloadAtt
specifier|private
name|PayloadAttribute
name|payloadAtt
decl_stmt|;
DECL|field|offsetAtt
specifier|private
name|OffsetAttribute
name|offsetAtt
decl_stmt|;
DECL|field|typeAtt
specifier|private
name|TypeAttribute
name|typeAtt
decl_stmt|;
DECL|field|flagsAtt
specifier|private
name|FlagsAttribute
name|flagsAtt
decl_stmt|;
DECL|field|in_termAtt
specifier|private
name|TermAttribute
name|in_termAtt
decl_stmt|;
DECL|field|in_posIncrAtt
specifier|private
name|PositionIncrementAttribute
name|in_posIncrAtt
decl_stmt|;
DECL|field|in_payloadAtt
specifier|private
name|PayloadAttribute
name|in_payloadAtt
decl_stmt|;
DECL|field|in_offsetAtt
specifier|private
name|OffsetAttribute
name|in_offsetAtt
decl_stmt|;
DECL|field|in_typeAtt
specifier|private
name|TypeAttribute
name|in_typeAtt
decl_stmt|;
DECL|field|in_flagsAtt
specifier|private
name|FlagsAttribute
name|in_flagsAtt
decl_stmt|;
comment|/**    * Creates a shingle filter based on a user defined matrix.    *    * The filter /will/ delete columns from the input matrix! You will not be able to reset the filter if you used this constructor.    * todo: don't touch the matrix! use a boolean, set the input stream to null or something, and keep track of where in the matrix we are at.    *    * @param matrix the input based for creating shingles. Does not need to contain any information until {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter#next(org.apache.lucene.analysis.Token)} is called the first time.    * @param minimumShingleSize minimum number of tokens in any shingle.    * @param maximumShingleSize maximum number of tokens in any shingle.    * @param spacerCharacter character to use between texts of the token parts in a shingle. null for none.    * @param ignoringSinglePrefixOrSuffixShingle if true, shingles that only contains permutation of the first of the last column will not be produced as shingles. Useful when adding boundary marker tokens such as '^' and '$'.    * @param settingsCodec codec used to read input token weight and matrix positioning.    */
DECL|method|ShingleMatrixFilter
specifier|public
name|ShingleMatrixFilter
parameter_list|(
name|Matrix
name|matrix
parameter_list|,
name|int
name|minimumShingleSize
parameter_list|,
name|int
name|maximumShingleSize
parameter_list|,
name|Character
name|spacerCharacter
parameter_list|,
name|boolean
name|ignoringSinglePrefixOrSuffixShingle
parameter_list|,
name|TokenSettingsCodec
name|settingsCodec
parameter_list|)
block|{
name|this
operator|.
name|matrix
operator|=
name|matrix
expr_stmt|;
name|this
operator|.
name|minimumShingleSize
operator|=
name|minimumShingleSize
expr_stmt|;
name|this
operator|.
name|maximumShingleSize
operator|=
name|maximumShingleSize
expr_stmt|;
name|this
operator|.
name|spacerCharacter
operator|=
name|spacerCharacter
expr_stmt|;
name|this
operator|.
name|ignoringSinglePrefixOrSuffixShingle
operator|=
name|ignoringSinglePrefixOrSuffixShingle
expr_stmt|;
name|this
operator|.
name|settingsCodec
operator|=
name|settingsCodec
expr_stmt|;
name|termAtt
operator|=
name|addAttribute
argument_list|(
name|TermAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|posIncrAtt
operator|=
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|payloadAtt
operator|=
name|addAttribute
argument_list|(
name|PayloadAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|offsetAtt
operator|=
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|typeAtt
operator|=
name|addAttribute
argument_list|(
name|TypeAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|flagsAtt
operator|=
name|addAttribute
argument_list|(
name|FlagsAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// set the input to be an empty token stream, we already have the data.
name|this
operator|.
name|input
operator|=
operator|new
name|EmptyTokenStream
argument_list|()
expr_stmt|;
name|in_termAtt
operator|=
name|input
operator|.
name|addAttribute
argument_list|(
name|TermAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|in_posIncrAtt
operator|=
name|input
operator|.
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|in_payloadAtt
operator|=
name|input
operator|.
name|addAttribute
argument_list|(
name|PayloadAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|in_offsetAtt
operator|=
name|input
operator|.
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|in_typeAtt
operator|=
name|input
operator|.
name|addAttribute
argument_list|(
name|TypeAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|in_flagsAtt
operator|=
name|input
operator|.
name|addAttribute
argument_list|(
name|FlagsAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a shingle filter using default settings.    *    * @see #defaultSpacerCharacter    * @see #ignoringSinglePrefixOrSuffixShingleByDefault    * @see #defaultSettingsCodec    *    * @param input stream from which to construct the matrix    * @param minimumShingleSize minimum number of tokens in any shingle.    * @param maximumShingleSize maximum number of tokens in any shingle.    */
DECL|method|ShingleMatrixFilter
specifier|public
name|ShingleMatrixFilter
parameter_list|(
name|TokenStream
name|input
parameter_list|,
name|int
name|minimumShingleSize
parameter_list|,
name|int
name|maximumShingleSize
parameter_list|)
block|{
name|this
argument_list|(
name|input
argument_list|,
name|minimumShingleSize
argument_list|,
name|maximumShingleSize
argument_list|,
name|defaultSpacerCharacter
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a shingle filter using default settings.    *    * @see #ignoringSinglePrefixOrSuffixShingleByDefault    * @see #defaultSettingsCodec    *    * @param input stream from which to construct the matrix    * @param minimumShingleSize minimum number of tokens in any shingle.    * @param maximumShingleSize maximum number of tokens in any shingle.    * @param spacerCharacter character to use between texts of the token parts in a shingle. null for none.    */
DECL|method|ShingleMatrixFilter
specifier|public
name|ShingleMatrixFilter
parameter_list|(
name|TokenStream
name|input
parameter_list|,
name|int
name|minimumShingleSize
parameter_list|,
name|int
name|maximumShingleSize
parameter_list|,
name|Character
name|spacerCharacter
parameter_list|)
block|{
name|this
argument_list|(
name|input
argument_list|,
name|minimumShingleSize
argument_list|,
name|maximumShingleSize
argument_list|,
name|spacerCharacter
argument_list|,
name|ignoringSinglePrefixOrSuffixShingleByDefault
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a shingle filter using the default {@link TokenSettingsCodec}.    *    * @see #defaultSettingsCodec    *    * @param input stream from which to construct the matrix    * @param minimumShingleSize minimum number of tokens in any shingle.    * @param maximumShingleSize maximum number of tokens in any shingle.    * @param spacerCharacter character to use between texts of the token parts in a shingle. null for none.    * @param ignoringSinglePrefixOrSuffixShingle if true, shingles that only contains permutation of the first of the last column will not be produced as shingles. Useful when adding boundary marker tokens such as '^' and '$'.    */
DECL|method|ShingleMatrixFilter
specifier|public
name|ShingleMatrixFilter
parameter_list|(
name|TokenStream
name|input
parameter_list|,
name|int
name|minimumShingleSize
parameter_list|,
name|int
name|maximumShingleSize
parameter_list|,
name|Character
name|spacerCharacter
parameter_list|,
name|boolean
name|ignoringSinglePrefixOrSuffixShingle
parameter_list|)
block|{
name|this
argument_list|(
name|input
argument_list|,
name|minimumShingleSize
argument_list|,
name|maximumShingleSize
argument_list|,
name|spacerCharacter
argument_list|,
name|ignoringSinglePrefixOrSuffixShingle
argument_list|,
name|defaultSettingsCodec
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a shingle filter with ad hoc parameter settings.    *    * @param input stream from which to construct the matrix    * @param minimumShingleSize minimum number of tokens in any shingle.    * @param maximumShingleSize maximum number of tokens in any shingle.    * @param spacerCharacter character to use between texts of the token parts in a shingle. null for none.    * @param ignoringSinglePrefixOrSuffixShingle if true, shingles that only contains permutation of the first of the last column will not be produced as shingles. Useful when adding boundary marker tokens such as '^' and '$'.    * @param settingsCodec codec used to read input token weight and matrix positioning.    */
DECL|method|ShingleMatrixFilter
specifier|public
name|ShingleMatrixFilter
parameter_list|(
name|TokenStream
name|input
parameter_list|,
name|int
name|minimumShingleSize
parameter_list|,
name|int
name|maximumShingleSize
parameter_list|,
name|Character
name|spacerCharacter
parameter_list|,
name|boolean
name|ignoringSinglePrefixOrSuffixShingle
parameter_list|,
name|TokenSettingsCodec
name|settingsCodec
parameter_list|)
block|{
name|this
operator|.
name|input
operator|=
name|input
expr_stmt|;
name|this
operator|.
name|minimumShingleSize
operator|=
name|minimumShingleSize
expr_stmt|;
name|this
operator|.
name|maximumShingleSize
operator|=
name|maximumShingleSize
expr_stmt|;
name|this
operator|.
name|spacerCharacter
operator|=
name|spacerCharacter
expr_stmt|;
name|this
operator|.
name|ignoringSinglePrefixOrSuffixShingle
operator|=
name|ignoringSinglePrefixOrSuffixShingle
expr_stmt|;
name|this
operator|.
name|settingsCodec
operator|=
name|settingsCodec
expr_stmt|;
name|termAtt
operator|=
name|addAttribute
argument_list|(
name|TermAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|posIncrAtt
operator|=
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|payloadAtt
operator|=
name|addAttribute
argument_list|(
name|PayloadAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|offsetAtt
operator|=
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|typeAtt
operator|=
name|addAttribute
argument_list|(
name|TypeAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|flagsAtt
operator|=
name|addAttribute
argument_list|(
name|FlagsAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|in_termAtt
operator|=
name|input
operator|.
name|addAttribute
argument_list|(
name|TermAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|in_posIncrAtt
operator|=
name|input
operator|.
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|in_payloadAtt
operator|=
name|input
operator|.
name|addAttribute
argument_list|(
name|PayloadAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|in_offsetAtt
operator|=
name|input
operator|.
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|in_typeAtt
operator|=
name|input
operator|.
name|addAttribute
argument_list|(
name|TypeAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
name|in_flagsAtt
operator|=
name|input
operator|.
name|addAttribute
argument_list|(
name|FlagsAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|// internal filter instance variables
comment|/** iterator over the current matrix row permutations */
DECL|field|permutations
specifier|private
name|Iterator
argument_list|<
name|Matrix
operator|.
name|Column
operator|.
name|Row
index|[]
argument_list|>
name|permutations
decl_stmt|;
comment|/** the current permutation of tokens used to produce shingles */
DECL|field|currentPermuationTokens
specifier|private
name|List
argument_list|<
name|Token
argument_list|>
name|currentPermuationTokens
decl_stmt|;
comment|/** index to what row a token in currentShingleTokens represents*/
DECL|field|currentPermutationRows
specifier|private
name|List
argument_list|<
name|Matrix
operator|.
name|Column
operator|.
name|Row
argument_list|>
name|currentPermutationRows
decl_stmt|;
DECL|field|currentPermutationTokensStartOffset
specifier|private
name|int
name|currentPermutationTokensStartOffset
decl_stmt|;
DECL|field|currentShingleLength
specifier|private
name|int
name|currentShingleLength
decl_stmt|;
comment|/**    * a set containing shingles that has been the result of a call to next(Token),    * used to avoid producing the same shingle more than once.    */
DECL|field|shinglesSeen
specifier|private
name|Set
argument_list|<
name|List
argument_list|<
name|Token
argument_list|>
argument_list|>
name|shinglesSeen
init|=
operator|new
name|HashSet
argument_list|<
name|List
argument_list|<
name|Token
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
name|permutations
operator|=
literal|null
expr_stmt|;
name|shinglesSeen
operator|.
name|clear
argument_list|()
expr_stmt|;
name|input
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
DECL|field|matrix
specifier|private
name|Matrix
name|matrix
decl_stmt|;
DECL|field|reusableToken
specifier|private
name|Token
name|reusableToken
init|=
operator|new
name|Token
argument_list|()
decl_stmt|;
DECL|method|incrementToken
specifier|public
specifier|final
name|boolean
name|incrementToken
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|matrix
operator|==
literal|null
condition|)
block|{
name|matrix
operator|=
operator|new
name|Matrix
argument_list|()
expr_stmt|;
comment|// fill matrix with maximumShingleSize columns
while|while
condition|(
name|matrix
operator|.
name|columns
operator|.
name|size
argument_list|()
operator|<
name|maximumShingleSize
operator|&&
name|readColumn
argument_list|()
condition|)
block|{
comment|// this loop looks ugly
block|}
block|}
comment|// this loop exists in order to avoid recursive calls to the next method
comment|// as the complexity of a large matrix
comment|// then would require a multi gigabyte sized stack.
name|Token
name|token
decl_stmt|;
do|do
block|{
name|token
operator|=
name|produceNextToken
argument_list|(
name|reusableToken
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|request_next_token
condition|)
do|;
if|if
condition|(
name|token
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|termAtt
operator|.
name|setTermBuffer
argument_list|(
name|token
operator|.
name|termBuffer
argument_list|()
argument_list|,
literal|0
argument_list|,
name|token
operator|.
name|termLength
argument_list|()
argument_list|)
expr_stmt|;
name|posIncrAtt
operator|.
name|setPositionIncrement
argument_list|(
name|token
operator|.
name|getPositionIncrement
argument_list|()
argument_list|)
expr_stmt|;
name|flagsAtt
operator|.
name|setFlags
argument_list|(
name|token
operator|.
name|getFlags
argument_list|()
argument_list|)
expr_stmt|;
name|offsetAtt
operator|.
name|setOffset
argument_list|(
name|token
operator|.
name|startOffset
argument_list|()
argument_list|,
name|token
operator|.
name|endOffset
argument_list|()
argument_list|)
expr_stmt|;
name|typeAtt
operator|.
name|setType
argument_list|(
name|token
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
name|payloadAtt
operator|.
name|setPayload
argument_list|(
name|token
operator|.
name|getPayload
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|getNextInputToken
specifier|private
name|Token
name|getNextInputToken
parameter_list|(
name|Token
name|token
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|input
operator|.
name|incrementToken
argument_list|()
condition|)
return|return
literal|null
return|;
name|token
operator|.
name|setTermBuffer
argument_list|(
name|in_termAtt
operator|.
name|termBuffer
argument_list|()
argument_list|,
literal|0
argument_list|,
name|in_termAtt
operator|.
name|termLength
argument_list|()
argument_list|)
expr_stmt|;
name|token
operator|.
name|setPositionIncrement
argument_list|(
name|in_posIncrAtt
operator|.
name|getPositionIncrement
argument_list|()
argument_list|)
expr_stmt|;
name|token
operator|.
name|setFlags
argument_list|(
name|in_flagsAtt
operator|.
name|getFlags
argument_list|()
argument_list|)
expr_stmt|;
name|token
operator|.
name|setOffset
argument_list|(
name|in_offsetAtt
operator|.
name|startOffset
argument_list|()
argument_list|,
name|in_offsetAtt
operator|.
name|endOffset
argument_list|()
argument_list|)
expr_stmt|;
name|token
operator|.
name|setType
argument_list|(
name|in_typeAtt
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
name|token
operator|.
name|setPayload
argument_list|(
name|in_payloadAtt
operator|.
name|getPayload
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
DECL|method|getNextToken
specifier|private
name|Token
name|getNextToken
parameter_list|(
name|Token
name|token
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|incrementToken
argument_list|()
condition|)
return|return
literal|null
return|;
name|token
operator|.
name|setTermBuffer
argument_list|(
name|termAtt
operator|.
name|termBuffer
argument_list|()
argument_list|,
literal|0
argument_list|,
name|termAtt
operator|.
name|termLength
argument_list|()
argument_list|)
expr_stmt|;
name|token
operator|.
name|setPositionIncrement
argument_list|(
name|posIncrAtt
operator|.
name|getPositionIncrement
argument_list|()
argument_list|)
expr_stmt|;
name|token
operator|.
name|setFlags
argument_list|(
name|flagsAtt
operator|.
name|getFlags
argument_list|()
argument_list|)
expr_stmt|;
name|token
operator|.
name|setOffset
argument_list|(
name|offsetAtt
operator|.
name|startOffset
argument_list|()
argument_list|,
name|offsetAtt
operator|.
name|endOffset
argument_list|()
argument_list|)
expr_stmt|;
name|token
operator|.
name|setType
argument_list|(
name|typeAtt
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
name|token
operator|.
name|setPayload
argument_list|(
name|payloadAtt
operator|.
name|getPayload
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
DECL|field|request_next_token
specifier|private
specifier|static
specifier|final
name|Token
name|request_next_token
init|=
operator|new
name|Token
argument_list|()
decl_stmt|;
comment|/**    * This method exists in order to avoid recursive calls to the method    * as the complexity of a fairly small matrix then easily would require    * a gigabyte sized stack per thread.    *    * @param reusableToken    * @return null if exhausted, instance request_next_token if one more call is required for an answer, or instance parameter resuableToken.    * @throws IOException    */
DECL|method|produceNextToken
specifier|private
name|Token
name|produceNextToken
parameter_list|(
specifier|final
name|Token
name|reusableToken
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentPermuationTokens
operator|!=
literal|null
condition|)
block|{
name|currentShingleLength
operator|++
expr_stmt|;
if|if
condition|(
name|currentShingleLength
operator|+
name|currentPermutationTokensStartOffset
operator|<=
name|currentPermuationTokens
operator|.
name|size
argument_list|()
operator|&&
name|currentShingleLength
operator|<=
name|maximumShingleSize
condition|)
block|{
comment|// it is possible to create at least one more shingle of the current matrix permutation
if|if
condition|(
name|ignoringSinglePrefixOrSuffixShingle
operator|&&
name|currentShingleLength
operator|==
literal|1
operator|&&
operator|(
operator|(
name|currentPermutationRows
operator|.
name|get
argument_list|(
name|currentPermutationTokensStartOffset
argument_list|)
operator|)
operator|.
name|getColumn
argument_list|()
operator|.
name|isFirst
argument_list|()
operator|||
operator|(
name|currentPermutationRows
operator|.
name|get
argument_list|(
name|currentPermutationTokensStartOffset
argument_list|)
operator|)
operator|.
name|getColumn
argument_list|()
operator|.
name|isLast
argument_list|()
operator|)
condition|)
block|{
return|return
name|getNextToken
argument_list|(
name|reusableToken
argument_list|)
return|;
block|}
name|int
name|termLength
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|Token
argument_list|>
name|shingle
init|=
operator|new
name|ArrayList
argument_list|<
name|Token
argument_list|>
argument_list|(
name|currentShingleLength
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|currentShingleLength
condition|;
name|i
operator|++
control|)
block|{
name|Token
name|shingleToken
init|=
name|currentPermuationTokens
operator|.
name|get
argument_list|(
name|i
operator|+
name|currentPermutationTokensStartOffset
argument_list|)
decl_stmt|;
name|termLength
operator|+=
name|shingleToken
operator|.
name|termLength
argument_list|()
expr_stmt|;
name|shingle
operator|.
name|add
argument_list|(
name|shingleToken
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spacerCharacter
operator|!=
literal|null
condition|)
block|{
name|termLength
operator|+=
name|currentShingleLength
operator|-
literal|1
expr_stmt|;
block|}
comment|// only produce shingles that not already has been created
if|if
condition|(
operator|!
name|shinglesSeen
operator|.
name|add
argument_list|(
name|shingle
argument_list|)
condition|)
block|{
return|return
name|request_next_token
return|;
block|}
comment|// shingle token factory
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|termLength
operator|+
literal|10
argument_list|)
decl_stmt|;
comment|// paranormal ability to foresee the future.
for|for
control|(
name|Token
name|shingleToken
range|:
name|shingle
control|)
block|{
if|if
condition|(
name|spacerCharacter
operator|!=
literal|null
operator|&&
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|spacerCharacter
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|shingleToken
operator|.
name|termBuffer
argument_list|()
argument_list|,
literal|0
argument_list|,
name|shingleToken
operator|.
name|termLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|reusableToken
operator|.
name|setTermBuffer
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|updateToken
argument_list|(
name|reusableToken
argument_list|,
name|shingle
argument_list|,
name|currentPermutationTokensStartOffset
argument_list|,
name|currentPermutationRows
argument_list|,
name|currentPermuationTokens
argument_list|)
expr_stmt|;
return|return
name|reusableToken
return|;
block|}
else|else
block|{
comment|// it is NOT possible to create one more shingles of the current matrix permutation
if|if
condition|(
name|currentPermutationTokensStartOffset
operator|<
name|currentPermuationTokens
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
comment|// reset shingle size and move one step to the right in the current tokens permutation
name|currentPermutationTokensStartOffset
operator|++
expr_stmt|;
name|currentShingleLength
operator|=
name|minimumShingleSize
operator|-
literal|1
expr_stmt|;
return|return
name|request_next_token
return|;
block|}
if|if
condition|(
name|permutations
operator|==
literal|null
condition|)
block|{
comment|// todo does this ever occur?
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|permutations
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// load more data (if available) to the matrix
if|if
condition|(
name|input
operator|!=
literal|null
operator|&&
name|readColumn
argument_list|()
condition|)
block|{
comment|// don't really care, we just read it.
block|}
comment|// get rid of resources
comment|// delete the first column in the matrix
name|Matrix
operator|.
name|Column
name|deletedColumn
init|=
name|matrix
operator|.
name|columns
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// remove all shingles seen that include any of the tokens from the deleted column.
name|List
argument_list|<
name|Token
argument_list|>
name|deletedColumnTokens
init|=
operator|new
name|ArrayList
argument_list|<
name|Token
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Matrix
operator|.
name|Column
operator|.
name|Row
name|row
range|:
name|deletedColumn
operator|.
name|getRows
argument_list|()
control|)
block|{
for|for
control|(
name|Token
name|token
range|:
name|row
operator|.
name|getTokens
argument_list|()
control|)
block|{
name|deletedColumnTokens
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Iterator
argument_list|<
name|List
argument_list|<
name|Token
argument_list|>
argument_list|>
name|shinglesSeenIterator
init|=
name|shinglesSeen
operator|.
name|iterator
argument_list|()
init|;
name|shinglesSeenIterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|List
argument_list|<
name|Token
argument_list|>
name|shingle
init|=
name|shinglesSeenIterator
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Token
name|deletedColumnToken
range|:
name|deletedColumnTokens
control|)
block|{
if|if
condition|(
name|shingle
operator|.
name|contains
argument_list|(
name|deletedColumnToken
argument_list|)
condition|)
block|{
name|shinglesSeenIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|matrix
operator|.
name|columns
operator|.
name|size
argument_list|()
operator|<
name|minimumShingleSize
condition|)
block|{
comment|// exhausted
return|return
literal|null
return|;
block|}
comment|// create permutations of the matrix it now looks
name|permutations
operator|=
name|matrix
operator|.
name|permutationIterator
argument_list|()
expr_stmt|;
block|}
name|nextTokensPermutation
argument_list|()
expr_stmt|;
return|return
name|request_next_token
return|;
block|}
block|}
if|if
condition|(
name|permutations
operator|==
literal|null
condition|)
block|{
name|permutations
operator|=
name|matrix
operator|.
name|permutationIterator
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|permutations
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|nextTokensPermutation
argument_list|()
expr_stmt|;
return|return
name|request_next_token
return|;
block|}
comment|/**    * get next permutation of row combinations,    * creates list of all tokens in the row and    * an index from each such token to what row they exist in.    * finally resets the current (next) shingle size and offset.    */
DECL|method|nextTokensPermutation
specifier|private
name|void
name|nextTokensPermutation
parameter_list|()
block|{
name|Matrix
operator|.
name|Column
operator|.
name|Row
index|[]
name|rowsPermutation
init|=
name|permutations
operator|.
name|next
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Matrix
operator|.
name|Column
operator|.
name|Row
argument_list|>
name|currentPermutationRows
init|=
operator|new
name|ArrayList
argument_list|<
name|Matrix
operator|.
name|Column
operator|.
name|Row
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Token
argument_list|>
name|currentPermuationTokens
init|=
operator|new
name|ArrayList
argument_list|<
name|Token
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Matrix
operator|.
name|Column
operator|.
name|Row
name|row
range|:
name|rowsPermutation
control|)
block|{
for|for
control|(
name|Token
name|token
range|:
name|row
operator|.
name|getTokens
argument_list|()
control|)
block|{
name|currentPermuationTokens
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|currentPermutationRows
operator|.
name|add
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|currentPermuationTokens
operator|=
name|currentPermuationTokens
expr_stmt|;
name|this
operator|.
name|currentPermutationRows
operator|=
name|currentPermutationRows
expr_stmt|;
name|currentPermutationTokensStartOffset
operator|=
literal|0
expr_stmt|;
name|currentShingleLength
operator|=
name|minimumShingleSize
operator|-
literal|1
expr_stmt|;
block|}
comment|/**    * Final touch of a shingle token before it is passed on to the consumer from method {@link #next(org.apache.lucene.analysis.Token)}.    *    * Calculates and sets type, flags, position increment, start/end offsets and weight.    *    * @param token Shingle token    * @param shingle Tokens used to produce the shingle token.    * @param currentPermutationStartOffset Start offset in parameter currentPermutationTokens    * @param currentPermutationRows index to Matrix.Column.Row from the position of tokens in parameter currentPermutationTokens    * @param currentPermuationTokens tokens of the current permutation of rows in the matrix.    */
DECL|method|updateToken
specifier|public
name|void
name|updateToken
parameter_list|(
name|Token
name|token
parameter_list|,
name|List
name|shingle
parameter_list|,
name|int
name|currentPermutationStartOffset
parameter_list|,
name|List
name|currentPermutationRows
parameter_list|,
name|List
name|currentPermuationTokens
parameter_list|)
block|{
name|token
operator|.
name|setType
argument_list|(
name|ShingleMatrixFilter
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|token
operator|.
name|setFlags
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|token
operator|.
name|setPositionIncrement
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|token
operator|.
name|setStartOffset
argument_list|(
operator|(
operator|(
name|Token
operator|)
name|shingle
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|startOffset
argument_list|()
argument_list|)
expr_stmt|;
name|token
operator|.
name|setEndOffset
argument_list|(
operator|(
operator|(
name|Token
operator|)
name|shingle
operator|.
name|get
argument_list|(
name|shingle
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|)
operator|.
name|endOffset
argument_list|()
argument_list|)
expr_stmt|;
name|settingsCodec
operator|.
name|setWeight
argument_list|(
name|token
argument_list|,
name|calculateShingleWeight
argument_list|(
name|token
argument_list|,
name|shingle
argument_list|,
name|currentPermutationStartOffset
argument_list|,
name|currentPermutationRows
argument_list|,
name|currentPermuationTokens
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Evaluates the new shingle token weight.    *    * for (shingle part token in shingle)    * weight +=  shingle part token weight * (1 / sqrt(all shingle part token weights summed))    *    * This algorithm gives a slightly greater score for longer shingles    * and is rather penalising to great shingle token part weights.    *    * @param shingleToken token returned to consumer    * @param shingle tokens the tokens used to produce the shingle token.    * @param currentPermutationStartOffset start offset in parameter currentPermutationRows and currentPermutationTokens.    * @param currentPermutationRows an index to what matrix row a token in parameter currentPermutationTokens exist.    * @param currentPermuationTokens all tokens in the current row permutation of the matrix. A sub list (parameter offset, parameter shingle.size) equals parameter shingle.    * @return weight to be set for parameter shingleToken    */
DECL|method|calculateShingleWeight
specifier|public
name|float
name|calculateShingleWeight
parameter_list|(
name|Token
name|shingleToken
parameter_list|,
name|List
name|shingle
parameter_list|,
name|int
name|currentPermutationStartOffset
parameter_list|,
name|List
name|currentPermutationRows
parameter_list|,
name|List
name|currentPermuationTokens
parameter_list|)
block|{
name|double
index|[]
name|weights
init|=
operator|new
name|double
index|[
name|shingle
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|double
name|total
init|=
literal|0f
decl_stmt|;
name|double
name|top
init|=
literal|0d
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|weights
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|weights
index|[
name|i
index|]
operator|=
name|settingsCodec
operator|.
name|getWeight
argument_list|(
operator|(
name|Token
operator|)
name|shingle
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|double
name|tmp
init|=
name|weights
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|tmp
operator|>
name|top
condition|)
block|{
name|top
operator|=
name|tmp
expr_stmt|;
block|}
name|total
operator|+=
name|tmp
expr_stmt|;
block|}
name|double
name|factor
init|=
literal|1d
operator|/
name|Math
operator|.
name|sqrt
argument_list|(
name|total
argument_list|)
decl_stmt|;
name|double
name|weight
init|=
literal|0d
decl_stmt|;
for|for
control|(
name|double
name|partWeight
range|:
name|weights
control|)
block|{
name|weight
operator|+=
name|partWeight
operator|*
name|factor
expr_stmt|;
block|}
return|return
operator|(
name|float
operator|)
name|weight
return|;
block|}
DECL|field|readColumnBuf
specifier|private
name|Token
name|readColumnBuf
decl_stmt|;
comment|/**    * Loads one column from the token stream.    *    * When the last token is read from the token stream it will column.setLast(true);    *    * @return true if it manage to read one more column from the input token stream    * @throws IOException if the matrix source input stream throws an exception    */
DECL|method|readColumn
specifier|private
name|boolean
name|readColumn
parameter_list|()
throws|throws
name|IOException
block|{
name|Token
name|token
decl_stmt|;
if|if
condition|(
name|readColumnBuf
operator|!=
literal|null
condition|)
block|{
name|token
operator|=
name|readColumnBuf
expr_stmt|;
name|readColumnBuf
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|token
operator|=
name|getNextInputToken
argument_list|(
operator|new
name|Token
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Matrix
operator|.
name|Column
name|currentReaderColumn
init|=
name|matrix
operator|.
expr|new
name|Column
argument_list|()
decl_stmt|;
name|Matrix
operator|.
name|Column
operator|.
name|Row
name|currentReaderRow
init|=
name|currentReaderColumn
operator|.
expr|new
name|Row
argument_list|()
decl_stmt|;
name|currentReaderRow
operator|.
name|getTokens
argument_list|()
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|TokenPositioner
name|tokenPositioner
decl_stmt|;
while|while
condition|(
operator|(
name|readColumnBuf
operator|=
name|getNextInputToken
argument_list|(
operator|new
name|Token
argument_list|()
argument_list|)
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|tokenPositioner
operator|=
name|settingsCodec
operator|.
name|getTokenPositioner
argument_list|(
name|readColumnBuf
argument_list|)
operator|)
operator|!=
name|TokenPositioner
operator|.
name|newColumn
condition|)
block|{
if|if
condition|(
name|tokenPositioner
operator|==
name|TokenPositioner
operator|.
name|sameRow
condition|)
block|{
name|currentReaderRow
operator|.
name|getTokens
argument_list|()
operator|.
name|add
argument_list|(
name|readColumnBuf
argument_list|)
expr_stmt|;
block|}
else|else
comment|/*if (tokenPositioner == TokenPositioner.newRow)*/
block|{
name|currentReaderRow
operator|=
name|currentReaderColumn
operator|.
expr|new
name|Row
argument_list|()
expr_stmt|;
name|currentReaderRow
operator|.
name|getTokens
argument_list|()
operator|.
name|add
argument_list|(
name|readColumnBuf
argument_list|)
expr_stmt|;
block|}
name|readColumnBuf
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|readColumnBuf
operator|==
literal|null
condition|)
block|{
name|readColumnBuf
operator|=
name|getNextInputToken
argument_list|(
operator|new
name|Token
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|readColumnBuf
operator|==
literal|null
condition|)
block|{
name|currentReaderColumn
operator|.
name|setLast
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * A column focused matrix in three dimensions:    *    *<pre>    * Token[column][row][z-axis] {    *     {{hello}, {greetings, and, salutations}},    *     {{world}, {earth}, {tellus}}    * };    *</pre>    *    * todo consider row groups    * to indicate that shingles is only to contain permutations with texts in that same row group.    *    */
DECL|class|Matrix
specifier|public
specifier|static
class|class
name|Matrix
block|{
DECL|field|columnsHasBeenCreated
specifier|private
name|boolean
name|columnsHasBeenCreated
init|=
literal|false
decl_stmt|;
DECL|field|columns
specifier|private
name|List
argument_list|<
name|Column
argument_list|>
name|columns
init|=
operator|new
name|ArrayList
argument_list|<
name|Column
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|getColumns
specifier|public
name|List
name|getColumns
parameter_list|()
block|{
return|return
name|columns
return|;
block|}
DECL|class|Column
specifier|public
class|class
name|Column
block|{
DECL|field|last
specifier|private
name|boolean
name|last
decl_stmt|;
DECL|field|first
specifier|private
name|boolean
name|first
decl_stmt|;
DECL|method|getMatrix
specifier|public
name|Matrix
name|getMatrix
parameter_list|()
block|{
return|return
name|Matrix
operator|.
name|this
return|;
block|}
DECL|method|Column
specifier|public
name|Column
parameter_list|(
name|Token
name|token
parameter_list|)
block|{
name|this
argument_list|()
expr_stmt|;
name|Row
name|row
init|=
operator|new
name|Row
argument_list|()
decl_stmt|;
name|row
operator|.
name|getTokens
argument_list|()
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
DECL|method|Column
specifier|public
name|Column
parameter_list|()
block|{
synchronized|synchronized
init|(
name|Matrix
operator|.
name|this
init|)
block|{
if|if
condition|(
operator|!
name|columnsHasBeenCreated
condition|)
block|{
name|this
operator|.
name|setFirst
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|columnsHasBeenCreated
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|Matrix
operator|.
name|this
operator|.
name|columns
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|field|rows
specifier|private
name|List
argument_list|<
name|Row
argument_list|>
name|rows
init|=
operator|new
name|ArrayList
argument_list|<
name|Row
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|getRows
specifier|public
name|List
argument_list|<
name|Row
argument_list|>
name|getRows
parameter_list|()
block|{
return|return
name|rows
return|;
block|}
DECL|method|getIndex
specifier|public
name|int
name|getIndex
parameter_list|()
block|{
return|return
name|Matrix
operator|.
name|this
operator|.
name|columns
operator|.
name|indexOf
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Column{"
operator|+
literal|"first="
operator|+
name|first
operator|+
literal|", last="
operator|+
name|last
operator|+
literal|", rows="
operator|+
name|rows
operator|+
literal|'}'
return|;
block|}
DECL|method|isFirst
specifier|public
name|boolean
name|isFirst
parameter_list|()
block|{
return|return
name|first
return|;
block|}
DECL|method|setFirst
specifier|public
name|void
name|setFirst
parameter_list|(
name|boolean
name|first
parameter_list|)
block|{
name|this
operator|.
name|first
operator|=
name|first
expr_stmt|;
block|}
DECL|method|setLast
specifier|public
name|void
name|setLast
parameter_list|(
name|boolean
name|last
parameter_list|)
block|{
name|this
operator|.
name|last
operator|=
name|last
expr_stmt|;
block|}
DECL|method|isLast
specifier|public
name|boolean
name|isLast
parameter_list|()
block|{
return|return
name|last
return|;
block|}
DECL|class|Row
specifier|public
class|class
name|Row
block|{
DECL|method|getColumn
specifier|public
name|Column
name|getColumn
parameter_list|()
block|{
return|return
name|Column
operator|.
name|this
return|;
block|}
DECL|field|tokens
specifier|private
name|List
argument_list|<
name|Token
argument_list|>
name|tokens
init|=
operator|new
name|LinkedList
argument_list|<
name|Token
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|Row
specifier|public
name|Row
parameter_list|()
block|{
name|Column
operator|.
name|this
operator|.
name|rows
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|getIndex
specifier|public
name|int
name|getIndex
parameter_list|()
block|{
return|return
name|Column
operator|.
name|this
operator|.
name|rows
operator|.
name|indexOf
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|method|getTokens
specifier|public
name|List
argument_list|<
name|Token
argument_list|>
name|getTokens
parameter_list|()
block|{
return|return
name|tokens
return|;
block|}
DECL|method|setTokens
specifier|public
name|void
name|setTokens
parameter_list|(
name|List
argument_list|<
name|Token
argument_list|>
name|tokens
parameter_list|)
block|{
name|this
operator|.
name|tokens
operator|=
name|tokens
expr_stmt|;
block|}
comment|//        public int getStartOffset() {
comment|//          int ret = tokens[0].startOffset();
comment|//          if (getIndex()> 0&& ret == 0) {
comment|//            ret = Column.this.rows.get(0).getStartOffset();
comment|//          }
comment|//          return ret;
comment|//        }
comment|//
comment|//        public int getEndOffset() {
comment|//          int ret = tokens[tokens.length - 1].endOffset();
comment|//          if (getIndex()> 0&& ret == 0) {
comment|//            ret = Column.this.rows.get(0).getEndOffset();
comment|//          }
comment|//          return ret;
comment|//        }
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Row{"
operator|+
literal|"index="
operator|+
name|getIndex
argument_list|()
operator|+
literal|", tokens="
operator|+
operator|(
name|tokens
operator|==
literal|null
condition|?
literal|null
else|:
name|tokens
operator|)
operator|+
literal|'}'
return|;
block|}
block|}
block|}
DECL|method|permutationIterator
specifier|public
name|Iterator
argument_list|<
name|Column
operator|.
name|Row
index|[]
argument_list|>
name|permutationIterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Column
operator|.
name|Row
index|[]
argument_list|>
argument_list|()
block|{
specifier|private
name|int
index|[]
name|columnRowCounters
init|=
operator|new
name|int
index|[
name|columns
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"not implemented"
argument_list|)
throw|;
block|}
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
name|int
name|s
init|=
name|columnRowCounters
operator|.
name|length
decl_stmt|;
name|int
name|n
init|=
name|columns
operator|.
name|size
argument_list|()
decl_stmt|;
return|return
name|s
operator|!=
literal|0
operator|&&
name|n
operator|>=
name|s
operator|&&
name|columnRowCounters
index|[
name|s
operator|-
literal|1
index|]
operator|<
operator|(
name|columns
operator|.
name|get
argument_list|(
name|s
operator|-
literal|1
argument_list|)
operator|)
operator|.
name|getRows
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|Column
operator|.
name|Row
index|[]
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"no more elements"
argument_list|)
throw|;
block|}
name|Column
operator|.
name|Row
index|[]
name|rows
init|=
operator|new
name|Column
operator|.
name|Row
index|[
name|columnRowCounters
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnRowCounters
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|rows
index|[
name|i
index|]
operator|=
name|columns
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|rows
operator|.
name|get
argument_list|(
name|columnRowCounters
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|incrementColumnRowCounters
argument_list|()
expr_stmt|;
return|return
name|rows
return|;
block|}
specifier|private
name|void
name|incrementColumnRowCounters
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnRowCounters
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|columnRowCounters
index|[
name|i
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|columnRowCounters
index|[
name|i
index|]
operator|==
name|columns
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|rows
operator|.
name|size
argument_list|()
operator|&&
name|i
operator|<
name|columnRowCounters
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|columnRowCounters
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
block|}
return|;
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Matrix{"
operator|+
literal|"columns="
operator|+
name|columns
operator|+
literal|'}'
return|;
block|}
block|}
DECL|method|getMinimumShingleSize
specifier|public
name|int
name|getMinimumShingleSize
parameter_list|()
block|{
return|return
name|minimumShingleSize
return|;
block|}
DECL|method|setMinimumShingleSize
specifier|public
name|void
name|setMinimumShingleSize
parameter_list|(
name|int
name|minimumShingleSize
parameter_list|)
block|{
name|this
operator|.
name|minimumShingleSize
operator|=
name|minimumShingleSize
expr_stmt|;
block|}
DECL|method|getMaximumShingleSize
specifier|public
name|int
name|getMaximumShingleSize
parameter_list|()
block|{
return|return
name|maximumShingleSize
return|;
block|}
DECL|method|setMaximumShingleSize
specifier|public
name|void
name|setMaximumShingleSize
parameter_list|(
name|int
name|maximumShingleSize
parameter_list|)
block|{
name|this
operator|.
name|maximumShingleSize
operator|=
name|maximumShingleSize
expr_stmt|;
block|}
DECL|method|getMatrix
specifier|public
name|Matrix
name|getMatrix
parameter_list|()
block|{
return|return
name|matrix
return|;
block|}
DECL|method|setMatrix
specifier|public
name|void
name|setMatrix
parameter_list|(
name|Matrix
name|matrix
parameter_list|)
block|{
name|this
operator|.
name|matrix
operator|=
name|matrix
expr_stmt|;
block|}
DECL|method|getSpacerCharacter
specifier|public
name|Character
name|getSpacerCharacter
parameter_list|()
block|{
return|return
name|spacerCharacter
return|;
block|}
DECL|method|setSpacerCharacter
specifier|public
name|void
name|setSpacerCharacter
parameter_list|(
name|Character
name|spacerCharacter
parameter_list|)
block|{
name|this
operator|.
name|spacerCharacter
operator|=
name|spacerCharacter
expr_stmt|;
block|}
DECL|method|isIgnoringSinglePrefixOrSuffixShingle
specifier|public
name|boolean
name|isIgnoringSinglePrefixOrSuffixShingle
parameter_list|()
block|{
return|return
name|ignoringSinglePrefixOrSuffixShingle
return|;
block|}
DECL|method|setIgnoringSinglePrefixOrSuffixShingle
specifier|public
name|void
name|setIgnoringSinglePrefixOrSuffixShingle
parameter_list|(
name|boolean
name|ignoringSinglePrefixOrSuffixShingle
parameter_list|)
block|{
name|this
operator|.
name|ignoringSinglePrefixOrSuffixShingle
operator|=
name|ignoringSinglePrefixOrSuffixShingle
expr_stmt|;
block|}
comment|/**    * Using this codec makes a {@link ShingleMatrixFilter} act like {@link org.apache.lucene.analysis.shingle.ShingleFilter}.    * It produces the most simple sort of shingles, ignoring token position increments, et c.    *    * It adds each token as a new column.    */
DECL|class|OneDimensionalNonWeightedTokenSettingsCodec
specifier|public
specifier|static
class|class
name|OneDimensionalNonWeightedTokenSettingsCodec
extends|extends
name|TokenSettingsCodec
block|{
DECL|method|getTokenPositioner
specifier|public
name|TokenPositioner
name|getTokenPositioner
parameter_list|(
name|Token
name|token
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|TokenPositioner
operator|.
name|newColumn
return|;
block|}
DECL|method|setTokenPositioner
specifier|public
name|void
name|setTokenPositioner
parameter_list|(
name|Token
name|token
parameter_list|,
name|TokenPositioner
name|tokenPositioner
parameter_list|)
block|{     }
DECL|method|getWeight
specifier|public
name|float
name|getWeight
parameter_list|(
name|Token
name|token
parameter_list|)
block|{
return|return
literal|1f
return|;
block|}
DECL|method|setWeight
specifier|public
name|void
name|setWeight
parameter_list|(
name|Token
name|token
parameter_list|,
name|float
name|weight
parameter_list|)
block|{     }
block|}
comment|/**    * A codec that creates a two dimensional matrix    * by treating tokens from the input stream with 0 position increment    * as new rows to the current column.    */
DECL|class|TwoDimensionalNonWeightedSynonymTokenSettingsCodec
specifier|public
specifier|static
class|class
name|TwoDimensionalNonWeightedSynonymTokenSettingsCodec
extends|extends
name|TokenSettingsCodec
block|{
DECL|method|getTokenPositioner
specifier|public
name|TokenPositioner
name|getTokenPositioner
parameter_list|(
name|Token
name|token
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|token
operator|.
name|getPositionIncrement
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|TokenPositioner
operator|.
name|newRow
return|;
block|}
else|else
block|{
return|return
name|TokenPositioner
operator|.
name|newColumn
return|;
block|}
block|}
DECL|method|setTokenPositioner
specifier|public
name|void
name|setTokenPositioner
parameter_list|(
name|Token
name|token
parameter_list|,
name|TokenPositioner
name|tokenPositioner
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|getWeight
specifier|public
name|float
name|getWeight
parameter_list|(
name|Token
name|token
parameter_list|)
block|{
return|return
literal|1f
return|;
block|}
DECL|method|setWeight
specifier|public
name|void
name|setWeight
parameter_list|(
name|Token
name|token
parameter_list|,
name|float
name|weight
parameter_list|)
block|{     }
block|}
comment|/**    * A full featured codec not to be used for something serious.    *    * It takes complete control of    * payload for weight    * and the bit flags for positioning in the matrix.    *    * Mainly exist for demonstrational purposes.    */
DECL|class|SimpleThreeDimensionalTokenSettingsCodec
specifier|public
specifier|static
class|class
name|SimpleThreeDimensionalTokenSettingsCodec
extends|extends
name|TokenSettingsCodec
block|{
comment|/**      * @param token      * @return the token flags int value as TokenPosition      * @throws IOException      */
DECL|method|getTokenPositioner
specifier|public
name|TokenPositioner
name|getTokenPositioner
parameter_list|(
name|Token
name|token
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|token
operator|.
name|getFlags
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
return|return
name|TokenPositioner
operator|.
name|newColumn
return|;
case|case
literal|1
case|:
return|return
name|TokenPositioner
operator|.
name|newRow
return|;
case|case
literal|2
case|:
return|return
name|TokenPositioner
operator|.
name|sameRow
return|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown matrix positioning of token "
operator|+
name|token
argument_list|)
throw|;
block|}
comment|/**      * Sets the TokenPositioner as token flags int value.      *      * @param token      * @param tokenPositioner      */
DECL|method|setTokenPositioner
specifier|public
name|void
name|setTokenPositioner
parameter_list|(
name|Token
name|token
parameter_list|,
name|TokenPositioner
name|tokenPositioner
parameter_list|)
block|{
name|token
operator|.
name|setFlags
argument_list|(
name|tokenPositioner
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns a 32 bit float from the payload, or 1f it null.      *      * @param token      * @return 32 bit float      */
DECL|method|getWeight
specifier|public
name|float
name|getWeight
parameter_list|(
name|Token
name|token
parameter_list|)
block|{
if|if
condition|(
name|token
operator|.
name|getPayload
argument_list|()
operator|==
literal|null
operator|||
name|token
operator|.
name|getPayload
argument_list|()
operator|.
name|getData
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|1f
return|;
block|}
else|else
block|{
return|return
name|PayloadHelper
operator|.
name|decodeFloat
argument_list|(
name|token
operator|.
name|getPayload
argument_list|()
operator|.
name|getData
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**      * Stores a 32 bit float in the payload, or set it to null if 1f;      * @param token      * @param weight      */
DECL|method|setWeight
specifier|public
name|void
name|setWeight
parameter_list|(
name|Token
name|token
parameter_list|,
name|float
name|weight
parameter_list|)
block|{
if|if
condition|(
name|weight
operator|==
literal|1f
condition|)
block|{
name|token
operator|.
name|setPayload
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|token
operator|.
name|setPayload
argument_list|(
operator|new
name|Payload
argument_list|(
name|PayloadHelper
operator|.
name|encodeFloat
argument_list|(
name|weight
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class
end_unit
