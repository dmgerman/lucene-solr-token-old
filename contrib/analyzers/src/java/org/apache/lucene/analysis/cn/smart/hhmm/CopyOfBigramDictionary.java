begin_unit
begin_comment
comment|/**  * Copyright 2009 www.imdict.net  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.analysis.cn.smart.hhmm
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|cn
operator|.
name|smart
operator|.
name|hhmm
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteOrder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|cn
operator|.
name|smart
operator|.
name|AnalyzerProfile
import|;
end_import
begin_class
DECL|class|CopyOfBigramDictionary
specifier|public
class|class
name|CopyOfBigramDictionary
extends|extends
name|AbstractDictionary
block|{
DECL|method|CopyOfBigramDictionary
specifier|private
name|CopyOfBigramDictionary
parameter_list|()
block|{   }
DECL|field|WORD_SEGMENT_CHAR
specifier|public
specifier|static
specifier|final
name|char
name|WORD_SEGMENT_CHAR
init|=
literal|'@'
decl_stmt|;
DECL|field|singleInstance
specifier|private
specifier|static
name|CopyOfBigramDictionary
name|singleInstance
decl_stmt|;
DECL|field|PRIME_BIGRAM_LENGTH
specifier|public
specifier|static
specifier|final
name|int
name|PRIME_BIGRAM_LENGTH
init|=
literal|402137
decl_stmt|;
comment|/**    * bigramTable æ¥å­å¨è¯ä¸è¯ä¹é´çè·³è½¬é¢çï¼ bigramHashTable å frequencyTable    * å°±æ¯ç¨æ¥å­å¨è¿äºé¢ççæ°æ®ç»æã ä¸ºäºæé«æ¥è¯¢éåº¦åèçåå­ï¼ éç¨ hash å¼æ¥ä»£æ¿å³èè¯ä½ä¸ºæ¥è¯¢ä¾æ®ï¼ å³èè¯å°±æ¯    * (formWord+'@'+toWord) ï¼ å©ç¨ FNV1 hash ç®æ³æ¥è®¡ç®å³èè¯çhashå¼ ï¼å¹¶ä¿å­å¨ bigramHashTable    * ä¸­ï¼å©ç¨ hash å¼æ¥ä»£æ¿å³èè¯æå¯è½ä¼äº§çå¾å°æ¦ççå²çªï¼ ä½æ¯ long ç±»å    * (64bit)çhashå¼ææå°å°æ­¤æ¦çéå°æä½ãbigramHashTable[i]ä¸frequencyTable[i]ä¸ä¸å¯¹åº    */
DECL|field|bigramHashTable
specifier|private
name|long
index|[]
name|bigramHashTable
decl_stmt|;
DECL|field|frequencyTable
specifier|private
name|int
index|[]
name|frequencyTable
decl_stmt|;
DECL|field|max
specifier|private
name|int
name|max
init|=
literal|0
decl_stmt|;
DECL|field|repeat
specifier|private
name|int
name|repeat
init|=
literal|0
decl_stmt|;
comment|// static Logger log = Logger.getLogger(BigramDictionary.class);
DECL|method|getInstance
specifier|public
specifier|synchronized
specifier|static
name|CopyOfBigramDictionary
name|getInstance
parameter_list|()
block|{
if|if
condition|(
name|singleInstance
operator|==
literal|null
condition|)
block|{
name|String
name|dictRoot
init|=
name|AnalyzerProfile
operator|.
name|ANALYSIS_DATA_DIR
decl_stmt|;
name|singleInstance
operator|=
operator|new
name|CopyOfBigramDictionary
argument_list|()
expr_stmt|;
name|singleInstance
operator|.
name|load
argument_list|(
name|dictRoot
argument_list|)
expr_stmt|;
block|}
return|return
name|singleInstance
return|;
block|}
DECL|method|loadFromObj
specifier|private
name|boolean
name|loadFromObj
parameter_list|(
name|File
name|serialObj
parameter_list|)
block|{
name|boolean
name|loadFromObject
init|=
literal|false
decl_stmt|;
try|try
block|{
name|ObjectInputStream
name|input
init|=
operator|new
name|ObjectInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|serialObj
argument_list|)
argument_list|)
decl_stmt|;
name|bigramHashTable
operator|=
operator|(
name|long
index|[]
operator|)
name|input
operator|.
name|readObject
argument_list|()
expr_stmt|;
name|frequencyTable
operator|=
operator|(
name|int
index|[]
operator|)
name|input
operator|.
name|readObject
argument_list|()
expr_stmt|;
comment|// log.info("load bigram dict from serialization.");
name|loadFromObject
operator|=
literal|true
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// log.warn(e.getMessage());
block|}
return|return
name|loadFromObject
return|;
block|}
DECL|method|saveToObj
specifier|private
name|void
name|saveToObj
parameter_list|(
name|File
name|serialObj
parameter_list|)
block|{
try|try
block|{
name|ObjectOutputStream
name|output
init|=
operator|new
name|ObjectOutputStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|serialObj
argument_list|)
argument_list|)
decl_stmt|;
name|output
operator|.
name|writeObject
argument_list|(
name|bigramHashTable
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeObject
argument_list|(
name|frequencyTable
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// log.info("serialize bigram dict.");
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// log.warn(e.getMessage());
block|}
block|}
DECL|method|load
specifier|private
name|void
name|load
parameter_list|(
name|String
name|dictRoot
parameter_list|)
block|{
name|String
name|bigramDictPath
init|=
name|dictRoot
operator|+
literal|"/bigramdict.dct"
decl_stmt|;
name|File
name|serialObj
init|=
operator|new
name|File
argument_list|(
name|dictRoot
operator|+
literal|"/bigramdict.mem"
argument_list|)
decl_stmt|;
if|if
condition|(
name|serialObj
operator|.
name|exists
argument_list|()
operator|&&
name|loadFromObj
argument_list|(
name|serialObj
argument_list|)
condition|)
block|{      }
else|else
block|{
try|try
block|{
name|bigramHashTable
operator|=
operator|new
name|long
index|[
name|PRIME_BIGRAM_LENGTH
index|]
expr_stmt|;
name|frequencyTable
operator|=
operator|new
name|int
index|[
name|PRIME_BIGRAM_LENGTH
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|PRIME_BIGRAM_LENGTH
condition|;
name|i
operator|++
control|)
block|{
comment|// å®éä¸å°0ä½ä¸ºåå§å¼æä¸ç¹é®é¢ï¼å ä¸ºæä¸ªå­ç¬¦ä¸²å¯è½hashå¼ä¸º0ï¼ä½æ¯æ¦çéå¸¸å°ï¼å æ­¤å½±åä¸å¤§
name|bigramHashTable
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|frequencyTable
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|loadFromFile
argument_list|(
name|bigramDictPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|saveToObj
argument_list|(
name|serialObj
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * å°è¯åºæä»¶å è½½å°WordDictionaryçç¸å³æ°æ®ç»æä¸­ï¼åªæ¯å è½½ï¼æ²¡æè¿è¡åå¹¶åä¿®æ¹æä½    *     * @param dctFilePath    * @return    * @throws FileNotFoundException    * @throws IOException    * @throws UnsupportedEncodingException    */
DECL|method|loadFromFile
specifier|public
name|void
name|loadFromFile
parameter_list|(
name|String
name|dctFilePath
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|IOException
throws|,
name|UnsupportedEncodingException
block|{
name|int
name|i
decl_stmt|,
name|cnt
decl_stmt|,
name|length
decl_stmt|,
name|total
init|=
literal|0
decl_stmt|;
comment|// æä»¶ä¸­åªç»è®¡äº6763ä¸ªæ±å­å 5ä¸ªç©ºæ±å­ç¬¦3756~3760ï¼å¶ä¸­ç¬¬3756ä¸ªç¨æ¥å­å¨ç¬¦å·ä¿¡æ¯ã
name|int
index|[]
name|buffer
init|=
operator|new
name|int
index|[
literal|3
index|]
decl_stmt|;
name|byte
index|[]
name|intBuffer
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|String
name|tmpword
decl_stmt|;
name|RandomAccessFile
name|dctFile
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|dctFilePath
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
comment|// å­å¸æä»¶ä¸­ç¬¬ä¸ä¸ªæ±å­åºç°çä½ç½®æ¯0ï¼æåä¸ä¸ªæ¯6768
for|for
control|(
name|i
operator|=
name|GB2312_FIRST_CHAR
init|;
name|i
operator|<
name|GB2312_FIRST_CHAR
operator|+
name|CHAR_NUM_IN_FILE
condition|;
name|i
operator|++
control|)
block|{
name|String
name|currentStr
init|=
name|getCCByGB2312Id
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// if (i == 5231)
comment|// System.out.println(i);
name|dctFile
operator|.
name|read
argument_list|(
name|intBuffer
argument_list|)
expr_stmt|;
comment|// åè¯åºæä»¶å¨cä¸å¼åï¼æä»¥åå¥çæä»¶ä¸ºlittle
comment|// endianç¼ç ï¼èjavaä¸ºbig endianï¼å¿é¡»è½¬æ¢è¿æ¥
name|cnt
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|intBuffer
argument_list|)
operator|.
name|order
argument_list|(
name|ByteOrder
operator|.
name|LITTLE_ENDIAN
argument_list|)
operator|.
name|getInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|cnt
operator|<=
literal|0
condition|)
block|{
continue|continue;
block|}
name|total
operator|+=
name|cnt
expr_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|j
operator|<
name|cnt
condition|)
block|{
name|dctFile
operator|.
name|read
argument_list|(
name|intBuffer
argument_list|)
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|intBuffer
argument_list|)
operator|.
name|order
argument_list|(
name|ByteOrder
operator|.
name|LITTLE_ENDIAN
argument_list|)
operator|.
name|getInt
argument_list|()
expr_stmt|;
comment|// frequency
name|dctFile
operator|.
name|read
argument_list|(
name|intBuffer
argument_list|)
expr_stmt|;
name|buffer
index|[
literal|1
index|]
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|intBuffer
argument_list|)
operator|.
name|order
argument_list|(
name|ByteOrder
operator|.
name|LITTLE_ENDIAN
argument_list|)
operator|.
name|getInt
argument_list|()
expr_stmt|;
comment|// length
name|dctFile
operator|.
name|read
argument_list|(
name|intBuffer
argument_list|)
expr_stmt|;
comment|// buffer[2] = ByteBuffer.wrap(intBuffer).order(
comment|// ByteOrder.LITTLE_ENDIAN).getInt();// handle
name|length
operator|=
name|buffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|byte
index|[]
name|lchBuffer
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|dctFile
operator|.
name|read
argument_list|(
name|lchBuffer
argument_list|)
expr_stmt|;
name|tmpword
operator|=
operator|new
name|String
argument_list|(
name|lchBuffer
argument_list|,
literal|"GB2312"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|3755
operator|+
name|GB2312_FIRST_CHAR
condition|)
block|{
name|tmpword
operator|=
name|currentStr
operator|+
name|tmpword
expr_stmt|;
block|}
name|char
name|carray
index|[]
init|=
name|tmpword
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|long
name|hashId
init|=
name|hash1
argument_list|(
name|carray
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|getAvaliableIndex
argument_list|(
name|hashId
argument_list|,
name|carray
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|bigramHashTable
index|[
name|index
index|]
operator|==
literal|0
condition|)
block|{
name|bigramHashTable
index|[
name|index
index|]
operator|=
name|hashId
expr_stmt|;
comment|// bigramStringTable[index] = tmpword;
block|}
name|frequencyTable
index|[
name|index
index|]
operator|+=
name|buffer
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
name|j
operator|++
expr_stmt|;
block|}
block|}
name|dctFile
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// log.info("load dictionary done! " + dctFilePath + " total:" + total);
block|}
comment|/*    * public void test(String dctFilePath) throws IOException { int i, cnt,    * length, total = 0; int corrupt = 0, notFound = 0; //    * æä»¶ä¸­åªç»è®¡äº6763ä¸ªæ±å­å 5ä¸ªç©ºæ±å­ç¬¦3756~3760ï¼å¶ä¸­ç¬¬3756ä¸ªç¨æ¥å­å¨ç¬¦å·ä¿¡æ¯ã int[] buffer = new int[3];    * byte[] intBuffer = new byte[4]; String tmpword; RandomAccessFile dctFile =    * new RandomAccessFile(dctFilePath, "r");    *     * // å­å¸æä»¶ä¸­ç¬¬ä¸ä¸ªæ±å­åºç°çä½ç½®æ¯0ï¼æåä¸ä¸ªæ¯6768 for (i = GB2312_FIRST_CHAR; i<    * GB2312_FIRST_CHAR + CHAR_NUM_IN_FILE; i++) { String currentStr =    * getCCByGB2312Id(i); // if (i == 5231) // System.out.println(i);    *     * dctFile.read(intBuffer);// åè¯åºæä»¶å¨cä¸å¼åï¼æä»¥åå¥çæä»¶ä¸ºlittle // endianç¼ç ï¼èjavaä¸ºbig    * endianï¼å¿é¡»è½¬æ¢è¿æ¥ cnt =    * ByteBuffer.wrap(intBuffer).order(ByteOrder.LITTLE_ENDIAN) .getInt(); if    * (cnt<= 0) { continue; } total += cnt; int j = 0; while (j< cnt) {    * dctFile.read(intBuffer); buffer[0] = ByteBuffer.wrap(intBuffer).order(    * ByteOrder.LITTLE_ENDIAN).getInt();// frequency dctFile.read(intBuffer);    * buffer[1] = ByteBuffer.wrap(intBuffer).order(    * ByteOrder.LITTLE_ENDIAN).getInt();// length dctFile.read(intBuffer); //    * buffer[2] = ByteBuffer.wrap(intBuffer).order( //    * ByteOrder.LITTLE_ENDIAN).getInt();// handle    *     * length = buffer[1]; if (length> 0) { byte[] lchBuffer = new byte[length];    * dctFile.read(lchBuffer); tmpword = new String(lchBuffer, "GB2312"); if (i    * != 3755 + GB2312_FIRST_CHAR) { tmpword = currentStr + tmpword; } char    * carray[] = tmpword.toCharArray(); int index = getBigramItemIndex(carray);    * if (index != -1) { // if (!bigramStringTable[index].equals(tmpword)) { //    * System.out.println("corrupt: " + tmpword + "<->" // +    * bigramStringTable[index]); // corrupt++; // } } else {    * System.out.println("not found: " + tmpword); notFound++; } } j++; } }    * dctFile.close(); System.out.println("num not found:" + notFound);    * System.out.println("num corrupt:" + corrupt);    *     * log.info("test dictionary done! " + dctFilePath + " total:" + total); cnt =    * 0; for (int j = 0; j< PRIME_BIGRAM_LENGTH; j++) { if (bigramHashTable[j]    * != 0) { cnt++; } } System.out.println("total num in bigramTable: " + cnt);    * }    */
DECL|method|getAvaliableIndex
specifier|private
name|int
name|getAvaliableIndex
parameter_list|(
name|long
name|hashId
parameter_list|,
name|char
name|carray
index|[]
parameter_list|)
block|{
name|int
name|hash1
init|=
call|(
name|int
call|)
argument_list|(
name|hashId
operator|%
name|PRIME_BIGRAM_LENGTH
argument_list|)
decl_stmt|;
name|int
name|hash2
init|=
name|hash2
argument_list|(
name|carray
argument_list|)
operator|%
name|PRIME_BIGRAM_LENGTH
decl_stmt|;
if|if
condition|(
name|hash1
operator|<
literal|0
condition|)
name|hash1
operator|=
name|PRIME_BIGRAM_LENGTH
operator|+
name|hash1
expr_stmt|;
if|if
condition|(
name|hash2
operator|<
literal|0
condition|)
name|hash2
operator|=
name|PRIME_BIGRAM_LENGTH
operator|+
name|hash2
expr_stmt|;
name|int
name|index
init|=
name|hash1
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|bigramHashTable
index|[
name|index
index|]
operator|!=
literal|0
operator|&&
name|bigramHashTable
index|[
name|index
index|]
operator|!=
name|hashId
operator|&&
name|i
operator|<
name|PRIME_BIGRAM_LENGTH
condition|)
block|{
name|index
operator|=
operator|(
name|hash1
operator|+
name|i
operator|*
name|hash2
operator|)
operator|%
name|PRIME_BIGRAM_LENGTH
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|// System.out.println(i - 1);
if|if
condition|(
name|i
operator|<
name|PRIME_BIGRAM_LENGTH
operator|&&
operator|(
name|bigramHashTable
index|[
name|index
index|]
operator|==
literal|0
operator|||
name|bigramHashTable
index|[
name|index
index|]
operator|==
name|hashId
operator|)
condition|)
block|{
return|return
name|index
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * @param c    * @return    */
DECL|method|getBigramItemIndex
specifier|private
name|int
name|getBigramItemIndex
parameter_list|(
name|char
name|carray
index|[]
parameter_list|)
block|{
name|long
name|hashId
init|=
name|hash1
argument_list|(
name|carray
argument_list|)
decl_stmt|;
name|int
name|hash1
init|=
call|(
name|int
call|)
argument_list|(
name|hashId
operator|%
name|PRIME_BIGRAM_LENGTH
argument_list|)
decl_stmt|;
name|int
name|hash2
init|=
name|hash2
argument_list|(
name|carray
argument_list|)
operator|%
name|PRIME_BIGRAM_LENGTH
decl_stmt|;
if|if
condition|(
name|hash1
operator|<
literal|0
condition|)
name|hash1
operator|=
name|PRIME_BIGRAM_LENGTH
operator|+
name|hash1
expr_stmt|;
if|if
condition|(
name|hash2
operator|<
literal|0
condition|)
name|hash2
operator|=
name|PRIME_BIGRAM_LENGTH
operator|+
name|hash2
expr_stmt|;
name|int
name|index
init|=
name|hash1
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
name|repeat
operator|++
expr_stmt|;
while|while
condition|(
name|bigramHashTable
index|[
name|index
index|]
operator|!=
literal|0
operator|&&
name|bigramHashTable
index|[
name|index
index|]
operator|!=
name|hashId
operator|&&
name|i
operator|<
name|PRIME_BIGRAM_LENGTH
condition|)
block|{
name|index
operator|=
operator|(
name|hash1
operator|+
name|i
operator|*
name|hash2
operator|)
operator|%
name|PRIME_BIGRAM_LENGTH
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|repeat
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|max
condition|)
name|max
operator|=
name|i
expr_stmt|;
block|}
comment|// System.out.println(i - 1);
if|if
condition|(
name|i
operator|<
name|PRIME_BIGRAM_LENGTH
operator|&&
name|bigramHashTable
index|[
name|index
index|]
operator|==
name|hashId
condition|)
block|{
return|return
name|index
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
DECL|method|getFrequency
specifier|public
name|int
name|getFrequency
parameter_list|(
name|char
index|[]
name|carray
parameter_list|)
block|{
name|int
name|index
init|=
name|getBigramItemIndex
argument_list|(
name|carray
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
return|return
name|frequencyTable
index|[
name|index
index|]
return|;
return|return
literal|0
return|;
block|}
DECL|method|main
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnsupportedEncodingException
throws|,
name|IOException
block|{
name|CopyOfBigramDictionary
name|dic
init|=
operator|new
name|CopyOfBigramDictionary
argument_list|()
decl_stmt|;
name|dic
operator|.
name|load
argument_list|(
literal|"D:/analysis-data"
argument_list|)
expr_stmt|;
comment|// dic.test("D:/analysis-data/BigramDict.dct");
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"max:"
operator|+
name|dic
operator|.
name|max
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"average repeat:"
operator|+
operator|(
name|double
operator|)
name|dic
operator|.
name|repeat
operator|/
literal|328856
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"end"
argument_list|)
expr_stmt|;
block|}
block|}
end_class
end_unit
