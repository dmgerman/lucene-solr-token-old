begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.spatial.geometry.shape
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|geometry
operator|.
name|shape
package|;
end_package
begin_comment
comment|/**  * Imported from mq java client.  No changes made.  *  *<p><font color="red"><b>NOTE:</b> This API is still in  * flux and might change in incompatible ways in the next  * release.</font>  */
end_comment
begin_class
DECL|class|DistanceApproximation
specifier|public
class|class
name|DistanceApproximation
block|{
DECL|field|m_testLat
specifier|private
name|double
name|m_testLat
decl_stmt|;
DECL|field|m_testLng
specifier|private
name|double
name|m_testLng
decl_stmt|;
DECL|field|m_mpd
specifier|private
name|double
name|m_mpd
decl_stmt|;
DECL|field|m_milesPerLngDeg
specifier|private
specifier|static
specifier|final
name|double
name|m_milesPerLngDeg
index|[]
init|=
block|{
literal|69.170976f
block|,
literal|69.160441f
block|,
literal|69.128838f
block|,
literal|69.076177f
block|,
literal|69.002475f
block|,
literal|68.907753f
block|,
literal|68.792041f
block|,
literal|68.655373f
block|,
literal|68.497792f
block|,
literal|68.319345f
block|,
literal|68.120088f
block|,
literal|67.900079f
block|,
literal|67.659387f
block|,
literal|67.398085f
block|,
literal|67.116253f
block|,
literal|66.813976f
block|,
literal|66.491346f
block|,
literal|66.148462f
block|,
literal|65.785428f
block|,
literal|65.402355f
block|,
literal|64.999359f
block|,
literal|64.576564f
block|,
literal|64.134098f
block|,
literal|63.672096f
block|,
literal|63.190698f
block|,
literal|62.690052f
block|,
literal|62.170310f
block|,
literal|61.631630f
block|,
literal|61.074176f
block|,
literal|60.498118f
block|,
literal|59.903632f
block|,
literal|59.290899f
block|,
literal|58.660106f
block|,
literal|58.011443f
block|,
literal|57.345111f
block|,
literal|56.661310f
block|,
literal|55.960250f
block|,
literal|55.242144f
block|,
literal|54.507211f
block|,
literal|53.755675f
block|,
literal|52.987764f
block|,
literal|52.203713f
block|,
literal|51.403761f
block|,
literal|50.588151f
block|,
literal|49.757131f
block|,
literal|48.910956f
block|,
literal|48.049882f
block|,
literal|47.174172f
block|,
literal|46.284093f
block|,
literal|45.379915f
block|,
literal|44.461915f
block|,
literal|43.530372f
block|,
literal|42.585570f
block|,
literal|41.627796f
block|,
literal|40.657342f
block|,
literal|39.674504f
block|,
literal|38.679582f
block|,
literal|37.672877f
block|,
literal|36.654698f
block|,
literal|35.625354f
block|,
literal|34.585159f
block|,
literal|33.534429f
block|,
literal|32.473485f
block|,
literal|31.402650f
block|,
literal|30.322249f
block|,
literal|29.232613f
block|,
literal|28.134073f
block|,
literal|27.026963f
block|,
literal|25.911621f
block|,
literal|24.788387f
block|,
literal|23.657602f
block|,
literal|22.519612f
block|,
literal|21.374762f
block|,
literal|20.223401f
block|,
literal|19.065881f
block|,
literal|17.902554f
block|,
literal|16.733774f
block|,
literal|15.559897f
block|,
literal|14.381280f
block|,
literal|13.198283f
block|,
literal|12.011266f
block|,
literal|10.820591f
block|,
literal|9.626619f
block|,
literal|8.429716f
block|,
literal|7.230245f
block|,
literal|6.028572f
block|,
literal|4.825062f
block|,
literal|3.620083f
block|,
literal|2.414002f
block|,
literal|1.207185f
block|,
literal|1.000000f
block|}
decl_stmt|;
DECL|field|MILES_PER_LATITUDE
specifier|public
specifier|static
specifier|final
name|double
name|MILES_PER_LATITUDE
init|=
literal|69.170976f
decl_stmt|;
DECL|field|KILOMETERS_PER_MILE
specifier|public
specifier|static
specifier|final
name|double
name|KILOMETERS_PER_MILE
init|=
literal|1.609347f
decl_stmt|;
DECL|method|DistanceApproximation
specifier|public
name|DistanceApproximation
parameter_list|()
block|{   }
DECL|method|setTestPoint
specifier|public
name|void
name|setTestPoint
parameter_list|(
name|double
name|lat
parameter_list|,
name|double
name|lng
parameter_list|)
block|{
name|m_testLat
operator|=
name|lat
expr_stmt|;
name|m_testLng
operator|=
name|lng
expr_stmt|;
name|m_mpd
operator|=
name|m_milesPerLngDeg
index|[
call|(
name|int
call|)
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|lat
argument_list|)
operator|+
literal|0.5f
argument_list|)
index|]
expr_stmt|;
block|}
comment|// Approximate arc distance between 2 lat,lng positions using miles per
comment|//    latitude and longitude degree
DECL|method|getDistanceSq
specifier|public
name|double
name|getDistanceSq
parameter_list|(
name|double
name|lat
parameter_list|,
name|double
name|lng
parameter_list|)
block|{
name|double
name|latMiles
init|=
operator|(
name|lat
operator|-
name|m_testLat
operator|)
operator|*
name|MILES_PER_LATITUDE
decl_stmt|;
comment|// Approximate longitude miles using the miles per degree assuming the
comment|//    middle latitude/longitude.  This is less accurate at high (near
comment|//    polar) latitudes but no road network is present at the poles!
comment|//    If we ever have any roads crossing the international date we will
comment|//    have to worry about that case.
name|double
name|lngMiles
init|=
operator|(
name|lng
operator|-
name|m_testLng
operator|)
operator|*
name|m_mpd
decl_stmt|;
comment|// Find the squared distance by the Pythagorean theorem (without sqrt)
return|return
operator|(
name|latMiles
operator|*
name|latMiles
operator|+
name|lngMiles
operator|*
name|lngMiles
operator|)
return|;
block|}
comment|// Approximate arc distance between a segment (with lat,lng endpoints) and
comment|//    the test position
DECL|method|getDistanceSq
specifier|public
name|double
name|getDistanceSq
parameter_list|(
name|double
name|lat1
parameter_list|,
name|double
name|lng1
parameter_list|,
name|double
name|lat2
parameter_list|,
name|double
name|lng2
parameter_list|)
block|{
comment|// Check if lat1,lng1 is closest point.  Construct a vector from point1
comment|//    to point2 (v1) and another from point 1 to the test point (v2).
comment|//    If dot product is negative then point 1 is the closest point
name|double
name|v1y
init|=
name|lat2
operator|-
name|lat1
decl_stmt|;
name|double
name|v1x
init|=
name|lng2
operator|-
name|lng1
decl_stmt|;
name|double
name|v2y
init|=
name|m_testLat
operator|-
name|lat1
decl_stmt|;
name|double
name|v2x
init|=
name|m_testLng
operator|-
name|lng1
decl_stmt|;
name|double
name|dot
init|=
name|v1x
operator|*
name|v2x
operator|+
name|v1y
operator|*
name|v2y
decl_stmt|;
if|if
condition|(
name|dot
operator|<=
literal|0.0f
condition|)
return|return
name|getDistanceSq
argument_list|(
name|lat1
argument_list|,
name|lng1
argument_list|)
return|;
comment|// Get the component of vector v2 along v1.  If component is greater
comment|//    than 1 then the endpoint is the closest point.
name|double
name|c
init|=
name|dot
operator|/
operator|(
name|v1x
operator|*
name|v1x
operator|+
name|v1y
operator|*
name|v1y
operator|)
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|1.0f
condition|)
return|return
name|getDistanceSq
argument_list|(
name|lat2
argument_list|,
name|lng2
argument_list|)
return|;
comment|// Since we are working io lat,lng space we need to find the point
comment|//    along p1->p2 such that q->pt is perpendicular to p1->p2.  We
comment|//    then find the distance squared between Q and pt.
return|return
name|getDistanceSq
argument_list|(
operator|(
name|lat1
operator|+
name|v1y
operator|*
name|c
operator|)
argument_list|,
operator|(
name|lng1
operator|+
name|v1x
operator|*
name|c
operator|)
argument_list|)
return|;
block|}
comment|// Return the number of miles per degree of longitude
DECL|method|getMilesPerLngDeg
specifier|public
specifier|static
name|double
name|getMilesPerLngDeg
parameter_list|(
name|double
name|lat
parameter_list|)
block|{
return|return
operator|(
name|Math
operator|.
name|abs
argument_list|(
name|lat
argument_list|)
operator|<=
literal|90.0
operator|)
condition|?
name|m_milesPerLngDeg
index|[
call|(
name|int
call|)
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|lat
argument_list|)
operator|+
literal|0.5f
argument_list|)
index|]
else|:
literal|69.170976f
return|;
block|}
DECL|method|getMilesPerLatDeg
specifier|public
specifier|static
name|double
name|getMilesPerLatDeg
parameter_list|()
block|{
return|return
name|MILES_PER_LATITUDE
return|;
block|}
block|}
end_class
end_unit
