<html>
<body>
<p>This package provides fast numeric range queries/filters on <code>long</code>, <code>double</code>, <code>int</code>,
or <code>float</code> (and other data types, that can be converted to numerical values) fields based on trie structures.</p>

<h3>How it works</h3>
<p>See the publication about <a target="_blank" href="http://www.panfmp.org">panFMP</a>, where this algorithm was described:

<blockquote><strong>Schindler, U, Diepenbroek, M</strong>, 2008. <em>Generic XML-based Framework for Metadata Portals.</em>
Computers &amp; Geosciences 34 (12), 1947-1955.
<a href="http://dx.doi.org/10.1016/j.cageo.2008.02.023" target="_blank">doi:10.1016/j.cageo.2008.02.023</a></blockquote>

<p><em>A quote from this paper:</em> Because Apache Lucene is a full-text search engine and not a conventional database,
it cannot handle numerical ranges (e.g., field value is inside user defined bounds, even dates are numerical values).
We have developed an extension to Apache Lucene that stores
the numerical values in a special string-encoded format with variable precision
(all numerical values like doubles, longs, floats, and ints are converted to lexicographic sortable string representations
and stored with different precisions. For a more detailed description of how the values are stored,
see {@link org.apache.lucene.search.trie.TrieUtils}. A range is then divided recursively into
multiple intervals for searching:
The center of the range is searched only with the lowest possible precision in the trie,
while the boundaries are matched more exactly. This reduces the number of terms dramatically.</p>

<p>For the variant that stores long values in 8 different precisions (each reduced by 8 bits) that
uses a lowest precision of 1 byte, the index contains only a maximum of 256 distinct values in the
lowest precision. Overall, a range could consist of a theoretical maximum of
<code>7*255*2 + 255 = 3825</code> distinct terms (when there is a term for every distinct value of an
8-byte-number in the index and the range covers almost all of them; a maximum of 255 distinct values is used
because it would always be possible to reduce the full 256 values to one term with degraded precision).
In practise, we have seen up to 300 terms in most cases (index with 500,000 metadata records
and a uniform value distribution).</p>

<p>You can choose any <code>precisionStep</code> when encoding integer values.
Lower step values mean more precisions and so more terms in index (and index gets larger).
On the other hand, the maximum number of terms to match reduces, which optimized query speed.
The formula to calculate the maximum term count is:
<pre>
 n = [ (bitsPerValue/precisionStep - 1) * (2^precisionStep - 1 ) * 2 ] + (2^precisionStep - 1 )
</pre>
<p><em>(this formula is only correct, when <code>bitsPerValue/precisionStep</code> is an integer;
in other cases, the value must be rounded up and the last summand must contain the modulo of the division as
precision step)</em>.
For longs stored using a precision step of 4, <code>n = 15*15*2 + 15 = 465</code>, and for a precision
step of 2, <code>n = 31*3*2 + 3 = 189</code>. But the faster search speed is reduced by more seeking
in the term enum of the index. Because of this, the ideal <code>precisionStep</code> value can only
be found out by testing. <b>Important:</b> You can index with a lower precision step value and test search speed
using a multiple of the original step value.</p>

<p>This dramatically improves the performance of Apache Lucene with range queries, which
are no longer dependent on the index size and the number of distinct values because there is
an upper limit unrelated to either of these properties.</p>

<h3>Indexing Usage</h3>
<p>To use the new query types the numerical values, which may be<code>long</code>, <code>double</code>, <code>int</code>,
<code>float</code>, or <code>Date</code>, the values must be indexed in a special prefix encoded format
using {@link org.apache.lucene.search.trie.LongTrieTokenStream} or
{@link org.apache.lucene.search.trie.IntTrieTokenStream}, which generate the necessary tokens.
Use {@link org.apache.lucene.search.trie.TrieUtils} to convert floating point values to integers.
Example code for indexing (it is recommened to disable norms and term frequencies during indexing
trie encoded fields):</p>

<pre>
  <em>// chose a step value, 8 is a general good value for large indexes:</em>
  int precisionStep = 8;
  
  Document doc = new Document();
  
  <em>// add some standard fields:</em>
  String svalue = "anything to index";
  doc.add(new Field("exampleString", svalue, Field.Store.YES, Field.Index.ANALYZED));
  
  <em>// add some numerical fields:</em>
  long lvalue = 121345L;
  Field f = new Field("exampleLong", new LongTrieTokenStream(lvalue, precisionStep));
  f.setOmitNorms(true); f.setOmitTermFreqAndPositions(true);
  doc.add(f);
  double dvalue = 1.057E17;
  f = new Field("exampleDouble", new LongTrieTokenStream(TrieUtils.doubleToSortableLong(dvalue), precisionStep));
  f.setOmitNorms(true); f.setOmitTermFreqAndPositions(true);
  doc.add(f);
  int ivalue = 121345;
  f = new Field("exampleInt", new IntTrieTokenStream(ivalue, precisionStep));
  f.setOmitNorms(true); f.setOmitTermFreqAndPositions(true);
  doc.add(f);
  float fvalue = 1.057E17f;
  f = new Field("exampleFloat", new IntTrieTokenStream(TrieUtils.floatToSortableInt(fvalue), precisionStep));
  f.setOmitNorms(true); f.setOmitTermFreqAndPositions(true);
  doc.add(f);
  Date datevalue = new Date(); <em>// actual time</em>
  f = new Field("exampleDate", new LongTrieTokenStream(datevalue.getTime(), precisionStep));
  f.setOmitNorms(true); f.setOmitTermFreqAndPositions(true);
  doc.add(f);
  
  <em>// if you want to also store one of the values:</em>
  doc.add(new Field("exampleLong", Long.toString(lvalue), Field.Store.YES, Field.Index.NO));
  
  <em>// or as encoded value:</em>
  doc.add(new Field("exampleLong2", TrieUtils.longToPrefixCoded(lvalue), Field.Store.YES, Field.Index.NO));
  
  <em>// now add document to IndexWriter, as usual</em>
</pre>

<p><em>(for higher indexing performance, you can reuse the TokenStreams &ndash;
more info about this in the stream documentation)</em></p>

<h3>Searching</h3>

<p>The numeric index fields you prepared in this way can be searched by
{@link org.apache.lucene.search.trie.LongTrieRangeFilter} or {@link org.apache.lucene.search.trie.IntTrieRangeFilter}:</p>

<pre>
  <em>// Java 1.4, because Long.valueOf(long) is not available:</em>
  Query q = new LongTrieRangeFilter("exampleLong", precisionStep, new Long(123L), new Long(999999L), true, true).asQuery();
  
  <em>// OR, Java 1.5, using autoboxing:</em>
  Query q = new LongTrieRangeFilter("exampleLong", precisionStep, 123L, 999999L, true, true).asQuery();
  
  <em>// execute the search, as usual:</em>
  TopDocs docs = searcher.search(q, 10);
  for (int i = 0; i&lt;docs.scoreDocs.length; i++) {
    Document doc = searcher.doc(docs.scoreDocs[i].doc);
    System.out.println(doc.get("exampleString"));
    
    <em>// decode a prefix coded, stored field:</em>
    System.out.println(TrieUtils.prefixCodedToLong(doc.get("exampleLong2")));
  }
</pre>

<h3>Performance</h3>

<p>Comparisions of the different types of RangeQueries on an index with about 500,000 docs showed
that the old {@link org.apache.lucene.search.RangeQuery} (with raised 
{@link org.apache.lucene.search.BooleanQuery} clause count) took about 30-40 secs to complete,
{@link org.apache.lucene.search.ConstantScoreRangeQuery} took 5 secs and executing
{@link org.apache.lucene.search.trie.LongTrieRangeFilter}<code>.asQuery()</code> took &lt;100ms to
complete (on an Opteron64 machine, Java 1.5, 8 bit precision step).
This query type was developed for a geographic portal, where the performance for
e.g. bounding boxes or exact date/time stamps is important.</p>

</body>
</html>
