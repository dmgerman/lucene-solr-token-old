begin_unit
begin_package
DECL|package|org.apache.lucene.index.memory
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|memory
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Token
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldSelector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermFreqVector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermPositionVector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermPositions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|HitCollector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Searcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_comment
comment|/**  * High-performance single-document main memory Apache Lucene fulltext search index.   *   *<h4>Overview</h4>  *   * This class is a replacement/substitute for a large subset of  * {@link org.apache.lucene.store.RAMDirectory} functionality. It is designed to  * enable maximum efficiency for on-the-fly matchmaking combining structured and   * fuzzy fulltext search in realtime streaming applications such as Nux XQuery based XML   * message queues, publish-subscribe systems for Blogs/newsfeeds, text chat, data acquisition and   * distribution systems, application level routers, firewalls, classifiers, etc.   * Rather than targetting fulltext search of infrequent queries over huge persistent   * data archives (historic search), this class targets fulltext search of huge   * numbers of queries over comparatively small transient realtime data (prospective   * search).   * For example as in   *<pre>  * float score = search(String text, Query query)  *</pre>  *<p>  * Each instance can hold at most one Lucene "document", with a document containing  * zero or more "fields", each field having a name and a fulltext value. The  * fulltext value is tokenized (split and transformed) into zero or more index terms   * (aka words) on<code>addField()</code>, according to the policy implemented by an  * Analyzer. For example, Lucene analyzers can split on whitespace, normalize to lower case  * for case insensitivity, ignore common terms with little discriminatory value such as "he", "in", "and" (stop  * words), reduce the terms to their natural linguistic root form such as "fishing"  * being reduced to "fish" (stemming), resolve synonyms/inflexions/thesauri   * (upon indexing and/or querying), etc. For details, see  *<a target="_blank" href="http://today.java.net/pub/a/today/2003/07/30/LuceneIntro.html">Lucene Analyzer Intro</a>.  *<p>  * Arbitrary Lucene queries can be run against this class - see<a target="_blank"   * href="http://lucene.apache.org/java/docs/queryparsersyntax.html">Lucene Query Syntax</a>  * as well as<a target="_blank"   * href="http://today.java.net/pub/a/today/2003/11/07/QueryParserRules.html">Query Parser Rules</a>.  * Note that a Lucene query selects on the field names and associated (indexed)   * tokenized terms, not on the original fulltext(s) - the latter are not stored   * but rather thrown away immediately after tokenization.  *<p>  * For some interesting background information on search technology, see Bob Wyman's  *<a target="_blank"   * href="http://bobwyman.pubsub.com/main/2005/05/mary_hodder_poi.html">Prospective Search</a>,   * Jim Gray's  *<a target="_blank" href="http://www.acmqueue.org/modules.php?name=Content&pa=showpage&pid=293&page=4">  * A Call to Arms - Custom subscriptions</a>, and Tim Bray's  *<a target="_blank"   * href="http://www.tbray.org/ongoing/When/200x/2003/07/30/OnSearchTOC">On Search, the Series</a>.  *   *   *<h4>Example Usage</h4>   *   *<pre>  * Analyzer analyzer = PatternAnalyzer.DEFAULT_ANALYZER;  * //Analyzer analyzer = new SimpleAnalyzer();  * MemoryIndex index = new MemoryIndex();  * index.addField("content", "Readings about Salmons and other select Alaska fishing Manuals", analyzer);  * index.addField("author", "Tales of James", analyzer);  * QueryParser parser = new QueryParser("content", analyzer);  * float score = index.search(parser.parse("+author:james +salmon~ +fish* manual~"));  * if (score&gt; 0.0f) {  *     System.out.println("it's a match");  * } else {  *     System.out.println("no match found");  * }  * System.out.println("indexData=" + index.toString());  *</pre>  *   *   *<h4>Example XQuery Usage</h4>   *   *<pre>  * (: An XQuery that finds all books authored by James that have something to do with "salmon fishing manuals", sorted by relevance :)  * declare namespace lucene = "java:nux.xom.pool.FullTextUtil";  * declare variable $query := "+salmon~ +fish* manual~"; (: any arbitrary Lucene query can go here :)  *   * for $book in /books/book[author="James" and lucene:match(abstract, $query)> 0.0]  * let $score := lucene:match($book/abstract, $query)  * order by $score descending  * return $book  *</pre>  *   *   *<h4>No thread safety guarantees</h4>  *   * An instance can be queried multiple times with the same or different queries,  * but an instance is not thread-safe. If desired use idioms such as:  *<pre>  * MemoryIndex index = ...  * synchronized (index) {  *    // read and/or write index (i.e. add fields and/or query)  * }   *</pre>  *   *   *<h4>Performance Notes</h4>  *   * Internally there's a new data structure geared towards efficient indexing   * and searching, plus the necessary support code to seamlessly plug into the Lucene   * framework.  *<p>  * This class performs very well for very small texts (e.g. 10 chars)   * as well as for large texts (e.g. 10 MB) and everything in between.   * Typically, it is about 10-100 times faster than<code>RAMDirectory</code>.  * Note that<code>RAMDirectory</code> has particularly   * large efficiency overheads for small to medium sized texts, both in time and space.  * Indexing a field with N tokens takes O(N) in the best case, and O(N logN) in the worst   * case. Memory consumption is probably larger than for<code>RAMDirectory</code>.  *<p>  * If you're curious about  * the whereabouts of bottlenecks, run java 1.5 with the non-perturbing '-server  * -agentlib:hprof=cpu=samples,depth=10' flags, then study the trace log and  * correlate its hotspot trailer with its call stack headers (see<a  * target="_blank"  * href="http://java.sun.com/developer/technicalArticles/Programming/HPROF.html">  * hprof tracing</a>).  *   * @author whoschek.AT.lbl.DOT.gov  */
end_comment
begin_class
DECL|class|MemoryIndex
specifier|public
class|class
name|MemoryIndex
block|{
comment|/** info for each field: Map<String fieldName, Info field> */
DECL|field|fields
specifier|private
specifier|final
name|HashMap
name|fields
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|/** fields sorted ascending by fieldName; lazily computed on demand */
DECL|field|sortedFields
specifier|private
specifier|transient
name|Map
operator|.
name|Entry
index|[]
name|sortedFields
decl_stmt|;
comment|/** pos: positions[3*i], startOffset: positions[3*i +1], endOffset: positions[3*i +2] */
DECL|field|stride
specifier|private
specifier|final
name|int
name|stride
decl_stmt|;
comment|/** Could be made configurable; See {@link Document#setBoost(float)} */
DECL|field|docBoost
specifier|private
specifier|static
specifier|final
name|float
name|docBoost
init|=
literal|1.0f
decl_stmt|;
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2782195016849084649L
decl_stmt|;
DECL|field|DEBUG
specifier|private
specifier|static
specifier|final
name|boolean
name|DEBUG
init|=
literal|false
decl_stmt|;
comment|/**    * Sorts term entries into ascending order; also works for    * Arrays.binarySearch() and Arrays.sort()    */
DECL|field|termComparator
specifier|private
specifier|static
specifier|final
name|Comparator
name|termComparator
init|=
operator|new
name|Comparator
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Object
name|o1
parameter_list|,
name|Object
name|o2
parameter_list|)
block|{
if|if
condition|(
name|o1
operator|instanceof
name|Map
operator|.
name|Entry
condition|)
name|o1
operator|=
operator|(
operator|(
name|Map
operator|.
name|Entry
operator|)
name|o1
operator|)
operator|.
name|getKey
argument_list|()
expr_stmt|;
if|if
condition|(
name|o2
operator|instanceof
name|Map
operator|.
name|Entry
condition|)
name|o2
operator|=
operator|(
operator|(
name|Map
operator|.
name|Entry
operator|)
name|o2
operator|)
operator|.
name|getKey
argument_list|()
expr_stmt|;
if|if
condition|(
name|o1
operator|==
name|o2
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|String
operator|)
name|o1
operator|)
operator|.
name|compareTo
argument_list|(
operator|(
name|String
operator|)
name|o2
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Constructs an empty instance.    */
DECL|method|MemoryIndex
specifier|public
name|MemoryIndex
parameter_list|()
block|{
name|this
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs an empty instance that can optionally store the start and end    * character offset of each token term in the text. This can be useful for    * highlighting of hit locations with the Lucene highlighter package.    * Private until the highlighter package matures, so that this can actually    * be meaningfully integrated.    *     * @param storeOffsets    *            whether or not to store the start and end character offset of    *            each token term in the text    */
DECL|method|MemoryIndex
specifier|private
name|MemoryIndex
parameter_list|(
name|boolean
name|storeOffsets
parameter_list|)
block|{
name|this
operator|.
name|stride
operator|=
name|storeOffsets
condition|?
literal|3
else|:
literal|1
expr_stmt|;
block|}
comment|/**    * Convenience method; Tokenizes the given field text and adds the resulting    * terms to the index; Equivalent to adding a tokenized, indexed,    * termVectorStored, unstored, non-keyword Lucene    * {@link org.apache.lucene.document.Field}.    *     * @param fieldName    *            a name to be associated with the text    * @param text    *            the text to tokenize and index.    * @param analyzer    *            the analyzer to use for tokenization    */
DECL|method|addField
specifier|public
name|void
name|addField
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|String
name|text
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
block|{
if|if
condition|(
name|fieldName
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"fieldName must not be null"
argument_list|)
throw|;
if|if
condition|(
name|text
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"text must not be null"
argument_list|)
throw|;
if|if
condition|(
name|analyzer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"analyzer must not be null"
argument_list|)
throw|;
name|TokenStream
name|stream
decl_stmt|;
if|if
condition|(
name|analyzer
operator|instanceof
name|PatternAnalyzer
condition|)
block|{
name|stream
operator|=
operator|(
operator|(
name|PatternAnalyzer
operator|)
name|analyzer
operator|)
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stream
operator|=
name|analyzer
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
operator|new
name|PatternAnalyzer
operator|.
name|FastStringReader
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|addField
argument_list|(
name|fieldName
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/**    * Convenience method; Creates and returns a token stream that generates a    * token for each keyword in the given collection, "as is", without any    * transforming text analysis. The resulting token stream can be fed into    * {@link #addField(String, TokenStream)}, perhaps wrapped into another    * {@link org.apache.lucene.analysis.TokenFilter}, as desired.    *     * @param keywords    *            the keywords to generate tokens for    * @return the corresponding token stream    */
DECL|method|keywordTokenStream
specifier|public
name|TokenStream
name|keywordTokenStream
parameter_list|(
specifier|final
name|Collection
name|keywords
parameter_list|)
block|{
comment|// TODO: deprecate& move this method into AnalyzerUtil?
if|if
condition|(
name|keywords
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"keywords must not be null"
argument_list|)
throw|;
return|return
operator|new
name|TokenStream
argument_list|()
block|{
specifier|private
name|Iterator
name|iter
init|=
name|keywords
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|private
name|int
name|start
init|=
literal|0
decl_stmt|;
specifier|public
name|Token
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
return|return
literal|null
return|;
name|Object
name|obj
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"keyword must not be null"
argument_list|)
throw|;
name|String
name|term
init|=
name|obj
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Token
name|token
init|=
operator|new
name|Token
argument_list|(
name|term
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|term
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|start
operator|+=
name|term
operator|.
name|length
argument_list|()
operator|+
literal|1
expr_stmt|;
comment|// separate words by 1 (blank) character
return|return
name|token
return|;
block|}
block|}
return|;
block|}
comment|/**    * Equivalent to<code>addField(fieldName, stream, 1.0f)</code>.    *     * @param fieldName    *            a name to be associated with the text    * @param stream    *            the token stream to retrieve tokens from    */
DECL|method|addField
specifier|public
name|void
name|addField
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|TokenStream
name|stream
parameter_list|)
block|{
name|addField
argument_list|(
name|fieldName
argument_list|,
name|stream
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
block|}
comment|/**    * Iterates over the given token stream and adds the resulting terms to the index;    * Equivalent to adding a tokenized, indexed, termVectorStored, unstored,    * Lucene {@link org.apache.lucene.document.Field}.    * Finally closes the token stream. Note that untokenized keywords can be added with this method via     * {@link #keywordTokenStream(Collection)}, the Lucene contrib<code>KeywordTokenizer</code> or similar utilities.    *     * @param fieldName    *            a name to be associated with the text    * @param stream    *            the token stream to retrieve tokens from.    * @param boost    *            the boost factor for hits for this field    * @see Field#setBoost(float)    */
DECL|method|addField
specifier|public
name|void
name|addField
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|TokenStream
name|stream
parameter_list|,
name|float
name|boost
parameter_list|)
block|{
comment|/*      * Note that this method signature avoids having a user call new      * o.a.l.d.Field(...) which would be much too expensive due to the      * String.intern() usage of that class.      *       * More often than not, String.intern() leads to serious performance      * degradations rather than improvements! If you're curious why, check      * out the JDK's native code, see how it oscillates multiple times back      * and forth between Java code and native code on each intern() call,      * only to end up using a plain vanilla java.util.HashMap on the Java      * heap for it's interned strings! String.equals() has a small cost      * compared to String.intern(), trust me. Application level interning      * (e.g. a HashMap per Directory/Index) typically leads to better      * solutions than frequent hidden low-level calls to String.intern().      *       * Perhaps with some luck, Lucene's Field.java (and Term.java) and      * cousins could be fixed to not use String.intern(). Sigh :-(      */
try|try
block|{
if|if
condition|(
name|fieldName
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"fieldName must not be null"
argument_list|)
throw|;
if|if
condition|(
name|stream
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"token stream must not be null"
argument_list|)
throw|;
if|if
condition|(
name|boost
operator|<=
literal|0.0f
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"boost factor must be greater than 0.0"
argument_list|)
throw|;
if|if
condition|(
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field must not be added more than once"
argument_list|)
throw|;
name|HashMap
name|terms
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
name|int
name|numTokens
init|=
literal|0
decl_stmt|;
name|int
name|pos
init|=
operator|-
literal|1
decl_stmt|;
name|Token
name|token
decl_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|stream
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|String
name|term
init|=
name|token
operator|.
name|termText
argument_list|()
decl_stmt|;
if|if
condition|(
name|term
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
comment|// nothing to do
comment|//        if (DEBUG) System.err.println("token='" + term + "'");
name|numTokens
operator|++
expr_stmt|;
name|pos
operator|+=
name|token
operator|.
name|getPositionIncrement
argument_list|()
expr_stmt|;
name|ArrayIntList
name|positions
init|=
operator|(
name|ArrayIntList
operator|)
name|terms
operator|.
name|get
argument_list|(
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
name|positions
operator|==
literal|null
condition|)
block|{
comment|// term not seen before
name|positions
operator|=
operator|new
name|ArrayIntList
argument_list|(
name|stride
argument_list|)
expr_stmt|;
name|terms
operator|.
name|put
argument_list|(
name|term
argument_list|,
name|positions
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stride
operator|==
literal|1
condition|)
block|{
name|positions
operator|.
name|add
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|positions
operator|.
name|add
argument_list|(
name|pos
argument_list|,
name|token
operator|.
name|startOffset
argument_list|()
argument_list|,
name|token
operator|.
name|endOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ensure infos.numTokens> 0 invariant; needed for correct operation of terms()
if|if
condition|(
name|numTokens
operator|>
literal|0
condition|)
block|{
name|boost
operator|=
name|boost
operator|*
name|docBoost
expr_stmt|;
comment|// see DocumentWriter.addDocument(...)
name|fields
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
operator|new
name|Info
argument_list|(
name|terms
argument_list|,
name|numTokens
argument_list|,
name|boost
argument_list|)
argument_list|)
expr_stmt|;
name|sortedFields
operator|=
literal|null
expr_stmt|;
comment|// invalidate sorted view, if any
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// can never happen
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
try|try
block|{
if|if
condition|(
name|stream
operator|!=
literal|null
condition|)
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e2
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e2
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Creates and returns a searcher that can be used to execute arbitrary    * Lucene queries and to collect the resulting query results as hits.    *     * @return a searcher    */
DECL|method|createSearcher
specifier|public
name|IndexSearcher
name|createSearcher
parameter_list|()
block|{
name|MemoryIndexReader
name|reader
init|=
operator|new
name|MemoryIndexReader
argument_list|()
decl_stmt|;
name|IndexSearcher
name|searcher
init|=
operator|new
name|IndexSearcher
argument_list|(
name|reader
argument_list|)
decl_stmt|;
comment|// ensures no auto-close !!
name|reader
operator|.
name|setSearcher
argument_list|(
name|searcher
argument_list|)
expr_stmt|;
comment|// to later get hold of searcher.getSimilarity()
return|return
name|searcher
return|;
block|}
comment|/**    * Convenience method that efficiently returns the relevance score by    * matching this index against the given Lucene query expression.    *     * @param query    *            an arbitrary Lucene query to run against this index    * @return the relevance score of the matchmaking; A number in the range    *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number    *         the better the match.    * @see org.apache.lucene.queryParser.QueryParser#parse(String)    */
DECL|method|search
specifier|public
name|float
name|search
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
if|if
condition|(
name|query
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"query must not be null"
argument_list|)
throw|;
name|Searcher
name|searcher
init|=
name|createSearcher
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|float
index|[]
name|scores
init|=
operator|new
name|float
index|[
literal|1
index|]
decl_stmt|;
comment|// inits to 0.0f (no match)
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
operator|new
name|HitCollector
argument_list|()
block|{
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|,
name|float
name|score
parameter_list|)
block|{
name|scores
index|[
literal|0
index|]
operator|=
name|score
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|float
name|score
init|=
name|scores
index|[
literal|0
index|]
decl_stmt|;
return|return
name|score
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// can never happen (RAMDirectory)
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// searcher.close();
comment|/*        * Note that it is harmless and important for good performance to        * NOT close the index reader!!! This avoids all sorts of        * unnecessary baggage and locking in the Lucene IndexReader        * superclass, all of which is completely unnecessary for this main        * memory index data structure without thread-safety claims.        *         * Wishing IndexReader would be an interface...        *         * Actually with the new tight createSearcher() API auto-closing is now        * made impossible, hence searcher.close() would be harmless...        */
block|}
block|}
comment|/**    * Returns a reasonable approximation of the main memory [bytes] consumed by    * this instance. Useful for smart memory sensititive caches/pools. Assumes    * fieldNames are interned, whereas tokenized terms are memory-overlaid.    *     * @return the main memory consumption    */
DECL|method|getMemorySize
specifier|public
name|int
name|getMemorySize
parameter_list|()
block|{
comment|// for example usage in a smart cache see nux.xom.pool.Pool
name|int
name|PTR
init|=
name|VM
operator|.
name|PTR
decl_stmt|;
name|int
name|INT
init|=
name|VM
operator|.
name|INT
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
name|size
operator|+=
name|VM
operator|.
name|sizeOfObject
argument_list|(
literal|2
operator|*
name|PTR
operator|+
name|INT
argument_list|)
expr_stmt|;
comment|// memory index
if|if
condition|(
name|sortedFields
operator|!=
literal|null
condition|)
name|size
operator|+=
name|VM
operator|.
name|sizeOfObjectArray
argument_list|(
name|sortedFields
operator|.
name|length
argument_list|)
expr_stmt|;
name|size
operator|+=
name|VM
operator|.
name|sizeOfHashMap
argument_list|(
name|fields
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
name|iter
init|=
name|fields
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// for each Field Info
name|Map
operator|.
name|Entry
name|entry
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|Info
name|info
init|=
operator|(
name|Info
operator|)
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|size
operator|+=
name|VM
operator|.
name|sizeOfObject
argument_list|(
literal|2
operator|*
name|INT
operator|+
literal|3
operator|*
name|PTR
argument_list|)
expr_stmt|;
comment|// Info instance vars
if|if
condition|(
name|info
operator|.
name|sortedTerms
operator|!=
literal|null
condition|)
name|size
operator|+=
name|VM
operator|.
name|sizeOfObjectArray
argument_list|(
name|info
operator|.
name|sortedTerms
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|info
operator|.
name|terms
operator|.
name|size
argument_list|()
decl_stmt|;
name|size
operator|+=
name|VM
operator|.
name|sizeOfHashMap
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|Iterator
name|iter2
init|=
name|info
operator|.
name|terms
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
comment|// for each term
name|Map
operator|.
name|Entry
name|e
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|iter2
operator|.
name|next
argument_list|()
decl_stmt|;
name|size
operator|+=
name|VM
operator|.
name|sizeOfObject
argument_list|(
name|PTR
operator|+
literal|3
operator|*
name|INT
argument_list|)
expr_stmt|;
comment|// assumes substring() memory overlay
comment|//        size += STR + 2 * ((String) e.getKey()).length();
name|ArrayIntList
name|positions
init|=
operator|(
name|ArrayIntList
operator|)
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|size
operator|+=
name|VM
operator|.
name|sizeOfArrayIntList
argument_list|(
name|positions
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
DECL|method|numPositions
specifier|private
name|int
name|numPositions
parameter_list|(
name|ArrayIntList
name|positions
parameter_list|)
block|{
return|return
name|positions
operator|.
name|size
argument_list|()
operator|/
name|stride
return|;
block|}
comment|/** sorts into ascending order (on demand), reusing memory along the way */
DECL|method|sortFields
specifier|private
name|void
name|sortFields
parameter_list|()
block|{
if|if
condition|(
name|sortedFields
operator|==
literal|null
condition|)
name|sortedFields
operator|=
name|sort
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
comment|/** returns a view of the given map's entries, sorted ascending by key */
DECL|method|sort
specifier|private
specifier|static
name|Map
operator|.
name|Entry
index|[]
name|sort
parameter_list|(
name|HashMap
name|map
parameter_list|)
block|{
name|int
name|size
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
name|Map
operator|.
name|Entry
index|[]
name|entries
init|=
operator|new
name|Map
operator|.
name|Entry
index|[
name|size
index|]
decl_stmt|;
name|Iterator
name|iter
init|=
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|entries
index|[
name|i
index|]
operator|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
literal|1
condition|)
name|Arrays
operator|.
name|sort
argument_list|(
name|entries
argument_list|,
name|termComparator
argument_list|)
expr_stmt|;
return|return
name|entries
return|;
block|}
comment|/**    * Returns a String representation of the index data for debugging purposes.    *     * @return the string representation    */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuffer
name|result
init|=
operator|new
name|StringBuffer
argument_list|(
literal|256
argument_list|)
decl_stmt|;
name|sortFields
argument_list|()
expr_stmt|;
name|int
name|sumChars
init|=
literal|0
decl_stmt|;
name|int
name|sumPositions
init|=
literal|0
decl_stmt|;
name|int
name|sumTerms
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedFields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Map
operator|.
name|Entry
name|entry
init|=
name|sortedFields
index|[
name|i
index|]
decl_stmt|;
name|String
name|fieldName
init|=
operator|(
name|String
operator|)
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Info
name|info
init|=
operator|(
name|Info
operator|)
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|info
operator|.
name|sortTerms
argument_list|()
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|fieldName
operator|+
literal|":\n"
argument_list|)
expr_stmt|;
name|int
name|numChars
init|=
literal|0
decl_stmt|;
name|int
name|numPositions
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|info
operator|.
name|sortedTerms
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|Map
operator|.
name|Entry
name|e
init|=
name|info
operator|.
name|sortedTerms
index|[
name|j
index|]
decl_stmt|;
name|String
name|term
init|=
operator|(
name|String
operator|)
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ArrayIntList
name|positions
init|=
operator|(
name|ArrayIntList
operator|)
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|"\t'"
operator|+
name|term
operator|+
literal|"':"
operator|+
name|numPositions
argument_list|(
name|positions
argument_list|)
operator|+
literal|":"
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|positions
operator|.
name|toString
argument_list|(
name|stride
argument_list|)
argument_list|)
expr_stmt|;
comment|// ignore offsets
name|result
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|numPositions
operator|+=
name|numPositions
argument_list|(
name|positions
argument_list|)
expr_stmt|;
name|numChars
operator|+=
name|term
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|append
argument_list|(
literal|"\tterms="
operator|+
name|info
operator|.
name|sortedTerms
operator|.
name|length
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|", positions="
operator|+
name|numPositions
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|", Kchars="
operator|+
operator|(
name|numChars
operator|/
literal|1000.0f
operator|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sumPositions
operator|+=
name|numPositions
expr_stmt|;
name|sumChars
operator|+=
name|numChars
expr_stmt|;
name|sumTerms
operator|+=
name|info
operator|.
name|sortedTerms
operator|.
name|length
expr_stmt|;
block|}
name|result
operator|.
name|append
argument_list|(
literal|"\nfields="
operator|+
name|sortedFields
operator|.
name|length
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|", terms="
operator|+
name|sumTerms
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|", positions="
operator|+
name|sumPositions
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|", Kchars="
operator|+
operator|(
name|sumChars
operator|/
literal|1000.0f
operator|)
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
comment|///////////////////////////////////////////////////////////////////////////////
comment|// Nested classes:
comment|///////////////////////////////////////////////////////////////////////////////
comment|/**    * Index data structure for a field; Contains the tokenized term texts and    * their positions.    */
DECL|class|Info
specifier|private
specifier|static
specifier|final
class|class
name|Info
implements|implements
name|Serializable
block|{
comment|/**      * Term strings and their positions for this field: Map<String      * termText, ArrayIntList positions>      */
DECL|field|terms
specifier|private
specifier|final
name|HashMap
name|terms
decl_stmt|;
comment|/** Terms sorted ascending by term text; computed on demand */
DECL|field|sortedTerms
specifier|private
specifier|transient
name|Map
operator|.
name|Entry
index|[]
name|sortedTerms
decl_stmt|;
comment|/** Number of added tokens for this field */
DECL|field|numTokens
specifier|private
specifier|final
name|int
name|numTokens
decl_stmt|;
comment|/** Boost factor for hits for this field */
DECL|field|boost
specifier|private
specifier|final
name|float
name|boost
decl_stmt|;
comment|/** Term for this field's fieldName, lazily computed on demand */
DECL|field|template
specifier|public
specifier|transient
name|Term
name|template
decl_stmt|;
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2882195016849084649L
decl_stmt|;
DECL|method|Info
specifier|public
name|Info
parameter_list|(
name|HashMap
name|terms
parameter_list|,
name|int
name|numTokens
parameter_list|,
name|float
name|boost
parameter_list|)
block|{
name|this
operator|.
name|terms
operator|=
name|terms
expr_stmt|;
name|this
operator|.
name|numTokens
operator|=
name|numTokens
expr_stmt|;
name|this
operator|.
name|boost
operator|=
name|boost
expr_stmt|;
block|}
comment|/**      * Sorts hashed terms into ascending order, reusing memory along the      * way. Note that sorting is lazily delayed until required (often it's      * not required at all). If a sorted view is required then hashing +      * sort + binary search is still faster and smaller than TreeMap usage      * (which would be an alternative and somewhat more elegant approach,      * apart from more sophisticated Tries / prefix trees).      */
DECL|method|sortTerms
specifier|public
name|void
name|sortTerms
parameter_list|()
block|{
if|if
condition|(
name|sortedTerms
operator|==
literal|null
condition|)
name|sortedTerms
operator|=
name|sort
argument_list|(
name|terms
argument_list|)
expr_stmt|;
block|}
comment|/** note that the frequency can be calculated as numPosition(getPositions(x)) */
DECL|method|getPositions
specifier|public
name|ArrayIntList
name|getPositions
parameter_list|(
name|String
name|term
parameter_list|)
block|{
return|return
operator|(
name|ArrayIntList
operator|)
name|terms
operator|.
name|get
argument_list|(
name|term
argument_list|)
return|;
block|}
comment|/** note that the frequency can be calculated as numPosition(getPositions(x)) */
DECL|method|getPositions
specifier|public
name|ArrayIntList
name|getPositions
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
return|return
operator|(
name|ArrayIntList
operator|)
name|sortedTerms
index|[
name|pos
index|]
operator|.
name|getValue
argument_list|()
return|;
block|}
DECL|method|getBoost
specifier|public
name|float
name|getBoost
parameter_list|()
block|{
return|return
name|boost
return|;
block|}
block|}
comment|///////////////////////////////////////////////////////////////////////////////
comment|// Nested classes:
comment|///////////////////////////////////////////////////////////////////////////////
comment|/**    * Efficient resizable auto-expanding list holding<code>int</code> elements;    * implemented with arrays.    */
DECL|class|ArrayIntList
specifier|private
specifier|static
specifier|final
class|class
name|ArrayIntList
implements|implements
name|Serializable
block|{
DECL|field|elements
specifier|private
name|int
index|[]
name|elements
decl_stmt|;
DECL|field|size
specifier|private
name|int
name|size
init|=
literal|0
decl_stmt|;
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2282195016849084649L
decl_stmt|;
DECL|method|ArrayIntList
specifier|public
name|ArrayIntList
parameter_list|()
block|{
name|this
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
DECL|method|ArrayIntList
specifier|public
name|ArrayIntList
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
name|elements
operator|=
operator|new
name|int
index|[
name|initialCapacity
index|]
expr_stmt|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|int
name|elem
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
name|elements
operator|.
name|length
condition|)
name|ensureCapacity
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|elements
index|[
name|size
operator|++
index|]
operator|=
name|elem
expr_stmt|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
if|if
condition|(
name|size
operator|+
literal|3
operator|>
name|elements
operator|.
name|length
condition|)
name|ensureCapacity
argument_list|(
name|size
operator|+
literal|3
argument_list|)
expr_stmt|;
name|elements
index|[
name|size
index|]
operator|=
name|pos
expr_stmt|;
name|elements
index|[
name|size
operator|+
literal|1
index|]
operator|=
name|start
expr_stmt|;
name|elements
index|[
name|size
operator|+
literal|2
index|]
operator|=
name|end
expr_stmt|;
name|size
operator|+=
literal|3
expr_stmt|;
block|}
DECL|method|get
specifier|public
name|int
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|>=
name|size
condition|)
name|throwIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|elements
index|[
name|index
index|]
return|;
block|}
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
DECL|method|toArray
specifier|public
name|int
index|[]
name|toArray
parameter_list|(
name|int
name|stride
parameter_list|)
block|{
name|int
index|[]
name|arr
init|=
operator|new
name|int
index|[
name|size
argument_list|()
operator|/
name|stride
index|]
decl_stmt|;
if|if
condition|(
name|stride
operator|==
literal|1
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|elements
argument_list|,
literal|0
argument_list|,
name|arr
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|// fast path
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
name|stride
control|)
name|arr
index|[
name|i
index|]
operator|=
name|elements
index|[
name|j
index|]
expr_stmt|;
block|}
return|return
name|arr
return|;
block|}
DECL|method|ensureCapacity
specifier|private
name|void
name|ensureCapacity
parameter_list|(
name|int
name|minCapacity
parameter_list|)
block|{
name|int
name|newCapacity
init|=
name|Math
operator|.
name|max
argument_list|(
name|minCapacity
argument_list|,
operator|(
name|elements
operator|.
name|length
operator|*
literal|3
operator|)
operator|/
literal|2
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
index|[]
name|newElements
init|=
operator|new
name|int
index|[
name|newCapacity
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|elements
argument_list|,
literal|0
argument_list|,
name|newElements
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|elements
operator|=
name|newElements
expr_stmt|;
block|}
DECL|method|throwIndex
specifier|private
name|void
name|throwIndex
parameter_list|(
name|int
name|index
parameter_list|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"index: "
operator|+
name|index
operator|+
literal|", size: "
operator|+
name|size
argument_list|)
throw|;
block|}
comment|/** returns the first few positions (without offsets); debug only */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|(
name|int
name|stride
parameter_list|)
block|{
name|int
name|s
init|=
name|size
argument_list|()
operator|/
name|stride
decl_stmt|;
name|int
name|len
init|=
name|Math
operator|.
name|min
argument_list|(
literal|10
argument_list|,
name|s
argument_list|)
decl_stmt|;
comment|// avoid printing huge lists
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|(
literal|4
operator|*
name|len
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|get
argument_list|(
name|i
operator|*
name|stride
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len
operator|-
literal|1
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
name|s
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|", ..."
argument_list|)
expr_stmt|;
comment|// and some more...
name|buf
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|///////////////////////////////////////////////////////////////////////////////
comment|// Nested classes:
comment|///////////////////////////////////////////////////////////////////////////////
DECL|field|MATCH_ALL_TERM
specifier|private
specifier|static
specifier|final
name|Term
name|MATCH_ALL_TERM
init|=
operator|new
name|Term
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|)
decl_stmt|;
comment|/**    * Search support for Lucene framework integration; implements all methods    * required by the Lucene IndexReader contracts.    */
DECL|class|MemoryIndexReader
specifier|private
specifier|final
class|class
name|MemoryIndexReader
extends|extends
name|IndexReader
block|{
DECL|field|searcher
specifier|private
name|Searcher
name|searcher
decl_stmt|;
comment|// needed to find searcher.getSimilarity()
DECL|method|MemoryIndexReader
specifier|private
name|MemoryIndexReader
parameter_list|()
block|{
name|super
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// avoid as much superclass baggage as possible
block|}
comment|// lucene>= 1.9 or lucene-1.4.3 with patch removing "final" in superclass
DECL|method|finalize
specifier|protected
name|void
name|finalize
parameter_list|()
block|{}
DECL|method|getInfo
specifier|private
name|Info
name|getInfo
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
operator|(
name|Info
operator|)
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
DECL|method|getInfo
specifier|private
name|Info
name|getInfo
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
return|return
operator|(
name|Info
operator|)
name|sortedFields
index|[
name|pos
index|]
operator|.
name|getValue
argument_list|()
return|;
block|}
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|(
name|Term
name|term
parameter_list|)
block|{
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|term
operator|.
name|field
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|freq
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
name|freq
operator|=
name|info
operator|.
name|getPositions
argument_list|(
name|term
operator|.
name|text
argument_list|()
argument_list|)
operator|!=
literal|null
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.docFreq: "
operator|+
name|term
operator|+
literal|", freq:"
operator|+
name|freq
argument_list|)
expr_stmt|;
return|return
name|freq
return|;
block|}
DECL|method|terms
specifier|public
name|TermEnum
name|terms
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.terms()"
argument_list|)
expr_stmt|;
return|return
name|terms
argument_list|(
name|MATCH_ALL_TERM
argument_list|)
return|;
block|}
DECL|method|terms
specifier|public
name|TermEnum
name|terms
parameter_list|(
name|Term
name|term
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.terms: "
operator|+
name|term
argument_list|)
expr_stmt|;
name|int
name|i
decl_stmt|;
comment|// index into info.sortedTerms
name|int
name|j
decl_stmt|;
comment|// index into sortedFields
name|sortFields
argument_list|()
expr_stmt|;
if|if
condition|(
name|sortedFields
operator|.
name|length
operator|==
literal|1
operator|&&
name|sortedFields
index|[
literal|0
index|]
operator|.
name|getKey
argument_list|()
operator|==
name|term
operator|.
name|field
argument_list|()
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
comment|// fast path
block|}
else|else
block|{
name|j
operator|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|sortedFields
argument_list|,
name|term
operator|.
name|field
argument_list|()
argument_list|,
name|termComparator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
comment|// not found; choose successor
name|j
operator|=
operator|-
name|j
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|sortedFields
operator|.
name|length
condition|)
name|getInfo
argument_list|(
name|j
argument_list|)
operator|.
name|sortTerms
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// found
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|info
operator|.
name|sortTerms
argument_list|()
expr_stmt|;
name|i
operator|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|info
operator|.
name|sortedTerms
argument_list|,
name|term
operator|.
name|text
argument_list|()
argument_list|,
name|termComparator
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|// not found; choose successor
name|i
operator|=
operator|-
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|info
operator|.
name|sortedTerms
operator|.
name|length
condition|)
block|{
comment|// move to next successor
name|j
operator|++
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|sortedFields
operator|.
name|length
condition|)
name|getInfo
argument_list|(
name|j
argument_list|)
operator|.
name|sortTerms
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|final
name|int
name|ix
init|=
name|i
decl_stmt|;
specifier|final
name|int
name|jx
init|=
name|j
decl_stmt|;
return|return
operator|new
name|TermEnum
argument_list|()
block|{
specifier|private
name|int
name|i
init|=
name|ix
decl_stmt|;
comment|// index into info.sortedTerms
specifier|private
name|int
name|j
init|=
name|jx
decl_stmt|;
comment|// index into sortedFields
specifier|public
name|boolean
name|next
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"TermEnum.next"
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|sortedFields
operator|.
name|length
condition|)
return|return
literal|false
return|;
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|++
name|i
operator|<
name|info
operator|.
name|sortedTerms
operator|.
name|length
condition|)
return|return
literal|true
return|;
comment|// move to successor
name|j
operator|++
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|sortedFields
operator|.
name|length
condition|)
return|return
literal|false
return|;
name|getInfo
argument_list|(
name|j
argument_list|)
operator|.
name|sortTerms
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|Term
name|term
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"TermEnum.term: "
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|sortedFields
operator|.
name|length
condition|)
return|return
literal|null
return|;
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|info
operator|.
name|sortedTerms
operator|.
name|length
condition|)
return|return
literal|null
return|;
comment|//          if (DEBUG) System.err.println("TermEnum.term: " + i + ", " + info.sortedTerms[i].getKey());
return|return
name|createTerm
argument_list|(
name|info
argument_list|,
name|j
argument_list|,
operator|(
name|String
operator|)
name|info
operator|.
name|sortedTerms
index|[
name|i
index|]
operator|.
name|getKey
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|int
name|docFreq
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"TermEnum.docFreq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|sortedFields
operator|.
name|length
condition|)
return|return
literal|0
return|;
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|info
operator|.
name|sortedTerms
operator|.
name|length
condition|)
return|return
literal|0
return|;
return|return
name|numPositions
argument_list|(
name|info
operator|.
name|getPositions
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"TermEnum.close"
argument_list|)
expr_stmt|;
block|}
comment|/** Returns a new Term object, minimizing String.intern() overheads. */
specifier|private
name|Term
name|createTerm
parameter_list|(
name|Info
name|info
parameter_list|,
name|int
name|pos
parameter_list|,
name|String
name|text
parameter_list|)
block|{
comment|// Assertion: sortFields has already been called before
name|Term
name|template
init|=
name|info
operator|.
name|template
decl_stmt|;
if|if
condition|(
name|template
operator|==
literal|null
condition|)
block|{
comment|// not yet cached?
name|String
name|fieldName
init|=
operator|(
name|String
operator|)
name|sortedFields
index|[
name|pos
index|]
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|template
operator|=
operator|new
name|Term
argument_list|(
name|fieldName
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|info
operator|.
name|template
operator|=
name|template
expr_stmt|;
block|}
return|return
name|template
operator|.
name|createTerm
argument_list|(
name|text
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|method|termPositions
specifier|public
name|TermPositions
name|termPositions
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.termPositions"
argument_list|)
expr_stmt|;
return|return
operator|new
name|TermPositions
argument_list|()
block|{
specifier|private
name|boolean
name|hasNext
decl_stmt|;
specifier|private
name|int
name|cursor
init|=
literal|0
decl_stmt|;
specifier|private
name|ArrayIntList
name|current
decl_stmt|;
specifier|public
name|void
name|seek
parameter_list|(
name|Term
name|term
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".seek: "
operator|+
name|term
argument_list|)
expr_stmt|;
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|term
operator|.
name|field
argument_list|()
argument_list|)
decl_stmt|;
name|current
operator|=
name|info
operator|==
literal|null
condition|?
literal|null
else|:
name|info
operator|.
name|getPositions
argument_list|(
name|term
operator|.
name|text
argument_list|()
argument_list|)
expr_stmt|;
name|hasNext
operator|=
operator|(
name|current
operator|!=
literal|null
operator|)
expr_stmt|;
name|cursor
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|seek
parameter_list|(
name|TermEnum
name|termEnum
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".seekEnum"
argument_list|)
expr_stmt|;
name|seek
argument_list|(
name|termEnum
operator|.
name|term
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|doc
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".doc"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|public
name|int
name|freq
parameter_list|()
block|{
name|int
name|freq
init|=
name|current
operator|!=
literal|null
condition|?
name|numPositions
argument_list|(
name|current
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".freq: "
operator|+
name|freq
argument_list|)
expr_stmt|;
return|return
name|freq
return|;
block|}
specifier|public
name|boolean
name|next
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".next: "
operator|+
name|current
operator|+
literal|", oldHasNext="
operator|+
name|hasNext
argument_list|)
expr_stmt|;
name|boolean
name|next
init|=
name|hasNext
decl_stmt|;
name|hasNext
operator|=
literal|false
expr_stmt|;
return|return
name|next
return|;
block|}
specifier|public
name|int
name|read
parameter_list|(
name|int
index|[]
name|docs
parameter_list|,
name|int
index|[]
name|freqs
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".read: "
operator|+
name|docs
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasNext
condition|)
return|return
literal|0
return|;
name|hasNext
operator|=
literal|false
expr_stmt|;
name|docs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|freqs
index|[
literal|0
index|]
operator|=
name|freq
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
specifier|public
name|boolean
name|skipTo
parameter_list|(
name|int
name|target
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".skipTo: "
operator|+
name|target
argument_list|)
expr_stmt|;
return|return
name|next
argument_list|()
return|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".close"
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|nextPosition
parameter_list|()
block|{
comment|// implements TermPositions
name|int
name|pos
init|=
name|current
operator|.
name|get
argument_list|(
name|cursor
argument_list|)
decl_stmt|;
name|cursor
operator|+=
name|stride
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".nextPosition: "
operator|+
name|pos
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
block|}
return|;
block|}
DECL|method|termDocs
specifier|public
name|TermDocs
name|termDocs
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.termDocs"
argument_list|)
expr_stmt|;
return|return
name|termPositions
argument_list|()
return|;
block|}
DECL|method|getTermFreqVectors
specifier|public
name|TermFreqVector
index|[]
name|getTermFreqVectors
parameter_list|(
name|int
name|docNumber
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.getTermFreqVectors"
argument_list|)
expr_stmt|;
name|TermFreqVector
index|[]
name|vectors
init|=
operator|new
name|TermFreqVector
index|[
name|fields
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
comment|//      if (vectors.length == 0) return null;
name|Iterator
name|iter
init|=
name|fields
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vectors
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|fieldName
init|=
operator|(
name|String
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|vectors
index|[
name|i
index|]
operator|=
name|getTermFreqVector
argument_list|(
name|docNumber
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|vectors
return|;
block|}
DECL|method|getTermFreqVector
specifier|public
name|TermFreqVector
name|getTermFreqVector
parameter_list|(
name|int
name|docNumber
parameter_list|,
specifier|final
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.getTermFreqVector"
argument_list|)
expr_stmt|;
specifier|final
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
return|return
literal|null
return|;
comment|// TODO: or return empty vector impl???
name|info
operator|.
name|sortTerms
argument_list|()
expr_stmt|;
return|return
operator|new
name|TermPositionVector
argument_list|()
block|{
specifier|private
specifier|final
name|Map
operator|.
name|Entry
index|[]
name|sortedTerms
init|=
name|info
operator|.
name|sortedTerms
decl_stmt|;
specifier|public
name|String
name|getField
parameter_list|()
block|{
return|return
name|fieldName
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|sortedTerms
operator|.
name|length
return|;
block|}
specifier|public
name|String
index|[]
name|getTerms
parameter_list|()
block|{
name|String
index|[]
name|terms
init|=
operator|new
name|String
index|[
name|sortedTerms
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|sortedTerms
operator|.
name|length
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|terms
index|[
name|i
index|]
operator|=
operator|(
name|String
operator|)
name|sortedTerms
index|[
name|i
index|]
operator|.
name|getKey
argument_list|()
expr_stmt|;
block|}
return|return
name|terms
return|;
block|}
specifier|public
name|int
index|[]
name|getTermFrequencies
parameter_list|()
block|{
name|int
index|[]
name|freqs
init|=
operator|new
name|int
index|[
name|sortedTerms
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|sortedTerms
operator|.
name|length
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|freqs
index|[
name|i
index|]
operator|=
name|numPositions
argument_list|(
operator|(
name|ArrayIntList
operator|)
name|sortedTerms
index|[
name|i
index|]
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|freqs
return|;
block|}
specifier|public
name|int
name|indexOf
parameter_list|(
name|String
name|term
parameter_list|)
block|{
name|int
name|i
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|sortedTerms
argument_list|,
name|term
argument_list|,
name|termComparator
argument_list|)
decl_stmt|;
return|return
name|i
operator|>=
literal|0
condition|?
name|i
else|:
operator|-
literal|1
return|;
block|}
specifier|public
name|int
index|[]
name|indexesOf
parameter_list|(
name|String
index|[]
name|terms
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
index|[]
name|indexes
init|=
operator|new
name|int
index|[
name|len
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|indexes
index|[
name|i
index|]
operator|=
name|indexOf
argument_list|(
name|terms
index|[
name|start
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|indexes
return|;
block|}
comment|// lucene>= 1.4.3
specifier|public
name|int
index|[]
name|getTermPositions
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ArrayIntList
operator|)
name|sortedTerms
index|[
name|index
index|]
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|toArray
argument_list|(
name|stride
argument_list|)
return|;
block|}
comment|// lucene>= 1.9 (remove this method for lucene-1.4.3)
specifier|public
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermVectorOffsetInfo
index|[]
name|getOffsets
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|stride
operator|==
literal|1
condition|)
return|return
literal|null
return|;
comment|// no offsets stored
name|ArrayIntList
name|positions
init|=
operator|(
name|ArrayIntList
operator|)
name|sortedTerms
index|[
name|index
index|]
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|positions
operator|.
name|size
argument_list|()
decl_stmt|;
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermVectorOffsetInfo
index|[]
name|offsets
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermVectorOffsetInfo
index|[
name|size
operator|/
name|stride
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|1
init|;
name|j
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
name|stride
control|)
block|{
name|int
name|start
init|=
name|positions
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|int
name|end
init|=
name|positions
operator|.
name|get
argument_list|(
name|j
operator|+
literal|1
argument_list|)
decl_stmt|;
name|offsets
index|[
name|i
index|]
operator|=
operator|new
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermVectorOffsetInfo
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
return|return
name|offsets
return|;
block|}
block|}
return|;
block|}
DECL|method|getSimilarity
specifier|private
name|Similarity
name|getSimilarity
parameter_list|()
block|{
if|if
condition|(
name|searcher
operator|!=
literal|null
condition|)
return|return
name|searcher
operator|.
name|getSimilarity
argument_list|()
return|;
return|return
name|Similarity
operator|.
name|getDefault
argument_list|()
return|;
block|}
DECL|method|setSearcher
specifier|private
name|void
name|setSearcher
parameter_list|(
name|Searcher
name|searcher
parameter_list|)
block|{
name|this
operator|.
name|searcher
operator|=
name|searcher
expr_stmt|;
block|}
comment|/** performance hack: cache norms to avoid repeated expensive calculations */
DECL|field|cachedNorms
specifier|private
name|byte
index|[]
name|cachedNorms
decl_stmt|;
DECL|field|cachedFieldName
specifier|private
name|String
name|cachedFieldName
decl_stmt|;
DECL|field|cachedSimilarity
specifier|private
name|Similarity
name|cachedSimilarity
decl_stmt|;
DECL|method|norms
specifier|public
name|byte
index|[]
name|norms
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|byte
index|[]
name|norms
init|=
name|cachedNorms
decl_stmt|;
name|Similarity
name|sim
init|=
name|getSimilarity
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldName
operator|!=
name|cachedFieldName
operator|||
name|sim
operator|!=
name|cachedSimilarity
condition|)
block|{
comment|// not cached?
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|int
name|numTokens
init|=
name|info
operator|!=
literal|null
condition|?
name|info
operator|.
name|numTokens
else|:
literal|0
decl_stmt|;
name|float
name|n
init|=
name|sim
operator|.
name|lengthNorm
argument_list|(
name|fieldName
argument_list|,
name|numTokens
argument_list|)
decl_stmt|;
name|float
name|boost
init|=
name|info
operator|!=
literal|null
condition|?
name|info
operator|.
name|getBoost
argument_list|()
else|:
literal|1.0f
decl_stmt|;
name|n
operator|=
name|n
operator|*
name|boost
expr_stmt|;
comment|// see DocumentWriter.writeNorms(String segment)
name|byte
name|norm
init|=
name|Similarity
operator|.
name|encodeNorm
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|norms
operator|=
operator|new
name|byte
index|[]
block|{
name|norm
block|}
expr_stmt|;
comment|// cache it for future reuse
name|cachedNorms
operator|=
name|norms
expr_stmt|;
name|cachedFieldName
operator|=
name|fieldName
expr_stmt|;
name|cachedSimilarity
operator|=
name|sim
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.norms: "
operator|+
name|fieldName
operator|+
literal|":"
operator|+
name|n
operator|+
literal|":"
operator|+
name|norm
operator|+
literal|":"
operator|+
name|numTokens
argument_list|)
expr_stmt|;
block|}
return|return
name|norms
return|;
block|}
DECL|method|norms
specifier|public
name|void
name|norms
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.norms*: "
operator|+
name|fieldName
argument_list|)
expr_stmt|;
name|byte
index|[]
name|norms
init|=
name|norms
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|norms
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|,
name|offset
argument_list|,
name|norms
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|doSetNorm
specifier|protected
name|void
name|doSetNorm
parameter_list|(
name|int
name|doc
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|byte
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|numDocs
specifier|public
name|int
name|numDocs
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.numDocs"
argument_list|)
expr_stmt|;
return|return
name|fields
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
return|;
block|}
DECL|method|maxDoc
specifier|public
name|int
name|maxDoc
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.maxDoc"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
DECL|method|document
specifier|public
name|Document
name|document
parameter_list|(
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.document"
argument_list|)
expr_stmt|;
return|return
operator|new
name|Document
argument_list|()
return|;
comment|// there are no stored fields
block|}
comment|//When we convert to JDK 1.5 make this Set<String>
DECL|method|document
specifier|public
name|Document
name|document
parameter_list|(
name|int
name|n
parameter_list|,
name|FieldSelector
name|fieldSelector
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.document"
argument_list|)
expr_stmt|;
return|return
operator|new
name|Document
argument_list|()
return|;
comment|// there are no stored fields
block|}
DECL|method|isDeleted
specifier|public
name|boolean
name|isDeleted
parameter_list|(
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.isDeleted"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|method|hasDeletions
specifier|public
name|boolean
name|hasDeletions
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.hasDeletions"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|method|doDelete
specifier|protected
name|void
name|doDelete
parameter_list|(
name|int
name|docNum
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|doUndeleteAll
specifier|protected
name|void
name|doUndeleteAll
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|doCommit
specifier|protected
name|void
name|doCommit
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.doCommit"
argument_list|)
expr_stmt|;
block|}
DECL|method|doClose
specifier|protected
name|void
name|doClose
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.doClose"
argument_list|)
expr_stmt|;
block|}
comment|// lucene>= 1.9 (remove this method for lucene-1.4.3)
DECL|method|getFieldNames
specifier|public
name|Collection
name|getFieldNames
parameter_list|(
name|FieldOption
name|fieldOption
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.getFieldNamesOption"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldOption
operator|==
name|FieldOption
operator|.
name|UNINDEXED
condition|)
return|return
name|Collections
operator|.
name|EMPTY_SET
return|;
if|if
condition|(
name|fieldOption
operator|==
name|FieldOption
operator|.
name|INDEXED_NO_TERMVECTOR
condition|)
return|return
name|Collections
operator|.
name|EMPTY_SET
return|;
if|if
condition|(
name|fieldOption
operator|==
name|FieldOption
operator|.
name|TERMVECTOR_WITH_OFFSET
operator|&&
name|stride
operator|==
literal|1
condition|)
return|return
name|Collections
operator|.
name|EMPTY_SET
return|;
if|if
condition|(
name|fieldOption
operator|==
name|FieldOption
operator|.
name|TERMVECTOR_WITH_POSITION_OFFSET
operator|&&
name|stride
operator|==
literal|1
condition|)
return|return
name|Collections
operator|.
name|EMPTY_SET
return|;
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|fields
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|///////////////////////////////////////////////////////////////////////////////
comment|// Nested classes:
comment|///////////////////////////////////////////////////////////////////////////////
DECL|class|VM
specifier|private
specifier|static
specifier|final
class|class
name|VM
block|{
DECL|field|PTR
specifier|public
specifier|static
specifier|final
name|int
name|PTR
init|=
name|is64BitVM
argument_list|()
condition|?
literal|8
else|:
literal|4
decl_stmt|;
comment|// bytes occupied by primitive data types
DECL|field|BOOLEAN
specifier|public
specifier|static
specifier|final
name|int
name|BOOLEAN
init|=
literal|1
decl_stmt|;
DECL|field|BYTE
specifier|public
specifier|static
specifier|final
name|int
name|BYTE
init|=
literal|1
decl_stmt|;
DECL|field|CHAR
specifier|public
specifier|static
specifier|final
name|int
name|CHAR
init|=
literal|2
decl_stmt|;
DECL|field|SHORT
specifier|public
specifier|static
specifier|final
name|int
name|SHORT
init|=
literal|2
decl_stmt|;
DECL|field|INT
specifier|public
specifier|static
specifier|final
name|int
name|INT
init|=
literal|4
decl_stmt|;
DECL|field|LONG
specifier|public
specifier|static
specifier|final
name|int
name|LONG
init|=
literal|8
decl_stmt|;
DECL|field|FLOAT
specifier|public
specifier|static
specifier|final
name|int
name|FLOAT
init|=
literal|4
decl_stmt|;
DECL|field|DOUBLE
specifier|public
specifier|static
specifier|final
name|int
name|DOUBLE
init|=
literal|8
decl_stmt|;
comment|/**      * Object header of any heap allocated Java object.       * ptr to class, info for monitor, gc, hash, etc.      */
DECL|field|OBJECT_HEADER
specifier|private
specifier|static
specifier|final
name|int
name|OBJECT_HEADER
init|=
literal|2
operator|*
literal|4
decl_stmt|;
comment|// typically even on 64 bit VMs
comment|//  private static final int OBJECT_HEADER = 2*PTR;
comment|/** 	 * Modern VMs tend to trade space for time, allocating memory on word 	 * boundaries. For example, on a 64 bit VM, the variables of a class with 	 * one 32 bit integer and one Java char really consume 8 bytes instead of 6 	 * bytes. 2 bytes are spent on padding. Similary, on a 64 bit VM a 	 * java.lang.Integer consumes OBJECT_HEADER + 8 bytes rather than 	 * OBJECT_HEADER + 4 bytes. 	 */
DECL|field|IS_WORD_ALIGNED_VM
specifier|private
specifier|static
specifier|final
name|boolean
name|IS_WORD_ALIGNED_VM
init|=
literal|true
decl_stmt|;
DECL|method|VM
specifier|private
name|VM
parameter_list|()
block|{}
comment|// not instantiable
comment|//  assumes n> 0
comment|//  64 bit VM:
comment|//    0     --> 0*PTR
comment|//    1..8  --> 1*PTR
comment|//    9..16 --> 2*PTR
DECL|method|sizeOf
specifier|private
specifier|static
name|int
name|sizeOf
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
name|IS_WORD_ALIGNED_VM
condition|?
operator|(
operator|(
name|n
operator|-
literal|1
operator|)
operator|/
name|PTR
operator|+
literal|1
operator|)
operator|*
name|PTR
else|:
name|n
return|;
block|}
DECL|method|sizeOfObject
specifier|public
specifier|static
name|int
name|sizeOfObject
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
name|sizeOf
argument_list|(
name|OBJECT_HEADER
operator|+
name|n
argument_list|)
return|;
block|}
DECL|method|sizeOfObjectArray
specifier|public
specifier|static
name|int
name|sizeOfObjectArray
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|sizeOfObject
argument_list|(
name|INT
operator|+
name|PTR
operator|*
name|len
argument_list|)
return|;
block|}
DECL|method|sizeOfCharArray
specifier|public
specifier|static
name|int
name|sizeOfCharArray
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|sizeOfObject
argument_list|(
name|INT
operator|+
name|CHAR
operator|*
name|len
argument_list|)
return|;
block|}
DECL|method|sizeOfIntArray
specifier|public
specifier|static
name|int
name|sizeOfIntArray
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|sizeOfObject
argument_list|(
name|INT
operator|+
name|INT
operator|*
name|len
argument_list|)
return|;
block|}
DECL|method|sizeOfString
specifier|public
specifier|static
name|int
name|sizeOfString
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|sizeOfObject
argument_list|(
literal|3
operator|*
name|INT
operator|+
name|PTR
argument_list|)
operator|+
name|sizeOfCharArray
argument_list|(
name|len
argument_list|)
return|;
block|}
DECL|method|sizeOfHashMap
specifier|public
specifier|static
name|int
name|sizeOfHashMap
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|sizeOfObject
argument_list|(
literal|4
operator|*
name|PTR
operator|+
literal|4
operator|*
name|INT
argument_list|)
operator|+
name|sizeOfObjectArray
argument_list|(
name|len
argument_list|)
operator|+
name|len
operator|*
name|sizeOfObject
argument_list|(
literal|3
operator|*
name|PTR
operator|+
name|INT
argument_list|)
return|;
comment|// entries
block|}
comment|// note: does not include referenced objects
DECL|method|sizeOfArrayList
specifier|public
specifier|static
name|int
name|sizeOfArrayList
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|sizeOfObject
argument_list|(
name|PTR
operator|+
literal|2
operator|*
name|INT
argument_list|)
operator|+
name|sizeOfObjectArray
argument_list|(
name|len
argument_list|)
return|;
block|}
DECL|method|sizeOfArrayIntList
specifier|public
specifier|static
name|int
name|sizeOfArrayIntList
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|sizeOfObject
argument_list|(
name|PTR
operator|+
name|INT
argument_list|)
operator|+
name|sizeOfIntArray
argument_list|(
name|len
argument_list|)
return|;
block|}
DECL|method|is64BitVM
specifier|private
specifier|static
name|boolean
name|is64BitVM
parameter_list|()
block|{
try|try
block|{
name|int
name|bits
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"sun.arch.data.model"
argument_list|,
literal|0
argument_list|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|bits
operator|!=
literal|0
condition|)
return|return
name|bits
operator|==
literal|64
return|;
comment|// fallback if sun.arch.data.model isn't available
return|return
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.vm.name"
argument_list|)
operator|.
name|toLowerCase
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"64"
argument_list|)
operator|>=
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
return|return
literal|false
return|;
comment|// better safe than sorry (applets, security managers, etc.) ...
block|}
block|}
block|}
block|}
end_class
end_unit
