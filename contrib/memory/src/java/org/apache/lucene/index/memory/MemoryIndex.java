begin_unit
begin_package
DECL|package|org.apache.lucene.index.memory
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|memory
package|;
end_package
begin_comment
comment|/**  * Copyright 2005 The Apache Software Foundation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Token
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermFreqVector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermPositionVector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermPositions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|HitCollector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Searcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Similarity
import|;
end_import
begin_comment
comment|/**  * High-performance single-document main memory Apache Lucene fulltext search index.   *   *<h4>Overview</h4>  *   * This class is a replacement/substitute for a large subset of  * {@link org.apache.lucene.store.RAMDirectory} functionality. It is designed to  * enable maximum efficiency for on-the-fly matchmaking combining structured and   * fuzzy full-text search in streaming applications such as Nux XQuery based XML   * message queues, publish-subscribe systems for newsfeeds, data acquisition and   * distribution systems, application level routers, firewalls, classifiers, etc.   * For example as in<code>float score = query(String text, Query query)</code>.  *<p>  * Each instance can hold at most one Lucene "document", with a document containing  * zero or more "fields", each field having a name and a free text value. The  * free text value is tokenized (split and transformed) into zero or more index terms   * (aka words) on<code>addField()</code>, according to the policy implemented by an  * Analyzer. For example, Lucene analyzers can split on whitespace, normalize to lower case  * for case insensitivity, ignore common terms with little discriminatory value such as "he", "in", "and" (stop  * words), reduce the terms to their natural linguistic root form such as "fishing"  * being reduced to "fish" (stemming), resolve synonyms/inflexions/thesauri   * (upon indexing and/or querying), etc. For details, see  *<a target="_blank" href="http://today.java.net/pub/a/today/2003/07/30/LuceneIntro.html">Lucene Analyzer Intro</a>.  *<p>  * Arbitrary Lucene queries can be run against this class - see<a target="_blank"   * href="http://lucene.apache.org/java/docs/queryparsersyntax.html">Lucene Query Syntax</a>  * as well as<a target="_blank"   * href="http://today.java.net/pub/a/today/2003/11/07/QueryParserRules.html">Query Parser Rules</a>.  * Note that a Lucene query selects on the field names and associated (indexed)   * tokenized terms, not on the original free text(s) - the latter are not stored   * but rather thrown away immediately after tokenization.  *<p>  * For some interesting background information on search technology, see   *<a target="_blank"   * href="http://www.tbray.org/ongoing/When/200x/2003/07/30/OnSearchTOC">On Search, the Series</a>.  *   *   *<h4>Example Usage</h4>   *   *<pre>  * Analyzer analyzer = new PatternAnalyzer.DEFAULT_ANALYZER;  * //Analyzer analyzer = new SimpleAnalyzer();  * MemoryIndex index = new MemoryIndex();  * index.addField("content", "James is in the woods", analyzer);  * index.addField("title", "Tales of James", analyzer);  * float score = index.query(QueryParser.parse("woods AND title:tales", "content", analyzer));  * if (score&gt; 0.0f) {  *     System.out.println("it's a match");  * } else {  *     System.out.println("no match found");  * }  * score = index.query(QueryParser.parse("wood* AND title:tale~0.2", "content", analyzer));  * System.out.println("score=" + score);  * System.out.println("indexData=" + index.toString());  *</pre>  *   *   *<h4>Example XQuery Usage</h4>   *   *<pre>  * (: An XQuery that finds all books authored by James that have something to do with "fish", sorted by relevance :)  * declare namespace lucene = "java:nux.xom.pool.FullTextUtil";  * declare variable $query := "fish~"; (: any arbitrary Lucene query can go here :)  *   * for $book in /books/book[author="James" and lucene:match(string(./abstract), $query)> 0.0]  * let $score := lucene:match(string($book/abstract), $query)  * order by $score descending  * return (&lt;score>{$score}</score>, $book)  *</pre>  *   *   *<h4>No thread safety guarantees</h4>  *   * An instance can be queried multiple times with the same or different queries,  * but an instance is not thread-safe. If desired use idioms such as:  *<pre>  * MemoryIndex index = ...  * synchronized (index) {  *    // read and/or write index (i.e. add fields and/or query)  * }   *</pre>  *   *   *<h4>Performance Notes</h4>  *   * Internally there's a new data structure geared towards efficient indexing   * and searching, plus the necessary support code to seamlessly plug into the Lucene   * framework.  *<p>  * This class performs very well for very small texts (e.g. 10 chars)   * as well as for large texts (e.g. 10 MB) and everything in between.   * Typically, it is about 10-100 times faster than<code>RAMDirectory</code>.  * Note that<code>RAMDirectory</code> has particularly   * large efficiency overheads for small to medium sized texts, both in time and space.  * Indexing a field with N tokens takes O(N) in the best case, and O(N logN) in the worst   * case. Memory consumption is probably larger than for<code>RAMDirectory</code>.  *<p>  * If you're curious about  * the whereabouts of bottlenecks, run java 1.5 with the non-perturbing '-server  * -agentlib:hprof=cpu=samples,depth=10' flags, then study the trace log and  * correlate its hotspot trailer with its call stack headers (see<a  * target="_blank"  * href="http://java.sun.com/developer/technicalArticles/Programming/HPROF.html">  * hprof tracing</a>).  *   * @author whoschek.AT.lbl.DOT.gov  */
end_comment
begin_class
DECL|class|MemoryIndex
specifier|public
class|class
name|MemoryIndex
block|{
comment|/** info for each field: Map<String fieldName, Info field> */
DECL|field|fields
specifier|private
specifier|final
name|HashMap
name|fields
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|/** fields sorted ascending by fieldName; lazily computed on demand */
DECL|field|sortedFields
specifier|private
specifier|transient
name|Map
operator|.
name|Entry
index|[]
name|sortedFields
decl_stmt|;
comment|/** pos: positions[3*i], startOffset: positions[3*(i+1)], endOffset: positions[3*(i+2)] */
DECL|field|stride
specifier|private
specifier|final
name|int
name|stride
decl_stmt|;
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2782195016849084649L
decl_stmt|;
DECL|field|DEBUG
specifier|private
specifier|static
specifier|final
name|boolean
name|DEBUG
init|=
literal|false
decl_stmt|;
comment|/** 	 * Sorts term entries into ascending order; also works for 	 * Arrays.binarySearch() and Arrays.sort() 	 */
DECL|field|termComparator
specifier|private
specifier|static
specifier|final
name|Comparator
name|termComparator
init|=
operator|new
name|Comparator
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Object
name|o1
parameter_list|,
name|Object
name|o2
parameter_list|)
block|{
if|if
condition|(
name|o1
operator|instanceof
name|Map
operator|.
name|Entry
condition|)
block|{
name|o1
operator|=
operator|(
operator|(
name|Map
operator|.
name|Entry
operator|)
name|o1
operator|)
operator|.
name|getKey
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|o2
operator|instanceof
name|Map
operator|.
name|Entry
condition|)
block|{
name|o2
operator|=
operator|(
operator|(
name|Map
operator|.
name|Entry
operator|)
name|o2
operator|)
operator|.
name|getKey
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|String
operator|)
name|o1
operator|)
operator|.
name|compareTo
argument_list|(
operator|(
name|String
operator|)
name|o2
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/** 	 * Constructs an instance. 	 */
DECL|method|MemoryIndex
specifier|public
name|MemoryIndex
parameter_list|()
block|{
name|this
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Constructs an instance that can optionally store the start and end 	 * character offset of each token term in the text. This can be useful for 	 * highlighting of hit locations with the Lucene highlighter package. 	 * Private until the highlighter package matures, so that this can actually 	 * be meaningfully integrated. 	 *  	 * @param storeOffsets 	 *            whether or not to store the start and end character offset of 	 *            each token term in the text 	 */
DECL|method|MemoryIndex
specifier|private
name|MemoryIndex
parameter_list|(
name|boolean
name|storeOffsets
parameter_list|)
block|{
name|this
operator|.
name|stride
operator|=
name|storeOffsets
condition|?
literal|3
else|:
literal|1
expr_stmt|;
block|}
comment|/** 	 * Convenience method; Tokenizes the given field text and adds the resulting 	 * terms to the index; Equivalent to adding a tokenized, indexed, 	 * termVectorStored, unstored, non-keyword Lucene 	 * {@link org.apache.lucene.document.Field}. 	 *  	 * @param fieldName 	 *            a name to be associated with the text 	 * @param text 	 *            the text to tokenize and index. 	 * @param analyzer 	 *            the analyzer to use for tokenization 	 */
DECL|method|addField
specifier|public
name|void
name|addField
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|String
name|text
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
block|{
if|if
condition|(
name|fieldName
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"fieldName must not be null"
argument_list|)
throw|;
if|if
condition|(
name|text
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"text must not be null"
argument_list|)
throw|;
if|if
condition|(
name|analyzer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"analyzer must not be null"
argument_list|)
throw|;
name|TokenStream
name|stream
decl_stmt|;
if|if
condition|(
name|analyzer
operator|instanceof
name|PatternAnalyzer
condition|)
block|{
name|stream
operator|=
operator|(
operator|(
name|PatternAnalyzer
operator|)
name|analyzer
operator|)
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stream
operator|=
name|analyzer
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
operator|new
name|StringReader
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|addField
argument_list|(
name|fieldName
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Iterates over the given token stream and adds the resulting terms to the index; 	 * Equivalent to adding a tokenized, indexed, termVectorStored, unstored, 	 * Lucene {@link org.apache.lucene.document.Field}. 	 * Finally closes the token stream. Note that untokenized keywords can be added with this method via  	 * the Lucene contrib<code>KeywordTokenizer</code> or similar utilities. 	 *  	 * @param fieldName 	 *            a name to be associated with the text 	 * @param stream 	 *            the token stream to retrieve tokens from. 	 */
DECL|method|addField
specifier|public
name|void
name|addField
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|TokenStream
name|stream
parameter_list|)
block|{
comment|/* 		 * Note that this method signature avoids having a user call new 		 * o.a.l.d.Field(...) which would be much too expensive due to the 		 * String.intern() usage of that class. 		 *  		 * More often than not, String.intern() leads to serious performance 		 * degradations rather than improvements! If you're curious why, check 		 * out the JDK's native code, see how it oscillates multiple times back 		 * and forth between Java code and native code on each intern() call, 		 * only to end up using a plain vanilla java.util.HashMap on the Java 		 * heap for it's interned strings! String.equals() has a small cost 		 * compared to String.intern(), trust me. Application level interning 		 * (e.g. a HashMap per Directory/Index) typically leads to better 		 * solutions than frequent hidden low-level calls to String.intern(). 		 *  		 * Perhaps with some luck, Lucene's Field.java (and Term.java) and 		 * cousins could be fixed to not use String.intern(). Sigh :-( 		 */
try|try
block|{
if|if
condition|(
name|fieldName
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"fieldName must not be null"
argument_list|)
throw|;
if|if
condition|(
name|stream
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"token stream must not be null"
argument_list|)
throw|;
if|if
condition|(
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field must not be added more than once"
argument_list|)
throw|;
name|HashMap
name|terms
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
name|int
name|numTokens
init|=
literal|0
decl_stmt|;
name|int
name|pos
init|=
operator|-
literal|1
decl_stmt|;
name|Token
name|token
decl_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|stream
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|numTokens
operator|++
expr_stmt|;
name|pos
operator|+=
name|token
operator|.
name|getPositionIncrement
argument_list|()
expr_stmt|;
name|String
name|term
init|=
name|token
operator|.
name|termText
argument_list|()
decl_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"token='"
operator|+
name|term
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|ArrayIntList
name|positions
init|=
operator|(
name|ArrayIntList
operator|)
name|terms
operator|.
name|get
argument_list|(
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
name|positions
operator|==
literal|null
condition|)
block|{
comment|// term not seen before
name|positions
operator|=
operator|new
name|ArrayIntList
argument_list|(
name|stride
argument_list|)
expr_stmt|;
name|terms
operator|.
name|put
argument_list|(
name|term
argument_list|,
name|positions
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stride
operator|==
literal|1
condition|)
name|positions
operator|.
name|add
argument_list|(
name|pos
argument_list|)
expr_stmt|;
else|else
name|positions
operator|.
name|add
argument_list|(
name|pos
argument_list|,
name|token
operator|.
name|startOffset
argument_list|()
argument_list|,
name|token
operator|.
name|endOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// ensure infos.numTokens> 0 invariant; needed for correct operation of terms()
if|if
condition|(
name|numTokens
operator|>
literal|0
condition|)
block|{
name|fields
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
operator|new
name|Info
argument_list|(
name|terms
argument_list|,
name|numTokens
argument_list|)
argument_list|)
expr_stmt|;
name|sortedFields
operator|=
literal|null
expr_stmt|;
comment|// invalidate sorted view, if any
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// can never happen
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
try|try
block|{
if|if
condition|(
name|stream
operator|!=
literal|null
condition|)
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e2
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e2
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** 	 * Creates and returns a searcher that can be used to execute arbitrary 	 * Lucene queries and to collect the resulting query results as hits. 	 */
DECL|method|createSearcher
specifier|public
name|IndexSearcher
name|createSearcher
parameter_list|()
block|{
name|MemoryIndexReader
name|reader
init|=
operator|new
name|MemoryIndexReader
argument_list|()
decl_stmt|;
name|IndexSearcher
name|searcher
init|=
operator|new
name|IndexSearcher
argument_list|(
name|reader
argument_list|)
decl_stmt|;
comment|// ensures no auto-close !!
name|reader
operator|.
name|setSearcher
argument_list|(
name|searcher
argument_list|)
expr_stmt|;
comment|// to later get hold of searcher.getSimilarity()
return|return
name|searcher
return|;
block|}
comment|/** 	 * Convenience method that efficiently returns the relevance score by 	 * matching this index against the given Lucene query expression. 	 *  	 * @param query 	 *            an arbitrary Lucene query to run against this index 	 * @return the relevance score of the matchmaking; A number in the range 	 *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number 	 *         the better the match. 	 * @see org.apache.lucene.queryParser.QueryParser#parse(String, String, 	 *      Analyzer) 	 */
DECL|method|search
specifier|public
name|float
name|search
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
if|if
condition|(
name|query
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"query must not be null"
argument_list|)
throw|;
if|if
condition|(
name|fields
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|0.0f
return|;
comment|// nothing to do
name|Searcher
name|searcher
init|=
name|createSearcher
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|float
index|[]
name|scores
init|=
operator|new
name|float
index|[
literal|1
index|]
decl_stmt|;
comment|// inits to 0.0f (no match)
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
operator|new
name|HitCollector
argument_list|()
block|{
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|,
name|float
name|score
parameter_list|)
block|{
name|scores
index|[
literal|0
index|]
operator|=
name|score
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|float
name|score
init|=
name|scores
index|[
literal|0
index|]
decl_stmt|;
return|return
name|score
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// can never happen (RAMDirectory)
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// searcher.close();
comment|/* 			 * Note that it is harmless and important for good performance to 			 * NOT close the index reader!!! This avoids all sorts of 			 * unnecessary baggage and locking in the Lucene IndexReader 			 * superclass, all of which is completely unnecessary for this main 			 * memory index data structure without thread-safety claims. 			 *  			 * Wishing IndexReader would be an interface... 			 *  			 * Actually with the new tight createSearcher() API auto-closing is now 			 * made impossible, hence searcher.close() would be harmless... 			 */
block|}
block|}
comment|/** 	 * Returns a reasonable approximation of the main memory [bytes] consumed by 	 * this instance. Useful for smart memory sensititve caches/pools. Assumes 	 * fieldNames are interned, whereas tokenized terms are memory-overlaid. For 	 * simplicity, assumes no VM word boundary alignment of instance vars. 	 */
DECL|method|getMemorySize
specifier|public
name|int
name|getMemorySize
parameter_list|()
block|{
comment|// for example usage in a smart cache see nux.xom.pool.Pool
name|int
name|HEADER
init|=
literal|12
decl_stmt|;
comment|// object header of any java object
name|int
name|PTR
init|=
literal|4
decl_stmt|;
comment|// pointer on 32 bit VMs
name|int
name|ARR
init|=
name|HEADER
operator|+
literal|4
decl_stmt|;
name|int
name|STR
init|=
name|HEADER
operator|+
literal|3
operator|*
literal|4
operator|+
name|PTR
operator|+
name|ARR
decl_stmt|;
comment|// string
name|int
name|INTARRLIST
init|=
name|HEADER
operator|+
literal|4
operator|+
name|PTR
operator|+
name|ARR
decl_stmt|;
name|int
name|HASHMAP
init|=
name|HEADER
operator|+
literal|4
operator|*
name|PTR
operator|+
literal|4
operator|*
literal|4
operator|+
name|ARR
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
name|size
operator|+=
name|HEADER
operator|+
literal|3
operator|*
name|PTR
expr_stmt|;
comment|// memory index
if|if
condition|(
name|sortedFields
operator|!=
literal|null
condition|)
name|size
operator|+=
name|ARR
operator|+
name|PTR
operator|*
name|sortedFields
operator|.
name|length
expr_stmt|;
name|size
operator|+=
name|HASHMAP
operator|+
name|fields
operator|.
name|size
argument_list|()
operator|*
operator|(
name|PTR
operator|+
name|HEADER
operator|+
literal|3
operator|*
name|PTR
operator|+
literal|4
operator|)
expr_stmt|;
comment|// Map.entries
name|Iterator
name|iter
init|=
name|fields
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// for each Field Info
name|Map
operator|.
name|Entry
name|entry
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|Info
name|info
init|=
operator|(
name|Info
operator|)
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|size
operator|+=
name|HEADER
operator|+
literal|4
operator|+
name|PTR
operator|+
name|PTR
expr_stmt|;
comment|// Info instance vars
if|if
condition|(
name|info
operator|.
name|sortedTerms
operator|!=
literal|null
condition|)
name|size
operator|+=
name|ARR
operator|+
name|PTR
operator|*
name|info
operator|.
name|sortedTerms
operator|.
name|length
expr_stmt|;
name|int
name|len
init|=
name|info
operator|.
name|terms
operator|.
name|size
argument_list|()
decl_stmt|;
name|size
operator|+=
name|HASHMAP
operator|+
name|len
operator|*
operator|(
name|PTR
operator|+
name|HEADER
operator|+
literal|3
operator|*
name|PTR
operator|+
literal|4
operator|)
expr_stmt|;
comment|// Map.entries
name|Iterator
name|iter2
init|=
name|info
operator|.
name|terms
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
comment|// for each term
name|Map
operator|.
name|Entry
name|e
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|iter2
operator|.
name|next
argument_list|()
decl_stmt|;
name|size
operator|+=
name|STR
operator|-
name|ARR
expr_stmt|;
comment|// assumes substring() memory overlay
comment|//				size += STR + 2 * ((String) e.getKey()).length();
name|ArrayIntList
name|positions
init|=
operator|(
name|ArrayIntList
operator|)
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|size
operator|+=
name|INTARRLIST
operator|+
literal|4
operator|*
name|positions
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
DECL|method|numPositions
specifier|private
name|int
name|numPositions
parameter_list|(
name|ArrayIntList
name|positions
parameter_list|)
block|{
return|return
name|positions
operator|.
name|size
argument_list|()
operator|/
name|stride
return|;
block|}
comment|/** sorts into ascending order (on demand), reusing memory along the way */
DECL|method|sortFields
specifier|private
name|void
name|sortFields
parameter_list|()
block|{
if|if
condition|(
name|sortedFields
operator|==
literal|null
condition|)
name|sortedFields
operator|=
name|sort
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
comment|/** returns a view of the given map's entries, sorted ascending by key */
DECL|method|sort
specifier|private
specifier|static
name|Map
operator|.
name|Entry
index|[]
name|sort
parameter_list|(
name|HashMap
name|map
parameter_list|)
block|{
name|int
name|size
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
name|Map
operator|.
name|Entry
index|[]
name|entries
init|=
operator|new
name|Map
operator|.
name|Entry
index|[
name|size
index|]
decl_stmt|;
name|Iterator
name|iter
init|=
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|entries
index|[
name|i
index|]
operator|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
literal|1
condition|)
name|Arrays
operator|.
name|sort
argument_list|(
name|entries
argument_list|,
name|termComparator
argument_list|)
expr_stmt|;
return|return
name|entries
return|;
block|}
comment|/** Returns a String representation of the index data for debugging purposes. */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuffer
name|result
init|=
operator|new
name|StringBuffer
argument_list|(
literal|256
argument_list|)
decl_stmt|;
name|sortFields
argument_list|()
expr_stmt|;
name|int
name|sumChars
init|=
literal|0
decl_stmt|;
name|int
name|sumPositions
init|=
literal|0
decl_stmt|;
name|int
name|sumTerms
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedFields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Map
operator|.
name|Entry
name|entry
init|=
name|sortedFields
index|[
name|i
index|]
decl_stmt|;
name|String
name|fieldName
init|=
operator|(
name|String
operator|)
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Info
name|info
init|=
operator|(
name|Info
operator|)
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|info
operator|.
name|sortTerms
argument_list|()
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|fieldName
operator|+
literal|":\n"
argument_list|)
expr_stmt|;
name|int
name|numChars
init|=
literal|0
decl_stmt|;
name|int
name|numPositions
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|info
operator|.
name|sortedTerms
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|Map
operator|.
name|Entry
name|e
init|=
name|info
operator|.
name|sortedTerms
index|[
name|j
index|]
decl_stmt|;
name|String
name|term
init|=
operator|(
name|String
operator|)
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ArrayIntList
name|positions
init|=
operator|(
name|ArrayIntList
operator|)
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|"\t'"
operator|+
name|term
operator|+
literal|"':"
operator|+
name|numPositions
argument_list|(
name|positions
argument_list|)
operator|+
literal|":"
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|positions
operator|.
name|toString
argument_list|(
name|stride
argument_list|)
argument_list|)
expr_stmt|;
comment|// ignore offsets
name|result
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|numPositions
operator|+=
name|numPositions
argument_list|(
name|positions
argument_list|)
expr_stmt|;
name|numChars
operator|+=
name|term
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|append
argument_list|(
literal|"\tterms="
operator|+
name|info
operator|.
name|sortedTerms
operator|.
name|length
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|", positions="
operator|+
name|numPositions
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|", Kchars="
operator|+
operator|(
name|numChars
operator|/
literal|1000.0f
operator|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sumPositions
operator|+=
name|numPositions
expr_stmt|;
name|sumChars
operator|+=
name|numChars
expr_stmt|;
name|sumTerms
operator|+=
name|info
operator|.
name|sortedTerms
operator|.
name|length
expr_stmt|;
block|}
name|result
operator|.
name|append
argument_list|(
literal|"\nfields="
operator|+
name|sortedFields
operator|.
name|length
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|", terms="
operator|+
name|sumTerms
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|", positions="
operator|+
name|sumPositions
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|", Kchars="
operator|+
operator|(
name|sumChars
operator|/
literal|1000.0f
operator|)
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
comment|///////////////////////////////////////////////////////////////////////////////
comment|// Nested classes:
comment|///////////////////////////////////////////////////////////////////////////////
comment|/** 	 * Index data structure for a field; Contains the tokenized term texts and 	 * their positions. 	 */
DECL|class|Info
specifier|private
specifier|static
specifier|final
class|class
name|Info
implements|implements
name|Serializable
block|{
comment|/** 		 * Term strings and their positions for this field: Map<String 		 * termText, ArrayIntList positions> 		 */
DECL|field|terms
specifier|private
specifier|final
name|HashMap
name|terms
decl_stmt|;
comment|/** Terms sorted ascending by term text; computed on demand */
DECL|field|sortedTerms
specifier|private
specifier|transient
name|Map
operator|.
name|Entry
index|[]
name|sortedTerms
decl_stmt|;
comment|/** Number of added tokens for this field */
DECL|field|numTokens
specifier|private
specifier|final
name|int
name|numTokens
decl_stmt|;
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2882195016849084649L
decl_stmt|;
DECL|method|Info
specifier|public
name|Info
parameter_list|(
name|HashMap
name|terms
parameter_list|,
name|int
name|numTokens
parameter_list|)
block|{
name|this
operator|.
name|terms
operator|=
name|terms
expr_stmt|;
name|this
operator|.
name|numTokens
operator|=
name|numTokens
expr_stmt|;
block|}
comment|/** 		 * Sorts hashed terms into ascending order, reusing memory along the 		 * way. Note that sorting is lazily delayed until required (often it's 		 * not required at all). If a sorted view is required then hashing + 		 * sort + binary search is still faster and smaller than TreeMap usage 		 * (which would be an alternative and somewhat more elegant approach, 		 * apart from more sophisticated Tries / prefix trees). 		 */
DECL|method|sortTerms
specifier|public
name|void
name|sortTerms
parameter_list|()
block|{
if|if
condition|(
name|sortedTerms
operator|==
literal|null
condition|)
name|sortedTerms
operator|=
name|sort
argument_list|(
name|terms
argument_list|)
expr_stmt|;
block|}
comment|/** note that the frequency can be calculated as numPosition(getPositions(x)) */
DECL|method|getPositions
specifier|public
name|ArrayIntList
name|getPositions
parameter_list|(
name|String
name|term
parameter_list|)
block|{
return|return
operator|(
name|ArrayIntList
operator|)
name|terms
operator|.
name|get
argument_list|(
name|term
argument_list|)
return|;
block|}
comment|/** note that the frequency can be calculated as numPosition(getPositions(x)) */
DECL|method|getPositions
specifier|public
name|ArrayIntList
name|getPositions
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
return|return
operator|(
name|ArrayIntList
operator|)
name|sortedTerms
index|[
name|pos
index|]
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
comment|///////////////////////////////////////////////////////////////////////////////
comment|// Nested classes:
comment|///////////////////////////////////////////////////////////////////////////////
comment|/** 	 * Efficient resizable auto-expanding list holding<code>int</code> elements; 	 * implemented with arrays. 	 */
DECL|class|ArrayIntList
specifier|private
specifier|static
specifier|final
class|class
name|ArrayIntList
implements|implements
name|Serializable
block|{
DECL|field|elements
specifier|private
name|int
index|[]
name|elements
decl_stmt|;
DECL|field|size
specifier|private
name|int
name|size
init|=
literal|0
decl_stmt|;
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2282195016849084649L
decl_stmt|;
DECL|method|ArrayIntList
specifier|public
name|ArrayIntList
parameter_list|()
block|{
name|this
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
DECL|method|ArrayIntList
specifier|public
name|ArrayIntList
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
name|elements
operator|=
operator|new
name|int
index|[
name|initialCapacity
index|]
expr_stmt|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|int
name|elem
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
name|elements
operator|.
name|length
condition|)
name|ensureCapacity
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|elements
index|[
name|size
operator|++
index|]
operator|=
name|elem
expr_stmt|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
if|if
condition|(
name|size
operator|+
literal|3
operator|>
name|elements
operator|.
name|length
condition|)
name|ensureCapacity
argument_list|(
name|size
operator|+
literal|3
argument_list|)
expr_stmt|;
name|elements
index|[
name|size
index|]
operator|=
name|pos
expr_stmt|;
name|elements
index|[
name|size
operator|+
literal|1
index|]
operator|=
name|start
expr_stmt|;
name|elements
index|[
name|size
operator|+
literal|2
index|]
operator|=
name|end
expr_stmt|;
name|size
operator|+=
literal|3
expr_stmt|;
block|}
DECL|method|get
specifier|public
name|int
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|>=
name|size
condition|)
name|throwIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|elements
index|[
name|index
index|]
return|;
block|}
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
DECL|method|toArray
specifier|public
name|int
index|[]
name|toArray
parameter_list|(
name|int
name|stride
parameter_list|)
block|{
name|int
index|[]
name|arr
init|=
operator|new
name|int
index|[
name|size
argument_list|()
operator|/
name|stride
index|]
decl_stmt|;
if|if
condition|(
name|stride
operator|==
literal|1
condition|)
name|System
operator|.
name|arraycopy
argument_list|(
name|elements
argument_list|,
literal|0
argument_list|,
name|arr
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|// fast path
else|else
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
name|stride
control|)
name|arr
index|[
name|i
index|]
operator|=
name|elements
index|[
name|j
index|]
expr_stmt|;
return|return
name|arr
return|;
block|}
DECL|method|ensureCapacity
specifier|private
name|void
name|ensureCapacity
parameter_list|(
name|int
name|minCapacity
parameter_list|)
block|{
name|int
name|newCapacity
init|=
name|Math
operator|.
name|max
argument_list|(
name|minCapacity
argument_list|,
operator|(
name|elements
operator|.
name|length
operator|*
literal|3
operator|)
operator|/
literal|2
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
index|[]
name|newElements
init|=
operator|new
name|int
index|[
name|newCapacity
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|elements
argument_list|,
literal|0
argument_list|,
name|newElements
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|elements
operator|=
name|newElements
expr_stmt|;
block|}
DECL|method|throwIndex
specifier|private
name|void
name|throwIndex
parameter_list|(
name|int
name|index
parameter_list|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"index: "
operator|+
name|index
operator|+
literal|", size: "
operator|+
name|size
argument_list|)
throw|;
block|}
comment|/** returns the first few positions (without offsets); debug only */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|(
name|int
name|stride
parameter_list|)
block|{
name|int
name|s
init|=
name|size
argument_list|()
operator|/
name|stride
decl_stmt|;
name|int
name|len
init|=
name|Math
operator|.
name|min
argument_list|(
literal|10
argument_list|,
name|s
argument_list|)
decl_stmt|;
comment|// avoid printing huge lists
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|(
literal|4
operator|*
name|len
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|get
argument_list|(
name|i
operator|*
name|stride
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len
operator|-
literal|1
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
name|s
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|", ..."
argument_list|)
expr_stmt|;
comment|// and some more...
name|buf
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|///////////////////////////////////////////////////////////////////////////////
comment|// Nested classes:
comment|///////////////////////////////////////////////////////////////////////////////
DECL|field|MATCH_ALL_TERM
specifier|private
specifier|static
specifier|final
name|Term
name|MATCH_ALL_TERM
init|=
operator|new
name|Term
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|)
decl_stmt|;
comment|/** 	 * Search support for Lucene framework integration; implements all methods 	 * required by the Lucene IndexReader contracts. 	 */
DECL|class|MemoryIndexReader
specifier|private
specifier|final
class|class
name|MemoryIndexReader
extends|extends
name|IndexReader
block|{
DECL|field|searcher
specifier|private
name|Searcher
name|searcher
decl_stmt|;
comment|// needed to find searcher.getSimilarity()
DECL|method|MemoryIndexReader
specifier|private
name|MemoryIndexReader
parameter_list|()
block|{
name|super
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// avoid as much superclass baggage as possible
block|}
comment|// lucene>= 1.9 or lucene-1.4.3 with patch removing "final" in superclass
DECL|method|finalize
specifier|protected
name|void
name|finalize
parameter_list|()
block|{}
DECL|method|getInfo
specifier|private
name|Info
name|getInfo
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
operator|(
name|Info
operator|)
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
DECL|method|getInfo
specifier|private
name|Info
name|getInfo
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
return|return
operator|(
name|Info
operator|)
name|sortedFields
index|[
name|pos
index|]
operator|.
name|getValue
argument_list|()
return|;
block|}
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|(
name|Term
name|term
parameter_list|)
block|{
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|term
operator|.
name|field
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|freq
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
name|freq
operator|=
name|info
operator|.
name|getPositions
argument_list|(
name|term
operator|.
name|text
argument_list|()
argument_list|)
operator|!=
literal|null
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.docFreq: "
operator|+
name|term
operator|+
literal|", freq:"
operator|+
name|freq
argument_list|)
expr_stmt|;
return|return
name|freq
return|;
block|}
DECL|method|terms
specifier|public
name|TermEnum
name|terms
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.terms()"
argument_list|)
expr_stmt|;
return|return
name|terms
argument_list|(
name|MATCH_ALL_TERM
argument_list|)
return|;
block|}
DECL|method|terms
specifier|public
name|TermEnum
name|terms
parameter_list|(
name|Term
name|term
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.terms: "
operator|+
name|term
argument_list|)
expr_stmt|;
name|int
name|i
decl_stmt|;
comment|// index into info.sortedTerms
name|int
name|j
decl_stmt|;
comment|// index into sortedFields
name|sortFields
argument_list|()
expr_stmt|;
name|j
operator|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|sortedFields
argument_list|,
name|term
operator|.
name|field
argument_list|()
argument_list|,
name|termComparator
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
comment|// not found; choose successor
name|j
operator|=
operator|-
name|j
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|sortedFields
operator|.
name|length
condition|)
name|getInfo
argument_list|(
name|j
argument_list|)
operator|.
name|sortTerms
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// found
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|info
operator|.
name|sortTerms
argument_list|()
expr_stmt|;
name|i
operator|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|info
operator|.
name|sortedTerms
argument_list|,
name|term
operator|.
name|text
argument_list|()
argument_list|,
name|termComparator
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|// not found; choose successor
name|i
operator|=
operator|-
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|info
operator|.
name|sortedTerms
operator|.
name|length
condition|)
block|{
comment|// move to next successor
name|j
operator|++
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|sortedFields
operator|.
name|length
condition|)
name|getInfo
argument_list|(
name|j
argument_list|)
operator|.
name|sortTerms
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|final
name|int
name|ix
init|=
name|i
decl_stmt|;
specifier|final
name|int
name|jx
init|=
name|j
decl_stmt|;
return|return
operator|new
name|TermEnum
argument_list|()
block|{
specifier|private
name|int
name|i
init|=
name|ix
decl_stmt|;
comment|// index into info.sortedTerms
specifier|private
name|int
name|j
init|=
name|jx
decl_stmt|;
comment|// index into sortedFields
specifier|public
name|boolean
name|next
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"TermEnum.next"
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|sortedFields
operator|.
name|length
condition|)
return|return
literal|false
return|;
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|++
name|i
operator|<
name|info
operator|.
name|sortedTerms
operator|.
name|length
condition|)
return|return
literal|true
return|;
comment|// move to successor
name|j
operator|++
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|sortedFields
operator|.
name|length
condition|)
return|return
literal|false
return|;
name|info
operator|.
name|sortTerms
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|Term
name|term
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"TermEnum.term: "
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|sortedFields
operator|.
name|length
condition|)
return|return
literal|null
return|;
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|info
operator|.
name|sortedTerms
operator|.
name|length
condition|)
return|return
literal|null
return|;
name|String
name|fieldName
init|=
operator|(
name|String
operator|)
name|sortedFields
index|[
name|j
index|]
operator|.
name|getKey
argument_list|()
decl_stmt|;
return|return
operator|new
name|Term
argument_list|(
name|fieldName
argument_list|,
operator|(
name|String
operator|)
name|info
operator|.
name|sortedTerms
index|[
name|i
index|]
operator|.
name|getKey
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|int
name|docFreq
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"TermEnum.docFreq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|sortedFields
operator|.
name|length
condition|)
return|return
literal|0
return|;
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|info
operator|.
name|sortedTerms
operator|.
name|length
condition|)
return|return
literal|0
return|;
return|return
name|numPositions
argument_list|(
name|info
operator|.
name|getPositions
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"TermEnum.close"
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
DECL|method|termPositions
specifier|public
name|TermPositions
name|termPositions
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.termPositions"
argument_list|)
expr_stmt|;
return|return
operator|new
name|TermPositions
argument_list|()
block|{
specifier|private
name|boolean
name|hasNext
decl_stmt|;
specifier|private
name|int
name|cursor
init|=
literal|0
decl_stmt|;
specifier|private
name|ArrayIntList
name|current
decl_stmt|;
specifier|public
name|void
name|seek
parameter_list|(
name|Term
name|term
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".seek: "
operator|+
name|term
argument_list|)
expr_stmt|;
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|term
operator|.
name|field
argument_list|()
argument_list|)
decl_stmt|;
name|current
operator|=
name|info
operator|==
literal|null
condition|?
literal|null
else|:
name|info
operator|.
name|getPositions
argument_list|(
name|term
operator|.
name|text
argument_list|()
argument_list|)
expr_stmt|;
name|hasNext
operator|=
operator|(
name|current
operator|!=
literal|null
operator|)
expr_stmt|;
name|cursor
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|seek
parameter_list|(
name|TermEnum
name|termEnum
parameter_list|)
block|{
name|seek
argument_list|(
name|termEnum
operator|.
name|term
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|doc
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".doc"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|public
name|int
name|freq
parameter_list|()
block|{
name|int
name|freq
init|=
name|current
operator|!=
literal|null
condition|?
name|numPositions
argument_list|(
name|current
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".freq: "
operator|+
name|freq
argument_list|)
expr_stmt|;
return|return
name|freq
return|;
block|}
specifier|public
name|boolean
name|next
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".next: "
operator|+
name|current
operator|+
literal|", oldHasNext="
operator|+
name|hasNext
argument_list|)
expr_stmt|;
name|boolean
name|next
init|=
name|hasNext
decl_stmt|;
name|hasNext
operator|=
literal|false
expr_stmt|;
return|return
name|next
return|;
block|}
specifier|public
name|int
name|read
parameter_list|(
name|int
index|[]
name|docs
parameter_list|,
name|int
index|[]
name|freqs
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".read: "
operator|+
name|docs
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasNext
condition|)
return|return
literal|0
return|;
name|hasNext
operator|=
literal|false
expr_stmt|;
name|docs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|freqs
index|[
literal|0
index|]
operator|=
name|freq
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
specifier|public
name|boolean
name|skipTo
parameter_list|(
name|int
name|target
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".skipTo: "
operator|+
name|target
argument_list|)
expr_stmt|;
return|return
name|next
argument_list|()
return|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".close"
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|nextPosition
parameter_list|()
block|{
comment|// implements TermPositions
name|int
name|pos
init|=
name|current
operator|.
name|get
argument_list|(
name|cursor
argument_list|)
decl_stmt|;
name|cursor
operator|+=
name|stride
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|".nextPosition: "
operator|+
name|pos
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
block|}
return|;
block|}
DECL|method|termDocs
specifier|public
name|TermDocs
name|termDocs
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.termDocs"
argument_list|)
expr_stmt|;
return|return
name|termPositions
argument_list|()
return|;
block|}
DECL|method|getTermFreqVectors
specifier|public
name|TermFreqVector
index|[]
name|getTermFreqVectors
parameter_list|(
name|int
name|docNumber
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.getTermFreqVectors"
argument_list|)
expr_stmt|;
name|TermFreqVector
index|[]
name|vectors
init|=
operator|new
name|TermFreqVector
index|[
name|fields
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|Iterator
name|iter
init|=
name|fields
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vectors
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|fieldName
init|=
operator|(
name|String
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|vectors
index|[
name|i
index|]
operator|=
name|getTermFreqVector
argument_list|(
name|docNumber
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|vectors
return|;
block|}
DECL|method|getTermFreqVector
specifier|public
name|TermFreqVector
name|getTermFreqVector
parameter_list|(
name|int
name|docNumber
parameter_list|,
specifier|final
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.getTermFreqVector"
argument_list|)
expr_stmt|;
specifier|final
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
return|return
literal|null
return|;
comment|// TODO: or return empty vector impl???
name|info
operator|.
name|sortTerms
argument_list|()
expr_stmt|;
return|return
operator|new
name|TermPositionVector
argument_list|()
block|{
specifier|final
name|Map
operator|.
name|Entry
index|[]
name|sortedTerms
init|=
name|info
operator|.
name|sortedTerms
decl_stmt|;
specifier|public
name|String
name|getField
parameter_list|()
block|{
return|return
name|fieldName
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|sortedTerms
operator|.
name|length
return|;
block|}
specifier|public
name|String
index|[]
name|getTerms
parameter_list|()
block|{
name|String
index|[]
name|terms
init|=
operator|new
name|String
index|[
name|sortedTerms
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedTerms
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|terms
index|[
name|i
index|]
operator|=
operator|(
name|String
operator|)
name|sortedTerms
index|[
name|i
index|]
operator|.
name|getKey
argument_list|()
expr_stmt|;
block|}
return|return
name|terms
return|;
block|}
specifier|public
name|int
index|[]
name|getTermFrequencies
parameter_list|()
block|{
name|int
index|[]
name|freqs
init|=
operator|new
name|int
index|[
name|sortedTerms
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedTerms
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|freqs
index|[
name|i
index|]
operator|=
name|numPositions
argument_list|(
operator|(
name|ArrayIntList
operator|)
name|sortedTerms
index|[
name|i
index|]
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|freqs
return|;
block|}
specifier|public
name|int
name|indexOf
parameter_list|(
name|String
name|term
parameter_list|)
block|{
name|int
name|i
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|sortedTerms
argument_list|,
name|term
argument_list|,
name|termComparator
argument_list|)
decl_stmt|;
return|return
name|i
operator|>=
literal|0
condition|?
name|i
else|:
operator|-
literal|1
return|;
block|}
specifier|public
name|int
index|[]
name|indexesOf
parameter_list|(
name|String
index|[]
name|terms
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
index|[]
name|indexes
init|=
operator|new
name|int
index|[
name|len
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|indexes
index|[
name|i
index|]
operator|=
name|indexOf
argument_list|(
name|terms
index|[
name|start
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|indexes
return|;
block|}
comment|// lucene>= 1.4.3
specifier|public
name|int
index|[]
name|getTermPositions
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ArrayIntList
operator|)
name|sortedTerms
index|[
name|index
index|]
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|toArray
argument_list|(
name|stride
argument_list|)
return|;
block|}
comment|// lucene>= 1.9 (remove this method for lucene-1.4.3)
specifier|public
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermVectorOffsetInfo
index|[]
name|getOffsets
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|stride
operator|==
literal|1
condition|)
return|return
literal|null
return|;
comment|// no offsets stored
name|ArrayIntList
name|positions
init|=
operator|(
name|ArrayIntList
operator|)
name|sortedTerms
index|[
name|index
index|]
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|positions
operator|.
name|size
argument_list|()
decl_stmt|;
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermVectorOffsetInfo
index|[]
name|offsets
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermVectorOffsetInfo
index|[
name|size
operator|/
name|stride
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|1
init|;
name|j
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
name|stride
control|)
block|{
name|int
name|start
init|=
name|positions
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|int
name|end
init|=
name|positions
operator|.
name|get
argument_list|(
name|j
operator|+
literal|1
argument_list|)
decl_stmt|;
name|offsets
index|[
name|i
index|]
operator|=
operator|new
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermVectorOffsetInfo
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
return|return
name|offsets
return|;
block|}
block|}
return|;
block|}
DECL|method|getSimilarity
specifier|private
name|Similarity
name|getSimilarity
parameter_list|()
block|{
return|return
name|searcher
operator|.
name|getSimilarity
argument_list|()
return|;
block|}
DECL|method|setSearcher
specifier|private
name|void
name|setSearcher
parameter_list|(
name|Searcher
name|searcher
parameter_list|)
block|{
name|this
operator|.
name|searcher
operator|=
name|searcher
expr_stmt|;
block|}
DECL|method|norms
specifier|public
name|byte
index|[]
name|norms
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.norms: "
operator|+
name|fieldName
argument_list|)
expr_stmt|;
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|int
name|numTokens
init|=
name|info
operator|!=
literal|null
condition|?
name|info
operator|.
name|numTokens
else|:
literal|0
decl_stmt|;
name|byte
name|norm
init|=
name|Similarity
operator|.
name|encodeNorm
argument_list|(
name|getSimilarity
argument_list|()
operator|.
name|lengthNorm
argument_list|(
name|fieldName
argument_list|,
name|numTokens
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|byte
index|[]
block|{
name|norm
block|}
return|;
block|}
DECL|method|norms
specifier|public
name|void
name|norms
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.norms: "
operator|+
name|fieldName
operator|+
literal|"*"
argument_list|)
expr_stmt|;
name|byte
index|[]
name|norms
init|=
name|norms
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|norms
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|,
name|offset
argument_list|,
name|norms
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|doSetNorm
specifier|protected
name|void
name|doSetNorm
parameter_list|(
name|int
name|doc
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|byte
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|numDocs
specifier|public
name|int
name|numDocs
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.numDocs"
argument_list|)
expr_stmt|;
return|return
name|fields
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
return|;
block|}
DECL|method|maxDoc
specifier|public
name|int
name|maxDoc
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.maxDoc"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
DECL|method|document
specifier|public
name|Document
name|document
parameter_list|(
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.document"
argument_list|)
expr_stmt|;
return|return
operator|new
name|Document
argument_list|()
return|;
comment|// there are no stored fields
block|}
DECL|method|isDeleted
specifier|public
name|boolean
name|isDeleted
parameter_list|(
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.isDeleted"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|method|hasDeletions
specifier|public
name|boolean
name|hasDeletions
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.hasDeletions"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|method|doDelete
specifier|protected
name|void
name|doDelete
parameter_list|(
name|int
name|docNum
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|doUndeleteAll
specifier|protected
name|void
name|doUndeleteAll
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|doCommit
specifier|protected
name|void
name|doCommit
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.doCommit"
argument_list|)
expr_stmt|;
block|}
DECL|method|doClose
specifier|protected
name|void
name|doClose
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.doClose"
argument_list|)
expr_stmt|;
block|}
comment|// lucene<= 1.4.3
DECL|method|getFieldNames
specifier|public
name|Collection
name|getFieldNames
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.getFieldNames"
argument_list|)
expr_stmt|;
return|return
name|getFieldNames
argument_list|(
literal|true
argument_list|)
return|;
block|}
comment|// lucene<= 1.4.3
DECL|method|getFieldNames
specifier|public
name|Collection
name|getFieldNames
parameter_list|(
name|boolean
name|indexed
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.getFieldNames "
operator|+
name|indexed
argument_list|)
expr_stmt|;
return|return
name|indexed
condition|?
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|fields
operator|.
name|keySet
argument_list|()
argument_list|)
else|:
name|Collections
operator|.
name|EMPTY_SET
return|;
block|}
comment|// lucene<= 1.4.3
DECL|method|getIndexedFieldNames
specifier|public
name|Collection
name|getIndexedFieldNames
parameter_list|(
name|boolean
name|storedTermVector
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.getIndexedFieldNames "
operator|+
name|storedTermVector
argument_list|)
expr_stmt|;
return|return
name|getFieldNames
argument_list|(
name|storedTermVector
argument_list|)
return|;
block|}
comment|// lucene>= 1.9 (deprecated) (remove this method for lucene-1.4.3)
DECL|method|getIndexedFieldNames
specifier|public
name|Collection
name|getIndexedFieldNames
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
operator|.
name|TermVector
name|tvSpec
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Deprecated; replaced by getFieldNames(IndexReader.FieldOption)"
argument_list|)
throw|;
block|}
comment|// lucene>= 1.9 (remove this method for lucene-1.4.3)
DECL|method|getFieldNames
specifier|public
name|Collection
name|getFieldNames
parameter_list|(
name|FieldOption
name|fieldOption
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.getFieldNamesOption"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldOption
operator|==
name|FieldOption
operator|.
name|UNINDEXED
condition|)
return|return
name|Collections
operator|.
name|EMPTY_SET
return|;
if|if
condition|(
name|fieldOption
operator|==
name|FieldOption
operator|.
name|INDEXED_NO_TERMVECTOR
condition|)
return|return
name|Collections
operator|.
name|EMPTY_SET
return|;
if|if
condition|(
name|fieldOption
operator|==
name|FieldOption
operator|.
name|TERMVECTOR_WITH_OFFSET
operator|&&
name|stride
operator|==
literal|1
condition|)
return|return
name|Collections
operator|.
name|EMPTY_SET
return|;
if|if
condition|(
name|fieldOption
operator|==
name|FieldOption
operator|.
name|TERMVECTOR_WITH_POSITION_OFFSET
operator|&&
name|stride
operator|==
literal|1
condition|)
return|return
name|Collections
operator|.
name|EMPTY_SET
return|;
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|fields
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
end_class
end_unit
