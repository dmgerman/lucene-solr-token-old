begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.gdata.search.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|gdata
operator|.
name|search
operator|.
name|index
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|gdata
operator|.
name|search
operator|.
name|config
operator|.
name|IndexSchema
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_comment
comment|/**  * A GDataIndexer encapsulates every writing access to the search index.  *<p>  * Insert, updates and deletes to the index happens inside this class. All  * modification will be base on an instance of  * {@link org.apache.lucene.gdata.search.index.IndexDocument} which contains all  * informations and command for the indexer.<br>  * Although this class provides methods to add, remove and update document in  * the index all<tt>IndexDocument</tt> instances should be added to the task  * queue via the {@link GDataIndexer#addIndexableDocumentTask(Future)} method.  * Inside this class runs an instance of  * {@link org.apache.lucene.gdata.search.index.IndexTask} listening on this  * queue. The analysis of the actual documents happens inside the  * {@link java.util.concurrent.Future} object added to the  * queue. This enables the indexer to do his actual work. Documents will be  * build / analyzed concurrently while already finished tasks can be added to  * the index.  *</p>  *   *   *   *  */
end_comment
begin_class
DECL|class|GDataIndexer
specifier|public
class|class
name|GDataIndexer
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|GDataIndexer
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|writer
specifier|protected
name|IndexWriter
name|writer
decl_stmt|;
DECL|field|searcher
specifier|protected
name|IndexSearcher
name|searcher
decl_stmt|;
DECL|field|committed
specifier|protected
name|AtomicInteger
name|committed
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|optimized
specifier|protected
name|AtomicInteger
name|optimized
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|isDestroyed
specifier|private
name|AtomicBoolean
name|isDestroyed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|docsAdded
specifier|protected
name|AtomicInteger
name|docsAdded
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|docsUpdated
specifier|protected
name|AtomicInteger
name|docsUpdated
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|docsDeleted
specifier|protected
name|AtomicInteger
name|docsDeleted
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|dir
specifier|private
specifier|final
name|Directory
name|dir
decl_stmt|;
DECL|field|listeners
specifier|private
specifier|final
name|List
argument_list|<
name|IndexEventListener
argument_list|>
name|listeners
init|=
operator|new
name|ArrayList
argument_list|<
name|IndexEventListener
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|futurQueue
specifier|protected
specifier|final
name|BlockingQueue
argument_list|<
name|Future
argument_list|<
name|IndexDocument
argument_list|>
argument_list|>
name|futurQueue
init|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Future
argument_list|<
name|IndexDocument
argument_list|>
argument_list|>
argument_list|(
literal|100
argument_list|)
decl_stmt|;
DECL|field|serviceConfiguration
specifier|private
specifier|final
name|IndexSchema
name|serviceConfiguration
decl_stmt|;
DECL|field|indexTaskExecutor
specifier|private
specifier|final
name|ExecutorService
name|indexTaskExecutor
decl_stmt|;
DECL|field|indexTask
specifier|protected
name|IndexTask
name|indexTask
decl_stmt|;
DECL|field|ZERO
specifier|private
specifier|static
specifier|final
name|Integer
name|ZERO
init|=
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|ONE
specifier|private
specifier|static
specifier|final
name|Integer
name|ONE
init|=
operator|new
name|Integer
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|field|action
specifier|private
specifier|final
name|Map
argument_list|<
name|IndexDocument
argument_list|,
name|Integer
argument_list|>
name|action
decl_stmt|;
DECL|method|GDataIndexer
specifier|protected
name|GDataIndexer
parameter_list|(
specifier|final
name|IndexSchema
name|schema
parameter_list|,
name|Directory
name|dir
parameter_list|,
name|boolean
name|create
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|schema
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"IndexServiceConfiguration must not be null"
argument_list|)
throw|;
if|if
condition|(
name|dir
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"IndexDirectory must not be null"
argument_list|)
throw|;
name|this
operator|.
name|serviceConfiguration
operator|=
name|schema
expr_stmt|;
name|this
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
name|openWriter
argument_list|(
name|create
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexTaskExecutor
operator|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
expr_stmt|;
name|this
operator|.
name|action
operator|=
operator|new
name|HashMap
argument_list|<
name|IndexDocument
argument_list|,
name|Integer
argument_list|>
argument_list|(
literal|128
argument_list|)
expr_stmt|;
block|}
DECL|method|setIndexTask
specifier|protected
name|void
name|setIndexTask
parameter_list|(
specifier|final
name|IndexTask
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|!=
literal|null
operator|&&
name|this
operator|.
name|indexTask
operator|==
literal|null
condition|)
name|this
operator|.
name|indexTask
operator|=
name|task
expr_stmt|;
block|}
DECL|method|init
specifier|protected
name|void
name|init
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|indexTask
operator|==
literal|null
condition|)
name|this
operator|.
name|indexTask
operator|=
operator|new
name|IndexTask
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|futurQueue
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexTaskExecutor
operator|.
name|execute
argument_list|(
name|this
operator|.
name|indexTask
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds the given future task to the queue, and waits if the queue is full.      * The queue size is set to 100 by default.      *       * @param task -      *            the task to be scheduled      * @throws InterruptedException -      *             if the queue is interrupted      */
DECL|method|addIndexableDocumentTask
specifier|public
name|void
name|addIndexableDocumentTask
parameter_list|(
specifier|final
name|Future
argument_list|<
name|IndexDocument
argument_list|>
name|task
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|this
operator|.
name|isDestroyed
operator|.
name|get
argument_list|()
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Indexer has already been destroyed"
argument_list|)
throw|;
name|this
operator|.
name|futurQueue
operator|.
name|put
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
comment|/*      * a added doc should not be in the index, be sure and delete possible      * duplicates      */
DECL|method|addDocument
specifier|protected
specifier|synchronized
name|void
name|addDocument
parameter_list|(
name|IndexDocument
name|indexable
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|indexable
operator|.
name|isInsert
argument_list|()
condition|)
throw|throw
operator|new
name|GdataIndexerException
argument_list|(
literal|"Index action must be set to insert"
argument_list|)
throw|;
name|setAction
argument_list|(
name|indexable
argument_list|)
expr_stmt|;
name|doWrite
argument_list|(
name|indexable
argument_list|)
expr_stmt|;
name|this
operator|.
name|docsAdded
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|setAction
specifier|private
name|void
name|setAction
parameter_list|(
name|IndexDocument
name|doc
parameter_list|)
block|{
name|Integer
name|docCountToKeep
init|=
name|this
operator|.
name|action
operator|.
name|get
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|doc
operator|.
name|isDelete
argument_list|()
operator|&&
operator|(
name|docCountToKeep
operator|==
literal|null
operator|||
name|docCountToKeep
operator|==
literal|0
operator|)
condition|)
block|{
comment|/*              * add a ONE for ONE documents to keep for this IndexDocument when              * doDelete. doDelete will keep the latest added document and              * deletes all other documents for this IndexDocument e.g. all              * duplicates              */
name|this
operator|.
name|action
operator|.
name|put
argument_list|(
name|doc
argument_list|,
name|ONE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|doc
operator|.
name|isDelete
argument_list|()
operator|&&
operator|(
name|docCountToKeep
operator|==
literal|null
operator|||
name|docCountToKeep
operator|>
literal|0
operator|)
condition|)
block|{
comment|/*              * add a zero for zero documents to keep for this IndexDocument when              * doDelete              */
name|this
operator|.
name|action
operator|.
name|put
argument_list|(
name|doc
argument_list|,
name|ZERO
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateDocument
specifier|protected
specifier|synchronized
name|void
name|updateDocument
parameter_list|(
name|IndexDocument
name|indexable
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|indexable
operator|.
name|isUpdate
argument_list|()
condition|)
throw|throw
operator|new
name|GdataIndexerException
argument_list|(
literal|"Index action must be set to update"
argument_list|)
throw|;
name|setAction
argument_list|(
name|indexable
argument_list|)
expr_stmt|;
name|doWrite
argument_list|(
name|indexable
argument_list|)
expr_stmt|;
name|this
operator|.
name|docsUpdated
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|deleteDocument
specifier|protected
specifier|synchronized
name|void
name|deleteDocument
parameter_list|(
name|IndexDocument
name|indexable
parameter_list|)
block|{
if|if
condition|(
operator|!
name|indexable
operator|.
name|isDelete
argument_list|()
condition|)
throw|throw
operator|new
name|GdataIndexerException
argument_list|(
literal|"Index action must be set to delete"
argument_list|)
throw|;
name|setAction
argument_list|(
name|indexable
argument_list|)
expr_stmt|;
name|this
operator|.
name|docsDeleted
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/**      * This method commits all changes to the index and closes all open      * resources (e.g. IndexWriter and IndexReader). This method notifies all      * registered Commit listeners if invoked.      *       * @param optimize -      *<code>true</code> if the index should be optimized on this      *            commit      * @throws IOException -      *             if an IOException occurs      */
DECL|method|commit
specifier|protected
specifier|synchronized
name|void
name|commit
parameter_list|(
name|boolean
name|optimize
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|info
argument_list|(
literal|"Commit called with optimize = "
operator|+
name|optimize
argument_list|)
expr_stmt|;
name|int
name|changes
init|=
name|this
operator|.
name|docsAdded
operator|.
name|intValue
argument_list|()
operator|+
name|this
operator|.
name|docsDeleted
operator|.
name|intValue
argument_list|()
operator|+
name|this
operator|.
name|docsUpdated
operator|.
name|intValue
argument_list|()
decl_stmt|;
comment|/*          * don't call listeners to prevent unnecessary close / open of searchers          */
if|if
condition|(
name|changes
operator|==
literal|0
condition|)
return|return;
name|this
operator|.
name|committed
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
name|this
operator|.
name|optimized
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|doDeltete
argument_list|()
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
block|{
name|closeSearcher
argument_list|()
expr_stmt|;
name|openWriter
argument_list|()
expr_stmt|;
name|this
operator|.
name|writer
operator|.
name|optimize
argument_list|()
expr_stmt|;
block|}
name|closeSearcher
argument_list|()
expr_stmt|;
name|closeWriter
argument_list|()
expr_stmt|;
name|this
operator|.
name|docsAdded
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|docsDeleted
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|docsUpdated
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|notifyCommitListeners
argument_list|(
name|this
operator|.
name|serviceConfiguration
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Registers a new IndexEventListener. All registered listeners will be      * notified if the index has been committed.      *       * @param listener -      *            the listener to register      *       */
DECL|method|registerIndexEventListener
specifier|public
name|void
name|registerIndexEventListener
parameter_list|(
name|IndexEventListener
name|listener
parameter_list|)
block|{
if|if
condition|(
name|listener
operator|==
literal|null
operator|||
name|this
operator|.
name|listeners
operator|.
name|contains
argument_list|(
name|listener
argument_list|)
condition|)
return|return;
name|this
operator|.
name|listeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes a registered IndexEventListener      *       * @param listener -      *            the listener to remove      */
DECL|method|removeIndexEventListener
specifier|public
name|void
name|removeIndexEventListener
parameter_list|(
name|IndexEventListener
name|listener
parameter_list|)
block|{
if|if
condition|(
name|listener
operator|==
literal|null
operator|||
operator|!
name|this
operator|.
name|listeners
operator|.
name|contains
argument_list|(
name|listener
argument_list|)
condition|)
return|return;
name|this
operator|.
name|listeners
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
DECL|method|notifyCommitListeners
specifier|protected
name|void
name|notifyCommitListeners
parameter_list|(
name|String
name|serviceId
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|info
argument_list|(
literal|"notify commit event listeners for service id: "
operator|+
name|serviceId
operator|+
literal|" --  current size of registered listeners: "
operator|+
name|this
operator|.
name|listeners
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|IndexEventListener
name|listener
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|listener
operator|.
name|commitCallBack
argument_list|(
name|serviceId
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|closeWriter
specifier|protected
name|void
name|closeWriter
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|this
operator|.
name|writer
operator|!=
literal|null
condition|)
name|this
operator|.
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|writer
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|closeSearcher
specifier|protected
name|void
name|closeSearcher
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|this
operator|.
name|searcher
operator|!=
literal|null
condition|)
name|this
operator|.
name|searcher
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|searcher
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|openSearcher
specifier|protected
name|void
name|openSearcher
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|searcher
operator|==
literal|null
condition|)
name|this
operator|.
name|searcher
operator|=
operator|new
name|IndexSearcher
argument_list|(
name|this
operator|.
name|dir
argument_list|)
expr_stmt|;
block|}
DECL|method|openWriter
specifier|protected
name|void
name|openWriter
parameter_list|()
throws|throws
name|IOException
block|{
name|openWriter
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|openWriter
specifier|private
name|void
name|openWriter
parameter_list|(
name|boolean
name|create
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|writer
operator|==
literal|null
condition|)
name|this
operator|.
name|writer
operator|=
operator|new
name|GDataIndexWriter
argument_list|(
name|this
operator|.
name|dir
argument_list|,
name|create
argument_list|,
name|this
operator|.
name|serviceConfiguration
argument_list|)
expr_stmt|;
block|}
comment|/*      * This should only be called in a synchronized block      */
DECL|method|doWrite
specifier|protected
name|void
name|doWrite
parameter_list|(
name|IndexDocument
name|document
parameter_list|)
throws|throws
name|IOException
block|{
name|closeSearcher
argument_list|()
expr_stmt|;
name|openWriter
argument_list|()
expr_stmt|;
name|this
operator|.
name|writer
operator|.
name|addDocument
argument_list|(
name|document
operator|.
name|getWriteable
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// only access synchronized
DECL|field|documentNumber
name|int
index|[]
name|documentNumber
decl_stmt|;
comment|/*      * This should only be called in a synchronized block      */
DECL|method|doDeltete
specifier|protected
name|void
name|doDeltete
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|action
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting documents and duplicates from index, size of IndexDocuments "
operator|+
name|this
operator|.
name|action
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|closeWriter
argument_list|()
expr_stmt|;
name|openSearcher
argument_list|()
expr_stmt|;
name|IndexReader
name|reader
init|=
name|this
operator|.
name|searcher
operator|.
name|getIndexReader
argument_list|()
decl_stmt|;
name|TermDocs
name|termDocs
init|=
name|reader
operator|.
name|termDocs
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|IndexDocument
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|this
operator|.
name|action
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|IndexDocument
name|indexDocument
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Integer
name|docToKeep
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// extend the array if needed
if|if
condition|(
name|this
operator|.
name|documentNumber
operator|==
literal|null
operator|||
name|docToKeep
operator|>
name|this
operator|.
name|documentNumber
operator|.
name|length
condition|)
name|this
operator|.
name|documentNumber
operator|=
operator|new
name|int
index|[
name|docToKeep
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|documentNumber
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|this
operator|.
name|documentNumber
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/*              * get the term to find the document from the document itself              */
name|termDocs
operator|.
name|seek
argument_list|(
name|indexDocument
operator|.
name|getDeletealbe
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|termDocs
operator|.
name|next
argument_list|()
condition|)
block|{
comment|/*                  * if this is a pure delete just delete it an continue                  */
if|if
condition|(
name|docToKeep
operator|==
literal|0
condition|)
block|{
name|reader
operator|.
name|deleteDocument
argument_list|(
name|termDocs
operator|.
name|doc
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|int
name|prev
init|=
name|this
operator|.
name|documentNumber
index|[
name|pos
index|]
decl_stmt|;
name|this
operator|.
name|documentNumber
index|[
name|pos
index|]
operator|=
name|termDocs
operator|.
name|doc
argument_list|()
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
operator|-
literal|1
condition|)
block|{
name|reader
operator|.
name|deleteDocument
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|pos
operator|>=
name|docToKeep
condition|)
name|pos
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*          * clear the map after all documents are processed          */
name|this
operator|.
name|action
operator|.
name|clear
argument_list|()
expr_stmt|;
name|closeSearcher
argument_list|()
expr_stmt|;
block|}
DECL|method|destroy
specifier|protected
specifier|synchronized
name|void
name|destroy
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|isDestroyed
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|indexTask
operator|.
name|isStopped
argument_list|()
condition|)
name|this
operator|.
name|indexTask
operator|.
name|stop
argument_list|()
expr_stmt|;
name|this
operator|.
name|futurQueue
operator|.
name|add
argument_list|(
operator|new
name|FinishingFuture
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexTaskExecutor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|closeWriter
argument_list|()
expr_stmt|;
name|closeSearcher
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|info
argument_list|(
literal|"Destroying GdataIndexer for service -- "
operator|+
name|this
operator|.
name|serviceConfiguration
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Used only for testing
DECL|method|getWriter
specifier|protected
specifier|synchronized
name|IndexWriter
name|getWriter
parameter_list|()
block|{
return|return
name|this
operator|.
name|writer
return|;
block|}
comment|/**      * This factory method creates a new GDataIndexer using a instance of      * {@link org.apache.lucene.gdata.search.index.IndexTask}      *       * @param config -      *            the config to be used to configure the indexer      * @param dir -      *            the directory to index to      * @param create -      *<code>true</code> to create a new index,<code>false</code>      *            to use the existing one.      * @return - a new GDataIndexer instance      * @throws IOException -      *             if an IOException occurs while initializing the indexer      */
DECL|method|createGdataIndexer
specifier|public
specifier|static
specifier|synchronized
name|GDataIndexer
name|createGdataIndexer
parameter_list|(
specifier|final
name|IndexSchema
name|config
parameter_list|,
name|Directory
name|dir
parameter_list|,
name|boolean
name|create
parameter_list|)
throws|throws
name|IOException
block|{
name|GDataIndexer
name|retVal
init|=
operator|new
name|GDataIndexer
argument_list|(
name|config
argument_list|,
name|dir
argument_list|,
name|create
argument_list|)
decl_stmt|;
name|retVal
operator|.
name|setIndexTask
argument_list|(
operator|new
name|IndexTask
argument_list|(
name|retVal
argument_list|,
name|retVal
operator|.
name|futurQueue
argument_list|)
argument_list|)
expr_stmt|;
name|retVal
operator|.
name|init
argument_list|()
expr_stmt|;
return|return
name|retVal
return|;
block|}
comment|/**      * This factory method creates a new GDataIndexer using a instance of      * {@link org.apache.lucene.gdata.search.index.TimedIndexTask}.      * This indexer will automatically commit the index      * if no modification to the index occur for the given time. The used time      * unit is {@link TimeUnit#SECONDS}. Values less than the default value      * will be ignored. For the default value see      * {@link org.apache.lucene.gdata.search.index.TimedIndexTask}.      *       * @param config -      *            the config to be used to configure the indexer      * @param dir -      *            the directory to index to      * @param create -      *<code>true</code> to create a new index,<code>false</code>      *            to use the existing one.      * @param commitTimeout -      *            the amount of seconds to wait until a commit should be      *            scheduled      * @return - a new GDataIndexer instance      * @throws IOException -      *             if an IOException occurs while initializing the indexer      */
DECL|method|createTimedGdataIndexer
specifier|public
specifier|static
specifier|synchronized
name|GDataIndexer
name|createTimedGdataIndexer
parameter_list|(
specifier|final
name|IndexSchema
name|config
parameter_list|,
name|Directory
name|dir
parameter_list|,
name|boolean
name|create
parameter_list|,
name|long
name|commitTimeout
parameter_list|)
throws|throws
name|IOException
block|{
name|GDataIndexer
name|retVal
init|=
operator|new
name|GDataIndexer
argument_list|(
name|config
argument_list|,
name|dir
argument_list|,
name|create
argument_list|)
decl_stmt|;
name|retVal
operator|.
name|setIndexTask
argument_list|(
operator|new
name|TimedIndexTask
argument_list|(
name|retVal
argument_list|,
name|retVal
operator|.
name|futurQueue
argument_list|,
name|commitTimeout
argument_list|)
argument_list|)
expr_stmt|;
name|retVal
operator|.
name|init
argument_list|()
expr_stmt|;
return|return
name|retVal
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
DECL|class|FinishingFuture
specifier|static
specifier|final
class|class
name|FinishingFuture
implements|implements
name|Future
argument_list|<
name|IndexDocument
argument_list|>
block|{
comment|/**          * @see java.util.concurrent.Future#cancel(boolean)          */
DECL|method|cancel
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|arg0
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
comment|/**          * @see java.util.concurrent.Future#isCancelled()          */
DECL|method|isCancelled
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**          * @see java.util.concurrent.Future#isDone()          */
DECL|method|isDone
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**          * @see java.util.concurrent.Future#get()          */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
DECL|method|get
specifier|public
name|IndexDocument
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
return|return
literal|null
return|;
block|}
comment|/**          * @see java.util.concurrent.Future#get(long,          *      java.util.concurrent.TimeUnit)          */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
DECL|method|get
specifier|public
name|IndexDocument
name|get
parameter_list|(
name|long
name|arg0
parameter_list|,
name|TimeUnit
name|arg1
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
throws|,
name|TimeoutException
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
end_class
end_unit
