begin_unit
begin_package
DECL|package|org.apache.lucene.queryParser.standard
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|Collator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TooManyListenersException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|DateTools
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|core
operator|.
name|QueryNodeException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|core
operator|.
name|QueryParserHelper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|core
operator|.
name|config
operator|.
name|QueryConfigHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|builders
operator|.
name|StandardQueryTreeBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|config
operator|.
name|AllowLeadingWildcardAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|config
operator|.
name|AnalyzerAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|config
operator|.
name|DateResolutionAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|config
operator|.
name|FieldDateResolutionMapAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|config
operator|.
name|DefaultOperatorAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|config
operator|.
name|DefaultPhraseSlopAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|config
operator|.
name|FieldBoostMapAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|config
operator|.
name|FuzzyAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|config
operator|.
name|LocaleAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|config
operator|.
name|LowercaseExpandedTermsAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|config
operator|.
name|MultiFieldAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|config
operator|.
name|MultiTermRewriteMethodAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|config
operator|.
name|StandardQueryConfigHandler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|config
operator|.
name|PositionIncrementsAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|config
operator|.
name|RangeCollatorAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|config
operator|.
name|DefaultOperatorAttribute
operator|.
name|Operator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|nodes
operator|.
name|RangeQueryNode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|parser
operator|.
name|StandardSyntaxParser
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryParser
operator|.
name|standard
operator|.
name|processors
operator|.
name|StandardQueryNodeProcessorPipeline
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FuzzyQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|MultiTermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_comment
comment|/**  *<p>  * This class is a helper that enables users to easily use the Lucene query  * parser.  *</p>  *<p>  * To construct a Query object from a query string, use the  * {@link #parse(String, String)} method:  *<ul>  * StandardQueryParser queryParserHelper = new StandardQueryParser();<br/>  * Query query = queryParserHelper.parse("a AND b", "defaultField");  *</ul>  *<p>  * To change any configuration before parsing the query string do, for example:  *<p/>  *<ul>  * // the query config handler returned by {@link StandardQueryParser} is a  * {@link StandardQueryConfigHandler}<br/>  * queryParserHelper.getQueryConfigHandler().setAnalyzer(new  * WhitespaceAnalyzer());  *</ul>  *<p>  * The syntax for query strings is as follows (copied from the old QueryParser  * javadoc):  *<ul>  * A Query is a series of clauses. A clause may be prefixed by:  *<ul>  *<li>a plus (<code>+</code>) or a minus (<code>-</code>) sign, indicating that  * the clause is required or prohibited respectively; or  *<li>a term followed by a colon, indicating the field to be searched. This  * enables one to construct queries which search multiple fields.  *</ul>  *   * A clause may be either:  *<ul>  *<li>a term, indicating all the documents that contain this term; or  *<li>a nested query, enclosed in parentheses. Note that this may be used with  * a<code>+</code>/<code>-</code> prefix to require any of a set of terms.  *</ul>  *   * Thus, in BNF, the query grammar is:  *   *<pre>  *   Query  ::= ( Clause )*  *   Clause ::= [&quot;+&quot;,&quot;-&quot;] [&lt;TERM&gt;&quot;:&quot;] (&lt;TERM&gt; |&quot;(&quot; Query&quot;)&quot; )  *</pre>  *   *<p>  * Examples of appropriately formatted queries can be found in the<a  * href="../../../../../../queryparsersyntax.html">query syntax  * documentation</a>.  *</p>  *</ul>  *<p>  * The text parser used by this helper is a {@link StandardSyntaxParser}.  *<p/>  *<p>  * The query node processor used by this helper is a  * {@link StandardQueryNodeProcessorPipeline}.  *<p/>  *<p>  * The builder used by this helper is a {@link StandardQueryTreeBuilder}.  *<p/>  *   * @see StandardQueryParser  * @see StandardQueryConfigHandler  * @see StandardSyntaxParser  * @see StandardQueryNodeProcessorPipeline  * @see StandardQueryTreeBuilder  */
end_comment
begin_class
DECL|class|StandardQueryParser
specifier|public
class|class
name|StandardQueryParser
extends|extends
name|QueryParserHelper
block|{
comment|/**    * Constructs a {@link StandardQueryParser} object.    */
DECL|method|StandardQueryParser
specifier|public
name|StandardQueryParser
parameter_list|()
block|{
name|super
argument_list|(
operator|new
name|StandardQueryConfigHandler
argument_list|()
argument_list|,
operator|new
name|StandardSyntaxParser
argument_list|()
argument_list|,
operator|new
name|StandardQueryNodeProcessorPipeline
argument_list|(
literal|null
argument_list|)
argument_list|,
operator|new
name|StandardQueryTreeBuilder
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs a {@link StandardQueryParser} object and sets an    * {@link Analyzer} to it. The same as:    *     *<ul>    * StandardQueryParser qp = new StandardQueryParser();    * qp.getQueryConfigHandler().setAnalyzer(analyzer);    *</ul>    *     * @param analyzer    *          the analyzer to be used by this query parser helper    */
DECL|method|StandardQueryParser
specifier|public
name|StandardQueryParser
parameter_list|(
name|Analyzer
name|analyzer
parameter_list|)
block|{
name|this
argument_list|()
expr_stmt|;
name|this
operator|.
name|setAnalyzer
argument_list|(
name|analyzer
argument_list|)
expr_stmt|;
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"<StandardQueryParser config=\""
operator|+
name|this
operator|.
name|getQueryConfigHandler
argument_list|()
operator|+
literal|"\"/>"
return|;
block|}
comment|/**    * Overrides {@link QueryParserHelper#parse(String, String)} so it casts the    * return object to {@link Query}. For more reference about this method, check    * {@link QueryParserHelper#parse(String, String)}.    *     * @param query    *          the query string    * @param defaultField    *          the default field used by the text parser    *     * @return the object built from the query    *     * @throws QueryNodeException    *           if something wrong happens along the three phases    */
annotation|@
name|Override
DECL|method|parse
specifier|public
name|Query
name|parse
parameter_list|(
name|String
name|query
parameter_list|,
name|String
name|defaultField
parameter_list|)
throws|throws
name|QueryNodeException
block|{
return|return
operator|(
name|Query
operator|)
name|super
operator|.
name|parse
argument_list|(
name|query
argument_list|,
name|defaultField
argument_list|)
return|;
block|}
comment|/**    * Gets implicit operator setting, which will be either {@link Operator#AND}    * or {@link Operator#OR}.    */
DECL|method|getDefaultOperator
specifier|public
name|Operator
name|getDefaultOperator
parameter_list|()
block|{
name|DefaultOperatorAttribute
name|attr
init|=
operator|(
name|DefaultOperatorAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|getAttribute
argument_list|(
name|DefaultOperatorAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|attr
operator|.
name|getOperator
argument_list|()
return|;
block|}
comment|/**    * Sets the collator used to determine index term inclusion in ranges for    * RangeQuerys.    *<p/>    *<strong>WARNING:</strong> Setting the rangeCollator to a non-null collator    * using this method will cause every single index Term in the Field    * referenced by lowerTerm and/or upperTerm to be examined. Depending on the    * number of index Terms in this Field, the operation could be very slow.    *     * @param collator    *          the collator to use when constructing {@link RangeQueryNode}s    */
DECL|method|setRangeCollator
specifier|public
name|void
name|setRangeCollator
parameter_list|(
name|Collator
name|collator
parameter_list|)
block|{
name|RangeCollatorAttribute
name|attr
init|=
operator|(
name|RangeCollatorAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|getAttribute
argument_list|(
name|RangeCollatorAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|attr
operator|.
name|setDateResolution
argument_list|(
name|collator
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return the collator used to determine index term inclusion in ranges for    *         RangeQuerys.    */
DECL|method|getRangeCollator
specifier|public
name|Collator
name|getRangeCollator
parameter_list|()
block|{
name|RangeCollatorAttribute
name|attr
init|=
operator|(
name|RangeCollatorAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|getAttribute
argument_list|(
name|RangeCollatorAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|attr
operator|.
name|getRangeCollator
argument_list|()
return|;
block|}
comment|/**    * Sets the boolean operator of the QueryParser. In default mode (    * {@link Operator#OR}) terms without any modifiers are considered optional:    * for example<code>capital of Hungary</code> is equal to    *<code>capital OR of OR Hungary</code>.<br/>    * In {@link Operator#AND} mode terms are considered to be in conjunction: the    * above mentioned query is parsed as<code>capital AND of AND Hungary</code>    */
DECL|method|setDefaultOperator
specifier|public
name|void
name|setDefaultOperator
parameter_list|(
name|Operator
name|operator
parameter_list|)
block|{
name|DefaultOperatorAttribute
name|attr
init|=
operator|(
name|DefaultOperatorAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|getAttribute
argument_list|(
name|DefaultOperatorAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|attr
operator|.
name|setOperator
argument_list|(
name|operator
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set to<code>true</code> to allow leading wildcard characters.    *<p>    * When set,<code>*</code> or<code>?</code> are allowed as the first    * character of a PrefixQuery and WildcardQuery. Note that this can produce    * very slow queries on big indexes.    *<p>    * Default: false.    */
DECL|method|setLowercaseExpandedTerms
specifier|public
name|void
name|setLowercaseExpandedTerms
parameter_list|(
name|boolean
name|lowercaseExpandedTerms
parameter_list|)
block|{
name|LowercaseExpandedTermsAttribute
name|attr
init|=
operator|(
name|LowercaseExpandedTermsAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|getAttribute
argument_list|(
name|LowercaseExpandedTermsAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|attr
operator|.
name|setLowercaseExpandedTerms
argument_list|(
name|lowercaseExpandedTerms
argument_list|)
expr_stmt|;
block|}
comment|/**    * @see #setLowercaseExpandedTerms(boolean)    */
DECL|method|getLowercaseExpandedTerms
specifier|public
name|boolean
name|getLowercaseExpandedTerms
parameter_list|()
block|{
name|LowercaseExpandedTermsAttribute
name|attr
init|=
operator|(
name|LowercaseExpandedTermsAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|getAttribute
argument_list|(
name|LowercaseExpandedTermsAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|attr
operator|.
name|isLowercaseExpandedTerms
argument_list|()
return|;
block|}
comment|/**    * Set to<code>true</code> to allow leading wildcard characters.    *<p>    * When set,<code>*</code> or<code>?</code> are allowed as the first    * character of a PrefixQuery and WildcardQuery. Note that this can produce    * very slow queries on big indexes.    *<p>    * Default: false.    */
DECL|method|setAllowLeadingWildcard
specifier|public
name|void
name|setAllowLeadingWildcard
parameter_list|(
name|boolean
name|allowLeadingWildcard
parameter_list|)
block|{
name|AllowLeadingWildcardAttribute
name|attr
init|=
operator|(
name|AllowLeadingWildcardAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|getAttribute
argument_list|(
name|AllowLeadingWildcardAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|attr
operator|.
name|setAllowLeadingWildcard
argument_list|(
name|allowLeadingWildcard
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set to<code>true</code> to enable position increments in result query.    *<p>    * When set, result phrase and multi-phrase queries will be aware of position    * increments. Useful when e.g. a StopFilter increases the position increment    * of the token that follows an omitted token.    *<p>    * Default: false.    */
DECL|method|setEnablePositionIncrements
specifier|public
name|void
name|setEnablePositionIncrements
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
name|PositionIncrementsAttribute
name|attr
init|=
operator|(
name|PositionIncrementsAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|getAttribute
argument_list|(
name|PositionIncrementsAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|attr
operator|.
name|setPositionIncrementsEnabled
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
block|}
comment|/**    * @see #setEnablePositionIncrements(boolean)    */
DECL|method|getEnablePositionIncrements
specifier|public
name|boolean
name|getEnablePositionIncrements
parameter_list|()
block|{
name|PositionIncrementsAttribute
name|attr
init|=
operator|(
name|PositionIncrementsAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|getAttribute
argument_list|(
name|PositionIncrementsAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|attr
operator|.
name|isPositionIncrementsEnabled
argument_list|()
return|;
block|}
comment|/**    * By default, it uses    * {@link MultiTermQuery#CONSTANT_SCORE_AUTO_REWRITE_DEFAULT} when creating a    * prefix, wildcard and range queries. This implementation is generally    * preferable because it a) Runs faster b) Does not have the scarcity of terms    * unduly influence score c) avoids any {@link TooManyListenersException}    * exception. However, if your application really needs to use the    * old-fashioned boolean queries expansion rewriting and the above points are    * not relevant then use this change the rewrite method.    */
DECL|method|setMultiTermRewriteMethod
specifier|public
name|void
name|setMultiTermRewriteMethod
parameter_list|(
name|MultiTermQuery
operator|.
name|RewriteMethod
name|method
parameter_list|)
block|{
name|MultiTermRewriteMethodAttribute
name|attr
init|=
operator|(
name|MultiTermRewriteMethodAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|getAttribute
argument_list|(
name|MultiTermRewriteMethodAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|attr
operator|.
name|setMultiTermRewriteMethod
argument_list|(
name|method
argument_list|)
expr_stmt|;
block|}
comment|/**    * @see #setMultiTermRewriteMethod(org.apache.lucene.search.MultiTermQuery.RewriteMethod)    */
DECL|method|getMultiTermRewriteMethod
specifier|public
name|MultiTermQuery
operator|.
name|RewriteMethod
name|getMultiTermRewriteMethod
parameter_list|()
block|{
name|MultiTermRewriteMethodAttribute
name|attr
init|=
operator|(
name|MultiTermRewriteMethodAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|getAttribute
argument_list|(
name|MultiTermRewriteMethodAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|attr
operator|.
name|getMultiTermRewriteMethod
argument_list|()
return|;
block|}
DECL|method|setMultiFields
specifier|public
name|void
name|setMultiFields
parameter_list|(
name|CharSequence
index|[]
name|fields
parameter_list|)
block|{
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
name|fields
operator|=
operator|new
name|CharSequence
index|[
literal|0
index|]
expr_stmt|;
block|}
name|MultiFieldAttribute
name|attr
init|=
operator|(
name|MultiFieldAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|MultiFieldAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|attr
operator|.
name|setFields
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the prefix length for fuzzy queries. Default is 0.    *     * @param fuzzyPrefixLength    *          The fuzzyPrefixLength to set.    */
DECL|method|setFuzzyPrefixLength
specifier|public
name|void
name|setFuzzyPrefixLength
parameter_list|(
name|int
name|fuzzyPrefixLength
parameter_list|)
block|{
name|FuzzyAttribute
name|attr
init|=
operator|(
name|FuzzyAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|FuzzyAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|attr
operator|.
name|setPrefixLength
argument_list|(
name|fuzzyPrefixLength
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set locale used by date range parsing.    */
DECL|method|setLocale
specifier|public
name|void
name|setLocale
parameter_list|(
name|Locale
name|locale
parameter_list|)
block|{
name|LocaleAttribute
name|attr
init|=
operator|(
name|LocaleAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|LocaleAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|attr
operator|.
name|setLocale
argument_list|(
name|locale
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns current locale, allowing access by subclasses.    */
DECL|method|getLocale
specifier|public
name|Locale
name|getLocale
parameter_list|()
block|{
name|LocaleAttribute
name|attr
init|=
operator|(
name|LocaleAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|LocaleAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|attr
operator|.
name|getLocale
argument_list|()
return|;
block|}
comment|/**    * Sets the default slop for phrases. If zero, then exact phrase matches are    * required. Default value is zero.    */
DECL|method|setDefaultPhraseSlop
specifier|public
name|void
name|setDefaultPhraseSlop
parameter_list|(
name|int
name|defaultPhraseSlop
parameter_list|)
block|{
name|DefaultPhraseSlopAttribute
name|attr
init|=
operator|(
name|DefaultPhraseSlopAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|DefaultPhraseSlopAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|attr
operator|.
name|setDefaultPhraseSlop
argument_list|(
name|defaultPhraseSlop
argument_list|)
expr_stmt|;
block|}
DECL|method|setAnalyzer
specifier|public
name|void
name|setAnalyzer
parameter_list|(
name|Analyzer
name|analyzer
parameter_list|)
block|{
name|AnalyzerAttribute
name|attr
init|=
operator|(
name|AnalyzerAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|getAttribute
argument_list|(
name|AnalyzerAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|attr
operator|.
name|setAnalyzer
argument_list|(
name|analyzer
argument_list|)
expr_stmt|;
block|}
DECL|method|getAnalyzer
specifier|public
name|Analyzer
name|getAnalyzer
parameter_list|()
block|{
name|QueryConfigHandler
name|config
init|=
name|this
operator|.
name|getQueryConfigHandler
argument_list|()
decl_stmt|;
if|if
condition|(
name|config
operator|.
name|hasAttribute
argument_list|(
name|AnalyzerAttribute
operator|.
name|class
argument_list|)
condition|)
block|{
name|AnalyzerAttribute
name|attr
init|=
operator|(
name|AnalyzerAttribute
operator|)
name|config
operator|.
name|getAttribute
argument_list|(
name|AnalyzerAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|attr
operator|.
name|getAnalyzer
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @see #setAllowLeadingWildcard(boolean)    */
DECL|method|getAllowLeadingWildcard
specifier|public
name|boolean
name|getAllowLeadingWildcard
parameter_list|()
block|{
name|AllowLeadingWildcardAttribute
name|attr
init|=
operator|(
name|AllowLeadingWildcardAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|AllowLeadingWildcardAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|attr
operator|.
name|isAllowLeadingWildcard
argument_list|()
return|;
block|}
comment|/**    * Get the minimal similarity for fuzzy queries.    */
DECL|method|getFuzzyMinSim
specifier|public
name|float
name|getFuzzyMinSim
parameter_list|()
block|{
name|FuzzyAttribute
name|attr
init|=
operator|(
name|FuzzyAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|FuzzyAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|attr
operator|.
name|getFuzzyMinSimilarity
argument_list|()
return|;
block|}
comment|/**    * Get the prefix length for fuzzy queries.    *     * @return Returns the fuzzyPrefixLength.    */
DECL|method|getFuzzyPrefixLength
specifier|public
name|int
name|getFuzzyPrefixLength
parameter_list|()
block|{
name|FuzzyAttribute
name|attr
init|=
operator|(
name|FuzzyAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|FuzzyAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|attr
operator|.
name|getPrefixLength
argument_list|()
return|;
block|}
comment|/**    * Gets the default slop for phrases.    */
DECL|method|getPhraseSlop
specifier|public
name|int
name|getPhraseSlop
parameter_list|()
block|{
name|DefaultPhraseSlopAttribute
name|attr
init|=
operator|(
name|DefaultPhraseSlopAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|DefaultPhraseSlopAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|attr
operator|.
name|getDefaultPhraseSlop
argument_list|()
return|;
block|}
comment|/**    * Set the minimum similarity for fuzzy queries. Default is defined on    * {@link FuzzyQuery#defaultMinSimilarity}.    */
DECL|method|setFuzzyMinSim
specifier|public
name|void
name|setFuzzyMinSim
parameter_list|(
name|float
name|fuzzyMinSim
parameter_list|)
block|{
name|FuzzyAttribute
name|attr
init|=
operator|(
name|FuzzyAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|FuzzyAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|attr
operator|.
name|setFuzzyMinSimilarity
argument_list|(
name|fuzzyMinSim
argument_list|)
expr_stmt|;
block|}
DECL|method|setFieldsBoost
specifier|public
name|void
name|setFieldsBoost
parameter_list|(
name|Map
argument_list|<
name|CharSequence
argument_list|,
name|Float
argument_list|>
name|boosts
parameter_list|)
block|{
name|FieldBoostMapAttribute
name|attr
init|=
operator|(
name|FieldBoostMapAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|FieldBoostMapAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|attr
operator|.
name|setFieldBoostMap
argument_list|(
name|boosts
argument_list|)
expr_stmt|;
block|}
DECL|method|setDateResolution
specifier|public
name|void
name|setDateResolution
parameter_list|(
name|DateTools
operator|.
name|Resolution
name|dateResolution
parameter_list|)
block|{
name|DateResolutionAttribute
name|attr
init|=
operator|(
name|DateResolutionAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|DateResolutionAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|attr
operator|.
name|setDateResolution
argument_list|(
name|dateResolution
argument_list|)
expr_stmt|;
block|}
DECL|method|setDateResolution
specifier|public
name|void
name|setDateResolution
parameter_list|(
name|Map
argument_list|<
name|CharSequence
argument_list|,
name|DateTools
operator|.
name|Resolution
argument_list|>
name|dateRes
parameter_list|)
block|{
name|FieldDateResolutionMapAttribute
name|attr
init|=
operator|(
name|FieldDateResolutionMapAttribute
operator|)
name|getQueryConfigHandler
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|FieldDateResolutionMapAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|attr
operator|.
name|setFieldDateResolutionMap
argument_list|(
name|dateRes
argument_list|)
expr_stmt|;
block|}
block|}
end_class
end_unit
