begin_unit
begin_package
DECL|package|org.apache.lucene.util.automaton.fst
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|fst
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockAnalyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriterConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiFields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|CodecProvider
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MockDirectoryWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LineFileDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|UnicodeUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|_TestUtil
import|;
end_import
begin_class
DECL|class|TestFSTs
specifier|public
class|class
name|TestFSTs
extends|extends
name|LuceneTestCase
block|{
DECL|field|dir
specifier|private
name|MockDirectoryWrapper
name|dir
decl_stmt|;
DECL|method|setUp
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|IOException
block|{
name|dir
operator|=
name|newDirectory
argument_list|()
expr_stmt|;
name|dir
operator|.
name|setPreventDoubleWrite
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|tearDown
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|IOException
block|{
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|toBytesRef
specifier|private
specifier|static
name|BytesRef
name|toBytesRef
parameter_list|(
name|IntsRef
name|ir
parameter_list|)
block|{
name|BytesRef
name|br
init|=
operator|new
name|BytesRef
argument_list|(
name|ir
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ir
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|x
init|=
name|ir
operator|.
name|ints
index|[
name|ir
operator|.
name|offset
operator|+
name|i
index|]
decl_stmt|;
assert|assert
name|x
operator|>=
literal|0
operator|&&
name|x
operator|<=
literal|255
assert|;
name|br
operator|.
name|bytes
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|x
expr_stmt|;
block|}
name|br
operator|.
name|length
operator|=
name|ir
operator|.
name|length
expr_stmt|;
return|return
name|br
return|;
block|}
DECL|method|toIntsRef
specifier|private
specifier|static
name|IntsRef
name|toIntsRef
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|inputMode
parameter_list|)
block|{
return|return
name|toIntsRef
argument_list|(
name|s
argument_list|,
name|inputMode
argument_list|,
operator|new
name|IntsRef
argument_list|(
literal|10
argument_list|)
argument_list|)
return|;
block|}
DECL|method|toIntsRef
specifier|private
specifier|static
name|IntsRef
name|toIntsRef
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|inputMode
parameter_list|,
name|IntsRef
name|ir
parameter_list|)
block|{
if|if
condition|(
name|inputMode
operator|==
literal|0
condition|)
block|{
comment|// utf8
return|return
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|s
argument_list|)
argument_list|,
name|ir
argument_list|)
return|;
block|}
else|else
block|{
comment|// utf32
return|return
name|toIntsRefUTF32
argument_list|(
name|s
argument_list|,
name|ir
argument_list|)
return|;
block|}
block|}
DECL|method|toIntsRefUTF32
specifier|private
specifier|static
name|IntsRef
name|toIntsRefUTF32
parameter_list|(
name|String
name|s
parameter_list|,
name|IntsRef
name|ir
parameter_list|)
block|{
specifier|final
name|int
name|charLength
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|charIdx
init|=
literal|0
decl_stmt|;
name|int
name|intIdx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|charIdx
operator|<
name|charLength
condition|)
block|{
if|if
condition|(
name|intIdx
operator|==
name|ir
operator|.
name|ints
operator|.
name|length
condition|)
block|{
name|ir
operator|.
name|grow
argument_list|(
name|intIdx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|utf32
init|=
name|s
operator|.
name|codePointAt
argument_list|(
name|charIdx
argument_list|)
decl_stmt|;
name|ir
operator|.
name|ints
index|[
name|intIdx
index|]
operator|=
name|utf32
expr_stmt|;
name|charIdx
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|utf32
argument_list|)
expr_stmt|;
name|intIdx
operator|++
expr_stmt|;
block|}
name|ir
operator|.
name|length
operator|=
name|intIdx
expr_stmt|;
return|return
name|ir
return|;
block|}
DECL|method|toIntsRef
specifier|private
specifier|static
name|IntsRef
name|toIntsRef
parameter_list|(
name|BytesRef
name|br
parameter_list|,
name|IntsRef
name|ir
parameter_list|)
block|{
if|if
condition|(
name|br
operator|.
name|length
operator|>
name|ir
operator|.
name|ints
operator|.
name|length
condition|)
block|{
name|ir
operator|.
name|grow
argument_list|(
name|br
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|br
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ir
operator|.
name|ints
index|[
name|i
index|]
operator|=
name|br
operator|.
name|bytes
index|[
name|br
operator|.
name|offset
operator|+
name|i
index|]
operator|&
literal|0xFF
expr_stmt|;
block|}
name|ir
operator|.
name|length
operator|=
name|br
operator|.
name|length
expr_stmt|;
return|return
name|ir
return|;
block|}
DECL|method|testBasicFSA
specifier|public
name|void
name|testBasicFSA
parameter_list|()
throws|throws
name|IOException
block|{
name|String
index|[]
name|strings
init|=
operator|new
name|String
index|[]
block|{
literal|"station"
block|,
literal|"commotion"
block|,
literal|"elation"
block|,
literal|"elastic"
block|,
literal|"plastic"
block|,
literal|"stop"
block|,
literal|"ftop"
block|,
literal|"ftation"
block|}
decl_stmt|;
name|IntsRef
index|[]
name|terms
init|=
operator|new
name|IntsRef
index|[
name|strings
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|inputMode
init|=
literal|0
init|;
name|inputMode
operator|<
literal|2
condition|;
name|inputMode
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: inputMode="
operator|+
name|inputModeToString
argument_list|(
name|inputMode
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|strings
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|terms
index|[
name|idx
index|]
operator|=
name|toIntsRef
argument_list|(
name|strings
index|[
name|idx
index|]
argument_list|,
name|inputMode
argument_list|)
expr_stmt|;
block|}
name|doTest
argument_list|(
name|inputMode
argument_list|,
name|terms
argument_list|)
expr_stmt|;
comment|// Test pre-determined FST sizes to make sure we haven't lost minimality (at least on this trivial set of terms):
comment|// FSA
block|{
specifier|final
name|Outputs
argument_list|<
name|Object
argument_list|>
name|outputs
init|=
name|NoOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|IntsRef
name|term
range|:
name|terms
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|(
name|term
argument_list|,
name|NO_OUTPUT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FST
argument_list|<
name|Object
argument_list|>
name|fst
init|=
operator|new
name|FSTTester
argument_list|<
name|Object
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|)
operator|.
name|doTest
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|22
argument_list|,
name|fst
operator|.
name|getNodeCount
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|27
argument_list|,
name|fst
operator|.
name|getArcCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// FST ord pos int
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|outputs
operator|.
name|get
argument_list|(
name|idx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
operator|new
name|FSTTester
argument_list|<
name|Long
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|)
operator|.
name|doTest
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|22
argument_list|,
name|fst
operator|.
name|getNodeCount
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|27
argument_list|,
name|fst
operator|.
name|getArcCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// FST byte sequence ord
block|{
specifier|final
name|ByteSequenceOutputs
name|outputs
init|=
name|ByteSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|BytesRef
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|BytesRef
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|BytesRef
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|BytesRef
name|output
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|30
argument_list|)
operator|==
literal|17
condition|?
name|NO_OUTPUT
else|:
operator|new
name|BytesRef
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|idx
argument_list|)
argument_list|)
decl_stmt|;
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|BytesRef
argument_list|>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FST
argument_list|<
name|BytesRef
argument_list|>
name|fst
init|=
operator|new
name|FSTTester
argument_list|<
name|BytesRef
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|)
operator|.
name|doTest
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|24
argument_list|,
name|fst
operator|.
name|getNodeCount
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|30
argument_list|,
name|fst
operator|.
name|getArcCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|simpleRandomString
specifier|private
specifier|static
name|String
name|simpleRandomString
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|r
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
literal|0
condition|)
block|{
comment|// allow 0 length
return|return
literal|""
return|;
block|}
specifier|final
name|char
index|[]
name|buffer
init|=
operator|new
name|char
index|[
name|end
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|97
argument_list|,
literal|102
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|end
argument_list|)
return|;
block|}
comment|// given set of terms, test the different outputs for them
DECL|method|doTest
specifier|private
name|void
name|doTest
parameter_list|(
name|int
name|inputMode
parameter_list|,
name|IntsRef
index|[]
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|terms
argument_list|)
expr_stmt|;
comment|// NoOutputs (simple FSA)
block|{
specifier|final
name|Outputs
argument_list|<
name|Object
argument_list|>
name|outputs
init|=
name|NoOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|IntsRef
name|term
range|:
name|terms
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Object
argument_list|>
argument_list|(
name|term
argument_list|,
name|NO_OUTPUT
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<
name|Object
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|)
operator|.
name|doTest
argument_list|()
expr_stmt|;
block|}
comment|// PositiveIntOutput (ord)
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|outputs
operator|.
name|get
argument_list|(
name|idx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<
name|Long
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|)
operator|.
name|doTest
argument_list|()
expr_stmt|;
block|}
comment|// PositiveIntOutput (random monotonically increasing positive number)
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
name|long
name|lastOutput
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|long
name|value
init|=
name|lastOutput
operator|+
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|lastOutput
operator|=
name|value
expr_stmt|;
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|outputs
operator|.
name|get
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<
name|Long
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|)
operator|.
name|doTest
argument_list|()
expr_stmt|;
block|}
comment|// PositiveIntOutput (random positive number)
block|{
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|outputs
operator|.
name|get
argument_list|(
name|random
operator|.
name|nextLong
argument_list|()
argument_list|)
operator|&
name|Long
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<
name|Long
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|)
operator|.
name|doTest
argument_list|()
expr_stmt|;
block|}
comment|// Pair<ord, (random monotonically increasing positive number>
block|{
specifier|final
name|PositiveIntOutputs
name|o1
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|PositiveIntOutputs
name|o2
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|PairOutputs
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|outputs
init|=
operator|new
name|PairOutputs
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|PairOutputs
operator|.
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|PairOutputs
operator|.
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
name|long
name|lastOutput
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|long
name|value
init|=
name|lastOutput
operator|+
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|lastOutput
operator|=
name|value
expr_stmt|;
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|PairOutputs
operator|.
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|outputs
operator|.
name|get
argument_list|(
name|o1
operator|.
name|get
argument_list|(
name|idx
argument_list|)
argument_list|,
name|o2
operator|.
name|get
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<
name|PairOutputs
operator|.
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|)
operator|.
name|doTest
argument_list|()
expr_stmt|;
block|}
comment|// Sequence-of-bytes
block|{
specifier|final
name|ByteSequenceOutputs
name|outputs
init|=
name|ByteSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|BytesRef
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|BytesRef
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|BytesRef
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|BytesRef
name|output
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|30
argument_list|)
operator|==
literal|17
condition|?
name|NO_OUTPUT
else|:
operator|new
name|BytesRef
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|idx
argument_list|)
argument_list|)
decl_stmt|;
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|BytesRef
argument_list|>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<
name|BytesRef
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|)
operator|.
name|doTest
argument_list|()
expr_stmt|;
block|}
comment|// Sequence-of-ints
block|{
specifier|final
name|IntSequenceOutputs
name|outputs
init|=
name|IntSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|IntsRef
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|IntsRef
argument_list|>
argument_list|>
argument_list|(
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|terms
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|String
name|s
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|idx
argument_list|)
decl_stmt|;
specifier|final
name|IntsRef
name|output
init|=
operator|new
name|IntsRef
argument_list|(
name|s
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|output
operator|.
name|length
operator|=
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|idx2
init|=
literal|0
init|;
name|idx2
operator|<
name|output
operator|.
name|length
condition|;
name|idx2
operator|++
control|)
block|{
name|output
operator|.
name|ints
index|[
name|idx2
index|]
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|idx2
argument_list|)
expr_stmt|;
block|}
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|FSTTester
operator|.
name|InputOutput
argument_list|<
name|IntsRef
argument_list|>
argument_list|(
name|terms
index|[
name|idx
index|]
argument_list|,
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|FSTTester
argument_list|<
name|IntsRef
argument_list|>
argument_list|(
name|random
argument_list|,
name|dir
argument_list|,
name|inputMode
argument_list|,
name|pairs
argument_list|,
name|outputs
argument_list|)
operator|.
name|doTest
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|FSTTester
specifier|private
specifier|static
class|class
name|FSTTester
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|random
specifier|final
name|Random
name|random
decl_stmt|;
DECL|field|pairs
specifier|final
name|List
argument_list|<
name|InputOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|pairs
decl_stmt|;
DECL|field|inputMode
specifier|final
name|int
name|inputMode
decl_stmt|;
DECL|field|outputs
specifier|final
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
decl_stmt|;
DECL|field|dir
specifier|final
name|Directory
name|dir
decl_stmt|;
DECL|method|FSTTester
specifier|public
name|FSTTester
parameter_list|(
name|Random
name|random
parameter_list|,
name|Directory
name|dir
parameter_list|,
name|int
name|inputMode
parameter_list|,
name|List
argument_list|<
name|InputOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|pairs
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|)
block|{
name|this
operator|.
name|random
operator|=
name|random
expr_stmt|;
name|this
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
name|this
operator|.
name|inputMode
operator|=
name|inputMode
expr_stmt|;
name|this
operator|.
name|pairs
operator|=
name|pairs
expr_stmt|;
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
block|}
DECL|class|InputOutput
specifier|private
specifier|static
class|class
name|InputOutput
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Comparable
argument_list|<
name|InputOutput
argument_list|<
name|T
argument_list|>
argument_list|>
block|{
DECL|field|input
specifier|public
specifier|final
name|IntsRef
name|input
decl_stmt|;
DECL|field|output
specifier|public
specifier|final
name|T
name|output
decl_stmt|;
DECL|method|InputOutput
specifier|public
name|InputOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|T
name|output
parameter_list|)
block|{
name|this
operator|.
name|input
operator|=
name|input
expr_stmt|;
name|this
operator|.
name|output
operator|=
name|output
expr_stmt|;
block|}
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|instanceof
name|InputOutput
condition|)
block|{
return|return
name|input
operator|.
name|compareTo
argument_list|(
operator|(
name|other
operator|)
operator|.
name|input
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
block|}
block|}
DECL|method|getRandomString
specifier|private
name|String
name|getRandomString
parameter_list|()
block|{
specifier|final
name|String
name|term
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|term
operator|=
name|_TestUtil
operator|.
name|randomRealisticUnicodeString
argument_list|(
name|random
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we want to mix in limited-alphabet symbols so
comment|// we get more sharing of the nodes given how few
comment|// terms we are testing...
name|term
operator|=
name|simpleRandomString
argument_list|(
name|random
argument_list|)
expr_stmt|;
block|}
return|return
name|term
return|;
block|}
DECL|method|doTest
specifier|public
name|void
name|doTest
parameter_list|()
throws|throws
name|IOException
block|{
comment|// no pruning
name|doTest
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// simple pruning
name|doTest
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|1
operator|+
name|pairs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// leafy pruning
name|doTest
argument_list|(
literal|0
argument_list|,
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|1
operator|+
name|pairs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// NOTE: only copies the stuff this test needs!!
DECL|method|copyArc
specifier|private
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|copyArc
parameter_list|(
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
block|{
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|copy
init|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
name|copy
operator|.
name|label
operator|=
name|arc
operator|.
name|label
expr_stmt|;
name|copy
operator|.
name|target
operator|=
name|arc
operator|.
name|target
expr_stmt|;
name|copy
operator|.
name|output
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|copy
operator|.
name|nextFinalOutput
operator|=
name|arc
operator|.
name|nextFinalOutput
expr_stmt|;
return|return
name|arc
return|;
block|}
comment|// runs the term, returning the output, or null if term
comment|// isn't accepted.  if stopNode is non-null it must be
comment|// length 2 int array; stopNode[0] will be the last
comment|// matching node (-1 if the term is accepted)
comment|// and stopNode[1] will be the length of the
comment|// term prefix that matches
DECL|method|run
specifier|private
name|T
name|run
parameter_list|(
name|FST
argument_list|<
name|T
argument_list|>
name|fst
parameter_list|,
name|IntsRef
name|term
parameter_list|,
name|int
index|[]
name|stopNode
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|term
operator|.
name|length
operator|==
literal|0
condition|)
block|{
specifier|final
name|T
name|output
init|=
name|fst
operator|.
name|getEmptyOutput
argument_list|()
decl_stmt|;
if|if
condition|(
name|stopNode
operator|!=
literal|null
condition|)
block|{
name|stopNode
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|output
operator|!=
literal|null
condition|)
block|{
comment|// accepted
name|stopNode
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|stopNode
index|[
literal|0
index|]
operator|=
name|fst
operator|.
name|getStartNode
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|output
return|;
block|}
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|node
init|=
name|fst
operator|.
name|getStartNode
argument_list|()
decl_stmt|;
name|int
name|lastNode
init|=
operator|-
literal|1
decl_stmt|;
name|T
name|output
init|=
name|fst
operator|.
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
comment|//System.out.println("match?");
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|term
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|//System.out.println("  int=" + term.ints[i]);
if|if
condition|(
operator|!
name|fst
operator|.
name|hasArcs
argument_list|(
name|node
argument_list|)
condition|)
block|{
comment|//System.out.println("    no arcs!");
comment|// hit end node before term's end
if|if
condition|(
name|stopNode
operator|!=
literal|null
condition|)
block|{
name|stopNode
index|[
literal|0
index|]
operator|=
name|lastNode
expr_stmt|;
name|stopNode
index|[
literal|1
index|]
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
name|output
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
if|if
condition|(
name|fst
operator|.
name|findArc
argument_list|(
name|node
argument_list|,
name|term
operator|.
name|ints
index|[
name|term
operator|.
name|offset
operator|+
name|i
index|]
argument_list|,
name|arc
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|node
operator|=
name|arc
operator|.
name|target
expr_stmt|;
comment|//System.out.println("    match final?=" + arc.isFinal());
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|fst
operator|.
name|outputs
operator|.
name|getNoOutput
argument_list|()
condition|)
block|{
name|output
operator|=
name|fst
operator|.
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stopNode
operator|!=
literal|null
condition|)
block|{
name|stopNode
index|[
literal|0
index|]
operator|=
name|node
expr_stmt|;
name|stopNode
index|[
literal|1
index|]
operator|=
name|i
expr_stmt|;
return|return
name|output
return|;
block|}
else|else
block|{
comment|//System.out.println("    no match");
return|return
literal|null
return|;
block|}
name|lastNode
operator|=
name|node
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|// hit term's end before end node
if|if
condition|(
name|stopNode
operator|!=
literal|null
condition|)
block|{
name|stopNode
index|[
literal|0
index|]
operator|=
name|node
expr_stmt|;
name|stopNode
index|[
literal|1
index|]
operator|=
name|term
operator|.
name|length
expr_stmt|;
return|return
name|output
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|fst
operator|.
name|outputs
operator|.
name|getNoOutput
argument_list|()
condition|)
block|{
name|output
operator|=
name|fst
operator|.
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stopNode
operator|!=
literal|null
condition|)
block|{
name|stopNode
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|stopNode
index|[
literal|1
index|]
operator|=
name|term
operator|.
name|length
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
DECL|method|randomAcceptedWord
specifier|private
name|T
name|randomAcceptedWord
parameter_list|(
name|FST
argument_list|<
name|T
argument_list|>
name|fst
parameter_list|,
name|IntsRef
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|node
init|=
name|fst
operator|.
name|getStartNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|fst
operator|.
name|noNodes
argument_list|()
condition|)
block|{
comment|// degenerate FST: only accepts the empty string
name|assertTrue
argument_list|(
name|fst
operator|.
name|getEmptyOutput
argument_list|()
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|in
operator|.
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|fst
operator|.
name|getEmptyOutput
argument_list|()
return|;
block|}
specifier|final
name|List
argument_list|<
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|>
name|arcs
init|=
operator|new
name|ArrayList
argument_list|<
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|in
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|in
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|T
name|output
init|=
name|fst
operator|.
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
comment|//System.out.println("get random");
while|while
condition|(
literal|true
condition|)
block|{
comment|// read all arcs:
comment|//System.out.println("  n=" + node);
name|int
name|arcAddress
init|=
name|node
decl_stmt|;
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
name|fst
operator|.
name|readFirstArc
argument_list|(
name|arcAddress
argument_list|,
name|arc
argument_list|)
expr_stmt|;
name|arcs
operator|.
name|add
argument_list|(
name|copyArc
argument_list|(
name|arc
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
name|fst
operator|.
name|readNextArc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
name|arcs
operator|.
name|add
argument_list|(
name|copyArc
argument_list|(
name|arc
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// pick one
name|arc
operator|=
name|arcs
operator|.
name|get
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
name|arcs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|arcs
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// append label
if|if
condition|(
name|in
operator|.
name|ints
operator|.
name|length
operator|==
name|in
operator|.
name|length
condition|)
block|{
name|in
operator|.
name|grow
argument_list|(
literal|1
operator|+
name|in
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|in
operator|.
name|ints
index|[
name|in
operator|.
name|length
operator|++
index|]
operator|=
name|arc
operator|.
name|label
expr_stmt|;
name|output
operator|=
name|fst
operator|.
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
comment|// maybe stop
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
if|if
condition|(
name|fst
operator|.
name|hasArcs
argument_list|(
name|arc
operator|.
name|target
argument_list|)
condition|)
block|{
comment|// final state but it also has outgoing edges
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|output
operator|=
name|fst
operator|.
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
name|node
operator|=
name|arc
operator|.
name|target
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
DECL|method|doTest
specifier|private
name|FST
argument_list|<
name|T
argument_list|>
name|doTest
parameter_list|(
name|int
name|prune1
parameter_list|,
name|int
name|prune2
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: prune1="
operator|+
name|prune1
operator|+
literal|" prune2="
operator|+
name|prune2
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Builder
argument_list|<
name|T
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<
name|T
argument_list|>
argument_list|(
name|inputMode
operator|==
literal|0
condition|?
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
else|:
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE4
argument_list|,
name|prune1
argument_list|,
name|prune2
argument_list|,
name|prune1
operator|==
literal|0
operator|&&
name|prune2
operator|==
literal|0
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|pair
operator|.
name|input
argument_list|,
name|pair
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
name|FST
argument_list|<
name|T
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
operator|&&
name|fst
operator|!=
literal|null
condition|)
block|{
name|IndexOutput
name|out
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"fst.bin"
argument_list|)
decl_stmt|;
name|fst
operator|.
name|save
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|in
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"fst.bin"
argument_list|)
decl_stmt|;
try|try
block|{
name|fst
operator|=
operator|new
name|FST
argument_list|<
name|T
argument_list|>
argument_list|(
name|in
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|deleteFile
argument_list|(
literal|"fst.bin"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|VERBOSE
operator|&&
name|pairs
operator|.
name|size
argument_list|()
operator|<=
literal|20
operator|&&
name|fst
operator|!=
literal|null
condition|)
block|{
name|PrintStream
name|ps
init|=
operator|new
name|PrintStream
argument_list|(
literal|"out.dot"
argument_list|)
decl_stmt|;
name|fst
operator|.
name|toDot
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|ps
operator|.
name|close
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"SAVED out.dot"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
if|if
condition|(
name|fst
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  fst has 0 nodes (fully pruned)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  fst has "
operator|+
name|fst
operator|.
name|getNodeCount
argument_list|()
operator|+
literal|" nodes and "
operator|+
name|fst
operator|.
name|getArcCount
argument_list|()
operator|+
literal|" arcs"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prune1
operator|==
literal|0
operator|&&
name|prune2
operator|==
literal|0
condition|)
block|{
name|verifyUnPruned
argument_list|(
name|inputMode
argument_list|,
name|fst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verifyPruned
argument_list|(
name|inputMode
argument_list|,
name|fst
argument_list|,
name|prune1
argument_list|,
name|prune2
argument_list|)
expr_stmt|;
block|}
return|return
name|fst
return|;
block|}
comment|// FST is complete
DECL|method|verifyUnPruned
specifier|private
name|void
name|verifyUnPruned
parameter_list|(
name|int
name|inputMode
parameter_list|,
name|FST
argument_list|<
name|T
argument_list|>
name|fst
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pairs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|assertNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now verify "
operator|+
name|pairs
operator|.
name|size
argument_list|()
operator|+
literal|" terms"
argument_list|)
expr_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|assertNotNull
argument_list|(
name|pair
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|pair
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|pair
operator|.
name|output
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pair
operator|.
name|input
argument_list|)
operator|+
literal|": "
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|pair
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assertNotNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
comment|// make sure all words are accepted
block|{
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
name|fstEnum
init|=
operator|new
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
argument_list|(
name|fst
argument_list|)
decl_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|IntsRef
name|term
init|=
name|pair
operator|.
name|input
decl_stmt|;
name|Object
name|output
init|=
name|run
argument_list|(
name|fst
argument_list|,
name|term
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"term "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
operator|+
literal|" is not accepted"
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|output
argument_list|,
name|pair
operator|.
name|output
argument_list|)
expr_stmt|;
comment|// verify enum's next
name|IntsRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|T
argument_list|>
name|t
init|=
name|fstEnum
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|term
argument_list|,
name|t
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|pair
operator|.
name|output
argument_list|,
name|t
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
name|assertNull
argument_list|(
name|fstEnum
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Map
argument_list|<
name|IntsRef
argument_list|,
name|T
argument_list|>
name|termsMap
init|=
operator|new
name|HashMap
argument_list|<
name|IntsRef
argument_list|,
name|T
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|termsMap
operator|.
name|put
argument_list|(
name|pair
operator|.
name|input
argument_list|,
name|pair
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
comment|// find random matching word and make sure it's valid
specifier|final
name|IntsRef
name|scratch
init|=
operator|new
name|IntsRef
argument_list|(
literal|10
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
literal|500
operator|*
name|RANDOM_MULTIPLIER
condition|;
name|iter
operator|++
control|)
block|{
name|T
name|output
init|=
name|randomAcceptedWord
argument_list|(
name|fst
argument_list|,
name|scratch
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"accepted word "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|scratch
argument_list|)
operator|+
literal|" is not valid"
argument_list|,
name|termsMap
operator|.
name|containsKey
argument_list|(
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|termsMap
operator|.
name|get
argument_list|(
name|scratch
argument_list|)
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
comment|// test single IntsRefFSTEnum.advance:
comment|//System.out.println("TEST: verify advance");
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
literal|100
operator|*
name|RANDOM_MULTIPLIER
condition|;
name|iter
operator|++
control|)
block|{
specifier|final
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
name|fstEnum
init|=
operator|new
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
argument_list|(
name|fst
argument_list|)
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// seek to term that doesn't exist:
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|IntsRef
name|term
init|=
name|toIntsRef
argument_list|(
name|getRandomString
argument_list|()
argument_list|,
name|inputMode
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|Collections
operator|.
name|binarySearch
argument_list|(
name|pairs
argument_list|,
operator|new
name|InputOutput
argument_list|<
name|T
argument_list|>
argument_list|(
name|term
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|pos
operator|=
operator|-
operator|(
name|pos
operator|+
literal|1
operator|)
expr_stmt|;
comment|// ok doesn't exist
comment|//System.out.println("  seek " + inputToString(inputMode, term));
specifier|final
name|IntsRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|T
argument_list|>
name|seekResult
init|=
name|fstEnum
operator|.
name|advance
argument_list|(
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
name|pairs
operator|.
name|size
argument_list|()
condition|)
block|{
comment|//System.out.println("    got " + inputToString(inputMode,seekResult.input) + " output=" + fst.outputs.outputToString(seekResult.output));
name|assertEquals
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|input
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|output
argument_list|,
name|seekResult
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// seeked beyond end
comment|//System.out.println("seek=" + seekTerm);
name|assertNull
argument_list|(
literal|"expected null but got "
operator|+
operator|(
name|seekResult
operator|==
literal|null
condition|?
literal|"null"
else|:
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
operator|)
argument_list|,
name|seekResult
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
else|else
block|{
comment|// seek to term that does exist:
name|InputOutput
name|pair
init|=
name|pairs
operator|.
name|get
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
name|pairs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|//System.out.println("  seek " + inputToString(inputMode, pair.input));
specifier|final
name|IntsRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|T
argument_list|>
name|seekResult
init|=
name|fstEnum
operator|.
name|advance
argument_list|(
name|pair
operator|.
name|input
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|pair
operator|.
name|input
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|pair
operator|.
name|output
argument_list|,
name|seekResult
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: mixed next/advance"
argument_list|)
expr_stmt|;
block|}
comment|// test mixed next/advance
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
literal|100
operator|*
name|RANDOM_MULTIPLIER
condition|;
name|iter
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: iter "
operator|+
name|iter
argument_list|)
expr_stmt|;
block|}
specifier|final
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
name|fstEnum
init|=
operator|new
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
argument_list|(
name|fst
argument_list|)
decl_stmt|;
name|int
name|upto
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|boolean
name|isDone
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|upto
operator|==
name|pairs
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|||
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// next
name|upto
operator|++
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do next"
argument_list|)
expr_stmt|;
block|}
name|isDone
operator|=
name|fstEnum
operator|.
name|next
argument_list|()
operator|==
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|upto
operator|!=
operator|-
literal|1
operator|&&
name|upto
operator|<
literal|0.75
operator|*
name|pairs
operator|.
name|size
argument_list|()
operator|&&
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|int
name|attempt
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|attempt
operator|<
literal|10
condition|;
name|attempt
operator|++
control|)
block|{
name|IntsRef
name|term
init|=
name|toIntsRef
argument_list|(
name|getRandomString
argument_list|()
argument_list|,
name|inputMode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|termsMap
operator|.
name|containsKey
argument_list|(
name|term
argument_list|)
operator|&&
name|term
operator|.
name|compareTo
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|input
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do non-exist advance("
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|int
name|pos
init|=
name|Collections
operator|.
name|binarySearch
argument_list|(
name|pairs
argument_list|,
operator|new
name|InputOutput
argument_list|<
name|T
argument_list|>
argument_list|(
name|term
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
assert|assert
name|pos
operator|<
literal|0
assert|;
name|upto
operator|=
operator|-
operator|(
name|pos
operator|+
literal|1
operator|)
expr_stmt|;
name|isDone
operator|=
name|fstEnum
operator|.
name|advance
argument_list|(
name|term
argument_list|)
operator|==
literal|null
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|attempt
operator|==
literal|10
condition|)
block|{
continue|continue;
block|}
block|}
else|else
block|{
specifier|final
name|int
name|inc
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|pairs
operator|.
name|size
argument_list|()
operator|-
name|upto
operator|-
literal|1
argument_list|)
decl_stmt|;
name|upto
operator|+=
name|inc
expr_stmt|;
if|if
condition|(
name|upto
operator|==
operator|-
literal|1
condition|)
block|{
name|upto
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do advance("
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|input
argument_list|)
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|isDone
operator|=
name|fstEnum
operator|.
name|advance
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|input
argument_list|)
operator|==
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
if|if
condition|(
operator|!
name|isDone
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    got "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    got null"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|upto
operator|==
name|pairs
operator|.
name|size
argument_list|()
condition|)
block|{
name|assertTrue
argument_list|(
name|isDone
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|assertFalse
argument_list|(
name|isDone
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|input
argument_list|,
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|output
argument_list|,
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|CountMinOutput
specifier|private
specifier|static
class|class
name|CountMinOutput
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|count
name|int
name|count
decl_stmt|;
DECL|field|output
name|T
name|output
decl_stmt|;
DECL|field|finalOutput
name|T
name|finalOutput
decl_stmt|;
DECL|field|isLeaf
name|boolean
name|isLeaf
init|=
literal|true
decl_stmt|;
DECL|field|isFinal
name|boolean
name|isFinal
decl_stmt|;
block|}
comment|// FST is pruned
DECL|method|verifyPruned
specifier|private
name|void
name|verifyPruned
parameter_list|(
name|int
name|inputMode
parameter_list|,
name|FST
argument_list|<
name|T
argument_list|>
name|fst
parameter_list|,
name|int
name|prune1
parameter_list|,
name|int
name|prune2
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now verify pruned "
operator|+
name|pairs
operator|.
name|size
argument_list|()
operator|+
literal|" terms; outputs="
operator|+
name|outputs
argument_list|)
expr_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pair
operator|.
name|input
argument_list|)
operator|+
literal|": "
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|pair
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// To validate the FST, we brute-force compute all prefixes
comment|// in the terms, matched to their "common" outputs, prune that
comment|// set according to the prune thresholds, then assert the FST
comment|// matches that same set.
comment|// NOTE: Crazy RAM intensive!!
comment|//System.out.println("TEST: tally prefixes");
comment|// build all prefixes
specifier|final
name|Map
argument_list|<
name|IntsRef
argument_list|,
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|prefixes
init|=
operator|new
name|HashMap
argument_list|<
name|IntsRef
argument_list|,
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|IntsRef
name|scratch
init|=
operator|new
name|IntsRef
argument_list|(
literal|10
argument_list|)
decl_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|scratch
operator|.
name|copy
argument_list|(
name|pair
operator|.
name|input
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<=
name|pair
operator|.
name|input
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|scratch
operator|.
name|length
operator|=
name|idx
expr_stmt|;
name|CountMinOutput
argument_list|<
name|T
argument_list|>
name|cmo
init|=
name|prefixes
operator|.
name|get
argument_list|(
name|scratch
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmo
operator|==
literal|null
condition|)
block|{
name|cmo
operator|=
operator|new
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|()
expr_stmt|;
name|cmo
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|cmo
operator|.
name|output
operator|=
name|pair
operator|.
name|output
expr_stmt|;
name|prefixes
operator|.
name|put
argument_list|(
operator|new
name|IntsRef
argument_list|(
name|scratch
argument_list|)
argument_list|,
name|cmo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmo
operator|.
name|count
operator|++
expr_stmt|;
name|cmo
operator|.
name|output
operator|=
name|outputs
operator|.
name|common
argument_list|(
name|cmo
operator|.
name|output
argument_list|,
name|pair
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|==
name|pair
operator|.
name|input
operator|.
name|length
condition|)
block|{
name|cmo
operator|.
name|isFinal
operator|=
literal|true
expr_stmt|;
name|cmo
operator|.
name|finalOutput
operator|=
name|cmo
operator|.
name|output
expr_stmt|;
block|}
block|}
block|}
comment|//System.out.println("TEST: now prune");
comment|// prune 'em
specifier|final
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|IntsRef
argument_list|,
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|>
name|it
init|=
name|prefixes
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|IntsRef
argument_list|,
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|ent
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|IntsRef
name|prefix
init|=
name|ent
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|CountMinOutput
argument_list|<
name|T
argument_list|>
name|cmo
init|=
name|ent
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|//System.out.println("  term=" + inputToString(inputMode, prefix) + " count=" + cmo.count + " isLeaf=" + cmo.isLeaf);
specifier|final
name|boolean
name|keep
decl_stmt|;
if|if
condition|(
name|prune1
operator|>
literal|0
condition|)
block|{
name|keep
operator|=
name|cmo
operator|.
name|count
operator|>=
name|prune1
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|prune2
operator|>
literal|0
assert|;
if|if
condition|(
name|prune2
operator|>
literal|1
operator|&&
name|cmo
operator|.
name|count
operator|>=
name|prune2
condition|)
block|{
name|keep
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prefix
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// consult our parent
name|scratch
operator|.
name|length
operator|=
name|prefix
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|prefix
operator|.
name|ints
argument_list|,
name|prefix
operator|.
name|offset
argument_list|,
name|scratch
operator|.
name|ints
argument_list|,
literal|0
argument_list|,
name|scratch
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|CountMinOutput
argument_list|<
name|T
argument_list|>
name|cmo2
init|=
name|prefixes
operator|.
name|get
argument_list|(
name|scratch
argument_list|)
decl_stmt|;
comment|//System.out.println("    parent count = " + (cmo2 == null ? -1 : cmo2.count));
name|keep
operator|=
name|cmo2
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|prune2
operator|>
literal|1
operator|&&
name|cmo2
operator|.
name|count
operator|>=
name|prune2
operator|)
operator|||
operator|(
name|prune2
operator|==
literal|1
operator|&&
operator|(
name|cmo2
operator|.
name|count
operator|>=
literal|2
operator|||
name|prefix
operator|.
name|length
operator|<=
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmo
operator|.
name|count
operator|>=
name|prune2
condition|)
block|{
name|keep
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|keep
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|keep
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|//System.out.println("    remove");
block|}
else|else
block|{
comment|// clear isLeaf for all ancestors
comment|//System.out.println("    keep");
name|scratch
operator|.
name|copy
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|scratch
operator|.
name|length
operator|--
expr_stmt|;
while|while
condition|(
name|scratch
operator|.
name|length
operator|>=
literal|0
condition|)
block|{
specifier|final
name|CountMinOutput
argument_list|<
name|T
argument_list|>
name|cmo2
init|=
name|prefixes
operator|.
name|get
argument_list|(
name|scratch
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmo2
operator|!=
literal|null
condition|)
block|{
comment|//System.out.println("    clear isLeaf " + inputToString(inputMode, scratch));
name|cmo2
operator|.
name|isLeaf
operator|=
literal|false
expr_stmt|;
block|}
name|scratch
operator|.
name|length
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|//System.out.println("TEST: after prune");
comment|/*         for(Map.Entry<BytesRef,CountMinOutput> ent : prefixes.entrySet()) {         System.out.println("  " + inputToString(inputMode, ent.getKey()) + ": isLeaf=" + ent.getValue().isLeaf + " isFinal=" + ent.getValue().isFinal);         if (ent.getValue().isFinal) {         System.out.println("    finalOutput=" + outputs.outputToString(ent.getValue().finalOutput));         }         }       */
if|if
condition|(
name|prefixes
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
name|assertNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertNotNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
comment|// make sure FST only enums valid prefixes
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
name|fstEnum
init|=
operator|new
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
argument_list|(
name|fst
argument_list|)
decl_stmt|;
name|IntsRefFSTEnum
operator|.
name|InputOutput
name|current
decl_stmt|;
while|while
condition|(
operator|(
name|current
operator|=
name|fstEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
comment|//System.out.println("  fst enum term=" + inputToString(inputMode, current.input) + " output=" + outputs.outputToString(current.output));
specifier|final
name|CountMinOutput
name|cmo
init|=
name|prefixes
operator|.
name|get
argument_list|(
name|current
operator|.
name|input
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|cmo
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|cmo
operator|.
name|isLeaf
operator|||
name|cmo
operator|.
name|isFinal
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmo
operator|.
name|isFinal
operator|&&
operator|!
name|cmo
operator|.
name|isLeaf
condition|)
block|{
name|assertEquals
argument_list|(
name|cmo
operator|.
name|finalOutput
argument_list|,
name|current
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
name|cmo
operator|.
name|output
argument_list|,
name|current
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
comment|// make sure all non-pruned prefixes are present in the FST
specifier|final
name|int
index|[]
name|stopNode
init|=
operator|new
name|int
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|IntsRef
argument_list|,
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|ent
range|:
name|prefixes
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|ent
operator|.
name|getKey
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|)
block|{
specifier|final
name|CountMinOutput
argument_list|<
name|T
argument_list|>
name|cmo
init|=
name|ent
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|T
name|output
init|=
name|run
argument_list|(
name|fst
argument_list|,
name|ent
operator|.
name|getKey
argument_list|()
argument_list|,
name|stopNode
argument_list|)
decl_stmt|;
comment|//System.out.println("  term=" + inputToString(inputMode, ent.getKey()) + " output=" + outputs.outputToString(cmo.output));
comment|// if (cmo.isFinal&& !cmo.isLeaf) {
if|if
condition|(
name|cmo
operator|.
name|isFinal
condition|)
block|{
name|assertEquals
argument_list|(
name|cmo
operator|.
name|finalOutput
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
name|cmo
operator|.
name|output
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
operator|.
name|length
argument_list|,
name|stopNode
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|testRandomWords
specifier|public
name|void
name|testRandomWords
parameter_list|()
throws|throws
name|IOException
block|{
name|testRandomWords
argument_list|(
literal|1000
argument_list|,
literal|5
operator|*
name|RANDOM_MULTIPLIER
argument_list|)
expr_stmt|;
comment|//testRandomWords(10, 100);
block|}
DECL|method|inputModeToString
specifier|private
name|String
name|inputModeToString
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
block|{
return|return
literal|"utf8"
return|;
block|}
else|else
block|{
return|return
literal|"utf32"
return|;
block|}
block|}
DECL|method|testRandomWords
specifier|private
name|void
name|testRandomWords
parameter_list|(
name|int
name|maxNumWords
parameter_list|,
name|int
name|numIter
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|numIter
condition|;
name|iter
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nTEST: iter "
operator|+
name|iter
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|inputMode
init|=
literal|0
init|;
name|inputMode
operator|<
literal|2
condition|;
name|inputMode
operator|++
control|)
block|{
specifier|final
name|int
name|numWords
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|maxNumWords
operator|+
literal|1
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|IntsRef
argument_list|>
name|termsSet
init|=
operator|new
name|HashSet
argument_list|<
name|IntsRef
argument_list|>
argument_list|()
decl_stmt|;
name|IntsRef
index|[]
name|terms
init|=
operator|new
name|IntsRef
index|[
name|numWords
index|]
decl_stmt|;
while|while
condition|(
name|termsSet
operator|.
name|size
argument_list|()
operator|<
name|numWords
condition|)
block|{
specifier|final
name|String
name|term
init|=
name|getRandomString
argument_list|()
decl_stmt|;
name|termsSet
operator|.
name|add
argument_list|(
name|toIntsRef
argument_list|(
name|term
argument_list|,
name|inputMode
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|doTest
argument_list|(
name|inputMode
argument_list|,
name|termsSet
operator|.
name|toArray
argument_list|(
operator|new
name|IntsRef
index|[
name|termsSet
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getRandomString
specifier|private
name|String
name|getRandomString
parameter_list|()
block|{
specifier|final
name|String
name|term
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|term
operator|=
name|_TestUtil
operator|.
name|randomRealisticUnicodeString
argument_list|(
name|random
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we want to mix in limited-alphabet symbols so
comment|// we get more sharing of the nodes given how few
comment|// terms we are testing...
name|term
operator|=
name|simpleRandomString
argument_list|(
name|random
argument_list|)
expr_stmt|;
block|}
return|return
name|term
return|;
block|}
annotation|@
name|Nightly
DECL|method|testBigSet
specifier|public
name|void
name|testBigSet
parameter_list|()
throws|throws
name|IOException
block|{
name|testRandomWords
argument_list|(
literal|50000
argument_list|,
name|RANDOM_MULTIPLIER
argument_list|)
expr_stmt|;
block|}
DECL|method|inputToString
specifier|private
specifier|static
name|String
name|inputToString
parameter_list|(
name|int
name|inputMode
parameter_list|,
name|IntsRef
name|term
parameter_list|)
block|{
if|if
condition|(
name|inputMode
operator|==
literal|0
condition|)
block|{
comment|// utf8
return|return
name|toBytesRef
argument_list|(
name|term
argument_list|)
operator|.
name|utf8ToString
argument_list|()
return|;
block|}
else|else
block|{
comment|// utf32
return|return
name|UnicodeUtil
operator|.
name|newString
argument_list|(
name|term
operator|.
name|ints
argument_list|,
name|term
operator|.
name|offset
argument_list|,
name|term
operator|.
name|length
argument_list|)
return|;
block|}
block|}
comment|// Build FST for all unique terms in the test line docs
comment|// file, up until a time limit
DECL|method|testRealTerms
specifier|public
name|void
name|testRealTerms
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|CodecProvider
operator|.
name|getDefault
argument_list|()
operator|.
name|getDefaultFieldCodec
argument_list|()
operator|.
name|equals
argument_list|(
literal|"SimpleText"
argument_list|)
condition|)
block|{
comment|// no
name|CodecProvider
operator|.
name|getDefault
argument_list|()
operator|.
name|setDefaultFieldCodec
argument_list|(
literal|"Standard"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|LineFileDocs
name|docs
init|=
operator|new
name|LineFileDocs
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|int
name|RUN_TIME_SEC
init|=
name|LuceneTestCase
operator|.
name|TEST_NIGHTLY
condition|?
literal|100
else|:
literal|1
decl_stmt|;
specifier|final
name|IndexWriterConfig
name|conf
init|=
name|newIndexWriterConfig
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
operator|new
name|MockAnalyzer
argument_list|()
argument_list|)
operator|.
name|setMaxBufferedDocs
argument_list|(
operator|-
literal|1
argument_list|)
operator|.
name|setRAMBufferSizeMB
argument_list|(
literal|64
argument_list|)
decl_stmt|;
specifier|final
name|File
name|tempDir
init|=
name|_TestUtil
operator|.
name|getTempDir
argument_list|(
literal|"fstlines"
argument_list|)
decl_stmt|;
specifier|final
name|MockDirectoryWrapper
name|dir
init|=
operator|new
name|MockDirectoryWrapper
argument_list|(
name|random
argument_list|,
name|FSDirectory
operator|.
name|open
argument_list|(
name|tempDir
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|IndexWriter
name|writer
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|long
name|stopTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|RUN_TIME_SEC
operator|*
literal|1000
decl_stmt|;
name|Document
name|doc
decl_stmt|;
name|int
name|docCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|doc
operator|=
name|docs
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|<
name|stopTime
condition|)
block|{
name|writer
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|docCount
operator|++
expr_stmt|;
block|}
name|IndexReader
name|r
init|=
name|IndexReader
operator|.
name|open
argument_list|(
name|writer
argument_list|)
decl_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
name|Builder
argument_list|<
name|Long
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<
name|Long
argument_list|>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
name|boolean
name|storeOrd
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
if|if
condition|(
name|storeOrd
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FST stores ord"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FST stores docFreq"
argument_list|)
expr_stmt|;
block|}
block|}
name|Terms
name|terms
init|=
name|MultiFields
operator|.
name|getTerms
argument_list|(
name|r
argument_list|,
literal|"body"
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|!=
literal|null
condition|)
block|{
specifier|final
name|TermsEnum
name|termsEnum
init|=
name|terms
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|BytesRef
name|term
decl_stmt|;
name|int
name|ord
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|term
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ord
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|termsEnum
operator|.
name|ord
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|uoe
parameter_list|)
block|{
name|storeOrd
operator|=
literal|false
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|output
decl_stmt|;
if|if
condition|(
name|storeOrd
condition|)
block|{
name|output
operator|=
name|ord
expr_stmt|;
block|}
else|else
block|{
name|output
operator|=
name|termsEnum
operator|.
name|docFreq
argument_list|()
expr_stmt|;
block|}
name|builder
operator|.
name|add
argument_list|(
name|term
argument_list|,
name|outputs
operator|.
name|get
argument_list|(
name|output
argument_list|)
argument_list|)
expr_stmt|;
name|ord
operator|++
expr_stmt|;
if|if
condition|(
name|ord
operator|%
literal|100000
operator|==
literal|0
operator|&&
name|LuceneTestCase
operator|.
name|TEST_NIGHTLY
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|ord
operator|+
literal|" terms..."
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FST: "
operator|+
name|docCount
operator|+
literal|" docs; "
operator|+
name|ord
operator|+
literal|" terms; "
operator|+
name|fst
operator|.
name|getNodeCount
argument_list|()
operator|+
literal|" nodes; "
operator|+
name|fst
operator|.
name|getArcCount
argument_list|()
operator|+
literal|" arcs;"
operator|+
literal|" "
operator|+
name|fst
operator|.
name|sizeInBytes
argument_list|()
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ord
operator|>
literal|0
condition|)
block|{
comment|// Now confirm BytesRefFSTEnum and TermsEnum act the
comment|// same:
specifier|final
name|BytesRefFSTEnum
argument_list|<
name|Long
argument_list|>
name|fstEnum
init|=
operator|new
name|BytesRefFSTEnum
argument_list|<
name|Long
argument_list|>
argument_list|(
name|fst
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
literal|1000
operator|*
name|RANDOM_MULTIPLIER
condition|;
name|iter
operator|++
control|)
block|{
name|fstEnum
operator|.
name|reset
argument_list|()
expr_stmt|;
specifier|final
name|BytesRef
name|randomTerm
init|=
operator|new
name|BytesRef
argument_list|(
name|getRandomString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|TermsEnum
operator|.
name|SeekStatus
name|seekResult
init|=
name|termsEnum
operator|.
name|seek
argument_list|(
name|randomTerm
argument_list|)
decl_stmt|;
specifier|final
name|BytesRefFSTEnum
operator|.
name|InputOutput
name|fstSeekResult
init|=
name|fstEnum
operator|.
name|advance
argument_list|(
name|randomTerm
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: seek "
operator|+
name|randomTerm
operator|.
name|utf8ToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seekResult
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|assertNull
argument_list|(
name|fstSeekResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertSame
argument_list|(
name|termsEnum
argument_list|,
name|fstEnum
argument_list|,
name|storeOrd
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|nextIter
init|=
literal|0
init|;
name|nextIter
operator|<
literal|10
condition|;
name|nextIter
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: next"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|termsEnum
operator|.
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  term="
operator|+
name|termsEnum
operator|.
name|term
argument_list|()
operator|.
name|utf8ToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertNotNull
argument_list|(
name|fstEnum
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|termsEnum
argument_list|,
name|fstEnum
argument_list|,
name|storeOrd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BytesRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|Long
argument_list|>
name|nextResult
init|=
name|fstEnum
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextResult
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"expected null but got: input="
operator|+
name|nextResult
operator|.
name|input
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" output="
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|nextResult
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|assertSame
specifier|private
name|void
name|assertSame
parameter_list|(
name|TermsEnum
name|termsEnum
parameter_list|,
name|BytesRefFSTEnum
name|fstEnum
parameter_list|,
name|boolean
name|storeOrd
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|termsEnum
operator|.
name|term
argument_list|()
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|fstEnum
operator|.
name|current
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
name|termsEnum
operator|.
name|term
argument_list|()
argument_list|,
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|storeOrd
condition|)
block|{
comment|// fst stored the ord
name|assertEquals
argument_list|(
name|termsEnum
operator|.
name|ord
argument_list|()
argument_list|,
operator|(
operator|(
name|Long
operator|)
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|output
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// fst stored the docFreq
name|assertEquals
argument_list|(
name|termsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|Long
operator|)
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|output
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|VisitTerms
specifier|private
specifier|static
specifier|abstract
class|class
name|VisitTerms
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|dirOut
specifier|private
specifier|final
name|String
name|dirOut
decl_stmt|;
DECL|field|wordsFileIn
specifier|private
specifier|final
name|String
name|wordsFileIn
decl_stmt|;
DECL|field|inputMode
specifier|private
name|int
name|inputMode
decl_stmt|;
DECL|field|outputs
specifier|private
specifier|final
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
decl_stmt|;
DECL|field|builder
specifier|private
specifier|final
name|Builder
argument_list|<
name|T
argument_list|>
name|builder
decl_stmt|;
DECL|method|VisitTerms
specifier|public
name|VisitTerms
parameter_list|(
name|String
name|dirOut
parameter_list|,
name|String
name|wordsFileIn
parameter_list|,
name|int
name|inputMode
parameter_list|,
name|int
name|prune
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|)
block|{
name|this
operator|.
name|dirOut
operator|=
name|dirOut
expr_stmt|;
name|this
operator|.
name|wordsFileIn
operator|=
name|wordsFileIn
expr_stmt|;
name|this
operator|.
name|inputMode
operator|=
name|inputMode
expr_stmt|;
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
name|builder
operator|=
operator|new
name|Builder
argument_list|<
name|T
argument_list|>
argument_list|(
name|inputMode
operator|==
literal|0
condition|?
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
else|:
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE4
argument_list|,
literal|0
argument_list|,
name|prune
argument_list|,
name|prune
operator|==
literal|0
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
block|}
DECL|method|getOutput
specifier|protected
specifier|abstract
name|T
name|getOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|run
specifier|public
name|void
name|run
parameter_list|(
name|int
name|limit
parameter_list|)
throws|throws
name|IOException
block|{
name|BufferedReader
name|is
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|wordsFileIn
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
argument_list|,
literal|65536
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|IntsRef
name|intsRef
init|=
operator|new
name|IntsRef
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|long
name|tStart
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|int
name|ord
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|w
init|=
name|is
operator|.
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|toIntsRef
argument_list|(
name|w
argument_list|,
name|inputMode
argument_list|,
name|intsRef
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|intsRef
argument_list|,
name|getOutput
argument_list|(
name|intsRef
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
name|ord
operator|++
expr_stmt|;
if|if
condition|(
name|ord
operator|%
literal|500000
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
operator|(
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|tStart
operator|)
operator|/
literal|1000.0
operator|)
operator|+
literal|"s: "
operator|+
name|ord
operator|+
literal|"..."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ord
operator|>=
name|limit
condition|)
block|{
break|break;
block|}
block|}
assert|assert
name|builder
operator|.
name|getTermCount
argument_list|()
operator|==
name|ord
assert|;
specifier|final
name|FST
argument_list|<
name|T
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
if|if
condition|(
name|fst
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FST was fully pruned!"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|ord
operator|+
literal|" terms; "
operator|+
name|fst
operator|.
name|getNodeCount
argument_list|()
operator|+
literal|" nodes; "
operator|+
name|fst
operator|.
name|getArcCount
argument_list|()
operator|+
literal|" arcs; "
operator|+
name|fst
operator|.
name|getArcWithOutputCount
argument_list|()
operator|+
literal|" arcs w/ output; tot size "
operator|+
name|fst
operator|.
name|sizeInBytes
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst
operator|.
name|getNodeCount
argument_list|()
operator|<
literal|100
condition|)
block|{
name|PrintStream
name|ps
init|=
operator|new
name|PrintStream
argument_list|(
literal|"out.dot"
argument_list|)
decl_stmt|;
name|fst
operator|.
name|toDot
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|ps
operator|.
name|close
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Wrote FST to out.dot"
argument_list|)
expr_stmt|;
block|}
name|Directory
name|dir
init|=
name|FSDirectory
operator|.
name|open
argument_list|(
operator|new
name|File
argument_list|(
name|dirOut
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|out
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"fst.bin"
argument_list|)
decl_stmt|;
name|fst
operator|.
name|save
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Saved FST to fst.bin."
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nNow verify..."
argument_list|)
expr_stmt|;
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
name|is
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|wordsFileIn
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
name|ord
operator|=
literal|0
expr_stmt|;
name|tStart
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|w
init|=
name|is
operator|.
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|toIntsRef
argument_list|(
name|w
argument_list|,
name|inputMode
argument_list|,
name|intsRef
argument_list|)
expr_stmt|;
name|T
name|expected
init|=
name|getOutput
argument_list|(
name|intsRef
argument_list|,
name|ord
argument_list|)
decl_stmt|;
name|T
name|actual
init|=
name|fst
operator|.
name|get
argument_list|(
name|intsRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|actual
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unexpected null output on input="
operator|+
name|w
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|actual
operator|.
name|equals
argument_list|(
name|expected
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"wrong output (got "
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|actual
argument_list|)
operator|+
literal|" but expected "
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|expected
argument_list|)
operator|+
literal|") on input="
operator|+
name|w
argument_list|)
throw|;
block|}
name|ord
operator|++
expr_stmt|;
if|if
condition|(
name|ord
operator|%
literal|500000
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
operator|(
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|tStart
operator|)
operator|/
literal|1000.0
operator|)
operator|+
literal|"s: "
operator|+
name|ord
operator|+
literal|"..."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ord
operator|>=
name|limit
condition|)
block|{
break|break;
block|}
block|}
name|double
name|totSec
init|=
operator|(
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|tStart
operator|)
operator|/
literal|1000.0
operator|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Verify took "
operator|+
name|totSec
operator|+
literal|" sec + ("
operator|+
call|(
name|int
call|)
argument_list|(
operator|(
name|totSec
operator|*
literal|1000000000
operator|/
name|ord
operator|)
argument_list|)
operator|+
literal|" nsec per lookup)"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// java -cp build/classes/test:build/classes/java:lib/junit-4.7.jar org.apache.lucene.util.automaton.fst.TestFSTs /x/tmp/allTerms3.txt out
DECL|method|main
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|wordsFileIn
init|=
name|args
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|String
name|dirOut
init|=
name|args
index|[
literal|1
index|]
decl_stmt|;
name|int
name|idx
init|=
literal|2
decl_stmt|;
name|int
name|prune
init|=
literal|0
decl_stmt|;
name|int
name|limit
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|int
name|inputMode
init|=
literal|0
decl_stmt|;
comment|// utf8
name|boolean
name|storeOrds
init|=
literal|false
decl_stmt|;
name|boolean
name|storeDocFreqs
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|args
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-prune"
argument_list|)
condition|)
block|{
name|prune
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|args
index|[
literal|1
operator|+
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-limit"
argument_list|)
condition|)
block|{
name|limit
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|args
index|[
literal|1
operator|+
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-utf8"
argument_list|)
condition|)
block|{
name|inputMode
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-utf32"
argument_list|)
condition|)
block|{
name|inputMode
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-docFreq"
argument_list|)
condition|)
block|{
name|storeDocFreqs
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
name|idx
index|]
operator|.
name|equals
argument_list|(
literal|"-ords"
argument_list|)
condition|)
block|{
name|storeOrds
operator|=
literal|true
expr_stmt|;
block|}
name|idx
operator|++
expr_stmt|;
block|}
comment|// ord benefits from share, docFreqs don't:
if|if
condition|(
name|storeOrds
operator|&&
name|storeDocFreqs
condition|)
block|{
comment|// Store both ord& docFreq:
specifier|final
name|PositiveIntOutputs
name|o1
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|PositiveIntOutputs
name|o2
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|PairOutputs
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|outputs
init|=
operator|new
name|PairOutputs
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
decl_stmt|;
operator|new
name|VisitTerms
argument_list|<
name|PairOutputs
operator|.
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|(
name|dirOut
argument_list|,
name|wordsFileIn
argument_list|,
name|inputMode
argument_list|,
name|prune
argument_list|,
name|outputs
argument_list|)
block|{
name|Random
name|rand
decl_stmt|;
annotation|@
name|Override
specifier|public
name|PairOutputs
operator|.
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|getOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|int
name|ord
parameter_list|)
block|{
if|if
condition|(
name|ord
operator|==
literal|0
condition|)
block|{
name|rand
operator|=
operator|new
name|Random
argument_list|(
literal|17
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|PairOutputs
operator|.
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
argument_list|(
name|o1
operator|.
name|get
argument_list|(
name|ord
argument_list|)
argument_list|,
name|o2
operator|.
name|get
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|1
argument_list|,
literal|5000
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|limit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storeOrds
condition|)
block|{
comment|// Store only ords
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|true
argument_list|)
decl_stmt|;
operator|new
name|VisitTerms
argument_list|<
name|Long
argument_list|>
argument_list|(
name|dirOut
argument_list|,
name|wordsFileIn
argument_list|,
name|inputMode
argument_list|,
name|prune
argument_list|,
name|outputs
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Long
name|getOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|int
name|ord
parameter_list|)
block|{
return|return
name|outputs
operator|.
name|get
argument_list|(
name|ord
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|limit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storeDocFreqs
condition|)
block|{
comment|// Store only docFreq
specifier|final
name|PositiveIntOutputs
name|outputs
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|(
literal|false
argument_list|)
decl_stmt|;
operator|new
name|VisitTerms
argument_list|<
name|Long
argument_list|>
argument_list|(
name|dirOut
argument_list|,
name|wordsFileIn
argument_list|,
name|inputMode
argument_list|,
name|prune
argument_list|,
name|outputs
argument_list|)
block|{
name|Random
name|rand
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Long
name|getOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|int
name|ord
parameter_list|)
block|{
if|if
condition|(
name|ord
operator|==
literal|0
condition|)
block|{
name|rand
operator|=
operator|new
name|Random
argument_list|(
literal|17
argument_list|)
expr_stmt|;
block|}
return|return
name|outputs
operator|.
name|get
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|1
argument_list|,
literal|5000
argument_list|)
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|limit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Store nothing
specifier|final
name|NoOutputs
name|outputs
init|=
name|NoOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|NO_OUTPUT
init|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
operator|new
name|VisitTerms
argument_list|<
name|Object
argument_list|>
argument_list|(
name|dirOut
argument_list|,
name|wordsFileIn
argument_list|,
name|inputMode
argument_list|,
name|prune
argument_list|,
name|outputs
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|getOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|int
name|ord
parameter_list|)
block|{
return|return
name|NO_OUTPUT
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|limit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
