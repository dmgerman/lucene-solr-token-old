begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|*
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_class
DECL|class|FlexTestUtil
specifier|public
class|class
name|FlexTestUtil
block|{
comment|// index variations
comment|//   need del docs
comment|//   need payloads
comment|//   lots of randomness
comment|//   surrogate pairs
comment|//
comment|// need more diverse index
comment|//    with omitTFAP
comment|//    with payloads
comment|//    bigger index
comment|// test advanceTo, mixed with getting or not getting positions
comment|// test that custom/null skipDocs work
comment|// test: direct flex compared to flex on non flex on flex
comment|// test with flex on one index and non-flex on the other
comment|//   (two dirs above)
comment|// temporarily force pre-flex emulation on flex emulation
comment|//   on pre-flex segment (in back compat test)
comment|// a sub-reader that has nonzero doc count but 100% are deleted
comment|// foreign bitdocs
comment|// advancing in DocsEnum, then next'ing, nextPosition'ing
comment|// mutlti-reader w/ empty sub-reader
comment|//   - eg from merge that had all del docs
comment|//   - eg from empty flush
comment|// make sure we test empty field (no terms)
comment|//  created from empty field in doc, but also, from
comment|//  removing all docs that had the field
comment|// test 1 vs many segment index
comment|// test multireader vs dir reader
comment|// test bulk read api
comment|// wrap reader as "external" reader -- double emulation test
DECL|method|verifyFlexVsPreFlex
specifier|public
specifier|static
name|void
name|verifyFlexVsPreFlex
parameter_list|(
name|Random
name|rand
parameter_list|,
name|Directory
name|d
parameter_list|)
throws|throws
name|Exception
block|{
name|IndexReader
name|r
init|=
name|IndexReader
operator|.
name|open
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|verifyFlexVsPreFlex
argument_list|(
name|rand
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|verifyFlexVsPreFlex
specifier|public
specifier|static
name|void
name|verifyFlexVsPreFlex
parameter_list|(
name|Random
name|rand
parameter_list|,
name|IndexWriter
name|w
parameter_list|)
throws|throws
name|Exception
block|{
name|IndexReader
name|r
init|=
name|w
operator|.
name|getReader
argument_list|()
decl_stmt|;
name|verifyFlexVsPreFlex
argument_list|(
name|rand
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|verifyFlexVsPreFlex
specifier|public
specifier|static
name|void
name|verifyFlexVsPreFlex
parameter_list|(
name|Random
name|rand
parameter_list|,
name|IndexReader
name|r
parameter_list|)
throws|throws
name|Exception
block|{
comment|// First test on DirReader
name|verifyFlexVsPreFlexSingle
argument_list|(
name|rand
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|// Then on each individual sub reader
name|IndexReader
index|[]
name|subReaders
init|=
name|r
operator|.
name|getSequentialSubReaders
argument_list|()
decl_stmt|;
name|IndexReader
index|[]
name|forcedSubReaders
init|=
operator|new
name|IndexReader
index|[
name|subReaders
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subReaders
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|forcedSubReaders
index|[
name|i
index|]
operator|=
operator|new
name|ForcedExternalReader
argument_list|(
name|subReaders
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|verifyFlexVsPreFlexSingle
argument_list|(
name|rand
argument_list|,
name|forcedSubReaders
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|verifyFlexVsPreFlexSingle
argument_list|(
name|rand
argument_list|,
name|subReaders
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Then on a new MultiReader
name|IndexReader
name|m
init|=
operator|new
name|MultiReader
argument_list|(
name|subReaders
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|verifyFlexVsPreFlexSingle
argument_list|(
name|rand
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Then on a forced-external reader (forced flex to
comment|// emulate API on pre-flex API, which in turn is
comment|// emulating pre-flex on flex -- twisted, but, better
comment|// work):
name|verifyFlexVsPreFlexSingle
argument_list|(
name|rand
argument_list|,
operator|new
name|ForcedExternalReader
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
operator|new
name|MultiReader
argument_list|(
name|forcedSubReaders
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|verifyFlexVsPreFlexSingle
argument_list|(
name|rand
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|verifyFlexVsPreFlexSingle
specifier|private
specifier|static
name|void
name|verifyFlexVsPreFlexSingle
parameter_list|(
name|Random
name|rand
parameter_list|,
name|IndexReader
name|r
parameter_list|)
throws|throws
name|Exception
block|{
comment|//List<Term> allTerms = new ArrayList<Term>();
comment|//System.out.println("TEST: now verify!!");
name|testStraightEnum
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|testRandomSkips
argument_list|(
name|rand
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|testRandomSeeks
argument_list|(
name|rand
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|testBogusFieldTerms
argument_list|(
name|rand
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
DECL|method|testBogusFieldTerms
specifier|private
specifier|static
name|void
name|testBogusFieldTerms
parameter_list|(
name|Random
name|rand
parameter_list|,
name|IndexReader
name|r
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|Fields
name|fields
init|=
name|MultiFields
operator|.
name|getFields
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|String
name|f
init|=
literal|"bogus"
operator|+
name|rand
operator|.
name|nextInt
argument_list|()
operator|+
literal|"reallybogus"
decl_stmt|;
name|Terms
name|terms
init|=
name|fields
operator|.
name|terms
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|terms
operator|==
literal|null
operator|||
name|terms
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|==
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testStraightEnum
specifier|private
specifier|static
name|void
name|testStraightEnum
parameter_list|(
name|IndexReader
name|r
parameter_list|)
throws|throws
name|Exception
block|{
comment|// straight enum of fields/terms/docs/positions
name|TermEnum
name|termEnum
init|=
name|r
operator|.
name|terms
argument_list|()
decl_stmt|;
specifier|final
name|Fields
name|fields
init|=
name|MultiFields
operator|.
name|getFields
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|FieldsEnum
name|fieldsEnum
init|=
name|fields
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|String
name|field
init|=
name|fieldsEnum
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
name|boolean
name|result
init|=
name|termEnum
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"got unexpected term="
operator|+
name|termEnum
operator|.
name|term
argument_list|()
operator|+
literal|" termEnum="
operator|+
name|termEnum
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|result
argument_list|)
expr_stmt|;
break|break;
block|}
name|TermsEnum
name|terms
init|=
name|fieldsEnum
operator|.
name|terms
argument_list|()
decl_stmt|;
name|DocsAndPositionsEnum
name|postings
init|=
literal|null
decl_stmt|;
name|DocsEnum
name|docsEnum
init|=
literal|null
decl_stmt|;
specifier|final
name|TermPositions
name|termPos
init|=
name|r
operator|.
name|termPositions
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|BytesRef
name|termRef
init|=
name|terms
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|termRef
operator|==
literal|null
condition|)
block|{
break|break;
block|}
else|else
block|{
name|assertTrue
argument_list|(
name|termEnum
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|Term
name|t
init|=
name|termEnum
operator|.
name|term
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|t
operator|.
name|field
argument_list|()
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|t
operator|.
name|text
argument_list|()
argument_list|,
name|termRef
operator|.
name|utf8ToString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|termEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|terms
operator|.
name|docFreq
argument_list|()
argument_list|)
expr_stmt|;
comment|//allTerms.add(t);
name|postings
operator|=
name|terms
operator|.
name|docsAndPositions
argument_list|(
name|MultiFields
operator|.
name|getDeletedDocs
argument_list|(
name|r
argument_list|)
argument_list|,
name|postings
argument_list|)
expr_stmt|;
name|docsEnum
operator|=
name|terms
operator|.
name|docs
argument_list|(
name|MultiFields
operator|.
name|getDeletedDocs
argument_list|(
name|r
argument_list|)
argument_list|,
name|docsEnum
argument_list|)
expr_stmt|;
specifier|final
name|DocsEnum
name|docs
decl_stmt|;
if|if
condition|(
name|postings
operator|!=
literal|null
condition|)
block|{
name|docs
operator|=
name|postings
expr_stmt|;
block|}
else|else
block|{
name|docs
operator|=
name|docsEnum
expr_stmt|;
block|}
name|termPos
operator|.
name|seek
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|doc
init|=
name|docs
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
operator|==
name|DocsEnum
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|assertFalse
argument_list|(
name|termPos
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|assertTrue
argument_list|(
name|termPos
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|termPos
operator|.
name|doc
argument_list|()
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|termPos
operator|.
name|freq
argument_list|()
argument_list|,
name|docs
operator|.
name|freq
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
name|freq
init|=
name|docs
operator|.
name|freq
argument_list|()
decl_stmt|;
if|if
condition|(
name|postings
operator|==
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|freq
argument_list|)
expr_stmt|;
comment|// Old API did not always do this,
comment|// specifically in the MultiTermPositions
comment|// case when some segs omit positions and
comment|// some don't
comment|//assertEquals(0, termPos.nextPosition());
name|assertEquals
argument_list|(
literal|false
argument_list|,
name|termPos
operator|.
name|isPayloadAvailable
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|freq
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|position
init|=
name|postings
operator|.
name|nextPosition
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|position
argument_list|,
name|termPos
operator|.
name|nextPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|postings
operator|.
name|hasPayload
argument_list|()
argument_list|,
name|termPos
operator|.
name|isPayloadAvailable
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|postings
operator|.
name|hasPayload
argument_list|()
condition|)
block|{
name|BytesRef
name|payload
init|=
name|postings
operator|.
name|getPayload
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|payload
operator|.
name|length
argument_list|,
name|termPos
operator|.
name|getPayloadLength
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|b2
init|=
name|termPos
operator|.
name|getPayload
argument_list|(
literal|null
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|payload
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|b2
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|equals
argument_list|(
name|payload
argument_list|,
name|b2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
DECL|method|testRandomSkips
specifier|private
specifier|static
name|void
name|testRandomSkips
parameter_list|(
name|Random
name|rand
parameter_list|,
name|IndexReader
name|r
parameter_list|)
throws|throws
name|Exception
block|{
name|TermEnum
name|termEnum
init|=
name|r
operator|.
name|terms
argument_list|()
decl_stmt|;
name|Fields
name|fields
init|=
name|MultiFields
operator|.
name|getFields
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|FieldsEnum
name|fieldsEnum
init|=
name|fields
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|boolean
name|skipNext
init|=
literal|false
decl_stmt|;
name|int
index|[]
name|docs2
init|=
operator|new
name|int
index|[
literal|16
index|]
decl_stmt|;
name|int
index|[]
name|freqs2
init|=
operator|new
name|int
index|[
literal|16
index|]
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|String
name|field
init|=
name|fieldsEnum
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
name|boolean
name|result
init|=
name|termEnum
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"got unexpected term="
operator|+
name|termEnum
operator|.
name|term
argument_list|()
operator|+
literal|" termEnum="
operator|+
name|termEnum
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|result
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rand
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|<=
literal|1
condition|)
block|{
comment|// Enum the terms
comment|//System.out.println("TEST:   get terms");
name|TermsEnum
name|terms
init|=
name|fieldsEnum
operator|.
name|terms
argument_list|()
decl_stmt|;
specifier|final
name|TermPositions
name|termPos
init|=
name|r
operator|.
name|termPositions
argument_list|()
decl_stmt|;
specifier|final
name|TermDocs
name|termDocs
init|=
name|r
operator|.
name|termDocs
argument_list|()
decl_stmt|;
name|DocsEnum
name|docs
init|=
literal|null
decl_stmt|;
name|DocsAndPositionsEnum
name|postings
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|BytesRef
name|termRef
init|=
name|terms
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|termRef
operator|==
literal|null
condition|)
block|{
break|break;
block|}
else|else
block|{
if|if
condition|(
name|skipNext
condition|)
block|{
name|skipNext
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|assertTrue
argument_list|(
name|termEnum
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Term
name|t
init|=
name|termEnum
operator|.
name|term
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|t
operator|.
name|field
argument_list|()
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|t
operator|.
name|text
argument_list|()
argument_list|,
name|termRef
operator|.
name|utf8ToString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|termEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|terms
operator|.
name|docFreq
argument_list|()
argument_list|)
expr_stmt|;
comment|//allTerms.add(t);
if|if
condition|(
name|rand
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|<=
literal|1
condition|)
block|{
name|docs
operator|=
name|terms
operator|.
name|docs
argument_list|(
name|MultiFields
operator|.
name|getDeletedDocs
argument_list|(
name|r
argument_list|)
argument_list|,
name|docs
argument_list|)
expr_stmt|;
assert|assert
operator|!
operator|(
name|docs
operator|instanceof
name|DocsAndPositionsEnum
operator|)
operator|:
literal|"docs="
operator|+
name|docs
assert|;
name|postings
operator|=
name|terms
operator|.
name|docsAndPositions
argument_list|(
name|MultiFields
operator|.
name|getDeletedDocs
argument_list|(
name|r
argument_list|)
argument_list|,
name|postings
argument_list|)
expr_stmt|;
specifier|final
name|DocsEnum
name|docsEnum
decl_stmt|;
if|if
condition|(
name|postings
operator|==
literal|null
condition|)
block|{
name|docsEnum
operator|=
name|docs
expr_stmt|;
block|}
else|else
block|{
name|docsEnum
operator|=
name|postings
expr_stmt|;
block|}
if|if
condition|(
name|rand
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// use bulk read API
name|termDocs
operator|.
name|seek
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DocsEnum
operator|.
name|BulkReadResult
name|result1
init|=
name|docs
operator|.
name|getBulkResult
argument_list|()
decl_stmt|;
name|int
name|result1Count
init|=
literal|0
decl_stmt|;
name|int
name|count2
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|result1Count
operator|==
literal|0
condition|)
block|{
name|result1Count
operator|=
name|docs
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|count2
operator|==
literal|0
condition|)
block|{
name|count2
operator|=
name|termDocs
operator|.
name|read
argument_list|(
name|docs2
argument_list|,
name|freqs2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result1Count
operator|==
literal|0
operator|||
name|count2
operator|==
literal|0
condition|)
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|count2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|result1Count
argument_list|)
expr_stmt|;
break|break;
block|}
specifier|final
name|int
name|limit
init|=
name|Math
operator|.
name|min
argument_list|(
name|result1Count
argument_list|,
name|count2
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|result1
operator|.
name|docs
operator|.
name|ints
index|[
name|i
index|]
argument_list|,
name|docs2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|result1
operator|.
name|freqs
operator|.
name|ints
index|[
name|i
index|]
argument_list|,
name|freqs2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result1Count
operator|>
name|limit
condition|)
block|{
comment|// copy down
comment|// TODO: in general I should not muck w/
comment|// the int[]'s returned to me like
comment|// this... this could mess up codecs
comment|// that have persistent RAM storage of
comment|// these int[]'s
name|System
operator|.
name|arraycopy
argument_list|(
name|result1
operator|.
name|docs
operator|.
name|ints
argument_list|,
name|limit
argument_list|,
name|result1
operator|.
name|docs
operator|.
name|ints
argument_list|,
literal|0
argument_list|,
name|result1Count
operator|-
name|limit
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|result1
operator|.
name|freqs
operator|.
name|ints
argument_list|,
name|limit
argument_list|,
name|result1
operator|.
name|freqs
operator|.
name|ints
argument_list|,
literal|0
argument_list|,
name|result1Count
operator|-
name|limit
argument_list|)
expr_stmt|;
block|}
name|result1Count
operator|-=
name|limit
expr_stmt|;
if|if
condition|(
name|count2
operator|>
name|limit
condition|)
block|{
comment|// copy down
name|System
operator|.
name|arraycopy
argument_list|(
name|docs2
argument_list|,
name|limit
argument_list|,
name|docs2
argument_list|,
literal|0
argument_list|,
name|count2
operator|-
name|limit
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|freqs2
argument_list|,
name|limit
argument_list|,
name|freqs2
argument_list|,
literal|0
argument_list|,
name|count2
operator|-
name|limit
argument_list|)
expr_stmt|;
block|}
name|count2
operator|-=
name|limit
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Enum the docs one by one
comment|//System.out.println("TEST:      get docs");
name|termPos
operator|.
name|seek
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|doc
init|=
name|docsEnum
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
operator|==
name|DocsEnum
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|assertFalse
argument_list|(
name|termPos
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|assertTrue
argument_list|(
name|termPos
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|termPos
operator|.
name|doc
argument_list|()
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|termPos
operator|.
name|freq
argument_list|()
argument_list|,
name|docsEnum
operator|.
name|freq
argument_list|()
argument_list|)
expr_stmt|;
comment|//System.out.println("TEST:     doc=" + doc + " freq=" + docs.freq());
if|if
condition|(
name|rand
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|<=
literal|1
condition|)
block|{
comment|// enum the positions
specifier|final
name|int
name|freq
init|=
name|docsEnum
operator|.
name|freq
argument_list|()
decl_stmt|;
if|if
condition|(
name|postings
operator|==
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|termPos
operator|.
name|freq
argument_list|()
argument_list|)
expr_stmt|;
comment|// Old API did not always do this,
comment|// specifically in the MultiTermPositions
comment|// case when some segs omit positions and
comment|// some don't
comment|//assertEquals(0, termPos.nextPosition());
name|assertFalse
argument_list|(
name|termPos
operator|.
name|isPayloadAvailable
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we have positions
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|freq
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|position
init|=
name|postings
operator|.
name|nextPosition
argument_list|()
decl_stmt|;
comment|//System.out.println("TEST:       pos=" + position);
name|assertEquals
argument_list|(
name|position
argument_list|,
name|termPos
operator|.
name|nextPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|postings
operator|.
name|hasPayload
argument_list|()
argument_list|,
name|termPos
operator|.
name|isPayloadAvailable
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|postings
operator|.
name|hasPayload
argument_list|()
condition|)
block|{
if|if
condition|(
name|rand
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|<=
literal|1
condition|)
block|{
name|BytesRef
name|payload
init|=
name|postings
operator|.
name|getPayload
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|payload
operator|.
name|length
argument_list|,
name|termPos
operator|.
name|getPayloadLength
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|b2
init|=
name|termPos
operator|.
name|getPayload
argument_list|(
literal|null
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|payload
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|b2
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|equals
argument_list|(
name|payload
argument_list|,
name|b2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
else|else
block|{
comment|//System.out.println("TEST:      skip docs");
block|}
block|}
block|}
block|}
else|else
block|{
comment|// Skip terms for this field
name|termEnum
operator|=
name|r
operator|.
name|terms
argument_list|(
operator|new
name|Term
argument_list|(
name|field
argument_list|,
literal|"\uFFFF"
argument_list|)
argument_list|)
expr_stmt|;
name|skipNext
operator|=
literal|true
expr_stmt|;
comment|//System.out.println("TEST:   skip terms; now=" + termEnum.term());
block|}
block|}
comment|// seek to before first term in a field
comment|// seek to after last term in a field
comment|// seek to random terms
comment|// enum docs, sometimes skipping
comment|// enum positions, sometimes skipping payloads
block|}
DECL|method|equals
specifier|private
specifier|static
name|boolean
name|equals
parameter_list|(
name|BytesRef
name|b1
parameter_list|,
name|byte
index|[]
name|b2
parameter_list|)
block|{
if|if
condition|(
name|b1
operator|.
name|length
operator|==
name|b2
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|end
init|=
name|b1
operator|.
name|offset
operator|+
name|b1
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|b1
operator|.
name|offset
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|b1
operator|.
name|bytes
index|[
name|i
index|]
operator|!=
name|b2
index|[
name|i
operator|-
name|b1
operator|.
name|offset
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|method|nextInt
specifier|public
specifier|static
name|int
name|nextInt
parameter_list|(
name|Random
name|rand
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
return|return
name|min
operator|+
name|rand
operator|.
name|nextInt
argument_list|(
name|max
operator|-
name|min
argument_list|)
return|;
block|}
DECL|method|nextInt
specifier|public
specifier|static
name|int
name|nextInt
parameter_list|(
name|Random
name|rand
parameter_list|,
name|int
name|max
parameter_list|)
block|{
return|return
name|rand
operator|.
name|nextInt
argument_list|(
name|max
argument_list|)
return|;
block|}
DECL|method|getRandomText
specifier|public
specifier|static
name|String
name|getRandomText
parameter_list|(
name|Random
name|rand
parameter_list|,
name|int
name|minLen
parameter_list|,
name|int
name|maxLen
parameter_list|,
name|boolean
name|doUnpairedSurr
parameter_list|)
block|{
specifier|final
name|int
name|len
init|=
name|nextInt
argument_list|(
name|rand
argument_list|,
name|minLen
argument_list|,
name|maxLen
argument_list|)
decl_stmt|;
name|char
index|[]
name|buffer
init|=
operator|new
name|char
index|[
name|len
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|t
init|=
name|rand
operator|.
name|nextInt
argument_list|(
name|doUnpairedSurr
condition|?
literal|6
else|:
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|t
operator|&&
name|i
operator|<
name|len
operator|-
literal|1
condition|)
block|{
comment|// Make a surrogate pair
comment|// High surrogate
name|buffer
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|0xd800
argument_list|,
literal|0xdc00
argument_list|)
expr_stmt|;
comment|// Low surrogate
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|0xdc00
argument_list|,
literal|0xe000
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|<=
literal|1
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|2
operator|==
name|t
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|0x80
argument_list|,
literal|0x800
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|3
operator|==
name|t
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|0x800
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|4
operator|==
name|t
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|0xe000
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|5
operator|==
name|t
condition|)
block|{
comment|// Illegal unpaired surrogate
if|if
condition|(
name|rand
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|0xd800
argument_list|,
literal|0xdc00
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|0xdc00
argument_list|,
literal|0xe000
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|new
name|String
argument_list|(
name|buffer
argument_list|)
return|;
block|}
DECL|method|testRandomSeeks
specifier|private
specifier|static
name|void
name|testRandomSeeks
parameter_list|(
name|Random
name|rand
parameter_list|,
name|IndexReader
name|r
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|int
name|ITER
init|=
literal|100
operator|*
name|_TestUtil
operator|.
name|getRandomMultiplier
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|allFields
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Fields
name|fields
init|=
name|MultiFields
operator|.
name|getFields
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|FieldsEnum
name|fieldsEnum
init|=
name|fields
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|f
init|=
name|fieldsEnum
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|allFields
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|fieldCount
init|=
name|allFields
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldCount
operator|==
literal|0
condition|)
block|{
return|return;
block|}
specifier|final
name|TermPositions
name|termPositions
init|=
name|r
operator|.
name|termPositions
argument_list|()
decl_stmt|;
name|DocsEnum
name|docs
init|=
literal|null
decl_stmt|;
name|DocsAndPositionsEnum
name|postings
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ITER
condition|;
name|i
operator|++
control|)
block|{
comment|// Random field:
name|String
name|f
init|=
name|allFields
operator|.
name|get
argument_list|(
name|rand
operator|.
name|nextInt
argument_list|(
name|fieldCount
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|text
init|=
name|getRandomText
argument_list|(
name|rand
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|TermsEnum
name|termsEnum
init|=
name|MultiFields
operator|.
name|getFields
argument_list|(
name|r
argument_list|)
operator|.
name|terms
argument_list|(
name|f
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|final
name|TermsEnum
operator|.
name|SeekStatus
name|seekStatus
init|=
name|termsEnum
operator|.
name|seek
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|text
argument_list|)
argument_list|)
decl_stmt|;
name|Term
name|t
init|=
operator|new
name|Term
argument_list|(
name|f
argument_list|,
name|text
argument_list|)
decl_stmt|;
comment|//System.out.println("seek to " + t);
specifier|final
name|TermEnum
name|termEnum
init|=
name|r
operator|.
name|terms
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|seekStatus
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|END
condition|)
block|{
comment|//System.out.println("found end");
name|assertTrue
argument_list|(
name|termEnum
operator|.
name|term
argument_list|()
operator|==
literal|null
operator|||
name|termEnum
operator|.
name|term
argument_list|()
operator|.
name|field
argument_list|()
operator|!=
name|f
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|seekStatus
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|FOUND
condition|)
block|{
comment|//System.out.println("found exact");
name|assertEquals
argument_list|(
name|t
argument_list|,
name|termEnum
operator|.
name|term
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//System.out.println("found other");
name|assertEquals
argument_list|(
name|termsEnum
operator|.
name|term
argument_list|()
operator|.
name|utf8ToString
argument_list|()
argument_list|,
name|termEnum
operator|.
name|term
argument_list|()
operator|.
name|text
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|termsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|termEnum
operator|.
name|docFreq
argument_list|()
argument_list|)
expr_stmt|;
name|docs
operator|=
name|termsEnum
operator|.
name|docs
argument_list|(
name|MultiFields
operator|.
name|getDeletedDocs
argument_list|(
name|r
argument_list|)
argument_list|,
name|docs
argument_list|)
expr_stmt|;
name|postings
operator|=
name|termsEnum
operator|.
name|docsAndPositions
argument_list|(
name|MultiFields
operator|.
name|getDeletedDocs
argument_list|(
name|r
argument_list|)
argument_list|,
name|postings
argument_list|)
expr_stmt|;
name|termPositions
operator|.
name|seek
argument_list|(
name|termEnum
operator|.
name|term
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|doc
init|=
literal|0
decl_stmt|;
specifier|final
name|DocsEnum
name|docsEnum
decl_stmt|;
if|if
condition|(
name|postings
operator|!=
literal|null
condition|)
block|{
name|docsEnum
operator|=
name|postings
expr_stmt|;
block|}
else|else
block|{
name|docsEnum
operator|=
name|docs
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|20
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|int
name|inc
init|=
name|nextInt
argument_list|(
name|rand
argument_list|,
literal|1
argument_list|,
name|Math
operator|.
name|max
argument_list|(
literal|10
argument_list|,
name|r
operator|.
name|maxDoc
argument_list|()
operator|/
literal|15
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|newDoc1
init|=
name|docsEnum
operator|.
name|advance
argument_list|(
name|doc
operator|+
name|inc
argument_list|)
decl_stmt|;
name|boolean
name|found
init|=
name|termPositions
operator|.
name|skipTo
argument_list|(
name|doc
operator|+
name|inc
argument_list|)
decl_stmt|;
name|int
name|newDoc2
decl_stmt|;
if|if
condition|(
name|newDoc1
operator|==
name|DocsEnum
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|assertFalse
argument_list|(
name|found
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|assertTrue
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|newDoc2
operator|=
name|termPositions
operator|.
name|doc
argument_list|()
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|newDoc1
argument_list|,
name|newDoc2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|docsEnum
operator|.
name|freq
argument_list|()
argument_list|,
name|termPositions
operator|.
name|freq
argument_list|()
argument_list|)
expr_stmt|;
name|doc
operator|=
name|newDoc1
expr_stmt|;
if|if
condition|(
name|postings
operator|==
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|termPositions
operator|.
name|freq
argument_list|()
argument_list|)
expr_stmt|;
comment|// Old API did not always do this,
comment|// specifically in the MultiTermPositions
comment|// case when some segs omit positions and
comment|// some don't
comment|//assertEquals(0, termPositions.nextPosition());
name|assertFalse
argument_list|(
name|termPositions
operator|.
name|isPayloadAvailable
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|docsEnum
operator|.
name|freq
argument_list|()
condition|;
name|k
operator|++
control|)
block|{
name|int
name|pos1
init|=
name|postings
operator|.
name|nextPosition
argument_list|()
decl_stmt|;
name|int
name|pos2
init|=
name|termPositions
operator|.
name|nextPosition
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|pos1
argument_list|,
name|pos2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|postings
operator|.
name|hasPayload
argument_list|()
argument_list|,
name|termPositions
operator|.
name|isPayloadAvailable
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|postings
operator|.
name|hasPayload
argument_list|()
condition|)
block|{
name|BytesRef
name|b1
init|=
name|postings
operator|.
name|getPayload
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|b1
operator|.
name|length
argument_list|,
name|termPositions
operator|.
name|getPayloadLength
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|b2
init|=
name|termPositions
operator|.
name|getPayload
argument_list|(
literal|null
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|b1
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|b2
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|equals
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|// Delegates to a "normal" IndexReader, making it look
comment|// "external", to force testing of the "flex API on
comment|// external reader" layer.  DO NOT OVERRIDE
comment|// getSequentialSubReaders!!
DECL|class|ForcedExternalReader
specifier|public
specifier|final
specifier|static
class|class
name|ForcedExternalReader
extends|extends
name|IndexReader
block|{
DECL|field|r
specifier|private
specifier|final
name|IndexReader
name|r
decl_stmt|;
DECL|method|ForcedExternalReader
specifier|public
name|ForcedExternalReader
parameter_list|(
name|IndexReader
name|r
parameter_list|)
block|{
name|this
operator|.
name|r
operator|=
name|r
expr_stmt|;
block|}
DECL|method|getTermFreqVectors
specifier|public
name|TermFreqVector
index|[]
name|getTermFreqVectors
parameter_list|(
name|int
name|docNumber
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|r
operator|.
name|getTermFreqVectors
argument_list|(
name|docNumber
argument_list|)
return|;
block|}
DECL|method|getTermFreqVector
specifier|public
name|TermFreqVector
name|getTermFreqVector
parameter_list|(
name|int
name|docNumber
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|r
operator|.
name|getTermFreqVector
argument_list|(
name|docNumber
argument_list|,
name|field
argument_list|)
return|;
block|}
DECL|method|getTermFreqVector
specifier|public
name|void
name|getTermFreqVector
parameter_list|(
name|int
name|docNumber
parameter_list|,
name|String
name|field
parameter_list|,
name|TermVectorMapper
name|mapper
parameter_list|)
throws|throws
name|IOException
block|{
name|r
operator|.
name|getTermFreqVector
argument_list|(
name|docNumber
argument_list|,
name|field
argument_list|,
name|mapper
argument_list|)
expr_stmt|;
block|}
DECL|method|getTermFreqVector
specifier|public
name|void
name|getTermFreqVector
parameter_list|(
name|int
name|docNumber
parameter_list|,
name|TermVectorMapper
name|mapper
parameter_list|)
throws|throws
name|IOException
block|{
name|r
operator|.
name|getTermFreqVector
argument_list|(
name|docNumber
argument_list|,
name|mapper
argument_list|)
expr_stmt|;
block|}
DECL|method|getDeletedDocs
specifier|public
name|Bits
name|getDeletedDocs
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|MultiFields
operator|.
name|getDeletedDocs
argument_list|(
name|r
argument_list|)
return|;
block|}
DECL|method|numDocs
specifier|public
name|int
name|numDocs
parameter_list|()
block|{
return|return
name|r
operator|.
name|numDocs
argument_list|()
return|;
block|}
DECL|method|maxDoc
specifier|public
name|int
name|maxDoc
parameter_list|()
block|{
return|return
name|r
operator|.
name|maxDoc
argument_list|()
return|;
block|}
DECL|method|document
specifier|public
name|Document
name|document
parameter_list|(
name|int
name|n
parameter_list|,
name|FieldSelector
name|fieldSelector
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|r
operator|.
name|document
argument_list|(
name|n
argument_list|,
name|fieldSelector
argument_list|)
return|;
block|}
DECL|method|isDeleted
specifier|public
name|boolean
name|isDeleted
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
name|r
operator|.
name|isDeleted
argument_list|(
name|n
argument_list|)
return|;
block|}
DECL|method|hasDeletions
specifier|public
name|boolean
name|hasDeletions
parameter_list|()
block|{
return|return
name|r
operator|.
name|hasDeletions
argument_list|()
return|;
block|}
DECL|method|norms
specifier|public
name|byte
index|[]
name|norms
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|r
operator|.
name|norms
argument_list|(
name|field
argument_list|)
return|;
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ForcedExternalReader("
operator|+
name|r
operator|+
literal|")"
return|;
block|}
DECL|method|norms
specifier|public
name|void
name|norms
parameter_list|(
name|String
name|field
parameter_list|,
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|r
operator|.
name|norms
argument_list|(
name|field
argument_list|,
name|bytes
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
DECL|method|doSetNorm
specifier|protected
name|void
name|doSetNorm
parameter_list|(
name|int
name|doc
parameter_list|,
name|String
name|field
parameter_list|,
name|byte
name|value
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|r
operator|.
name|doSetNorm
argument_list|(
name|doc
argument_list|,
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
DECL|method|terms
specifier|public
name|TermEnum
name|terms
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|r
operator|.
name|terms
argument_list|()
return|;
block|}
DECL|method|terms
specifier|public
name|TermEnum
name|terms
parameter_list|(
name|Term
name|t
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|r
operator|.
name|terms
argument_list|(
name|t
argument_list|)
return|;
block|}
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|(
name|Term
name|t
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|r
operator|.
name|docFreq
argument_list|(
name|t
argument_list|)
return|;
block|}
DECL|method|termDocs
specifier|public
name|TermDocs
name|termDocs
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|r
operator|.
name|termDocs
argument_list|()
return|;
block|}
DECL|method|termPositions
specifier|public
name|TermPositions
name|termPositions
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|r
operator|.
name|termPositions
argument_list|()
return|;
block|}
DECL|method|doDelete
specifier|public
name|void
name|doDelete
parameter_list|(
name|int
name|docID
parameter_list|)
throws|throws
name|IOException
block|{
name|r
operator|.
name|doDelete
argument_list|(
name|docID
argument_list|)
expr_stmt|;
block|}
DECL|method|doUndeleteAll
specifier|public
name|void
name|doUndeleteAll
parameter_list|()
throws|throws
name|IOException
block|{
name|r
operator|.
name|doUndeleteAll
argument_list|()
expr_stmt|;
block|}
DECL|method|doCommit
specifier|protected
name|void
name|doCommit
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commitUserData
parameter_list|)
throws|throws
name|IOException
block|{
name|r
operator|.
name|doCommit
argument_list|(
name|commitUserData
argument_list|)
expr_stmt|;
block|}
DECL|method|doClose
specifier|protected
name|void
name|doClose
parameter_list|()
throws|throws
name|IOException
block|{
name|r
operator|.
name|doClose
argument_list|()
expr_stmt|;
block|}
DECL|method|getFieldNames
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getFieldNames
parameter_list|(
name|FieldOption
name|fldOption
parameter_list|)
block|{
return|return
name|r
operator|.
name|getFieldNames
argument_list|(
name|fldOption
argument_list|)
return|;
block|}
block|}
DECL|method|main
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
comment|//Directory dir = FSDirectory.open(new File("/x/lucene/wiki.5M/index"));
name|Directory
name|dir
init|=
name|FSDirectory
operator|.
name|open
argument_list|(
operator|new
name|File
argument_list|(
literal|"/x/lucene/flex.wiki.1M/index"
argument_list|)
argument_list|)
decl_stmt|;
name|verifyFlexVsPreFlex
argument_list|(
operator|new
name|Random
argument_list|()
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
end_class
end_unit
