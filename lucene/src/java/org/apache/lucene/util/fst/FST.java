begin_unit
begin_package
DECL|package|org.apache.lucene.util.fst
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Builder
operator|.
name|UnCompiledNode
import|;
end_import
begin_comment
comment|// TODO: if FST is pure prefix trie we can do a more compact
end_comment
begin_comment
comment|// job, ie, once we are at a 'suffix only', just store the
end_comment
begin_comment
comment|// completion labels as a string not as a series of arcs.
end_comment
begin_comment
comment|// NOTE: while the FST is able to represent a non-final
end_comment
begin_comment
comment|// dead-end state (NON_FINAL_END_NODE=0), the layers above
end_comment
begin_comment
comment|// (FSTEnum, Util) have problems with this!!
end_comment
begin_comment
comment|/** Represents an FST using a compact byte[] format.  *<p> The format is similar to what's used by Morfologik  *  (http://sourceforge.net/projects/morfologik).  *  *<p><b>NOTE</b>: the FST cannot be larger than ~2.1 GB  *  because it uses int to address the byte[].  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|FST
specifier|public
class|class
name|FST
parameter_list|<
name|T
parameter_list|>
block|{
DECL|enum|INPUT_TYPE
DECL|enum constant|BYTE1
DECL|enum constant|BYTE2
DECL|enum constant|BYTE4
specifier|public
specifier|static
enum|enum
name|INPUT_TYPE
block|{
name|BYTE1
block|,
name|BYTE2
block|,
name|BYTE4
block|}
empty_stmt|;
DECL|field|inputType
specifier|public
specifier|final
name|INPUT_TYPE
name|inputType
decl_stmt|;
DECL|field|BIT_FINAL_ARC
specifier|private
specifier|final
specifier|static
name|int
name|BIT_FINAL_ARC
init|=
literal|1
operator|<<
literal|0
decl_stmt|;
DECL|field|BIT_LAST_ARC
specifier|private
specifier|final
specifier|static
name|int
name|BIT_LAST_ARC
init|=
literal|1
operator|<<
literal|1
decl_stmt|;
DECL|field|BIT_TARGET_NEXT
specifier|private
specifier|final
specifier|static
name|int
name|BIT_TARGET_NEXT
init|=
literal|1
operator|<<
literal|2
decl_stmt|;
DECL|field|BIT_STOP_NODE
specifier|private
specifier|final
specifier|static
name|int
name|BIT_STOP_NODE
init|=
literal|1
operator|<<
literal|3
decl_stmt|;
DECL|field|BIT_ARC_HAS_OUTPUT
specifier|private
specifier|final
specifier|static
name|int
name|BIT_ARC_HAS_OUTPUT
init|=
literal|1
operator|<<
literal|4
decl_stmt|;
DECL|field|BIT_ARC_HAS_FINAL_OUTPUT
specifier|private
specifier|final
specifier|static
name|int
name|BIT_ARC_HAS_FINAL_OUTPUT
init|=
literal|1
operator|<<
literal|5
decl_stmt|;
comment|// Arcs are stored as fixed-size (per entry) array, so
comment|// that we can find an arc using binary search.  We do
comment|// this when number of arcs is> NUM_ARCS_ARRAY:
DECL|field|BIT_ARCS_AS_FIXED_ARRAY
specifier|private
specifier|final
specifier|static
name|int
name|BIT_ARCS_AS_FIXED_ARRAY
init|=
literal|1
operator|<<
literal|6
decl_stmt|;
comment|/**    * @see #shouldExpand(UnCompiledNode)    */
DECL|field|FIXED_ARRAY_SHALLOW_DISTANCE
specifier|final
specifier|static
name|int
name|FIXED_ARRAY_SHALLOW_DISTANCE
init|=
literal|3
decl_stmt|;
comment|// 0 => only root node.
comment|/**    * @see #shouldExpand(UnCompiledNode)    */
DECL|field|FIXED_ARRAY_NUM_ARCS_SHALLOW
specifier|final
specifier|static
name|int
name|FIXED_ARRAY_NUM_ARCS_SHALLOW
init|=
literal|5
decl_stmt|;
comment|/**    * @see #shouldExpand(UnCompiledNode)    */
DECL|field|FIXED_ARRAY_NUM_ARCS_DEEP
specifier|final
specifier|static
name|int
name|FIXED_ARRAY_NUM_ARCS_DEEP
init|=
literal|10
decl_stmt|;
DECL|field|bytesPerArc
specifier|private
name|int
index|[]
name|bytesPerArc
init|=
operator|new
name|int
index|[
literal|0
index|]
decl_stmt|;
comment|// Increment version to change it
DECL|field|FILE_FORMAT_NAME
specifier|private
specifier|final
specifier|static
name|String
name|FILE_FORMAT_NAME
init|=
literal|"FST"
decl_stmt|;
DECL|field|VERSION_START
specifier|private
specifier|final
specifier|static
name|int
name|VERSION_START
init|=
literal|0
decl_stmt|;
comment|/** Changed numBytesPerArc for array'd case from byte to int. */
DECL|field|VERSION_INT_NUM_BYTES_PER_ARC
specifier|private
specifier|final
specifier|static
name|int
name|VERSION_INT_NUM_BYTES_PER_ARC
init|=
literal|1
decl_stmt|;
DECL|field|VERSION_CURRENT
specifier|private
specifier|final
specifier|static
name|int
name|VERSION_CURRENT
init|=
name|VERSION_INT_NUM_BYTES_PER_ARC
decl_stmt|;
comment|// Never serialized; just used to represent the virtual
comment|// final node w/ no arcs:
DECL|field|FINAL_END_NODE
specifier|private
specifier|final
specifier|static
name|int
name|FINAL_END_NODE
init|=
operator|-
literal|1
decl_stmt|;
comment|// Never serialized; just used to represent the virtual
comment|// non-final node w/ no arcs:
DECL|field|NON_FINAL_END_NODE
specifier|private
specifier|final
specifier|static
name|int
name|NON_FINAL_END_NODE
init|=
literal|0
decl_stmt|;
comment|// if non-null, this FST accepts the empty string and
comment|// produces this output
DECL|field|emptyOutput
name|T
name|emptyOutput
decl_stmt|;
DECL|field|emptyOutputBytes
specifier|private
name|byte
index|[]
name|emptyOutputBytes
decl_stmt|;
DECL|field|bytes
specifier|private
name|byte
index|[]
name|bytes
decl_stmt|;
DECL|field|byteUpto
name|int
name|byteUpto
init|=
literal|0
decl_stmt|;
DECL|field|startNode
specifier|private
name|int
name|startNode
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|outputs
specifier|public
specifier|final
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
decl_stmt|;
DECL|field|lastFrozenNode
specifier|private
name|int
name|lastFrozenNode
decl_stmt|;
DECL|field|NO_OUTPUT
specifier|private
specifier|final
name|T
name|NO_OUTPUT
decl_stmt|;
DECL|field|nodeCount
specifier|public
name|int
name|nodeCount
decl_stmt|;
DECL|field|arcCount
specifier|public
name|int
name|arcCount
decl_stmt|;
DECL|field|arcWithOutputCount
specifier|public
name|int
name|arcWithOutputCount
decl_stmt|;
comment|// If arc has this label then that arc is final/accepted
DECL|field|END_LABEL
specifier|public
specifier|static
specifier|final
name|int
name|END_LABEL
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|allowArrayArcs
specifier|private
name|boolean
name|allowArrayArcs
init|=
literal|true
decl_stmt|;
DECL|field|cachedRootArcs
specifier|private
name|Arc
argument_list|<
name|T
argument_list|>
name|cachedRootArcs
index|[]
decl_stmt|;
DECL|class|Arc
specifier|public
specifier|final
specifier|static
class|class
name|Arc
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|label
specifier|public
name|int
name|label
decl_stmt|;
DECL|field|output
specifier|public
name|T
name|output
decl_stmt|;
DECL|field|target
specifier|public
name|int
name|target
decl_stmt|;
DECL|field|flags
name|byte
name|flags
decl_stmt|;
DECL|field|nextFinalOutput
specifier|public
name|T
name|nextFinalOutput
decl_stmt|;
DECL|field|nextArc
name|int
name|nextArc
decl_stmt|;
comment|// This is non-zero if current arcs are fixed array:
DECL|field|posArcsStart
name|int
name|posArcsStart
decl_stmt|;
DECL|field|bytesPerArc
name|int
name|bytesPerArc
decl_stmt|;
DECL|field|arcIdx
name|int
name|arcIdx
decl_stmt|;
DECL|field|numArcs
name|int
name|numArcs
decl_stmt|;
comment|/** Returns this */
DECL|method|copyFrom
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|copyFrom
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|other
parameter_list|)
block|{
name|label
operator|=
name|other
operator|.
name|label
expr_stmt|;
name|target
operator|=
name|other
operator|.
name|target
expr_stmt|;
name|flags
operator|=
name|other
operator|.
name|flags
expr_stmt|;
name|output
operator|=
name|other
operator|.
name|output
expr_stmt|;
name|nextFinalOutput
operator|=
name|other
operator|.
name|nextFinalOutput
expr_stmt|;
name|nextArc
operator|=
name|other
operator|.
name|nextArc
expr_stmt|;
if|if
condition|(
name|other
operator|.
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
name|bytesPerArc
operator|=
name|other
operator|.
name|bytesPerArc
expr_stmt|;
name|posArcsStart
operator|=
name|other
operator|.
name|posArcsStart
expr_stmt|;
name|arcIdx
operator|=
name|other
operator|.
name|arcIdx
expr_stmt|;
name|numArcs
operator|=
name|other
operator|.
name|numArcs
expr_stmt|;
block|}
else|else
block|{
name|bytesPerArc
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|method|flag
name|boolean
name|flag
parameter_list|(
name|int
name|flag
parameter_list|)
block|{
return|return
name|FST
operator|.
name|flag
argument_list|(
name|flags
argument_list|,
name|flag
argument_list|)
return|;
block|}
DECL|method|isLast
specifier|public
name|boolean
name|isLast
parameter_list|()
block|{
return|return
name|flag
argument_list|(
name|BIT_LAST_ARC
argument_list|)
return|;
block|}
DECL|method|isFinal
specifier|public
name|boolean
name|isFinal
parameter_list|()
block|{
return|return
name|flag
argument_list|(
name|BIT_FINAL_ARC
argument_list|)
return|;
block|}
block|}
empty_stmt|;
DECL|method|flag
specifier|static
name|boolean
name|flag
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
return|return
operator|(
name|flags
operator|&
name|bit
operator|)
operator|!=
literal|0
return|;
block|}
DECL|field|writer
specifier|private
specifier|final
name|BytesWriter
name|writer
decl_stmt|;
comment|// make a new empty FST, for building
DECL|method|FST
specifier|public
name|FST
parameter_list|(
name|INPUT_TYPE
name|inputType
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|)
block|{
name|this
operator|.
name|inputType
operator|=
name|inputType
expr_stmt|;
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
name|bytes
operator|=
operator|new
name|byte
index|[
literal|128
index|]
expr_stmt|;
name|NO_OUTPUT
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
name|writer
operator|=
operator|new
name|BytesWriter
argument_list|()
expr_stmt|;
name|emptyOutput
operator|=
literal|null
expr_stmt|;
block|}
comment|// create an existing FST
DECL|method|FST
specifier|public
name|FST
parameter_list|(
name|DataInput
name|in
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
name|writer
operator|=
literal|null
expr_stmt|;
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|in
argument_list|,
name|FILE_FORMAT_NAME
argument_list|,
name|VERSION_INT_NUM_BYTES_PER_ARC
argument_list|,
name|VERSION_INT_NUM_BYTES_PER_ARC
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|readByte
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// accepts empty string
name|int
name|numBytes
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
comment|// messy
name|bytes
operator|=
operator|new
name|byte
index|[
name|numBytes
index|]
expr_stmt|;
name|in
operator|.
name|readBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|emptyOutput
operator|=
name|outputs
operator|.
name|read
argument_list|(
name|getBytesReader
argument_list|(
name|numBytes
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emptyOutput
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|byte
name|t
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
literal|0
case|:
name|inputType
operator|=
name|INPUT_TYPE
operator|.
name|BYTE1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|inputType
operator|=
name|INPUT_TYPE
operator|.
name|BYTE2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|inputType
operator|=
name|INPUT_TYPE
operator|.
name|BYTE4
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"invalid input type "
operator|+
name|t
argument_list|)
throw|;
block|}
name|startNode
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|nodeCount
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|arcCount
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|arcWithOutputCount
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|bytes
operator|=
operator|new
name|byte
index|[
name|in
operator|.
name|readVInt
argument_list|()
index|]
expr_stmt|;
name|in
operator|.
name|readBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|NO_OUTPUT
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
name|cacheRootArcs
argument_list|()
expr_stmt|;
block|}
DECL|method|getInputType
specifier|public
name|INPUT_TYPE
name|getInputType
parameter_list|()
block|{
return|return
name|inputType
return|;
block|}
comment|/** Returns bytes used to represent the FST */
DECL|method|sizeInBytes
specifier|public
name|int
name|sizeInBytes
parameter_list|()
block|{
return|return
name|bytes
operator|.
name|length
return|;
block|}
DECL|method|finish
name|void
name|finish
parameter_list|(
name|int
name|startNode
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|startNode
operator|==
name|FINAL_END_NODE
operator|&&
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|startNode
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|startNode
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"already finished"
argument_list|)
throw|;
block|}
name|byte
index|[]
name|finalBytes
init|=
operator|new
name|byte
index|[
name|writer
operator|.
name|posWrite
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|finalBytes
argument_list|,
literal|0
argument_list|,
name|writer
operator|.
name|posWrite
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|finalBytes
expr_stmt|;
name|this
operator|.
name|startNode
operator|=
name|startNode
expr_stmt|;
name|cacheRootArcs
argument_list|()
expr_stmt|;
block|}
comment|// Caches first 128 labels
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|cacheRootArcs
specifier|private
name|void
name|cacheRootArcs
parameter_list|()
throws|throws
name|IOException
block|{
name|cachedRootArcs
operator|=
operator|(
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
index|[]
operator|)
operator|new
name|FST
operator|.
name|Arc
index|[
literal|0x80
index|]
expr_stmt|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
name|getFirstArc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
specifier|final
name|BytesReader
name|in
init|=
name|getBytesReader
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetHasArcs
argument_list|(
name|arc
argument_list|)
condition|)
block|{
name|readFirstRealArc
argument_list|(
name|arc
operator|.
name|target
argument_list|,
name|arc
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
assert|assert
name|arc
operator|.
name|label
operator|!=
name|END_LABEL
assert|;
if|if
condition|(
name|arc
operator|.
name|label
operator|<
name|cachedRootArcs
operator|.
name|length
condition|)
block|{
name|cachedRootArcs
index|[
name|arc
operator|.
name|label
index|]
operator|=
operator|new
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|arc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
if|if
condition|(
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
break|break;
block|}
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getEmptyOutput
specifier|public
name|T
name|getEmptyOutput
parameter_list|()
block|{
return|return
name|emptyOutput
return|;
block|}
DECL|method|setEmptyOutput
name|void
name|setEmptyOutput
parameter_list|(
name|T
name|v
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|emptyOutput
operator|=
name|outputs
operator|.
name|merge
argument_list|(
name|emptyOutput
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emptyOutput
operator|=
name|v
expr_stmt|;
block|}
comment|// TODO: this is messy -- replace with sillyBytesWriter; maybe make
comment|// bytes private
specifier|final
name|int
name|posSave
init|=
name|writer
operator|.
name|posWrite
decl_stmt|;
name|outputs
operator|.
name|write
argument_list|(
name|emptyOutput
argument_list|,
name|writer
argument_list|)
expr_stmt|;
name|emptyOutputBytes
operator|=
operator|new
name|byte
index|[
name|writer
operator|.
name|posWrite
operator|-
name|posSave
index|]
expr_stmt|;
comment|// reverse
specifier|final
name|int
name|stopAt
init|=
operator|(
name|writer
operator|.
name|posWrite
operator|-
name|posSave
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|stopAt
condition|)
block|{
specifier|final
name|byte
name|b
init|=
name|bytes
index|[
name|posSave
operator|+
name|upto
index|]
decl_stmt|;
name|bytes
index|[
name|posSave
operator|+
name|upto
index|]
operator|=
name|bytes
index|[
name|writer
operator|.
name|posWrite
operator|-
name|upto
operator|-
literal|1
index|]
expr_stmt|;
name|bytes
index|[
name|writer
operator|.
name|posWrite
operator|-
name|upto
operator|-
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
name|posSave
argument_list|,
name|emptyOutputBytes
argument_list|,
literal|0
argument_list|,
name|writer
operator|.
name|posWrite
operator|-
name|posSave
argument_list|)
expr_stmt|;
name|writer
operator|.
name|posWrite
operator|=
name|posSave
expr_stmt|;
block|}
DECL|method|save
specifier|public
name|void
name|save
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|startNode
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"call finish first"
argument_list|)
throw|;
block|}
name|CodecUtil
operator|.
name|writeHeader
argument_list|(
name|out
argument_list|,
name|FILE_FORMAT_NAME
argument_list|,
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
comment|// TODO: really we should encode this as an arc, arriving
comment|// to the root node, instead of special casing here:
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|1
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|emptyOutputBytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|emptyOutputBytes
argument_list|,
literal|0
argument_list|,
name|emptyOutputBytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|final
name|byte
name|t
decl_stmt|;
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE1
condition|)
block|{
name|t
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE2
condition|)
block|{
name|t
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
literal|2
expr_stmt|;
block|}
name|out
operator|.
name|writeByte
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|startNode
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|nodeCount
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|arcCount
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|arcWithOutputCount
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|writeLabel
specifier|private
name|void
name|writeLabel
parameter_list|(
name|int
name|v
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|v
operator|>=
literal|0
operator|:
literal|"v="
operator|+
name|v
assert|;
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE1
condition|)
block|{
assert|assert
name|v
operator|<=
literal|255
operator|:
literal|"v="
operator|+
name|v
assert|;
name|writer
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE2
condition|)
block|{
assert|assert
name|v
operator|<=
literal|65535
operator|:
literal|"v="
operator|+
name|v
assert|;
name|writer
operator|.
name|writeVInt
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//writeInt(v);
name|writer
operator|.
name|writeVInt
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|readLabel
name|int
name|readLabel
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|v
decl_stmt|;
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE1
condition|)
block|{
name|v
operator|=
name|in
operator|.
name|readByte
argument_list|()
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
comment|// returns true if the node at this address has any
comment|// outgoing arcs
DECL|method|targetHasArcs
specifier|public
name|boolean
name|targetHasArcs
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
block|{
return|return
name|arc
operator|.
name|target
operator|>
literal|0
return|;
block|}
comment|// serializes new node by appending its bytes to the end
comment|// of the current byte[]
DECL|method|addNode
name|int
name|addNode
parameter_list|(
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("FST.addNode pos=" + posWrite + " numArcs=" + node.numArcs);
if|if
condition|(
name|node
operator|.
name|numArcs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|isFinal
condition|)
block|{
return|return
name|FINAL_END_NODE
return|;
block|}
else|else
block|{
return|return
name|NON_FINAL_END_NODE
return|;
block|}
block|}
name|int
name|startAddress
init|=
name|writer
operator|.
name|posWrite
decl_stmt|;
comment|//System.out.println("  startAddr=" + startAddress);
specifier|final
name|boolean
name|doFixedArray
init|=
name|shouldExpand
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|final
name|int
name|fixedArrayStart
decl_stmt|;
if|if
condition|(
name|doFixedArray
condition|)
block|{
if|if
condition|(
name|bytesPerArc
operator|.
name|length
operator|<
name|node
operator|.
name|numArcs
condition|)
block|{
name|bytesPerArc
operator|=
operator|new
name|int
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|node
operator|.
name|numArcs
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
comment|// write a "false" first arc:
name|writer
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|BIT_ARCS_AS_FIXED_ARRAY
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeVInt
argument_list|(
name|node
operator|.
name|numArcs
argument_list|)
expr_stmt|;
comment|// placeholder -- we'll come back and write the number
comment|// of bytes per arc (int) here:
comment|// TODO: we could make this a vInt instead
name|writer
operator|.
name|writeInt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fixedArrayStart
operator|=
name|writer
operator|.
name|posWrite
expr_stmt|;
comment|//System.out.println("  do fixed arcs array arcsStart=" + fixedArrayStart);
block|}
else|else
block|{
name|fixedArrayStart
operator|=
literal|0
expr_stmt|;
block|}
name|nodeCount
operator|++
expr_stmt|;
name|arcCount
operator|+=
name|node
operator|.
name|numArcs
expr_stmt|;
specifier|final
name|int
name|lastArc
init|=
name|node
operator|.
name|numArcs
operator|-
literal|1
decl_stmt|;
name|int
name|lastArcStart
init|=
name|writer
operator|.
name|posWrite
decl_stmt|;
name|int
name|maxBytesPerArc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|node
operator|.
name|numArcs
condition|;
name|arcIdx
operator|++
control|)
block|{
specifier|final
name|Builder
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
name|node
operator|.
name|arcs
index|[
name|arcIdx
index|]
decl_stmt|;
specifier|final
name|Builder
operator|.
name|CompiledNode
name|target
init|=
operator|(
name|Builder
operator|.
name|CompiledNode
operator|)
name|arc
operator|.
name|target
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arcIdx
operator|==
name|lastArc
condition|)
block|{
name|flags
operator|+=
name|BIT_LAST_ARC
expr_stmt|;
block|}
if|if
condition|(
name|lastFrozenNode
operator|==
name|target
operator|.
name|address
operator|&&
operator|!
name|doFixedArray
condition|)
block|{
name|flags
operator|+=
name|BIT_TARGET_NEXT
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
condition|)
block|{
name|flags
operator|+=
name|BIT_FINAL_ARC
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|flags
operator|+=
name|BIT_ARC_HAS_FINAL_OUTPUT
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|arc
operator|.
name|nextFinalOutput
operator|==
name|NO_OUTPUT
assert|;
block|}
name|boolean
name|targetHasArcs
init|=
name|target
operator|.
name|address
operator|>
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|targetHasArcs
condition|)
block|{
name|flags
operator|+=
name|BIT_STOP_NODE
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|flags
operator|+=
name|BIT_ARC_HAS_OUTPUT
expr_stmt|;
block|}
name|writer
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|flags
argument_list|)
expr_stmt|;
name|writeLabel
argument_list|(
name|arc
operator|.
name|label
argument_list|)
expr_stmt|;
comment|//System.out.println("  write arc: label=" + arc.label + " flags=" + flags);
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|outputs
operator|.
name|write
argument_list|(
name|arc
operator|.
name|output
argument_list|,
name|writer
argument_list|)
expr_stmt|;
name|arcWithOutputCount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|outputs
operator|.
name|write
argument_list|(
name|arc
operator|.
name|nextFinalOutput
argument_list|,
name|writer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetHasArcs
operator|&&
operator|(
name|doFixedArray
operator|||
name|lastFrozenNode
operator|!=
name|target
operator|.
name|address
operator|)
condition|)
block|{
assert|assert
name|target
operator|.
name|address
operator|>
literal|0
assert|;
name|writer
operator|.
name|writeInt
argument_list|(
name|target
operator|.
name|address
argument_list|)
expr_stmt|;
block|}
comment|// just write the arcs "like normal" on first pass,
comment|// but record how many bytes each one took, and max
comment|// byte size:
if|if
condition|(
name|doFixedArray
condition|)
block|{
name|bytesPerArc
index|[
name|arcIdx
index|]
operator|=
name|writer
operator|.
name|posWrite
operator|-
name|lastArcStart
expr_stmt|;
name|lastArcStart
operator|=
name|writer
operator|.
name|posWrite
expr_stmt|;
name|maxBytesPerArc
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxBytesPerArc
argument_list|,
name|bytesPerArc
index|[
name|arcIdx
index|]
argument_list|)
expr_stmt|;
comment|//System.out.println("    bytes=" + bytesPerArc[arcIdx]);
block|}
block|}
comment|// TODO: if arc'd arrays will be "too wasteful" by some
comment|// measure, eg if arcs have vastly different sized
comment|// outputs, then we should selectively disable array for
comment|// such cases
if|if
condition|(
name|doFixedArray
condition|)
block|{
assert|assert
name|maxBytesPerArc
operator|>
literal|0
assert|;
comment|// 2nd pass just "expands" all arcs to take up a fixed
comment|// byte size
specifier|final
name|int
name|sizeNeeded
init|=
name|fixedArrayStart
operator|+
name|node
operator|.
name|numArcs
operator|*
name|maxBytesPerArc
decl_stmt|;
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|bytes
argument_list|,
name|sizeNeeded
argument_list|)
expr_stmt|;
comment|// TODO: we could make this a vInt instead
name|bytes
index|[
name|fixedArrayStart
operator|-
literal|4
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|maxBytesPerArc
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|bytes
index|[
name|fixedArrayStart
operator|-
literal|3
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|maxBytesPerArc
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|bytes
index|[
name|fixedArrayStart
operator|-
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|maxBytesPerArc
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|bytes
index|[
name|fixedArrayStart
operator|-
literal|1
index|]
operator|=
operator|(
name|byte
operator|)
name|maxBytesPerArc
expr_stmt|;
comment|// expand the arcs in place, backwards
name|int
name|srcPos
init|=
name|writer
operator|.
name|posWrite
decl_stmt|;
name|int
name|destPos
init|=
name|fixedArrayStart
operator|+
name|node
operator|.
name|numArcs
operator|*
name|maxBytesPerArc
decl_stmt|;
name|writer
operator|.
name|posWrite
operator|=
name|destPos
expr_stmt|;
for|for
control|(
name|int
name|arcIdx
init|=
name|node
operator|.
name|numArcs
operator|-
literal|1
init|;
name|arcIdx
operator|>=
literal|0
condition|;
name|arcIdx
operator|--
control|)
block|{
comment|//System.out.println("  repack arcIdx=" + arcIdx + " srcPos=" + srcPos + " destPos=" + destPos);
name|destPos
operator|-=
name|maxBytesPerArc
expr_stmt|;
name|srcPos
operator|-=
name|bytesPerArc
index|[
name|arcIdx
index|]
expr_stmt|;
if|if
condition|(
name|srcPos
operator|!=
name|destPos
condition|)
block|{
assert|assert
name|destPos
operator|>
name|srcPos
assert|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
name|srcPos
argument_list|,
name|bytes
argument_list|,
name|destPos
argument_list|,
name|bytesPerArc
index|[
name|arcIdx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// reverse bytes in-place; we do this so that the
comment|// "BIT_TARGET_NEXT" opto can work, ie, it reads the
comment|// node just before the current one
specifier|final
name|int
name|endAddress
init|=
name|lastFrozenNode
operator|=
name|writer
operator|.
name|posWrite
operator|-
literal|1
decl_stmt|;
name|int
name|left
init|=
name|startAddress
decl_stmt|;
name|int
name|right
init|=
name|endAddress
decl_stmt|;
while|while
condition|(
name|left
operator|<
name|right
condition|)
block|{
specifier|final
name|byte
name|b
init|=
name|bytes
index|[
name|left
index|]
decl_stmt|;
name|bytes
index|[
name|left
operator|++
index|]
operator|=
name|bytes
index|[
name|right
index|]
expr_stmt|;
name|bytes
index|[
name|right
operator|--
index|]
operator|=
name|b
expr_stmt|;
block|}
return|return
name|endAddress
return|;
block|}
comment|/** Fills virtual 'start' arc, ie, an empty incoming arc to    *  the FST's start node */
DECL|method|getFirstArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|getFirstArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
block|{
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|arc
operator|.
name|flags
operator|=
name|BIT_FINAL_ARC
operator||
name|BIT_LAST_ARC
expr_stmt|;
name|arc
operator|.
name|nextFinalOutput
operator|=
name|emptyOutput
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|flags
operator|=
name|BIT_LAST_ARC
expr_stmt|;
name|arc
operator|.
name|nextFinalOutput
operator|=
name|NO_OUTPUT
expr_stmt|;
block|}
name|arc
operator|.
name|output
operator|=
name|NO_OUTPUT
expr_stmt|;
comment|// If there are no nodes, ie, the FST only accepts the
comment|// empty string, then startNode is 0, and then readFirstTargetArc
name|arc
operator|.
name|target
operator|=
name|startNode
expr_stmt|;
return|return
name|arc
return|;
block|}
comment|/** Follows the<code>follow</code> arc and reads the last    *  arc of its target; this changes the provided    *<code>arc</code> (2nd arg) in-place and returns it.    *     * @return Returns the second argument    * (<code>arc</code>). */
DECL|method|readLastTargetArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readLastTargetArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("readLast");
if|if
condition|(
operator|!
name|targetHasArcs
argument_list|(
name|follow
argument_list|)
condition|)
block|{
comment|//System.out.println("  end node");
assert|assert
name|follow
operator|.
name|isFinal
argument_list|()
assert|;
name|arc
operator|.
name|label
operator|=
name|END_LABEL
expr_stmt|;
name|arc
operator|.
name|output
operator|=
name|follow
operator|.
name|nextFinalOutput
expr_stmt|;
name|arc
operator|.
name|flags
operator|=
name|BIT_LAST_ARC
expr_stmt|;
return|return
name|arc
return|;
block|}
else|else
block|{
specifier|final
name|BytesReader
name|in
init|=
name|getBytesReader
argument_list|(
name|follow
operator|.
name|target
argument_list|)
decl_stmt|;
name|arc
operator|.
name|flags
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARCS_AS_FIXED_ARRAY
argument_list|)
condition|)
block|{
comment|// array: jump straight to end
name|arc
operator|.
name|numArcs
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
comment|//System.out.println("  array numArcs=" + arc.numArcs + " bpa=" + arc.bytesPerArc);
name|arc
operator|.
name|posArcsStart
operator|=
name|in
operator|.
name|pos
expr_stmt|;
name|arc
operator|.
name|arcIdx
operator|=
name|arc
operator|.
name|numArcs
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|// non-array: linear scan
name|arc
operator|.
name|bytesPerArc
operator|=
literal|0
expr_stmt|;
comment|//System.out.println("  scan");
while|while
condition|(
operator|!
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
comment|// skip this arc:
name|readLabel
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_STOP_NODE
argument_list|)
condition|)
block|{           }
elseif|else
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{           }
else|else
block|{
name|in
operator|.
name|pos
operator|-=
literal|4
expr_stmt|;
block|}
name|arc
operator|.
name|flags
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
block|}
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|pos
operator|+
literal|1
expr_stmt|;
block|}
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
expr_stmt|;
assert|assert
name|arc
operator|.
name|isLast
argument_list|()
assert|;
return|return
name|arc
return|;
block|}
block|}
comment|/**    * Follow the<code>follow</code> arc and read the first arc of its target;    * this changes the provided<code>arc</code> (2nd arg) in-place and returns    * it.    *     * @return Returns the second argument (<code>arc</code>).    */
DECL|method|readFirstTargetArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readFirstTargetArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
throws|throws
name|IOException
block|{
comment|//int pos = address;
comment|//System.out.println("    readFirstTarget follow.target=" + follow.target + " isFinal=" + follow.isFinal());
if|if
condition|(
name|follow
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|// Insert "fake" final first arc:
name|arc
operator|.
name|label
operator|=
name|END_LABEL
expr_stmt|;
name|arc
operator|.
name|output
operator|=
name|follow
operator|.
name|nextFinalOutput
expr_stmt|;
if|if
condition|(
name|follow
operator|.
name|target
operator|<=
literal|0
condition|)
block|{
name|arc
operator|.
name|flags
operator|=
name|BIT_LAST_ARC
operator||
name|BIT_FINAL_ARC
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|flags
operator|=
name|BIT_FINAL_ARC
expr_stmt|;
name|arc
operator|.
name|nextArc
operator|=
name|follow
operator|.
name|target
expr_stmt|;
block|}
comment|//System.out.println("    insert isFinal; nextArc=" + follow.target + " isLast=" + arc.isLast() + " output=" + outputs.outputToString(arc.output));
return|return
name|arc
return|;
block|}
else|else
block|{
return|return
name|readFirstRealArc
argument_list|(
name|follow
operator|.
name|target
argument_list|,
name|arc
argument_list|)
return|;
block|}
block|}
DECL|method|readFirstRealArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readFirstRealArc
parameter_list|(
name|int
name|address
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|BytesReader
name|in
init|=
name|getBytesReader
argument_list|(
name|address
argument_list|)
decl_stmt|;
name|arc
operator|.
name|flags
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARCS_AS_FIXED_ARRAY
argument_list|)
condition|)
block|{
comment|//System.out.println("  fixedArray");
comment|// this is first arc in a fixed-array
name|arc
operator|.
name|numArcs
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|arc
operator|.
name|arcIdx
operator|=
operator|-
literal|1
expr_stmt|;
name|arc
operator|.
name|nextArc
operator|=
name|arc
operator|.
name|posArcsStart
operator|=
name|in
operator|.
name|pos
expr_stmt|;
comment|//System.out.println("  bytesPer=" + arc.bytesPerArc + " numArcs=" + arc.numArcs + " arcsStart=" + pos);
block|}
else|else
block|{
name|arc
operator|.
name|nextArc
operator|=
name|address
expr_stmt|;
name|arc
operator|.
name|bytesPerArc
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
comment|/**    * Checks if<code>arc</code>'s target state is in expanded (or vector) format.     *     * @return Returns<code>true</code> if<code>arc</code> points to a state in an    * expanded array format.    */
DECL|method|isExpandedTarget
name|boolean
name|isExpandedTarget
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|targetHasArcs
argument_list|(
name|follow
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
specifier|final
name|BytesReader
name|in
init|=
name|getBytesReader
argument_list|(
name|follow
operator|.
name|target
argument_list|)
decl_stmt|;
specifier|final
name|byte
name|b
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
return|return
operator|(
name|b
operator|&
name|BIT_ARCS_AS_FIXED_ARRAY
operator|)
operator|!=
literal|0
return|;
block|}
block|}
comment|/** In-place read; returns the arc. */
DECL|method|readNextArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readNextArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|arc
operator|.
name|label
operator|==
name|END_LABEL
condition|)
block|{
comment|// This was a fake inserted "final" arc
if|if
condition|(
name|arc
operator|.
name|nextArc
operator|<=
literal|0
condition|)
block|{
comment|// This arc went to virtual final node, ie has no outgoing arcs
return|return
literal|null
return|;
block|}
return|return
name|readFirstRealArc
argument_list|(
name|arc
operator|.
name|nextArc
argument_list|,
name|arc
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|getBytesReader
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Peeks at next arc's label; does not alter arc.  Do    *  not call this if arc.isLast()! */
DECL|method|readNextArcLabel
specifier|public
name|int
name|readNextArcLabel
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|arc
operator|.
name|isLast
argument_list|()
assert|;
specifier|final
name|BytesReader
name|in
decl_stmt|;
if|if
condition|(
name|arc
operator|.
name|label
operator|==
name|END_LABEL
condition|)
block|{
comment|//System.out.println("    nextArc fake " + arc.nextArc);
name|in
operator|=
name|getBytesReader
argument_list|(
name|arc
operator|.
name|nextArc
argument_list|)
expr_stmt|;
name|byte
name|flags
init|=
name|bytes
index|[
name|in
operator|.
name|pos
index|]
decl_stmt|;
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_ARCS_AS_FIXED_ARRAY
argument_list|)
condition|)
block|{
comment|//System.out.println("    nextArc fake array");
name|in
operator|.
name|pos
operator|--
expr_stmt|;
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|arc
operator|.
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
comment|//System.out.println("    nextArc real array");
comment|// arcs are at fixed entries
name|in
operator|=
name|getBytesReader
argument_list|(
name|arc
operator|.
name|posArcsStart
operator|-
operator|(
literal|1
operator|+
name|arc
operator|.
name|arcIdx
operator|)
operator|*
name|arc
operator|.
name|bytesPerArc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// arcs are packed
comment|//System.out.println("    nextArc real packed");
name|in
operator|=
name|getBytesReader
argument_list|(
name|arc
operator|.
name|nextArc
argument_list|)
expr_stmt|;
block|}
block|}
comment|// skip flags
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
return|return
name|readLabel
argument_list|(
name|in
argument_list|)
return|;
block|}
comment|/** Never returns null, but you should never call this if    *  arc.isLast() is true. */
DECL|method|readNextRealArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readNextRealArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|,
specifier|final
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|// this is a continuing arc in a fixed array
if|if
condition|(
name|arc
operator|.
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
comment|// arcs are at fixed entries
name|arc
operator|.
name|arcIdx
operator|++
expr_stmt|;
assert|assert
name|arc
operator|.
name|arcIdx
operator|<
name|arc
operator|.
name|numArcs
assert|;
name|in
operator|.
name|pos
operator|=
name|arc
operator|.
name|posArcsStart
operator|-
name|arc
operator|.
name|arcIdx
operator|*
name|arc
operator|.
name|bytesPerArc
expr_stmt|;
block|}
else|else
block|{
comment|// arcs are packed
name|in
operator|.
name|pos
operator|=
name|arc
operator|.
name|nextArc
expr_stmt|;
block|}
name|arc
operator|.
name|flags
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|arc
operator|.
name|label
operator|=
name|readLabel
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|arc
operator|.
name|output
operator|=
name|outputs
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|output
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|arc
operator|.
name|nextFinalOutput
operator|=
name|outputs
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|nextFinalOutput
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_STOP_NODE
argument_list|)
condition|)
block|{
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_FINAL_ARC
argument_list|)
condition|)
block|{
name|arc
operator|.
name|target
operator|=
name|FINAL_END_NODE
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|target
operator|=
name|NON_FINAL_END_NODE
expr_stmt|;
block|}
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|pos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|pos
expr_stmt|;
if|if
condition|(
operator|!
name|arc
operator|.
name|flag
argument_list|(
name|BIT_LAST_ARC
argument_list|)
condition|)
block|{
if|if
condition|(
name|arc
operator|.
name|bytesPerArc
operator|==
literal|0
condition|)
block|{
comment|// must scan
name|seekToNextNode
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|.
name|pos
operator|=
name|arc
operator|.
name|posArcsStart
operator|-
name|arc
operator|.
name|bytesPerArc
operator|*
name|arc
operator|.
name|numArcs
expr_stmt|;
block|}
block|}
name|arc
operator|.
name|target
operator|=
name|in
operator|.
name|pos
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|target
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|pos
expr_stmt|;
block|}
return|return
name|arc
return|;
block|}
comment|/** Finds an arc leaving the incoming arc, replacing the arc in place.    *  This returns null if the arc was not found, else the incoming arc. */
DECL|method|findTargetArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|findTargetArc
parameter_list|(
name|int
name|labelToMatch
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|follow
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|cachedRootArcs
operator|!=
literal|null
assert|;
comment|// Short-circuit if this arc is in the root arc cache:
if|if
condition|(
name|follow
operator|.
name|target
operator|==
name|startNode
operator|&&
name|labelToMatch
operator|!=
name|END_LABEL
operator|&&
name|labelToMatch
operator|<
name|cachedRootArcs
operator|.
name|length
condition|)
block|{
specifier|final
name|Arc
argument_list|<
name|T
argument_list|>
name|result
init|=
name|cachedRootArcs
index|[
name|labelToMatch
index|]
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
else|else
block|{
name|arc
operator|.
name|copyFrom
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|arc
return|;
block|}
block|}
if|if
condition|(
name|labelToMatch
operator|==
name|END_LABEL
condition|)
block|{
if|if
condition|(
name|follow
operator|.
name|isFinal
argument_list|()
condition|)
block|{
if|if
condition|(
name|follow
operator|.
name|target
operator|<=
literal|0
condition|)
block|{
name|arc
operator|.
name|flags
operator|=
name|BIT_LAST_ARC
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|arc
operator|.
name|nextArc
operator|=
name|follow
operator|.
name|target
expr_stmt|;
block|}
name|arc
operator|.
name|output
operator|=
name|follow
operator|.
name|nextFinalOutput
expr_stmt|;
name|arc
operator|.
name|label
operator|=
name|END_LABEL
expr_stmt|;
return|return
name|arc
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
if|if
condition|(
operator|!
name|targetHasArcs
argument_list|(
name|follow
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// TODO: maybe make an explicit thread state that holds
comment|// reusable stuff eg BytesReader:
specifier|final
name|BytesReader
name|in
init|=
name|getBytesReader
argument_list|(
name|follow
operator|.
name|target
argument_list|)
decl_stmt|;
comment|// System.out.println("fta label=" + (char) labelToMatch);
if|if
condition|(
operator|(
name|in
operator|.
name|readByte
argument_list|()
operator|&
name|BIT_ARCS_AS_FIXED_ARRAY
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// Arcs are full array; do binary search:
name|arc
operator|.
name|numArcs
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|//System.out.println("  bs " + arc.numArcs);
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|arc
operator|.
name|posArcsStart
operator|=
name|in
operator|.
name|pos
expr_stmt|;
name|int
name|low
init|=
literal|0
decl_stmt|;
name|int
name|high
init|=
name|arc
operator|.
name|numArcs
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
comment|//System.out.println("    cycle");
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|in
operator|.
name|pos
operator|=
name|arc
operator|.
name|posArcsStart
operator|-
name|arc
operator|.
name|bytesPerArc
operator|*
name|mid
operator|-
literal|1
expr_stmt|;
name|int
name|midLabel
init|=
name|readLabel
argument_list|(
name|in
argument_list|)
decl_stmt|;
specifier|final
name|int
name|cmp
init|=
name|midLabel
operator|-
name|labelToMatch
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|arc
operator|.
name|arcIdx
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
comment|//System.out.println("    found!");
return|return
name|readNextRealArc
argument_list|(
name|arc
argument_list|,
name|in
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// Linear scan
name|readFirstTargetArc
argument_list|(
name|follow
argument_list|,
name|arc
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|//System.out.println("  non-bs cycle");
comment|// TODO: we should fix this code to not have to create
comment|// object for the output of every arc we scan... only
comment|// for the matching arc, if found
if|if
condition|(
name|arc
operator|.
name|label
operator|==
name|labelToMatch
condition|)
block|{
comment|//System.out.println("    found!");
return|return
name|arc
return|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|label
operator|>
name|labelToMatch
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|readNextArc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|seekToNextNode
specifier|private
name|void
name|seekToNextNode
parameter_list|(
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|flags
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
name|readLabel
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_STOP_NODE
argument_list|)
operator|&&
operator|!
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_LAST_ARC
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
DECL|method|getNodeCount
specifier|public
name|int
name|getNodeCount
parameter_list|()
block|{
comment|// 1+ in order to count the -1 implicit final node
return|return
literal|1
operator|+
name|nodeCount
return|;
block|}
DECL|method|getArcCount
specifier|public
name|int
name|getArcCount
parameter_list|()
block|{
return|return
name|arcCount
return|;
block|}
DECL|method|getArcWithOutputCount
specifier|public
name|int
name|getArcWithOutputCount
parameter_list|()
block|{
return|return
name|arcWithOutputCount
return|;
block|}
DECL|method|setAllowArrayArcs
specifier|public
name|void
name|setAllowArrayArcs
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
name|allowArrayArcs
operator|=
name|v
expr_stmt|;
block|}
comment|/**    * Nodes will be expanded if their depth (distance from the root node) is    *&lt;= this value and their number of arcs is&gt;=    * {@link #FIXED_ARRAY_NUM_ARCS_SHALLOW}.    *     *<p>    * Fixed array consumes more RAM but enables binary search on the arcs    * (instead of a linear scan) on lookup by arc label.    *     * @return<code>true</code> if<code>node</code> should be stored in an    *         expanded (array) form.    *     * @see #FIXED_ARRAY_NUM_ARCS_DEEP    * @see Builder.UnCompiledNode#depth    */
DECL|method|shouldExpand
specifier|private
name|boolean
name|shouldExpand
parameter_list|(
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|)
block|{
return|return
name|allowArrayArcs
operator|&&
operator|(
operator|(
name|node
operator|.
name|depth
operator|<=
name|FIXED_ARRAY_SHALLOW_DISTANCE
operator|&&
name|node
operator|.
name|numArcs
operator|>=
name|FIXED_ARRAY_NUM_ARCS_SHALLOW
operator|)
operator|||
name|node
operator|.
name|numArcs
operator|>=
name|FIXED_ARRAY_NUM_ARCS_DEEP
operator|)
return|;
block|}
comment|// Non-static: writes to FST's byte[]
DECL|class|BytesWriter
class|class
name|BytesWriter
extends|extends
name|DataOutput
block|{
DECL|field|posWrite
name|int
name|posWrite
decl_stmt|;
DECL|method|BytesWriter
specifier|public
name|BytesWriter
parameter_list|()
block|{
comment|// pad: ensure no node gets address 0 which is reserved to mean
comment|// the stop state w/ no arcs
name|posWrite
operator|=
literal|1
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeByte
specifier|public
name|void
name|writeByte
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|.
name|length
operator|==
name|posWrite
condition|)
block|{
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
assert|assert
name|posWrite
operator|<
name|bytes
operator|.
name|length
operator|:
literal|"posWrite="
operator|+
name|posWrite
operator|+
literal|" bytes.length="
operator|+
name|bytes
operator|.
name|length
assert|;
name|bytes
index|[
name|posWrite
operator|++
index|]
operator|=
name|b
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeBytes
specifier|public
name|void
name|writeBytes
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
specifier|final
name|int
name|size
init|=
name|posWrite
operator|+
name|length
decl_stmt|;
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|bytes
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|,
name|posWrite
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|posWrite
operator|+=
name|length
expr_stmt|;
block|}
block|}
DECL|method|getBytesReader
specifier|public
specifier|final
name|BytesReader
name|getBytesReader
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
comment|// TODO: maybe re-use via ThreadLocal?
return|return
operator|new
name|BytesReader
argument_list|(
name|pos
argument_list|)
return|;
block|}
comment|// Non-static: reads byte[] from FST
DECL|class|BytesReader
specifier|final
class|class
name|BytesReader
extends|extends
name|DataInput
block|{
DECL|field|pos
name|int
name|pos
decl_stmt|;
DECL|method|BytesReader
specifier|public
name|BytesReader
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|this
operator|.
name|pos
operator|=
name|pos
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|readByte
specifier|public
name|byte
name|readByte
parameter_list|()
block|{
return|return
name|bytes
index|[
name|pos
operator|--
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|readBytes
specifier|public
name|void
name|readBytes
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|b
index|[
name|offset
operator|+
name|i
index|]
operator|=
name|bytes
index|[
name|pos
operator|--
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
end_class
end_unit
