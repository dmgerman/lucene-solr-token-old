begin_unit
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import
begin_class
DECL|class|ThreadSafeCloneableSortedMap
specifier|public
class|class
name|ThreadSafeCloneableSortedMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Cloneable
block|{
DECL|field|copy
specifier|private
specifier|volatile
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copy
decl_stmt|;
DECL|field|cloneLock
specifier|private
name|Lock
name|cloneLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
DECL|field|delegate
specifier|private
specifier|final
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
decl_stmt|;
DECL|method|ThreadSafeCloneableSortedMap
specifier|private
name|ThreadSafeCloneableSortedMap
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
DECL|method|getThreadSafeSortedMap
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ThreadSafeCloneableSortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getThreadSafeSortedMap
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|delegate
parameter_list|)
block|{
return|return
operator|new
name|ThreadSafeCloneableSortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|delegate
argument_list|)
return|;
block|}
DECL|method|getReadCopy
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getReadCopy
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
init|=
name|copy
decl_stmt|;
if|if
condition|(
name|m
operator|!=
literal|null
condition|)
block|{
return|return
name|m
return|;
block|}
comment|// we have to clone
name|cloneLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// check again - maybe a different thread was faster
name|m
operator|=
name|copy
expr_stmt|;
if|if
condition|(
name|m
operator|!=
literal|null
condition|)
block|{
return|return
name|m
return|;
block|}
comment|// still no copy there - create one now
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|clone
init|=
name|clone
argument_list|(
name|delegate
argument_list|)
decl_stmt|;
name|copy
operator|=
name|clone
expr_stmt|;
return|return
name|clone
return|;
block|}
finally|finally
block|{
name|cloneLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|clone
specifier|protected
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|clone
parameter_list|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
if|if
condition|(
name|map
operator|instanceof
name|TreeMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
condition|)
block|{
return|return
call|(
name|TreeMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
call|)
argument_list|(
operator|(
name|TreeMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|map
argument_list|)
operator|.
name|clone
argument_list|()
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|map
operator|.
name|getClass
argument_list|()
operator|+
literal|" not supported. Overwrite clone(SortedMap<K, V> map) in a custom subclass to support this map."
argument_list|)
throw|;
block|}
DECL|class|Task
specifier|private
specifier|abstract
specifier|static
class|class
name|Task
parameter_list|<
name|T
parameter_list|>
block|{
DECL|method|run
specifier|abstract
name|T
name|run
parameter_list|()
function_decl|;
block|}
DECL|method|withLock
specifier|private
specifier|final
parameter_list|<
name|T
parameter_list|>
name|T
name|withLock
parameter_list|(
name|Task
argument_list|<
name|T
argument_list|>
name|task
parameter_list|)
block|{
name|copy
operator|=
literal|null
expr_stmt|;
name|cloneLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|task
operator|.
name|run
argument_list|()
return|;
block|}
finally|finally
block|{
name|cloneLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|comparator
annotation|@
name|Override
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|comparator
argument_list|()
return|;
block|}
DECL|method|subMap
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subMap
parameter_list|(
name|K
name|fromKey
parameter_list|,
name|K
name|toKey
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|subMap
argument_list|(
name|fromKey
argument_list|,
name|toKey
argument_list|)
return|;
block|}
DECL|method|headMap
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|headMap
parameter_list|(
name|K
name|toKey
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|headMap
argument_list|(
name|toKey
argument_list|)
return|;
block|}
DECL|method|tailMap
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tailMap
parameter_list|(
name|K
name|fromKey
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|tailMap
argument_list|(
name|fromKey
argument_list|)
return|;
block|}
DECL|method|firstKey
annotation|@
name|Override
specifier|public
name|K
name|firstKey
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|firstKey
argument_list|()
return|;
block|}
DECL|method|lastKey
annotation|@
name|Override
specifier|public
name|K
name|lastKey
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|lastKey
argument_list|()
return|;
block|}
DECL|method|size
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isEmpty
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|containsKey
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|containsValue
annotation|@
name|Override
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|containsValue
argument_list|(
name|value
argument_list|)
return|;
block|}
DECL|method|get
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|put
annotation|@
name|Override
specifier|public
name|V
name|put
parameter_list|(
specifier|final
name|K
name|key
parameter_list|,
specifier|final
name|V
name|value
parameter_list|)
block|{
return|return
name|withLock
argument_list|(
operator|new
name|Task
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
name|V
name|run
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
DECL|method|remove
annotation|@
name|Override
specifier|public
name|V
name|remove
parameter_list|(
specifier|final
name|Object
name|key
parameter_list|)
block|{
return|return
name|withLock
argument_list|(
operator|new
name|Task
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
name|V
name|run
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|remove
argument_list|(
name|key
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
DECL|method|putAll
annotation|@
name|Override
specifier|public
name|void
name|putAll
parameter_list|(
specifier|final
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
name|withLock
argument_list|(
operator|new
name|Task
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
name|V
name|run
parameter_list|()
block|{
name|delegate
operator|.
name|putAll
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|clear
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|withLock
argument_list|(
operator|new
name|Task
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
name|V
name|run
parameter_list|()
block|{
name|delegate
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// nocommit : don't use these methods to modify the map.
comment|// TODO implement Set and Collection that acquire lock for modifications
comment|//
DECL|method|keySet
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|keySet
argument_list|()
return|;
block|}
DECL|method|values
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|values
argument_list|()
return|;
block|}
DECL|method|entrySet
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|entrySet
argument_list|()
return|;
block|}
block|}
end_class
end_unit
