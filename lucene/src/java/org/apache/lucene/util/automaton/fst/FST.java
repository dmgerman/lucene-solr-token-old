begin_unit
begin_package
DECL|package|org.apache.lucene.util.automaton.fst
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|fst
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_comment
comment|/** Represents an FST using a compact byte[] format.  *<p> The format is similar to what's used by Morfologik  *  (http://sourceforge.net/projects/morfologik).  * @lucene.experimental  */
end_comment
begin_class
DECL|class|FST
specifier|public
class|class
name|FST
parameter_list|<
name|T
parameter_list|>
block|{
DECL|enum|INPUT_TYPE
DECL|enum constant|BYTE1
DECL|enum constant|BYTE2
DECL|enum constant|BYTE4
specifier|public
specifier|static
enum|enum
name|INPUT_TYPE
block|{
name|BYTE1
block|,
name|BYTE2
block|,
name|BYTE4
block|}
empty_stmt|;
DECL|field|inputType
specifier|private
specifier|final
name|INPUT_TYPE
name|inputType
decl_stmt|;
DECL|field|BIT_FINAL_ARC
specifier|private
specifier|final
specifier|static
name|int
name|BIT_FINAL_ARC
init|=
literal|1
operator|<<
literal|0
decl_stmt|;
DECL|field|BIT_LAST_ARC
specifier|private
specifier|final
specifier|static
name|int
name|BIT_LAST_ARC
init|=
literal|1
operator|<<
literal|1
decl_stmt|;
DECL|field|BIT_TARGET_NEXT
specifier|private
specifier|final
specifier|static
name|int
name|BIT_TARGET_NEXT
init|=
literal|1
operator|<<
literal|2
decl_stmt|;
DECL|field|BIT_STOP_NODE
specifier|private
specifier|final
specifier|static
name|int
name|BIT_STOP_NODE
init|=
literal|1
operator|<<
literal|3
decl_stmt|;
DECL|field|BIT_ARC_HAS_OUTPUT
specifier|private
specifier|final
specifier|static
name|int
name|BIT_ARC_HAS_OUTPUT
init|=
literal|1
operator|<<
literal|4
decl_stmt|;
DECL|field|BIT_ARC_HAS_FINAL_OUTPUT
specifier|private
specifier|final
specifier|static
name|int
name|BIT_ARC_HAS_FINAL_OUTPUT
init|=
literal|1
operator|<<
literal|5
decl_stmt|;
comment|// Arcs are stored as fixed-size (per entry) array, so
comment|// that we can find an arc using binary search.  We do
comment|// this when number of arcs is> NUM_ARCS_ARRAY:
DECL|field|BIT_ARCS_AS_FIXED_ARRAY
specifier|private
specifier|final
specifier|static
name|int
name|BIT_ARCS_AS_FIXED_ARRAY
init|=
literal|1
operator|<<
literal|6
decl_stmt|;
comment|// If the node has>= this number of arcs, the arcs are
comment|// stored as a fixed array.  Fixed array consumes more RAM
comment|// but enables binary search on the arcs (instead of
comment|// linear scan) on lookup by arc label:
DECL|field|NUM_ARCS_FIXED_ARRAY
specifier|private
specifier|final
specifier|static
name|int
name|NUM_ARCS_FIXED_ARRAY
init|=
literal|10
decl_stmt|;
DECL|field|bytesPerArc
specifier|private
name|int
index|[]
name|bytesPerArc
init|=
operator|new
name|int
index|[
literal|0
index|]
decl_stmt|;
comment|// Increment version to change it
DECL|field|FILE_FORMAT_NAME
specifier|private
specifier|final
specifier|static
name|String
name|FILE_FORMAT_NAME
init|=
literal|"FST"
decl_stmt|;
DECL|field|VERSION_START
specifier|private
specifier|final
specifier|static
name|int
name|VERSION_START
init|=
literal|0
decl_stmt|;
DECL|field|VERSION_CURRENT
specifier|private
specifier|final
specifier|static
name|int
name|VERSION_CURRENT
init|=
name|VERSION_START
decl_stmt|;
comment|// Never serialized; just used to represent the virtual
comment|// final node w/ no arcs:
DECL|field|FINAL_END_NODE
specifier|private
specifier|final
specifier|static
name|int
name|FINAL_END_NODE
init|=
operator|-
literal|1
decl_stmt|;
comment|// Never serialized; just used to represent the virtual
comment|// non-final node w/ no arcs:
DECL|field|NON_FINAL_END_NODE
specifier|private
specifier|final
specifier|static
name|int
name|NON_FINAL_END_NODE
init|=
literal|0
decl_stmt|;
comment|// if non-null, this FST accepts the empty string and
comment|// produces this output
DECL|field|emptyOutput
specifier|private
name|T
name|emptyOutput
decl_stmt|;
DECL|field|emptyOutputBytes
specifier|private
name|byte
index|[]
name|emptyOutputBytes
decl_stmt|;
DECL|field|bytes
specifier|private
name|byte
index|[]
name|bytes
decl_stmt|;
DECL|field|byteUpto
name|int
name|byteUpto
init|=
literal|0
decl_stmt|;
DECL|field|startNode
specifier|private
name|int
name|startNode
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|outputs
specifier|public
specifier|final
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
decl_stmt|;
DECL|field|lastFrozenNode
specifier|private
name|int
name|lastFrozenNode
decl_stmt|;
DECL|field|NO_OUTPUT
specifier|private
specifier|final
name|T
name|NO_OUTPUT
decl_stmt|;
DECL|field|nodeCount
specifier|public
name|int
name|nodeCount
decl_stmt|;
DECL|field|arcCount
specifier|public
name|int
name|arcCount
decl_stmt|;
DECL|field|arcWithOutputCount
specifier|public
name|int
name|arcWithOutputCount
decl_stmt|;
DECL|class|Arc
specifier|public
specifier|final
specifier|static
class|class
name|Arc
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|label
name|int
name|label
decl_stmt|;
comment|// really a "unsigned" byte
DECL|field|target
name|int
name|target
decl_stmt|;
DECL|field|flags
name|byte
name|flags
decl_stmt|;
DECL|field|output
name|T
name|output
decl_stmt|;
DECL|field|nextFinalOutput
name|T
name|nextFinalOutput
decl_stmt|;
DECL|field|nextArc
name|int
name|nextArc
decl_stmt|;
comment|// This is non-zero if current arcs are fixed array:
DECL|field|posArcsStart
name|int
name|posArcsStart
decl_stmt|;
DECL|field|bytesPerArc
name|int
name|bytesPerArc
decl_stmt|;
DECL|field|arcIdx
name|int
name|arcIdx
decl_stmt|;
DECL|field|numArcs
name|int
name|numArcs
decl_stmt|;
comment|// Must call this before re-using an Arc instance on a
comment|// new node
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|bytesPerArc
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|flag
specifier|public
name|boolean
name|flag
parameter_list|(
name|int
name|flag
parameter_list|)
block|{
return|return
name|FST
operator|.
name|flag
argument_list|(
name|flags
argument_list|,
name|flag
argument_list|)
return|;
block|}
DECL|method|isLast
specifier|public
name|boolean
name|isLast
parameter_list|()
block|{
return|return
name|flag
argument_list|(
name|BIT_LAST_ARC
argument_list|)
return|;
block|}
DECL|method|isFinal
specifier|public
name|boolean
name|isFinal
parameter_list|()
block|{
return|return
name|flag
argument_list|(
name|BIT_FINAL_ARC
argument_list|)
return|;
block|}
block|}
empty_stmt|;
DECL|method|flag
specifier|static
name|boolean
name|flag
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
return|return
operator|(
name|flags
operator|&
name|bit
operator|)
operator|!=
literal|0
return|;
block|}
DECL|field|writer
specifier|private
specifier|final
name|BytesWriter
name|writer
decl_stmt|;
comment|// make a new empty FST, for building
DECL|method|FST
specifier|public
name|FST
parameter_list|(
name|INPUT_TYPE
name|inputType
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|)
block|{
name|this
operator|.
name|inputType
operator|=
name|inputType
expr_stmt|;
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
name|bytes
operator|=
operator|new
name|byte
index|[
literal|128
index|]
expr_stmt|;
name|NO_OUTPUT
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
name|writer
operator|=
operator|new
name|BytesWriter
argument_list|()
expr_stmt|;
name|emptyOutput
operator|=
literal|null
expr_stmt|;
block|}
comment|// create an existing FST
DECL|method|FST
specifier|public
name|FST
parameter_list|(
name|IndexInput
name|in
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
name|writer
operator|=
literal|null
expr_stmt|;
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|in
argument_list|,
name|FILE_FORMAT_NAME
argument_list|,
name|VERSION_START
argument_list|,
name|VERSION_START
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|readByte
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// accepts empty string
name|int
name|numBytes
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
comment|// messy
name|bytes
operator|=
operator|new
name|byte
index|[
name|numBytes
index|]
expr_stmt|;
name|in
operator|.
name|readBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|emptyOutput
operator|=
name|outputs
operator|.
name|read
argument_list|(
operator|new
name|BytesReader
argument_list|(
name|numBytes
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emptyOutput
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|byte
name|t
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
literal|0
case|:
name|inputType
operator|=
name|INPUT_TYPE
operator|.
name|BYTE1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|inputType
operator|=
name|INPUT_TYPE
operator|.
name|BYTE2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|inputType
operator|=
name|INPUT_TYPE
operator|.
name|BYTE4
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"invalid input type "
operator|+
name|t
argument_list|)
throw|;
block|}
name|startNode
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|nodeCount
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|arcCount
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|arcWithOutputCount
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|bytes
operator|=
operator|new
name|byte
index|[
name|in
operator|.
name|readVInt
argument_list|()
index|]
expr_stmt|;
name|in
operator|.
name|readBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|NO_OUTPUT
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
block|}
DECL|method|getInputType
specifier|public
name|INPUT_TYPE
name|getInputType
parameter_list|()
block|{
return|return
name|inputType
return|;
block|}
comment|/** Returns bytes used to represent the FST */
DECL|method|sizeInBytes
specifier|public
name|int
name|sizeInBytes
parameter_list|()
block|{
return|return
name|bytes
operator|.
name|length
return|;
block|}
DECL|method|finish
name|void
name|finish
parameter_list|(
name|int
name|startNode
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|startNode
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"already finished"
argument_list|)
throw|;
block|}
name|byte
index|[]
name|finalBytes
init|=
operator|new
name|byte
index|[
name|writer
operator|.
name|posWrite
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|finalBytes
argument_list|,
literal|0
argument_list|,
name|writer
operator|.
name|posWrite
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|finalBytes
expr_stmt|;
name|this
operator|.
name|startNode
operator|=
name|startNode
expr_stmt|;
block|}
DECL|method|setEmptyOutput
specifier|public
name|void
name|setEmptyOutput
parameter_list|(
name|T
name|v
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"empty output is already set"
argument_list|)
throw|;
block|}
name|emptyOutput
operator|=
name|v
expr_stmt|;
comment|// TODO: this is messy -- replace with sillyBytesWriter; maybe make
comment|// bytes private
specifier|final
name|int
name|posSave
init|=
name|writer
operator|.
name|posWrite
decl_stmt|;
name|outputs
operator|.
name|write
argument_list|(
name|emptyOutput
argument_list|,
name|writer
argument_list|)
expr_stmt|;
name|emptyOutputBytes
operator|=
operator|new
name|byte
index|[
name|writer
operator|.
name|posWrite
operator|-
name|posSave
index|]
expr_stmt|;
comment|// reverse
specifier|final
name|int
name|stopAt
init|=
operator|(
name|writer
operator|.
name|posWrite
operator|-
name|posSave
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|stopAt
condition|)
block|{
specifier|final
name|byte
name|b
init|=
name|bytes
index|[
name|posSave
operator|+
name|upto
index|]
decl_stmt|;
name|bytes
index|[
name|posSave
operator|+
name|upto
index|]
operator|=
name|bytes
index|[
name|writer
operator|.
name|posWrite
operator|-
name|upto
operator|-
literal|1
index|]
expr_stmt|;
name|bytes
index|[
name|writer
operator|.
name|posWrite
operator|-
name|upto
operator|-
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
name|posSave
argument_list|,
name|emptyOutputBytes
argument_list|,
literal|0
argument_list|,
name|writer
operator|.
name|posWrite
operator|-
name|posSave
argument_list|)
expr_stmt|;
name|writer
operator|.
name|posWrite
operator|=
name|posSave
expr_stmt|;
block|}
DECL|method|save
specifier|public
name|void
name|save
parameter_list|(
name|IndexOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|startNode
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"call finish first"
argument_list|)
throw|;
block|}
name|CodecUtil
operator|.
name|writeHeader
argument_list|(
name|out
argument_list|,
name|FILE_FORMAT_NAME
argument_list|,
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|1
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|emptyOutputBytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|emptyOutputBytes
argument_list|,
literal|0
argument_list|,
name|emptyOutputBytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|final
name|byte
name|t
decl_stmt|;
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE1
condition|)
block|{
name|t
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE2
condition|)
block|{
name|t
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
literal|2
expr_stmt|;
block|}
name|out
operator|.
name|writeByte
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|startNode
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|nodeCount
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|arcCount
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|arcWithOutputCount
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|writeLabel
specifier|private
name|void
name|writeLabel
parameter_list|(
name|int
name|v
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|v
operator|>=
literal|0
operator|:
literal|"v="
operator|+
name|v
assert|;
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE1
condition|)
block|{
assert|assert
name|v
operator|<=
literal|255
operator|:
literal|"v="
operator|+
name|v
assert|;
name|writer
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE2
condition|)
block|{
assert|assert
name|v
operator|<=
literal|65535
operator|:
literal|"v="
operator|+
name|v
assert|;
name|writer
operator|.
name|writeVInt
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//writeInt(v);
name|writer
operator|.
name|writeVInt
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|readLabel
specifier|private
name|int
name|readLabel
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|v
decl_stmt|;
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE1
condition|)
block|{
name|v
operator|=
name|in
operator|.
name|readByte
argument_list|()
operator|&
literal|0xFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE2
condition|)
block|{
name|v
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
comment|// returns true if the node at this address has any
comment|// outgoing arcs
DECL|method|hasArcs
specifier|public
name|boolean
name|hasArcs
parameter_list|(
name|int
name|address
parameter_list|)
block|{
return|return
name|address
operator|!=
name|FINAL_END_NODE
operator|&&
name|address
operator|!=
name|NON_FINAL_END_NODE
return|;
block|}
DECL|method|getStartNode
specifier|public
name|int
name|getStartNode
parameter_list|()
block|{
if|if
condition|(
name|startNode
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"call finish first"
argument_list|)
throw|;
block|}
return|return
name|startNode
return|;
block|}
comment|// returns null if this FST does not accept the empty
comment|// string, else, the output for the empty string
DECL|method|getEmptyOutput
specifier|public
name|T
name|getEmptyOutput
parameter_list|()
block|{
return|return
name|emptyOutput
return|;
block|}
comment|// serializes new node by appending its bytes to the end
comment|// of the current byte[]
DECL|method|addNode
name|int
name|addNode
parameter_list|(
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|T
argument_list|>
name|node
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("FST.addNode pos=" + posWrite + " numArcs=" + node.numArcs);
if|if
condition|(
name|node
operator|.
name|numArcs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|isFinal
condition|)
block|{
return|return
name|FINAL_END_NODE
return|;
block|}
else|else
block|{
return|return
name|NON_FINAL_END_NODE
return|;
block|}
block|}
name|int
name|startAddress
init|=
name|writer
operator|.
name|posWrite
decl_stmt|;
comment|//System.out.println("  startAddr=" + startAddress);
specifier|final
name|boolean
name|doFixedArray
init|=
name|node
operator|.
name|numArcs
operator|>=
name|NUM_ARCS_FIXED_ARRAY
decl_stmt|;
specifier|final
name|int
name|fixedArrayStart
decl_stmt|;
if|if
condition|(
name|doFixedArray
condition|)
block|{
if|if
condition|(
name|bytesPerArc
operator|.
name|length
operator|<
name|node
operator|.
name|numArcs
condition|)
block|{
name|bytesPerArc
operator|=
operator|new
name|int
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|node
operator|.
name|numArcs
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
comment|// write a "false" first arc:
name|writer
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|BIT_ARCS_AS_FIXED_ARRAY
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeVInt
argument_list|(
name|node
operator|.
name|numArcs
argument_list|)
expr_stmt|;
comment|// placeholder -- we'll come back and write the number
comment|// of bytes per arc here:
name|writer
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fixedArrayStart
operator|=
name|writer
operator|.
name|posWrite
expr_stmt|;
comment|//System.out.println("  do fixed arcs array arcsStart=" + fixedArrayStart);
block|}
else|else
block|{
name|fixedArrayStart
operator|=
literal|0
expr_stmt|;
block|}
name|nodeCount
operator|++
expr_stmt|;
name|arcCount
operator|+=
name|node
operator|.
name|numArcs
expr_stmt|;
specifier|final
name|int
name|lastArc
init|=
name|node
operator|.
name|numArcs
operator|-
literal|1
decl_stmt|;
name|int
name|lastArcStart
init|=
name|writer
operator|.
name|posWrite
decl_stmt|;
name|int
name|maxBytesPerArc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|node
operator|.
name|numArcs
condition|;
name|arcIdx
operator|++
control|)
block|{
specifier|final
name|Builder
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
name|node
operator|.
name|arcs
index|[
name|arcIdx
index|]
decl_stmt|;
specifier|final
name|Builder
operator|.
name|CompiledNode
name|target
init|=
operator|(
name|Builder
operator|.
name|CompiledNode
operator|)
name|arc
operator|.
name|target
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arcIdx
operator|==
name|lastArc
condition|)
block|{
name|flags
operator|+=
name|BIT_LAST_ARC
expr_stmt|;
block|}
if|if
condition|(
name|lastFrozenNode
operator|==
name|target
operator|.
name|address
operator|&&
operator|!
name|doFixedArray
condition|)
block|{
name|flags
operator|+=
name|BIT_TARGET_NEXT
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
condition|)
block|{
name|flags
operator|+=
name|BIT_FINAL_ARC
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|flags
operator|+=
name|BIT_ARC_HAS_FINAL_OUTPUT
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|arc
operator|.
name|nextFinalOutput
operator|==
name|NO_OUTPUT
assert|;
block|}
name|boolean
name|targetHasArcs
init|=
name|hasArcs
argument_list|(
name|target
operator|.
name|address
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|targetHasArcs
condition|)
block|{
name|flags
operator|+=
name|BIT_STOP_NODE
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|flags
operator|+=
name|BIT_ARC_HAS_OUTPUT
expr_stmt|;
block|}
name|writer
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|flags
argument_list|)
expr_stmt|;
name|writeLabel
argument_list|(
name|arc
operator|.
name|label
argument_list|)
expr_stmt|;
comment|//System.out.println("  write arc: label=" + arc.label + " flags=" + flags);
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|outputs
operator|.
name|write
argument_list|(
name|arc
operator|.
name|output
argument_list|,
name|writer
argument_list|)
expr_stmt|;
name|arcWithOutputCount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|outputs
operator|.
name|write
argument_list|(
name|arc
operator|.
name|nextFinalOutput
argument_list|,
name|writer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetHasArcs
operator|&&
operator|(
name|doFixedArray
operator|||
name|lastFrozenNode
operator|!=
name|target
operator|.
name|address
operator|)
condition|)
block|{
assert|assert
name|target
operator|.
name|address
operator|>
literal|0
assert|;
name|writer
operator|.
name|writeInt
argument_list|(
name|target
operator|.
name|address
argument_list|)
expr_stmt|;
block|}
comment|// just write the arcs "like normal" on first pass,
comment|// but record how many bytes each one took, and max
comment|// byte size:
if|if
condition|(
name|doFixedArray
condition|)
block|{
name|bytesPerArc
index|[
name|arcIdx
index|]
operator|=
name|writer
operator|.
name|posWrite
operator|-
name|lastArcStart
expr_stmt|;
name|lastArcStart
operator|=
name|writer
operator|.
name|posWrite
expr_stmt|;
name|maxBytesPerArc
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxBytesPerArc
argument_list|,
name|bytesPerArc
index|[
name|arcIdx
index|]
argument_list|)
expr_stmt|;
comment|//System.out.println("    bytes=" + bytesPerArc[arcIdx]);
block|}
block|}
if|if
condition|(
name|doFixedArray
condition|)
block|{
assert|assert
name|maxBytesPerArc
operator|>
literal|0
assert|;
comment|// 2nd pass just "expands" all arcs to take up a fixed
comment|// byte size
specifier|final
name|int
name|sizeNeeded
init|=
name|fixedArrayStart
operator|+
name|node
operator|.
name|numArcs
operator|*
name|maxBytesPerArc
decl_stmt|;
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|bytes
argument_list|,
name|sizeNeeded
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxBytesPerArc
operator|>
literal|255
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"max arc size is too large ("
operator|+
name|maxBytesPerArc
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|bytes
index|[
name|fixedArrayStart
operator|-
literal|1
index|]
operator|=
operator|(
name|byte
operator|)
name|maxBytesPerArc
expr_stmt|;
comment|// expand the arcs in place, backwards
name|int
name|srcPos
init|=
name|writer
operator|.
name|posWrite
decl_stmt|;
name|int
name|destPos
init|=
name|fixedArrayStart
operator|+
name|node
operator|.
name|numArcs
operator|*
name|maxBytesPerArc
decl_stmt|;
name|writer
operator|.
name|posWrite
operator|=
name|destPos
expr_stmt|;
for|for
control|(
name|int
name|arcIdx
init|=
name|node
operator|.
name|numArcs
operator|-
literal|1
init|;
name|arcIdx
operator|>=
literal|0
condition|;
name|arcIdx
operator|--
control|)
block|{
comment|//System.out.println("  repack arcIdx=" + arcIdx + " srcPos=" + srcPos + " destPos=" + destPos);
name|destPos
operator|-=
name|maxBytesPerArc
expr_stmt|;
name|srcPos
operator|-=
name|bytesPerArc
index|[
name|arcIdx
index|]
expr_stmt|;
if|if
condition|(
name|srcPos
operator|!=
name|destPos
condition|)
block|{
assert|assert
name|destPos
operator|>
name|srcPos
assert|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
name|srcPos
argument_list|,
name|bytes
argument_list|,
name|destPos
argument_list|,
name|bytesPerArc
index|[
name|arcIdx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// reverse bytes in-place; we do this so that the
comment|// "BIT_TARGET_NEXT" opto can work, ie, it reads the
comment|// node just before the current one
specifier|final
name|int
name|endAddress
init|=
name|writer
operator|.
name|posWrite
decl_stmt|;
specifier|final
name|int
name|stopAt
init|=
operator|(
name|endAddress
operator|-
name|startAddress
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|stopAt
condition|)
block|{
specifier|final
name|byte
name|b
init|=
name|bytes
index|[
name|startAddress
operator|+
name|upto
index|]
decl_stmt|;
name|bytes
index|[
name|startAddress
operator|+
name|upto
index|]
operator|=
name|bytes
index|[
name|endAddress
operator|-
name|upto
operator|-
literal|1
index|]
expr_stmt|;
name|bytes
index|[
name|endAddress
operator|-
name|upto
operator|-
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
name|lastFrozenNode
operator|=
name|endAddress
operator|-
literal|1
expr_stmt|;
comment|/*     System.out.println("  return node addr=" + (endAddress-1));     for(int i=endAddress-1;i>=startAddress;i--) {       System.out.println("    bytes[" + i + "]=" + bytes[i]);     }     */
return|return
name|endAddress
operator|-
literal|1
return|;
block|}
DECL|method|readFirstArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readFirstArc
parameter_list|(
name|int
name|address
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("readFirstArc addr=" + address);
comment|//int pos = address;
specifier|final
name|BytesReader
name|in
init|=
operator|new
name|BytesReader
argument_list|(
name|address
argument_list|)
decl_stmt|;
name|arc
operator|.
name|flags
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARCS_AS_FIXED_ARRAY
argument_list|)
condition|)
block|{
comment|//System.out.println("  fixedArray");
comment|// this is first arc in a fixed-array
name|arc
operator|.
name|numArcs
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readByte
argument_list|()
operator|&
literal|0xFF
expr_stmt|;
name|arc
operator|.
name|arcIdx
operator|=
operator|-
literal|1
expr_stmt|;
name|arc
operator|.
name|posArcsStart
operator|=
name|in
operator|.
name|pos
expr_stmt|;
comment|//System.out.println("  bytesPer=" + arc.bytesPerArc + " numArcs=" + arc.numArcs + " arcsStart=" + pos);
block|}
else|else
block|{
name|in
operator|.
name|pos
operator|++
expr_stmt|;
name|arc
operator|.
name|bytesPerArc
operator|=
literal|0
expr_stmt|;
block|}
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|pos
expr_stmt|;
return|return
name|readNextArc
argument_list|(
name|arc
argument_list|)
return|;
block|}
DECL|method|readNextArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|readNextArc
parameter_list|(
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
throws|throws
name|IOException
block|{
comment|// this is a continuing arc in a fixed array
specifier|final
name|BytesReader
name|in
decl_stmt|;
if|if
condition|(
name|arc
operator|.
name|bytesPerArc
operator|!=
literal|0
condition|)
block|{
comment|// arcs are at fixed entries
name|arc
operator|.
name|arcIdx
operator|++
expr_stmt|;
name|in
operator|=
operator|new
name|BytesReader
argument_list|(
name|arc
operator|.
name|posArcsStart
operator|-
name|arc
operator|.
name|arcIdx
operator|*
name|arc
operator|.
name|bytesPerArc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// arcs are packed
name|in
operator|=
operator|new
name|BytesReader
argument_list|(
name|arc
operator|.
name|nextArc
argument_list|)
expr_stmt|;
block|}
name|arc
operator|.
name|flags
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|arc
operator|.
name|label
operator|=
name|readLabel
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|arc
operator|.
name|output
operator|=
name|outputs
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|output
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|arc
operator|.
name|nextFinalOutput
operator|=
name|outputs
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|nextFinalOutput
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_STOP_NODE
argument_list|)
condition|)
block|{
name|arc
operator|.
name|target
operator|=
name|FINAL_END_NODE
expr_stmt|;
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|pos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|pos
expr_stmt|;
if|if
condition|(
operator|!
name|arc
operator|.
name|flag
argument_list|(
name|BIT_LAST_ARC
argument_list|)
condition|)
block|{
if|if
condition|(
name|arc
operator|.
name|bytesPerArc
operator|==
literal|0
condition|)
block|{
comment|// must scan
name|seekToNextNode
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|.
name|pos
operator|=
name|arc
operator|.
name|posArcsStart
operator|-
name|arc
operator|.
name|bytesPerArc
operator|*
name|arc
operator|.
name|numArcs
expr_stmt|;
block|}
block|}
name|arc
operator|.
name|target
operator|=
name|in
operator|.
name|pos
expr_stmt|;
block|}
else|else
block|{
name|arc
operator|.
name|target
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|arc
operator|.
name|nextArc
operator|=
name|in
operator|.
name|pos
expr_stmt|;
block|}
return|return
name|arc
return|;
block|}
DECL|method|findArc
specifier|public
name|Arc
argument_list|<
name|T
argument_list|>
name|findArc
parameter_list|(
name|int
name|address
parameter_list|,
name|int
name|labelToMatch
parameter_list|,
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: maybe make an explicit thread state that holds
comment|// reusable stuff eg BytesReader:
specifier|final
name|BytesReader
name|in
init|=
operator|new
name|BytesReader
argument_list|(
name|address
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|in
operator|.
name|readByte
argument_list|()
operator|&
name|BIT_ARCS_AS_FIXED_ARRAY
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// Arcs are full array; do binary search:
comment|//System.out.println("findArc: array label=" + labelToMatch);
name|arc
operator|.
name|numArcs
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|arc
operator|.
name|bytesPerArc
operator|=
name|in
operator|.
name|readByte
argument_list|()
operator|&
literal|0xFF
expr_stmt|;
name|arc
operator|.
name|posArcsStart
operator|=
name|in
operator|.
name|pos
expr_stmt|;
name|int
name|low
init|=
literal|0
decl_stmt|;
name|int
name|high
init|=
name|arc
operator|.
name|numArcs
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|in
operator|.
name|pos
operator|=
name|arc
operator|.
name|posArcsStart
operator|-
name|arc
operator|.
name|bytesPerArc
operator|*
name|mid
operator|-
literal|1
expr_stmt|;
name|int
name|midLabel
init|=
name|readLabel
argument_list|(
name|in
argument_list|)
decl_stmt|;
specifier|final
name|int
name|cmp
init|=
name|midLabel
operator|-
name|labelToMatch
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|arc
operator|.
name|arcIdx
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
return|return
name|readNextArc
argument_list|(
name|arc
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|//System.out.println("findArc: scan");
name|readFirstArc
argument_list|(
name|address
argument_list|,
name|arc
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|arc
operator|.
name|label
operator|==
name|labelToMatch
condition|)
block|{
return|return
name|arc
return|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|readNextArc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Looks up the output for this input, or null if the    *  input is not accepted. FST must be    *  INPUT_TYPE.BYTE4. */
DECL|method|get
specifier|public
name|T
name|get
parameter_list|(
name|IntsRef
name|input
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE4
assert|;
if|if
condition|(
name|input
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|getEmptyOutput
argument_list|()
return|;
block|}
comment|// TODO: would be nice not to alloc this on every lookup
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|node
init|=
name|getStartNode
argument_list|()
decl_stmt|;
name|T
name|output
init|=
name|NO_OUTPUT
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|input
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|hasArcs
argument_list|(
name|node
argument_list|)
condition|)
block|{
comment|// hit end of FST before input end
return|return
literal|null
return|;
block|}
if|if
condition|(
name|findArc
argument_list|(
name|node
argument_list|,
name|input
operator|.
name|ints
index|[
name|input
operator|.
name|offset
operator|+
name|i
index|]
argument_list|,
name|arc
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|node
operator|=
name|arc
operator|.
name|target
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
if|if
condition|(
operator|!
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|// hit input's end before end node
return|return
literal|null
return|;
block|}
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
comment|/** Logically casts input to UTF32 ints then looks up the output    *  or null if the input is not accepted.  FST must be    *  INPUT_TYPE.BYTE4.  */
DECL|method|get
specifier|public
name|T
name|get
parameter_list|(
name|char
index|[]
name|input
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE4
assert|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|getEmptyOutput
argument_list|()
return|;
block|}
comment|// TODO: would be nice not to alloc this on every lookup
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|node
init|=
name|getStartNode
argument_list|()
decl_stmt|;
name|int
name|charIdx
init|=
name|offset
decl_stmt|;
specifier|final
name|int
name|charLimit
init|=
name|offset
operator|+
name|length
decl_stmt|;
name|T
name|output
init|=
name|NO_OUTPUT
decl_stmt|;
while|while
condition|(
name|charIdx
operator|<
name|charLimit
condition|)
block|{
if|if
condition|(
operator|!
name|hasArcs
argument_list|(
name|node
argument_list|)
condition|)
block|{
comment|// hit end of FST before input end
return|return
literal|null
return|;
block|}
specifier|final
name|int
name|utf32
init|=
name|Character
operator|.
name|codePointAt
argument_list|(
name|input
argument_list|,
name|charIdx
argument_list|)
decl_stmt|;
name|charIdx
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|utf32
argument_list|)
expr_stmt|;
if|if
condition|(
name|findArc
argument_list|(
name|node
argument_list|,
name|utf32
argument_list|,
name|arc
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|node
operator|=
name|arc
operator|.
name|target
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
if|if
condition|(
operator|!
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|// hit input's end before end node
return|return
literal|null
return|;
block|}
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
comment|/** Logically casts input to UTF32 ints then looks up the output    *  or null if the input is not accepted.  FST must be    *  INPUT_TYPE.BYTE4.  */
DECL|method|get
specifier|public
name|T
name|get
parameter_list|(
name|CharSequence
name|input
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE4
assert|;
specifier|final
name|int
name|len
init|=
name|input
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
name|getEmptyOutput
argument_list|()
return|;
block|}
comment|// TODO: would be nice not to alloc this on every lookup
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|node
init|=
name|getStartNode
argument_list|()
decl_stmt|;
name|int
name|charIdx
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|charLimit
init|=
name|input
operator|.
name|length
argument_list|()
decl_stmt|;
name|T
name|output
init|=
name|NO_OUTPUT
decl_stmt|;
while|while
condition|(
name|charIdx
operator|<
name|charLimit
condition|)
block|{
if|if
condition|(
operator|!
name|hasArcs
argument_list|(
name|node
argument_list|)
condition|)
block|{
comment|// hit end of FST before input end
return|return
literal|null
return|;
block|}
specifier|final
name|int
name|utf32
init|=
name|Character
operator|.
name|codePointAt
argument_list|(
name|input
argument_list|,
name|charIdx
argument_list|)
decl_stmt|;
name|charIdx
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|utf32
argument_list|)
expr_stmt|;
if|if
condition|(
name|findArc
argument_list|(
name|node
argument_list|,
name|utf32
argument_list|,
name|arc
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|node
operator|=
name|arc
operator|.
name|target
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
if|if
condition|(
operator|!
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|// hit input's end before end node
return|return
literal|null
return|;
block|}
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
comment|/** Looks up the output for this input, or null if the    *  input is not accepted */
DECL|method|get
specifier|public
name|T
name|get
parameter_list|(
name|BytesRef
name|input
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|inputType
operator|==
name|INPUT_TYPE
operator|.
name|BYTE1
assert|;
if|if
condition|(
name|input
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|getEmptyOutput
argument_list|()
return|;
block|}
comment|// TODO: would be nice not to alloc this on every lookup
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|node
init|=
name|getStartNode
argument_list|()
decl_stmt|;
name|T
name|output
init|=
name|NO_OUTPUT
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|input
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|hasArcs
argument_list|(
name|node
argument_list|)
condition|)
block|{
comment|// hit end of FST before input end
return|return
literal|null
return|;
block|}
if|if
condition|(
name|findArc
argument_list|(
name|node
argument_list|,
name|input
operator|.
name|bytes
index|[
name|i
operator|+
name|input
operator|.
name|offset
index|]
argument_list|,
name|arc
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|node
operator|=
name|arc
operator|.
name|target
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
if|if
condition|(
operator|!
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
comment|// hit input's end before end node
return|return
literal|null
return|;
block|}
if|if
condition|(
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
comment|/** Returns true if this FST has no nodes */
DECL|method|noNodes
specifier|public
name|boolean
name|noNodes
parameter_list|()
block|{
comment|//System.out.println("isempty startNode=" + startNode);
return|return
name|startNode
operator|==
literal|0
return|;
block|}
DECL|method|seekToNextNode
specifier|private
name|void
name|seekToNextNode
parameter_list|(
name|BytesReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|flags
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
name|readLabel
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_ARC_HAS_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_ARC_HAS_FINAL_OUTPUT
argument_list|)
condition|)
block|{
name|outputs
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_STOP_NODE
argument_list|)
operator|&&
operator|!
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flag
argument_list|(
name|flags
argument_list|,
name|BIT_LAST_ARC
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
comment|// NOTE: this consumes alot of RAM!
comment|// final arcs have a flat end (not arrow)
comment|// arcs w/ NEXT opto are in blue
comment|/*     eg:       PrintStream ps = new PrintStream("out.dot");       fst.toDot(ps);       ps.close();       System.out.println("SAVED out.dot");            then dot -Tpng out.dot> /x/tmp/out.png   */
DECL|method|toDot
specifier|public
name|void
name|toDot
parameter_list|(
name|PrintStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|queue
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|startNode
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|seen
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|seen
operator|.
name|add
argument_list|(
name|startNode
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"digraph FST {"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"  rankdir = LR;"
argument_list|)
expr_stmt|;
comment|//out.println("  " + startNode + " [shape=circle label=" + startNode + "];");
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|startNode
operator|+
literal|" [label=\"\" shape=circle];"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"  initial [shape=point color=white label=\"\"];"
argument_list|)
expr_stmt|;
if|if
condition|(
name|emptyOutput
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"  initial -> "
operator|+
name|startNode
operator|+
literal|" [arrowhead=tee label=\"("
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|emptyOutput
argument_list|)
operator|+
literal|")\"];"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|println
argument_list|(
literal|"  initial -> "
operator|+
name|startNode
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
operator|new
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|queue
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|Integer
name|node
init|=
name|queue
operator|.
name|get
argument_list|(
name|queue
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|queue
operator|.
name|remove
argument_list|(
name|queue
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|FINAL_END_NODE
operator|||
name|node
operator|==
name|NON_FINAL_END_NODE
condition|)
block|{
continue|continue;
block|}
comment|// scan all arcs
name|readFirstArc
argument_list|(
name|node
argument_list|,
name|arc
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|!
name|seen
operator|.
name|contains
argument_list|(
name|arc
operator|.
name|target
argument_list|)
condition|)
block|{
comment|//out.println("  " + arc.target + " [label=" + arc.target + "];");
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|arc
operator|.
name|target
operator|+
literal|" [label=\"\" shape=circle];"
argument_list|)
expr_stmt|;
name|seen
operator|.
name|add
argument_list|(
name|arc
operator|.
name|target
argument_list|)
expr_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|arc
operator|.
name|target
argument_list|)
expr_stmt|;
block|}
name|String
name|outs
decl_stmt|;
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|outs
operator|=
literal|"/"
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outs
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
operator|&&
name|arc
operator|.
name|nextFinalOutput
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|outs
operator|+=
literal|" ("
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|arc
operator|.
name|nextFinalOutput
argument_list|)
operator|+
literal|")"
expr_stmt|;
block|}
name|out
operator|.
name|print
argument_list|(
literal|"  "
operator|+
name|node
operator|+
literal|" -> "
operator|+
name|arc
operator|.
name|target
operator|+
literal|" [label=\""
operator|+
name|arc
operator|.
name|label
operator|+
name|outs
operator|+
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
name|out
operator|.
name|print
argument_list|(
literal|" arrowhead=tee"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|flag
argument_list|(
name|BIT_TARGET_NEXT
argument_list|)
condition|)
block|{
name|out
operator|.
name|print
argument_list|(
literal|" color=blue"
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|println
argument_list|(
literal|"];"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
break|break;
block|}
else|else
block|{
name|readNextArc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|out
operator|.
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
DECL|method|getNodeCount
specifier|public
name|int
name|getNodeCount
parameter_list|()
block|{
comment|// 1+ in order to count the -1 implicit final node
return|return
literal|1
operator|+
name|nodeCount
return|;
block|}
DECL|method|getArcCount
specifier|public
name|int
name|getArcCount
parameter_list|()
block|{
return|return
name|arcCount
return|;
block|}
DECL|method|getArcWithOutputCount
specifier|public
name|int
name|getArcWithOutputCount
parameter_list|()
block|{
return|return
name|arcWithOutputCount
return|;
block|}
comment|// Non-static: writes to FST's byte[]
DECL|class|BytesWriter
specifier|private
class|class
name|BytesWriter
extends|extends
name|DataOutput
block|{
DECL|field|posWrite
name|int
name|posWrite
decl_stmt|;
DECL|method|BytesWriter
specifier|public
name|BytesWriter
parameter_list|()
block|{
comment|// pad: ensure no node gets address 0 which is reserved to mean
comment|// the stop state w/ no arcs
name|posWrite
operator|=
literal|1
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeByte
specifier|public
name|void
name|writeByte
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|.
name|length
operator|==
name|posWrite
condition|)
block|{
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
assert|assert
name|posWrite
operator|<
name|bytes
operator|.
name|length
operator|:
literal|"posWrite="
operator|+
name|posWrite
operator|+
literal|" bytes.length="
operator|+
name|bytes
operator|.
name|length
assert|;
name|bytes
index|[
name|posWrite
operator|++
index|]
operator|=
name|b
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeBytes
specifier|public
name|void
name|writeBytes
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
specifier|final
name|int
name|size
init|=
name|posWrite
operator|+
name|length
decl_stmt|;
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|bytes
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|,
name|posWrite
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|posWrite
operator|+=
name|length
expr_stmt|;
block|}
block|}
comment|// Non-static: reads byte[] from FST
DECL|class|BytesReader
specifier|private
class|class
name|BytesReader
extends|extends
name|DataInput
block|{
DECL|field|pos
name|int
name|pos
decl_stmt|;
DECL|method|BytesReader
specifier|public
name|BytesReader
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|this
operator|.
name|pos
operator|=
name|pos
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|readByte
specifier|public
name|byte
name|readByte
parameter_list|()
block|{
return|return
name|bytes
index|[
name|pos
operator|--
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|readBytes
specifier|public
name|void
name|readBytes
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|b
index|[
name|offset
operator|+
name|i
index|]
operator|=
name|bytes
index|[
name|pos
operator|--
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
end_class
end_unit
