begin_unit
begin_comment
comment|/*  * dk.brics.automaton  *   * Copyright (c) 2001-2009 Anders Moeller  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_package
DECL|package|org.apache.lucene.util.automaton
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_comment
comment|/**  * Basic automata operations.  *   * @lucene.experimental  */
end_comment
begin_class
DECL|class|BasicOperations
specifier|final
specifier|public
class|class
name|BasicOperations
block|{
DECL|method|BasicOperations
specifier|private
name|BasicOperations
parameter_list|()
block|{}
comment|/**    * Returns an automaton that accepts the concatenation of the languages of the    * given automata.    *<p>    * Complexity: linear in number of states.    */
DECL|method|concatenate
specifier|static
specifier|public
name|Automaton
name|concatenate
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
if|if
condition|(
name|a1
operator|.
name|isSingleton
argument_list|()
operator|&&
name|a2
operator|.
name|isSingleton
argument_list|()
condition|)
return|return
name|BasicAutomata
operator|.
name|makeString
argument_list|(
name|a1
operator|.
name|singleton
operator|+
name|a2
operator|.
name|singleton
argument_list|)
return|;
comment|// adding epsilon transitions with the NFA concatenation algorithm
comment|// in this case always produces a resulting DFA, preventing expensive
comment|// redundant determinize() calls for this common case.
name|boolean
name|deterministic
init|=
name|a1
operator|.
name|isSingleton
argument_list|()
operator|&&
name|a2
operator|.
name|isDeterministic
argument_list|()
decl_stmt|;
if|if
condition|(
name|a1
operator|==
name|a2
condition|)
block|{
name|a1
operator|=
name|a1
operator|.
name|cloneExpanded
argument_list|()
expr_stmt|;
name|a2
operator|=
name|a2
operator|.
name|cloneExpanded
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|a1
operator|=
name|a1
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
name|a2
operator|=
name|a2
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|State
name|s
range|:
name|a1
operator|.
name|getAcceptStates
argument_list|()
control|)
block|{
name|s
operator|.
name|accept
operator|=
literal|false
expr_stmt|;
name|s
operator|.
name|addEpsilon
argument_list|(
name|a2
operator|.
name|initial
argument_list|)
expr_stmt|;
block|}
name|a1
operator|.
name|deterministic
operator|=
name|deterministic
expr_stmt|;
name|a1
operator|.
name|clearHashCode
argument_list|()
expr_stmt|;
name|a1
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
return|return
name|a1
return|;
block|}
comment|/**    * Returns an automaton that accepts the concatenation of the languages of the    * given automata.    *<p>    * Complexity: linear in total number of states.    */
DECL|method|concatenate
specifier|static
specifier|public
name|Automaton
name|concatenate
parameter_list|(
name|List
argument_list|<
name|Automaton
argument_list|>
name|l
parameter_list|)
block|{
if|if
condition|(
name|l
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|BasicAutomata
operator|.
name|makeEmptyString
argument_list|()
return|;
name|boolean
name|all_singleton
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Automaton
name|a
range|:
name|l
control|)
if|if
condition|(
operator|!
name|a
operator|.
name|isSingleton
argument_list|()
condition|)
block|{
name|all_singleton
operator|=
literal|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|all_singleton
condition|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Automaton
name|a
range|:
name|l
control|)
name|b
operator|.
name|append
argument_list|(
name|a
operator|.
name|singleton
argument_list|)
expr_stmt|;
return|return
name|BasicAutomata
operator|.
name|makeString
argument_list|(
name|b
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
for|for
control|(
name|Automaton
name|a
range|:
name|l
control|)
if|if
condition|(
name|BasicOperations
operator|.
name|isEmpty
argument_list|(
name|a
argument_list|)
condition|)
return|return
name|BasicAutomata
operator|.
name|makeEmpty
argument_list|()
return|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|ids
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Automaton
name|a
range|:
name|l
control|)
name|ids
operator|.
name|add
argument_list|(
name|System
operator|.
name|identityHashCode
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|has_aliases
init|=
name|ids
operator|.
name|size
argument_list|()
operator|!=
name|l
operator|.
name|size
argument_list|()
decl_stmt|;
name|Automaton
name|b
init|=
name|l
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|has_aliases
condition|)
name|b
operator|=
name|b
operator|.
name|cloneExpanded
argument_list|()
expr_stmt|;
else|else
name|b
operator|=
name|b
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|State
argument_list|>
name|ac
init|=
name|b
operator|.
name|getAcceptStates
argument_list|()
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Automaton
name|a
range|:
name|l
control|)
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
block|{
if|if
condition|(
name|a
operator|.
name|isEmptyString
argument_list|()
condition|)
continue|continue;
name|Automaton
name|aa
init|=
name|a
decl_stmt|;
if|if
condition|(
name|has_aliases
condition|)
name|aa
operator|=
name|aa
operator|.
name|cloneExpanded
argument_list|()
expr_stmt|;
else|else
name|aa
operator|=
name|aa
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|State
argument_list|>
name|ns
init|=
name|aa
operator|.
name|getAcceptStates
argument_list|()
decl_stmt|;
for|for
control|(
name|State
name|s
range|:
name|ac
control|)
block|{
name|s
operator|.
name|accept
operator|=
literal|false
expr_stmt|;
name|s
operator|.
name|addEpsilon
argument_list|(
name|aa
operator|.
name|initial
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|accept
condition|)
name|ns
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|ac
operator|=
name|ns
expr_stmt|;
block|}
name|b
operator|.
name|deterministic
operator|=
literal|false
expr_stmt|;
name|b
operator|.
name|clearHashCode
argument_list|()
expr_stmt|;
name|b
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
return|return
name|b
return|;
block|}
block|}
comment|/**    * Returns an automaton that accepts the union of the empty string and the    * language of the given automaton.    *<p>    * Complexity: linear in number of states.    */
DECL|method|optional
specifier|static
specifier|public
name|Automaton
name|optional
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
name|a
operator|=
name|a
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
name|State
name|s
init|=
operator|new
name|State
argument_list|()
decl_stmt|;
name|s
operator|.
name|addEpsilon
argument_list|(
name|a
operator|.
name|initial
argument_list|)
expr_stmt|;
name|s
operator|.
name|accept
operator|=
literal|true
expr_stmt|;
name|a
operator|.
name|initial
operator|=
name|s
expr_stmt|;
name|a
operator|.
name|deterministic
operator|=
literal|false
expr_stmt|;
name|a
operator|.
name|clearHashCode
argument_list|()
expr_stmt|;
name|a
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/**    * Returns an automaton that accepts the Kleene star (zero or more    * concatenated repetitions) of the language of the given automaton. Never    * modifies the input automaton language.    *<p>    * Complexity: linear in number of states.    */
DECL|method|repeat
specifier|static
specifier|public
name|Automaton
name|repeat
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
name|a
operator|=
name|a
operator|.
name|cloneExpanded
argument_list|()
expr_stmt|;
name|State
name|s
init|=
operator|new
name|State
argument_list|()
decl_stmt|;
name|s
operator|.
name|accept
operator|=
literal|true
expr_stmt|;
name|s
operator|.
name|addEpsilon
argument_list|(
name|a
operator|.
name|initial
argument_list|)
expr_stmt|;
for|for
control|(
name|State
name|p
range|:
name|a
operator|.
name|getAcceptStates
argument_list|()
control|)
name|p
operator|.
name|addEpsilon
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|a
operator|.
name|initial
operator|=
name|s
expr_stmt|;
name|a
operator|.
name|deterministic
operator|=
literal|false
expr_stmt|;
name|a
operator|.
name|clearHashCode
argument_list|()
expr_stmt|;
name|a
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/**    * Returns an automaton that accepts<code>min</code> or more concatenated    * repetitions of the language of the given automaton.    *<p>    * Complexity: linear in number of states and in<code>min</code>.    */
DECL|method|repeat
specifier|static
specifier|public
name|Automaton
name|repeat
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|int
name|min
parameter_list|)
block|{
if|if
condition|(
name|min
operator|==
literal|0
condition|)
return|return
name|repeat
argument_list|(
name|a
argument_list|)
return|;
name|List
argument_list|<
name|Automaton
argument_list|>
name|as
init|=
operator|new
name|ArrayList
argument_list|<
name|Automaton
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|min
operator|--
operator|>
literal|0
condition|)
name|as
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|as
operator|.
name|add
argument_list|(
name|repeat
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|concatenate
argument_list|(
name|as
argument_list|)
return|;
block|}
comment|/**    * Returns an automaton that accepts between<code>min</code> and    *<code>max</code> (including both) concatenated repetitions of the language    * of the given automaton.    *<p>    * Complexity: linear in number of states and in<code>min</code> and    *<code>max</code>.    */
DECL|method|repeat
specifier|static
specifier|public
name|Automaton
name|repeat
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
if|if
condition|(
name|min
operator|>
name|max
condition|)
return|return
name|BasicAutomata
operator|.
name|makeEmpty
argument_list|()
return|;
name|max
operator|-=
name|min
expr_stmt|;
name|a
operator|.
name|expandSingleton
argument_list|()
expr_stmt|;
name|Automaton
name|b
decl_stmt|;
if|if
condition|(
name|min
operator|==
literal|0
condition|)
name|b
operator|=
name|BasicAutomata
operator|.
name|makeEmptyString
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|min
operator|==
literal|1
condition|)
name|b
operator|=
name|a
operator|.
name|clone
argument_list|()
expr_stmt|;
else|else
block|{
name|List
argument_list|<
name|Automaton
argument_list|>
name|as
init|=
operator|new
name|ArrayList
argument_list|<
name|Automaton
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|min
operator|--
operator|>
literal|0
condition|)
name|as
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|concatenate
argument_list|(
name|as
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|>
literal|0
condition|)
block|{
name|Automaton
name|d
init|=
name|a
operator|.
name|clone
argument_list|()
decl_stmt|;
while|while
condition|(
operator|--
name|max
operator|>
literal|0
condition|)
block|{
name|Automaton
name|c
init|=
name|a
operator|.
name|clone
argument_list|()
decl_stmt|;
for|for
control|(
name|State
name|p
range|:
name|c
operator|.
name|getAcceptStates
argument_list|()
control|)
name|p
operator|.
name|addEpsilon
argument_list|(
name|d
operator|.
name|initial
argument_list|)
expr_stmt|;
name|d
operator|=
name|c
expr_stmt|;
block|}
for|for
control|(
name|State
name|p
range|:
name|b
operator|.
name|getAcceptStates
argument_list|()
control|)
name|p
operator|.
name|addEpsilon
argument_list|(
name|d
operator|.
name|initial
argument_list|)
expr_stmt|;
name|b
operator|.
name|deterministic
operator|=
literal|false
expr_stmt|;
name|b
operator|.
name|clearHashCode
argument_list|()
expr_stmt|;
name|b
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
comment|/**    * Returns a (deterministic) automaton that accepts the complement of the    * language of the given automaton.    *<p>    * Complexity: linear in number of states (if already deterministic).    */
DECL|method|complement
specifier|static
specifier|public
name|Automaton
name|complement
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
name|a
operator|=
name|a
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
name|a
operator|.
name|determinize
argument_list|()
expr_stmt|;
name|a
operator|.
name|totalize
argument_list|()
expr_stmt|;
for|for
control|(
name|State
name|p
range|:
name|a
operator|.
name|getStates
argument_list|()
control|)
name|p
operator|.
name|accept
operator|=
operator|!
name|p
operator|.
name|accept
expr_stmt|;
name|a
operator|.
name|removeDeadTransitions
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/**    * Returns a (deterministic) automaton that accepts the intersection of the    * language of<code>a1</code> and the complement of the language of    *<code>a2</code>. As a side-effect, the automata may be determinized, if not    * already deterministic.    *<p>    * Complexity: quadratic in number of states (if already deterministic).    */
DECL|method|minus
specifier|static
specifier|public
name|Automaton
name|minus
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
if|if
condition|(
name|BasicOperations
operator|.
name|isEmpty
argument_list|(
name|a1
argument_list|)
operator|||
name|a1
operator|==
name|a2
condition|)
return|return
name|BasicAutomata
operator|.
name|makeEmpty
argument_list|()
return|;
if|if
condition|(
name|BasicOperations
operator|.
name|isEmpty
argument_list|(
name|a2
argument_list|)
condition|)
return|return
name|a1
operator|.
name|cloneIfRequired
argument_list|()
return|;
if|if
condition|(
name|a1
operator|.
name|isSingleton
argument_list|()
condition|)
block|{
if|if
condition|(
name|BasicOperations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
name|a1
operator|.
name|singleton
argument_list|)
condition|)
return|return
name|BasicAutomata
operator|.
name|makeEmpty
argument_list|()
return|;
else|else
return|return
name|a1
operator|.
name|cloneIfRequired
argument_list|()
return|;
block|}
return|return
name|intersection
argument_list|(
name|a1
argument_list|,
name|a2
operator|.
name|complement
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns an automaton that accepts the intersection of the languages of the    * given automata. Never modifies the input automata languages.    *<p>    * Complexity: quadratic in number of states.    */
DECL|method|intersection
specifier|static
specifier|public
name|Automaton
name|intersection
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
if|if
condition|(
name|a1
operator|.
name|isSingleton
argument_list|()
condition|)
block|{
if|if
condition|(
name|BasicOperations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
name|a1
operator|.
name|singleton
argument_list|)
condition|)
return|return
name|a1
operator|.
name|cloneIfRequired
argument_list|()
return|;
else|else
return|return
name|BasicAutomata
operator|.
name|makeEmpty
argument_list|()
return|;
block|}
if|if
condition|(
name|a2
operator|.
name|isSingleton
argument_list|()
condition|)
block|{
if|if
condition|(
name|BasicOperations
operator|.
name|run
argument_list|(
name|a1
argument_list|,
name|a2
operator|.
name|singleton
argument_list|)
condition|)
return|return
name|a2
operator|.
name|cloneIfRequired
argument_list|()
return|;
else|else
return|return
name|BasicAutomata
operator|.
name|makeEmpty
argument_list|()
return|;
block|}
if|if
condition|(
name|a1
operator|==
name|a2
condition|)
return|return
name|a1
operator|.
name|cloneIfRequired
argument_list|()
return|;
name|Transition
index|[]
index|[]
name|transitions1
init|=
name|Automaton
operator|.
name|getSortedTransitions
argument_list|(
name|a1
operator|.
name|getStates
argument_list|()
argument_list|)
decl_stmt|;
name|Transition
index|[]
index|[]
name|transitions2
init|=
name|Automaton
operator|.
name|getSortedTransitions
argument_list|(
name|a2
operator|.
name|getStates
argument_list|()
argument_list|)
decl_stmt|;
name|Automaton
name|c
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|LinkedList
argument_list|<
name|StatePair
argument_list|>
name|worklist
init|=
operator|new
name|LinkedList
argument_list|<
name|StatePair
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|StatePair
argument_list|,
name|StatePair
argument_list|>
name|newstates
init|=
operator|new
name|HashMap
argument_list|<
name|StatePair
argument_list|,
name|StatePair
argument_list|>
argument_list|()
decl_stmt|;
name|StatePair
name|p
init|=
operator|new
name|StatePair
argument_list|(
name|c
operator|.
name|initial
argument_list|,
name|a1
operator|.
name|initial
argument_list|,
name|a2
operator|.
name|initial
argument_list|)
decl_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|newstates
operator|.
name|put
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|worklist
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|worklist
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|p
operator|.
name|s
operator|.
name|accept
operator|=
name|p
operator|.
name|s1
operator|.
name|accept
operator|&&
name|p
operator|.
name|s2
operator|.
name|accept
expr_stmt|;
name|Transition
index|[]
name|t1
init|=
name|transitions1
index|[
name|p
operator|.
name|s1
operator|.
name|number
index|]
decl_stmt|;
name|Transition
index|[]
name|t2
init|=
name|transitions2
index|[
name|p
operator|.
name|s2
operator|.
name|number
index|]
decl_stmt|;
for|for
control|(
name|int
name|n1
init|=
literal|0
init|,
name|b2
init|=
literal|0
init|;
name|n1
operator|<
name|t1
operator|.
name|length
condition|;
name|n1
operator|++
control|)
block|{
while|while
condition|(
name|b2
operator|<
name|t2
operator|.
name|length
operator|&&
name|t2
index|[
name|b2
index|]
operator|.
name|max
operator|<
name|t1
index|[
name|n1
index|]
operator|.
name|min
condition|)
name|b2
operator|++
expr_stmt|;
for|for
control|(
name|int
name|n2
init|=
name|b2
init|;
name|n2
operator|<
name|t2
operator|.
name|length
operator|&&
name|t1
index|[
name|n1
index|]
operator|.
name|max
operator|>=
name|t2
index|[
name|n2
index|]
operator|.
name|min
condition|;
name|n2
operator|++
control|)
if|if
condition|(
name|t2
index|[
name|n2
index|]
operator|.
name|max
operator|>=
name|t1
index|[
name|n1
index|]
operator|.
name|min
condition|)
block|{
name|StatePair
name|q
init|=
operator|new
name|StatePair
argument_list|(
name|t1
index|[
name|n1
index|]
operator|.
name|to
argument_list|,
name|t2
index|[
name|n2
index|]
operator|.
name|to
argument_list|)
decl_stmt|;
name|StatePair
name|r
init|=
name|newstates
operator|.
name|get
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
name|q
operator|.
name|s
operator|=
operator|new
name|State
argument_list|()
expr_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|newstates
operator|.
name|put
argument_list|(
name|q
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|r
operator|=
name|q
expr_stmt|;
block|}
name|char
name|min
init|=
name|t1
index|[
name|n1
index|]
operator|.
name|min
operator|>
name|t2
index|[
name|n2
index|]
operator|.
name|min
condition|?
name|t1
index|[
name|n1
index|]
operator|.
name|min
else|:
name|t2
index|[
name|n2
index|]
operator|.
name|min
decl_stmt|;
name|char
name|max
init|=
name|t1
index|[
name|n1
index|]
operator|.
name|max
operator|<
name|t2
index|[
name|n2
index|]
operator|.
name|max
condition|?
name|t1
index|[
name|n1
index|]
operator|.
name|max
else|:
name|t2
index|[
name|n2
index|]
operator|.
name|max
decl_stmt|;
name|p
operator|.
name|s
operator|.
name|transitions
operator|.
name|add
argument_list|(
operator|new
name|Transition
argument_list|(
name|min
argument_list|,
name|max
argument_list|,
name|r
operator|.
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|c
operator|.
name|deterministic
operator|=
name|a1
operator|.
name|deterministic
operator|&&
name|a2
operator|.
name|deterministic
expr_stmt|;
name|c
operator|.
name|removeDeadTransitions
argument_list|()
expr_stmt|;
name|c
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/**    * Returns true if the language of<code>a1</code> is a subset of the language    * of<code>a2</code>. As a side-effect,<code>a2</code> is determinized if    * not already marked as deterministic.    *<p>    * Complexity: quadratic in number of states.    */
DECL|method|subsetOf
specifier|public
specifier|static
name|boolean
name|subsetOf
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
if|if
condition|(
name|a1
operator|==
name|a2
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|a1
operator|.
name|isSingleton
argument_list|()
condition|)
block|{
if|if
condition|(
name|a2
operator|.
name|isSingleton
argument_list|()
condition|)
return|return
name|a1
operator|.
name|singleton
operator|.
name|equals
argument_list|(
name|a2
operator|.
name|singleton
argument_list|)
return|;
return|return
name|BasicOperations
operator|.
name|run
argument_list|(
name|a2
argument_list|,
name|a1
operator|.
name|singleton
argument_list|)
return|;
block|}
name|a2
operator|.
name|determinize
argument_list|()
expr_stmt|;
name|Transition
index|[]
index|[]
name|transitions1
init|=
name|Automaton
operator|.
name|getSortedTransitions
argument_list|(
name|a1
operator|.
name|getStates
argument_list|()
argument_list|)
decl_stmt|;
name|Transition
index|[]
index|[]
name|transitions2
init|=
name|Automaton
operator|.
name|getSortedTransitions
argument_list|(
name|a2
operator|.
name|getStates
argument_list|()
argument_list|)
decl_stmt|;
name|LinkedList
argument_list|<
name|StatePair
argument_list|>
name|worklist
init|=
operator|new
name|LinkedList
argument_list|<
name|StatePair
argument_list|>
argument_list|()
decl_stmt|;
name|HashSet
argument_list|<
name|StatePair
argument_list|>
name|visited
init|=
operator|new
name|HashSet
argument_list|<
name|StatePair
argument_list|>
argument_list|()
decl_stmt|;
name|StatePair
name|p
init|=
operator|new
name|StatePair
argument_list|(
name|a1
operator|.
name|initial
argument_list|,
name|a2
operator|.
name|initial
argument_list|)
decl_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|visited
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|worklist
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|worklist
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|s1
operator|.
name|accept
operator|&&
operator|!
name|p
operator|.
name|s2
operator|.
name|accept
condition|)
return|return
literal|false
return|;
name|Transition
index|[]
name|t1
init|=
name|transitions1
index|[
name|p
operator|.
name|s1
operator|.
name|number
index|]
decl_stmt|;
name|Transition
index|[]
name|t2
init|=
name|transitions2
index|[
name|p
operator|.
name|s2
operator|.
name|number
index|]
decl_stmt|;
for|for
control|(
name|int
name|n1
init|=
literal|0
init|,
name|b2
init|=
literal|0
init|;
name|n1
operator|<
name|t1
operator|.
name|length
condition|;
name|n1
operator|++
control|)
block|{
while|while
condition|(
name|b2
operator|<
name|t2
operator|.
name|length
operator|&&
name|t2
index|[
name|b2
index|]
operator|.
name|max
operator|<
name|t1
index|[
name|n1
index|]
operator|.
name|min
condition|)
name|b2
operator|++
expr_stmt|;
name|int
name|min1
init|=
name|t1
index|[
name|n1
index|]
operator|.
name|min
decl_stmt|,
name|max1
init|=
name|t1
index|[
name|n1
index|]
operator|.
name|max
decl_stmt|;
for|for
control|(
name|int
name|n2
init|=
name|b2
init|;
name|n2
operator|<
name|t2
operator|.
name|length
operator|&&
name|t1
index|[
name|n1
index|]
operator|.
name|max
operator|>=
name|t2
index|[
name|n2
index|]
operator|.
name|min
condition|;
name|n2
operator|++
control|)
block|{
if|if
condition|(
name|t2
index|[
name|n2
index|]
operator|.
name|min
operator|>
name|min1
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|t2
index|[
name|n2
index|]
operator|.
name|max
operator|<
name|Character
operator|.
name|MAX_VALUE
condition|)
name|min1
operator|=
name|t2
index|[
name|n2
index|]
operator|.
name|max
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|min1
operator|=
name|Character
operator|.
name|MAX_VALUE
expr_stmt|;
name|max1
operator|=
name|Character
operator|.
name|MIN_VALUE
expr_stmt|;
block|}
name|StatePair
name|q
init|=
operator|new
name|StatePair
argument_list|(
name|t1
index|[
name|n1
index|]
operator|.
name|to
argument_list|,
name|t2
index|[
name|n2
index|]
operator|.
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|visited
operator|.
name|contains
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|worklist
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|visited
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|min1
operator|<=
name|max1
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns an automaton that accepts the union of the languages of the given    * automata.    *<p>    * Complexity: linear in number of states.    */
DECL|method|union
specifier|public
specifier|static
name|Automaton
name|union
parameter_list|(
name|Automaton
name|a1
parameter_list|,
name|Automaton
name|a2
parameter_list|)
block|{
if|if
condition|(
operator|(
name|a1
operator|.
name|isSingleton
argument_list|()
operator|&&
name|a2
operator|.
name|isSingleton
argument_list|()
operator|&&
name|a1
operator|.
name|singleton
operator|.
name|equals
argument_list|(
name|a2
operator|.
name|singleton
argument_list|)
operator|)
operator|||
name|a1
operator|==
name|a2
condition|)
return|return
name|a1
operator|.
name|cloneIfRequired
argument_list|()
return|;
if|if
condition|(
name|a1
operator|==
name|a2
condition|)
block|{
name|a1
operator|=
name|a1
operator|.
name|cloneExpanded
argument_list|()
expr_stmt|;
name|a2
operator|=
name|a2
operator|.
name|cloneExpanded
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|a1
operator|=
name|a1
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
name|a2
operator|=
name|a2
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
block|}
name|State
name|s
init|=
operator|new
name|State
argument_list|()
decl_stmt|;
name|s
operator|.
name|addEpsilon
argument_list|(
name|a1
operator|.
name|initial
argument_list|)
expr_stmt|;
name|s
operator|.
name|addEpsilon
argument_list|(
name|a2
operator|.
name|initial
argument_list|)
expr_stmt|;
name|a1
operator|.
name|initial
operator|=
name|s
expr_stmt|;
name|a1
operator|.
name|deterministic
operator|=
literal|false
expr_stmt|;
name|a1
operator|.
name|clearHashCode
argument_list|()
expr_stmt|;
name|a1
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
return|return
name|a1
return|;
block|}
comment|/**    * Returns an automaton that accepts the union of the languages of the given    * automata.    *<p>    * Complexity: linear in number of states.    */
DECL|method|union
specifier|public
specifier|static
name|Automaton
name|union
parameter_list|(
name|Collection
argument_list|<
name|Automaton
argument_list|>
name|l
parameter_list|)
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|ids
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Automaton
name|a
range|:
name|l
control|)
name|ids
operator|.
name|add
argument_list|(
name|System
operator|.
name|identityHashCode
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|has_aliases
init|=
name|ids
operator|.
name|size
argument_list|()
operator|!=
name|l
operator|.
name|size
argument_list|()
decl_stmt|;
name|State
name|s
init|=
operator|new
name|State
argument_list|()
decl_stmt|;
for|for
control|(
name|Automaton
name|b
range|:
name|l
control|)
block|{
if|if
condition|(
name|BasicOperations
operator|.
name|isEmpty
argument_list|(
name|b
argument_list|)
condition|)
continue|continue;
name|Automaton
name|bb
init|=
name|b
decl_stmt|;
if|if
condition|(
name|has_aliases
condition|)
name|bb
operator|=
name|bb
operator|.
name|cloneExpanded
argument_list|()
expr_stmt|;
else|else
name|bb
operator|=
name|bb
operator|.
name|cloneExpandedIfRequired
argument_list|()
expr_stmt|;
name|s
operator|.
name|addEpsilon
argument_list|(
name|bb
operator|.
name|initial
argument_list|)
expr_stmt|;
block|}
name|Automaton
name|a
init|=
operator|new
name|Automaton
argument_list|()
decl_stmt|;
name|a
operator|.
name|initial
operator|=
name|s
expr_stmt|;
name|a
operator|.
name|deterministic
operator|=
literal|false
expr_stmt|;
name|a
operator|.
name|clearHashCode
argument_list|()
expr_stmt|;
name|a
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/**    * Determinizes the given automaton.    *<p>    * Complexity: exponential in number of states.    */
DECL|method|determinize
specifier|public
specifier|static
name|void
name|determinize
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|deterministic
operator|||
name|a
operator|.
name|isSingleton
argument_list|()
condition|)
return|return;
name|Set
argument_list|<
name|State
argument_list|>
name|initialset
init|=
operator|new
name|HashSet
argument_list|<
name|State
argument_list|>
argument_list|()
decl_stmt|;
name|initialset
operator|.
name|add
argument_list|(
name|a
operator|.
name|initial
argument_list|)
expr_stmt|;
name|determinize
argument_list|(
name|a
argument_list|,
name|initialset
argument_list|)
expr_stmt|;
block|}
comment|/**    * Determinizes the given automaton using the given set of initial states.    */
DECL|method|determinize
specifier|static
name|void
name|determinize
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|Set
argument_list|<
name|State
argument_list|>
name|initialset
parameter_list|)
block|{
name|char
index|[]
name|points
init|=
name|a
operator|.
name|getStartPoints
argument_list|()
decl_stmt|;
comment|// subset construction
name|Map
argument_list|<
name|Set
argument_list|<
name|State
argument_list|>
argument_list|,
name|Set
argument_list|<
name|State
argument_list|>
argument_list|>
name|sets
init|=
operator|new
name|HashMap
argument_list|<
name|Set
argument_list|<
name|State
argument_list|>
argument_list|,
name|Set
argument_list|<
name|State
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|LinkedList
argument_list|<
name|Set
argument_list|<
name|State
argument_list|>
argument_list|>
name|worklist
init|=
operator|new
name|LinkedList
argument_list|<
name|Set
argument_list|<
name|State
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Set
argument_list|<
name|State
argument_list|>
argument_list|,
name|State
argument_list|>
name|newstate
init|=
operator|new
name|HashMap
argument_list|<
name|Set
argument_list|<
name|State
argument_list|>
argument_list|,
name|State
argument_list|>
argument_list|()
decl_stmt|;
name|sets
operator|.
name|put
argument_list|(
name|initialset
argument_list|,
name|initialset
argument_list|)
expr_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|initialset
argument_list|)
expr_stmt|;
name|a
operator|.
name|initial
operator|=
operator|new
name|State
argument_list|()
expr_stmt|;
name|newstate
operator|.
name|put
argument_list|(
name|initialset
argument_list|,
name|a
operator|.
name|initial
argument_list|)
expr_stmt|;
while|while
condition|(
name|worklist
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Set
argument_list|<
name|State
argument_list|>
name|s
init|=
name|worklist
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
name|State
name|r
init|=
name|newstate
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
for|for
control|(
name|State
name|q
range|:
name|s
control|)
if|if
condition|(
name|q
operator|.
name|accept
condition|)
block|{
name|r
operator|.
name|accept
operator|=
literal|true
expr_stmt|;
break|break;
block|}
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
name|points
operator|.
name|length
condition|;
name|n
operator|++
control|)
block|{
name|Set
argument_list|<
name|State
argument_list|>
name|p
init|=
operator|new
name|HashSet
argument_list|<
name|State
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|State
name|q
range|:
name|s
control|)
for|for
control|(
name|Transition
name|t
range|:
name|q
operator|.
name|transitions
control|)
if|if
condition|(
name|t
operator|.
name|min
operator|<=
name|points
index|[
name|n
index|]
operator|&&
name|points
index|[
name|n
index|]
operator|<=
name|t
operator|.
name|max
condition|)
name|p
operator|.
name|add
argument_list|(
name|t
operator|.
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sets
operator|.
name|containsKey
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|sets
operator|.
name|put
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|newstate
operator|.
name|put
argument_list|(
name|p
argument_list|,
operator|new
name|State
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|State
name|q
init|=
name|newstate
operator|.
name|get
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|char
name|min
init|=
name|points
index|[
name|n
index|]
decl_stmt|;
name|char
name|max
decl_stmt|;
if|if
condition|(
name|n
operator|+
literal|1
operator|<
name|points
operator|.
name|length
condition|)
name|max
operator|=
call|(
name|char
call|)
argument_list|(
name|points
index|[
name|n
operator|+
literal|1
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|max
operator|=
name|Character
operator|.
name|MAX_VALUE
expr_stmt|;
name|r
operator|.
name|transitions
operator|.
name|add
argument_list|(
operator|new
name|Transition
argument_list|(
name|min
argument_list|,
name|max
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|a
operator|.
name|deterministic
operator|=
literal|true
expr_stmt|;
name|a
operator|.
name|removeDeadTransitions
argument_list|()
expr_stmt|;
block|}
comment|/**    * Adds epsilon transitions to the given automaton. This method adds extra    * character interval transitions that are equivalent to the given set of    * epsilon transitions.    *     * @param pairs collection of {@link StatePair} objects representing pairs of    *          source/destination states where epsilon transitions should be    *          added    */
DECL|method|addEpsilons
specifier|public
specifier|static
name|void
name|addEpsilons
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|Collection
argument_list|<
name|StatePair
argument_list|>
name|pairs
parameter_list|)
block|{
name|a
operator|.
name|expandSingleton
argument_list|()
expr_stmt|;
name|HashMap
argument_list|<
name|State
argument_list|,
name|HashSet
argument_list|<
name|State
argument_list|>
argument_list|>
name|forward
init|=
operator|new
name|HashMap
argument_list|<
name|State
argument_list|,
name|HashSet
argument_list|<
name|State
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|State
argument_list|,
name|HashSet
argument_list|<
name|State
argument_list|>
argument_list|>
name|back
init|=
operator|new
name|HashMap
argument_list|<
name|State
argument_list|,
name|HashSet
argument_list|<
name|State
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|StatePair
name|p
range|:
name|pairs
control|)
block|{
name|HashSet
argument_list|<
name|State
argument_list|>
name|to
init|=
name|forward
operator|.
name|get
argument_list|(
name|p
operator|.
name|s1
argument_list|)
decl_stmt|;
if|if
condition|(
name|to
operator|==
literal|null
condition|)
block|{
name|to
operator|=
operator|new
name|HashSet
argument_list|<
name|State
argument_list|>
argument_list|()
expr_stmt|;
name|forward
operator|.
name|put
argument_list|(
name|p
operator|.
name|s1
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
name|to
operator|.
name|add
argument_list|(
name|p
operator|.
name|s2
argument_list|)
expr_stmt|;
name|HashSet
argument_list|<
name|State
argument_list|>
name|from
init|=
name|back
operator|.
name|get
argument_list|(
name|p
operator|.
name|s2
argument_list|)
decl_stmt|;
if|if
condition|(
name|from
operator|==
literal|null
condition|)
block|{
name|from
operator|=
operator|new
name|HashSet
argument_list|<
name|State
argument_list|>
argument_list|()
expr_stmt|;
name|back
operator|.
name|put
argument_list|(
name|p
operator|.
name|s2
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
name|from
operator|.
name|add
argument_list|(
name|p
operator|.
name|s1
argument_list|)
expr_stmt|;
block|}
comment|// calculate epsilon closure
name|LinkedList
argument_list|<
name|StatePair
argument_list|>
name|worklist
init|=
operator|new
name|LinkedList
argument_list|<
name|StatePair
argument_list|>
argument_list|(
name|pairs
argument_list|)
decl_stmt|;
name|HashSet
argument_list|<
name|StatePair
argument_list|>
name|workset
init|=
operator|new
name|HashSet
argument_list|<
name|StatePair
argument_list|>
argument_list|(
name|pairs
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|worklist
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|StatePair
name|p
init|=
name|worklist
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
name|workset
operator|.
name|remove
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|HashSet
argument_list|<
name|State
argument_list|>
name|to
init|=
name|forward
operator|.
name|get
argument_list|(
name|p
operator|.
name|s2
argument_list|)
decl_stmt|;
name|HashSet
argument_list|<
name|State
argument_list|>
name|from
init|=
name|back
operator|.
name|get
argument_list|(
name|p
operator|.
name|s1
argument_list|)
decl_stmt|;
if|if
condition|(
name|to
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|State
name|s
range|:
name|to
control|)
block|{
name|StatePair
name|pp
init|=
operator|new
name|StatePair
argument_list|(
name|p
operator|.
name|s1
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pairs
operator|.
name|contains
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|pairs
operator|.
name|add
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|forward
operator|.
name|get
argument_list|(
name|p
operator|.
name|s1
argument_list|)
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|back
operator|.
name|get
argument_list|(
name|s
argument_list|)
operator|.
name|add
argument_list|(
name|p
operator|.
name|s1
argument_list|)
expr_stmt|;
name|worklist
operator|.
name|add
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|workset
operator|.
name|add
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|State
name|q
range|:
name|from
control|)
block|{
name|StatePair
name|qq
init|=
operator|new
name|StatePair
argument_list|(
name|q
argument_list|,
name|p
operator|.
name|s1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|workset
operator|.
name|contains
argument_list|(
name|qq
argument_list|)
condition|)
block|{
name|worklist
operator|.
name|add
argument_list|(
name|qq
argument_list|)
expr_stmt|;
name|workset
operator|.
name|add
argument_list|(
name|qq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|// add transitions
for|for
control|(
name|StatePair
name|p
range|:
name|pairs
control|)
name|p
operator|.
name|s1
operator|.
name|addEpsilon
argument_list|(
name|p
operator|.
name|s2
argument_list|)
expr_stmt|;
name|a
operator|.
name|deterministic
operator|=
literal|false
expr_stmt|;
name|a
operator|.
name|clearHashCode
argument_list|()
expr_stmt|;
name|a
operator|.
name|checkMinimizeAlways
argument_list|()
expr_stmt|;
block|}
comment|/**    * Returns true if the given automaton accepts the empty string and nothing    * else.    */
DECL|method|isEmptyString
specifier|public
specifier|static
name|boolean
name|isEmptyString
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|isSingleton
argument_list|()
condition|)
return|return
name|a
operator|.
name|singleton
operator|.
name|length
argument_list|()
operator|==
literal|0
return|;
else|else
return|return
name|a
operator|.
name|initial
operator|.
name|accept
operator|&&
name|a
operator|.
name|initial
operator|.
name|transitions
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**    * Returns true if the given automaton accepts no strings.    */
DECL|method|isEmpty
specifier|public
specifier|static
name|boolean
name|isEmpty
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|isSingleton
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
operator|!
name|a
operator|.
name|initial
operator|.
name|accept
operator|&&
name|a
operator|.
name|initial
operator|.
name|transitions
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**    * Returns true if the given automaton accepts all strings.    */
DECL|method|isTotal
specifier|public
specifier|static
name|boolean
name|isTotal
parameter_list|(
name|Automaton
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|isSingleton
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|a
operator|.
name|initial
operator|.
name|accept
operator|&&
name|a
operator|.
name|initial
operator|.
name|transitions
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|Transition
name|t
init|=
name|a
operator|.
name|initial
operator|.
name|transitions
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
name|t
operator|.
name|to
operator|==
name|a
operator|.
name|initial
operator|&&
name|t
operator|.
name|min
operator|==
name|Character
operator|.
name|MIN_VALUE
operator|&&
name|t
operator|.
name|max
operator|==
name|Character
operator|.
name|MAX_VALUE
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns true if the given string is accepted by the automaton.    *<p>    * Complexity: linear in the length of the string.    *<p>    *<b>Note:</b> for full performance, use the {@link RunAutomaton} class.    */
DECL|method|run
specifier|public
specifier|static
name|boolean
name|run
parameter_list|(
name|Automaton
name|a
parameter_list|,
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|isSingleton
argument_list|()
condition|)
return|return
name|s
operator|.
name|equals
argument_list|(
name|a
operator|.
name|singleton
argument_list|)
return|;
if|if
condition|(
name|a
operator|.
name|deterministic
condition|)
block|{
name|State
name|p
init|=
name|a
operator|.
name|initial
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|State
name|q
init|=
name|p
operator|.
name|step
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|p
operator|=
name|q
expr_stmt|;
block|}
return|return
name|p
operator|.
name|accept
return|;
block|}
else|else
block|{
name|Set
argument_list|<
name|State
argument_list|>
name|states
init|=
name|a
operator|.
name|getStates
argument_list|()
decl_stmt|;
name|Automaton
operator|.
name|setStateNumbers
argument_list|(
name|states
argument_list|)
expr_stmt|;
name|LinkedList
argument_list|<
name|State
argument_list|>
name|pp
init|=
operator|new
name|LinkedList
argument_list|<
name|State
argument_list|>
argument_list|()
decl_stmt|;
name|LinkedList
argument_list|<
name|State
argument_list|>
name|pp_other
init|=
operator|new
name|LinkedList
argument_list|<
name|State
argument_list|>
argument_list|()
decl_stmt|;
name|BitSet
name|bb
init|=
operator|new
name|BitSet
argument_list|(
name|states
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|BitSet
name|bb_other
init|=
operator|new
name|BitSet
argument_list|(
name|states
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|pp
operator|.
name|add
argument_list|(
name|a
operator|.
name|initial
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|State
argument_list|>
name|dest
init|=
operator|new
name|ArrayList
argument_list|<
name|State
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|accept
init|=
name|a
operator|.
name|initial
operator|.
name|accept
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|accept
operator|=
literal|false
expr_stmt|;
name|pp_other
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bb_other
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|State
name|p
range|:
name|pp
control|)
block|{
name|dest
operator|.
name|clear
argument_list|()
expr_stmt|;
name|p
operator|.
name|step
argument_list|(
name|c
argument_list|,
name|dest
argument_list|)
expr_stmt|;
for|for
control|(
name|State
name|q
range|:
name|dest
control|)
block|{
if|if
condition|(
name|q
operator|.
name|accept
condition|)
name|accept
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|bb_other
operator|.
name|get
argument_list|(
name|q
operator|.
name|number
argument_list|)
condition|)
block|{
name|bb_other
operator|.
name|set
argument_list|(
name|q
operator|.
name|number
argument_list|)
expr_stmt|;
name|pp_other
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|LinkedList
argument_list|<
name|State
argument_list|>
name|tp
init|=
name|pp
decl_stmt|;
name|pp
operator|=
name|pp_other
expr_stmt|;
name|pp_other
operator|=
name|tp
expr_stmt|;
name|BitSet
name|tb
init|=
name|bb
decl_stmt|;
name|bb
operator|=
name|bb_other
expr_stmt|;
name|bb_other
operator|=
name|tb
expr_stmt|;
block|}
return|return
name|accept
return|;
block|}
block|}
block|}
end_class
end_unit
