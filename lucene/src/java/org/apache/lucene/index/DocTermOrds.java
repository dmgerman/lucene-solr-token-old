begin_unit
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PagedBytes
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_comment
comment|/**  * This class enables fast access to multiple term ords for  * a specified field across all docIDs.  *  * Like FieldCache, it uninverts the index and holds a  * packed data structure in RAM to enable fast access.  * Unlike FieldCache, it can handle multi-valued fields,  * and, it does not hold the term bytes in RAM.  Rather, you  * must obtain a TermsEnum from the {@link #getOrdTermsEnum}  * method, and then seek-by-ord to get the term's bytes.  *  * While normally term ords are type long, in this API they are  * int as the internal representation here cannot address  * more than MAX_INT unique terms.  Also, typically this  * class is used on fields with relatively few unique terms  * vs the number of documents.  In addition, there is an  * internal limit (16 MB) on how many bytes each chunk of  * documents may consume.  If you trip this limit you'll hit  * an IllegalStateException.  *  * Deleted documents are skipped during uninversion, and if  * you look them up you'll get 0 ords.  *  * The returned per-document ords do not retain their  * original order in the document.  Instead they are returned  * in sorted (by ord, ie term's BytesRef comparator) order.  They  * are also de-dup'd (ie if doc has same term more than once  * in this field, you'll only get that ord back once).  *  * This class tests whether the provided reader is able to  * retrieve terms by ord (ie, it's single segment, and it  * uses an ord-capable terms index).  If not, this class  * will create its own term index internally, allowing to  * create a wrapped TermsEnum that can handle ord.  The  * {@link #getOrdTermsEnum} method then provides this  * wrapped enum, if necessary.  *  * The RAM consumption of this class can be high!  *  * @lucene.experimental  */
end_comment
begin_comment
comment|/*  * Final form of the un-inverted field:  *   Each document points to a list of term numbers that are contained in that document.  *  *   Term numbers are in sorted order, and are encoded as variable-length deltas from the  *   previous term number.  Real term numbers start at 2 since 0 and 1 are reserved.  A  *   term number of 0 signals the end of the termNumber list.  *  *   There is a single int[maxDoc()] which either contains a pointer into a byte[] for  *   the termNumber lists, or directly contains the termNumber list if it fits in the 4  *   bytes of an integer.  If the first byte in the integer is 1, the next 3 bytes  *   are a pointer into a byte[] where the termNumber list starts.  *  *   There are actually 256 byte arrays, to compensate for the fact that the pointers  *   into the byte arrays are only 3 bytes long.  The correct byte array for a document  *   is a function of it's id.  *  *   To save space and speed up faceting, any term that matches enough documents will  *   not be un-inverted... it will be skipped while building the un-inverted field structure,  *   and will use a set intersection method during faceting.  *  *   To further save memory, the terms (the actual string values) are not all stored in  *   memory, but a TermIndex is used to convert term numbers to term values only  *   for the terms needed after faceting has completed.  Only every 128th term value  *   is stored, along with it's corresponding term number, and this is used as an  *   index to find the closest term and iterate until the desired number is hit (very  *   much like Lucene's own internal term index).  *  */
end_comment
begin_class
DECL|class|DocTermOrds
specifier|public
class|class
name|DocTermOrds
block|{
comment|// Term ords are shifted by this, internally, to reserve
comment|// values 0 (end term) and 1 (index is a pointer into byte array)
DECL|field|TNUM_OFFSET
specifier|private
specifier|final
specifier|static
name|int
name|TNUM_OFFSET
init|=
literal|2
decl_stmt|;
comment|// Default: every 128th term is indexed
DECL|field|DEFAULT_INDEX_INTERVAL_BITS
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_INDEX_INTERVAL_BITS
init|=
literal|7
decl_stmt|;
comment|// decrease to a low number like 2 for testing
DECL|field|indexIntervalBits
specifier|private
name|int
name|indexIntervalBits
decl_stmt|;
DECL|field|indexIntervalMask
specifier|private
name|int
name|indexIntervalMask
decl_stmt|;
DECL|field|indexInterval
specifier|private
name|int
name|indexInterval
decl_stmt|;
DECL|field|maxTermDocFreq
specifier|protected
specifier|final
name|int
name|maxTermDocFreq
decl_stmt|;
DECL|field|field
specifier|protected
specifier|final
name|String
name|field
decl_stmt|;
DECL|field|numTermsInField
specifier|protected
name|int
name|numTermsInField
decl_stmt|;
DECL|field|termInstances
specifier|protected
name|long
name|termInstances
decl_stmt|;
comment|// total number of references to term numbers
DECL|field|memsz
specifier|private
name|long
name|memsz
decl_stmt|;
DECL|field|total_time
specifier|protected
name|int
name|total_time
decl_stmt|;
comment|// total time to uninvert the field
DECL|field|phase1_time
specifier|protected
name|int
name|phase1_time
decl_stmt|;
comment|// time for phase1 of the uninvert process
DECL|field|index
specifier|protected
name|int
index|[]
name|index
decl_stmt|;
DECL|field|tnums
specifier|protected
name|byte
index|[]
index|[]
name|tnums
init|=
operator|new
name|byte
index|[
literal|256
index|]
index|[]
decl_stmt|;
DECL|field|sizeOfIndexedStrings
specifier|protected
name|long
name|sizeOfIndexedStrings
decl_stmt|;
DECL|field|indexedTermsArray
specifier|protected
name|BytesRef
index|[]
name|indexedTermsArray
decl_stmt|;
DECL|field|prefix
specifier|protected
name|BytesRef
name|prefix
decl_stmt|;
DECL|field|ordBase
specifier|protected
name|int
name|ordBase
decl_stmt|;
DECL|field|docsEnum
specifier|protected
name|DocsEnum
name|docsEnum
decl_stmt|;
comment|//used while uninverting
DECL|method|ramUsedInBytes
specifier|public
name|long
name|ramUsedInBytes
parameter_list|()
block|{
comment|// can cache the mem size since it shouldn't change
if|if
condition|(
name|memsz
operator|!=
literal|0
condition|)
return|return
name|memsz
return|;
name|long
name|sz
init|=
literal|8
operator|*
literal|8
operator|+
literal|32
decl_stmt|;
comment|// local fields
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
name|sz
operator|+=
name|index
operator|.
name|length
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|tnums
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|byte
index|[]
name|arr
range|:
name|tnums
control|)
if|if
condition|(
name|arr
operator|!=
literal|null
condition|)
name|sz
operator|+=
name|arr
operator|.
name|length
expr_stmt|;
block|}
name|memsz
operator|=
name|sz
expr_stmt|;
return|return
name|sz
return|;
block|}
comment|/** Inverts all terms */
DECL|method|DocTermOrds
specifier|public
name|DocTermOrds
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|reader
argument_list|,
name|field
argument_list|,
literal|null
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
comment|/** Inverts only terms starting w/ prefix */
DECL|method|DocTermOrds
specifier|public
name|DocTermOrds
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|BytesRef
name|termPrefix
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|reader
argument_list|,
name|field
argument_list|,
name|termPrefix
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
comment|/** Inverts only terms starting w/ prefix, and only terms    *  whose docFreq (not taking deletions into account) is    *<=  maxTermDocFreq */
DECL|method|DocTermOrds
specifier|public
name|DocTermOrds
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|BytesRef
name|termPrefix
parameter_list|,
name|int
name|maxTermDocFreq
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|reader
argument_list|,
name|field
argument_list|,
name|termPrefix
argument_list|,
name|maxTermDocFreq
argument_list|,
name|DEFAULT_INDEX_INTERVAL_BITS
argument_list|)
expr_stmt|;
name|uninvert
argument_list|(
name|reader
argument_list|,
name|termPrefix
argument_list|)
expr_stmt|;
block|}
comment|/** Inverts only terms starting w/ prefix, and only terms    *  whose docFreq (not taking deletions into account) is    *<=  maxTermDocFreq, with a custom indexing interval    *  (default is every 128nd term). */
DECL|method|DocTermOrds
specifier|public
name|DocTermOrds
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|BytesRef
name|termPrefix
parameter_list|,
name|int
name|maxTermDocFreq
parameter_list|,
name|int
name|indexIntervalBits
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|field
argument_list|,
name|maxTermDocFreq
argument_list|,
name|indexIntervalBits
argument_list|)
expr_stmt|;
name|uninvert
argument_list|(
name|reader
argument_list|,
name|termPrefix
argument_list|)
expr_stmt|;
block|}
comment|/** Subclass inits w/ this, but be sure you then call    *  uninvert, only once */
DECL|method|DocTermOrds
specifier|protected
name|DocTermOrds
parameter_list|(
name|String
name|field
parameter_list|,
name|int
name|maxTermDocFreq
parameter_list|,
name|int
name|indexIntervalBits
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("DTO init field=" + field + " maxTDFreq=" + maxTermDocFreq);
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|maxTermDocFreq
operator|=
name|maxTermDocFreq
expr_stmt|;
name|this
operator|.
name|indexIntervalBits
operator|=
name|indexIntervalBits
expr_stmt|;
name|indexIntervalMask
operator|=
literal|0xffffffff
operator|>>>
operator|(
literal|32
operator|-
name|indexIntervalBits
operator|)
expr_stmt|;
name|indexInterval
operator|=
literal|1
operator|<<
name|indexIntervalBits
expr_stmt|;
block|}
comment|/** Returns a TermsEnum that implements ord.  If the    *  provided reader supports ord, we just return its    *  TermsEnum; if it does not, we build a "private" terms    *  index internally (WARNING: consumes RAM) and use that    *  index to implement ord.  This also enables ord on top    *  of a composite reader.  The returned TermsEnum is    *  unpositioned.  This returns null if there are no terms.    *    *<p><b>NOTE</b>: you must pass the same reader that was    *  used when creating this class */
DECL|method|getOrdTermsEnum
specifier|public
name|TermsEnum
name|getOrdTermsEnum
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|termInstances
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|indexedTermsArray
operator|==
literal|null
condition|)
block|{
comment|//System.out.println("GET normal enum");
specifier|final
name|Terms
name|terms
init|=
name|MultiFields
operator|.
name|getTerms
argument_list|(
name|reader
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|!=
literal|null
condition|)
block|{
return|return
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
comment|//System.out.println("GET wrapped enum ordBase=" + ordBase);
return|return
operator|new
name|OrdWrappedTermsEnum
argument_list|(
name|reader
argument_list|)
return|;
block|}
block|}
comment|/** Subclass can override this */
DECL|method|visitTerm
specifier|protected
name|void
name|visitTerm
parameter_list|(
name|TermsEnum
name|te
parameter_list|,
name|int
name|termNum
parameter_list|)
throws|throws
name|IOException
block|{   }
DECL|method|setActualDocFreq
specifier|protected
name|void
name|setActualDocFreq
parameter_list|(
name|int
name|termNum
parameter_list|,
name|int
name|df
parameter_list|)
throws|throws
name|IOException
block|{   }
comment|// Call this only once (if you subclass!)
DECL|method|uninvert
specifier|protected
name|void
name|uninvert
parameter_list|(
specifier|final
name|IndexReader
name|reader
parameter_list|,
specifier|final
name|BytesRef
name|termPrefix
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("DTO uninvert field=" + field + " prefix=" + termPrefix);
specifier|final
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|prefix
operator|=
name|termPrefix
operator|==
literal|null
condition|?
literal|null
else|:
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|termPrefix
argument_list|)
expr_stmt|;
specifier|final
name|int
name|maxDoc
init|=
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
specifier|final
name|int
index|[]
name|index
init|=
operator|new
name|int
index|[
name|maxDoc
index|]
decl_stmt|;
comment|// immediate term numbers, or the index into the byte[] representing the last number
specifier|final
name|int
index|[]
name|lastTerm
init|=
operator|new
name|int
index|[
name|maxDoc
index|]
decl_stmt|;
comment|// last term we saw for this document
specifier|final
name|byte
index|[]
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|maxDoc
index|]
index|[]
decl_stmt|;
comment|// list of term numbers for the doc (delta encoded vInts)
specifier|final
name|Terms
name|terms
init|=
name|MultiFields
operator|.
name|getTerms
argument_list|(
name|reader
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|==
literal|null
condition|)
block|{
comment|// No terms
return|return;
block|}
specifier|final
name|TermsEnum
name|te
init|=
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|BytesRef
name|seekStart
init|=
name|termPrefix
operator|!=
literal|null
condition|?
name|termPrefix
else|:
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
comment|//System.out.println("seekStart=" + seekStart.utf8ToString());
if|if
condition|(
name|te
operator|.
name|seekCeil
argument_list|(
name|seekStart
argument_list|)
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|END
condition|)
block|{
comment|// No terms match
return|return;
block|}
comment|// If we need our "term index wrapper", these will be
comment|// init'd below:
name|List
argument_list|<
name|BytesRef
argument_list|>
name|indexedTerms
init|=
literal|null
decl_stmt|;
name|PagedBytes
name|indexedTermsBytes
init|=
literal|null
decl_stmt|;
name|boolean
name|testedOrd
init|=
literal|false
decl_stmt|;
specifier|final
name|Bits
name|liveDocs
init|=
name|MultiFields
operator|.
name|getLiveDocs
argument_list|(
name|reader
argument_list|)
decl_stmt|;
comment|// we need a minimum of 9 bytes, but round up to 12 since the space would
comment|// be wasted with most allocators anyway.
name|byte
index|[]
name|tempArr
init|=
operator|new
name|byte
index|[
literal|12
index|]
decl_stmt|;
comment|//
comment|// enumerate all terms, and build an intermediate form of the un-inverted field.
comment|//
comment|// During this intermediate form, every document has a (potential) byte[]
comment|// and the int[maxDoc()] array either contains the termNumber list directly
comment|// or the *end* offset of the termNumber list in it's byte array (for faster
comment|// appending and faster creation of the final form).
comment|//
comment|// idea... if things are too large while building, we could do a range of docs
comment|// at a time (but it would be a fair amount slower to build)
comment|// could also do ranges in parallel to take advantage of multiple CPUs
comment|// OPTIONAL: remap the largest df terms to the lowest 128 (single byte)
comment|// values.  This requires going over the field first to find the most
comment|// frequent terms ahead of time.
name|int
name|termNum
init|=
literal|0
decl_stmt|;
name|docsEnum
operator|=
literal|null
expr_stmt|;
comment|// Loop begins with te positioned to first term (we call
comment|// seek above):
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|final
name|BytesRef
name|t
init|=
name|te
operator|.
name|term
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
operator|||
operator|(
name|termPrefix
operator|!=
literal|null
operator|&&
operator|!
name|StringHelper
operator|.
name|startsWith
argument_list|(
name|t
argument_list|,
name|termPrefix
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
comment|//System.out.println("visit term=" + t.utf8ToString() + " " + t + " termNum=" + termNum);
if|if
condition|(
operator|!
name|testedOrd
condition|)
block|{
try|try
block|{
name|ordBase
operator|=
operator|(
name|int
operator|)
name|te
operator|.
name|ord
argument_list|()
expr_stmt|;
comment|//System.out.println("got ordBase=" + ordBase);
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|uoe
parameter_list|)
block|{
comment|// Reader cannot provide ord support, so we wrap
comment|// our own support by creating our own terms index:
name|indexedTerms
operator|=
operator|new
name|ArrayList
argument_list|<
name|BytesRef
argument_list|>
argument_list|()
expr_stmt|;
name|indexedTermsBytes
operator|=
operator|new
name|PagedBytes
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|//System.out.println("NO ORDS");
block|}
name|testedOrd
operator|=
literal|true
expr_stmt|;
block|}
name|visitTerm
argument_list|(
name|te
argument_list|,
name|termNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexedTerms
operator|!=
literal|null
operator|&&
operator|(
name|termNum
operator|&
name|indexIntervalMask
operator|)
operator|==
literal|0
condition|)
block|{
comment|// Index this term
name|sizeOfIndexedStrings
operator|+=
name|t
operator|.
name|length
expr_stmt|;
name|BytesRef
name|indexedTerm
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|indexedTermsBytes
operator|.
name|copy
argument_list|(
name|t
argument_list|,
name|indexedTerm
argument_list|)
expr_stmt|;
comment|// TODO: really should 1) strip off useless suffix,
comment|// and 2) use FST not array/PagedBytes
name|indexedTerms
operator|.
name|add
argument_list|(
name|indexedTerm
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|df
init|=
name|te
operator|.
name|docFreq
argument_list|()
decl_stmt|;
if|if
condition|(
name|df
operator|<=
name|maxTermDocFreq
condition|)
block|{
name|docsEnum
operator|=
name|te
operator|.
name|docs
argument_list|(
name|liveDocs
argument_list|,
name|docsEnum
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// dF, but takes deletions into account
name|int
name|actualDF
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|doc
init|=
name|docsEnum
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
break|break;
block|}
comment|//System.out.println("  chunk=" + chunk + " docs");
name|actualDF
operator|++
expr_stmt|;
name|termInstances
operator|++
expr_stmt|;
comment|//System.out.println("    docID=" + doc);
comment|// add TNUM_OFFSET to the term number to make room for special reserved values:
comment|// 0 (end term) and 1 (index into byte array follows)
name|int
name|delta
init|=
name|termNum
operator|-
name|lastTerm
index|[
name|doc
index|]
operator|+
name|TNUM_OFFSET
decl_stmt|;
name|lastTerm
index|[
name|doc
index|]
operator|=
name|termNum
expr_stmt|;
name|int
name|val
init|=
name|index
index|[
name|doc
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0xff
operator|)
operator|==
literal|1
condition|)
block|{
comment|// index into byte array (actually the end of
comment|// the doc-specific byte[] when building)
name|int
name|pos
init|=
name|val
operator|>>>
literal|8
decl_stmt|;
name|int
name|ilen
init|=
name|vIntSize
argument_list|(
name|delta
argument_list|)
decl_stmt|;
name|byte
index|[]
name|arr
init|=
name|bytes
index|[
name|doc
index|]
decl_stmt|;
name|int
name|newend
init|=
name|pos
operator|+
name|ilen
decl_stmt|;
if|if
condition|(
name|newend
operator|>
name|arr
operator|.
name|length
condition|)
block|{
comment|// We avoid a doubling strategy to lower memory usage.
comment|// this faceting method isn't for docs with many terms.
comment|// In hotspot, objects have 2 words of overhead, then fields, rounded up to a 64-bit boundary.
comment|// TODO: figure out what array lengths we can round up to w/o actually using more memory
comment|// (how much space does a byte[] take up?  Is data preceded by a 32 bit length only?
comment|// It should be safe to round up to the nearest 32 bits in any case.
name|int
name|newLen
init|=
operator|(
name|newend
operator|+
literal|3
operator|)
operator|&
literal|0xfffffffc
decl_stmt|;
comment|// 4 byte alignment
name|byte
index|[]
name|newarr
init|=
operator|new
name|byte
index|[
name|newLen
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|arr
argument_list|,
literal|0
argument_list|,
name|newarr
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|arr
operator|=
name|newarr
expr_stmt|;
name|bytes
index|[
name|doc
index|]
operator|=
name|newarr
expr_stmt|;
block|}
name|pos
operator|=
name|writeInt
argument_list|(
name|delta
argument_list|,
name|arr
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|index
index|[
name|doc
index|]
operator|=
operator|(
name|pos
operator|<<
literal|8
operator|)
operator||
literal|1
expr_stmt|;
comment|// update pointer to end index in byte[]
block|}
else|else
block|{
comment|// OK, this int has data in it... find the end (a zero starting byte - not
comment|// part of another number, hence not following a byte with the high bit set).
name|int
name|ipos
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|ipos
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
literal|0x0000ff80
operator|)
operator|==
literal|0
condition|)
block|{
name|ipos
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
literal|0x00ff8000
operator|)
operator|==
literal|0
condition|)
block|{
name|ipos
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
literal|0xff800000
operator|)
operator|==
literal|0
condition|)
block|{
name|ipos
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|ipos
operator|=
literal|4
expr_stmt|;
block|}
comment|//System.out.println("      ipos=" + ipos);
name|int
name|endPos
init|=
name|writeInt
argument_list|(
name|delta
argument_list|,
name|tempArr
argument_list|,
name|ipos
argument_list|)
decl_stmt|;
comment|//System.out.println("      endpos=" + endPos);
if|if
condition|(
name|endPos
operator|<=
literal|4
condition|)
block|{
comment|//System.out.println("      fits!");
comment|// value will fit in the integer... move bytes back
for|for
control|(
name|int
name|j
init|=
name|ipos
init|;
name|j
operator|<
name|endPos
condition|;
name|j
operator|++
control|)
block|{
name|val
operator||=
operator|(
name|tempArr
index|[
name|j
index|]
operator|&
literal|0xff
operator|)
operator|<<
operator|(
name|j
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
name|index
index|[
name|doc
index|]
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
comment|// value won't fit... move integer into byte[]
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|ipos
condition|;
name|j
operator|++
control|)
block|{
name|tempArr
index|[
name|j
index|]
operator|=
operator|(
name|byte
operator|)
name|val
expr_stmt|;
name|val
operator|>>>=
literal|8
expr_stmt|;
block|}
comment|// point at the end index in the byte[]
name|index
index|[
name|doc
index|]
operator|=
operator|(
name|endPos
operator|<<
literal|8
operator|)
operator||
literal|1
expr_stmt|;
name|bytes
index|[
name|doc
index|]
operator|=
name|tempArr
expr_stmt|;
name|tempArr
operator|=
operator|new
name|byte
index|[
literal|12
index|]
expr_stmt|;
block|}
block|}
block|}
name|setActualDocFreq
argument_list|(
name|termNum
argument_list|,
name|actualDF
argument_list|)
expr_stmt|;
block|}
name|termNum
operator|++
expr_stmt|;
if|if
condition|(
name|te
operator|.
name|next
argument_list|()
operator|==
literal|null
condition|)
block|{
break|break;
block|}
block|}
name|numTermsInField
operator|=
name|termNum
expr_stmt|;
name|long
name|midPoint
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|termInstances
operator|==
literal|0
condition|)
block|{
comment|// we didn't invert anything
comment|// lower memory consumption.
name|tnums
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
comment|//
comment|// transform intermediate form into the final form, building a single byte[]
comment|// at a time, and releasing the intermediate byte[]s as we go to avoid
comment|// increasing the memory footprint.
comment|//
for|for
control|(
name|int
name|pass
init|=
literal|0
init|;
name|pass
operator|<
literal|256
condition|;
name|pass
operator|++
control|)
block|{
name|byte
index|[]
name|target
init|=
name|tnums
index|[
name|pass
index|]
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
comment|// end in target;
if|if
condition|(
name|target
operator|!=
literal|null
condition|)
block|{
name|pos
operator|=
name|target
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
operator|new
name|byte
index|[
literal|4096
index|]
expr_stmt|;
block|}
comment|// loop over documents, 0x00ppxxxx, 0x01ppxxxx, 0x02ppxxxx
comment|// where pp is the pass (which array we are building), and xx is all values.
comment|// each pass shares the same byte[] for termNumber lists.
for|for
control|(
name|int
name|docbase
init|=
name|pass
operator|<<
literal|16
init|;
name|docbase
operator|<
name|maxDoc
condition|;
name|docbase
operator|+=
operator|(
literal|1
operator|<<
literal|24
operator|)
control|)
block|{
name|int
name|lim
init|=
name|Math
operator|.
name|min
argument_list|(
name|docbase
operator|+
operator|(
literal|1
operator|<<
literal|16
operator|)
argument_list|,
name|maxDoc
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|doc
init|=
name|docbase
init|;
name|doc
operator|<
name|lim
condition|;
name|doc
operator|++
control|)
block|{
comment|//System.out.println("  pass=" + pass + " process docID=" + doc);
name|int
name|val
init|=
name|index
index|[
name|doc
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0xff
operator|)
operator|==
literal|1
condition|)
block|{
name|int
name|len
init|=
name|val
operator|>>>
literal|8
decl_stmt|;
comment|//System.out.println("    ptr pos=" + pos);
name|index
index|[
name|doc
index|]
operator|=
operator|(
name|pos
operator|<<
literal|8
operator|)
operator||
literal|1
expr_stmt|;
comment|// change index to point to start of array
if|if
condition|(
operator|(
name|pos
operator|&
literal|0xff000000
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// we only have 24 bits for the array index
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Too many values for UnInvertedField faceting on field "
operator|+
name|field
argument_list|)
throw|;
block|}
name|byte
index|[]
name|arr
init|=
name|bytes
index|[
name|doc
index|]
decl_stmt|;
comment|/*               for(byte b : arr) {                 //System.out.println("      b=" + Integer.toHexString((int) b));               }               */
name|bytes
index|[
name|doc
index|]
operator|=
literal|null
expr_stmt|;
comment|// IMPORTANT: allow GC to avoid OOM
if|if
condition|(
name|target
operator|.
name|length
operator|<=
name|pos
operator|+
name|len
condition|)
block|{
name|int
name|newlen
init|=
name|target
operator|.
name|length
decl_stmt|;
comment|/*** we don't have to worry about the array getting too large                  * since the "pos" param will overflow first (only 24 bits available)                 if ((newlen<<1)<= 0) {                   // overflow...                   newlen = Integer.MAX_VALUE;                   if (newlen<= pos + len) {                     throw new SolrException(400,"Too many terms to uninvert field!");                   }                 } else {                   while (newlen<= pos + len) newlen<<=1;  // doubling strategy                 }                 ****/
while|while
condition|(
name|newlen
operator|<=
name|pos
operator|+
name|len
condition|)
name|newlen
operator|<<=
literal|1
expr_stmt|;
comment|// doubling strategy
name|byte
index|[]
name|newtarget
init|=
operator|new
name|byte
index|[
name|newlen
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|target
argument_list|,
literal|0
argument_list|,
name|newtarget
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|target
operator|=
name|newtarget
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|arr
argument_list|,
literal|0
argument_list|,
name|target
argument_list|,
name|pos
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
comment|// skip single byte at end and leave it 0 for terminator
block|}
block|}
block|}
comment|// shrink array
if|if
condition|(
name|pos
operator|<
name|target
operator|.
name|length
condition|)
block|{
name|byte
index|[]
name|newtarget
init|=
operator|new
name|byte
index|[
name|pos
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|target
argument_list|,
literal|0
argument_list|,
name|newtarget
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|target
operator|=
name|newtarget
expr_stmt|;
block|}
name|tnums
index|[
name|pass
index|]
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|(
name|pass
operator|<<
literal|16
operator|)
operator|>
name|maxDoc
condition|)
break|break;
block|}
if|if
condition|(
name|indexedTerms
operator|!=
literal|null
condition|)
block|{
name|indexedTermsArray
operator|=
name|indexedTerms
operator|.
name|toArray
argument_list|(
operator|new
name|BytesRef
index|[
name|indexedTerms
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|endTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|total_time
operator|=
call|(
name|int
call|)
argument_list|(
name|endTime
operator|-
name|startTime
argument_list|)
expr_stmt|;
name|phase1_time
operator|=
call|(
name|int
call|)
argument_list|(
name|midPoint
operator|-
name|startTime
argument_list|)
expr_stmt|;
block|}
comment|/** Number of bytes to represent an unsigned int as a vint. */
DECL|method|vIntSize
specifier|private
specifier|static
name|int
name|vIntSize
parameter_list|(
name|int
name|x
parameter_list|)
block|{
if|if
condition|(
operator|(
name|x
operator|&
operator|(
literal|0xffffffff
operator|<<
operator|(
literal|7
operator|*
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|x
operator|&
operator|(
literal|0xffffffff
operator|<<
operator|(
literal|7
operator|*
literal|2
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|2
return|;
block|}
if|if
condition|(
operator|(
name|x
operator|&
operator|(
literal|0xffffffff
operator|<<
operator|(
literal|7
operator|*
literal|3
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|3
return|;
block|}
if|if
condition|(
operator|(
name|x
operator|&
operator|(
literal|0xffffffff
operator|<<
operator|(
literal|7
operator|*
literal|4
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|4
return|;
block|}
return|return
literal|5
return|;
block|}
comment|// todo: if we know the size of the vInt already, we could do
comment|// a single switch on the size
DECL|method|writeInt
specifier|private
specifier|static
name|int
name|writeInt
parameter_list|(
name|int
name|x
parameter_list|,
name|byte
index|[]
name|arr
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|int
name|a
decl_stmt|;
name|a
operator|=
operator|(
name|x
operator|>>>
operator|(
literal|7
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|a
operator|!=
literal|0
condition|)
block|{
name|arr
index|[
name|pos
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|a
operator||
literal|0x80
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
operator|(
name|x
operator|>>>
operator|(
literal|7
operator|*
literal|3
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|a
operator|!=
literal|0
condition|)
block|{
name|arr
index|[
name|pos
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|a
operator||
literal|0x80
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
operator|(
name|x
operator|>>>
operator|(
literal|7
operator|*
literal|2
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|a
operator|!=
literal|0
condition|)
block|{
name|arr
index|[
name|pos
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|a
operator||
literal|0x80
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
operator|(
name|x
operator|>>>
operator|(
literal|7
operator|*
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|a
operator|!=
literal|0
condition|)
block|{
name|arr
index|[
name|pos
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|a
operator||
literal|0x80
argument_list|)
expr_stmt|;
block|}
name|arr
index|[
name|pos
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|x
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
DECL|class|TermOrdsIterator
specifier|public
class|class
name|TermOrdsIterator
block|{
DECL|field|tnum
specifier|private
name|int
name|tnum
decl_stmt|;
DECL|field|upto
specifier|private
name|int
name|upto
decl_stmt|;
DECL|field|arr
specifier|private
name|byte
index|[]
name|arr
decl_stmt|;
comment|/** Buffer must be at least 5 ints long.  Returns number      *  of term ords placed into buffer; if this count is      *  less than buffer.length then that is the end. */
DECL|method|read
specifier|public
name|int
name|read
parameter_list|(
name|int
index|[]
name|buffer
parameter_list|)
block|{
name|int
name|bufferUpto
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arr
operator|==
literal|null
condition|)
block|{
comment|// code is inlined into upto
comment|//System.out.println("inlined");
name|int
name|code
init|=
name|upto
decl_stmt|;
name|int
name|delta
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|delta
operator|=
operator|(
name|delta
operator|<<
literal|7
operator|)
operator||
operator|(
name|code
operator|&
literal|0x7f
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
break|break;
name|tnum
operator|+=
name|delta
operator|-
name|TNUM_OFFSET
expr_stmt|;
name|buffer
index|[
name|bufferUpto
operator|++
index|]
operator|=
name|ordBase
operator|+
name|tnum
expr_stmt|;
comment|//System.out.println("  tnum=" + tnum);
name|delta
operator|=
literal|0
expr_stmt|;
block|}
name|code
operator|>>>=
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// code is a pointer
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|delta
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|byte
name|b
init|=
name|arr
index|[
name|upto
operator|++
index|]
decl_stmt|;
name|delta
operator|=
operator|(
name|delta
operator|<<
literal|7
operator|)
operator||
operator|(
name|b
operator|&
literal|0x7f
operator|)
expr_stmt|;
comment|//System.out.println("    cycle: upto=" + upto + " delta=" + delta + " b=" + b);
if|if
condition|(
operator|(
name|b
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|//System.out.println("  delta=" + delta);
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
break|break;
name|tnum
operator|+=
name|delta
operator|-
name|TNUM_OFFSET
expr_stmt|;
comment|//System.out.println("  tnum=" + tnum);
name|buffer
index|[
name|bufferUpto
operator|++
index|]
operator|=
name|ordBase
operator|+
name|tnum
expr_stmt|;
if|if
condition|(
name|bufferUpto
operator|==
name|buffer
operator|.
name|length
condition|)
block|{
break|break;
block|}
block|}
block|}
return|return
name|bufferUpto
return|;
block|}
DECL|method|reset
specifier|public
name|TermOrdsIterator
name|reset
parameter_list|(
name|int
name|docID
parameter_list|)
block|{
comment|//System.out.println("  reset docID=" + docID);
name|tnum
operator|=
literal|0
expr_stmt|;
specifier|final
name|int
name|code
init|=
name|index
index|[
name|docID
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|0xff
operator|)
operator|==
literal|1
condition|)
block|{
comment|// a pointer
name|upto
operator|=
name|code
operator|>>>
literal|8
expr_stmt|;
comment|//System.out.println("    pointer!  upto=" + upto);
name|int
name|whichArray
init|=
operator|(
name|docID
operator|>>>
literal|16
operator|)
operator|&
literal|0xff
decl_stmt|;
name|arr
operator|=
name|tnums
index|[
name|whichArray
index|]
expr_stmt|;
block|}
else|else
block|{
comment|//System.out.println("    inline!");
name|arr
operator|=
literal|null
expr_stmt|;
name|upto
operator|=
name|code
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
block|}
comment|/** Returns an iterator to step through the term ords for    *  this document.  It's also possible to subclass this    *  class and directly access members. */
DECL|method|lookup
specifier|public
name|TermOrdsIterator
name|lookup
parameter_list|(
name|int
name|doc
parameter_list|,
name|TermOrdsIterator
name|reuse
parameter_list|)
block|{
specifier|final
name|TermOrdsIterator
name|ret
decl_stmt|;
if|if
condition|(
name|reuse
operator|!=
literal|null
condition|)
block|{
name|ret
operator|=
name|reuse
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|new
name|TermOrdsIterator
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
operator|.
name|reset
argument_list|(
name|doc
argument_list|)
return|;
block|}
comment|/* Only used if original IndexReader doesn't implement    * ord; in this case we "wrap" our own terms index    * around it. */
DECL|class|OrdWrappedTermsEnum
specifier|private
specifier|final
class|class
name|OrdWrappedTermsEnum
extends|extends
name|TermsEnum
block|{
DECL|field|reader
specifier|private
specifier|final
name|IndexReader
name|reader
decl_stmt|;
DECL|field|termsEnum
specifier|private
specifier|final
name|TermsEnum
name|termsEnum
decl_stmt|;
DECL|field|term
specifier|private
name|BytesRef
name|term
decl_stmt|;
DECL|field|ord
specifier|private
name|long
name|ord
init|=
operator|-
name|indexInterval
operator|-
literal|1
decl_stmt|;
comment|// force "real" seek
DECL|method|OrdWrappedTermsEnum
specifier|public
name|OrdWrappedTermsEnum
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|reader
operator|=
name|reader
expr_stmt|;
assert|assert
name|indexedTermsArray
operator|!=
literal|null
assert|;
name|termsEnum
operator|=
name|MultiFields
operator|.
name|getTerms
argument_list|(
name|reader
argument_list|,
name|field
argument_list|)
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|termsEnum
operator|.
name|getComparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|boolean
name|needsFreqs
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|termsEnum
operator|.
name|docs
argument_list|(
name|liveDocs
argument_list|,
name|reuse
argument_list|,
name|needsFreqs
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|termsEnum
operator|.
name|docsAndPositions
argument_list|(
name|liveDocs
argument_list|,
name|reuse
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
block|{
return|return
name|term
return|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
throws|throws
name|IOException
block|{
name|ord
operator|++
expr_stmt|;
if|if
condition|(
name|termsEnum
operator|.
name|next
argument_list|()
operator|==
literal|null
condition|)
block|{
name|term
operator|=
literal|null
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|setTerm
argument_list|()
return|;
comment|// this is extra work if we know we are in bounds...
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|termsEnum
operator|.
name|docFreq
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|termsEnum
operator|.
name|totalTermFreq
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|ordBase
operator|+
name|ord
return|;
block|}
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
name|BytesRef
name|target
parameter_list|,
name|boolean
name|useCache
parameter_list|)
throws|throws
name|IOException
block|{
comment|// already here
if|if
condition|(
name|term
operator|!=
literal|null
operator|&&
name|term
operator|.
name|equals
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
name|int
name|startIdx
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|indexedTermsArray
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|startIdx
operator|>=
literal|0
condition|)
block|{
comment|// we hit the term exactly... lucky us!
name|TermsEnum
operator|.
name|SeekStatus
name|seekStatus
init|=
name|termsEnum
operator|.
name|seekCeil
argument_list|(
name|target
argument_list|)
decl_stmt|;
assert|assert
name|seekStatus
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|FOUND
assert|;
name|ord
operator|=
name|startIdx
operator|<<
name|indexIntervalBits
expr_stmt|;
name|setTerm
argument_list|()
expr_stmt|;
assert|assert
name|term
operator|!=
literal|null
assert|;
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
comment|// we didn't hit the term exactly
name|startIdx
operator|=
operator|-
name|startIdx
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|startIdx
operator|==
literal|0
condition|)
block|{
comment|// our target occurs *before* the first term
name|TermsEnum
operator|.
name|SeekStatus
name|seekStatus
init|=
name|termsEnum
operator|.
name|seekCeil
argument_list|(
name|target
argument_list|)
decl_stmt|;
assert|assert
name|seekStatus
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|NOT_FOUND
assert|;
name|ord
operator|=
literal|0
expr_stmt|;
name|setTerm
argument_list|()
expr_stmt|;
assert|assert
name|term
operator|!=
literal|null
assert|;
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
comment|// back up to the start of the block
name|startIdx
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|ord
operator|>>
name|indexIntervalBits
operator|)
operator|==
name|startIdx
operator|&&
name|term
operator|!=
literal|null
operator|&&
name|term
operator|.
name|compareTo
argument_list|(
name|target
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|// we are already in the right block and the current term is before the term we want,
comment|// so we don't need to seek.
block|}
else|else
block|{
comment|// seek to the right block
name|TermsEnum
operator|.
name|SeekStatus
name|seekStatus
init|=
name|termsEnum
operator|.
name|seekCeil
argument_list|(
name|indexedTermsArray
index|[
name|startIdx
index|]
argument_list|)
decl_stmt|;
assert|assert
name|seekStatus
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|FOUND
assert|;
name|ord
operator|=
name|startIdx
operator|<<
name|indexIntervalBits
expr_stmt|;
name|setTerm
argument_list|()
expr_stmt|;
assert|assert
name|term
operator|!=
literal|null
assert|;
comment|// should be non-null since it's in the index
block|}
while|while
condition|(
name|term
operator|!=
literal|null
operator|&&
name|term
operator|.
name|compareTo
argument_list|(
name|target
argument_list|)
operator|<
literal|0
condition|)
block|{
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|term
operator|==
literal|null
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
elseif|else
if|if
condition|(
name|term
operator|.
name|compareTo
argument_list|(
name|target
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
else|else
block|{
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|targetOrd
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|delta
init|=
call|(
name|int
call|)
argument_list|(
name|targetOrd
operator|-
name|ordBase
operator|-
name|ord
argument_list|)
decl_stmt|;
comment|//System.out.println("  seek(ord) targetOrd=" + targetOrd + " delta=" + delta + " ord=" + ord + " ii=" + indexInterval);
if|if
condition|(
name|delta
argument_list|<
literal|0
operator|||
name|delta
argument_list|>
name|indexInterval
condition|)
block|{
specifier|final
name|int
name|idx
init|=
call|(
name|int
call|)
argument_list|(
name|targetOrd
operator|>>>
name|indexIntervalBits
argument_list|)
decl_stmt|;
specifier|final
name|BytesRef
name|base
init|=
name|indexedTermsArray
index|[
name|idx
index|]
decl_stmt|;
comment|//System.out.println("  do seek term=" + base.utf8ToString());
name|ord
operator|=
name|idx
operator|<<
name|indexIntervalBits
expr_stmt|;
name|delta
operator|=
call|(
name|int
call|)
argument_list|(
name|targetOrd
operator|-
name|ord
argument_list|)
expr_stmt|;
specifier|final
name|TermsEnum
operator|.
name|SeekStatus
name|seekStatus
init|=
name|termsEnum
operator|.
name|seekCeil
argument_list|(
name|base
argument_list|,
literal|true
argument_list|)
decl_stmt|;
assert|assert
name|seekStatus
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|FOUND
assert|;
block|}
else|else
block|{
comment|//System.out.println("seek w/in block");
block|}
while|while
condition|(
operator|--
name|delta
operator|>=
literal|0
condition|)
block|{
name|BytesRef
name|br
init|=
name|termsEnum
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|br
operator|==
literal|null
condition|)
block|{
assert|assert
literal|false
assert|;
return|return;
block|}
name|ord
operator|++
expr_stmt|;
block|}
name|setTerm
argument_list|()
expr_stmt|;
assert|assert
name|term
operator|!=
literal|null
assert|;
block|}
DECL|method|setTerm
specifier|private
name|BytesRef
name|setTerm
parameter_list|()
throws|throws
name|IOException
block|{
name|term
operator|=
name|termsEnum
operator|.
name|term
argument_list|()
expr_stmt|;
comment|//System.out.println("  setTerm() term=" + term.utf8ToString() + " vs prefix=" + (prefix == null ? "null" : prefix.utf8ToString()));
if|if
condition|(
name|prefix
operator|!=
literal|null
operator|&&
operator|!
name|StringHelper
operator|.
name|startsWith
argument_list|(
name|term
argument_list|,
name|prefix
argument_list|)
condition|)
block|{
name|term
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|term
return|;
block|}
block|}
DECL|method|lookupTerm
specifier|public
name|BytesRef
name|lookupTerm
parameter_list|(
name|TermsEnum
name|termsEnum
parameter_list|,
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
name|termsEnum
operator|.
name|seekExact
argument_list|(
name|ord
argument_list|)
expr_stmt|;
return|return
name|termsEnum
operator|.
name|term
argument_list|()
return|;
block|}
block|}
end_class
end_unit
