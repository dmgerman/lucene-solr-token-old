begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
operator|.
name|FieldNumberBiMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|CodecProvider
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|DefaultSegmentInfosWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|SegmentInfosReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|SegmentInfosWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|NoSuchDirectoryException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ThreadInterruptedException
import|;
end_import
begin_comment
comment|/**  * A collection of segmentInfo objects with methods for operating on  * those segments in relation to the file system.  *   * @lucene.experimental  */
end_comment
begin_class
DECL|class|SegmentInfos
specifier|public
specifier|final
class|class
name|SegmentInfos
implements|implements
name|Cloneable
implements|,
name|Iterable
argument_list|<
name|SegmentInfo
argument_list|>
block|{
comment|/*     * The file format version, a negative number.    *      * NOTE: future format numbers must always be one smaller     * than the latest. With time, support for old formats will    * be removed, however the numbers should continue to decrease.     */
comment|/** Used for the segments.gen file only!    * Whenever you add a new format, make it 1 smaller (negative version logic)! */
DECL|field|FORMAT_SEGMENTS_GEN_CURRENT
specifier|public
specifier|static
specifier|final
name|int
name|FORMAT_SEGMENTS_GEN_CURRENT
init|=
operator|-
literal|2
decl_stmt|;
DECL|field|counter
specifier|public
name|int
name|counter
init|=
literal|0
decl_stmt|;
comment|// used to name new segments
comment|/**    * counts how often the index has been changed by adding or deleting docs.    * starting with the current time in milliseconds forces to create unique version numbers.    */
DECL|field|version
specifier|public
name|long
name|version
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
DECL|field|globalFieldMapVersion
specifier|private
name|long
name|globalFieldMapVersion
init|=
literal|0
decl_stmt|;
comment|// version of the GFNM for the next commit
DECL|field|lastGlobalFieldMapVersion
specifier|private
name|long
name|lastGlobalFieldMapVersion
init|=
literal|0
decl_stmt|;
comment|// version of the GFNM file we last successfully read or wrote
DECL|field|pendingMapVersion
specifier|private
name|long
name|pendingMapVersion
init|=
operator|-
literal|1
decl_stmt|;
comment|// version of the GFNM itself that we have last successfully written
comment|// or -1 if we it was not written. This is set during prepareCommit
DECL|field|generation
specifier|private
name|long
name|generation
init|=
literal|0
decl_stmt|;
comment|// generation of the "segments_N" for the next commit
DECL|field|lastGeneration
specifier|private
name|long
name|lastGeneration
init|=
literal|0
decl_stmt|;
comment|// generation of the "segments_N" file we last successfully read
comment|// or wrote; this is normally the same as generation except if
comment|// there was an IOException that had interrupted a commit
DECL|field|userData
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|userData
init|=
name|Collections
operator|.
expr|<
name|String
decl_stmt|,
name|String
decl|>
name|emptyMap
argument_list|()
decl_stmt|;
comment|// Opaque Map<String, String> that user can specify during IndexWriter.commit
DECL|field|codecs
specifier|private
name|CodecProvider
name|codecs
decl_stmt|;
DECL|field|format
specifier|private
name|int
name|format
decl_stmt|;
DECL|field|globalFieldNumberMap
specifier|private
name|FieldNumberBiMap
name|globalFieldNumberMap
decl_stmt|;
comment|// this segments global field number map - lazy loaded on demand
DECL|field|segments
specifier|private
name|List
argument_list|<
name|SegmentInfo
argument_list|>
name|segments
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentInfo
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|segmentSet
specifier|private
name|Set
argument_list|<
name|SegmentInfo
argument_list|>
name|segmentSet
init|=
operator|new
name|HashSet
argument_list|<
name|SegmentInfo
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|cachedUnmodifiableList
specifier|private
specifier|transient
name|List
argument_list|<
name|SegmentInfo
argument_list|>
name|cachedUnmodifiableList
decl_stmt|;
DECL|field|cachedUnmodifiableSet
specifier|private
specifier|transient
name|Set
argument_list|<
name|SegmentInfo
argument_list|>
name|cachedUnmodifiableSet
decl_stmt|;
comment|/**    * If non-null, information about loading segments_N files    * will be printed here.  @see #setInfoStream.    */
DECL|field|infoStream
specifier|private
specifier|static
name|PrintStream
name|infoStream
init|=
literal|null
decl_stmt|;
DECL|method|SegmentInfos
specifier|public
name|SegmentInfos
parameter_list|()
block|{
name|this
argument_list|(
name|CodecProvider
operator|.
name|getDefault
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|SegmentInfos
specifier|public
name|SegmentInfos
parameter_list|(
name|CodecProvider
name|codecs
parameter_list|)
block|{
name|this
operator|.
name|codecs
operator|=
name|codecs
expr_stmt|;
block|}
DECL|method|setFormat
specifier|public
name|void
name|setFormat
parameter_list|(
name|int
name|format
parameter_list|)
block|{
name|this
operator|.
name|format
operator|=
name|format
expr_stmt|;
block|}
DECL|method|getFormat
specifier|public
name|int
name|getFormat
parameter_list|()
block|{
return|return
name|format
return|;
block|}
DECL|method|info
specifier|public
name|SegmentInfo
name|info
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|segments
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/**    * Get the generation (N) of the current segments_N file    * from a list of files.    *    * @param files -- array of file names to check    */
DECL|method|getCurrentSegmentGeneration
specifier|public
specifier|static
name|long
name|getCurrentSegmentGeneration
parameter_list|(
name|String
index|[]
name|files
parameter_list|)
block|{
if|if
condition|(
name|files
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|long
name|max
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|files
control|)
block|{
if|if
condition|(
name|file
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|)
operator|&&
operator|!
name|file
operator|.
name|equals
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS_GEN
argument_list|)
condition|)
block|{
name|long
name|gen
init|=
name|generationFromSegmentsFileName
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|gen
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|gen
expr_stmt|;
block|}
block|}
block|}
return|return
name|max
return|;
block|}
comment|/**    * Get the generation (N) of the current segments_N file    * in the directory.    *    * @param directory -- directory to search for the latest segments_N file    */
DECL|method|getCurrentSegmentGeneration
specifier|public
specifier|static
name|long
name|getCurrentSegmentGeneration
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|getCurrentSegmentGeneration
argument_list|(
name|directory
operator|.
name|listAll
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchDirectoryException
name|nsde
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/**    * Get the filename of the current segments_N file    * from a list of files.    *    * @param files -- array of file names to check    */
DECL|method|getCurrentSegmentFileName
specifier|public
specifier|static
name|String
name|getCurrentSegmentFileName
parameter_list|(
name|String
index|[]
name|files
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|getCurrentSegmentGeneration
argument_list|(
name|files
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the filename of the current segments_N file    * in the directory.    *    * @param directory -- directory to search for the latest segments_N file    */
DECL|method|getCurrentSegmentFileName
specifier|public
specifier|static
name|String
name|getCurrentSegmentFileName
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|getCurrentSegmentGeneration
argument_list|(
name|directory
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the segments_N filename in use by this segment infos.    */
DECL|method|getCurrentSegmentFileName
specifier|public
name|String
name|getCurrentSegmentFileName
parameter_list|()
block|{
return|return
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|lastGeneration
argument_list|)
return|;
block|}
DECL|method|getGlobalFieldNumberName
specifier|private
name|String
name|getGlobalFieldNumberName
parameter_list|(
name|long
name|version
parameter_list|)
block|{
comment|/*      * This creates a file name ${version}.fnx without a leading underscore      * since this file might belong to more than one segment (global map) and      * could otherwise easily be confused with a per-segment file.      */
return|return
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
literal|""
operator|+
name|version
argument_list|,
literal|""
argument_list|,
name|IndexFileNames
operator|.
name|GLOBAL_FIELD_NUM_MAP_EXTENSION
argument_list|)
return|;
block|}
comment|/**    * Parse the generation off the segments file name and    * return it.    */
DECL|method|generationFromSegmentsFileName
specifier|public
specifier|static
name|long
name|generationFromSegmentsFileName
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
if|if
condition|(
name|fileName
operator|.
name|equals
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fileName
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|)
condition|)
block|{
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|fileName
operator|.
name|substring
argument_list|(
literal|1
operator|+
name|IndexFileNames
operator|.
name|SEGMENTS
operator|.
name|length
argument_list|()
argument_list|)
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"fileName \""
operator|+
name|fileName
operator|+
literal|"\" is not a segments file"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the next segments_N filename that will be written.    */
DECL|method|getNextSegmentFileName
specifier|public
name|String
name|getNextSegmentFileName
parameter_list|()
block|{
name|long
name|nextGeneration
decl_stmt|;
if|if
condition|(
name|generation
operator|==
operator|-
literal|1
condition|)
block|{
name|nextGeneration
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nextGeneration
operator|=
name|generation
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|nextGeneration
argument_list|)
return|;
block|}
comment|/**    * Read a particular segmentFileName.  Note that this may    * throw an IOException if a commit is in process.    *    * @param directory -- directory containing the segments file    * @param segmentFileName -- segment file to load    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|read
specifier|public
specifier|final
name|void
name|read
parameter_list|(
name|Directory
name|directory
parameter_list|,
name|String
name|segmentFileName
parameter_list|,
name|CodecProvider
name|codecs
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|this
operator|.
name|codecs
operator|=
name|codecs
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
comment|// Clear any previous segments:
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
name|generation
operator|=
name|generationFromSegmentsFileName
argument_list|(
name|segmentFileName
argument_list|)
expr_stmt|;
name|lastGeneration
operator|=
name|generation
expr_stmt|;
try|try
block|{
name|SegmentInfosReader
name|infosReader
init|=
name|codecs
operator|.
name|getSegmentInfosReader
argument_list|()
decl_stmt|;
name|infosReader
operator|.
name|read
argument_list|(
name|directory
argument_list|,
name|segmentFileName
argument_list|,
name|codecs
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// Clear any segment infos we had loaded so we
comment|// have a clean slate on retry:
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * This version of read uses the retry logic (for lock-less    * commits) to find the right segments file to load.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|read
specifier|public
specifier|final
name|void
name|read
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|read
argument_list|(
name|directory
argument_list|,
name|CodecProvider
operator|.
name|getDefault
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|read
specifier|public
specifier|final
name|void
name|read
parameter_list|(
name|Directory
name|directory
parameter_list|,
specifier|final
name|CodecProvider
name|codecs
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|generation
operator|=
name|lastGeneration
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|codecs
operator|=
name|codecs
expr_stmt|;
operator|new
name|FindSegmentsFile
argument_list|(
name|directory
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|Object
name|doBody
parameter_list|(
name|String
name|segmentFileName
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|read
argument_list|(
name|directory
argument_list|,
name|segmentFileName
argument_list|,
name|codecs
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// either we are on 4.0 or we don't have a lastGlobalFieldMapVersion i.e. its still set to 0
assert|assert
name|DefaultSegmentInfosWriter
operator|.
name|FORMAT_4_0
operator|<=
name|format
operator|||
operator|(
name|DefaultSegmentInfosWriter
operator|.
name|FORMAT_4_0
operator|>
name|format
operator|&&
name|lastGlobalFieldMapVersion
operator|==
literal|0
operator|)
assert|;
block|}
comment|// Only non-null after prepareCommit has been called and
comment|// before finishCommit is called
DECL|field|pendingSegnOutput
name|IndexOutput
name|pendingSegnOutput
decl_stmt|;
DECL|method|write
specifier|private
name|void
name|write
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|segmentFileName
init|=
name|getNextSegmentFileName
argument_list|()
decl_stmt|;
specifier|final
name|String
name|globalFieldMapFile
decl_stmt|;
if|if
condition|(
name|globalFieldNumberMap
operator|!=
literal|null
operator|&&
name|globalFieldNumberMap
operator|.
name|isDirty
argument_list|()
condition|)
block|{
name|globalFieldMapFile
operator|=
name|getGlobalFieldNumberName
argument_list|(
operator|++
name|globalFieldMapVersion
argument_list|)
expr_stmt|;
name|pendingMapVersion
operator|=
name|writeGlobalFieldMap
argument_list|(
name|globalFieldNumberMap
argument_list|,
name|directory
argument_list|,
name|globalFieldMapFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|globalFieldMapFile
operator|=
literal|null
expr_stmt|;
block|}
comment|// Always advance the generation on write:
if|if
condition|(
name|generation
operator|==
operator|-
literal|1
condition|)
block|{
name|generation
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|generation
operator|++
expr_stmt|;
block|}
name|IndexOutput
name|segnOutput
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|SegmentInfosWriter
name|infosWriter
init|=
name|codecs
operator|.
name|getSegmentInfosWriter
argument_list|()
decl_stmt|;
name|segnOutput
operator|=
name|infosWriter
operator|.
name|writeInfos
argument_list|(
name|directory
argument_list|,
name|segmentFileName
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|infosWriter
operator|.
name|prepareCommit
argument_list|(
name|segnOutput
argument_list|)
expr_stmt|;
name|pendingSegnOutput
operator|=
name|segnOutput
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// We hit an exception above; try to close the file
comment|// but suppress any exception:
name|IOUtils
operator|.
name|closeSafely
argument_list|(
literal|true
argument_list|,
name|segnOutput
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Try not to leave a truncated segments_N file in
comment|// the index:
name|directory
operator|.
name|deleteFile
argument_list|(
name|segmentFileName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress so we keep throwing the original exception
block|}
if|if
condition|(
name|globalFieldMapFile
operator|!=
literal|null
condition|)
block|{
comment|// delete if written here
try|try
block|{
comment|// Try not to leave global field map in
comment|// the index:
name|directory
operator|.
name|deleteFile
argument_list|(
name|globalFieldMapFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress so we keep throwing the original exception
block|}
block|}
name|pendingMapVersion
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/** Prunes any segment whose docs are all deleted. */
DECL|method|pruneDeletedSegments
specifier|public
name|void
name|pruneDeletedSegments
parameter_list|()
block|{
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|SegmentInfo
argument_list|>
name|it
init|=
name|segments
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|SegmentInfo
name|info
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|getDelCount
argument_list|()
operator|==
name|info
operator|.
name|docCount
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|segmentSet
operator|.
name|remove
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|segmentSet
operator|.
name|size
argument_list|()
operator|==
name|segments
operator|.
name|size
argument_list|()
assert|;
block|}
comment|/**    * Returns a copy of this instance, also copying each    * SegmentInfo.    */
annotation|@
name|Override
DECL|method|clone
specifier|public
name|Object
name|clone
parameter_list|()
block|{
try|try
block|{
specifier|final
name|SegmentInfos
name|sis
init|=
operator|(
name|SegmentInfos
operator|)
name|super
operator|.
name|clone
argument_list|()
decl_stmt|;
comment|// deep clone, first recreate all collections:
name|sis
operator|.
name|segments
operator|=
operator|new
name|ArrayList
argument_list|<
name|SegmentInfo
argument_list|>
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|sis
operator|.
name|segmentSet
operator|=
operator|new
name|HashSet
argument_list|<
name|SegmentInfo
argument_list|>
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|sis
operator|.
name|cachedUnmodifiableList
operator|=
literal|null
expr_stmt|;
name|sis
operator|.
name|cachedUnmodifiableSet
operator|=
literal|null
expr_stmt|;
for|for
control|(
specifier|final
name|SegmentInfo
name|info
range|:
name|this
control|)
block|{
assert|assert
name|info
operator|.
name|getSegmentCodecs
argument_list|()
operator|!=
literal|null
assert|;
comment|// dont directly access segments, use add method!!!
name|sis
operator|.
name|add
argument_list|(
operator|(
name|SegmentInfo
operator|)
name|info
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sis
operator|.
name|userData
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|userData
argument_list|)
expr_stmt|;
return|return
name|sis
return|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"should not happen"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * version number when this SegmentInfos was generated.    */
DECL|method|getVersion
specifier|public
name|long
name|getVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
DECL|method|getGeneration
specifier|public
name|long
name|getGeneration
parameter_list|()
block|{
return|return
name|generation
return|;
block|}
DECL|method|getLastGeneration
specifier|public
name|long
name|getLastGeneration
parameter_list|()
block|{
return|return
name|lastGeneration
return|;
block|}
comment|/**    * Current version number from segments file.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|readCurrentVersion
specifier|public
specifier|static
name|long
name|readCurrentVersion
parameter_list|(
name|Directory
name|directory
parameter_list|,
specifier|final
name|CodecProvider
name|codecs
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
comment|// Fully read the segments file: this ensures that it's
comment|// completely written so that if
comment|// IndexWriter.prepareCommit has been called (but not
comment|// yet commit), then the reader will still see itself as
comment|// current:
name|SegmentInfos
name|sis
init|=
operator|new
name|SegmentInfos
argument_list|(
name|codecs
argument_list|)
decl_stmt|;
name|sis
operator|.
name|read
argument_list|(
name|directory
argument_list|,
name|codecs
argument_list|)
expr_stmt|;
return|return
name|sis
operator|.
name|version
return|;
block|}
comment|/**    * Returns userData from latest segments file    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|readCurrentUserData
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|readCurrentUserData
parameter_list|(
name|Directory
name|directory
parameter_list|,
name|CodecProvider
name|codecs
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|SegmentInfos
name|sis
init|=
operator|new
name|SegmentInfos
argument_list|(
name|codecs
argument_list|)
decl_stmt|;
name|sis
operator|.
name|read
argument_list|(
name|directory
argument_list|,
name|codecs
argument_list|)
expr_stmt|;
return|return
name|sis
operator|.
name|getUserData
argument_list|()
return|;
block|}
comment|/** If non-null, information about retries when loading    * the segments file will be printed to this.    */
DECL|method|setInfoStream
specifier|public
specifier|static
name|void
name|setInfoStream
parameter_list|(
name|PrintStream
name|infoStream
parameter_list|)
block|{
name|SegmentInfos
operator|.
name|infoStream
operator|=
name|infoStream
expr_stmt|;
block|}
comment|/* Advanced configuration of retry logic in loading      segments_N file */
DECL|field|defaultGenFileRetryCount
specifier|private
specifier|static
name|int
name|defaultGenFileRetryCount
init|=
literal|10
decl_stmt|;
DECL|field|defaultGenFileRetryPauseMsec
specifier|private
specifier|static
name|int
name|defaultGenFileRetryPauseMsec
init|=
literal|50
decl_stmt|;
DECL|field|defaultGenLookaheadCount
specifier|private
specifier|static
name|int
name|defaultGenLookaheadCount
init|=
literal|10
decl_stmt|;
comment|/**    * Advanced: set how many times to try loading the    * segments.gen file contents to determine current segment    * generation.  This file is only referenced when the    * primary method (listing the directory) fails.    */
DECL|method|setDefaultGenFileRetryCount
specifier|public
specifier|static
name|void
name|setDefaultGenFileRetryCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|defaultGenFileRetryCount
operator|=
name|count
expr_stmt|;
block|}
comment|/**    * @see #setDefaultGenFileRetryCount    */
DECL|method|getDefaultGenFileRetryCount
specifier|public
specifier|static
name|int
name|getDefaultGenFileRetryCount
parameter_list|()
block|{
return|return
name|defaultGenFileRetryCount
return|;
block|}
comment|/**    * Advanced: set how many milliseconds to pause in between    * attempts to load the segments.gen file.    */
DECL|method|setDefaultGenFileRetryPauseMsec
specifier|public
specifier|static
name|void
name|setDefaultGenFileRetryPauseMsec
parameter_list|(
name|int
name|msec
parameter_list|)
block|{
name|defaultGenFileRetryPauseMsec
operator|=
name|msec
expr_stmt|;
block|}
comment|/**    * @see #setDefaultGenFileRetryPauseMsec    */
DECL|method|getDefaultGenFileRetryPauseMsec
specifier|public
specifier|static
name|int
name|getDefaultGenFileRetryPauseMsec
parameter_list|()
block|{
return|return
name|defaultGenFileRetryPauseMsec
return|;
block|}
comment|/**    * Advanced: set how many times to try incrementing the    * gen when loading the segments file.  This only runs if    * the primary (listing directory) and secondary (opening    * segments.gen file) methods fail to find the segments    * file.    */
DECL|method|setDefaultGenLookaheadCount
specifier|public
specifier|static
name|void
name|setDefaultGenLookaheadCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|defaultGenLookaheadCount
operator|=
name|count
expr_stmt|;
block|}
comment|/**    * @see #setDefaultGenLookaheadCount    */
DECL|method|getDefaultGenLookahedCount
specifier|public
specifier|static
name|int
name|getDefaultGenLookahedCount
parameter_list|()
block|{
return|return
name|defaultGenLookaheadCount
return|;
block|}
comment|/**    * @see #setInfoStream    */
DECL|method|getInfoStream
specifier|public
specifier|static
name|PrintStream
name|getInfoStream
parameter_list|()
block|{
return|return
name|infoStream
return|;
block|}
comment|/**    * Prints the given message to the infoStream. Note, this method does not    * check for null infoStream. It assumes this check has been performed by the    * caller, which is recommended to avoid the (usually) expensive message    * creation.    */
DECL|method|message
specifier|private
specifier|static
name|void
name|message
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|infoStream
operator|.
name|println
argument_list|(
literal|"SIS ["
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"]: "
operator|+
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**    * Utility class for executing code that needs to do    * something with the current segments file.  This is    * necessary with lock-less commits because from the time    * you locate the current segments file name, until you    * actually open it, read its contents, or check modified    * time, etc., it could have been deleted due to a writer    * commit finishing.    */
DECL|class|FindSegmentsFile
specifier|public
specifier|abstract
specifier|static
class|class
name|FindSegmentsFile
block|{
DECL|field|directory
specifier|final
name|Directory
name|directory
decl_stmt|;
DECL|method|FindSegmentsFile
specifier|public
name|FindSegmentsFile
parameter_list|(
name|Directory
name|directory
parameter_list|)
block|{
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
block|}
DECL|method|run
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|run
argument_list|(
literal|null
argument_list|)
return|;
block|}
DECL|method|run
specifier|public
name|Object
name|run
parameter_list|(
name|IndexCommit
name|commit
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
if|if
condition|(
name|commit
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|directory
operator|!=
name|commit
operator|.
name|getDirectory
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"the specified commit does not match the specified Directory"
argument_list|)
throw|;
return|return
name|doBody
argument_list|(
name|commit
operator|.
name|getSegmentsFileName
argument_list|()
argument_list|)
return|;
block|}
name|String
name|segmentFileName
init|=
literal|null
decl_stmt|;
name|long
name|lastGen
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|gen
init|=
literal|0
decl_stmt|;
name|int
name|genLookaheadCount
init|=
literal|0
decl_stmt|;
name|IOException
name|exc
init|=
literal|null
decl_stmt|;
name|int
name|retryCount
init|=
literal|0
decl_stmt|;
name|boolean
name|useFirstMethod
init|=
literal|true
decl_stmt|;
comment|// Loop until we succeed in calling doBody() without
comment|// hitting an IOException.  An IOException most likely
comment|// means a commit was in process and has finished, in
comment|// the time it took us to load the now-old infos files
comment|// (and segments files).  It's also possible it's a
comment|// true error (corrupt index).  To distinguish these,
comment|// on each retry we must see "forward progress" on
comment|// which generation we are trying to load.  If we
comment|// don't, then the original error is real and we throw
comment|// it.
comment|// We have three methods for determining the current
comment|// generation.  We try the first two in parallel (when
comment|// useFirstMethod is true), and fall back to the third
comment|// when necessary.
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|useFirstMethod
condition|)
block|{
comment|// List the directory and use the highest
comment|// segments_N file.  This method works well as long
comment|// as there is no stale caching on the directory
comment|// contents (NOTE: NFS clients often have such stale
comment|// caching):
name|String
index|[]
name|files
init|=
literal|null
decl_stmt|;
name|long
name|genA
init|=
operator|-
literal|1
decl_stmt|;
name|files
operator|=
name|directory
operator|.
name|listAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|files
operator|!=
literal|null
condition|)
block|{
name|genA
operator|=
name|getCurrentSegmentGeneration
argument_list|(
name|files
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"directory listing genA="
operator|+
name|genA
argument_list|)
expr_stmt|;
block|}
comment|// Also open segments.gen and read its
comment|// contents.  Then we take the larger of the two
comment|// gens.  This way, if either approach is hitting
comment|// a stale cache (NFS) we have a better chance of
comment|// getting the right generation.
name|long
name|genB
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|defaultGenFileRetryCount
condition|;
name|i
operator|++
control|)
block|{
name|IndexInput
name|genInput
init|=
literal|null
decl_stmt|;
try|try
block|{
name|genInput
operator|=
name|directory
operator|.
name|openInput
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS_GEN
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"segments.gen open: FileNotFoundException "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"segments.gen open: IOException "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|genInput
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|int
name|version
init|=
name|genInput
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|version
operator|==
name|FORMAT_SEGMENTS_GEN_CURRENT
condition|)
block|{
name|long
name|gen0
init|=
name|genInput
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|long
name|gen1
init|=
name|genInput
operator|.
name|readLong
argument_list|()
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"fallback check: "
operator|+
name|gen0
operator|+
literal|"; "
operator|+
name|gen1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gen0
operator|==
name|gen1
condition|)
block|{
comment|// The file is consistent.
name|genB
operator|=
name|gen0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* TODO: Investigate this!                    throw new IndexFormatTooNewException("segments.gen version number invalid: " + version +                     " (must be " + FORMAT_SEGMENTS_GEN_CURRENT + ")");                   */
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|err2
parameter_list|)
block|{
comment|// rethrow any format exception
if|if
condition|(
name|err2
operator|instanceof
name|CorruptIndexException
condition|)
throw|throw
name|err2
throw|;
comment|// else will retry
block|}
finally|finally
block|{
name|genInput
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|defaultGenFileRetryPauseMsec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|ThreadInterruptedException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS_GEN
operator|+
literal|" check: genB="
operator|+
name|genB
argument_list|)
expr_stmt|;
block|}
comment|// Pick the larger of the two gen's:
name|gen
operator|=
name|Math
operator|.
name|max
argument_list|(
name|genA
argument_list|,
name|genB
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Neither approach found a generation
throw|throw
operator|new
name|IndexNotFoundException
argument_list|(
literal|"no segments* file found in "
operator|+
name|directory
operator|+
literal|": files: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|files
argument_list|)
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|useFirstMethod
operator|&&
name|lastGen
operator|==
name|gen
operator|&&
name|retryCount
operator|>=
literal|2
condition|)
block|{
comment|// Give up on first method -- this is 3rd cycle on
comment|// listing directory and checking gen file to
comment|// attempt to locate the segments file.
name|useFirstMethod
operator|=
literal|false
expr_stmt|;
block|}
comment|// Second method: since both directory cache and
comment|// file contents cache seem to be stale, just
comment|// advance the generation.
if|if
condition|(
operator|!
name|useFirstMethod
condition|)
block|{
if|if
condition|(
name|genLookaheadCount
operator|<
name|defaultGenLookaheadCount
condition|)
block|{
name|gen
operator|++
expr_stmt|;
name|genLookaheadCount
operator|++
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"look ahead increment gen to "
operator|+
name|gen
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// All attempts have failed -- throw first exc:
throw|throw
name|exc
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|lastGen
operator|==
name|gen
condition|)
block|{
comment|// This means we're about to try the same
comment|// segments_N last tried.
name|retryCount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// Segment file has advanced since our last loop
comment|// (we made "progress"), so reset retryCount:
name|retryCount
operator|=
literal|0
expr_stmt|;
block|}
name|lastGen
operator|=
name|gen
expr_stmt|;
name|segmentFileName
operator|=
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|gen
argument_list|)
expr_stmt|;
try|try
block|{
name|Object
name|v
init|=
name|doBody
argument_list|(
name|segmentFileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"success on "
operator|+
name|segmentFileName
argument_list|)
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|err
parameter_list|)
block|{
comment|// Save the original root cause:
if|if
condition|(
name|exc
operator|==
literal|null
condition|)
block|{
name|exc
operator|=
name|err
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"primary Exception on '"
operator|+
name|segmentFileName
operator|+
literal|"': "
operator|+
name|err
operator|+
literal|"'; will retry: retryCount="
operator|+
name|retryCount
operator|+
literal|"; gen = "
operator|+
name|gen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gen
operator|>
literal|1
operator|&&
name|useFirstMethod
operator|&&
name|retryCount
operator|==
literal|1
condition|)
block|{
comment|// This is our second time trying this same segments
comment|// file (because retryCount is 1), and, there is
comment|// possibly a segments_(N-1) (because gen> 1).
comment|// So, check if the segments_(N-1) exists and
comment|// try it if so:
name|String
name|prevSegmentFileName
init|=
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|gen
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|prevExists
decl_stmt|;
name|prevExists
operator|=
name|directory
operator|.
name|fileExists
argument_list|(
name|prevSegmentFileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevExists
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"fallback to prior segment file '"
operator|+
name|prevSegmentFileName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Object
name|v
init|=
name|doBody
argument_list|(
name|prevSegmentFileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"success on fallback "
operator|+
name|prevSegmentFileName
argument_list|)
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|err2
parameter_list|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"secondary Exception on '"
operator|+
name|prevSegmentFileName
operator|+
literal|"': "
operator|+
name|err2
operator|+
literal|"'; will retry"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**      * Subclass must implement this.  The assumption is an      * IOException will be thrown if something goes wrong      * during the processing that could have been caused by      * a writer committing.      */
DECL|method|doBody
specifier|protected
specifier|abstract
name|Object
name|doBody
parameter_list|(
name|String
name|segmentFileName
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
function_decl|;
block|}
comment|// Carry over generation numbers from another SegmentInfos
DECL|method|updateGeneration
name|void
name|updateGeneration
parameter_list|(
name|SegmentInfos
name|other
parameter_list|)
block|{
name|lastGeneration
operator|=
name|other
operator|.
name|lastGeneration
expr_stmt|;
name|generation
operator|=
name|other
operator|.
name|generation
expr_stmt|;
name|lastGlobalFieldMapVersion
operator|=
name|other
operator|.
name|lastGlobalFieldMapVersion
expr_stmt|;
name|globalFieldMapVersion
operator|=
name|other
operator|.
name|globalFieldMapVersion
expr_stmt|;
block|}
DECL|method|rollbackCommit
specifier|final
name|void
name|rollbackCommit
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pendingSegnOutput
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|pendingSegnOutput
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress so we keep throwing the original exception
comment|// in our caller
block|}
comment|// Must carefully compute fileName from "generation"
comment|// since lastGeneration isn't incremented:
try|try
block|{
specifier|final
name|String
name|segmentFileName
init|=
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|generation
argument_list|)
decl_stmt|;
name|dir
operator|.
name|deleteFile
argument_list|(
name|segmentFileName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress so we keep throwing the original exception
comment|// in our caller
block|}
name|pendingSegnOutput
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|pendingMapVersion
operator|!=
operator|-
literal|1
condition|)
block|{
try|try
block|{
specifier|final
name|String
name|fieldMapName
init|=
name|getGlobalFieldNumberName
argument_list|(
name|globalFieldMapVersion
operator|--
argument_list|)
decl_stmt|;
name|dir
operator|.
name|deleteFile
argument_list|(
name|fieldMapName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress so we keep throwing the original exception
comment|// in our caller
block|}
name|pendingMapVersion
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/** Call this to start a commit.  This writes the new    *  segments file, but writes an invalid checksum at the    *  end, so that it is not visible to readers.  Once this    *  is called you must call {@link #finishCommit} to complete    *  the commit or {@link #rollbackCommit} to abort it.    *<p>    *  Note: {@link #changed()} should be called prior to this    *  method if changes have been made to this {@link SegmentInfos} instance    *</p>      **/
DECL|method|prepareCommit
specifier|final
name|void
name|prepareCommit
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pendingSegnOutput
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"prepareCommit was already called"
argument_list|)
throw|;
name|write
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
DECL|method|writeGlobalFieldMap
specifier|private
specifier|final
name|long
name|writeGlobalFieldMap
parameter_list|(
name|FieldNumberBiMap
name|map
parameter_list|,
name|Directory
name|dir
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|long
name|version
decl_stmt|;
try|try
block|{
name|version
operator|=
name|map
operator|.
name|write
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// throw orig excp
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
try|try
block|{
name|dir
operator|.
name|deleteFile
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// throw orig excp
block|}
block|}
else|else
block|{
comment|// we must sync here explicitly since during a commit
comment|// IW will not sync the global field map.
name|dir
operator|.
name|sync
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|version
return|;
block|}
DECL|method|readGlobalFieldMap
specifier|private
name|void
name|readGlobalFieldMap
parameter_list|(
name|FieldNumberBiMap
name|map
parameter_list|,
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|name
init|=
name|getGlobalFieldNumberName
argument_list|(
name|lastGlobalFieldMapVersion
argument_list|)
decl_stmt|;
specifier|final
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
name|name
argument_list|)
decl_stmt|;
try|try
block|{
name|map
operator|.
name|read
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Returns all file names referenced by SegmentInfo    *  instances matching the provided Directory (ie files    *  associated with any "external" segments are skipped).    *  The returned collection is recomputed on each    *  invocation.  */
DECL|method|files
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|files
parameter_list|(
name|Directory
name|dir
parameter_list|,
name|boolean
name|includeSegmentsFile
parameter_list|)
throws|throws
name|IOException
block|{
name|HashSet
argument_list|<
name|String
argument_list|>
name|files
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|includeSegmentsFile
condition|)
block|{
specifier|final
name|String
name|segmentFileName
init|=
name|getCurrentSegmentFileName
argument_list|()
decl_stmt|;
if|if
condition|(
name|segmentFileName
operator|!=
literal|null
condition|)
block|{
comment|/*          * TODO: if lastGen == -1 we get might get null here it seems wrong to          * add null to the files set          */
name|files
operator|.
name|add
argument_list|(
name|segmentFileName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastGlobalFieldMapVersion
operator|>
literal|0
condition|)
block|{
name|files
operator|.
name|add
argument_list|(
name|getGlobalFieldNumberName
argument_list|(
name|lastGlobalFieldMapVersion
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|size
init|=
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentInfo
name|info
init|=
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|dir
operator|==
name|dir
condition|)
block|{
name|files
operator|.
name|addAll
argument_list|(
name|info
argument_list|(
name|i
argument_list|)
operator|.
name|files
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|files
return|;
block|}
DECL|method|finishCommit
specifier|final
name|void
name|finishCommit
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pendingSegnOutput
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"prepareCommit was not called"
argument_list|)
throw|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|SegmentInfosWriter
name|infosWriter
init|=
name|codecs
operator|.
name|getSegmentInfosWriter
argument_list|()
decl_stmt|;
name|infosWriter
operator|.
name|finishCommit
argument_list|(
name|pendingSegnOutput
argument_list|)
expr_stmt|;
name|pendingSegnOutput
operator|=
literal|null
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
name|rollbackCommit
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
comment|// NOTE: if we crash here, we have left a segments_N
comment|// file in the directory in a possibly corrupt state (if
comment|// some bytes made it to stable storage and others
comment|// didn't).  But, the segments_N file includes checksum
comment|// at the end, which should catch this case.  So when a
comment|// reader tries to read it, it will throw a
comment|// CorruptIndexException, which should cause the retry
comment|// logic in SegmentInfos to kick in and load the last
comment|// good (previous) segments_N-1 file.
specifier|final
name|String
name|fileName
init|=
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|generation
argument_list|)
decl_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|dir
operator|.
name|sync
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
try|try
block|{
name|dir
operator|.
name|deleteFile
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress so we keep throwing the original exception
block|}
block|}
block|}
name|lastGeneration
operator|=
name|generation
expr_stmt|;
if|if
condition|(
name|pendingMapVersion
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/*        * TODO is it possible that the commit does not succeed here? if another        * commit happens at the same time and we lost the race between the        * prepareCommit and finishCommit the latest version is already        * incremented.        */
name|globalFieldNumberMap
operator|.
name|commitLastVersion
argument_list|(
name|pendingMapVersion
argument_list|)
expr_stmt|;
name|pendingMapVersion
operator|=
operator|-
literal|1
expr_stmt|;
name|lastGlobalFieldMapVersion
operator|=
name|globalFieldMapVersion
expr_stmt|;
block|}
try|try
block|{
name|IndexOutput
name|genOutput
init|=
name|dir
operator|.
name|createOutput
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS_GEN
argument_list|)
decl_stmt|;
try|try
block|{
name|genOutput
operator|.
name|writeInt
argument_list|(
name|FORMAT_SEGMENTS_GEN_CURRENT
argument_list|)
expr_stmt|;
name|genOutput
operator|.
name|writeLong
argument_list|(
name|generation
argument_list|)
expr_stmt|;
name|genOutput
operator|.
name|writeLong
argument_list|(
name|generation
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|genOutput
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ThreadInterruptedException
name|t
parameter_list|)
block|{
throw|throw
name|t
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// It's OK if we fail to write this file since it's
comment|// used only as one of the retry fallbacks.
block|}
block|}
comment|/** Writes& syncs to the Directory dir, taking care to    *  remove the segments file on exception    *<p>    *  Note: {@link #changed()} should be called prior to this    *  method if changes have been made to this {@link SegmentInfos} instance    *</p>      **/
DECL|method|commit
specifier|final
name|void
name|commit
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
name|prepareCommit
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|finishCommit
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|(
name|Directory
name|directory
parameter_list|)
block|{
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|getCurrentSegmentFileName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
specifier|final
name|int
name|count
init|=
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SegmentInfo
name|info
init|=
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|info
operator|.
name|toString
argument_list|(
name|directory
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getUserData
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getUserData
parameter_list|()
block|{
return|return
name|userData
return|;
block|}
DECL|method|setUserData
name|void
name|setUserData
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|userData
operator|=
name|Collections
operator|.
expr|<
name|String
operator|,
name|String
operator|>
name|emptyMap
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|userData
operator|=
name|data
expr_stmt|;
block|}
block|}
comment|/** Replaces all segments in this instance, but keeps    *  generation, version, counter so that future commits    *  remain write once.    */
DECL|method|replace
name|void
name|replace
parameter_list|(
name|SegmentInfos
name|other
parameter_list|)
block|{
name|rollbackSegmentInfos
argument_list|(
name|other
operator|.
name|asList
argument_list|()
argument_list|)
expr_stmt|;
name|lastGeneration
operator|=
name|other
operator|.
name|lastGeneration
expr_stmt|;
name|lastGlobalFieldMapVersion
operator|=
name|other
operator|.
name|lastGlobalFieldMapVersion
expr_stmt|;
name|format
operator|=
name|other
operator|.
name|format
expr_stmt|;
block|}
comment|/** Returns sum of all segment's docCounts.  Note that    *  this does not include deletions */
DECL|method|totalDocCount
specifier|public
name|int
name|totalDocCount
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SegmentInfo
name|info
range|:
name|this
control|)
block|{
name|count
operator|+=
name|info
operator|.
name|docCount
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/** Call this before committing if changes have been made to the    *  segments. */
DECL|method|changed
specifier|public
name|void
name|changed
parameter_list|()
block|{
name|version
operator|++
expr_stmt|;
block|}
comment|/**    * Loads or returns the already loaded the global field number map for this {@link SegmentInfos}.    * If this {@link SegmentInfos} has no global field number map the returned instance is empty    */
DECL|method|getOrLoadGlobalFieldNumberMap
name|FieldNumberBiMap
name|getOrLoadGlobalFieldNumberMap
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|globalFieldNumberMap
operator|!=
literal|null
condition|)
block|{
return|return
name|globalFieldNumberMap
return|;
block|}
specifier|final
name|FieldNumberBiMap
name|map
init|=
operator|new
name|FieldNumberBiMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastGlobalFieldMapVersion
operator|>
literal|0
condition|)
block|{
comment|// if we don't have a global map or this is a SI from a earlier version we just return the empty map;
name|readGlobalFieldMap
argument_list|(
name|map
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|format
operator|>
name|DefaultSegmentInfosWriter
operator|.
name|FORMAT_4_0
condition|)
block|{
assert|assert
name|lastGlobalFieldMapVersion
operator|==
literal|0
assert|;
comment|// build the map up if we open a pre 4.0 index
for|for
control|(
name|SegmentInfo
name|info
range|:
name|this
control|)
block|{
specifier|final
name|FieldInfos
name|segFieldInfos
init|=
name|info
operator|.
name|getFieldInfos
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldInfo
name|fi
range|:
name|segFieldInfos
control|)
block|{
name|map
operator|.
name|addOrGet
argument_list|(
name|fi
operator|.
name|name
argument_list|,
name|fi
operator|.
name|number
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|globalFieldNumberMap
operator|=
name|map
return|;
block|}
comment|/**    * Called by {@link SegmentInfosReader} when reading the global field map version    */
DECL|method|setGlobalFieldMapVersion
specifier|public
name|void
name|setGlobalFieldMapVersion
parameter_list|(
name|long
name|version
parameter_list|)
block|{
name|lastGlobalFieldMapVersion
operator|=
name|globalFieldMapVersion
operator|=
name|version
expr_stmt|;
block|}
DECL|method|getGlobalFieldMapVersion
specifier|public
name|long
name|getGlobalFieldMapVersion
parameter_list|()
block|{
return|return
name|globalFieldMapVersion
return|;
block|}
comment|// for testing
DECL|method|getLastGlobalFieldMapVersion
name|long
name|getLastGlobalFieldMapVersion
parameter_list|()
block|{
return|return
name|lastGlobalFieldMapVersion
return|;
block|}
comment|/** applies all changes caused by committing a merge to this SegmentInfos */
DECL|method|applyMergeChanges
name|void
name|applyMergeChanges
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|,
name|boolean
name|dropSegment
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|SegmentInfo
argument_list|>
name|mergedAway
init|=
operator|new
name|HashSet
argument_list|<
name|SegmentInfo
argument_list|>
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
decl_stmt|;
name|boolean
name|inserted
init|=
literal|false
decl_stmt|;
name|int
name|newSegIdx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|segIdx
init|=
literal|0
init|,
name|cnt
init|=
name|segments
operator|.
name|size
argument_list|()
init|;
name|segIdx
operator|<
name|cnt
condition|;
name|segIdx
operator|++
control|)
block|{
assert|assert
name|segIdx
operator|>=
name|newSegIdx
assert|;
specifier|final
name|SegmentInfo
name|info
init|=
name|segments
operator|.
name|get
argument_list|(
name|segIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergedAway
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inserted
operator|&&
operator|!
name|dropSegment
condition|)
block|{
name|segments
operator|.
name|set
argument_list|(
name|segIdx
argument_list|,
name|merge
operator|.
name|info
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|true
expr_stmt|;
name|newSegIdx
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|segments
operator|.
name|set
argument_list|(
name|newSegIdx
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|newSegIdx
operator|++
expr_stmt|;
block|}
block|}
comment|// Either we found place to insert segment, or, we did
comment|// not, but only because all segments we merged became
comment|// deleted while we are merging, in which case it should
comment|// be the case that the new segment is also all deleted,
comment|// we insert it at the beginning if it should not be dropped:
if|if
condition|(
operator|!
name|inserted
operator|&&
operator|!
name|dropSegment
condition|)
block|{
name|segments
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|merge
operator|.
name|info
argument_list|)
expr_stmt|;
block|}
comment|// the rest of the segments in list are duplicates, so don't remove from map, only list!
name|segments
operator|.
name|subList
argument_list|(
name|newSegIdx
argument_list|,
name|segments
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// update the Set
if|if
condition|(
operator|!
name|dropSegment
condition|)
block|{
name|segmentSet
operator|.
name|add
argument_list|(
name|merge
operator|.
name|info
argument_list|)
expr_stmt|;
block|}
name|segmentSet
operator|.
name|removeAll
argument_list|(
name|mergedAway
argument_list|)
expr_stmt|;
assert|assert
name|segmentSet
operator|.
name|size
argument_list|()
operator|==
name|segments
operator|.
name|size
argument_list|()
assert|;
block|}
DECL|method|createBackupSegmentInfos
name|List
argument_list|<
name|SegmentInfo
argument_list|>
name|createBackupSegmentInfos
parameter_list|(
name|boolean
name|cloneChildren
parameter_list|)
block|{
if|if
condition|(
name|cloneChildren
condition|)
block|{
specifier|final
name|List
argument_list|<
name|SegmentInfo
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentInfo
argument_list|>
argument_list|(
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|SegmentInfo
name|info
range|:
name|this
control|)
block|{
assert|assert
name|info
operator|.
name|getSegmentCodecs
argument_list|()
operator|!=
literal|null
assert|;
name|list
operator|.
name|add
argument_list|(
operator|(
name|SegmentInfo
operator|)
name|info
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
else|else
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|SegmentInfo
argument_list|>
argument_list|(
name|segments
argument_list|)
return|;
block|}
block|}
DECL|method|rollbackSegmentInfos
name|void
name|rollbackSegmentInfos
parameter_list|(
name|List
argument_list|<
name|SegmentInfo
argument_list|>
name|infos
parameter_list|)
block|{
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|addAll
argument_list|(
name|infos
argument_list|)
expr_stmt|;
block|}
comment|/** Returns an<b>unmodifiable</b> {@link Iterator} of contained segments in order. */
comment|// @Override (comment out until Java 6)
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|SegmentInfo
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|asList
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/** Returns all contained segments as an<b>unmodifiable</b> {@link List} view. */
DECL|method|asList
specifier|public
name|List
argument_list|<
name|SegmentInfo
argument_list|>
name|asList
parameter_list|()
block|{
if|if
condition|(
name|cachedUnmodifiableList
operator|==
literal|null
condition|)
block|{
name|cachedUnmodifiableList
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|segments
argument_list|)
expr_stmt|;
block|}
return|return
name|cachedUnmodifiableList
return|;
block|}
comment|/** Returns all contained segments as an<b>unmodifiable</b> {@link Set} view.    * The iterator is not sorted, use {@link List} view or {@link #iterator} to get all segments in order. */
DECL|method|asSet
specifier|public
name|Set
argument_list|<
name|SegmentInfo
argument_list|>
name|asSet
parameter_list|()
block|{
if|if
condition|(
name|cachedUnmodifiableSet
operator|==
literal|null
condition|)
block|{
name|cachedUnmodifiableSet
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|segmentSet
argument_list|)
expr_stmt|;
block|}
return|return
name|cachedUnmodifiableSet
return|;
block|}
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|segments
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|SegmentInfo
name|si
parameter_list|)
block|{
if|if
condition|(
name|segmentSet
operator|.
name|contains
argument_list|(
name|si
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot add the same segment two times to this SegmentInfos instance"
argument_list|)
throw|;
block|}
name|segments
operator|.
name|add
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|segmentSet
operator|.
name|add
argument_list|(
name|si
argument_list|)
expr_stmt|;
assert|assert
name|segmentSet
operator|.
name|size
argument_list|()
operator|==
name|segments
operator|.
name|size
argument_list|()
assert|;
block|}
DECL|method|addAll
specifier|public
name|void
name|addAll
parameter_list|(
name|Iterable
argument_list|<
name|SegmentInfo
argument_list|>
name|sis
parameter_list|)
block|{
for|for
control|(
specifier|final
name|SegmentInfo
name|si
range|:
name|sis
control|)
block|{
name|this
operator|.
name|add
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|segments
operator|.
name|clear
argument_list|()
expr_stmt|;
name|segmentSet
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|(
name|SegmentInfo
name|si
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|this
operator|.
name|indexOf
argument_list|(
name|si
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|this
operator|.
name|remove
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|segmentSet
operator|.
name|remove
argument_list|(
name|segments
operator|.
name|remove
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
assert|assert
name|segmentSet
operator|.
name|size
argument_list|()
operator|==
name|segments
operator|.
name|size
argument_list|()
assert|;
block|}
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|SegmentInfo
name|si
parameter_list|)
block|{
return|return
name|segmentSet
operator|.
name|contains
argument_list|(
name|si
argument_list|)
return|;
block|}
DECL|method|indexOf
specifier|public
name|int
name|indexOf
parameter_list|(
name|SegmentInfo
name|si
parameter_list|)
block|{
if|if
condition|(
name|segmentSet
operator|.
name|contains
argument_list|(
name|si
argument_list|)
condition|)
block|{
return|return
name|segments
operator|.
name|indexOf
argument_list|(
name|si
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
end_class
end_unit
