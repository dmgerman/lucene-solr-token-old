begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Constants
import|;
end_import
begin_class
DECL|class|DocumentsWriterRAMAllocator
class|class
name|DocumentsWriterRAMAllocator
block|{
DECL|field|byteBlockAllocator
specifier|final
name|ByteBlockAllocator
name|byteBlockAllocator
init|=
operator|new
name|ByteBlockAllocator
argument_list|(
name|BYTE_BLOCK_SIZE
argument_list|)
decl_stmt|;
DECL|field|perDocAllocator
specifier|final
name|ByteBlockAllocator
name|perDocAllocator
init|=
operator|new
name|ByteBlockAllocator
argument_list|(
name|PER_DOC_BLOCK_SIZE
argument_list|)
decl_stmt|;
DECL|class|ByteBlockAllocator
class|class
name|ByteBlockAllocator
extends|extends
name|ByteBlockPool
operator|.
name|Allocator
block|{
DECL|field|blockSize
specifier|final
name|int
name|blockSize
decl_stmt|;
DECL|method|ByteBlockAllocator
name|ByteBlockAllocator
parameter_list|(
name|int
name|blockSize
parameter_list|)
block|{
name|this
operator|.
name|blockSize
operator|=
name|blockSize
expr_stmt|;
block|}
DECL|field|freeByteBlocks
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|freeByteBlocks
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
comment|/* Allocate another byte[] from the shared pool */
annotation|@
name|Override
DECL|method|getByteBlock
name|byte
index|[]
name|getByteBlock
parameter_list|()
block|{
specifier|final
name|int
name|size
init|=
name|freeByteBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|b
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|size
condition|)
block|{
name|b
operator|=
operator|new
name|byte
index|[
name|blockSize
index|]
expr_stmt|;
comment|// Always record a block allocated, even if
comment|// trackAllocations is false.  This is necessary
comment|// because this block will be shared between
comment|// things that don't track allocations (term
comment|// vectors) and things that do (freq/prox
comment|// postings).
name|numBytesUsed
operator|+=
name|blockSize
expr_stmt|;
block|}
else|else
name|b
operator|=
name|freeByteBlocks
operator|.
name|remove
argument_list|(
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
comment|/* Return byte[]'s to the pool */
annotation|@
name|Override
DECL|method|recycleByteBlocks
name|void
name|recycleByteBlocks
parameter_list|(
name|byte
index|[]
index|[]
name|blocks
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|freeByteBlocks
operator|.
name|add
argument_list|(
name|blocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|recycleByteBlocks
name|void
name|recycleByteBlocks
parameter_list|(
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|blocks
parameter_list|)
block|{
specifier|final
name|int
name|size
init|=
name|blocks
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|freeByteBlocks
operator|.
name|add
argument_list|(
name|blocks
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|field|freeIntBlocks
specifier|private
name|ArrayList
argument_list|<
name|int
index|[]
argument_list|>
name|freeIntBlocks
init|=
operator|new
name|ArrayList
argument_list|<
name|int
index|[]
argument_list|>
argument_list|()
decl_stmt|;
comment|/* Allocate another int[] from the shared pool */
DECL|method|getIntBlock
name|int
index|[]
name|getIntBlock
parameter_list|()
block|{
specifier|final
name|int
name|size
init|=
name|freeIntBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
index|[]
name|b
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|size
condition|)
block|{
name|b
operator|=
operator|new
name|int
index|[
name|INT_BLOCK_SIZE
index|]
expr_stmt|;
comment|// Always record a block allocated, even if
comment|// trackAllocations is false.  This is necessary
comment|// because this block will be shared between
comment|// things that don't track allocations (term
comment|// vectors) and things that do (freq/prox
comment|// postings).
name|numBytesUsed
operator|+=
name|INT_BLOCK_SIZE
operator|*
name|INT_NUM_BYTE
expr_stmt|;
block|}
else|else
name|b
operator|=
name|freeIntBlocks
operator|.
name|remove
argument_list|(
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
DECL|method|bytesUsed
name|void
name|bytesUsed
parameter_list|(
name|long
name|numBytes
parameter_list|)
block|{
name|numBytesUsed
operator|+=
name|numBytes
expr_stmt|;
block|}
comment|/* Return int[]s to the pool */
DECL|method|recycleIntBlocks
name|void
name|recycleIntBlocks
parameter_list|(
name|int
index|[]
index|[]
name|blocks
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
name|freeIntBlocks
operator|.
name|add
argument_list|(
name|blocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
DECL|method|getRAMUsed
name|long
name|getRAMUsed
parameter_list|()
block|{
return|return
name|numBytesUsed
return|;
block|}
DECL|field|numBytesUsed
name|long
name|numBytesUsed
decl_stmt|;
DECL|field|nf
name|NumberFormat
name|nf
init|=
name|NumberFormat
operator|.
name|getInstance
argument_list|()
decl_stmt|;
DECL|field|PER_DOC_BLOCK_SIZE
specifier|final
specifier|static
name|int
name|PER_DOC_BLOCK_SIZE
init|=
literal|1024
decl_stmt|;
comment|// Coarse estimates used to measure RAM usage of buffered deletes
DECL|field|OBJECT_HEADER_BYTES
specifier|final
specifier|static
name|int
name|OBJECT_HEADER_BYTES
init|=
literal|8
decl_stmt|;
DECL|field|POINTER_NUM_BYTE
specifier|final
specifier|static
name|int
name|POINTER_NUM_BYTE
init|=
name|Constants
operator|.
name|JRE_IS_64BIT
condition|?
literal|8
else|:
literal|4
decl_stmt|;
DECL|field|INT_NUM_BYTE
specifier|final
specifier|static
name|int
name|INT_NUM_BYTE
init|=
literal|4
decl_stmt|;
DECL|field|CHAR_NUM_BYTE
specifier|final
specifier|static
name|int
name|CHAR_NUM_BYTE
init|=
literal|2
decl_stmt|;
comment|/* Rough logic: HashMap has an array[Entry] w/ varying      load factor (say 2 * POINTER).  Entry is object w/ Term      key, BufferedDeletes.Num val, int hash, Entry next      (OBJ_HEADER + 3*POINTER + INT).  Term is object w/      String field and String text (OBJ_HEADER + 2*POINTER).      We don't count Term's field since it's interned.      Term's text is String (OBJ_HEADER + 4*INT + POINTER +      OBJ_HEADER + string.length*CHAR).  BufferedDeletes.num is      OBJ_HEADER + INT. */
DECL|field|BYTES_PER_DEL_TERM
specifier|final
specifier|static
name|int
name|BYTES_PER_DEL_TERM
init|=
literal|8
operator|*
name|POINTER_NUM_BYTE
operator|+
literal|5
operator|*
name|OBJECT_HEADER_BYTES
operator|+
literal|6
operator|*
name|INT_NUM_BYTE
decl_stmt|;
comment|/* Rough logic: del docIDs are List<Integer>.  Say list      allocates ~2X size (2*POINTER).  Integer is OBJ_HEADER      + int */
DECL|field|BYTES_PER_DEL_DOCID
specifier|final
specifier|static
name|int
name|BYTES_PER_DEL_DOCID
init|=
literal|2
operator|*
name|POINTER_NUM_BYTE
operator|+
name|OBJECT_HEADER_BYTES
operator|+
name|INT_NUM_BYTE
decl_stmt|;
comment|/* Rough logic: HashMap has an array[Entry] w/ varying      load factor (say 2 * POINTER).  Entry is object w/      Query key, Integer val, int hash, Entry next      (OBJ_HEADER + 3*POINTER + INT).  Query we often      undercount (say 24 bytes).  Integer is OBJ_HEADER + INT. */
DECL|field|BYTES_PER_DEL_QUERY
specifier|final
specifier|static
name|int
name|BYTES_PER_DEL_QUERY
init|=
literal|5
operator|*
name|POINTER_NUM_BYTE
operator|+
literal|2
operator|*
name|OBJECT_HEADER_BYTES
operator|+
literal|2
operator|*
name|INT_NUM_BYTE
operator|+
literal|24
decl_stmt|;
comment|/* Initial chunks size of the shared byte[] blocks used to      store postings data */
DECL|field|BYTE_BLOCK_SHIFT
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_SHIFT
init|=
literal|15
decl_stmt|;
DECL|field|BYTE_BLOCK_SIZE
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_SIZE
init|=
literal|1
operator|<<
name|BYTE_BLOCK_SHIFT
decl_stmt|;
DECL|field|BYTE_BLOCK_MASK
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_MASK
init|=
name|BYTE_BLOCK_SIZE
operator|-
literal|1
decl_stmt|;
DECL|field|BYTE_BLOCK_NOT_MASK
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_NOT_MASK
init|=
operator|~
name|BYTE_BLOCK_MASK
decl_stmt|;
DECL|field|MAX_TERM_LENGTH_UTF8
specifier|final
specifier|static
name|int
name|MAX_TERM_LENGTH_UTF8
init|=
name|BYTE_BLOCK_SIZE
operator|-
literal|2
decl_stmt|;
comment|/* Initial chunks size of the shared int[] blocks used to      store postings data */
DECL|field|INT_BLOCK_SHIFT
specifier|final
specifier|static
name|int
name|INT_BLOCK_SHIFT
init|=
literal|13
decl_stmt|;
DECL|field|INT_BLOCK_SIZE
specifier|final
specifier|static
name|int
name|INT_BLOCK_SIZE
init|=
literal|1
operator|<<
name|INT_BLOCK_SHIFT
decl_stmt|;
DECL|field|INT_BLOCK_MASK
specifier|final
specifier|static
name|int
name|INT_BLOCK_MASK
init|=
name|INT_BLOCK_SIZE
operator|-
literal|1
decl_stmt|;
DECL|method|toMB
name|String
name|toMB
parameter_list|(
name|long
name|v
parameter_list|)
block|{
return|return
name|nf
operator|.
name|format
argument_list|(
name|v
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
return|;
block|}
block|}
end_class
end_unit
