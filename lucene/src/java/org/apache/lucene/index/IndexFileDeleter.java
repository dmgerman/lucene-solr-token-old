begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilenameFilter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|CodecProvider
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|NoSuchDirectoryException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CollectionUtil
import|;
end_import
begin_comment
comment|/*  * This class keeps track of each SegmentInfos instance that  * is still "live", either because it corresponds to a  * segments_N file in the Directory (a "commit", i.e. a  * committed SegmentInfos) or because it's an in-memory  * SegmentInfos that a writer is actively updating but has  * not yet committed.  This class uses simple reference  * counting to map the live SegmentInfos instances to  * individual files in the Directory.  *  * The same directory file may be referenced by more than  * one IndexCommit, i.e. more than one SegmentInfos.  * Therefore we count how many commits reference each file.  * When all the commits referencing a certain file have been  * deleted, the refcount for that file becomes zero, and the  * file is deleted.  *  * A separate deletion policy interface  * (IndexDeletionPolicy) is consulted on creation (onInit)  * and once per commit (onCommit), to decide when a commit  * should be removed.  *  * It is the business of the IndexDeletionPolicy to choose  * when to delete commit points.  The actual mechanics of  * file deletion, retrying, etc, derived from the deletion  * of commit points is the business of the IndexFileDeleter.  *  * The current default deletion policy is {@link  * KeepOnlyLastCommitDeletionPolicy}, which removes all  * prior commits when a new commit has completed.  This  * matches the behavior before 2.2.  *  * Note that you must hold the write.lock before  * instantiating this class.  It opens segments_N file(s)  * directly with no retry logic.  */
end_comment
begin_class
DECL|class|IndexFileDeleter
specifier|final
class|class
name|IndexFileDeleter
block|{
comment|/* Files that we tried to delete but failed (likely    * because they are open and we are running on Windows),    * so we will retry them again later: */
DECL|field|deletable
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|deletable
decl_stmt|;
comment|/* Reference count for all files in the index.    * Counts how many existing commits reference a file.    **/
DECL|field|refCounts
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|RefCount
argument_list|>
name|refCounts
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RefCount
argument_list|>
argument_list|()
decl_stmt|;
comment|/* Holds all commits (segments_N) currently in the index.    * This will have just 1 commit if you are using the    * default delete policy (KeepOnlyLastCommitDeletionPolicy).    * Other policies may leave commit points live for longer    * in which case this list would be longer than 1: */
DECL|field|commits
specifier|private
name|List
argument_list|<
name|CommitPoint
argument_list|>
name|commits
init|=
operator|new
name|ArrayList
argument_list|<
name|CommitPoint
argument_list|>
argument_list|()
decl_stmt|;
comment|/* Holds files we had incref'd from the previous    * non-commit checkpoint: */
DECL|field|lastFiles
specifier|private
name|List
argument_list|<
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
name|lastFiles
init|=
operator|new
name|ArrayList
argument_list|<
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/* Commits that the IndexDeletionPolicy have decided to delete: */
DECL|field|commitsToDelete
specifier|private
name|List
argument_list|<
name|CommitPoint
argument_list|>
name|commitsToDelete
init|=
operator|new
name|ArrayList
argument_list|<
name|CommitPoint
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|infoStream
specifier|private
name|PrintStream
name|infoStream
decl_stmt|;
DECL|field|directory
specifier|private
name|Directory
name|directory
decl_stmt|;
DECL|field|policy
specifier|private
name|IndexDeletionPolicy
name|policy
decl_stmt|;
DECL|field|startingCommitDeleted
specifier|final
name|boolean
name|startingCommitDeleted
decl_stmt|;
DECL|field|lastSegmentInfos
specifier|private
name|SegmentInfos
name|lastSegmentInfos
decl_stmt|;
comment|/** Change to true to see details of reference counts when    *  infoStream != null */
DECL|field|VERBOSE_REF_COUNTS
specifier|public
specifier|static
name|boolean
name|VERBOSE_REF_COUNTS
init|=
literal|false
decl_stmt|;
comment|// Used only for assert
DECL|field|writer
specifier|private
specifier|final
name|IndexWriter
name|writer
decl_stmt|;
DECL|method|setInfoStream
name|void
name|setInfoStream
parameter_list|(
name|PrintStream
name|infoStream
parameter_list|)
block|{
name|this
operator|.
name|infoStream
operator|=
name|infoStream
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"setInfoStream deletionPolicy="
operator|+
name|policy
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|message
specifier|private
name|void
name|message
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|infoStream
operator|.
name|println
argument_list|(
literal|"IFD ["
operator|+
operator|new
name|Date
argument_list|()
operator|+
literal|"; "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"]: "
operator|+
name|message
argument_list|)
expr_stmt|;
block|}
DECL|field|indexFilenameFilter
specifier|private
specifier|final
name|FilenameFilter
name|indexFilenameFilter
decl_stmt|;
comment|// called only from assert
DECL|method|locked
specifier|private
name|boolean
name|locked
parameter_list|()
block|{
return|return
name|writer
operator|==
literal|null
operator|||
name|Thread
operator|.
name|holdsLock
argument_list|(
name|writer
argument_list|)
return|;
block|}
comment|/**    * Initialize the deleter: find all previous commits in    * the Directory, incref the files they reference, call    * the policy to let it delete commits.  This will remove    * any files not referenced by any of the commits.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|IndexFileDeleter
specifier|public
name|IndexFileDeleter
parameter_list|(
name|Directory
name|directory
parameter_list|,
name|IndexDeletionPolicy
name|policy
parameter_list|,
name|SegmentInfos
name|segmentInfos
parameter_list|,
name|PrintStream
name|infoStream
parameter_list|,
name|CodecProvider
name|codecs
parameter_list|,
name|IndexWriter
name|writer
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|this
operator|.
name|infoStream
operator|=
name|infoStream
expr_stmt|;
name|this
operator|.
name|writer
operator|=
name|writer
expr_stmt|;
specifier|final
name|String
name|currentSegmentsFile
init|=
name|segmentInfos
operator|.
name|getCurrentSegmentFileName
argument_list|()
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"init: current segments file is \""
operator|+
name|currentSegmentsFile
operator|+
literal|"\"; deletionPolicy="
operator|+
name|policy
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|policy
operator|=
name|policy
expr_stmt|;
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
comment|// First pass: walk the files and initialize our ref
comment|// counts:
name|long
name|currentGen
init|=
name|segmentInfos
operator|.
name|getGeneration
argument_list|()
decl_stmt|;
name|indexFilenameFilter
operator|=
operator|new
name|IndexFileNameFilter
argument_list|(
name|codecs
argument_list|)
expr_stmt|;
name|CommitPoint
name|currentCommitPoint
init|=
literal|null
decl_stmt|;
name|String
index|[]
name|files
init|=
literal|null
decl_stmt|;
try|try
block|{
name|files
operator|=
name|directory
operator|.
name|listAll
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchDirectoryException
name|e
parameter_list|)
block|{
comment|// it means the directory is empty, so ignore it.
name|files
operator|=
operator|new
name|String
index|[
literal|0
index|]
expr_stmt|;
block|}
for|for
control|(
name|String
name|fileName
range|:
name|files
control|)
block|{
if|if
condition|(
operator|(
name|indexFilenameFilter
operator|.
name|accept
argument_list|(
literal|null
argument_list|,
name|fileName
argument_list|)
operator|)
operator|&&
operator|!
name|fileName
operator|.
name|endsWith
argument_list|(
literal|"write.lock"
argument_list|)
operator|&&
operator|!
name|fileName
operator|.
name|equals
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS_GEN
argument_list|)
condition|)
block|{
comment|// Add this file to refCounts with initial count 0:
name|getRefCount
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileName
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|)
condition|)
block|{
comment|// This is a commit (segments or segments_N), and
comment|// it's valid (<= the max gen).  Load it, then
comment|// incref all files it refers to:
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"init: load commit \""
operator|+
name|fileName
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
name|SegmentInfos
name|sis
init|=
operator|new
name|SegmentInfos
argument_list|(
name|codecs
argument_list|)
decl_stmt|;
try|try
block|{
name|sis
operator|.
name|read
argument_list|(
name|directory
argument_list|,
name|fileName
argument_list|,
name|codecs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// LUCENE-948: on NFS (and maybe others), if
comment|// you have writers switching back and forth
comment|// between machines, it's very likely that the
comment|// dir listing will be stale and will claim a
comment|// file segments_X exists when in fact it
comment|// doesn't.  So, we catch this and handle it
comment|// as if the file does not exist
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"init: hit FileNotFoundException when loading commit \""
operator|+
name|fileName
operator|+
literal|"\"; skipping this commit point"
argument_list|)
expr_stmt|;
block|}
name|sis
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|SegmentInfos
operator|.
name|generationFromSegmentsFileName
argument_list|(
name|fileName
argument_list|)
operator|<=
name|currentGen
condition|)
block|{
throw|throw
name|e
throw|;
block|}
else|else
block|{
comment|// Most likely we are opening an index that
comment|// has an aborted "future" commit, so suppress
comment|// exc in this case
name|sis
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sis
operator|!=
literal|null
condition|)
block|{
specifier|final
name|SegmentInfos
name|infos
init|=
name|sis
decl_stmt|;
for|for
control|(
name|SegmentInfo
name|segmentInfo
range|:
name|infos
control|)
block|{
try|try
block|{
comment|/*                  * Force FI to load for each segment since we could see a                  * segments file and load successfully above if the files are                  * still referenced when they are deleted and the os doesn't let                  * you delete them. Yet its likely that fnm files are removed                  * while seg file is still around Since LUCENE-2984 we need FI                  * to find out if a seg has vectors and prox so we need those                  * files to be opened for a commit point.                  */
name|segmentInfo
operator|.
name|getFieldInfos
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|refresh
argument_list|(
name|segmentInfo
operator|.
name|name
argument_list|)
expr_stmt|;
name|sis
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"init: hit FileNotFoundException when loading commit \""
operator|+
name|fileName
operator|+
literal|"\"; skipping this commit point"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|sis
operator|!=
literal|null
condition|)
block|{
specifier|final
name|CommitPoint
name|commitPoint
init|=
operator|new
name|CommitPoint
argument_list|(
name|commitsToDelete
argument_list|,
name|directory
argument_list|,
name|sis
argument_list|)
decl_stmt|;
if|if
condition|(
name|sis
operator|.
name|getGeneration
argument_list|()
operator|==
name|segmentInfos
operator|.
name|getGeneration
argument_list|()
condition|)
block|{
name|currentCommitPoint
operator|=
name|commitPoint
expr_stmt|;
block|}
name|commits
operator|.
name|add
argument_list|(
name|commitPoint
argument_list|)
expr_stmt|;
name|incRef
argument_list|(
name|sis
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastSegmentInfos
operator|==
literal|null
operator|||
name|sis
operator|.
name|getGeneration
argument_list|()
operator|>
name|lastSegmentInfos
operator|.
name|getGeneration
argument_list|()
condition|)
block|{
name|lastSegmentInfos
operator|=
name|sis
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|currentCommitPoint
operator|==
literal|null
operator|&&
name|currentSegmentsFile
operator|!=
literal|null
condition|)
block|{
comment|// We did not in fact see the segments_N file
comment|// corresponding to the segmentInfos that was passed
comment|// in.  Yet, it must exist, because our caller holds
comment|// the write lock.  This can happen when the directory
comment|// listing was stale (eg when index accessed via NFS
comment|// client with stale directory listing cache).  So we
comment|// try now to explicitly open this commit point:
name|SegmentInfos
name|sis
init|=
operator|new
name|SegmentInfos
argument_list|(
name|codecs
argument_list|)
decl_stmt|;
try|try
block|{
name|sis
operator|.
name|read
argument_list|(
name|directory
argument_list|,
name|currentSegmentsFile
argument_list|,
name|codecs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CorruptIndexException
argument_list|(
literal|"failed to locate current segments_N file"
argument_list|)
throw|;
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"forced open of current segments file "
operator|+
name|segmentInfos
operator|.
name|getCurrentSegmentFileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|currentCommitPoint
operator|=
operator|new
name|CommitPoint
argument_list|(
name|commitsToDelete
argument_list|,
name|directory
argument_list|,
name|sis
argument_list|)
expr_stmt|;
name|commits
operator|.
name|add
argument_list|(
name|currentCommitPoint
argument_list|)
expr_stmt|;
name|incRef
argument_list|(
name|sis
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// We keep commits list in sorted order (oldest to newest):
name|CollectionUtil
operator|.
name|mergeSort
argument_list|(
name|commits
argument_list|)
expr_stmt|;
comment|// Now delete anything with ref count at 0.  These are
comment|// presumably abandoned files eg due to crash of
comment|// IndexWriter.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RefCount
argument_list|>
name|entry
range|:
name|refCounts
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|RefCount
name|rc
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|String
name|fileName
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|rc
operator|.
name|count
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"init: removing unreferenced file \""
operator|+
name|fileName
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
name|deleteFile
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Finally, give policy a chance to remove things on
comment|// startup:
if|if
condition|(
name|currentSegmentsFile
operator|!=
literal|null
condition|)
block|{
name|policy
operator|.
name|onInit
argument_list|(
name|commits
argument_list|)
expr_stmt|;
block|}
comment|// Always protect the incoming segmentInfos since
comment|// sometime it may not be the most recent commit
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|startingCommitDeleted
operator|=
name|currentCommitPoint
operator|==
literal|null
condition|?
literal|false
else|:
name|currentCommitPoint
operator|.
name|isDeleted
argument_list|()
expr_stmt|;
name|deleteCommits
argument_list|()
expr_stmt|;
block|}
DECL|method|getLastSegmentInfos
specifier|public
name|SegmentInfos
name|getLastSegmentInfos
parameter_list|()
block|{
return|return
name|lastSegmentInfos
return|;
block|}
comment|/**    * Remove the CommitPoints in the commitsToDelete List by    * DecRef'ing all files from each SegmentInfos.    */
DECL|method|deleteCommits
specifier|private
name|void
name|deleteCommits
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|size
init|=
name|commitsToDelete
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
comment|// First decref all files that had been referred to by
comment|// the now-deleted commits:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|CommitPoint
name|commit
init|=
name|commitsToDelete
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"deleteCommits: now decRef commit \""
operator|+
name|commit
operator|.
name|getSegmentsFileName
argument_list|()
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|String
name|file
range|:
name|commit
operator|.
name|files
control|)
block|{
name|decRef
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
name|commitsToDelete
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Now compact commits to remove deleted ones (preserving the sort):
name|size
operator|=
name|commits
operator|.
name|size
argument_list|()
expr_stmt|;
name|int
name|readFrom
init|=
literal|0
decl_stmt|;
name|int
name|writeTo
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|readFrom
operator|<
name|size
condition|)
block|{
name|CommitPoint
name|commit
init|=
name|commits
operator|.
name|get
argument_list|(
name|readFrom
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|commit
operator|.
name|deleted
condition|)
block|{
if|if
condition|(
name|writeTo
operator|!=
name|readFrom
condition|)
block|{
name|commits
operator|.
name|set
argument_list|(
name|writeTo
argument_list|,
name|commits
operator|.
name|get
argument_list|(
name|readFrom
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|writeTo
operator|++
expr_stmt|;
block|}
name|readFrom
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|size
operator|>
name|writeTo
condition|)
block|{
name|commits
operator|.
name|remove
argument_list|(
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|size
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Writer calls this when it has hit an error and had to    * roll back, to tell us that there may now be    * unreferenced files in the filesystem.  So we re-list    * the filesystem and delete such files.  If segmentName    * is non-null, we will only delete files corresponding to    * that segment.    */
DECL|method|refresh
specifier|public
name|void
name|refresh
parameter_list|(
name|String
name|segmentName
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
name|String
index|[]
name|files
init|=
name|directory
operator|.
name|listAll
argument_list|()
decl_stmt|;
name|String
name|segmentPrefix1
decl_stmt|;
name|String
name|segmentPrefix2
decl_stmt|;
if|if
condition|(
name|segmentName
operator|!=
literal|null
condition|)
block|{
name|segmentPrefix1
operator|=
name|segmentName
operator|+
literal|"."
expr_stmt|;
name|segmentPrefix2
operator|=
name|segmentName
operator|+
literal|"_"
expr_stmt|;
block|}
else|else
block|{
name|segmentPrefix1
operator|=
literal|null
expr_stmt|;
name|segmentPrefix2
operator|=
literal|null
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|files
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|fileName
init|=
name|files
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|segmentName
operator|==
literal|null
operator|||
name|fileName
operator|.
name|startsWith
argument_list|(
name|segmentPrefix1
argument_list|)
operator|||
name|fileName
operator|.
name|startsWith
argument_list|(
name|segmentPrefix2
argument_list|)
operator|)
operator|&&
name|indexFilenameFilter
operator|.
name|accept
argument_list|(
literal|null
argument_list|,
name|fileName
argument_list|)
operator|&&
operator|!
name|refCounts
operator|.
name|containsKey
argument_list|(
name|fileName
argument_list|)
operator|&&
operator|!
name|fileName
operator|.
name|equals
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS_GEN
argument_list|)
condition|)
block|{
comment|// Unreferenced file, so remove it
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"refresh [prefix="
operator|+
name|segmentName
operator|+
literal|"]: removing newly created unreferenced file \""
operator|+
name|fileName
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
name|deleteFile
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|refresh
specifier|public
name|void
name|refresh
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Set to null so that we regenerate the list of pending
comment|// files; else we can accumulate same file more than
comment|// once
assert|assert
name|locked
argument_list|()
assert|;
name|deletable
operator|=
literal|null
expr_stmt|;
name|refresh
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|// DecRef old files from the last checkpoint, if any:
assert|assert
name|locked
argument_list|()
assert|;
name|int
name|size
init|=
name|lastFiles
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|decRef
argument_list|(
name|lastFiles
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lastFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|deletePendingFiles
argument_list|()
expr_stmt|;
block|}
comment|/**    * Revisits the {@link IndexDeletionPolicy} by calling its    * {@link IndexDeletionPolicy#onCommit(List)} again with the known commits.    * This is useful in cases where a deletion policy which holds onto index    * commits is used. The application may know that some commits are not held by    * the deletion policy anymore and call    * {@link IndexWriter#deleteUnusedFiles()}, which will attempt to delete the    * unused commits again.    */
DECL|method|revisitPolicy
name|void
name|revisitPolicy
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"now revisitPolicy"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commits
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|policy
operator|.
name|onCommit
argument_list|(
name|commits
argument_list|)
expr_stmt|;
name|deleteCommits
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|deletePendingFiles
specifier|public
name|void
name|deletePendingFiles
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
if|if
condition|(
name|deletable
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|oldDeletable
init|=
name|deletable
decl_stmt|;
name|deletable
operator|=
literal|null
expr_stmt|;
name|int
name|size
init|=
name|oldDeletable
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"delete pending file "
operator|+
name|oldDeletable
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|deleteFile
argument_list|(
name|oldDeletable
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * For definition of "check point" see IndexWriter comments:    * "Clarification: Check Points (and commits)".    *    * Writer calls this when it has made a "consistent    * change" to the index, meaning new files are written to    * the index and the in-memory SegmentInfos have been    * modified to point to those files.    *    * This may or may not be a commit (segments_N may or may    * not have been written).    *    * We simply incref the files referenced by the new    * SegmentInfos and decref the files we had previously    * seen (if any).    *    * If this is a commit, we also call the policy to give it    * a chance to remove other commits.  If any commits are    * removed, we decref their files as well.    */
DECL|method|checkpoint
specifier|public
name|void
name|checkpoint
parameter_list|(
name|SegmentInfos
name|segmentInfos
parameter_list|,
name|boolean
name|isCommit
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"now checkpoint \""
operator|+
name|segmentInfos
operator|.
name|toString
argument_list|(
name|directory
argument_list|)
operator|+
literal|"\" ["
operator|+
name|segmentInfos
operator|.
name|size
argument_list|()
operator|+
literal|" segments "
operator|+
literal|"; isCommit = "
operator|+
name|isCommit
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
comment|// Try again now to delete any previously un-deletable
comment|// files (because they were in use, on Windows):
name|deletePendingFiles
argument_list|()
expr_stmt|;
comment|// Incref the files:
name|incRef
argument_list|(
name|segmentInfos
argument_list|,
name|isCommit
argument_list|)
expr_stmt|;
if|if
condition|(
name|isCommit
condition|)
block|{
comment|// Append to our commits list:
name|commits
operator|.
name|add
argument_list|(
operator|new
name|CommitPoint
argument_list|(
name|commitsToDelete
argument_list|,
name|directory
argument_list|,
name|segmentInfos
argument_list|)
argument_list|)
expr_stmt|;
comment|// Tell policy so it can remove commits:
name|policy
operator|.
name|onCommit
argument_list|(
name|commits
argument_list|)
expr_stmt|;
comment|// Decref files for commits that were deleted by the policy:
name|deleteCommits
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// DecRef old files from the last checkpoint, if any:
for|for
control|(
name|Collection
argument_list|<
name|String
argument_list|>
name|lastFile
range|:
name|lastFiles
control|)
block|{
name|decRef
argument_list|(
name|lastFile
argument_list|)
expr_stmt|;
block|}
name|lastFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Save files so we can decr on next checkpoint/commit:
name|lastFiles
operator|.
name|add
argument_list|(
name|segmentInfos
operator|.
name|files
argument_list|(
name|directory
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|incRef
name|void
name|incRef
parameter_list|(
name|SegmentInfos
name|segmentInfos
parameter_list|,
name|boolean
name|isCommit
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
comment|// If this is a commit point, also incRef the
comment|// segments_N file:
for|for
control|(
specifier|final
name|String
name|fileName
range|:
name|segmentInfos
operator|.
name|files
argument_list|(
name|directory
argument_list|,
name|isCommit
argument_list|)
control|)
block|{
name|incRef
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|incRef
name|void
name|incRef
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
for|for
control|(
specifier|final
name|String
name|file
range|:
name|files
control|)
block|{
name|incRef
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|incRef
name|void
name|incRef
parameter_list|(
name|String
name|fileName
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
name|RefCount
name|rc
init|=
name|getRefCount
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
operator|&&
name|VERBOSE_REF_COUNTS
condition|)
block|{
name|message
argument_list|(
literal|"  IncRef \""
operator|+
name|fileName
operator|+
literal|"\": pre-incr count is "
operator|+
name|rc
operator|.
name|count
argument_list|)
expr_stmt|;
block|}
name|rc
operator|.
name|IncRef
argument_list|()
expr_stmt|;
block|}
DECL|method|decRef
name|void
name|decRef
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
for|for
control|(
specifier|final
name|String
name|file
range|:
name|files
control|)
block|{
name|decRef
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|decRef
name|void
name|decRef
parameter_list|(
name|String
name|fileName
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
name|RefCount
name|rc
init|=
name|getRefCount
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
operator|&&
name|VERBOSE_REF_COUNTS
condition|)
block|{
name|message
argument_list|(
literal|"  DecRef \""
operator|+
name|fileName
operator|+
literal|"\": pre-decr count is "
operator|+
name|rc
operator|.
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|rc
operator|.
name|DecRef
argument_list|()
condition|)
block|{
comment|// This file is no longer referenced by any past
comment|// commit points nor by the in-memory SegmentInfos:
name|deleteFile
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|refCounts
operator|.
name|remove
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|decRef
name|void
name|decRef
parameter_list|(
name|SegmentInfos
name|segmentInfos
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
for|for
control|(
specifier|final
name|String
name|file
range|:
name|segmentInfos
operator|.
name|files
argument_list|(
name|directory
argument_list|,
literal|false
argument_list|)
control|)
block|{
name|decRef
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|exists
specifier|public
name|boolean
name|exists
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
assert|assert
name|locked
argument_list|()
assert|;
if|if
condition|(
operator|!
name|refCounts
operator|.
name|containsKey
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|getRefCount
argument_list|(
name|fileName
argument_list|)
operator|.
name|count
operator|>
literal|0
return|;
block|}
block|}
DECL|method|getRefCount
specifier|private
name|RefCount
name|getRefCount
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
assert|assert
name|locked
argument_list|()
assert|;
name|RefCount
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|refCounts
operator|.
name|containsKey
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
name|rc
operator|=
operator|new
name|RefCount
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|refCounts
operator|.
name|put
argument_list|(
name|fileName
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|refCounts
operator|.
name|get
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
DECL|method|deleteFiles
name|void
name|deleteFiles
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
for|for
control|(
specifier|final
name|String
name|file
range|:
name|files
control|)
block|{
name|deleteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Deletes the specified files, but only if they are new    *  (have not yet been incref'd). */
DECL|method|deleteNewFiles
name|void
name|deleteNewFiles
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
for|for
control|(
specifier|final
name|String
name|fileName
range|:
name|files
control|)
block|{
if|if
condition|(
operator|!
name|refCounts
operator|.
name|containsKey
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"delete new file \""
operator|+
name|fileName
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
name|deleteFile
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|deleteFile
name|void
name|deleteFile
parameter_list|(
name|String
name|fileName
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
try|try
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"delete \""
operator|+
name|fileName
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
name|directory
operator|.
name|deleteFile
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// if delete fails
if|if
condition|(
name|directory
operator|.
name|fileExists
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
comment|// Some operating systems (e.g. Windows) don't
comment|// permit a file to be deleted while it is opened
comment|// for read (e.g. by another process or thread). So
comment|// we assume that when a delete fails it is because
comment|// the file is open in another process, and queue
comment|// the file for subsequent deletion.
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"unable to remove file \""
operator|+
name|fileName
operator|+
literal|"\": "
operator|+
name|e
operator|.
name|toString
argument_list|()
operator|+
literal|"; Will re-try later."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deletable
operator|==
literal|null
condition|)
block|{
name|deletable
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|deletable
operator|.
name|add
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
comment|// add to deletable
block|}
block|}
block|}
comment|/**    * Tracks the reference count for a single index file:    */
DECL|class|RefCount
specifier|final
specifier|private
specifier|static
class|class
name|RefCount
block|{
comment|// fileName used only for better assert error messages
DECL|field|fileName
specifier|final
name|String
name|fileName
decl_stmt|;
DECL|field|initDone
name|boolean
name|initDone
decl_stmt|;
DECL|method|RefCount
name|RefCount
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
name|this
operator|.
name|fileName
operator|=
name|fileName
expr_stmt|;
block|}
DECL|field|count
name|int
name|count
decl_stmt|;
DECL|method|IncRef
specifier|public
name|int
name|IncRef
parameter_list|()
block|{
if|if
condition|(
operator|!
name|initDone
condition|)
block|{
name|initDone
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|count
operator|>
literal|0
operator|:
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": RefCount is 0 pre-increment for file \""
operator|+
name|fileName
operator|+
literal|"\""
assert|;
block|}
return|return
operator|++
name|count
return|;
block|}
DECL|method|DecRef
specifier|public
name|int
name|DecRef
parameter_list|()
block|{
assert|assert
name|count
operator|>
literal|0
operator|:
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": RefCount is 0 pre-decrement for file \""
operator|+
name|fileName
operator|+
literal|"\""
assert|;
return|return
operator|--
name|count
return|;
block|}
block|}
comment|/**    * Holds details for each commit point.  This class is    * also passed to the deletion policy.  Note: this class    * has a natural ordering that is inconsistent with    * equals.    */
DECL|class|CommitPoint
specifier|final
specifier|private
specifier|static
class|class
name|CommitPoint
extends|extends
name|IndexCommit
block|{
DECL|field|files
name|Collection
argument_list|<
name|String
argument_list|>
name|files
decl_stmt|;
DECL|field|segmentsFileName
name|String
name|segmentsFileName
decl_stmt|;
DECL|field|deleted
name|boolean
name|deleted
decl_stmt|;
DECL|field|directory
name|Directory
name|directory
decl_stmt|;
DECL|field|commitsToDelete
name|Collection
argument_list|<
name|CommitPoint
argument_list|>
name|commitsToDelete
decl_stmt|;
DECL|field|version
name|long
name|version
decl_stmt|;
DECL|field|generation
name|long
name|generation
decl_stmt|;
DECL|field|isOptimized
specifier|final
name|boolean
name|isOptimized
decl_stmt|;
DECL|field|userData
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|userData
decl_stmt|;
DECL|method|CommitPoint
specifier|public
name|CommitPoint
parameter_list|(
name|Collection
argument_list|<
name|CommitPoint
argument_list|>
name|commitsToDelete
parameter_list|,
name|Directory
name|directory
parameter_list|,
name|SegmentInfos
name|segmentInfos
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
name|this
operator|.
name|commitsToDelete
operator|=
name|commitsToDelete
expr_stmt|;
name|userData
operator|=
name|segmentInfos
operator|.
name|getUserData
argument_list|()
expr_stmt|;
name|segmentsFileName
operator|=
name|segmentInfos
operator|.
name|getCurrentSegmentFileName
argument_list|()
expr_stmt|;
name|version
operator|=
name|segmentInfos
operator|.
name|getVersion
argument_list|()
expr_stmt|;
name|generation
operator|=
name|segmentInfos
operator|.
name|getGeneration
argument_list|()
expr_stmt|;
name|files
operator|=
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|segmentInfos
operator|.
name|files
argument_list|(
name|directory
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|isOptimized
operator|=
name|segmentInfos
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|!
name|segmentInfos
operator|.
name|info
argument_list|(
literal|0
argument_list|)
operator|.
name|hasDeletions
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"IndexFileDeleter.CommitPoint("
operator|+
name|segmentsFileName
operator|+
literal|")"
return|;
block|}
annotation|@
name|Override
DECL|method|isOptimized
specifier|public
name|boolean
name|isOptimized
parameter_list|()
block|{
return|return
name|isOptimized
return|;
block|}
annotation|@
name|Override
DECL|method|getSegmentsFileName
specifier|public
name|String
name|getSegmentsFileName
parameter_list|()
block|{
return|return
name|segmentsFileName
return|;
block|}
annotation|@
name|Override
DECL|method|getFileNames
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getFileNames
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|files
return|;
block|}
annotation|@
name|Override
DECL|method|getDirectory
specifier|public
name|Directory
name|getDirectory
parameter_list|()
block|{
return|return
name|directory
return|;
block|}
annotation|@
name|Override
DECL|method|getVersion
specifier|public
name|long
name|getVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
annotation|@
name|Override
DECL|method|getGeneration
specifier|public
name|long
name|getGeneration
parameter_list|()
block|{
return|return
name|generation
return|;
block|}
annotation|@
name|Override
DECL|method|getUserData
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getUserData
parameter_list|()
block|{
return|return
name|userData
return|;
block|}
comment|/**      * Called only be the deletion policy, to remove this      * commit point from the index.      */
annotation|@
name|Override
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|()
block|{
if|if
condition|(
operator|!
name|deleted
condition|)
block|{
name|deleted
operator|=
literal|true
expr_stmt|;
name|commitsToDelete
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|isDeleted
specifier|public
name|boolean
name|isDeleted
parameter_list|()
block|{
return|return
name|deleted
return|;
block|}
block|}
block|}
end_class
end_unit
