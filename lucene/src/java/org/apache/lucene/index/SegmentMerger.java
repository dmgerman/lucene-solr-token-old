begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
operator|.
name|FieldOption
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MergePolicy
operator|.
name|MergeAbortedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|FieldsConsumer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|MergeState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|PerDocConsumer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|PerDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|CompoundFileDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ReaderUtil
import|;
end_import
begin_comment
comment|/**  * The SegmentMerger class combines two or more Segments, represented by an IndexReader ({@link #add},  * into a single Segment.  After adding the appropriate readers, call the merge method to combine the  * segments.  *  * @see #merge  * @see #add  */
end_comment
begin_class
DECL|class|SegmentMerger
specifier|final
class|class
name|SegmentMerger
block|{
DECL|field|directory
specifier|private
name|Directory
name|directory
decl_stmt|;
DECL|field|segment
specifier|private
name|String
name|segment
decl_stmt|;
DECL|field|termIndexInterval
specifier|private
name|int
name|termIndexInterval
init|=
name|IndexWriterConfig
operator|.
name|DEFAULT_TERM_INDEX_INTERVAL
decl_stmt|;
DECL|field|readers
specifier|private
name|List
argument_list|<
name|MergeState
operator|.
name|IndexReaderAndLiveDocs
argument_list|>
name|readers
init|=
operator|new
name|ArrayList
argument_list|<
name|MergeState
operator|.
name|IndexReaderAndLiveDocs
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|fieldInfos
specifier|private
specifier|final
name|FieldInfos
name|fieldInfos
decl_stmt|;
DECL|field|mergedDocs
specifier|private
name|int
name|mergedDocs
decl_stmt|;
DECL|field|checkAbort
specifier|private
specifier|final
name|MergeState
operator|.
name|CheckAbort
name|checkAbort
decl_stmt|;
comment|/** Maximum number of contiguous documents to bulk-copy       when merging stored fields */
DECL|field|MAX_RAW_MERGE_DOCS
specifier|private
specifier|final
specifier|static
name|int
name|MAX_RAW_MERGE_DOCS
init|=
literal|4192
decl_stmt|;
DECL|field|codec
specifier|private
name|Codec
name|codec
decl_stmt|;
DECL|field|segmentWriteState
specifier|private
name|SegmentWriteState
name|segmentWriteState
decl_stmt|;
DECL|field|payloadProcessorProvider
specifier|private
name|PayloadProcessorProvider
name|payloadProcessorProvider
decl_stmt|;
DECL|field|context
specifier|private
name|IOContext
name|context
decl_stmt|;
DECL|method|SegmentMerger
name|SegmentMerger
parameter_list|(
name|Directory
name|dir
parameter_list|,
name|int
name|termIndexInterval
parameter_list|,
name|String
name|name
parameter_list|,
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|,
name|PayloadProcessorProvider
name|payloadProcessorProvider
parameter_list|,
name|FieldInfos
name|fieldInfos
parameter_list|,
name|IOContext
name|context
parameter_list|)
block|{
name|this
operator|.
name|payloadProcessorProvider
operator|=
name|payloadProcessorProvider
expr_stmt|;
name|directory
operator|=
name|dir
expr_stmt|;
name|segment
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|fieldInfos
operator|=
name|fieldInfos
expr_stmt|;
if|if
condition|(
name|merge
operator|!=
literal|null
condition|)
block|{
name|checkAbort
operator|=
operator|new
name|MergeState
operator|.
name|CheckAbort
argument_list|(
name|merge
argument_list|,
name|directory
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|checkAbort
operator|=
operator|new
name|MergeState
operator|.
name|CheckAbort
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|work
parameter_list|(
name|double
name|units
parameter_list|)
throws|throws
name|MergeAbortedException
block|{
comment|// do nothing
block|}
block|}
expr_stmt|;
block|}
name|this
operator|.
name|termIndexInterval
operator|=
name|termIndexInterval
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
block|}
DECL|method|fieldInfos
specifier|public
name|FieldInfos
name|fieldInfos
parameter_list|()
block|{
return|return
name|fieldInfos
return|;
block|}
comment|/**    * Add an IndexReader to the collection of readers that are to be merged    * @param reader    */
DECL|method|add
specifier|final
name|void
name|add
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
block|{
try|try
block|{
operator|new
name|ReaderUtil
operator|.
name|Gather
argument_list|(
name|reader
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|add
parameter_list|(
name|int
name|base
parameter_list|,
name|IndexReader
name|r
parameter_list|)
block|{
name|readers
operator|.
name|add
argument_list|(
operator|new
name|MergeState
operator|.
name|IndexReaderAndLiveDocs
argument_list|(
name|r
argument_list|,
name|r
operator|.
name|getLiveDocs
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// won't happen
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
block|}
DECL|method|add
specifier|final
name|void
name|add
parameter_list|(
name|SegmentReader
name|reader
parameter_list|,
name|Bits
name|liveDocs
parameter_list|)
block|{
name|readers
operator|.
name|add
argument_list|(
operator|new
name|MergeState
operator|.
name|IndexReaderAndLiveDocs
argument_list|(
name|reader
argument_list|,
name|liveDocs
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Merges the readers specified by the {@link #add} method into the directory passed to the constructor    * @return The number of documents that were merged    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|merge
specifier|final
name|int
name|merge
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
comment|// NOTE: it's important to add calls to
comment|// checkAbort.work(...) if you make any changes to this
comment|// method that will spend alot of time.  The frequency
comment|// of this check impacts how long
comment|// IndexWriter.close(false) takes to actually stop the
comment|// threads.
name|mergedDocs
operator|=
name|mergeFields
argument_list|()
expr_stmt|;
name|mergeTerms
argument_list|()
expr_stmt|;
name|mergePerDoc
argument_list|()
expr_stmt|;
name|mergeNorms
argument_list|()
expr_stmt|;
if|if
condition|(
name|fieldInfos
operator|.
name|hasVectors
argument_list|()
condition|)
block|{
name|mergeVectors
argument_list|()
expr_stmt|;
block|}
return|return
name|mergedDocs
return|;
block|}
comment|/**    * NOTE: this method creates a compound file for all files returned by    * info.files(). While, generally, this may include separate norms and    * deletion files, this SegmentInfo must not reference such files when this    * method is called, because they are not allowed within a compound file.    */
DECL|method|createCompoundFile
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|createCompoundFile
parameter_list|(
name|String
name|fileName
parameter_list|,
specifier|final
name|SegmentInfo
name|info
parameter_list|,
name|IOContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Now merge all added files
name|Collection
argument_list|<
name|String
argument_list|>
name|files
init|=
name|info
operator|.
name|files
argument_list|()
decl_stmt|;
name|CompoundFileDirectory
name|cfsDir
init|=
name|directory
operator|.
name|createCompoundOutput
argument_list|(
name|fileName
argument_list|,
name|context
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
name|String
name|file
range|:
name|files
control|)
block|{
assert|assert
operator|!
name|IndexFileNames
operator|.
name|matchesExtension
argument_list|(
name|file
argument_list|,
name|IndexFileNames
operator|.
name|DELETES_EXTENSION
argument_list|)
operator|:
literal|".del file is not allowed in .cfs: "
operator|+
name|file
assert|;
assert|assert
operator|!
name|IndexFileNames
operator|.
name|isSeparateNormsFile
argument_list|(
name|file
argument_list|)
operator|:
literal|"separate norms file (.s[0-9]+) is not allowed in .cfs: "
operator|+
name|file
assert|;
name|directory
operator|.
name|copy
argument_list|(
name|cfsDir
argument_list|,
name|file
argument_list|,
name|file
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|checkAbort
operator|.
name|work
argument_list|(
name|directory
operator|.
name|fileLength
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|cfsDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|files
return|;
block|}
DECL|method|addIndexed
specifier|private
specifier|static
name|void
name|addIndexed
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|FieldInfos
name|fInfos
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|names
parameter_list|,
name|boolean
name|storeTermVectors
parameter_list|,
name|boolean
name|storePositionWithTermVector
parameter_list|,
name|boolean
name|storeOffsetWithTermVector
parameter_list|,
name|boolean
name|storePayloads
parameter_list|,
name|IndexOptions
name|indexOptions
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|String
name|field
range|:
name|names
control|)
block|{
name|fInfos
operator|.
name|addOrUpdate
argument_list|(
name|field
argument_list|,
literal|true
argument_list|,
name|storeTermVectors
argument_list|,
name|storePositionWithTermVector
argument_list|,
name|storeOffsetWithTermVector
argument_list|,
operator|!
name|reader
operator|.
name|hasNorms
argument_list|(
name|field
argument_list|)
argument_list|,
name|storePayloads
argument_list|,
name|indexOptions
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|matchingSegmentReaders
specifier|private
name|SegmentReader
index|[]
name|matchingSegmentReaders
decl_stmt|;
DECL|field|rawDocLengths
specifier|private
name|int
index|[]
name|rawDocLengths
decl_stmt|;
DECL|field|rawDocLengths2
specifier|private
name|int
index|[]
name|rawDocLengths2
decl_stmt|;
DECL|field|matchedCount
specifier|private
name|int
name|matchedCount
decl_stmt|;
DECL|method|getMatchedSubReaderCount
specifier|public
name|int
name|getMatchedSubReaderCount
parameter_list|()
block|{
return|return
name|matchedCount
return|;
block|}
DECL|method|setMatchingSegmentReaders
specifier|private
name|void
name|setMatchingSegmentReaders
parameter_list|()
block|{
comment|// If the i'th reader is a SegmentReader and has
comment|// identical fieldName -> number mapping, then this
comment|// array will be non-null at position i:
name|int
name|numReaders
init|=
name|readers
operator|.
name|size
argument_list|()
decl_stmt|;
name|matchingSegmentReaders
operator|=
operator|new
name|SegmentReader
index|[
name|numReaders
index|]
expr_stmt|;
comment|// If this reader is a SegmentReader, and all of its
comment|// field name -> number mappings match the "merged"
comment|// FieldInfos, then we can do a bulk copy of the
comment|// stored fields:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numReaders
condition|;
name|i
operator|++
control|)
block|{
name|MergeState
operator|.
name|IndexReaderAndLiveDocs
name|reader
init|=
name|readers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|reader
operator|.
name|reader
operator|instanceof
name|SegmentReader
condition|)
block|{
name|SegmentReader
name|segmentReader
init|=
operator|(
name|SegmentReader
operator|)
name|reader
operator|.
name|reader
decl_stmt|;
name|boolean
name|same
init|=
literal|true
decl_stmt|;
name|FieldInfos
name|segmentFieldInfos
init|=
name|segmentReader
operator|.
name|fieldInfos
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldInfo
name|fi
range|:
name|segmentFieldInfos
control|)
block|{
name|same
operator|=
name|fieldInfos
operator|.
name|fieldName
argument_list|(
name|fi
operator|.
name|number
argument_list|)
operator|.
name|equals
argument_list|(
name|fi
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|same
condition|)
block|{
name|matchingSegmentReaders
index|[
name|i
index|]
operator|=
name|segmentReader
expr_stmt|;
name|matchedCount
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|// Used for bulk-reading raw bytes for stored fields
name|rawDocLengths
operator|=
operator|new
name|int
index|[
name|MAX_RAW_MERGE_DOCS
index|]
expr_stmt|;
name|rawDocLengths2
operator|=
operator|new
name|int
index|[
name|MAX_RAW_MERGE_DOCS
index|]
expr_stmt|;
block|}
comment|/**    *    * @return The number of documents in all of the readers    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|mergeFields
specifier|private
name|int
name|mergeFields
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
for|for
control|(
name|MergeState
operator|.
name|IndexReaderAndLiveDocs
name|readerAndLiveDocs
range|:
name|readers
control|)
block|{
specifier|final
name|IndexReader
name|reader
init|=
name|readerAndLiveDocs
operator|.
name|reader
decl_stmt|;
if|if
condition|(
name|reader
operator|instanceof
name|SegmentReader
condition|)
block|{
name|SegmentReader
name|segmentReader
init|=
operator|(
name|SegmentReader
operator|)
name|reader
decl_stmt|;
name|FieldInfos
name|readerFieldInfos
init|=
name|segmentReader
operator|.
name|fieldInfos
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldInfo
name|fi
range|:
name|readerFieldInfos
control|)
block|{
name|fieldInfos
operator|.
name|add
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|addIndexed
argument_list|(
name|reader
argument_list|,
name|fieldInfos
argument_list|,
name|reader
operator|.
name|getFieldNames
argument_list|(
name|FieldOption
operator|.
name|TERMVECTOR_WITH_POSITION_OFFSET
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
expr_stmt|;
name|addIndexed
argument_list|(
name|reader
argument_list|,
name|fieldInfos
argument_list|,
name|reader
operator|.
name|getFieldNames
argument_list|(
name|FieldOption
operator|.
name|TERMVECTOR_WITH_POSITION
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
expr_stmt|;
name|addIndexed
argument_list|(
name|reader
argument_list|,
name|fieldInfos
argument_list|,
name|reader
operator|.
name|getFieldNames
argument_list|(
name|FieldOption
operator|.
name|TERMVECTOR_WITH_OFFSET
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
expr_stmt|;
name|addIndexed
argument_list|(
name|reader
argument_list|,
name|fieldInfos
argument_list|,
name|reader
operator|.
name|getFieldNames
argument_list|(
name|FieldOption
operator|.
name|TERMVECTOR
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
expr_stmt|;
name|addIndexed
argument_list|(
name|reader
argument_list|,
name|fieldInfos
argument_list|,
name|reader
operator|.
name|getFieldNames
argument_list|(
name|FieldOption
operator|.
name|OMIT_POSITIONS
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|IndexOptions
operator|.
name|DOCS_AND_FREQS
argument_list|)
expr_stmt|;
name|addIndexed
argument_list|(
name|reader
argument_list|,
name|fieldInfos
argument_list|,
name|reader
operator|.
name|getFieldNames
argument_list|(
name|FieldOption
operator|.
name|OMIT_TERM_FREQ_AND_POSITIONS
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|IndexOptions
operator|.
name|DOCS_ONLY
argument_list|)
expr_stmt|;
name|addIndexed
argument_list|(
name|reader
argument_list|,
name|fieldInfos
argument_list|,
name|reader
operator|.
name|getFieldNames
argument_list|(
name|FieldOption
operator|.
name|STORES_PAYLOADS
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
expr_stmt|;
name|addIndexed
argument_list|(
name|reader
argument_list|,
name|fieldInfos
argument_list|,
name|reader
operator|.
name|getFieldNames
argument_list|(
name|FieldOption
operator|.
name|INDEXED
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
expr_stmt|;
name|fieldInfos
operator|.
name|addOrUpdate
argument_list|(
name|reader
operator|.
name|getFieldNames
argument_list|(
name|FieldOption
operator|.
name|UNINDEXED
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fieldInfos
operator|.
name|addOrUpdate
argument_list|(
name|reader
operator|.
name|getFieldNames
argument_list|(
name|FieldOption
operator|.
name|DOC_VALUES
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|SegmentCodecs
name|codecInfo
init|=
name|fieldInfos
operator|.
name|buildSegmentCodecs
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|fieldInfos
operator|.
name|write
argument_list|(
name|directory
argument_list|,
name|segment
operator|+
literal|"."
operator|+
name|IndexFileNames
operator|.
name|FIELD_INFOS_EXTENSION
argument_list|)
expr_stmt|;
name|int
name|docCount
init|=
literal|0
decl_stmt|;
name|setMatchingSegmentReaders
argument_list|()
expr_stmt|;
specifier|final
name|FieldsWriter
name|fieldsWriter
init|=
operator|new
name|FieldsWriter
argument_list|(
name|directory
argument_list|,
name|segment
argument_list|,
name|context
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|MergeState
operator|.
name|IndexReaderAndLiveDocs
name|reader
range|:
name|readers
control|)
block|{
specifier|final
name|SegmentReader
name|matchingSegmentReader
init|=
name|matchingSegmentReaders
index|[
name|idx
operator|++
index|]
decl_stmt|;
name|FieldsReader
name|matchingFieldsReader
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|matchingSegmentReader
operator|!=
literal|null
condition|)
block|{
specifier|final
name|FieldsReader
name|fieldsReader
init|=
name|matchingSegmentReader
operator|.
name|getFieldsReader
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldsReader
operator|!=
literal|null
condition|)
block|{
name|matchingFieldsReader
operator|=
name|fieldsReader
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reader
operator|.
name|liveDocs
operator|!=
literal|null
condition|)
block|{
name|docCount
operator|+=
name|copyFieldsWithDeletions
argument_list|(
name|fieldsWriter
argument_list|,
name|reader
argument_list|,
name|matchingFieldsReader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|docCount
operator|+=
name|copyFieldsNoDeletions
argument_list|(
name|fieldsWriter
argument_list|,
name|reader
argument_list|,
name|matchingFieldsReader
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|fieldsWriter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
specifier|final
name|String
name|fileName
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segment
argument_list|,
literal|""
argument_list|,
name|IndexFileNames
operator|.
name|FIELDS_INDEX_EXTENSION
argument_list|)
decl_stmt|;
specifier|final
name|long
name|fdxFileLength
init|=
name|directory
operator|.
name|fileLength
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
literal|4
operator|+
operator|(
operator|(
name|long
operator|)
name|docCount
operator|)
operator|*
literal|8
operator|!=
name|fdxFileLength
condition|)
comment|// This is most likely a bug in Sun JRE 1.6.0_04/_05;
comment|// we detect that the bug has struck, here, and
comment|// throw an exception to prevent the corruption from
comment|// entering the index.  See LUCENE-1282 for
comment|// details.
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"mergeFields produced an invalid result: docCount is "
operator|+
name|docCount
operator|+
literal|" but fdx file size is "
operator|+
name|fdxFileLength
operator|+
literal|" file="
operator|+
name|fileName
operator|+
literal|" file exists?="
operator|+
name|directory
operator|.
name|fileExists
argument_list|(
name|fileName
argument_list|)
operator|+
literal|"; now aborting this merge to prevent index corruption"
argument_list|)
throw|;
name|segmentWriteState
operator|=
operator|new
name|SegmentWriteState
argument_list|(
literal|null
argument_list|,
name|directory
argument_list|,
name|segment
argument_list|,
name|fieldInfos
argument_list|,
name|docCount
argument_list|,
name|termIndexInterval
argument_list|,
name|codecInfo
argument_list|,
literal|null
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|docCount
return|;
block|}
DECL|method|copyFieldsWithDeletions
specifier|private
name|int
name|copyFieldsWithDeletions
parameter_list|(
specifier|final
name|FieldsWriter
name|fieldsWriter
parameter_list|,
specifier|final
name|MergeState
operator|.
name|IndexReaderAndLiveDocs
name|reader
parameter_list|,
specifier|final
name|FieldsReader
name|matchingFieldsReader
parameter_list|)
throws|throws
name|IOException
throws|,
name|MergeAbortedException
throws|,
name|CorruptIndexException
block|{
name|int
name|docCount
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|maxDoc
init|=
name|reader
operator|.
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
specifier|final
name|Bits
name|liveDocs
init|=
name|reader
operator|.
name|liveDocs
decl_stmt|;
assert|assert
name|liveDocs
operator|!=
literal|null
assert|;
if|if
condition|(
name|matchingFieldsReader
operator|!=
literal|null
condition|)
block|{
comment|// We can bulk-copy because the fieldInfos are "congruent"
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|maxDoc
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|liveDocs
operator|.
name|get
argument_list|(
name|j
argument_list|)
condition|)
block|{
comment|// skip deleted docs
operator|++
name|j
expr_stmt|;
continue|continue;
block|}
comment|// We can optimize this case (doing a bulk byte copy) since the field
comment|// numbers are identical
name|int
name|start
init|=
name|j
decl_stmt|,
name|numDocs
init|=
literal|0
decl_stmt|;
do|do
block|{
name|j
operator|++
expr_stmt|;
name|numDocs
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|maxDoc
condition|)
break|break;
if|if
condition|(
operator|!
name|liveDocs
operator|.
name|get
argument_list|(
name|j
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|numDocs
operator|<
name|MAX_RAW_MERGE_DOCS
condition|)
do|;
name|IndexInput
name|stream
init|=
name|matchingFieldsReader
operator|.
name|rawDocs
argument_list|(
name|rawDocLengths
argument_list|,
name|start
argument_list|,
name|numDocs
argument_list|)
decl_stmt|;
name|fieldsWriter
operator|.
name|addRawDocuments
argument_list|(
name|stream
argument_list|,
name|rawDocLengths
argument_list|,
name|numDocs
argument_list|)
expr_stmt|;
name|docCount
operator|+=
name|numDocs
expr_stmt|;
name|checkAbort
operator|.
name|work
argument_list|(
literal|300
operator|*
name|numDocs
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|maxDoc
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|liveDocs
operator|.
name|get
argument_list|(
name|j
argument_list|)
condition|)
block|{
comment|// skip deleted docs
continue|continue;
block|}
comment|// NOTE: it's very important to first assign to doc then pass it to
comment|// termVectorsWriter.addAllDocVectors; see LUCENE-1282
name|Document
name|doc
init|=
name|reader
operator|.
name|reader
operator|.
name|document
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|fieldsWriter
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|,
name|fieldInfos
argument_list|)
expr_stmt|;
name|docCount
operator|++
expr_stmt|;
name|checkAbort
operator|.
name|work
argument_list|(
literal|300
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|docCount
return|;
block|}
DECL|method|copyFieldsNoDeletions
specifier|private
name|int
name|copyFieldsNoDeletions
parameter_list|(
specifier|final
name|FieldsWriter
name|fieldsWriter
parameter_list|,
specifier|final
name|MergeState
operator|.
name|IndexReaderAndLiveDocs
name|reader
parameter_list|,
specifier|final
name|FieldsReader
name|matchingFieldsReader
parameter_list|)
throws|throws
name|IOException
throws|,
name|MergeAbortedException
throws|,
name|CorruptIndexException
block|{
specifier|final
name|int
name|maxDoc
init|=
name|reader
operator|.
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
name|int
name|docCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|matchingFieldsReader
operator|!=
literal|null
condition|)
block|{
comment|// We can bulk-copy because the fieldInfos are "congruent"
while|while
condition|(
name|docCount
operator|<
name|maxDoc
condition|)
block|{
name|int
name|len
init|=
name|Math
operator|.
name|min
argument_list|(
name|MAX_RAW_MERGE_DOCS
argument_list|,
name|maxDoc
operator|-
name|docCount
argument_list|)
decl_stmt|;
name|IndexInput
name|stream
init|=
name|matchingFieldsReader
operator|.
name|rawDocs
argument_list|(
name|rawDocLengths
argument_list|,
name|docCount
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|fieldsWriter
operator|.
name|addRawDocuments
argument_list|(
name|stream
argument_list|,
name|rawDocLengths
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|docCount
operator|+=
name|len
expr_stmt|;
name|checkAbort
operator|.
name|work
argument_list|(
literal|300
operator|*
name|len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
name|docCount
operator|<
name|maxDoc
condition|;
name|docCount
operator|++
control|)
block|{
comment|// NOTE: it's very important to first assign to doc then pass it to
comment|// termVectorsWriter.addAllDocVectors; see LUCENE-1282
name|Document
name|doc
init|=
name|reader
operator|.
name|reader
operator|.
name|document
argument_list|(
name|docCount
argument_list|)
decl_stmt|;
name|fieldsWriter
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|,
name|fieldInfos
argument_list|)
expr_stmt|;
name|checkAbort
operator|.
name|work
argument_list|(
literal|300
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|docCount
return|;
block|}
comment|/**    * Merge the TermVectors from each of the segments into the new one.    * @throws IOException    */
DECL|method|mergeVectors
specifier|private
specifier|final
name|void
name|mergeVectors
parameter_list|()
throws|throws
name|IOException
block|{
name|TermVectorsWriter
name|termVectorsWriter
init|=
operator|new
name|TermVectorsWriter
argument_list|(
name|directory
argument_list|,
name|segment
argument_list|,
name|fieldInfos
argument_list|,
name|context
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|MergeState
operator|.
name|IndexReaderAndLiveDocs
name|reader
range|:
name|readers
control|)
block|{
specifier|final
name|SegmentReader
name|matchingSegmentReader
init|=
name|matchingSegmentReaders
index|[
name|idx
operator|++
index|]
decl_stmt|;
name|TermVectorsReader
name|matchingVectorsReader
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|matchingSegmentReader
operator|!=
literal|null
condition|)
block|{
name|TermVectorsReader
name|vectorsReader
init|=
name|matchingSegmentReader
operator|.
name|getTermVectorsReader
argument_list|()
decl_stmt|;
comment|// If the TV* files are an older format then they cannot read raw docs:
if|if
condition|(
name|vectorsReader
operator|!=
literal|null
operator|&&
name|vectorsReader
operator|.
name|canReadRawDocs
argument_list|()
condition|)
block|{
name|matchingVectorsReader
operator|=
name|vectorsReader
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reader
operator|.
name|liveDocs
operator|!=
literal|null
condition|)
block|{
name|copyVectorsWithDeletions
argument_list|(
name|termVectorsWriter
argument_list|,
name|matchingVectorsReader
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copyVectorsNoDeletions
argument_list|(
name|termVectorsWriter
argument_list|,
name|matchingVectorsReader
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|termVectorsWriter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
specifier|final
name|String
name|fileName
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segment
argument_list|,
literal|""
argument_list|,
name|IndexFileNames
operator|.
name|VECTORS_INDEX_EXTENSION
argument_list|)
decl_stmt|;
specifier|final
name|long
name|tvxSize
init|=
name|directory
operator|.
name|fileLength
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
literal|4
operator|+
operator|(
operator|(
name|long
operator|)
name|mergedDocs
operator|)
operator|*
literal|16
operator|!=
name|tvxSize
condition|)
comment|// This is most likely a bug in Sun JRE 1.6.0_04/_05;
comment|// we detect that the bug has struck, here, and
comment|// throw an exception to prevent the corruption from
comment|// entering the index.  See LUCENE-1282 for
comment|// details.
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"mergeVectors produced an invalid result: mergedDocs is "
operator|+
name|mergedDocs
operator|+
literal|" but tvx size is "
operator|+
name|tvxSize
operator|+
literal|" file="
operator|+
name|fileName
operator|+
literal|" file exists?="
operator|+
name|directory
operator|.
name|fileExists
argument_list|(
name|fileName
argument_list|)
operator|+
literal|"; now aborting this merge to prevent index corruption"
argument_list|)
throw|;
block|}
DECL|method|copyVectorsWithDeletions
specifier|private
name|void
name|copyVectorsWithDeletions
parameter_list|(
specifier|final
name|TermVectorsWriter
name|termVectorsWriter
parameter_list|,
specifier|final
name|TermVectorsReader
name|matchingVectorsReader
parameter_list|,
specifier|final
name|MergeState
operator|.
name|IndexReaderAndLiveDocs
name|reader
parameter_list|)
throws|throws
name|IOException
throws|,
name|MergeAbortedException
block|{
specifier|final
name|int
name|maxDoc
init|=
name|reader
operator|.
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
specifier|final
name|Bits
name|liveDocs
init|=
name|reader
operator|.
name|liveDocs
decl_stmt|;
if|if
condition|(
name|matchingVectorsReader
operator|!=
literal|null
condition|)
block|{
comment|// We can bulk-copy because the fieldInfos are "congruent"
for|for
control|(
name|int
name|docNum
init|=
literal|0
init|;
name|docNum
operator|<
name|maxDoc
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|liveDocs
operator|.
name|get
argument_list|(
name|docNum
argument_list|)
condition|)
block|{
comment|// skip deleted docs
operator|++
name|docNum
expr_stmt|;
continue|continue;
block|}
comment|// We can optimize this case (doing a bulk byte copy) since the field
comment|// numbers are identical
name|int
name|start
init|=
name|docNum
decl_stmt|,
name|numDocs
init|=
literal|0
decl_stmt|;
do|do
block|{
name|docNum
operator|++
expr_stmt|;
name|numDocs
operator|++
expr_stmt|;
if|if
condition|(
name|docNum
operator|>=
name|maxDoc
condition|)
break|break;
if|if
condition|(
operator|!
name|liveDocs
operator|.
name|get
argument_list|(
name|docNum
argument_list|)
condition|)
block|{
name|docNum
operator|++
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|numDocs
operator|<
name|MAX_RAW_MERGE_DOCS
condition|)
do|;
name|matchingVectorsReader
operator|.
name|rawDocs
argument_list|(
name|rawDocLengths
argument_list|,
name|rawDocLengths2
argument_list|,
name|start
argument_list|,
name|numDocs
argument_list|)
expr_stmt|;
name|termVectorsWriter
operator|.
name|addRawDocuments
argument_list|(
name|matchingVectorsReader
argument_list|,
name|rawDocLengths
argument_list|,
name|rawDocLengths2
argument_list|,
name|numDocs
argument_list|)
expr_stmt|;
name|checkAbort
operator|.
name|work
argument_list|(
literal|300
operator|*
name|numDocs
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|docNum
init|=
literal|0
init|;
name|docNum
operator|<
name|maxDoc
condition|;
name|docNum
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|liveDocs
operator|.
name|get
argument_list|(
name|docNum
argument_list|)
condition|)
block|{
comment|// skip deleted docs
continue|continue;
block|}
comment|// NOTE: it's very important to first assign to vectors then pass it to
comment|// termVectorsWriter.addAllDocVectors; see LUCENE-1282
name|TermFreqVector
index|[]
name|vectors
init|=
name|reader
operator|.
name|reader
operator|.
name|getTermFreqVectors
argument_list|(
name|docNum
argument_list|)
decl_stmt|;
name|termVectorsWriter
operator|.
name|addAllDocVectors
argument_list|(
name|vectors
argument_list|)
expr_stmt|;
name|checkAbort
operator|.
name|work
argument_list|(
literal|300
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|copyVectorsNoDeletions
specifier|private
name|void
name|copyVectorsNoDeletions
parameter_list|(
specifier|final
name|TermVectorsWriter
name|termVectorsWriter
parameter_list|,
specifier|final
name|TermVectorsReader
name|matchingVectorsReader
parameter_list|,
specifier|final
name|MergeState
operator|.
name|IndexReaderAndLiveDocs
name|reader
parameter_list|)
throws|throws
name|IOException
throws|,
name|MergeAbortedException
block|{
specifier|final
name|int
name|maxDoc
init|=
name|reader
operator|.
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|matchingVectorsReader
operator|!=
literal|null
condition|)
block|{
comment|// We can bulk-copy because the fieldInfos are "congruent"
name|int
name|docCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|docCount
operator|<
name|maxDoc
condition|)
block|{
name|int
name|len
init|=
name|Math
operator|.
name|min
argument_list|(
name|MAX_RAW_MERGE_DOCS
argument_list|,
name|maxDoc
operator|-
name|docCount
argument_list|)
decl_stmt|;
name|matchingVectorsReader
operator|.
name|rawDocs
argument_list|(
name|rawDocLengths
argument_list|,
name|rawDocLengths2
argument_list|,
name|docCount
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|termVectorsWriter
operator|.
name|addRawDocuments
argument_list|(
name|matchingVectorsReader
argument_list|,
name|rawDocLengths
argument_list|,
name|rawDocLengths2
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|docCount
operator|+=
name|len
expr_stmt|;
name|checkAbort
operator|.
name|work
argument_list|(
literal|300
operator|*
name|len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|docNum
init|=
literal|0
init|;
name|docNum
operator|<
name|maxDoc
condition|;
name|docNum
operator|++
control|)
block|{
comment|// NOTE: it's very important to first assign to vectors then pass it to
comment|// termVectorsWriter.addAllDocVectors; see LUCENE-1282
name|TermFreqVector
index|[]
name|vectors
init|=
name|reader
operator|.
name|reader
operator|.
name|getTermFreqVectors
argument_list|(
name|docNum
argument_list|)
decl_stmt|;
name|termVectorsWriter
operator|.
name|addAllDocVectors
argument_list|(
name|vectors
argument_list|)
expr_stmt|;
name|checkAbort
operator|.
name|work
argument_list|(
literal|300
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getSegmentCodecs
name|SegmentCodecs
name|getSegmentCodecs
parameter_list|()
block|{
assert|assert
name|segmentWriteState
operator|!=
literal|null
assert|;
return|return
name|segmentWriteState
operator|.
name|segmentCodecs
return|;
block|}
DECL|method|mergeTerms
specifier|private
specifier|final
name|void
name|mergeTerms
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
comment|// Let CodecProvider decide which codec will be used to write
comment|// the new segment:
name|int
name|docBase
init|=
literal|0
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Fields
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<
name|Fields
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ReaderUtil
operator|.
name|Slice
argument_list|>
name|slices
init|=
operator|new
name|ArrayList
argument_list|<
name|ReaderUtil
operator|.
name|Slice
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|MergeState
operator|.
name|IndexReaderAndLiveDocs
name|r
range|:
name|readers
control|)
block|{
specifier|final
name|Fields
name|f
init|=
name|r
operator|.
name|reader
operator|.
name|fields
argument_list|()
decl_stmt|;
specifier|final
name|int
name|maxDoc
init|=
name|r
operator|.
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
block|{
name|slices
operator|.
name|add
argument_list|(
operator|new
name|ReaderUtil
operator|.
name|Slice
argument_list|(
name|docBase
argument_list|,
name|maxDoc
argument_list|,
name|fields
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|docBase
operator|+=
name|maxDoc
expr_stmt|;
block|}
comment|// we may gather more readers than mergeState.readerCount
name|mergeState
operator|=
operator|new
name|MergeState
argument_list|()
expr_stmt|;
name|mergeState
operator|.
name|readers
operator|=
name|readers
expr_stmt|;
name|mergeState
operator|.
name|readerCount
operator|=
name|readers
operator|.
name|size
argument_list|()
expr_stmt|;
name|mergeState
operator|.
name|fieldInfos
operator|=
name|fieldInfos
expr_stmt|;
name|mergeState
operator|.
name|mergedDocCount
operator|=
name|mergedDocs
expr_stmt|;
comment|// Remap docIDs
name|mergeState
operator|.
name|docMaps
operator|=
operator|new
name|int
index|[
name|mergeState
operator|.
name|readerCount
index|]
index|[]
expr_stmt|;
name|mergeState
operator|.
name|docBase
operator|=
operator|new
name|int
index|[
name|mergeState
operator|.
name|readerCount
index|]
expr_stmt|;
name|mergeState
operator|.
name|hasPayloadProcessorProvider
operator|=
name|payloadProcessorProvider
operator|!=
literal|null
expr_stmt|;
name|mergeState
operator|.
name|dirPayloadProcessor
operator|=
operator|new
name|PayloadProcessorProvider
operator|.
name|DirPayloadProcessor
index|[
name|mergeState
operator|.
name|readerCount
index|]
expr_stmt|;
name|mergeState
operator|.
name|currentPayloadProcessor
operator|=
operator|new
name|PayloadProcessorProvider
operator|.
name|PayloadProcessor
index|[
name|mergeState
operator|.
name|readerCount
index|]
expr_stmt|;
name|mergeState
operator|.
name|checkAbort
operator|=
name|checkAbort
expr_stmt|;
name|docBase
operator|=
literal|0
expr_stmt|;
name|int
name|inputDocBase
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mergeState
operator|.
name|readerCount
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|MergeState
operator|.
name|IndexReaderAndLiveDocs
name|reader
init|=
name|readers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|mergeState
operator|.
name|docBase
index|[
name|i
index|]
operator|=
name|docBase
expr_stmt|;
name|inputDocBase
operator|+=
name|reader
operator|.
name|reader
operator|.
name|maxDoc
argument_list|()
expr_stmt|;
specifier|final
name|int
name|maxDoc
init|=
name|reader
operator|.
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|reader
operator|.
name|liveDocs
operator|!=
literal|null
condition|)
block|{
name|int
name|delCount
init|=
literal|0
decl_stmt|;
specifier|final
name|Bits
name|liveDocs
init|=
name|reader
operator|.
name|liveDocs
decl_stmt|;
assert|assert
name|liveDocs
operator|!=
literal|null
assert|;
specifier|final
name|int
index|[]
name|docMap
init|=
name|mergeState
operator|.
name|docMaps
index|[
name|i
index|]
operator|=
operator|new
name|int
index|[
name|maxDoc
index|]
decl_stmt|;
name|int
name|newDocID
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|maxDoc
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|liveDocs
operator|.
name|get
argument_list|(
name|j
argument_list|)
condition|)
block|{
name|docMap
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|delCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|docMap
index|[
name|j
index|]
operator|=
name|newDocID
operator|++
expr_stmt|;
block|}
block|}
name|docBase
operator|+=
name|maxDoc
operator|-
name|delCount
expr_stmt|;
block|}
else|else
block|{
name|docBase
operator|+=
name|maxDoc
expr_stmt|;
block|}
if|if
condition|(
name|payloadProcessorProvider
operator|!=
literal|null
condition|)
block|{
name|mergeState
operator|.
name|dirPayloadProcessor
index|[
name|i
index|]
operator|=
name|payloadProcessorProvider
operator|.
name|getDirProcessor
argument_list|(
name|reader
operator|.
name|reader
operator|.
name|directory
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|codec
operator|=
name|segmentWriteState
operator|.
name|segmentCodecs
operator|.
name|codec
argument_list|()
expr_stmt|;
specifier|final
name|FieldsConsumer
name|consumer
init|=
name|codec
operator|.
name|fieldsConsumer
argument_list|(
name|segmentWriteState
argument_list|)
decl_stmt|;
try|try
block|{
name|consumer
operator|.
name|merge
argument_list|(
name|mergeState
argument_list|,
operator|new
name|MultiFields
argument_list|(
name|fields
operator|.
name|toArray
argument_list|(
name|Fields
operator|.
name|EMPTY_ARRAY
argument_list|)
argument_list|,
name|slices
operator|.
name|toArray
argument_list|(
name|ReaderUtil
operator|.
name|Slice
operator|.
name|EMPTY_ARRAY
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|consumer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|mergePerDoc
specifier|private
name|void
name|mergePerDoc
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|PerDocValues
argument_list|>
name|perDocProducers
init|=
operator|new
name|ArrayList
argument_list|<
name|PerDocValues
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ReaderUtil
operator|.
name|Slice
argument_list|>
name|perDocSlices
init|=
operator|new
name|ArrayList
argument_list|<
name|ReaderUtil
operator|.
name|Slice
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|docBase
init|=
literal|0
decl_stmt|;
for|for
control|(
name|MergeState
operator|.
name|IndexReaderAndLiveDocs
name|r
range|:
name|readers
control|)
block|{
specifier|final
name|int
name|maxDoc
init|=
name|r
operator|.
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
specifier|final
name|PerDocValues
name|producer
init|=
name|r
operator|.
name|reader
operator|.
name|perDocValues
argument_list|()
decl_stmt|;
if|if
condition|(
name|producer
operator|!=
literal|null
condition|)
block|{
name|perDocSlices
operator|.
name|add
argument_list|(
operator|new
name|ReaderUtil
operator|.
name|Slice
argument_list|(
name|docBase
argument_list|,
name|maxDoc
argument_list|,
name|perDocProducers
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|perDocProducers
operator|.
name|add
argument_list|(
name|producer
argument_list|)
expr_stmt|;
block|}
name|docBase
operator|+=
name|maxDoc
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perDocSlices
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|PerDocConsumer
name|docsConsumer
init|=
name|codec
operator|.
name|docsConsumer
argument_list|(
operator|new
name|PerDocWriteState
argument_list|(
name|segmentWriteState
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
specifier|final
name|MultiPerDocValues
name|multiPerDocValues
init|=
operator|new
name|MultiPerDocValues
argument_list|(
name|perDocProducers
operator|.
name|toArray
argument_list|(
name|PerDocValues
operator|.
name|EMPTY_ARRAY
argument_list|)
argument_list|,
name|perDocSlices
operator|.
name|toArray
argument_list|(
name|ReaderUtil
operator|.
name|Slice
operator|.
name|EMPTY_ARRAY
argument_list|)
argument_list|)
decl_stmt|;
name|docsConsumer
operator|.
name|merge
argument_list|(
name|mergeState
argument_list|,
name|multiPerDocValues
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeSafely
argument_list|(
operator|!
name|success
argument_list|,
name|docsConsumer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* don't close the perDocProducers here since they are private segment producers      * and will be closed once the SegmentReader goes out of scope */
block|}
DECL|field|mergeState
specifier|private
name|MergeState
name|mergeState
decl_stmt|;
DECL|method|getAnyNonBulkMerges
specifier|public
name|boolean
name|getAnyNonBulkMerges
parameter_list|()
block|{
assert|assert
name|matchedCount
operator|<=
name|readers
operator|.
name|size
argument_list|()
assert|;
return|return
name|matchedCount
operator|!=
name|readers
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|mergeNorms
specifier|private
name|void
name|mergeNorms
parameter_list|()
throws|throws
name|IOException
block|{
name|IndexOutput
name|output
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
for|for
control|(
name|FieldInfo
name|fi
range|:
name|fieldInfos
control|)
block|{
if|if
condition|(
name|fi
operator|.
name|isIndexed
operator|&&
operator|!
name|fi
operator|.
name|omitNorms
condition|)
block|{
if|if
condition|(
name|output
operator|==
literal|null
condition|)
block|{
name|output
operator|=
name|directory
operator|.
name|createOutput
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segment
argument_list|,
literal|""
argument_list|,
name|IndexFileNames
operator|.
name|NORMS_EXTENSION
argument_list|)
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeBytes
argument_list|(
name|SegmentNorms
operator|.
name|NORMS_HEADER
argument_list|,
name|SegmentNorms
operator|.
name|NORMS_HEADER
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|MergeState
operator|.
name|IndexReaderAndLiveDocs
name|reader
range|:
name|readers
control|)
block|{
specifier|final
name|int
name|maxDoc
init|=
name|reader
operator|.
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
name|byte
name|normBuffer
index|[]
init|=
name|reader
operator|.
name|reader
operator|.
name|norms
argument_list|(
name|fi
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|normBuffer
operator|==
literal|null
condition|)
block|{
comment|// Can be null if this segment doesn't have
comment|// any docs with this field
name|normBuffer
operator|=
operator|new
name|byte
index|[
name|maxDoc
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|normBuffer
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reader
operator|.
name|liveDocs
operator|==
literal|null
condition|)
block|{
comment|//optimized case for segments without deleted docs
name|output
operator|.
name|writeBytes
argument_list|(
name|normBuffer
argument_list|,
name|maxDoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// this segment has deleted docs, so we have to
comment|// check for every doc if it is deleted or not
specifier|final
name|Bits
name|liveDocs
init|=
name|reader
operator|.
name|liveDocs
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|maxDoc
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|liveDocs
operator|.
name|get
argument_list|(
name|k
argument_list|)
condition|)
block|{
name|output
operator|.
name|writeByte
argument_list|(
name|normBuffer
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|checkAbort
operator|.
name|work
argument_list|(
name|maxDoc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeSafely
argument_list|(
operator|!
name|success
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
