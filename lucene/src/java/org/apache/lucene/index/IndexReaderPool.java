begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License. You may obtain a copy of the License at  *   * http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|BufferedIndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_comment
comment|/** Holds shared SegmentReader instances. IndexWriter uses  *  SegmentReaders for 1) applying deletes, 2) doing  *  merges, 3) handing out a real-time reader.  This pool  *  reuses instances of the SegmentReaders in all these  *  places if it is in "near real-time mode" (getReader()  *  has been called on this instance). */
end_comment
begin_class
DECL|class|IndexReaderPool
specifier|public
class|class
name|IndexReaderPool
block|{
DECL|field|readerMap
specifier|private
specifier|final
name|Map
argument_list|<
name|SegmentInfo
argument_list|,
name|SegmentReader
argument_list|>
name|readerMap
init|=
operator|new
name|HashMap
argument_list|<
name|SegmentInfo
argument_list|,
name|SegmentReader
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|directory
specifier|private
specifier|final
name|Directory
name|directory
decl_stmt|;
DECL|field|config
specifier|private
specifier|final
name|IndexWriterConfig
name|config
decl_stmt|;
DECL|field|writer
specifier|private
specifier|final
name|IndexWriter
name|writer
decl_stmt|;
DECL|method|IndexReaderPool
specifier|public
name|IndexReaderPool
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|Directory
name|directory
parameter_list|,
name|IndexWriterConfig
name|config
parameter_list|)
block|{
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
name|this
operator|.
name|writer
operator|=
name|writer
expr_stmt|;
block|}
comment|/** Forcefully clear changes for the specified segments,    *  and remove from the pool.   This is called on successful merge. */
DECL|method|clear
specifier|synchronized
name|void
name|clear
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|infos
operator|==
literal|null
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|SegmentInfo
argument_list|,
name|SegmentReader
argument_list|>
name|ent
range|:
name|readerMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|hasChanges
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
specifier|final
name|SegmentInfo
name|info
range|:
name|infos
control|)
block|{
if|if
condition|(
name|readerMap
operator|.
name|containsKey
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|readerMap
operator|.
name|get
argument_list|(
name|info
argument_list|)
operator|.
name|hasChanges
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Release the segment reader (i.e. decRef it and close if there    * are no more references.    * @param sr    * @throws IOException    */
DECL|method|release
specifier|public
specifier|synchronized
name|void
name|release
parameter_list|(
name|SegmentReader
name|sr
parameter_list|)
throws|throws
name|IOException
block|{
name|release
argument_list|(
name|sr
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Release the segment reader (i.e. decRef it and close if there    * are no more references.    * @param sr    * @throws IOException    */
DECL|method|release
specifier|public
specifier|synchronized
name|void
name|release
parameter_list|(
name|SegmentReader
name|sr
parameter_list|,
name|boolean
name|drop
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|boolean
name|pooled
init|=
name|readerMap
operator|.
name|containsKey
argument_list|(
name|sr
operator|.
name|getSegmentInfo
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
operator|!
name|pooled
operator||
name|readerMap
operator|.
name|get
argument_list|(
name|sr
operator|.
name|getSegmentInfo
argument_list|()
argument_list|)
operator|==
name|sr
assert|;
comment|// Drop caller's ref; for an external reader (not
comment|// pooled), this decRef will close it
name|sr
operator|.
name|decRef
argument_list|()
expr_stmt|;
if|if
condition|(
name|pooled
operator|&&
operator|(
name|drop
operator|||
operator|(
operator|!
name|writer
operator|.
name|poolReaders
operator|&&
name|sr
operator|.
name|getRefCount
argument_list|()
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
comment|// We are the last ref to this reader; since we're
comment|// not pooling readers, we release it:
name|readerMap
operator|.
name|remove
argument_list|(
name|sr
operator|.
name|getSegmentInfo
argument_list|()
argument_list|)
expr_stmt|;
comment|// nocommit
comment|//assert !sr.hasChanges || Thread.holdsLock(IndexWriter.this);
comment|// Drop our ref -- this will commit any pending
comment|// changes to the dir
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|sr
operator|.
name|close
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
operator|&&
name|sr
operator|.
name|hasChanges
condition|)
block|{
comment|// Abandon the changes& retry closing:
name|sr
operator|.
name|hasChanges
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|sr
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ignore
parameter_list|)
block|{
comment|// Keep throwing original exception
block|}
block|}
block|}
block|}
block|}
comment|/** Remove all our references to readers, and commits    *  any pending changes. */
DECL|method|close
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|SegmentInfo
argument_list|,
name|SegmentReader
argument_list|>
argument_list|>
name|iter
init|=
name|readerMap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|SegmentInfo
argument_list|,
name|SegmentReader
argument_list|>
name|ent
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|SegmentReader
name|sr
init|=
name|ent
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|sr
operator|.
name|hasChanges
condition|)
block|{
assert|assert
name|writer
operator|.
name|infoIsLive
argument_list|(
name|sr
operator|.
name|getSegmentInfo
argument_list|()
argument_list|)
assert|;
name|sr
operator|.
name|startCommit
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|sr
operator|.
name|doCommit
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|sr
operator|.
name|rollbackCommit
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|// NOTE: it is allowed that this decRef does not
comment|// actually close the SR; this can happen when a
comment|// near real-time reader is kept open after the
comment|// IndexWriter instance is closed
name|sr
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Commit all segment reader in the pool.    * @throws IOException    */
DECL|method|commit
specifier|synchronized
name|void
name|commit
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|SegmentInfo
argument_list|,
name|SegmentReader
argument_list|>
name|ent
range|:
name|readerMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|SegmentReader
name|sr
init|=
name|ent
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|sr
operator|.
name|hasChanges
condition|)
block|{
assert|assert
name|writer
operator|.
name|infoIsLive
argument_list|(
name|sr
operator|.
name|getSegmentInfo
argument_list|()
argument_list|)
assert|;
name|sr
operator|.
name|startCommit
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|sr
operator|.
name|doCommit
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|sr
operator|.
name|rollbackCommit
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Returns a ref to a clone.  NOTE: this clone is not    * enrolled in the pool, so you should simply close()    * it when you're done (ie, do not call release()).    */
DECL|method|getReadOnlyClone
specifier|public
specifier|synchronized
name|SegmentReader
name|getReadOnlyClone
parameter_list|(
name|SegmentInfo
name|info
parameter_list|,
name|boolean
name|doOpenStores
parameter_list|,
name|int
name|termInfosIndexDivisor
parameter_list|)
throws|throws
name|IOException
block|{
name|SegmentReader
name|sr
init|=
name|get
argument_list|(
name|info
argument_list|,
name|doOpenStores
argument_list|,
name|BufferedIndexInput
operator|.
name|BUFFER_SIZE
argument_list|,
name|termInfosIndexDivisor
argument_list|)
decl_stmt|;
try|try
block|{
return|return
operator|(
name|SegmentReader
operator|)
name|sr
operator|.
name|clone
argument_list|(
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|sr
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Obtain a SegmentReader from the readerPool.  The reader    * must be returned by calling {@link #release(SegmentReader)}    * @see #release(SegmentReader)    * @param info    * @param doOpenStores    * @throws IOException    */
DECL|method|get
specifier|public
specifier|synchronized
name|SegmentReader
name|get
parameter_list|(
name|SegmentInfo
name|info
parameter_list|,
name|boolean
name|doOpenStores
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|get
argument_list|(
name|info
argument_list|,
name|doOpenStores
argument_list|,
name|BufferedIndexInput
operator|.
name|BUFFER_SIZE
argument_list|,
name|config
operator|.
name|getReaderTermsIndexDivisor
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Obtain a SegmentReader from the readerPool.  The reader    * must be returned by calling {@link #release(SegmentReader)}    *     * @see #release(SegmentReader)    * @param info    * @param doOpenStores    * @param readBufferSize    * @param termsIndexDivisor    * @throws IOException    */
DECL|method|get
specifier|public
specifier|synchronized
name|SegmentReader
name|get
parameter_list|(
name|SegmentInfo
name|info
parameter_list|,
name|boolean
name|doOpenStores
parameter_list|,
name|int
name|readBufferSize
parameter_list|,
name|int
name|termsIndexDivisor
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|writer
operator|.
name|poolReaders
condition|)
block|{
name|readBufferSize
operator|=
name|BufferedIndexInput
operator|.
name|BUFFER_SIZE
expr_stmt|;
block|}
name|SegmentReader
name|sr
init|=
name|readerMap
operator|.
name|get
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|sr
operator|==
literal|null
condition|)
block|{
comment|// TODO: we may want to avoid doing this while
comment|// synchronized
comment|// Returns a ref, which we xfer to readerMap:
name|sr
operator|=
name|SegmentReader
operator|.
name|get
argument_list|(
literal|false
argument_list|,
name|info
operator|.
name|dir
argument_list|,
name|info
argument_list|,
name|readBufferSize
argument_list|,
name|doOpenStores
argument_list|,
name|termsIndexDivisor
argument_list|,
name|config
operator|.
name|getCodecProvider
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|dir
operator|==
name|directory
condition|)
block|{
comment|// Only pool if reader is not external
name|readerMap
operator|.
name|put
argument_list|(
name|info
argument_list|,
name|sr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|doOpenStores
condition|)
block|{
name|sr
operator|.
name|openDocStores
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|termsIndexDivisor
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// If this reader was originally opened because we
comment|// needed to merge it, we didn't load the terms
comment|// index.  But now, if the caller wants the terms
comment|// index (eg because it's doing deletes, or an NRT
comment|// reader is being opened) we ask the reader to
comment|// load its terms index.
name|sr
operator|.
name|loadTermsIndex
argument_list|(
name|termsIndexDivisor
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Return a ref to our caller
if|if
condition|(
name|info
operator|.
name|dir
operator|==
name|directory
condition|)
block|{
comment|// Only incRef if we pooled (reader is not external)
name|sr
operator|.
name|incRef
argument_list|()
expr_stmt|;
block|}
return|return
name|sr
return|;
block|}
comment|// Returns a ref
DECL|method|getIfExists
specifier|public
specifier|synchronized
name|SegmentReader
name|getIfExists
parameter_list|(
name|SegmentInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|SegmentReader
name|sr
init|=
name|readerMap
operator|.
name|get
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|sr
operator|!=
literal|null
condition|)
block|{
name|sr
operator|.
name|incRef
argument_list|()
expr_stmt|;
block|}
return|return
name|sr
return|;
block|}
block|}
end_class
end_unit
