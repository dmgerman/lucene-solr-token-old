begin_unit
begin_package
DECL|package|org.apache.lucene.index.codecs.preflex
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|preflex
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFileNames
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|FieldsProducer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|CompoundFileDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|UnicodeUtil
import|;
end_import
begin_comment
comment|/** Exposes flex API on a pre-flex index, as a codec.   * @lucene.experimental  * @deprecated (4.0)  */
end_comment
begin_class
annotation|@
name|Deprecated
DECL|class|PreFlexFields
specifier|public
class|class
name|PreFlexFields
extends|extends
name|FieldsProducer
block|{
DECL|field|DEBUG_SURROGATES
specifier|private
specifier|static
specifier|final
name|boolean
name|DEBUG_SURROGATES
init|=
literal|false
decl_stmt|;
DECL|field|tis
specifier|public
name|TermInfosReader
name|tis
decl_stmt|;
DECL|field|tisNoIndex
specifier|public
specifier|final
name|TermInfosReader
name|tisNoIndex
decl_stmt|;
DECL|field|freqStream
specifier|public
specifier|final
name|IndexInput
name|freqStream
decl_stmt|;
DECL|field|proxStream
specifier|public
specifier|final
name|IndexInput
name|proxStream
decl_stmt|;
DECL|field|fieldInfos
specifier|final
specifier|private
name|FieldInfos
name|fieldInfos
decl_stmt|;
DECL|field|si
specifier|private
specifier|final
name|SegmentInfo
name|si
decl_stmt|;
DECL|field|fields
specifier|final
name|TreeMap
argument_list|<
name|String
argument_list|,
name|FieldInfo
argument_list|>
name|fields
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|FieldInfo
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|preTerms
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Terms
argument_list|>
name|preTerms
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Terms
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|dir
specifier|private
specifier|final
name|Directory
name|dir
decl_stmt|;
DECL|field|readBufferSize
specifier|private
specifier|final
name|int
name|readBufferSize
decl_stmt|;
DECL|field|cfsReader
specifier|private
name|Directory
name|cfsReader
decl_stmt|;
DECL|method|PreFlexFields
specifier|public
name|PreFlexFields
parameter_list|(
name|Directory
name|dir
parameter_list|,
name|FieldInfos
name|fieldInfos
parameter_list|,
name|SegmentInfo
name|info
parameter_list|,
name|int
name|readBufferSize
parameter_list|,
name|int
name|indexDivisor
parameter_list|)
throws|throws
name|IOException
block|{
name|si
operator|=
name|info
expr_stmt|;
comment|// NOTE: we must always load terms index, even for
comment|// "sequential" scan during merging, because what is
comment|// sequential to merger may not be to TermInfosReader
comment|// since we do the surrogates dance:
if|if
condition|(
name|indexDivisor
operator|<
literal|0
condition|)
block|{
name|indexDivisor
operator|=
operator|-
name|indexDivisor
expr_stmt|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|TermInfosReader
name|r
init|=
operator|new
name|TermInfosReader
argument_list|(
name|dir
argument_list|,
name|info
operator|.
name|name
argument_list|,
name|fieldInfos
argument_list|,
name|readBufferSize
argument_list|,
name|indexDivisor
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexDivisor
operator|==
operator|-
literal|1
condition|)
block|{
name|tisNoIndex
operator|=
name|r
expr_stmt|;
block|}
else|else
block|{
name|tisNoIndex
operator|=
literal|null
expr_stmt|;
name|tis
operator|=
name|r
expr_stmt|;
block|}
name|this
operator|.
name|readBufferSize
operator|=
name|readBufferSize
expr_stmt|;
name|this
operator|.
name|fieldInfos
operator|=
name|fieldInfos
expr_stmt|;
comment|// make sure that all index files have been read or are kept open
comment|// so that if an index update removes them we'll still have them
name|freqStream
operator|=
name|dir
operator|.
name|openInput
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|info
operator|.
name|name
argument_list|,
literal|""
argument_list|,
name|PreFlexCodec
operator|.
name|FREQ_EXTENSION
argument_list|)
argument_list|,
name|readBufferSize
argument_list|)
expr_stmt|;
name|boolean
name|anyProx
init|=
literal|false
decl_stmt|;
for|for
control|(
name|FieldInfo
name|fi
range|:
name|fieldInfos
control|)
block|{
if|if
condition|(
name|fi
operator|.
name|isIndexed
condition|)
block|{
name|fields
operator|.
name|put
argument_list|(
name|fi
operator|.
name|name
argument_list|,
name|fi
argument_list|)
expr_stmt|;
name|preTerms
operator|.
name|put
argument_list|(
name|fi
operator|.
name|name
argument_list|,
operator|new
name|PreTerms
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fi
operator|.
name|omitTermFreqAndPositions
condition|)
block|{
name|anyProx
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|anyProx
condition|)
block|{
name|proxStream
operator|=
name|dir
operator|.
name|openInput
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|info
operator|.
name|name
argument_list|,
literal|""
argument_list|,
name|PreFlexCodec
operator|.
name|PROX_EXTENSION
argument_list|)
argument_list|,
name|readBufferSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|proxStream
operator|=
literal|null
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
comment|// With lock-less commits, it's entirely possible (and
comment|// fine) to hit a FileNotFound exception above. In
comment|// this case, we want to explicitly close any subset
comment|// of things that were opened so that we don't have to
comment|// wait for a GC to do so.
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|this
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
block|}
comment|// If this returns, we do the surrogates dance so that the
comment|// terms are sorted by unicode sort order.  This should be
comment|// true when segments are used for "normal" searching;
comment|// it's only false during testing, to create a pre-flex
comment|// index, using the test-only PreFlexRW.
DECL|method|sortTermsByUnicode
specifier|protected
name|boolean
name|sortTermsByUnicode
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
DECL|method|files
specifier|static
name|void
name|files
parameter_list|(
name|Directory
name|dir
parameter_list|,
name|SegmentInfo
name|info
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
throws|throws
name|IOException
block|{
name|files
operator|.
name|add
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|info
operator|.
name|name
argument_list|,
literal|""
argument_list|,
name|PreFlexCodec
operator|.
name|TERMS_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|files
operator|.
name|add
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|info
operator|.
name|name
argument_list|,
literal|""
argument_list|,
name|PreFlexCodec
operator|.
name|TERMS_INDEX_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|files
operator|.
name|add
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|info
operator|.
name|name
argument_list|,
literal|""
argument_list|,
name|PreFlexCodec
operator|.
name|FREQ_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|getHasProx
argument_list|()
condition|)
block|{
comment|// LUCENE-1739: for certain versions of 2.9-dev,
comment|// hasProx would be incorrectly computed during
comment|// indexing as true, and then stored into the segments
comment|// file, when it should have been false.  So we do the
comment|// extra check, here:
specifier|final
name|String
name|prx
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|info
operator|.
name|name
argument_list|,
literal|""
argument_list|,
name|PreFlexCodec
operator|.
name|PROX_EXTENSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|.
name|fileExists
argument_list|(
name|prx
argument_list|)
condition|)
block|{
name|files
operator|.
name|add
argument_list|(
name|prx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|FieldsEnum
name|iterator
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|PreFlexFieldsEnum
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|terms
specifier|public
name|Terms
name|terms
parameter_list|(
name|String
name|field
parameter_list|)
block|{
return|return
name|preTerms
operator|.
name|get
argument_list|(
name|field
argument_list|)
return|;
block|}
DECL|method|getTermsDict
specifier|synchronized
specifier|private
name|TermInfosReader
name|getTermsDict
parameter_list|()
block|{
if|if
condition|(
name|tis
operator|!=
literal|null
condition|)
block|{
return|return
name|tis
return|;
block|}
else|else
block|{
return|return
name|tisNoIndex
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|loadTermsIndex
specifier|synchronized
specifier|public
name|void
name|loadTermsIndex
parameter_list|(
name|int
name|indexDivisor
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tis
operator|==
literal|null
condition|)
block|{
name|Directory
name|dir0
decl_stmt|;
if|if
condition|(
name|si
operator|.
name|getUseCompoundFile
argument_list|()
condition|)
block|{
comment|// In some cases, we were originally opened when CFS
comment|// was not used, but then we are asked to open the
comment|// terms reader with index, the segment has switched
comment|// to CFS
if|if
condition|(
operator|!
operator|(
name|dir
operator|instanceof
name|CompoundFileDirectory
operator|)
condition|)
block|{
name|dir0
operator|=
name|cfsReader
operator|=
name|dir
operator|.
name|openCompoundInput
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|si
operator|.
name|name
argument_list|,
literal|""
argument_list|,
name|IndexFileNames
operator|.
name|COMPOUND_FILE_EXTENSION
argument_list|)
argument_list|,
name|readBufferSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dir0
operator|=
name|dir
expr_stmt|;
block|}
name|dir0
operator|=
name|cfsReader
expr_stmt|;
block|}
else|else
block|{
name|dir0
operator|=
name|dir
expr_stmt|;
block|}
name|tis
operator|=
operator|new
name|TermInfosReader
argument_list|(
name|dir0
argument_list|,
name|si
operator|.
name|name
argument_list|,
name|fieldInfos
argument_list|,
name|readBufferSize
argument_list|,
name|indexDivisor
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|tis
operator|!=
literal|null
condition|)
block|{
name|tis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tisNoIndex
operator|!=
literal|null
condition|)
block|{
name|tisNoIndex
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cfsReader
operator|!=
literal|null
condition|)
block|{
name|cfsReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|freqStream
operator|!=
literal|null
condition|)
block|{
name|freqStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|proxStream
operator|!=
literal|null
condition|)
block|{
name|proxStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|PreFlexFieldsEnum
specifier|private
class|class
name|PreFlexFieldsEnum
extends|extends
name|FieldsEnum
block|{
DECL|field|it
specifier|final
name|Iterator
argument_list|<
name|FieldInfo
argument_list|>
name|it
decl_stmt|;
DECL|field|termsEnum
specifier|private
specifier|final
name|PreTermsEnum
name|termsEnum
decl_stmt|;
DECL|field|current
name|FieldInfo
name|current
decl_stmt|;
DECL|method|PreFlexFieldsEnum
specifier|public
name|PreFlexFieldsEnum
parameter_list|()
throws|throws
name|IOException
block|{
name|it
operator|=
name|fields
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|termsEnum
operator|=
operator|new
name|PreTermsEnum
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|String
name|next
parameter_list|()
block|{
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|current
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
name|current
operator|.
name|name
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|terms
specifier|public
name|TermsEnum
name|terms
parameter_list|()
throws|throws
name|IOException
block|{
name|termsEnum
operator|.
name|reset
argument_list|(
name|current
argument_list|)
expr_stmt|;
return|return
name|termsEnum
return|;
block|}
block|}
DECL|class|PreTerms
specifier|private
class|class
name|PreTerms
extends|extends
name|Terms
block|{
DECL|field|fieldInfo
specifier|final
name|FieldInfo
name|fieldInfo
decl_stmt|;
DECL|method|PreTerms
name|PreTerms
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
name|this
operator|.
name|fieldInfo
operator|=
name|fieldInfo
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|TermsEnum
name|iterator
parameter_list|()
throws|throws
name|IOException
block|{
name|PreTermsEnum
name|termsEnum
init|=
operator|new
name|PreTermsEnum
argument_list|()
decl_stmt|;
name|termsEnum
operator|.
name|reset
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
return|return
name|termsEnum
return|;
block|}
annotation|@
name|Override
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
comment|// Pre-flex indexes always sorted in UTF16 order, but
comment|// we remap on-the-fly to unicode order
if|if
condition|(
name|sortTermsByUnicode
argument_list|()
condition|)
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUTF16Comparator
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getSumTotalTermFreq
specifier|public
name|long
name|getSumTotalTermFreq
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
DECL|class|PreTermsEnum
specifier|private
class|class
name|PreTermsEnum
extends|extends
name|TermsEnum
block|{
DECL|field|termEnum
specifier|private
name|SegmentTermEnum
name|termEnum
decl_stmt|;
DECL|field|fieldInfo
specifier|private
name|FieldInfo
name|fieldInfo
decl_stmt|;
DECL|field|internedFieldName
specifier|private
name|String
name|internedFieldName
decl_stmt|;
DECL|field|skipNext
specifier|private
name|boolean
name|skipNext
decl_stmt|;
DECL|field|current
specifier|private
name|BytesRef
name|current
decl_stmt|;
DECL|field|seekTermEnum
specifier|private
name|SegmentTermEnum
name|seekTermEnum
decl_stmt|;
DECL|field|UTF8_NON_BMP_LEAD
specifier|private
specifier|static
specifier|final
name|byte
name|UTF8_NON_BMP_LEAD
init|=
operator|(
name|byte
operator|)
literal|0xf0
decl_stmt|;
DECL|field|UTF8_HIGH_BMP_LEAD
specifier|private
specifier|static
specifier|final
name|byte
name|UTF8_HIGH_BMP_LEAD
init|=
operator|(
name|byte
operator|)
literal|0xee
decl_stmt|;
comment|// Returns true if the unicode char is "after" the
comment|// surrogates in UTF16, ie>= U+E000 and<= U+FFFF:
DECL|method|isHighBMPChar
specifier|private
specifier|final
name|boolean
name|isHighBMPChar
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
return|return
operator|(
name|b
index|[
name|idx
index|]
operator|&
name|UTF8_HIGH_BMP_LEAD
operator|)
operator|==
name|UTF8_HIGH_BMP_LEAD
return|;
block|}
comment|// Returns true if the unicode char in the UTF8 byte
comment|// sequence starting at idx encodes a char outside of
comment|// BMP (ie what would be a surrogate pair in UTF16):
DECL|method|isNonBMPChar
specifier|private
specifier|final
name|boolean
name|isNonBMPChar
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
return|return
operator|(
name|b
index|[
name|idx
index|]
operator|&
name|UTF8_NON_BMP_LEAD
operator|)
operator|==
name|UTF8_NON_BMP_LEAD
return|;
block|}
DECL|field|scratch
specifier|private
specifier|final
name|byte
index|[]
name|scratch
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
DECL|field|prevTerm
specifier|private
specifier|final
name|BytesRef
name|prevTerm
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
DECL|field|scratchTerm
specifier|private
specifier|final
name|BytesRef
name|scratchTerm
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
DECL|field|newSuffixStart
specifier|private
name|int
name|newSuffixStart
decl_stmt|;
comment|// Swap in S, in place of E:
DECL|method|seekToNonBMP
specifier|private
name|boolean
name|seekToNonBMP
parameter_list|(
name|SegmentTermEnum
name|te
parameter_list|,
name|BytesRef
name|term
parameter_list|,
name|int
name|pos
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|savLength
init|=
name|term
operator|.
name|length
decl_stmt|;
assert|assert
name|term
operator|.
name|offset
operator|==
literal|0
assert|;
comment|// The 3 bytes starting at downTo make up 1
comment|// unicode character:
assert|assert
name|isHighBMPChar
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|pos
argument_list|)
assert|;
comment|// NOTE: we cannot make this assert, because
comment|// AutomatonQuery legitimately sends us malformed UTF8
comment|// (eg the UTF8 bytes with just 0xee)
comment|// assert term.length>= pos + 3: "term.length=" + term.length + " pos+3=" + (pos+3) + " byte=" + Integer.toHexString(term.bytes[pos]) + " term=" + term.toString();
comment|// Save the bytes&& length, since we need to
comment|// restore this if seek "back" finds no matching
comment|// terms
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
literal|4
operator|+
name|pos
condition|)
block|{
name|term
operator|.
name|grow
argument_list|(
literal|4
operator|+
name|pos
argument_list|)
expr_stmt|;
block|}
name|scratch
index|[
literal|0
index|]
operator|=
name|term
operator|.
name|bytes
index|[
name|pos
index|]
expr_stmt|;
name|scratch
index|[
literal|1
index|]
operator|=
name|term
operator|.
name|bytes
index|[
name|pos
operator|+
literal|1
index|]
expr_stmt|;
name|scratch
index|[
literal|2
index|]
operator|=
name|term
operator|.
name|bytes
index|[
name|pos
operator|+
literal|2
index|]
expr_stmt|;
name|term
operator|.
name|bytes
index|[
name|pos
index|]
operator|=
operator|(
name|byte
operator|)
literal|0xf0
expr_stmt|;
name|term
operator|.
name|bytes
index|[
name|pos
operator|+
literal|1
index|]
operator|=
operator|(
name|byte
operator|)
literal|0x90
expr_stmt|;
name|term
operator|.
name|bytes
index|[
name|pos
operator|+
literal|2
index|]
operator|=
operator|(
name|byte
operator|)
literal|0x80
expr_stmt|;
name|term
operator|.
name|bytes
index|[
name|pos
operator|+
literal|3
index|]
operator|=
operator|(
name|byte
operator|)
literal|0x80
expr_stmt|;
name|term
operator|.
name|length
operator|=
literal|4
operator|+
name|pos
expr_stmt|;
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      try seek term="
operator|+
name|UnicodeUtil
operator|.
name|toHexString
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Seek "back":
name|getTermsDict
argument_list|()
operator|.
name|seekEnum
argument_list|(
name|te
argument_list|,
operator|new
name|Term
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|term
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Test if the term we seek'd to in fact found a
comment|// surrogate pair at the same position as the E:
name|Term
name|t2
init|=
name|te
operator|.
name|term
argument_list|()
decl_stmt|;
comment|// Cannot be null (or move to next field) because at
comment|// "worst" it'd seek to the same term we are on now,
comment|// unless we are being called from seek
if|if
condition|(
name|t2
operator|==
literal|null
operator|||
name|t2
operator|.
name|field
argument_list|()
operator|!=
name|internedFieldName
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      got term="
operator|+
name|UnicodeUtil
operator|.
name|toHexString
argument_list|(
name|t2
operator|.
name|text
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Now test if prefix is identical and we found
comment|// a non-BMP char at the same position:
name|BytesRef
name|b2
init|=
name|t2
operator|.
name|bytes
argument_list|()
decl_stmt|;
assert|assert
name|b2
operator|.
name|offset
operator|==
literal|0
assert|;
name|boolean
name|matches
decl_stmt|;
if|if
condition|(
name|b2
operator|.
name|length
operator|>=
name|term
operator|.
name|length
operator|&&
name|isNonBMPChar
argument_list|(
name|b2
operator|.
name|bytes
argument_list|,
name|pos
argument_list|)
condition|)
block|{
name|matches
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|term
operator|.
name|bytes
index|[
name|i
index|]
operator|!=
name|b2
operator|.
name|bytes
index|[
name|i
index|]
condition|)
block|{
name|matches
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|matches
operator|=
literal|false
expr_stmt|;
block|}
comment|// Restore term:
name|term
operator|.
name|length
operator|=
name|savLength
expr_stmt|;
name|term
operator|.
name|bytes
index|[
name|pos
index|]
operator|=
name|scratch
index|[
literal|0
index|]
expr_stmt|;
name|term
operator|.
name|bytes
index|[
name|pos
operator|+
literal|1
index|]
operator|=
name|scratch
index|[
literal|1
index|]
expr_stmt|;
name|term
operator|.
name|bytes
index|[
name|pos
operator|+
literal|2
index|]
operator|=
name|scratch
index|[
literal|2
index|]
expr_stmt|;
return|return
name|matches
return|;
block|}
comment|// Seek type 2 "continue" (back to the start of the
comment|// surrogates): scan the stripped suffix from the
comment|// prior term, backwards. If there was an E in that
comment|// part, then we try to seek back to S.  If that
comment|// seek finds a matching term, we go there.
DECL|method|doContinue
specifier|private
name|boolean
name|doContinue
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  try cont"
argument_list|)
expr_stmt|;
block|}
name|int
name|downTo
init|=
name|prevTerm
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|boolean
name|didSeek
init|=
literal|false
decl_stmt|;
specifier|final
name|int
name|limit
init|=
name|Math
operator|.
name|min
argument_list|(
name|newSuffixStart
argument_list|,
name|scratchTerm
operator|.
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
name|downTo
operator|>
name|limit
condition|)
block|{
if|if
condition|(
name|isHighBMPChar
argument_list|(
name|prevTerm
operator|.
name|bytes
argument_list|,
name|downTo
argument_list|)
condition|)
block|{
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    found E pos="
operator|+
name|downTo
operator|+
literal|" vs len="
operator|+
name|prevTerm
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seekToNonBMP
argument_list|(
name|seekTermEnum
argument_list|,
name|prevTerm
argument_list|,
name|downTo
argument_list|)
condition|)
block|{
comment|// TODO: more efficient seek?
name|getTermsDict
argument_list|()
operator|.
name|seekEnum
argument_list|(
name|termEnum
argument_list|,
name|seekTermEnum
operator|.
name|term
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//newSuffixStart = downTo+4;
name|newSuffixStart
operator|=
name|downTo
expr_stmt|;
name|scratchTerm
operator|.
name|copy
argument_list|(
name|termEnum
operator|.
name|term
argument_list|()
operator|.
name|bytes
argument_list|()
argument_list|)
expr_stmt|;
name|didSeek
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      seek!"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      no seek"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Shorten prevTerm in place so that we don't redo
comment|// this loop if we come back here:
if|if
condition|(
operator|(
name|prevTerm
operator|.
name|bytes
index|[
name|downTo
index|]
operator|&
literal|0xc0
operator|)
operator|==
literal|0xc0
operator|||
operator|(
name|prevTerm
operator|.
name|bytes
index|[
name|downTo
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|prevTerm
operator|.
name|length
operator|=
name|downTo
expr_stmt|;
block|}
name|downTo
operator|--
expr_stmt|;
block|}
return|return
name|didSeek
return|;
block|}
comment|// Look for seek type 3 ("pop"): if the delta from
comment|// prev -> current was replacing an S with an E,
comment|// we must now seek to beyond that E.  This seek
comment|// "finishes" the dance at this character
comment|// position.
DECL|method|doPop
specifier|private
name|boolean
name|doPop
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  try pop"
argument_list|)
expr_stmt|;
block|}
assert|assert
name|newSuffixStart
operator|<=
name|prevTerm
operator|.
name|length
assert|;
assert|assert
name|newSuffixStart
operator|<
name|scratchTerm
operator|.
name|length
operator|||
name|newSuffixStart
operator|==
literal|0
assert|;
if|if
condition|(
name|prevTerm
operator|.
name|length
operator|>
name|newSuffixStart
operator|&&
name|isNonBMPChar
argument_list|(
name|prevTerm
operator|.
name|bytes
argument_list|,
name|newSuffixStart
argument_list|)
operator|&&
name|isHighBMPChar
argument_list|(
name|scratchTerm
operator|.
name|bytes
argument_list|,
name|newSuffixStart
argument_list|)
condition|)
block|{
comment|// Seek type 2 -- put 0xFF at this position:
name|scratchTerm
operator|.
name|bytes
index|[
name|newSuffixStart
index|]
operator|=
operator|(
name|byte
operator|)
literal|0xff
expr_stmt|;
name|scratchTerm
operator|.
name|length
operator|=
name|newSuffixStart
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    seek to term="
operator|+
name|UnicodeUtil
operator|.
name|toHexString
argument_list|(
name|scratchTerm
operator|.
name|utf8ToString
argument_list|()
argument_list|)
operator|+
literal|" "
operator|+
name|scratchTerm
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// TODO: more efficient seek?  can we simply swap
comment|// the enums?
name|getTermsDict
argument_list|()
operator|.
name|seekEnum
argument_list|(
name|termEnum
argument_list|,
operator|new
name|Term
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|scratchTerm
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|Term
name|t2
init|=
name|termEnum
operator|.
name|term
argument_list|()
decl_stmt|;
comment|// We could hit EOF or different field since this
comment|// was a seek "forward":
if|if
condition|(
name|t2
operator|!=
literal|null
operator|&&
name|t2
operator|.
name|field
argument_list|()
operator|==
name|internedFieldName
condition|)
block|{
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      got term="
operator|+
name|UnicodeUtil
operator|.
name|toHexString
argument_list|(
name|t2
operator|.
name|text
argument_list|()
argument_list|)
operator|+
literal|" "
operator|+
name|t2
operator|.
name|bytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|BytesRef
name|b2
init|=
name|t2
operator|.
name|bytes
argument_list|()
decl_stmt|;
assert|assert
name|b2
operator|.
name|offset
operator|==
literal|0
assert|;
comment|// Set newSuffixStart -- we can't use
comment|// termEnum's since the above seek may have
comment|// done no scanning (eg, term was precisely
comment|// and index term, or, was in the term seek
comment|// cache):
name|scratchTerm
operator|.
name|copy
argument_list|(
name|b2
argument_list|)
expr_stmt|;
name|setNewSuffixStart
argument_list|(
name|prevTerm
argument_list|,
name|scratchTerm
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|newSuffixStart
operator|!=
literal|0
operator|||
name|scratchTerm
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      got term=null (or next field)"
argument_list|)
expr_stmt|;
block|}
name|newSuffixStart
operator|=
literal|0
expr_stmt|;
name|scratchTerm
operator|.
name|length
operator|=
literal|0
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// Pre-flex indices store terms in UTF16 sort order, but
comment|// certain queries require Unicode codepoint order; this
comment|// method carefully seeks around surrogates to handle
comment|// this impedance mismatch
DECL|method|surrogateDance
specifier|private
name|void
name|surrogateDance
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|unicodeSortOrder
condition|)
block|{
return|return;
block|}
comment|// We are invoked after TIS.next() (by UTF16 order) to
comment|// possibly seek to a different "next" (by unicode
comment|// order) term.
comment|// We scan only the "delta" from the last term to the
comment|// current term, in UTF8 bytes.  We look at 1) the bytes
comment|// stripped from the prior term, and then 2) the bytes
comment|// appended to that prior term's prefix.
comment|// We don't care about specific UTF8 sequences, just
comment|// the "category" of the UTF16 character.  Category S
comment|// is a high/low surrogate pair (it non-BMP).
comment|// Category E is any BMP char> UNI_SUR_LOW_END (and<
comment|// U+FFFF). Category A is the rest (any unicode char
comment|//<= UNI_SUR_HIGH_START).
comment|// The core issue is that pre-flex indices sort the
comment|// characters as ASE, while flex must sort as AES.  So
comment|// when scanning, when we hit S, we must 1) seek
comment|// forward to E and enum the terms there, then 2) seek
comment|// back to S and enum all terms there, then 3) seek to
comment|// after E.  Three different seek points (1, 2, 3).
comment|// We can easily detect S in UTF8: if a byte has
comment|// prefix 11110 (0xf0), then that byte and the
comment|// following 3 bytes encode a single unicode codepoint
comment|// in S.  Similarly, we can detect E: if a byte has
comment|// prefix 1110111 (0xee), then that byte and the
comment|// following 2 bytes encode a single unicode codepoint
comment|// in E.
comment|// Note that this is really a recursive process --
comment|// maybe the char at pos 2 needs to dance, but any
comment|// point in its dance, suddenly pos 4 needs to dance
comment|// so you must finish pos 4 before returning to pos
comment|// 2.  But then during pos 4's dance maybe pos 7 needs
comment|// to dance, etc.  However, despite being recursive,
comment|// we don't need to hold any state because the state
comment|// can always be derived by looking at prior term&
comment|// current term.
comment|// TODO: can we avoid this copy?
if|if
condition|(
name|termEnum
operator|.
name|term
argument_list|()
operator|==
literal|null
operator|||
name|termEnum
operator|.
name|term
argument_list|()
operator|.
name|field
argument_list|()
operator|!=
name|internedFieldName
condition|)
block|{
name|scratchTerm
operator|.
name|length
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|scratchTerm
operator|.
name|copy
argument_list|(
name|termEnum
operator|.
name|term
argument_list|()
operator|.
name|bytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  dance"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    prev="
operator|+
name|UnicodeUtil
operator|.
name|toHexString
argument_list|(
name|prevTerm
operator|.
name|utf8ToString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"         "
operator|+
name|prevTerm
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    term="
operator|+
name|UnicodeUtil
operator|.
name|toHexString
argument_list|(
name|scratchTerm
operator|.
name|utf8ToString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"         "
operator|+
name|scratchTerm
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// This code assumes TermInfosReader/SegmentTermEnum
comment|// always use BytesRef.offset == 0
assert|assert
name|prevTerm
operator|.
name|offset
operator|==
literal|0
assert|;
assert|assert
name|scratchTerm
operator|.
name|offset
operator|==
literal|0
assert|;
comment|// Need to loop here because we may need to do multiple
comment|// pops, and possibly a continue in the end, ie:
comment|//
comment|//  cont
comment|//  pop, cont
comment|//  pop, pop, cont
comment|//<nothing>
comment|//
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|doContinue
argument_list|()
condition|)
block|{
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|doPop
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  finish bmp ends"
argument_list|)
expr_stmt|;
block|}
name|doPushes
argument_list|()
expr_stmt|;
block|}
comment|// Look for seek type 1 ("push"): if the newly added
comment|// suffix contains any S, we must try to seek to the
comment|// corresponding E.  If we find a match, we go there;
comment|// else we keep looking for additional S's in the new
comment|// suffix.  This "starts" the dance, at this character
comment|// position:
DECL|method|doPushes
specifier|private
name|void
name|doPushes
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|upTo
init|=
name|newSuffixStart
decl_stmt|;
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  try push newSuffixStart="
operator|+
name|newSuffixStart
operator|+
literal|" scratchLen="
operator|+
name|scratchTerm
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|upTo
operator|<
name|scratchTerm
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|isNonBMPChar
argument_list|(
name|scratchTerm
operator|.
name|bytes
argument_list|,
name|upTo
argument_list|)
operator|&&
operator|(
name|upTo
operator|>
name|newSuffixStart
operator|||
operator|(
name|upTo
operator|>=
name|prevTerm
operator|.
name|length
operator|||
operator|(
operator|!
name|isNonBMPChar
argument_list|(
name|prevTerm
operator|.
name|bytes
argument_list|,
name|upTo
argument_list|)
operator|&&
operator|!
name|isHighBMPChar
argument_list|(
name|prevTerm
operator|.
name|bytes
argument_list|,
name|upTo
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|// A non-BMP char (4 bytes UTF8) starts here:
assert|assert
name|scratchTerm
operator|.
name|length
operator|>=
name|upTo
operator|+
literal|4
assert|;
specifier|final
name|int
name|savLength
init|=
name|scratchTerm
operator|.
name|length
decl_stmt|;
name|scratch
index|[
literal|0
index|]
operator|=
name|scratchTerm
operator|.
name|bytes
index|[
name|upTo
index|]
expr_stmt|;
name|scratch
index|[
literal|1
index|]
operator|=
name|scratchTerm
operator|.
name|bytes
index|[
name|upTo
operator|+
literal|1
index|]
expr_stmt|;
name|scratch
index|[
literal|2
index|]
operator|=
name|scratchTerm
operator|.
name|bytes
index|[
name|upTo
operator|+
literal|2
index|]
expr_stmt|;
name|scratchTerm
operator|.
name|bytes
index|[
name|upTo
index|]
operator|=
name|UTF8_HIGH_BMP_LEAD
expr_stmt|;
name|scratchTerm
operator|.
name|bytes
index|[
name|upTo
operator|+
literal|1
index|]
operator|=
operator|(
name|byte
operator|)
literal|0x80
expr_stmt|;
name|scratchTerm
operator|.
name|bytes
index|[
name|upTo
operator|+
literal|2
index|]
operator|=
operator|(
name|byte
operator|)
literal|0x80
expr_stmt|;
name|scratchTerm
operator|.
name|length
operator|=
name|upTo
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    try seek 1 pos="
operator|+
name|upTo
operator|+
literal|" term="
operator|+
name|UnicodeUtil
operator|.
name|toHexString
argument_list|(
name|scratchTerm
operator|.
name|utf8ToString
argument_list|()
argument_list|)
operator|+
literal|" "
operator|+
name|scratchTerm
operator|.
name|toString
argument_list|()
operator|+
literal|" len="
operator|+
name|scratchTerm
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|// Seek "forward":
comment|// TODO: more efficient seek?
name|getTermsDict
argument_list|()
operator|.
name|seekEnum
argument_list|(
name|seekTermEnum
argument_list|,
operator|new
name|Term
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|scratchTerm
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|scratchTerm
operator|.
name|bytes
index|[
name|upTo
index|]
operator|=
name|scratch
index|[
literal|0
index|]
expr_stmt|;
name|scratchTerm
operator|.
name|bytes
index|[
name|upTo
operator|+
literal|1
index|]
operator|=
name|scratch
index|[
literal|1
index|]
expr_stmt|;
name|scratchTerm
operator|.
name|bytes
index|[
name|upTo
operator|+
literal|2
index|]
operator|=
name|scratch
index|[
literal|2
index|]
expr_stmt|;
name|scratchTerm
operator|.
name|length
operator|=
name|savLength
expr_stmt|;
comment|// Did we find a match?
specifier|final
name|Term
name|t2
init|=
name|seekTermEnum
operator|.
name|term
argument_list|()
decl_stmt|;
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
if|if
condition|(
name|t2
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      hit term=null"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      hit term="
operator|+
name|UnicodeUtil
operator|.
name|toHexString
argument_list|(
name|t2
operator|.
name|text
argument_list|()
argument_list|)
operator|+
literal|" "
operator|+
operator|(
name|t2
operator|==
literal|null
condition|?
literal|null
else|:
name|t2
operator|.
name|bytes
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Since this was a seek "forward", we could hit
comment|// EOF or a different field:
name|boolean
name|matches
decl_stmt|;
if|if
condition|(
name|t2
operator|!=
literal|null
operator|&&
name|t2
operator|.
name|field
argument_list|()
operator|==
name|internedFieldName
condition|)
block|{
specifier|final
name|BytesRef
name|b2
init|=
name|t2
operator|.
name|bytes
argument_list|()
decl_stmt|;
assert|assert
name|b2
operator|.
name|offset
operator|==
literal|0
assert|;
if|if
condition|(
name|b2
operator|.
name|length
operator|>=
name|upTo
operator|+
literal|3
operator|&&
name|isHighBMPChar
argument_list|(
name|b2
operator|.
name|bytes
argument_list|,
name|upTo
argument_list|)
condition|)
block|{
name|matches
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|upTo
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|scratchTerm
operator|.
name|bytes
index|[
name|i
index|]
operator|!=
name|b2
operator|.
name|bytes
index|[
name|i
index|]
condition|)
block|{
name|matches
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|matches
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|matches
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|matches
condition|)
block|{
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      matches!"
argument_list|)
expr_stmt|;
block|}
comment|// OK seek "back"
comment|// TODO: more efficient seek?
name|getTermsDict
argument_list|()
operator|.
name|seekEnum
argument_list|(
name|termEnum
argument_list|,
name|seekTermEnum
operator|.
name|term
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|scratchTerm
operator|.
name|copy
argument_list|(
name|seekTermEnum
operator|.
name|term
argument_list|()
operator|.
name|bytes
argument_list|()
argument_list|)
expr_stmt|;
comment|// +3 because we don't need to check the char
comment|// at upTo: we know it's> BMP
name|upTo
operator|+=
literal|3
expr_stmt|;
comment|// NOTE: we keep iterating, now, since this
comment|// can easily "recurse".  Ie, after seeking
comment|// forward at a certain char position, we may
comment|// find another surrogate in our [new] suffix
comment|// and must then do another seek (recurse)
block|}
else|else
block|{
name|upTo
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|upTo
operator|++
expr_stmt|;
block|}
block|}
block|}
DECL|field|unicodeSortOrder
specifier|private
name|boolean
name|unicodeSortOrder
decl_stmt|;
DECL|method|reset
name|void
name|reset
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("pff.reset te=" + termEnum);
name|this
operator|.
name|fieldInfo
operator|=
name|fieldInfo
expr_stmt|;
name|internedFieldName
operator|=
name|fieldInfo
operator|.
name|name
operator|.
name|intern
argument_list|()
expr_stmt|;
specifier|final
name|Term
name|term
init|=
operator|new
name|Term
argument_list|(
name|internedFieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|termEnum
operator|==
literal|null
condition|)
block|{
name|termEnum
operator|=
name|getTermsDict
argument_list|()
operator|.
name|terms
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|seekTermEnum
operator|=
name|getTermsDict
argument_list|()
operator|.
name|terms
argument_list|(
name|term
argument_list|)
expr_stmt|;
comment|//System.out.println("  term=" + termEnum.term());
block|}
else|else
block|{
name|getTermsDict
argument_list|()
operator|.
name|seekEnum
argument_list|(
name|termEnum
argument_list|,
name|term
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|skipNext
operator|=
literal|true
expr_stmt|;
name|unicodeSortOrder
operator|=
name|sortTermsByUnicode
argument_list|()
expr_stmt|;
specifier|final
name|Term
name|t
init|=
name|termEnum
operator|.
name|term
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
operator|&&
name|t
operator|.
name|field
argument_list|()
operator|==
name|internedFieldName
condition|)
block|{
name|newSuffixStart
operator|=
literal|0
expr_stmt|;
name|prevTerm
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|surrogateDance
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
comment|// Pre-flex indexes always sorted in UTF16 order, but
comment|// we remap on-the-fly to unicode order
if|if
condition|(
name|unicodeSortOrder
condition|)
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUTF16Comparator
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|seek
specifier|public
name|SeekStatus
name|seek
parameter_list|(
name|long
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|seek
specifier|public
name|SeekStatus
name|seek
parameter_list|(
name|BytesRef
name|term
parameter_list|,
name|boolean
name|useCache
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TE.seek target="
operator|+
name|UnicodeUtil
operator|.
name|toHexString
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|skipNext
operator|=
literal|false
expr_stmt|;
specifier|final
name|TermInfosReader
name|tis
init|=
name|getTermsDict
argument_list|()
decl_stmt|;
specifier|final
name|Term
name|t0
init|=
operator|new
name|Term
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|term
argument_list|)
decl_stmt|;
assert|assert
name|termEnum
operator|!=
literal|null
assert|;
name|tis
operator|.
name|seekEnum
argument_list|(
name|termEnum
argument_list|,
name|t0
argument_list|,
name|useCache
argument_list|)
expr_stmt|;
specifier|final
name|Term
name|t
init|=
name|termEnum
operator|.
name|term
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
operator|&&
name|t
operator|.
name|field
argument_list|()
operator|==
name|internedFieldName
operator|&&
name|term
operator|.
name|bytesEquals
argument_list|(
name|t
operator|.
name|bytes
argument_list|()
argument_list|)
condition|)
block|{
comment|// If we found an exact match, no need to do the
comment|// surrogate dance
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  seek exact match"
argument_list|)
expr_stmt|;
block|}
name|current
operator|=
name|t
operator|.
name|bytes
argument_list|()
expr_stmt|;
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
literal|null
operator|||
name|t
operator|.
name|field
argument_list|()
operator|!=
name|internedFieldName
condition|)
block|{
comment|// TODO: maybe we can handle this like the next()
comment|// into null?  set term as prevTerm then dance?
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  seek hit EOF"
argument_list|)
expr_stmt|;
block|}
comment|// We hit EOF; try end-case surrogate dance: if we
comment|// find an E, try swapping in S, backwards:
name|scratchTerm
operator|.
name|copy
argument_list|(
name|term
argument_list|)
expr_stmt|;
assert|assert
name|scratchTerm
operator|.
name|offset
operator|==
literal|0
assert|;
for|for
control|(
name|int
name|i
init|=
name|scratchTerm
operator|.
name|length
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|isHighBMPChar
argument_list|(
name|scratchTerm
operator|.
name|bytes
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    found E pos="
operator|+
name|i
operator|+
literal|"; try seek"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seekToNonBMP
argument_list|(
name|seekTermEnum
argument_list|,
name|scratchTerm
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|scratchTerm
operator|.
name|copy
argument_list|(
name|seekTermEnum
operator|.
name|term
argument_list|()
operator|.
name|bytes
argument_list|()
argument_list|)
expr_stmt|;
name|getTermsDict
argument_list|()
operator|.
name|seekEnum
argument_list|(
name|termEnum
argument_list|,
name|seekTermEnum
operator|.
name|term
argument_list|()
argument_list|,
name|useCache
argument_list|)
expr_stmt|;
name|newSuffixStart
operator|=
literal|1
operator|+
name|i
expr_stmt|;
name|doPushes
argument_list|()
expr_stmt|;
comment|// Found a match
comment|// TODO: faster seek?
name|current
operator|=
name|termEnum
operator|.
name|term
argument_list|()
operator|.
name|bytes
argument_list|()
expr_stmt|;
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
block|}
block|}
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  seek END"
argument_list|)
expr_stmt|;
block|}
name|current
operator|=
literal|null
expr_stmt|;
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
else|else
block|{
comment|// We found a non-exact but non-null term; this one
comment|// is fun -- just treat it like next, by pretending
comment|// requested term was prev:
name|prevTerm
operator|.
name|copy
argument_list|(
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  seek hit non-exact term="
operator|+
name|UnicodeUtil
operator|.
name|toHexString
argument_list|(
name|t
operator|.
name|text
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|BytesRef
name|br
init|=
name|t
operator|.
name|bytes
argument_list|()
decl_stmt|;
assert|assert
name|br
operator|.
name|offset
operator|==
literal|0
assert|;
name|setNewSuffixStart
argument_list|(
name|term
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|surrogateDance
argument_list|()
expr_stmt|;
specifier|final
name|Term
name|t2
init|=
name|termEnum
operator|.
name|term
argument_list|()
decl_stmt|;
if|if
condition|(
name|t2
operator|==
literal|null
operator|||
name|t2
operator|.
name|field
argument_list|()
operator|!=
name|internedFieldName
condition|)
block|{
comment|// PreFlex codec interns field names; verify:
assert|assert
name|t2
operator|==
literal|null
operator|||
operator|!
name|t2
operator|.
name|field
argument_list|()
operator|.
name|equals
argument_list|(
name|internedFieldName
argument_list|)
assert|;
name|current
operator|=
literal|null
expr_stmt|;
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
else|else
block|{
name|current
operator|=
name|t2
operator|.
name|bytes
argument_list|()
expr_stmt|;
assert|assert
operator|!
name|unicodeSortOrder
operator|||
name|term
operator|.
name|compareTo
argument_list|(
name|current
argument_list|)
operator|<
literal|0
operator|:
literal|"term="
operator|+
name|UnicodeUtil
operator|.
name|toHexString
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
operator|+
literal|" vs current="
operator|+
name|UnicodeUtil
operator|.
name|toHexString
argument_list|(
name|current
operator|.
name|utf8ToString
argument_list|()
argument_list|)
assert|;
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
block|}
block|}
DECL|method|setNewSuffixStart
specifier|private
name|void
name|setNewSuffixStart
parameter_list|(
name|BytesRef
name|br1
parameter_list|,
name|BytesRef
name|br2
parameter_list|)
block|{
specifier|final
name|int
name|limit
init|=
name|Math
operator|.
name|min
argument_list|(
name|br1
operator|.
name|length
argument_list|,
name|br2
operator|.
name|length
argument_list|)
decl_stmt|;
name|int
name|lastStart
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|br1
operator|.
name|bytes
index|[
name|br1
operator|.
name|offset
operator|+
name|i
index|]
operator|&
literal|0xc0
operator|)
operator|==
literal|0xc0
operator|||
operator|(
name|br1
operator|.
name|bytes
index|[
name|br1
operator|.
name|offset
operator|+
name|i
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|lastStart
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|br1
operator|.
name|bytes
index|[
name|br1
operator|.
name|offset
operator|+
name|i
index|]
operator|!=
name|br2
operator|.
name|bytes
index|[
name|br2
operator|.
name|offset
operator|+
name|i
index|]
condition|)
block|{
name|newSuffixStart
operator|=
name|lastStart
expr_stmt|;
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    set newSuffixStart="
operator|+
name|newSuffixStart
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
name|newSuffixStart
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    set newSuffixStart="
operator|+
name|newSuffixStart
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TE.next()"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|skipNext
condition|)
block|{
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  skipNext=true"
argument_list|)
expr_stmt|;
block|}
name|skipNext
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|termEnum
operator|.
name|term
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
comment|// PreFlex codec interns field names:
block|}
elseif|else
if|if
condition|(
name|termEnum
operator|.
name|term
argument_list|()
operator|.
name|field
argument_list|()
operator|!=
name|internedFieldName
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|current
operator|=
name|termEnum
operator|.
name|term
argument_list|()
operator|.
name|bytes
argument_list|()
return|;
block|}
block|}
comment|// TODO: can we use STE's prevBuffer here?
name|prevTerm
operator|.
name|copy
argument_list|(
name|termEnum
operator|.
name|term
argument_list|()
operator|.
name|bytes
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|termEnum
operator|.
name|next
argument_list|()
operator|&&
name|termEnum
operator|.
name|term
argument_list|()
operator|.
name|field
argument_list|()
operator|==
name|internedFieldName
condition|)
block|{
name|newSuffixStart
operator|=
name|termEnum
operator|.
name|newSuffixStart
expr_stmt|;
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  newSuffixStart="
operator|+
name|newSuffixStart
argument_list|)
expr_stmt|;
block|}
name|surrogateDance
argument_list|()
expr_stmt|;
specifier|final
name|Term
name|t
init|=
name|termEnum
operator|.
name|term
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
operator|||
name|t
operator|.
name|field
argument_list|()
operator|!=
name|internedFieldName
condition|)
block|{
comment|// PreFlex codec interns field names; verify:
assert|assert
name|t
operator|==
literal|null
operator|||
operator|!
name|t
operator|.
name|field
argument_list|()
operator|.
name|equals
argument_list|(
name|internedFieldName
argument_list|)
assert|;
name|current
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|current
operator|=
name|t
operator|.
name|bytes
argument_list|()
expr_stmt|;
block|}
return|return
name|current
return|;
block|}
else|else
block|{
comment|// This field is exhausted, but we have to give
comment|// surrogateDance a chance to seek back:
if|if
condition|(
name|DEBUG_SURROGATES
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  force cont"
argument_list|)
expr_stmt|;
block|}
comment|//newSuffixStart = prevTerm.length;
name|newSuffixStart
operator|=
literal|0
expr_stmt|;
name|surrogateDance
argument_list|()
expr_stmt|;
specifier|final
name|Term
name|t
init|=
name|termEnum
operator|.
name|term
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
operator|||
name|t
operator|.
name|field
argument_list|()
operator|!=
name|internedFieldName
condition|)
block|{
comment|// PreFlex codec interns field names; verify:
assert|assert
name|t
operator|==
literal|null
operator|||
operator|!
name|t
operator|.
name|field
argument_list|()
operator|.
name|equals
argument_list|(
name|internedFieldName
argument_list|)
assert|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|current
operator|=
name|t
operator|.
name|bytes
argument_list|()
expr_stmt|;
return|return
name|current
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
block|{
return|return
name|current
return|;
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
block|{
return|return
name|termEnum
operator|.
name|docFreq
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|)
throws|throws
name|IOException
block|{
name|PreDocsEnum
name|docsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|==
literal|null
operator|||
operator|!
operator|(
name|reuse
operator|instanceof
name|PreDocsEnum
operator|)
condition|)
block|{
name|docsEnum
operator|=
operator|new
name|PreDocsEnum
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|docsEnum
operator|=
operator|(
name|PreDocsEnum
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
name|docsEnum
operator|.
name|getFreqStream
argument_list|()
operator|!=
name|freqStream
condition|)
block|{
name|docsEnum
operator|=
operator|new
name|PreDocsEnum
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|docsEnum
operator|.
name|reset
argument_list|(
name|termEnum
argument_list|,
name|skipDocs
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|)
throws|throws
name|IOException
block|{
name|PreDocsAndPositionsEnum
name|docsPosEnum
decl_stmt|;
if|if
condition|(
name|fieldInfo
operator|.
name|omitTermFreqAndPositions
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|reuse
operator|==
literal|null
operator|||
operator|!
operator|(
name|reuse
operator|instanceof
name|PreDocsAndPositionsEnum
operator|)
condition|)
block|{
name|docsPosEnum
operator|=
operator|new
name|PreDocsAndPositionsEnum
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|docsPosEnum
operator|=
operator|(
name|PreDocsAndPositionsEnum
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
name|docsPosEnum
operator|.
name|getFreqStream
argument_list|()
operator|!=
name|freqStream
condition|)
block|{
name|docsPosEnum
operator|=
operator|new
name|PreDocsAndPositionsEnum
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|docsPosEnum
operator|.
name|reset
argument_list|(
name|termEnum
argument_list|,
name|skipDocs
argument_list|)
return|;
block|}
block|}
DECL|class|PreDocsEnum
specifier|private
specifier|final
class|class
name|PreDocsEnum
extends|extends
name|DocsEnum
block|{
DECL|field|docs
specifier|final
specifier|private
name|SegmentTermDocs
name|docs
decl_stmt|;
DECL|field|docID
specifier|private
name|int
name|docID
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|PreDocsEnum
name|PreDocsEnum
parameter_list|()
throws|throws
name|IOException
block|{
name|docs
operator|=
operator|new
name|SegmentTermDocs
argument_list|(
name|freqStream
argument_list|,
name|getTermsDict
argument_list|()
argument_list|,
name|fieldInfos
argument_list|)
expr_stmt|;
block|}
DECL|method|getFreqStream
name|IndexInput
name|getFreqStream
parameter_list|()
block|{
return|return
name|freqStream
return|;
block|}
DECL|method|reset
specifier|public
name|PreDocsEnum
name|reset
parameter_list|(
name|SegmentTermEnum
name|termEnum
parameter_list|,
name|Bits
name|skipDocs
parameter_list|)
throws|throws
name|IOException
block|{
name|docs
operator|.
name|setSkipDocs
argument_list|(
name|skipDocs
argument_list|)
expr_stmt|;
name|docs
operator|.
name|seek
argument_list|(
name|termEnum
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|docs
operator|.
name|next
argument_list|()
condition|)
block|{
return|return
name|docID
operator|=
name|docs
operator|.
name|doc
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|docID
operator|=
name|NO_MORE_DOCS
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|docs
operator|.
name|skipTo
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
name|docID
operator|=
name|docs
operator|.
name|doc
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|docID
operator|=
name|NO_MORE_DOCS
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
block|{
return|return
name|docs
operator|.
name|freq
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|docID
return|;
block|}
annotation|@
name|Override
DECL|method|read
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|bulkResult
operator|==
literal|null
condition|)
block|{
name|initBulkResult
argument_list|()
expr_stmt|;
name|bulkResult
operator|.
name|docs
operator|.
name|ints
operator|=
operator|new
name|int
index|[
literal|32
index|]
expr_stmt|;
name|bulkResult
operator|.
name|freqs
operator|.
name|ints
operator|=
operator|new
name|int
index|[
literal|32
index|]
expr_stmt|;
block|}
return|return
name|this
operator|.
name|docs
operator|.
name|read
argument_list|(
name|bulkResult
operator|.
name|docs
operator|.
name|ints
argument_list|,
name|bulkResult
operator|.
name|freqs
operator|.
name|ints
argument_list|)
return|;
block|}
block|}
DECL|class|PreDocsAndPositionsEnum
specifier|private
specifier|final
class|class
name|PreDocsAndPositionsEnum
extends|extends
name|DocsAndPositionsEnum
block|{
DECL|field|pos
specifier|final
specifier|private
name|SegmentTermPositions
name|pos
decl_stmt|;
DECL|field|docID
specifier|private
name|int
name|docID
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|PreDocsAndPositionsEnum
name|PreDocsAndPositionsEnum
parameter_list|()
throws|throws
name|IOException
block|{
name|pos
operator|=
operator|new
name|SegmentTermPositions
argument_list|(
name|freqStream
argument_list|,
name|proxStream
argument_list|,
name|getTermsDict
argument_list|()
argument_list|,
name|fieldInfos
argument_list|)
expr_stmt|;
block|}
DECL|method|getFreqStream
name|IndexInput
name|getFreqStream
parameter_list|()
block|{
return|return
name|freqStream
return|;
block|}
DECL|method|reset
specifier|public
name|DocsAndPositionsEnum
name|reset
parameter_list|(
name|SegmentTermEnum
name|termEnum
parameter_list|,
name|Bits
name|skipDocs
parameter_list|)
throws|throws
name|IOException
block|{
name|pos
operator|.
name|setSkipDocs
argument_list|(
name|skipDocs
argument_list|)
expr_stmt|;
name|pos
operator|.
name|seek
argument_list|(
name|termEnum
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pos
operator|.
name|next
argument_list|()
condition|)
block|{
return|return
name|docID
operator|=
name|pos
operator|.
name|doc
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|docID
operator|=
name|NO_MORE_DOCS
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pos
operator|.
name|skipTo
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
name|docID
operator|=
name|pos
operator|.
name|doc
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|docID
operator|=
name|NO_MORE_DOCS
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
block|{
return|return
name|pos
operator|.
name|freq
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|docID
return|;
block|}
annotation|@
name|Override
DECL|method|nextPosition
specifier|public
name|int
name|nextPosition
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|docID
operator|!=
name|NO_MORE_DOCS
assert|;
return|return
name|pos
operator|.
name|nextPosition
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hasPayload
specifier|public
name|boolean
name|hasPayload
parameter_list|()
block|{
assert|assert
name|docID
operator|!=
name|NO_MORE_DOCS
assert|;
return|return
name|pos
operator|.
name|isPayloadAvailable
argument_list|()
return|;
block|}
DECL|field|payload
specifier|private
name|BytesRef
name|payload
decl_stmt|;
annotation|@
name|Override
DECL|method|getPayload
specifier|public
name|BytesRef
name|getPayload
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|len
init|=
name|pos
operator|.
name|getPayloadLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|payload
operator|==
literal|null
condition|)
block|{
name|payload
operator|=
operator|new
name|BytesRef
argument_list|()
expr_stmt|;
name|payload
operator|.
name|bytes
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|payload
operator|.
name|bytes
operator|.
name|length
operator|<
name|len
condition|)
block|{
name|payload
operator|.
name|grow
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|payload
operator|.
name|bytes
operator|=
name|pos
operator|.
name|getPayload
argument_list|(
name|payload
operator|.
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|payload
operator|.
name|length
operator|=
name|len
expr_stmt|;
return|return
name|payload
return|;
block|}
block|}
block|}
end_class
end_unit
