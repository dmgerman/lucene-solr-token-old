begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_comment
comment|/**<p>This class implements a {@link MergePolicy} that tries  *  to merge segments into levels of exponentially  *  increasing size, where each level has fewer segments than  *  the value of the merge factor. Whenever extra segments  *  (beyond the merge factor upper bound) are encountered,  *  all segments within the level are merged. You can get or  *  set the merge factor using {@link #getMergeFactor()} and  *  {@link #setMergeFactor(int)} respectively.</p>  *  *<p>This class is abstract and requires a subclass to  * define the {@link #size} method which specifies how a  * segment's size is determined.  {@link LogDocMergePolicy}  * is one subclass that measures size by document count in  * the segment.  {@link LogByteSizeMergePolicy} is another  * subclass that measures size as the total byte size of the  * file(s) for the segment.</p>  */
end_comment
begin_class
DECL|class|LogMergePolicy
specifier|public
specifier|abstract
class|class
name|LogMergePolicy
extends|extends
name|MergePolicy
block|{
comment|/** Defines the allowed range of log(size) for each    *  level.  A level is computed by taking the max segment    *  log size, minus LEVEL_LOG_SPAN, and finding all    *  segments falling within that range. */
DECL|field|LEVEL_LOG_SPAN
specifier|public
specifier|static
specifier|final
name|double
name|LEVEL_LOG_SPAN
init|=
literal|0.75
decl_stmt|;
comment|/** Default merge factor, which is how many segments are    *  merged at a time */
DECL|field|DEFAULT_MERGE_FACTOR
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MERGE_FACTOR
init|=
literal|10
decl_stmt|;
comment|/** Default maximum segment size.  A segment of this size    *  or larger will never be merged.  @see setMaxMergeDocs */
DECL|field|DEFAULT_MAX_MERGE_DOCS
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_MERGE_DOCS
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
comment|/** Default noCFSRatio.  If a merge's size is>= 10% of    *  the index, then we disable compound file for it.    *  @see #setNoCFSRatio */
DECL|field|DEFAULT_NO_CFS_RATIO
specifier|public
specifier|static
specifier|final
name|double
name|DEFAULT_NO_CFS_RATIO
init|=
literal|0.1
decl_stmt|;
DECL|field|mergeFactor
specifier|protected
name|int
name|mergeFactor
init|=
name|DEFAULT_MERGE_FACTOR
decl_stmt|;
DECL|field|minMergeSize
specifier|protected
name|long
name|minMergeSize
decl_stmt|;
DECL|field|maxMergeSize
specifier|protected
name|long
name|maxMergeSize
decl_stmt|;
comment|// Although the core MPs set it explicitly, we must default in case someone
comment|// out there wrote his own LMP ...
DECL|field|maxMergeSizeForOptimize
specifier|protected
name|long
name|maxMergeSizeForOptimize
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
DECL|field|maxMergeDocs
specifier|protected
name|int
name|maxMergeDocs
init|=
name|DEFAULT_MAX_MERGE_DOCS
decl_stmt|;
DECL|field|requireContiguousMerge
specifier|protected
name|boolean
name|requireContiguousMerge
init|=
literal|false
decl_stmt|;
DECL|field|noCFSRatio
specifier|protected
name|double
name|noCFSRatio
init|=
name|DEFAULT_NO_CFS_RATIO
decl_stmt|;
DECL|field|calibrateSizeByDeletes
specifier|protected
name|boolean
name|calibrateSizeByDeletes
init|=
literal|true
decl_stmt|;
DECL|field|useCompoundFile
specifier|protected
name|boolean
name|useCompoundFile
init|=
literal|true
decl_stmt|;
DECL|method|LogMergePolicy
specifier|public
name|LogMergePolicy
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
DECL|method|verbose
specifier|protected
name|boolean
name|verbose
parameter_list|()
block|{
name|IndexWriter
name|w
init|=
name|writer
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|w
operator|!=
literal|null
operator|&&
name|w
operator|.
name|verbose
argument_list|()
return|;
block|}
comment|/** @see #setNoCFSRatio */
DECL|method|getNoCFSRatio
specifier|public
name|double
name|getNoCFSRatio
parameter_list|()
block|{
return|return
name|noCFSRatio
return|;
block|}
comment|/** If a merged segment will be more than this percentage    *  of the total size of the index, leave the segment as    *  non-compound file even if compound file is enabled.    *  Set to 1.0 to always use CFS regardless of merge    *  size. */
DECL|method|setNoCFSRatio
specifier|public
name|void
name|setNoCFSRatio
parameter_list|(
name|double
name|noCFSRatio
parameter_list|)
block|{
if|if
condition|(
name|noCFSRatio
argument_list|<
literal|0.0
operator|||
name|noCFSRatio
argument_list|>
literal|1.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"noCFSRatio must be 0.0 to 1.0 inclusive; got "
operator|+
name|noCFSRatio
argument_list|)
throw|;
block|}
name|this
operator|.
name|noCFSRatio
operator|=
name|noCFSRatio
expr_stmt|;
block|}
DECL|method|message
specifier|protected
name|void
name|message
parameter_list|(
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
name|writer
operator|.
name|get
argument_list|()
operator|.
name|message
argument_list|(
literal|"LMP: "
operator|+
name|message
argument_list|)
expr_stmt|;
block|}
comment|/** If true, merges must be in-order slice of the    *  segments.  If false, then the merge policy is free to    *  pick any segments.  The default is false, which is    *  in general more efficient than true since it gives the    *  merge policy more freedom to pick closely sized    *  segments. */
DECL|method|setRequireContiguousMerge
specifier|public
name|void
name|setRequireContiguousMerge
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
name|requireContiguousMerge
operator|=
name|v
expr_stmt|;
block|}
comment|/** See {@link #setRequireContiguousMerge}. */
DECL|method|getRequireContiguousMerge
specifier|public
name|boolean
name|getRequireContiguousMerge
parameter_list|()
block|{
return|return
name|requireContiguousMerge
return|;
block|}
comment|/**<p>Returns the number of segments that are merged at    * once and also controls the total number of segments    * allowed to accumulate in the index.</p> */
DECL|method|getMergeFactor
specifier|public
name|int
name|getMergeFactor
parameter_list|()
block|{
return|return
name|mergeFactor
return|;
block|}
comment|/** Determines how often segment indices are merged by    * addDocument().  With smaller values, less RAM is used    * while indexing, and searches on unoptimized indices are    * faster, but indexing speed is slower.  With larger    * values, more RAM is used during indexing, and while    * searches on unoptimized indices are slower, indexing is    * faster.  Thus larger values (> 10) are best for batch    * index creation, and smaller values (< 10) for indices    * that are interactively maintained. */
DECL|method|setMergeFactor
specifier|public
name|void
name|setMergeFactor
parameter_list|(
name|int
name|mergeFactor
parameter_list|)
block|{
if|if
condition|(
name|mergeFactor
operator|<
literal|2
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"mergeFactor cannot be less than 2"
argument_list|)
throw|;
name|this
operator|.
name|mergeFactor
operator|=
name|mergeFactor
expr_stmt|;
block|}
comment|// Javadoc inherited
annotation|@
name|Override
DECL|method|useCompoundFile
specifier|public
name|boolean
name|useCompoundFile
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|SegmentInfo
name|mergedInfo
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|boolean
name|doCFS
decl_stmt|;
if|if
condition|(
operator|!
name|useCompoundFile
condition|)
block|{
name|doCFS
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noCFSRatio
operator|==
literal|1.0
condition|)
block|{
name|doCFS
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SegmentInfo
name|info
range|:
name|infos
control|)
name|totalSize
operator|+=
name|size
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|doCFS
operator|=
name|size
argument_list|(
name|mergedInfo
argument_list|)
operator|<=
name|noCFSRatio
operator|*
name|totalSize
expr_stmt|;
block|}
return|return
name|doCFS
return|;
block|}
comment|/** Sets whether compound file format should be used for    *  newly flushed and newly merged segments. */
DECL|method|setUseCompoundFile
specifier|public
name|void
name|setUseCompoundFile
parameter_list|(
name|boolean
name|useCompoundFile
parameter_list|)
block|{
name|this
operator|.
name|useCompoundFile
operator|=
name|useCompoundFile
expr_stmt|;
block|}
comment|/** Returns true if newly flushed and newly merge segments    *  are written in compound file format. @see    *  #setUseCompoundFile */
DECL|method|getUseCompoundFile
specifier|public
name|boolean
name|getUseCompoundFile
parameter_list|()
block|{
return|return
name|useCompoundFile
return|;
block|}
comment|/** Sets whether the segment size should be calibrated by    *  the number of deletes when choosing segments for merge. */
DECL|method|setCalibrateSizeByDeletes
specifier|public
name|void
name|setCalibrateSizeByDeletes
parameter_list|(
name|boolean
name|calibrateSizeByDeletes
parameter_list|)
block|{
name|this
operator|.
name|calibrateSizeByDeletes
operator|=
name|calibrateSizeByDeletes
expr_stmt|;
block|}
comment|/** Returns true if the segment size should be calibrated     *  by the number of deletes when choosing segments for merge. */
DECL|method|getCalibrateSizeByDeletes
specifier|public
name|boolean
name|getCalibrateSizeByDeletes
parameter_list|()
block|{
return|return
name|calibrateSizeByDeletes
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{}
DECL|method|size
specifier|abstract
specifier|protected
name|long
name|size
parameter_list|(
name|SegmentInfo
name|info
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|sizeDocs
specifier|protected
name|long
name|sizeDocs
parameter_list|(
name|SegmentInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|calibrateSizeByDeletes
condition|)
block|{
name|int
name|delCount
init|=
name|writer
operator|.
name|get
argument_list|()
operator|.
name|numDeletedDocs
argument_list|(
name|info
argument_list|)
decl_stmt|;
assert|assert
name|delCount
operator|<=
name|info
operator|.
name|docCount
assert|;
return|return
operator|(
name|info
operator|.
name|docCount
operator|-
operator|(
name|long
operator|)
name|delCount
operator|)
return|;
block|}
else|else
block|{
return|return
name|info
operator|.
name|docCount
return|;
block|}
block|}
DECL|method|sizeBytes
specifier|protected
name|long
name|sizeBytes
parameter_list|(
name|SegmentInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|byteSize
init|=
name|info
operator|.
name|sizeInBytes
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|calibrateSizeByDeletes
condition|)
block|{
name|int
name|delCount
init|=
name|writer
operator|.
name|get
argument_list|()
operator|.
name|numDeletedDocs
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|double
name|delRatio
init|=
operator|(
name|info
operator|.
name|docCount
operator|<=
literal|0
condition|?
literal|0.0f
else|:
operator|(
operator|(
name|float
operator|)
name|delCount
operator|/
operator|(
name|float
operator|)
name|info
operator|.
name|docCount
operator|)
operator|)
decl_stmt|;
assert|assert
name|delRatio
operator|<=
literal|1.0
assert|;
return|return
operator|(
name|info
operator|.
name|docCount
operator|<=
literal|0
condition|?
name|byteSize
else|:
call|(
name|long
call|)
argument_list|(
name|byteSize
operator|*
operator|(
literal|1.0
operator|-
name|delRatio
operator|)
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
name|byteSize
return|;
block|}
block|}
DECL|method|isOptimized
specifier|protected
name|boolean
name|isOptimized
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|int
name|maxNumSegments
parameter_list|,
name|Set
argument_list|<
name|SegmentInfo
argument_list|>
name|segmentsToOptimize
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|numSegments
init|=
name|infos
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|numToOptimize
init|=
literal|0
decl_stmt|;
name|SegmentInfo
name|optimizeInfo
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
operator|&&
name|numToOptimize
operator|<=
name|maxNumSegments
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentInfo
name|info
init|=
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|segmentsToOptimize
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|numToOptimize
operator|++
expr_stmt|;
name|optimizeInfo
operator|=
name|info
expr_stmt|;
block|}
block|}
return|return
name|numToOptimize
operator|<=
name|maxNumSegments
operator|&&
operator|(
name|numToOptimize
operator|!=
literal|1
operator|||
name|isOptimized
argument_list|(
name|optimizeInfo
argument_list|)
operator|)
return|;
block|}
comment|/** Returns true if this single info is optimized (has no    *  pending norms or deletes, is in the same dir as the    *  writer, and matches the current compound file setting */
DECL|method|isOptimized
specifier|protected
name|boolean
name|isOptimized
parameter_list|(
name|SegmentInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|IndexWriter
name|w
init|=
name|writer
operator|.
name|get
argument_list|()
decl_stmt|;
assert|assert
name|w
operator|!=
literal|null
assert|;
name|boolean
name|hasDeletions
init|=
name|w
operator|.
name|numDeletedDocs
argument_list|(
name|info
argument_list|)
operator|>
literal|0
decl_stmt|;
return|return
operator|!
name|hasDeletions
operator|&&
operator|!
name|info
operator|.
name|hasSeparateNorms
argument_list|()
operator|&&
name|info
operator|.
name|dir
operator|==
name|w
operator|.
name|getDirectory
argument_list|()
operator|&&
operator|(
name|info
operator|.
name|getUseCompoundFile
argument_list|()
operator|==
name|useCompoundFile
operator|||
name|noCFSRatio
operator|<
literal|1.0
operator|)
return|;
block|}
comment|/**    * Returns the merges necessary to optimize the index, taking the max merge    * size or max merge docs into consideration. This method attempts to respect    * the {@code maxNumSegments} parameter, however it might be, due to size    * constraints, that more than that number of segments will remain in the    * index. Also, this method does not guarantee that exactly {@code    * maxNumSegments} will remain, but&lt;= that number.    */
DECL|method|findMergesForOptimizeSizeLimit
specifier|private
name|MergeSpecification
name|findMergesForOptimizeSizeLimit
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|int
name|maxNumSegments
parameter_list|,
name|int
name|last
parameter_list|)
throws|throws
name|IOException
block|{
name|MergeSpecification
name|spec
init|=
operator|new
name|MergeSpecification
argument_list|()
decl_stmt|;
name|int
name|start
init|=
name|last
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|start
operator|>=
literal|0
condition|)
block|{
name|SegmentInfo
name|info
init|=
name|infos
operator|.
name|info
argument_list|(
name|start
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
argument_list|(
name|info
argument_list|)
operator|>
name|maxMergeSizeForOptimize
operator|||
name|sizeDocs
argument_list|(
name|info
argument_list|)
operator|>
name|maxMergeDocs
condition|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"optimize: skip segment="
operator|+
name|info
operator|+
literal|": size is> maxMergeSize ("
operator|+
name|maxMergeSizeForOptimize
operator|+
literal|") or sizeDocs is> maxMergeDocs ("
operator|+
name|maxMergeDocs
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|// need to skip that segment + add a merge for the 'right' segments,
comment|// unless there is only 1 which is optimized.
if|if
condition|(
name|last
operator|-
name|start
operator|-
literal|1
operator|>
literal|1
operator|||
operator|(
name|start
operator|!=
name|last
operator|-
literal|1
operator|&&
operator|!
name|isOptimized
argument_list|(
name|infos
operator|.
name|info
argument_list|(
name|start
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|// there is more than 1 segment to the right of this one, or an unoptimized single segment.
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|infos
operator|.
name|range
argument_list|(
name|start
operator|+
literal|1
argument_list|,
name|last
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|start
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last
operator|-
name|start
operator|==
name|mergeFactor
condition|)
block|{
comment|// mergeFactor eligible segments were found, add them as a merge.
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|infos
operator|.
name|range
argument_list|(
name|start
argument_list|,
name|last
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|start
expr_stmt|;
block|}
operator|--
name|start
expr_stmt|;
block|}
comment|// Add any left-over segments, unless there is just 1 already optimized.
if|if
condition|(
name|last
operator|>
literal|0
operator|&&
operator|(
operator|++
name|start
operator|+
literal|1
operator|<
name|last
operator|||
operator|!
name|isOptimized
argument_list|(
name|infos
operator|.
name|info
argument_list|(
name|start
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|infos
operator|.
name|range
argument_list|(
name|start
argument_list|,
name|last
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|spec
operator|.
name|merges
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|spec
return|;
block|}
comment|/**    * Returns the merges necessary to optimize the index. This method constraints    * the returned merges only by the {@code maxNumSegments} parameter, and    * guaranteed that exactly that number of segments will remain in the index.    */
DECL|method|findMergesForOptimizeMaxNumSegments
specifier|private
name|MergeSpecification
name|findMergesForOptimizeMaxNumSegments
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|int
name|maxNumSegments
parameter_list|,
name|int
name|last
parameter_list|)
throws|throws
name|IOException
block|{
name|MergeSpecification
name|spec
init|=
operator|new
name|MergeSpecification
argument_list|()
decl_stmt|;
comment|// First, enroll all "full" merges (size
comment|// mergeFactor) to potentially be run concurrently:
while|while
condition|(
name|last
operator|-
name|maxNumSegments
operator|+
literal|1
operator|>=
name|mergeFactor
condition|)
block|{
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|infos
operator|.
name|range
argument_list|(
name|last
operator|-
name|mergeFactor
argument_list|,
name|last
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|-=
name|mergeFactor
expr_stmt|;
block|}
comment|// Only if there are no full merges pending do we
comment|// add a final partial (< mergeFactor segments) merge:
if|if
condition|(
literal|0
operator|==
name|spec
operator|.
name|merges
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|maxNumSegments
operator|==
literal|1
condition|)
block|{
comment|// Since we must optimize down to 1 segment, the
comment|// choice is simple:
if|if
condition|(
name|last
operator|>
literal|1
operator|||
operator|!
name|isOptimized
argument_list|(
name|infos
operator|.
name|info
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|infos
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|last
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|last
operator|>
name|maxNumSegments
condition|)
block|{
comment|// Take care to pick a partial merge that is
comment|// least cost, but does not make the index too
comment|// lopsided.  If we always just picked the
comment|// partial tail then we could produce a highly
comment|// lopsided index over time:
comment|// We must merge this many segments to leave
comment|// maxNumSegments in the index (from when
comment|// optimize was first kicked off):
specifier|final
name|int
name|finalMergeSize
init|=
name|last
operator|-
name|maxNumSegments
operator|+
literal|1
decl_stmt|;
comment|// Consider all possible starting points:
name|long
name|bestSize
init|=
literal|0
decl_stmt|;
name|int
name|bestStart
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|last
operator|-
name|finalMergeSize
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|long
name|sumSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|finalMergeSize
condition|;
name|j
operator|++
control|)
name|sumSize
operator|+=
name|size
argument_list|(
name|infos
operator|.
name|info
argument_list|(
name|j
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
operator|(
name|sumSize
operator|<
literal|2
operator|*
name|size
argument_list|(
name|infos
operator|.
name|info
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|&&
name|sumSize
operator|<
name|bestSize
operator|)
condition|)
block|{
name|bestStart
operator|=
name|i
expr_stmt|;
name|bestSize
operator|=
name|sumSize
expr_stmt|;
block|}
block|}
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|infos
operator|.
name|range
argument_list|(
name|bestStart
argument_list|,
name|bestStart
operator|+
name|finalMergeSize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|spec
operator|.
name|merges
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|spec
return|;
block|}
comment|/** Returns the merges necessary to optimize the index.    *  This merge policy defines "optimized" to mean only the    *  requested number of segments is left in the index, and    *  respects the {@link #maxMergeSizeForOptimize} setting.    *  By default, and assuming {@code maxNumSegments=1}, only    *  one segment will be left in the index, where that segment    *  has no deletions pending nor separate norms, and it is in    *  compound file format if the current useCompoundFile    *  setting is true.  This method returns multiple merges    *  (mergeFactor at a time) so the {@link MergeScheduler}    *  in use may make use of concurrency. */
annotation|@
name|Override
DECL|method|findMergesForOptimize
specifier|public
name|MergeSpecification
name|findMergesForOptimize
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|int
name|maxNumSegments
parameter_list|,
name|Set
argument_list|<
name|SegmentInfo
argument_list|>
name|segmentsToOptimize
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|maxNumSegments
operator|>
literal|0
assert|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"findMergesForOptimize: maxNumSegs="
operator|+
name|maxNumSegments
operator|+
literal|" segsToOptimize= "
operator|+
name|segmentsToOptimize
argument_list|)
expr_stmt|;
block|}
comment|// If the segments are already optimized (e.g. there's only 1 segment), or
comment|// there are<maxNumSegements, all optimized, nothing to do.
if|if
condition|(
name|isOptimized
argument_list|(
name|infos
argument_list|,
name|maxNumSegments
argument_list|,
name|segmentsToOptimize
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"already optimized; skip"
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|// TODO: handle non-contiguous merge case differently?
comment|// Find the newest (rightmost) segment that needs to
comment|// be optimized (other segments may have been flushed
comment|// since optimize started):
name|int
name|last
init|=
name|infos
operator|.
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|last
operator|>
literal|0
condition|)
block|{
specifier|final
name|SegmentInfo
name|info
init|=
name|infos
operator|.
name|info
argument_list|(
operator|--
name|last
argument_list|)
decl_stmt|;
if|if
condition|(
name|segmentsToOptimize
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|last
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|last
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"last == 0; skip"
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|// There is only one segment already, and it is optimized
if|if
condition|(
name|maxNumSegments
operator|==
literal|1
operator|&&
name|last
operator|==
literal|1
operator|&&
name|isOptimized
argument_list|(
name|infos
operator|.
name|info
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"already 1 seg; skip"
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|// Check if there are any segments above the threshold
name|boolean
name|anyTooLarge
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
block|{
name|SegmentInfo
name|info
init|=
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
argument_list|(
name|info
argument_list|)
operator|>
name|maxMergeSizeForOptimize
operator|||
name|sizeDocs
argument_list|(
name|info
argument_list|)
operator|>
name|maxMergeDocs
condition|)
block|{
name|anyTooLarge
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|anyTooLarge
condition|)
block|{
return|return
name|findMergesForOptimizeSizeLimit
argument_list|(
name|infos
argument_list|,
name|maxNumSegments
argument_list|,
name|last
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|findMergesForOptimizeMaxNumSegments
argument_list|(
name|infos
argument_list|,
name|maxNumSegments
argument_list|,
name|last
argument_list|)
return|;
block|}
block|}
comment|/**    * Finds merges necessary to expunge all deletes from the    * index.  We simply merge adjacent segments that have    * deletes, up to mergeFactor at a time.    */
annotation|@
name|Override
DECL|method|findMergesToExpungeDeletes
specifier|public
name|MergeSpecification
name|findMergesToExpungeDeletes
parameter_list|(
name|SegmentInfos
name|segmentInfos
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
specifier|final
name|int
name|numSegments
init|=
name|segmentInfos
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
name|message
argument_list|(
literal|"findMergesToExpungeDeletes: "
operator|+
name|numSegments
operator|+
literal|" segments"
argument_list|)
expr_stmt|;
name|MergeSpecification
name|spec
init|=
operator|new
name|MergeSpecification
argument_list|()
decl_stmt|;
name|int
name|firstSegmentWithDeletions
init|=
operator|-
literal|1
decl_stmt|;
name|IndexWriter
name|w
init|=
name|writer
operator|.
name|get
argument_list|()
decl_stmt|;
assert|assert
name|w
operator|!=
literal|null
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentInfo
name|info
init|=
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|delCount
init|=
name|w
operator|.
name|numDeletedDocs
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|delCount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
name|message
argument_list|(
literal|"  segment "
operator|+
name|info
operator|.
name|name
operator|+
literal|" has deletions"
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstSegmentWithDeletions
operator|==
operator|-
literal|1
condition|)
name|firstSegmentWithDeletions
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|-
name|firstSegmentWithDeletions
operator|==
name|mergeFactor
condition|)
block|{
comment|// We've seen mergeFactor segments in a row with
comment|// deletions, so force a merge now:
if|if
condition|(
name|verbose
argument_list|()
condition|)
name|message
argument_list|(
literal|"  add merge "
operator|+
name|firstSegmentWithDeletions
operator|+
literal|" to "
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
operator|+
literal|" inclusive"
argument_list|)
expr_stmt|;
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|segmentInfos
operator|.
name|range
argument_list|(
name|firstSegmentWithDeletions
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|firstSegmentWithDeletions
operator|=
name|i
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|firstSegmentWithDeletions
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// End of a sequence of segments with deletions, so,
comment|// merge those past segments even if it's fewer than
comment|// mergeFactor segments
if|if
condition|(
name|verbose
argument_list|()
condition|)
name|message
argument_list|(
literal|"  add merge "
operator|+
name|firstSegmentWithDeletions
operator|+
literal|" to "
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
operator|+
literal|" inclusive"
argument_list|)
expr_stmt|;
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|segmentInfos
operator|.
name|range
argument_list|(
name|firstSegmentWithDeletions
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|firstSegmentWithDeletions
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|firstSegmentWithDeletions
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
name|message
argument_list|(
literal|"  add merge "
operator|+
name|firstSegmentWithDeletions
operator|+
literal|" to "
operator|+
operator|(
name|numSegments
operator|-
literal|1
operator|)
operator|+
literal|" inclusive"
argument_list|)
expr_stmt|;
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|segmentInfos
operator|.
name|range
argument_list|(
name|firstSegmentWithDeletions
argument_list|,
name|numSegments
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|spec
return|;
block|}
DECL|class|SegmentInfoAndLevel
specifier|private
specifier|static
class|class
name|SegmentInfoAndLevel
implements|implements
name|Comparable
block|{
DECL|field|info
name|SegmentInfo
name|info
decl_stmt|;
DECL|field|level
name|float
name|level
decl_stmt|;
DECL|field|index
name|int
name|index
decl_stmt|;
DECL|method|SegmentInfoAndLevel
specifier|public
name|SegmentInfoAndLevel
parameter_list|(
name|SegmentInfo
name|info
parameter_list|,
name|float
name|level
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|this
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|this
operator|.
name|level
operator|=
name|level
expr_stmt|;
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
block|}
comment|// Sorts largest to smallest
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|SegmentInfoAndLevel
name|other
init|=
operator|(
name|SegmentInfoAndLevel
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|level
operator|<
name|other
operator|.
name|level
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|level
operator|>
name|other
operator|.
name|level
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
block|}
DECL|class|SortByIndex
specifier|private
specifier|static
class|class
name|SortByIndex
implements|implements
name|Comparator
argument_list|<
name|SegmentInfoAndLevel
argument_list|>
block|{
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
name|SegmentInfoAndLevel
name|o1
parameter_list|,
name|SegmentInfoAndLevel
name|o2
parameter_list|)
block|{
return|return
name|o1
operator|.
name|index
operator|-
name|o2
operator|.
name|index
return|;
block|}
block|}
DECL|field|sortByIndex
specifier|private
specifier|static
specifier|final
name|SortByIndex
name|sortByIndex
init|=
operator|new
name|SortByIndex
argument_list|()
decl_stmt|;
comment|/** Checks if any merges are now necessary and returns a    *  {@link MergePolicy.MergeSpecification} if so.  A merge    *  is necessary when there are more than {@link    *  #setMergeFactor} segments at a given level.  When    *  multiple levels have too many segments, this method    *  will return multiple merges, allowing the {@link    *  MergeScheduler} to use concurrency. */
annotation|@
name|Override
DECL|method|findMerges
specifier|public
name|MergeSpecification
name|findMerges
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|numSegments
init|=
name|infos
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
name|message
argument_list|(
literal|"findMerges: "
operator|+
name|numSegments
operator|+
literal|" segments"
argument_list|)
expr_stmt|;
comment|// Compute levels, which is just log (base mergeFactor)
comment|// of the size of each segment
name|SegmentInfoAndLevel
index|[]
name|levels
init|=
operator|new
name|SegmentInfoAndLevel
index|[
name|numSegments
index|]
decl_stmt|;
specifier|final
name|float
name|norm
init|=
operator|(
name|float
operator|)
name|Math
operator|.
name|log
argument_list|(
name|mergeFactor
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentInfo
name|info
init|=
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|size
init|=
name|size
argument_list|(
name|info
argument_list|)
decl_stmt|;
comment|// Floor tiny segments
if|if
condition|(
name|size
operator|<
literal|1
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|levels
index|[
name|i
index|]
operator|=
operator|new
name|SegmentInfoAndLevel
argument_list|(
name|info
argument_list|,
operator|(
name|float
operator|)
name|Math
operator|.
name|log
argument_list|(
name|size
argument_list|)
operator|/
name|norm
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"seg "
operator|+
name|info
operator|.
name|name
operator|+
literal|" level="
operator|+
name|levels
index|[
name|i
index|]
operator|.
name|level
operator|+
literal|" size="
operator|+
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|requireContiguousMerge
condition|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|levels
argument_list|)
expr_stmt|;
block|}
specifier|final
name|float
name|levelFloor
decl_stmt|;
if|if
condition|(
name|minMergeSize
operator|<=
literal|0
condition|)
name|levelFloor
operator|=
operator|(
name|float
operator|)
literal|0.0
expr_stmt|;
else|else
name|levelFloor
operator|=
call|(
name|float
call|)
argument_list|(
name|Math
operator|.
name|log
argument_list|(
name|minMergeSize
argument_list|)
operator|/
name|norm
argument_list|)
expr_stmt|;
comment|// Now, we quantize the log values into levels.  The
comment|// first level is any segment whose log size is within
comment|// LEVEL_LOG_SPAN of the max size, or, who has such as
comment|// segment "to the right".  Then, we find the max of all
comment|// other segments and use that to define the next level
comment|// segment, etc.
name|MergeSpecification
name|spec
init|=
literal|null
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|numSegments
condition|)
block|{
comment|// Find max level of all segments not already
comment|// quantized.
name|float
name|maxLevel
init|=
name|levels
index|[
name|start
index|]
operator|.
name|level
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
operator|+
name|start
init|;
name|i
operator|<
name|numSegments
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|float
name|level
init|=
name|levels
index|[
name|i
index|]
operator|.
name|level
decl_stmt|;
if|if
condition|(
name|level
operator|>
name|maxLevel
condition|)
name|maxLevel
operator|=
name|level
expr_stmt|;
block|}
comment|// Now search backwards for the rightmost segment that
comment|// falls into this level:
name|float
name|levelBottom
decl_stmt|;
if|if
condition|(
name|maxLevel
operator|<=
name|levelFloor
condition|)
comment|// All remaining segments fall into the min level
name|levelBottom
operator|=
operator|-
literal|1.0F
expr_stmt|;
else|else
block|{
name|levelBottom
operator|=
call|(
name|float
call|)
argument_list|(
name|maxLevel
operator|-
name|LEVEL_LOG_SPAN
argument_list|)
expr_stmt|;
comment|// Force a boundary at the level floor
if|if
condition|(
name|levelBottom
operator|<
name|levelFloor
operator|&&
name|maxLevel
operator|>=
name|levelFloor
condition|)
name|levelBottom
operator|=
name|levelFloor
expr_stmt|;
block|}
name|int
name|upto
init|=
name|numSegments
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|upto
operator|>=
name|start
condition|)
block|{
if|if
condition|(
name|levels
index|[
name|upto
index|]
operator|.
name|level
operator|>=
name|levelBottom
condition|)
block|{
break|break;
block|}
name|upto
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|verbose
argument_list|()
condition|)
name|message
argument_list|(
literal|"  level "
operator|+
name|levelBottom
operator|+
literal|" to "
operator|+
name|maxLevel
operator|+
literal|": "
operator|+
operator|(
literal|1
operator|+
name|upto
operator|-
name|start
operator|)
operator|+
literal|" segments"
argument_list|)
expr_stmt|;
comment|// Finally, record all merges that are viable at this level:
name|int
name|end
init|=
name|start
operator|+
name|mergeFactor
decl_stmt|;
while|while
condition|(
name|end
operator|<=
literal|1
operator|+
name|upto
condition|)
block|{
name|boolean
name|anyTooLarge
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentInfo
name|info
init|=
name|levels
index|[
name|i
index|]
operator|.
name|info
decl_stmt|;
name|anyTooLarge
operator||=
operator|(
name|size
argument_list|(
name|info
argument_list|)
operator|>=
name|maxMergeSize
operator|||
name|sizeDocs
argument_list|(
name|info
argument_list|)
operator|>=
name|maxMergeDocs
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|anyTooLarge
condition|)
block|{
if|if
condition|(
name|spec
operator|==
literal|null
condition|)
name|spec
operator|=
operator|new
name|MergeSpecification
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"    "
operator|+
name|start
operator|+
literal|" to "
operator|+
name|end
operator|+
literal|": add this merge"
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|levels
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|sortByIndex
argument_list|)
expr_stmt|;
specifier|final
name|SegmentInfos
name|mergeInfos
init|=
operator|new
name|SegmentInfos
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|mergeInfos
operator|.
name|add
argument_list|(
name|levels
index|[
name|i
index|]
operator|.
name|info
argument_list|)
expr_stmt|;
assert|assert
name|infos
operator|.
name|contains
argument_list|(
name|levels
index|[
name|i
index|]
operator|.
name|info
argument_list|)
assert|;
block|}
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|mergeInfos
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"    "
operator|+
name|start
operator|+
literal|" to "
operator|+
name|end
operator|+
literal|": contains segment over maxMergeSize or maxMergeDocs; skipping"
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|end
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|mergeFactor
expr_stmt|;
block|}
name|start
operator|=
literal|1
operator|+
name|upto
expr_stmt|;
block|}
return|return
name|spec
return|;
block|}
comment|/**<p>Determines the largest segment (measured by    * document count) that may be merged with other segments.    * Small values (e.g., less than 10,000) are best for    * interactive indexing, as this limits the length of    * pauses while indexing to a few seconds.  Larger values    * are best for batched indexing and speedier    * searches.</p>    *    *<p>The default value is {@link Integer#MAX_VALUE}.</p>    *    *<p>The default merge policy ({@link    * LogByteSizeMergePolicy}) also allows you to set this    * limit by net size (in MB) of the segment, using {@link    * LogByteSizeMergePolicy#setMaxMergeMB}.</p>    */
DECL|method|setMaxMergeDocs
specifier|public
name|void
name|setMaxMergeDocs
parameter_list|(
name|int
name|maxMergeDocs
parameter_list|)
block|{
name|this
operator|.
name|maxMergeDocs
operator|=
name|maxMergeDocs
expr_stmt|;
block|}
comment|/** Returns the largest segment (measured by document    *  count) that may be merged with other segments.    *  @see #setMaxMergeDocs */
DECL|method|getMaxMergeDocs
specifier|public
name|int
name|getMaxMergeDocs
parameter_list|()
block|{
return|return
name|maxMergeDocs
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"["
operator|+
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": "
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"minMergeSize="
argument_list|)
operator|.
name|append
argument_list|(
name|minMergeSize
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"mergeFactor="
argument_list|)
operator|.
name|append
argument_list|(
name|mergeFactor
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxMergeSize="
argument_list|)
operator|.
name|append
argument_list|(
name|maxMergeSize
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxMergeSizeForOptimize="
argument_list|)
operator|.
name|append
argument_list|(
name|maxMergeSizeForOptimize
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"calibrateSizeByDeletes="
argument_list|)
operator|.
name|append
argument_list|(
name|calibrateSizeByDeletes
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxMergeDocs="
argument_list|)
operator|.
name|append
argument_list|(
name|maxMergeDocs
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"useCompoundFile="
argument_list|)
operator|.
name|append
argument_list|(
name|useCompoundFile
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"requireContiguousMerge="
argument_list|)
operator|.
name|append
argument_list|(
name|requireContiguousMerge
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class
end_unit
