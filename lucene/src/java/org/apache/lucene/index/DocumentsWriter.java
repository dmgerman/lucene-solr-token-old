begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|SimilarityProvider
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RAMFile
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BitVector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RecyclingByteBlockAllocator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ThreadInterruptedException
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ByteBlockPool
operator|.
name|BYTE_BLOCK_MASK
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ByteBlockPool
operator|.
name|BYTE_BLOCK_SIZE
import|;
end_import
begin_comment
comment|/**  * This class accepts multiple added documents and directly  * writes a single segment file.  It does this more  * efficiently than creating a single segment per document  * (with DocumentWriter) and doing standard merges on those  * segments.  *  * Each added document is passed to the {@link DocConsumer},  * which in turn processes the document and interacts with  * other consumers in the indexing chain.  Certain  * consumers, like {@link StoredFieldsWriter} and {@link  * TermVectorsTermsWriter}, digest a document and  * immediately write bytes to the "doc store" files (ie,  * they do not consume RAM per document, except while they  * are processing the document).  *  * Other consumers, eg {@link FreqProxTermsWriter} and  * {@link NormsWriter}, buffer bytes in RAM and flush only  * when a new segment is produced.   * Once we have used our allowed RAM buffer, or the number  * of added docs is large enough (in the case we are  * flushing by doc count instead of RAM usage), we create a  * real segment and flush it to the Directory.  *  * Threads:  *  * Multiple threads are allowed into addDocument at once.  * There is an initial synchronized call to getThreadState  * which allocates a ThreadState for this thread.  The same  * thread will get the same ThreadState over time (thread  * affinity) so that if there are consistent patterns (for  * example each thread is indexing a different content  * source) then we make better use of RAM.  Then  * processDocument is called on that ThreadState without  * synchronization (most of the "heavy lifting" is in this  * call).  Finally the synchronized "finishDocument" is  * called to flush changes to the directory.  *  * When flush is called by IndexWriter we forcefully idle  * all threads and flush only once they are all idle.  This  * means you can call flush with a given thread even while  * other threads are actively adding/deleting documents.  *  *  * Exceptions:  *  * Because this class directly updates in-memory posting  * lists, and flushes stored fields and term vectors  * directly to files in the directory, there are certain  * limited times when an exception can corrupt this state.  * For example, a disk full while flushing stored fields  * leaves this file in a corrupt state.  Or, an OOM  * exception while appending to the in-memory posting lists  * can corrupt that posting list.  We call such exceptions  * "aborting exceptions".  In these cases we must call  * abort() to discard all docs added since the last flush.  *  * All other exceptions ("non-aborting exceptions") can  * still partially update the index structures.  These  * updates are consistent, but, they represent only a part  * of the document seen up until the exception was hit.  * When this happens, we immediately mark the document as  * deleted so that the document is always atomically ("all  * or none") added to the index.  */
end_comment
begin_class
DECL|class|DocumentsWriter
specifier|final
class|class
name|DocumentsWriter
block|{
DECL|field|bytesUsed
specifier|final
name|AtomicLong
name|bytesUsed
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|writer
name|IndexWriter
name|writer
decl_stmt|;
DECL|field|directory
name|Directory
name|directory
decl_stmt|;
DECL|field|segment
name|String
name|segment
decl_stmt|;
comment|// Current segment we are working on
DECL|field|nextDocID
specifier|private
name|int
name|nextDocID
decl_stmt|;
comment|// Next docID to be added
DECL|field|numDocs
specifier|private
name|int
name|numDocs
decl_stmt|;
comment|// # of docs added, but not yet flushed
comment|// Max # ThreadState instances; if there are more threads
comment|// than this they share ThreadStates
DECL|field|threadStates
specifier|private
name|DocumentsWriterThreadState
index|[]
name|threadStates
init|=
operator|new
name|DocumentsWriterThreadState
index|[
literal|0
index|]
decl_stmt|;
DECL|field|threadBindings
specifier|private
specifier|final
name|HashMap
argument_list|<
name|Thread
argument_list|,
name|DocumentsWriterThreadState
argument_list|>
name|threadBindings
init|=
operator|new
name|HashMap
argument_list|<
name|Thread
argument_list|,
name|DocumentsWriterThreadState
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|bufferIsFull
name|boolean
name|bufferIsFull
decl_stmt|;
comment|// True when it's time to write segment
DECL|field|aborting
specifier|private
name|boolean
name|aborting
decl_stmt|;
comment|// True if an abort is pending
DECL|field|infoStream
name|PrintStream
name|infoStream
decl_stmt|;
DECL|field|similarityProvider
name|SimilarityProvider
name|similarityProvider
decl_stmt|;
comment|// max # simultaneous threads; if there are more than
comment|// this, they wait for others to finish first
DECL|field|maxThreadStates
specifier|private
specifier|final
name|int
name|maxThreadStates
decl_stmt|;
comment|// TODO: cutover to BytesRefHash
comment|// Deletes for our still-in-RAM (to be flushed next) segment
DECL|field|pendingDeletes
specifier|private
name|BufferedDeletes
name|pendingDeletes
init|=
operator|new
name|BufferedDeletes
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|class|DocState
specifier|static
class|class
name|DocState
block|{
DECL|field|docWriter
name|DocumentsWriter
name|docWriter
decl_stmt|;
DECL|field|analyzer
name|Analyzer
name|analyzer
decl_stmt|;
DECL|field|infoStream
name|PrintStream
name|infoStream
decl_stmt|;
DECL|field|similarityProvider
name|SimilarityProvider
name|similarityProvider
decl_stmt|;
DECL|field|docID
name|int
name|docID
decl_stmt|;
DECL|field|doc
name|Document
name|doc
decl_stmt|;
DECL|field|maxTermPrefix
name|String
name|maxTermPrefix
decl_stmt|;
comment|// Only called by asserts
DECL|method|testPoint
specifier|public
name|boolean
name|testPoint
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|docWriter
operator|.
name|writer
operator|.
name|testPoint
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
comment|// don't hold onto doc nor analyzer, in case it is
comment|// largish:
name|doc
operator|=
literal|null
expr_stmt|;
name|analyzer
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/** Consumer returns this on each doc.  This holds any    *  state that must be flushed synchronized "in docID    *  order".  We gather these and flush them in order. */
DECL|class|DocWriter
specifier|abstract
specifier|static
class|class
name|DocWriter
block|{
DECL|field|next
name|DocWriter
name|next
decl_stmt|;
DECL|field|docID
name|int
name|docID
decl_stmt|;
DECL|method|finish
specifier|abstract
name|void
name|finish
parameter_list|()
throws|throws
name|IOException
function_decl|;
DECL|method|abort
specifier|abstract
name|void
name|abort
parameter_list|()
function_decl|;
DECL|method|sizeInBytes
specifier|abstract
name|long
name|sizeInBytes
parameter_list|()
function_decl|;
DECL|method|setNext
name|void
name|setNext
parameter_list|(
name|DocWriter
name|next
parameter_list|)
block|{
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/**    * Create and return a new DocWriterBuffer.    */
DECL|method|newPerDocBuffer
name|PerDocBuffer
name|newPerDocBuffer
parameter_list|()
block|{
return|return
operator|new
name|PerDocBuffer
argument_list|()
return|;
block|}
comment|/**    * RAMFile buffer for DocWriters.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
class|class
DECL|class|PerDocBuffer
name|PerDocBuffer
extends|extends
name|RAMFile
block|{
comment|/**      * Allocate bytes used from shared pool.      */
annotation|@
name|Override
DECL|method|newBuffer
specifier|protected
name|byte
index|[]
name|newBuffer
parameter_list|(
name|int
name|size
parameter_list|)
block|{
assert|assert
name|size
operator|==
name|PER_DOC_BLOCK_SIZE
assert|;
return|return
name|perDocAllocator
operator|.
name|getByteBlock
argument_list|()
return|;
block|}
comment|/**      * Recycle the bytes used.      */
DECL|method|recycle
specifier|synchronized
name|void
name|recycle
parameter_list|()
block|{
if|if
condition|(
name|buffers
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Recycle the blocks
name|perDocAllocator
operator|.
name|recycleByteBlocks
argument_list|(
name|buffers
argument_list|)
expr_stmt|;
name|buffers
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sizeInBytes
operator|=
literal|0
expr_stmt|;
assert|assert
name|numBuffers
argument_list|()
operator|==
literal|0
assert|;
block|}
block|}
block|}
comment|/**    * The IndexingChain must define the {@link #getChain(DocumentsWriter)} method    * which returns the DocConsumer that the DocumentsWriter calls to process the    * documents.     */
DECL|class|IndexingChain
specifier|abstract
specifier|static
class|class
name|IndexingChain
block|{
DECL|method|getChain
specifier|abstract
name|DocConsumer
name|getChain
parameter_list|(
name|DocumentsWriter
name|documentsWriter
parameter_list|)
function_decl|;
block|}
DECL|field|defaultIndexingChain
specifier|static
specifier|final
name|IndexingChain
name|defaultIndexingChain
init|=
operator|new
name|IndexingChain
argument_list|()
block|{
annotation|@
name|Override
name|DocConsumer
name|getChain
parameter_list|(
name|DocumentsWriter
name|documentsWriter
parameter_list|)
block|{
comment|/*       This is the current indexing chain:        DocConsumer / DocConsumerPerThread         --> code: DocFieldProcessor / DocFieldProcessorPerThread           --> DocFieldConsumer / DocFieldConsumerPerThread / DocFieldConsumerPerField             --> code: DocFieldConsumers / DocFieldConsumersPerThread / DocFieldConsumersPerField               --> code: DocInverter / DocInverterPerThread / DocInverterPerField                 --> InvertedDocConsumer / InvertedDocConsumerPerThread / InvertedDocConsumerPerField                   --> code: TermsHash / TermsHashPerThread / TermsHashPerField                     --> TermsHashConsumer / TermsHashConsumerPerThread / TermsHashConsumerPerField                       --> code: FreqProxTermsWriter / FreqProxTermsWriterPerThread / FreqProxTermsWriterPerField                       --> code: TermVectorsTermsWriter / TermVectorsTermsWriterPerThread / TermVectorsTermsWriterPerField                 --> InvertedDocEndConsumer / InvertedDocConsumerPerThread / InvertedDocConsumerPerField                   --> code: NormsWriter / NormsWriterPerThread / NormsWriterPerField               --> code: StoredFieldsWriter / StoredFieldsWriterPerThread / StoredFieldsWriterPerField     */
comment|// Build up indexing chain:
specifier|final
name|TermsHashConsumer
name|termVectorsWriter
init|=
operator|new
name|TermVectorsTermsWriter
argument_list|(
name|documentsWriter
argument_list|)
decl_stmt|;
specifier|final
name|TermsHashConsumer
name|freqProxWriter
init|=
operator|new
name|FreqProxTermsWriter
argument_list|()
decl_stmt|;
comment|/*        * nesting TermsHash instances here to allow the secondary (TermVectors) share the interned postings        * via a shared ByteBlockPool. See TermsHashPerField for details.         */
specifier|final
name|TermsHash
name|termVectorsTermHash
init|=
operator|new
name|TermsHash
argument_list|(
name|documentsWriter
argument_list|,
literal|false
argument_list|,
name|termVectorsWriter
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|InvertedDocConsumer
name|termsHash
init|=
operator|new
name|TermsHash
argument_list|(
name|documentsWriter
argument_list|,
literal|true
argument_list|,
name|freqProxWriter
argument_list|,
name|termVectorsTermHash
argument_list|)
decl_stmt|;
specifier|final
name|NormsWriter
name|normsWriter
init|=
operator|new
name|NormsWriter
argument_list|()
decl_stmt|;
specifier|final
name|DocInverter
name|docInverter
init|=
operator|new
name|DocInverter
argument_list|(
name|termsHash
argument_list|,
name|normsWriter
argument_list|)
decl_stmt|;
return|return
operator|new
name|DocFieldProcessor
argument_list|(
name|documentsWriter
argument_list|,
name|docInverter
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|consumer
specifier|final
name|DocConsumer
name|consumer
decl_stmt|;
comment|// How much RAM we can use before flushing.  This is 0 if
comment|// we are flushing by doc count instead.
DECL|field|ramBufferSize
specifier|private
name|long
name|ramBufferSize
init|=
call|(
name|long
call|)
argument_list|(
name|IndexWriterConfig
operator|.
name|DEFAULT_RAM_BUFFER_SIZE_MB
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
decl_stmt|;
DECL|field|waitQueuePauseBytes
specifier|private
name|long
name|waitQueuePauseBytes
init|=
call|(
name|long
call|)
argument_list|(
name|ramBufferSize
operator|*
literal|0.1
argument_list|)
decl_stmt|;
DECL|field|waitQueueResumeBytes
specifier|private
name|long
name|waitQueueResumeBytes
init|=
call|(
name|long
call|)
argument_list|(
name|ramBufferSize
operator|*
literal|0.05
argument_list|)
decl_stmt|;
comment|// If we've allocated 5% over our RAM budget, we then
comment|// free down to 95%
DECL|field|freeLevel
specifier|private
name|long
name|freeLevel
init|=
call|(
name|long
call|)
argument_list|(
name|IndexWriterConfig
operator|.
name|DEFAULT_RAM_BUFFER_SIZE_MB
operator|*
literal|1024
operator|*
literal|1024
operator|*
literal|0.95
argument_list|)
decl_stmt|;
comment|// Flush @ this number of docs.  If ramBufferSize is
comment|// non-zero we will flush by RAM usage instead.
DECL|field|maxBufferedDocs
specifier|private
name|int
name|maxBufferedDocs
init|=
name|IndexWriterConfig
operator|.
name|DEFAULT_MAX_BUFFERED_DOCS
decl_stmt|;
DECL|field|closed
specifier|private
name|boolean
name|closed
decl_stmt|;
DECL|field|fieldInfos
specifier|private
specifier|final
name|FieldInfos
name|fieldInfos
decl_stmt|;
DECL|field|bufferedDeletesStream
specifier|private
specifier|final
name|BufferedDeletesStream
name|bufferedDeletesStream
decl_stmt|;
DECL|field|flushControl
specifier|private
specifier|final
name|IndexWriter
operator|.
name|FlushControl
name|flushControl
decl_stmt|;
DECL|method|DocumentsWriter
name|DocumentsWriter
parameter_list|(
name|Directory
name|directory
parameter_list|,
name|IndexWriter
name|writer
parameter_list|,
name|IndexingChain
name|indexingChain
parameter_list|,
name|int
name|maxThreadStates
parameter_list|,
name|FieldInfos
name|fieldInfos
parameter_list|,
name|BufferedDeletesStream
name|bufferedDeletesStream
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
name|this
operator|.
name|writer
operator|=
name|writer
expr_stmt|;
name|this
operator|.
name|similarityProvider
operator|=
name|writer
operator|.
name|getConfig
argument_list|()
operator|.
name|getSimilarityProvider
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxThreadStates
operator|=
name|maxThreadStates
expr_stmt|;
name|this
operator|.
name|fieldInfos
operator|=
name|fieldInfos
expr_stmt|;
name|this
operator|.
name|bufferedDeletesStream
operator|=
name|bufferedDeletesStream
expr_stmt|;
name|flushControl
operator|=
name|writer
operator|.
name|flushControl
expr_stmt|;
name|consumer
operator|=
name|indexingChain
operator|.
name|getChain
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// Buffer a specific docID for deletion.  Currently only
comment|// used when we hit a exception when adding a document
DECL|method|deleteDocID
specifier|synchronized
name|void
name|deleteDocID
parameter_list|(
name|int
name|docIDUpto
parameter_list|)
block|{
name|pendingDeletes
operator|.
name|addDocID
argument_list|(
name|docIDUpto
argument_list|)
expr_stmt|;
comment|// NOTE: we do not trigger flush here.  This is
comment|// potentially a RAM leak, if you have an app that tries
comment|// to add docs but every single doc always hits a
comment|// non-aborting exception.  Allowing a flush here gets
comment|// very messy because we are only invoked when handling
comment|// exceptions so to do this properly, while handling an
comment|// exception we'd have to go off and flush new deletes
comment|// which is risky (likely would hit some other
comment|// confounding exception).
block|}
DECL|method|deleteQueries
name|boolean
name|deleteQueries
parameter_list|(
name|Query
modifier|...
name|queries
parameter_list|)
block|{
specifier|final
name|boolean
name|doFlush
init|=
name|flushControl
operator|.
name|waitUpdate
argument_list|(
literal|0
argument_list|,
name|queries
operator|.
name|length
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
for|for
control|(
name|Query
name|query
range|:
name|queries
control|)
block|{
name|pendingDeletes
operator|.
name|addQuery
argument_list|(
name|query
argument_list|,
name|numDocs
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|doFlush
return|;
block|}
DECL|method|deleteQuery
name|boolean
name|deleteQuery
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
specifier|final
name|boolean
name|doFlush
init|=
name|flushControl
operator|.
name|waitUpdate
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|pendingDeletes
operator|.
name|addQuery
argument_list|(
name|query
argument_list|,
name|numDocs
argument_list|)
expr_stmt|;
block|}
return|return
name|doFlush
return|;
block|}
DECL|method|deleteTerms
name|boolean
name|deleteTerms
parameter_list|(
name|Term
modifier|...
name|terms
parameter_list|)
block|{
specifier|final
name|boolean
name|doFlush
init|=
name|flushControl
operator|.
name|waitUpdate
argument_list|(
literal|0
argument_list|,
name|terms
operator|.
name|length
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
for|for
control|(
name|Term
name|term
range|:
name|terms
control|)
block|{
name|pendingDeletes
operator|.
name|addTerm
argument_list|(
name|term
argument_list|,
name|numDocs
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|doFlush
return|;
block|}
comment|// TODO: we could check w/ FreqProxTermsWriter: if the
comment|// term doesn't exist, don't bother buffering into the
comment|// per-DWPT map (but still must go into the global map)
DECL|method|deleteTerm
name|boolean
name|deleteTerm
parameter_list|(
name|Term
name|term
parameter_list|,
name|boolean
name|skipWait
parameter_list|)
block|{
specifier|final
name|boolean
name|doFlush
init|=
name|flushControl
operator|.
name|waitUpdate
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|skipWait
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|pendingDeletes
operator|.
name|addTerm
argument_list|(
name|term
argument_list|,
name|numDocs
argument_list|)
expr_stmt|;
block|}
return|return
name|doFlush
return|;
block|}
DECL|method|getFieldInfos
specifier|public
name|FieldInfos
name|getFieldInfos
parameter_list|()
block|{
return|return
name|fieldInfos
return|;
block|}
comment|/** If non-null, various details of indexing are printed    *  here. */
DECL|method|setInfoStream
specifier|synchronized
name|void
name|setInfoStream
parameter_list|(
name|PrintStream
name|infoStream
parameter_list|)
block|{
name|this
operator|.
name|infoStream
operator|=
name|infoStream
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|threadStates
index|[
name|i
index|]
operator|.
name|docState
operator|.
name|infoStream
operator|=
name|infoStream
expr_stmt|;
block|}
block|}
DECL|method|setSimilarityProvider
specifier|synchronized
name|void
name|setSimilarityProvider
parameter_list|(
name|SimilarityProvider
name|similarity
parameter_list|)
block|{
name|this
operator|.
name|similarityProvider
operator|=
name|similarity
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|threadStates
index|[
name|i
index|]
operator|.
name|docState
operator|.
name|similarityProvider
operator|=
name|similarity
expr_stmt|;
block|}
block|}
comment|/** Set how much RAM we can use before flushing. */
DECL|method|setRAMBufferSizeMB
specifier|synchronized
name|void
name|setRAMBufferSizeMB
parameter_list|(
name|double
name|mb
parameter_list|)
block|{
if|if
condition|(
name|mb
operator|==
name|IndexWriterConfig
operator|.
name|DISABLE_AUTO_FLUSH
condition|)
block|{
name|ramBufferSize
operator|=
name|IndexWriterConfig
operator|.
name|DISABLE_AUTO_FLUSH
expr_stmt|;
name|waitQueuePauseBytes
operator|=
literal|4
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
name|waitQueueResumeBytes
operator|=
literal|2
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
block|}
else|else
block|{
name|ramBufferSize
operator|=
call|(
name|long
call|)
argument_list|(
name|mb
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|waitQueuePauseBytes
operator|=
call|(
name|long
call|)
argument_list|(
name|ramBufferSize
operator|*
literal|0.1
argument_list|)
expr_stmt|;
name|waitQueueResumeBytes
operator|=
call|(
name|long
call|)
argument_list|(
name|ramBufferSize
operator|*
literal|0.05
argument_list|)
expr_stmt|;
name|freeLevel
operator|=
call|(
name|long
call|)
argument_list|(
literal|0.95
operator|*
name|ramBufferSize
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getRAMBufferSizeMB
specifier|synchronized
name|double
name|getRAMBufferSizeMB
parameter_list|()
block|{
if|if
condition|(
name|ramBufferSize
operator|==
name|IndexWriterConfig
operator|.
name|DISABLE_AUTO_FLUSH
condition|)
block|{
return|return
name|ramBufferSize
return|;
block|}
else|else
block|{
return|return
name|ramBufferSize
operator|/
literal|1024.
operator|/
literal|1024.
return|;
block|}
block|}
comment|/** Set max buffered docs, which means we will flush by    *  doc count instead of by RAM usage. */
DECL|method|setMaxBufferedDocs
name|void
name|setMaxBufferedDocs
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|maxBufferedDocs
operator|=
name|count
expr_stmt|;
block|}
DECL|method|getMaxBufferedDocs
name|int
name|getMaxBufferedDocs
parameter_list|()
block|{
return|return
name|maxBufferedDocs
return|;
block|}
comment|/** Get current segment name we are writing. */
DECL|method|getSegment
specifier|synchronized
name|String
name|getSegment
parameter_list|()
block|{
return|return
name|segment
return|;
block|}
comment|/** Returns how many docs are currently buffered in RAM. */
DECL|method|getNumDocs
specifier|synchronized
name|int
name|getNumDocs
parameter_list|()
block|{
return|return
name|numDocs
return|;
block|}
DECL|method|message
name|void
name|message
parameter_list|(
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|message
argument_list|(
literal|"DW: "
operator|+
name|message
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setAborting
specifier|synchronized
name|void
name|setAborting
parameter_list|()
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"setAborting"
argument_list|)
expr_stmt|;
block|}
name|aborting
operator|=
literal|true
expr_stmt|;
block|}
comment|/** Called if we hit an exception at a bad time (when    *  updating the index files) and must discard all    *  currently buffered docs.  This resets our state,    *  discarding any docs added since last flush. */
DECL|method|abort
specifier|synchronized
name|void
name|abort
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"docWriter: abort"
argument_list|)
expr_stmt|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// Forcefully remove waiting ThreadStates from line
name|waitQueue
operator|.
name|abort
argument_list|()
expr_stmt|;
comment|// Wait for all other threads to finish with
comment|// DocumentsWriter:
name|waitIdle
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"docWriter: abort waitIdle done"
argument_list|)
expr_stmt|;
block|}
assert|assert
literal|0
operator|==
name|waitQueue
operator|.
name|numWaiting
operator|:
literal|"waitQueue.numWaiting="
operator|+
name|waitQueue
operator|.
name|numWaiting
assert|;
name|waitQueue
operator|.
name|waitingBytes
operator|=
literal|0
expr_stmt|;
name|pendingDeletes
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|DocumentsWriterThreadState
name|threadState
range|:
name|threadStates
control|)
try|try
block|{
name|threadState
operator|.
name|consumer
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{         }
try|try
block|{
name|consumer
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{       }
comment|// Reset all postings data
name|doAfterFlush
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|aborting
operator|=
literal|false
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"docWriter: done abort; success="
operator|+
name|success
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Reset after a flush */
DECL|method|doAfterFlush
specifier|private
name|void
name|doAfterFlush
parameter_list|()
throws|throws
name|IOException
block|{
comment|// All ThreadStates should be idle when we are called
assert|assert
name|allThreadsIdle
argument_list|()
assert|;
name|threadBindings
operator|.
name|clear
argument_list|()
expr_stmt|;
name|waitQueue
operator|.
name|reset
argument_list|()
expr_stmt|;
name|segment
operator|=
literal|null
expr_stmt|;
name|numDocs
operator|=
literal|0
expr_stmt|;
name|nextDocID
operator|=
literal|0
expr_stmt|;
name|bufferIsFull
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|threadStates
index|[
name|i
index|]
operator|.
name|doAfterFlush
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|allThreadsIdle
specifier|private
specifier|synchronized
name|boolean
name|allThreadsIdle
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|threadStates
index|[
name|i
index|]
operator|.
name|isIdle
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|anyChanges
specifier|synchronized
name|boolean
name|anyChanges
parameter_list|()
block|{
return|return
name|numDocs
operator|!=
literal|0
operator|||
name|pendingDeletes
operator|.
name|any
argument_list|()
return|;
block|}
comment|// for testing
DECL|method|getPendingDeletes
specifier|public
name|BufferedDeletes
name|getPendingDeletes
parameter_list|()
block|{
return|return
name|pendingDeletes
return|;
block|}
DECL|method|pushDeletes
specifier|private
name|void
name|pushDeletes
parameter_list|(
name|SegmentInfo
name|newSegment
parameter_list|,
name|SegmentInfos
name|segmentInfos
parameter_list|)
block|{
comment|// Lock order: DW -> BD
specifier|final
name|long
name|delGen
init|=
name|bufferedDeletesStream
operator|.
name|getNextGen
argument_list|()
decl_stmt|;
if|if
condition|(
name|pendingDeletes
operator|.
name|any
argument_list|()
condition|)
block|{
if|if
condition|(
name|segmentInfos
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|||
name|newSegment
operator|!=
literal|null
condition|)
block|{
specifier|final
name|FrozenBufferedDeletes
name|packet
init|=
operator|new
name|FrozenBufferedDeletes
argument_list|(
name|pendingDeletes
argument_list|,
name|delGen
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"flush: push buffered deletes"
argument_list|)
expr_stmt|;
block|}
name|bufferedDeletesStream
operator|.
name|push
argument_list|(
name|packet
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"flush: delGen="
operator|+
name|packet
operator|.
name|gen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newSegment
operator|!=
literal|null
condition|)
block|{
name|newSegment
operator|.
name|setBufferedDeletesGen
argument_list|(
name|packet
operator|.
name|gen
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"flush: drop buffered deletes: no segments"
argument_list|)
expr_stmt|;
block|}
comment|// We can safely discard these deletes: since
comment|// there are no segments, the deletions cannot
comment|// affect anything.
block|}
name|pendingDeletes
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newSegment
operator|!=
literal|null
condition|)
block|{
name|newSegment
operator|.
name|setBufferedDeletesGen
argument_list|(
name|delGen
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|anyDeletions
specifier|public
name|boolean
name|anyDeletions
parameter_list|()
block|{
return|return
name|pendingDeletes
operator|.
name|any
argument_list|()
return|;
block|}
comment|/** Flush all pending docs to a new segment */
comment|// Lock order: IW -> DW
DECL|method|flush
specifier|synchronized
name|SegmentInfo
name|flush
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|IndexFileDeleter
name|deleter
parameter_list|,
name|MergePolicy
name|mergePolicy
parameter_list|,
name|SegmentInfos
name|segmentInfos
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// We change writer's segmentInfos:
assert|assert
name|Thread
operator|.
name|holdsLock
argument_list|(
name|writer
argument_list|)
assert|;
name|waitIdle
argument_list|()
expr_stmt|;
if|if
condition|(
name|numDocs
operator|==
literal|0
condition|)
block|{
comment|// nothing to do!
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"flush: no docs; skipping"
argument_list|)
expr_stmt|;
block|}
comment|// Lock order: IW -> DW -> BD
name|pushDeletes
argument_list|(
literal|null
argument_list|,
name|segmentInfos
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|aborting
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"flush: skip because aborting is set"
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|SegmentInfo
name|newSegment
decl_stmt|;
try|try
block|{
assert|assert
name|nextDocID
operator|==
name|numDocs
assert|;
assert|assert
name|waitQueue
operator|.
name|numWaiting
operator|==
literal|0
assert|;
assert|assert
name|waitQueue
operator|.
name|waitingBytes
operator|==
literal|0
assert|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"flush postings as segment "
operator|+
name|segment
operator|+
literal|" numDocs="
operator|+
name|numDocs
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SegmentWriteState
name|flushState
init|=
operator|new
name|SegmentWriteState
argument_list|(
name|infoStream
argument_list|,
name|directory
argument_list|,
name|segment
argument_list|,
name|fieldInfos
argument_list|,
name|numDocs
argument_list|,
name|writer
operator|.
name|getConfig
argument_list|()
operator|.
name|getTermIndexInterval
argument_list|()
argument_list|,
name|SegmentCodecs
operator|.
name|build
argument_list|(
name|fieldInfos
argument_list|,
name|writer
operator|.
name|codecs
argument_list|)
argument_list|,
name|pendingDeletes
argument_list|)
decl_stmt|;
comment|// Apply delete-by-docID now (delete-byDocID only
comment|// happens when an exception is hit processing that
comment|// doc, eg if analyzer has some problem w/ the text):
if|if
condition|(
name|pendingDeletes
operator|.
name|docIDs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|flushState
operator|.
name|deletedDocs
operator|=
operator|new
name|BitVector
argument_list|(
name|numDocs
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|delDocID
range|:
name|pendingDeletes
operator|.
name|docIDs
control|)
block|{
name|flushState
operator|.
name|deletedDocs
operator|.
name|set
argument_list|(
name|delDocID
argument_list|)
expr_stmt|;
block|}
name|pendingDeletes
operator|.
name|bytesUsed
operator|.
name|addAndGet
argument_list|(
operator|-
name|pendingDeletes
operator|.
name|docIDs
operator|.
name|size
argument_list|()
operator|*
name|BufferedDeletes
operator|.
name|BYTES_PER_DEL_DOCID
argument_list|)
expr_stmt|;
name|pendingDeletes
operator|.
name|docIDs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|newSegment
operator|=
operator|new
name|SegmentInfo
argument_list|(
name|segment
argument_list|,
name|numDocs
argument_list|,
name|directory
argument_list|,
literal|false
argument_list|,
name|fieldInfos
operator|.
name|hasProx
argument_list|()
argument_list|,
name|flushState
operator|.
name|segmentCodecs
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|DocConsumerPerThread
argument_list|>
name|threads
init|=
operator|new
name|HashSet
argument_list|<
name|DocConsumerPerThread
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|DocumentsWriterThreadState
name|threadState
range|:
name|threadStates
control|)
block|{
name|threads
operator|.
name|add
argument_list|(
name|threadState
operator|.
name|consumer
argument_list|)
expr_stmt|;
block|}
name|double
name|startMBUsed
init|=
name|bytesUsed
argument_list|()
operator|/
literal|1024.
operator|/
literal|1024.
decl_stmt|;
name|consumer
operator|.
name|flush
argument_list|(
name|threads
argument_list|,
name|flushState
argument_list|)
expr_stmt|;
name|newSegment
operator|.
name|setHasVectors
argument_list|(
name|flushState
operator|.
name|hasVectors
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"new segment has "
operator|+
operator|(
name|flushState
operator|.
name|hasVectors
condition|?
literal|"vectors"
else|:
literal|"no vectors"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flushState
operator|.
name|deletedDocs
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"new segment has "
operator|+
name|flushState
operator|.
name|deletedDocs
operator|.
name|count
argument_list|()
operator|+
literal|" deleted docs"
argument_list|)
expr_stmt|;
block|}
name|message
argument_list|(
literal|"flushedFiles="
operator|+
name|newSegment
operator|.
name|files
argument_list|()
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"flushed codecs="
operator|+
name|newSegment
operator|.
name|getSegmentCodecs
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mergePolicy
operator|.
name|useCompoundFile
argument_list|(
name|segmentInfos
argument_list|,
name|newSegment
argument_list|)
condition|)
block|{
specifier|final
name|String
name|cfsFileName
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segment
argument_list|,
literal|""
argument_list|,
name|IndexFileNames
operator|.
name|COMPOUND_FILE_EXTENSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"flush: create compound file \""
operator|+
name|cfsFileName
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
name|CompoundFileWriter
name|cfsWriter
init|=
operator|new
name|CompoundFileWriter
argument_list|(
name|directory
argument_list|,
name|cfsFileName
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|fileName
range|:
name|newSegment
operator|.
name|files
argument_list|()
control|)
block|{
name|cfsWriter
operator|.
name|addFile
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
name|cfsWriter
operator|.
name|close
argument_list|()
expr_stmt|;
name|deleter
operator|.
name|deleteNewFiles
argument_list|(
name|newSegment
operator|.
name|files
argument_list|()
argument_list|)
expr_stmt|;
name|newSegment
operator|.
name|setUseCompoundFile
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Must write deleted docs after the CFS so we don't
comment|// slurp the del file into CFS:
if|if
condition|(
name|flushState
operator|.
name|deletedDocs
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|delCount
init|=
name|flushState
operator|.
name|deletedDocs
operator|.
name|count
argument_list|()
decl_stmt|;
assert|assert
name|delCount
operator|>
literal|0
assert|;
name|newSegment
operator|.
name|setDelCount
argument_list|(
name|delCount
argument_list|)
expr_stmt|;
name|newSegment
operator|.
name|advanceDelGen
argument_list|()
expr_stmt|;
specifier|final
name|String
name|delFileName
init|=
name|newSegment
operator|.
name|getDelFileName
argument_list|()
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"flush: write "
operator|+
name|delCount
operator|+
literal|" deletes to "
operator|+
name|delFileName
argument_list|)
expr_stmt|;
block|}
name|boolean
name|success2
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// TODO: in the NRT case it'd be better to hand
comment|// this del vector over to the
comment|// shortly-to-be-opened SegmentReader and let it
comment|// carry the changes; there's no reason to use
comment|// filesystem as intermediary here.
name|flushState
operator|.
name|deletedDocs
operator|.
name|write
argument_list|(
name|directory
argument_list|,
name|delFileName
argument_list|)
expr_stmt|;
name|success2
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success2
condition|)
block|{
try|try
block|{
name|directory
operator|.
name|deleteFile
argument_list|(
name|delFileName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// suppress this so we keep throwing the
comment|// original exception
block|}
block|}
block|}
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"flush: segment="
operator|+
name|newSegment
argument_list|)
expr_stmt|;
specifier|final
name|double
name|newSegmentSizeNoStore
init|=
name|newSegment
operator|.
name|sizeInBytes
argument_list|(
literal|false
argument_list|)
operator|/
literal|1024.
operator|/
literal|1024.
decl_stmt|;
specifier|final
name|double
name|newSegmentSize
init|=
name|newSegment
operator|.
name|sizeInBytes
argument_list|(
literal|true
argument_list|)
operator|/
literal|1024.
operator|/
literal|1024.
decl_stmt|;
name|message
argument_list|(
literal|"  ramUsed="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|startMBUsed
argument_list|)
operator|+
literal|" MB"
operator|+
literal|" newFlushedSize="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|newSegmentSize
argument_list|)
operator|+
literal|" MB"
operator|+
literal|" ("
operator|+
name|nf
operator|.
name|format
argument_list|(
name|newSegmentSizeNoStore
argument_list|)
operator|+
literal|" MB w/o doc stores)"
operator|+
literal|" docs/MB="
operator|+
name|nf
operator|.
name|format
argument_list|(
name|numDocs
operator|/
name|newSegmentSize
argument_list|)
operator|+
literal|" new/old="
operator|+
name|nf
operator|.
name|format
argument_list|(
literal|100.0
operator|*
name|newSegmentSizeNoStore
operator|/
name|startMBUsed
argument_list|)
operator|+
literal|"%"
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|notifyAll
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|segment
operator|!=
literal|null
condition|)
block|{
name|deleter
operator|.
name|refresh
argument_list|(
name|segment
argument_list|)
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|doAfterFlush
argument_list|()
expr_stmt|;
comment|// Lock order: IW -> DW -> BD
name|pushDeletes
argument_list|(
name|newSegment
argument_list|,
name|segmentInfos
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"flush time "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
operator|+
literal|" msec"
argument_list|)
expr_stmt|;
block|}
return|return
name|newSegment
return|;
block|}
DECL|method|close
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
name|closed
operator|=
literal|true
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|/** Returns a free (idle) ThreadState that may be used for    * indexing this one document.  This call also pauses if a    * flush is pending.  If delTerm is non-null then we    * buffer this deleted term after the thread state has    * been acquired. */
DECL|method|getThreadState
specifier|synchronized
name|DocumentsWriterThreadState
name|getThreadState
parameter_list|(
name|Document
name|doc
parameter_list|,
name|Term
name|delTerm
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Thread
name|currentThread
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
assert|assert
operator|!
name|Thread
operator|.
name|holdsLock
argument_list|(
name|writer
argument_list|)
assert|;
comment|// First, find a thread state.  If this thread already
comment|// has affinity to a specific ThreadState, use that one
comment|// again.
name|DocumentsWriterThreadState
name|state
init|=
name|threadBindings
operator|.
name|get
argument_list|(
name|currentThread
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
comment|// First time this thread has called us since last
comment|// flush.  Find the least loaded thread state:
name|DocumentsWriterThreadState
name|minThreadState
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadStates
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|DocumentsWriterThreadState
name|ts
init|=
name|threadStates
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|minThreadState
operator|==
literal|null
operator|||
name|ts
operator|.
name|numThreads
operator|<
name|minThreadState
operator|.
name|numThreads
condition|)
block|{
name|minThreadState
operator|=
name|ts
expr_stmt|;
block|}
block|}
if|if
condition|(
name|minThreadState
operator|!=
literal|null
operator|&&
operator|(
name|minThreadState
operator|.
name|numThreads
operator|==
literal|0
operator|||
name|threadStates
operator|.
name|length
operator|>=
name|maxThreadStates
operator|)
condition|)
block|{
name|state
operator|=
name|minThreadState
expr_stmt|;
name|state
operator|.
name|numThreads
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// Just create a new "private" thread state
name|DocumentsWriterThreadState
index|[]
name|newArray
init|=
operator|new
name|DocumentsWriterThreadState
index|[
literal|1
operator|+
name|threadStates
operator|.
name|length
index|]
decl_stmt|;
if|if
condition|(
name|threadStates
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|threadStates
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|threadStates
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|newArray
index|[
name|threadStates
operator|.
name|length
index|]
operator|=
operator|new
name|DocumentsWriterThreadState
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|threadStates
operator|=
name|newArray
expr_stmt|;
block|}
name|threadBindings
operator|.
name|put
argument_list|(
name|currentThread
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
comment|// Next, wait until my thread state is idle (in case
comment|// it's shared with other threads), and no flush/abort
comment|// pending
name|waitReady
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|// Allocate segment name if this is the first doc since
comment|// last flush:
if|if
condition|(
name|segment
operator|==
literal|null
condition|)
block|{
name|segment
operator|=
name|writer
operator|.
name|newSegmentName
argument_list|()
expr_stmt|;
assert|assert
name|numDocs
operator|==
literal|0
assert|;
block|}
name|state
operator|.
name|docState
operator|.
name|docID
operator|=
name|nextDocID
operator|++
expr_stmt|;
if|if
condition|(
name|delTerm
operator|!=
literal|null
condition|)
block|{
name|pendingDeletes
operator|.
name|addTerm
argument_list|(
name|delTerm
argument_list|,
name|state
operator|.
name|docState
operator|.
name|docID
argument_list|)
expr_stmt|;
block|}
name|numDocs
operator|++
expr_stmt|;
name|state
operator|.
name|isIdle
operator|=
literal|false
expr_stmt|;
return|return
name|state
return|;
block|}
DECL|method|addDocument
name|boolean
name|addDocument
parameter_list|(
name|Document
name|doc
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|updateDocument
argument_list|(
name|doc
argument_list|,
name|analyzer
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|updateDocument
name|boolean
name|updateDocument
parameter_list|(
name|Document
name|doc
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|,
name|Term
name|delTerm
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
comment|// Possibly trigger a flush, or wait until any running flush completes:
name|boolean
name|doFlush
init|=
name|flushControl
operator|.
name|waitUpdate
argument_list|(
literal|1
argument_list|,
name|delTerm
operator|!=
literal|null
condition|?
literal|1
else|:
literal|0
argument_list|)
decl_stmt|;
comment|// This call is synchronized but fast
specifier|final
name|DocumentsWriterThreadState
name|state
init|=
name|getThreadState
argument_list|(
name|doc
argument_list|,
name|delTerm
argument_list|)
decl_stmt|;
specifier|final
name|DocState
name|docState
init|=
name|state
operator|.
name|docState
decl_stmt|;
name|docState
operator|.
name|doc
operator|=
name|doc
expr_stmt|;
name|docState
operator|.
name|analyzer
operator|=
name|analyzer
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// This call is not synchronized and does all the
comment|// work
specifier|final
name|DocWriter
name|perDoc
decl_stmt|;
try|try
block|{
name|perDoc
operator|=
name|state
operator|.
name|consumer
operator|.
name|processDocument
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|docState
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// This call is synchronized but fast
name|finishDocument
argument_list|(
name|state
argument_list|,
name|perDoc
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// If this thread state had decided to flush, we
comment|// must clear it so another thread can flush
if|if
condition|(
name|doFlush
condition|)
block|{
name|flushControl
operator|.
name|clearFlushPending
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"exception in updateDocument aborting="
operator|+
name|aborting
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
name|state
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|aborting
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|skipDocWriter
operator|.
name|docID
operator|=
name|docState
operator|.
name|docID
expr_stmt|;
name|boolean
name|success2
init|=
literal|false
decl_stmt|;
try|try
block|{
name|waitQueue
operator|.
name|add
argument_list|(
name|skipDocWriter
argument_list|)
expr_stmt|;
name|success2
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success2
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// Immediately mark this document as deleted
comment|// since likely it was partially added.  This
comment|// keeps indexing as "all or none" (atomic) when
comment|// adding a document:
name|deleteDocID
argument_list|(
name|state
operator|.
name|docState
operator|.
name|docID
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|doFlush
operator||=
name|flushControl
operator|.
name|flushByRAMUsage
argument_list|(
literal|"new document"
argument_list|)
expr_stmt|;
return|return
name|doFlush
return|;
block|}
DECL|method|waitIdle
specifier|public
specifier|synchronized
name|void
name|waitIdle
parameter_list|()
block|{
while|while
condition|(
operator|!
name|allThreadsIdle
argument_list|()
condition|)
block|{
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|ThreadInterruptedException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|waitReady
specifier|synchronized
name|void
name|waitReady
parameter_list|(
name|DocumentsWriterThreadState
name|state
parameter_list|)
block|{
while|while
condition|(
operator|!
name|closed
operator|&&
operator|(
operator|!
name|state
operator|.
name|isIdle
operator|||
name|aborting
operator|)
condition|)
block|{
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|ThreadInterruptedException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|AlreadyClosedException
argument_list|(
literal|"this IndexWriter is closed"
argument_list|)
throw|;
block|}
block|}
comment|/** Does the synchronized work to finish/flush the    *  inverted document. */
DECL|method|finishDocument
specifier|private
name|void
name|finishDocument
parameter_list|(
name|DocumentsWriterThreadState
name|perThread
parameter_list|,
name|DocWriter
name|docWriter
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Must call this w/o holding synchronized(this) else
comment|// we'll hit deadlock:
name|balanceRAM
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
assert|assert
name|docWriter
operator|==
literal|null
operator|||
name|docWriter
operator|.
name|docID
operator|==
name|perThread
operator|.
name|docState
operator|.
name|docID
assert|;
if|if
condition|(
name|aborting
condition|)
block|{
comment|// We are currently aborting, and another thread is
comment|// waiting for me to become idle.  We just forcefully
comment|// idle this threadState; it will be fully reset by
comment|// abort()
if|if
condition|(
name|docWriter
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|docWriter
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{           }
block|}
name|perThread
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
comment|// wakes up any threads waiting on the wait queue
name|notifyAll
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|final
name|boolean
name|doPause
decl_stmt|;
if|if
condition|(
name|docWriter
operator|!=
literal|null
condition|)
block|{
name|doPause
operator|=
name|waitQueue
operator|.
name|add
argument_list|(
name|docWriter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|skipDocWriter
operator|.
name|docID
operator|=
name|perThread
operator|.
name|docState
operator|.
name|docID
expr_stmt|;
name|doPause
operator|=
name|waitQueue
operator|.
name|add
argument_list|(
name|skipDocWriter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doPause
condition|)
block|{
name|waitForWaitQueue
argument_list|()
expr_stmt|;
block|}
name|perThread
operator|.
name|isIdle
operator|=
literal|true
expr_stmt|;
comment|// wakes up any threads waiting on the wait queue
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|waitForWaitQueue
specifier|synchronized
name|void
name|waitForWaitQueue
parameter_list|()
block|{
do|do
block|{
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|ThreadInterruptedException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
do|while
condition|(
operator|!
name|waitQueue
operator|.
name|doResume
argument_list|()
condition|)
do|;
block|}
DECL|class|SkipDocWriter
specifier|private
specifier|static
class|class
name|SkipDocWriter
extends|extends
name|DocWriter
block|{
annotation|@
name|Override
DECL|method|finish
name|void
name|finish
parameter_list|()
block|{     }
annotation|@
name|Override
DECL|method|abort
name|void
name|abort
parameter_list|()
block|{     }
annotation|@
name|Override
DECL|method|sizeInBytes
name|long
name|sizeInBytes
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|field|skipDocWriter
specifier|final
name|SkipDocWriter
name|skipDocWriter
init|=
operator|new
name|SkipDocWriter
argument_list|()
decl_stmt|;
DECL|field|nf
name|NumberFormat
name|nf
init|=
name|NumberFormat
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|/* Initial chunks size of the shared byte[] blocks used to      store postings data */
DECL|field|BYTE_BLOCK_NOT_MASK
specifier|final
specifier|static
name|int
name|BYTE_BLOCK_NOT_MASK
init|=
operator|~
name|BYTE_BLOCK_MASK
decl_stmt|;
comment|/* if you increase this, you must fix field cache impl for    * getTerms/getTermsIndex requires<= 32768. */
DECL|field|MAX_TERM_LENGTH_UTF8
specifier|final
specifier|static
name|int
name|MAX_TERM_LENGTH_UTF8
init|=
name|BYTE_BLOCK_SIZE
operator|-
literal|2
decl_stmt|;
comment|/* Initial chunks size of the shared int[] blocks used to      store postings data */
DECL|field|INT_BLOCK_SHIFT
specifier|final
specifier|static
name|int
name|INT_BLOCK_SHIFT
init|=
literal|13
decl_stmt|;
DECL|field|INT_BLOCK_SIZE
specifier|final
specifier|static
name|int
name|INT_BLOCK_SIZE
init|=
literal|1
operator|<<
name|INT_BLOCK_SHIFT
decl_stmt|;
DECL|field|INT_BLOCK_MASK
specifier|final
specifier|static
name|int
name|INT_BLOCK_MASK
init|=
name|INT_BLOCK_SIZE
operator|-
literal|1
decl_stmt|;
DECL|field|freeIntBlocks
specifier|private
name|List
argument_list|<
name|int
index|[]
argument_list|>
name|freeIntBlocks
init|=
operator|new
name|ArrayList
argument_list|<
name|int
index|[]
argument_list|>
argument_list|()
decl_stmt|;
comment|/* Allocate another int[] from the shared pool */
DECL|method|getIntBlock
specifier|synchronized
name|int
index|[]
name|getIntBlock
parameter_list|()
block|{
specifier|final
name|int
name|size
init|=
name|freeIntBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
index|[]
name|b
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|size
condition|)
block|{
name|b
operator|=
operator|new
name|int
index|[
name|INT_BLOCK_SIZE
index|]
expr_stmt|;
name|bytesUsed
operator|.
name|addAndGet
argument_list|(
name|INT_BLOCK_SIZE
operator|*
name|RamUsageEstimator
operator|.
name|NUM_BYTES_INT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|freeIntBlocks
operator|.
name|remove
argument_list|(
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
DECL|method|bytesUsed
name|long
name|bytesUsed
parameter_list|()
block|{
return|return
name|bytesUsed
operator|.
name|get
argument_list|()
operator|+
name|pendingDeletes
operator|.
name|bytesUsed
operator|.
name|get
argument_list|()
return|;
block|}
comment|/* Return int[]s to the pool */
DECL|method|recycleIntBlocks
specifier|synchronized
name|void
name|recycleIntBlocks
parameter_list|(
name|int
index|[]
index|[]
name|blocks
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|freeIntBlocks
operator|.
name|add
argument_list|(
name|blocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|blocks
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|field|byteBlockAllocator
specifier|final
name|RecyclingByteBlockAllocator
name|byteBlockAllocator
init|=
operator|new
name|RecyclingByteBlockAllocator
argument_list|(
name|BYTE_BLOCK_SIZE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|bytesUsed
argument_list|)
decl_stmt|;
DECL|field|PER_DOC_BLOCK_SIZE
specifier|final
specifier|static
name|int
name|PER_DOC_BLOCK_SIZE
init|=
literal|1024
decl_stmt|;
DECL|field|perDocAllocator
specifier|final
name|RecyclingByteBlockAllocator
name|perDocAllocator
init|=
operator|new
name|RecyclingByteBlockAllocator
argument_list|(
name|PER_DOC_BLOCK_SIZE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|bytesUsed
argument_list|)
decl_stmt|;
DECL|method|toMB
name|String
name|toMB
parameter_list|(
name|long
name|v
parameter_list|)
block|{
return|return
name|nf
operator|.
name|format
argument_list|(
name|v
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
return|;
block|}
comment|/* We have three pools of RAM: Postings, byte blocks    * (holds freq/prox posting data) and per-doc buffers    * (stored fields/term vectors).  Different docs require    * varying amount of storage from these classes.  For    * example, docs with many unique single-occurrence short    * terms will use up the Postings RAM and hardly any of    * the other two.  Whereas docs with very large terms will    * use alot of byte blocks RAM.  This method just frees    * allocations from the pools once we are over-budget,    * which balances the pools to match the current docs. */
DECL|method|balanceRAM
name|void
name|balanceRAM
parameter_list|()
block|{
specifier|final
name|boolean
name|doBalance
decl_stmt|;
specifier|final
name|long
name|deletesRAMUsed
decl_stmt|;
name|deletesRAMUsed
operator|=
name|bufferedDeletesStream
operator|.
name|bytesUsed
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|ramBufferSize
operator|==
name|IndexWriterConfig
operator|.
name|DISABLE_AUTO_FLUSH
operator|||
name|bufferIsFull
condition|)
block|{
return|return;
block|}
name|doBalance
operator|=
name|bytesUsed
argument_list|()
operator|+
name|deletesRAMUsed
operator|>=
name|ramBufferSize
expr_stmt|;
block|}
if|if
condition|(
name|doBalance
condition|)
block|{
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"  RAM: balance allocations: usedMB="
operator|+
name|toMB
argument_list|(
name|bytesUsed
argument_list|()
argument_list|)
operator|+
literal|" vs trigger="
operator|+
name|toMB
argument_list|(
name|ramBufferSize
argument_list|)
operator|+
literal|" deletesMB="
operator|+
name|toMB
argument_list|(
name|deletesRAMUsed
argument_list|)
operator|+
literal|" byteBlockFree="
operator|+
name|toMB
argument_list|(
name|byteBlockAllocator
operator|.
name|bytesUsed
argument_list|()
argument_list|)
operator|+
literal|" perDocFree="
operator|+
name|toMB
argument_list|(
name|perDocAllocator
operator|.
name|bytesUsed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|startBytesUsed
init|=
name|bytesUsed
argument_list|()
operator|+
name|deletesRAMUsed
decl_stmt|;
name|int
name|iter
init|=
literal|0
decl_stmt|;
comment|// We free equally from each pool in 32 KB
comment|// chunks until we are below our threshold
comment|// (freeLevel)
name|boolean
name|any
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|bytesUsed
argument_list|()
operator|+
name|deletesRAMUsed
operator|>
name|freeLevel
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
literal|0
operator|==
name|perDocAllocator
operator|.
name|numBufferedBlocks
argument_list|()
operator|&&
literal|0
operator|==
name|byteBlockAllocator
operator|.
name|numBufferedBlocks
argument_list|()
operator|&&
literal|0
operator|==
name|freeIntBlocks
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|any
condition|)
block|{
comment|// Nothing else to free -- must flush now.
name|bufferIsFull
operator|=
name|bytesUsed
argument_list|()
operator|+
name|deletesRAMUsed
operator|>
name|ramBufferSize
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|bytesUsed
argument_list|()
operator|+
name|deletesRAMUsed
operator|>
name|ramBufferSize
condition|)
block|{
name|message
argument_list|(
literal|"    nothing to free; set bufferIsFull"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"    nothing to free"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
operator|(
literal|0
operator|==
name|iter
operator|%
literal|4
operator|)
operator|&&
name|byteBlockAllocator
operator|.
name|numBufferedBlocks
argument_list|()
operator|>
literal|0
condition|)
block|{
name|byteBlockAllocator
operator|.
name|freeBlocks
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|1
operator|==
name|iter
operator|%
literal|4
operator|)
operator|&&
name|freeIntBlocks
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|freeIntBlocks
operator|.
name|remove
argument_list|(
name|freeIntBlocks
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bytesUsed
operator|.
name|addAndGet
argument_list|(
operator|-
name|INT_BLOCK_SIZE
operator|*
name|RamUsageEstimator
operator|.
name|NUM_BYTES_INT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|2
operator|==
name|iter
operator|%
literal|4
operator|)
operator|&&
name|perDocAllocator
operator|.
name|numBufferedBlocks
argument_list|()
operator|>
literal|0
condition|)
block|{
name|perDocAllocator
operator|.
name|freeBlocks
argument_list|(
literal|32
argument_list|)
expr_stmt|;
comment|// Remove upwards of 32 blocks (each block is 1K)
block|}
block|}
if|if
condition|(
operator|(
literal|3
operator|==
name|iter
operator|%
literal|4
operator|)
operator|&&
name|any
condition|)
block|{
comment|// Ask consumer to free any recycled state
name|any
operator|=
name|consumer
operator|.
name|freeRAM
argument_list|()
expr_stmt|;
block|}
name|iter
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"    after free: freedMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
operator|(
name|startBytesUsed
operator|-
name|bytesUsed
argument_list|()
operator|-
name|deletesRAMUsed
operator|)
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
operator|+
literal|" usedMB="
operator|+
name|nf
operator|.
name|format
argument_list|(
operator|(
name|bytesUsed
argument_list|()
operator|+
name|deletesRAMUsed
operator|)
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|field|waitQueue
specifier|final
name|WaitQueue
name|waitQueue
init|=
operator|new
name|WaitQueue
argument_list|()
decl_stmt|;
DECL|class|WaitQueue
specifier|private
class|class
name|WaitQueue
block|{
DECL|field|waiting
name|DocWriter
index|[]
name|waiting
decl_stmt|;
DECL|field|nextWriteDocID
name|int
name|nextWriteDocID
decl_stmt|;
DECL|field|nextWriteLoc
name|int
name|nextWriteLoc
decl_stmt|;
DECL|field|numWaiting
name|int
name|numWaiting
decl_stmt|;
DECL|field|waitingBytes
name|long
name|waitingBytes
decl_stmt|;
DECL|method|WaitQueue
specifier|public
name|WaitQueue
parameter_list|()
block|{
name|waiting
operator|=
operator|new
name|DocWriter
index|[
literal|10
index|]
expr_stmt|;
block|}
DECL|method|reset
specifier|synchronized
name|void
name|reset
parameter_list|()
block|{
comment|// NOTE: nextWriteLoc doesn't need to be reset
assert|assert
name|numWaiting
operator|==
literal|0
assert|;
assert|assert
name|waitingBytes
operator|==
literal|0
assert|;
name|nextWriteDocID
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|doResume
specifier|synchronized
name|boolean
name|doResume
parameter_list|()
block|{
return|return
name|waitingBytes
operator|<=
name|waitQueueResumeBytes
return|;
block|}
DECL|method|doPause
specifier|synchronized
name|boolean
name|doPause
parameter_list|()
block|{
return|return
name|waitingBytes
operator|>
name|waitQueuePauseBytes
return|;
block|}
DECL|method|abort
specifier|synchronized
name|void
name|abort
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|waiting
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|DocWriter
name|doc
init|=
name|waiting
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|abort
argument_list|()
expr_stmt|;
name|waiting
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
name|waitingBytes
operator|=
literal|0
expr_stmt|;
assert|assert
name|count
operator|==
name|numWaiting
assert|;
name|numWaiting
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|writeDocument
specifier|private
name|void
name|writeDocument
parameter_list|(
name|DocWriter
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|doc
operator|==
name|skipDocWriter
operator|||
name|nextWriteDocID
operator|==
name|doc
operator|.
name|docID
assert|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|doc
operator|.
name|finish
argument_list|()
expr_stmt|;
name|nextWriteDocID
operator|++
expr_stmt|;
name|nextWriteLoc
operator|++
expr_stmt|;
assert|assert
name|nextWriteLoc
operator|<=
name|waiting
operator|.
name|length
assert|;
if|if
condition|(
name|nextWriteLoc
operator|==
name|waiting
operator|.
name|length
condition|)
block|{
name|nextWriteLoc
operator|=
literal|0
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|setAborting
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|add
specifier|synchronized
specifier|public
name|boolean
name|add
parameter_list|(
name|DocWriter
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|doc
operator|.
name|docID
operator|>=
name|nextWriteDocID
assert|;
if|if
condition|(
name|doc
operator|.
name|docID
operator|==
name|nextWriteDocID
condition|)
block|{
name|writeDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|doc
operator|=
name|waiting
index|[
name|nextWriteLoc
index|]
expr_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|numWaiting
operator|--
expr_stmt|;
name|waiting
index|[
name|nextWriteLoc
index|]
operator|=
literal|null
expr_stmt|;
name|waitingBytes
operator|-=
name|doc
operator|.
name|sizeInBytes
argument_list|()
expr_stmt|;
name|writeDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
else|else
block|{
comment|// I finished before documents that were added
comment|// before me.  This can easily happen when I am a
comment|// small doc and the docs before me were large, or,
comment|// just due to luck in the thread scheduling.  Just
comment|// add myself to the queue and when that large doc
comment|// finishes, it will flush me:
name|int
name|gap
init|=
name|doc
operator|.
name|docID
operator|-
name|nextWriteDocID
decl_stmt|;
if|if
condition|(
name|gap
operator|>=
name|waiting
operator|.
name|length
condition|)
block|{
comment|// Grow queue
name|DocWriter
index|[]
name|newArray
init|=
operator|new
name|DocWriter
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|gap
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
assert|assert
name|nextWriteLoc
operator|>=
literal|0
assert|;
name|System
operator|.
name|arraycopy
argument_list|(
name|waiting
argument_list|,
name|nextWriteLoc
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|waiting
operator|.
name|length
operator|-
name|nextWriteLoc
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|waiting
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
name|waiting
operator|.
name|length
operator|-
name|nextWriteLoc
argument_list|,
name|nextWriteLoc
argument_list|)
expr_stmt|;
name|nextWriteLoc
operator|=
literal|0
expr_stmt|;
name|waiting
operator|=
name|newArray
expr_stmt|;
name|gap
operator|=
name|doc
operator|.
name|docID
operator|-
name|nextWriteDocID
expr_stmt|;
block|}
name|int
name|loc
init|=
name|nextWriteLoc
operator|+
name|gap
decl_stmt|;
if|if
condition|(
name|loc
operator|>=
name|waiting
operator|.
name|length
condition|)
block|{
name|loc
operator|-=
name|waiting
operator|.
name|length
expr_stmt|;
block|}
comment|// We should only wrap one time
assert|assert
name|loc
operator|<
name|waiting
operator|.
name|length
assert|;
comment|// Nobody should be in my spot!
assert|assert
name|waiting
index|[
name|loc
index|]
operator|==
literal|null
assert|;
name|waiting
index|[
name|loc
index|]
operator|=
name|doc
expr_stmt|;
name|numWaiting
operator|++
expr_stmt|;
name|waitingBytes
operator|+=
name|doc
operator|.
name|sizeInBytes
argument_list|()
expr_stmt|;
block|}
return|return
name|doPause
argument_list|()
return|;
block|}
block|}
block|}
end_class
end_unit
