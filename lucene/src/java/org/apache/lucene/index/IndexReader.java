begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|DocumentStoredFieldVisitor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|CodecProvider
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|PerDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|values
operator|.
name|IndexDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FieldCache
import|;
end_import
begin_comment
comment|// javadocs
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ReaderUtil
import|;
end_import
begin_comment
comment|// for javadocs
end_comment
begin_comment
comment|/** IndexReader is an abstract class, providing an interface for accessing an  index.  Search of an index is done entirely through this abstract interface,  so that any subclass which implements it is searchable.<p> Concrete subclasses of IndexReader are usually constructed with a call to  one of the static<code>open()</code> methods, e.g. {@link  #open(Directory, boolean)}.<p> For efficiency, in this API documents are often referred to via<i>document numbers</i>, non-negative integers which each name a unique  document in the index.  These document numbers are ephemeral--they may change  as documents are added to and deleted from an index.  Clients should thus not  rely on a given document having the same number between sessions.<p> An IndexReader can be opened on a directory for which an IndexWriter is  opened already, but it cannot be used to delete documents from the index then.<p><b>NOTE</b>: for backwards API compatibility, several methods are not listed   as abstract, but have no useful implementations in this base class and   instead always throw UnsupportedOperationException.  Subclasses are   strongly encouraged to override these methods, but in many cases may not   need to.</p><p><b>NOTE</b>: as of 2.4, it's possible to open a read-only  IndexReader using the static open methods that accept the   boolean readOnly parameter.  Such a reader may have better   concurrency.  You must specify false if you want to   make changes with the resulting IndexReader.</p><a name="thread-safety"></a><p><b>NOTE</b>: {@link  IndexReader} instances are completely thread  safe, meaning multiple threads can call any of its methods,  concurrently.  If your application requires external  synchronization, you should<b>not</b> synchronize on the<code>IndexReader</code> instance; use your own  (non-Lucene) objects instead. */
end_comment
begin_class
DECL|class|IndexReader
specifier|public
specifier|abstract
class|class
name|IndexReader
implements|implements
name|Cloneable
implements|,
name|Closeable
block|{
comment|/**    * A custom listener that's invoked when the IndexReader    * is finished.    *    *<p>For a SegmentReader, this listener is called only    * once all SegmentReaders sharing the same core are    * closed.  At this point it is safe for apps to evict    * this reader from any caches keyed on {@link    * #getCoreCacheKey}.  This is the same interface that    * {@link FieldCache} uses, internally, to evict    * entries.</p>    *    *<p>For other readers, this listener is called when they    * are closed.</p>    *    * @lucene.experimental    */
DECL|interface|ReaderFinishedListener
specifier|public
specifier|static
interface|interface
name|ReaderFinishedListener
block|{
DECL|method|finished
specifier|public
name|void
name|finished
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
function_decl|;
block|}
comment|// Impls must set this if they may call add/removeReaderFinishedListener:
DECL|field|readerFinishedListeners
specifier|protected
specifier|volatile
name|Collection
argument_list|<
name|ReaderFinishedListener
argument_list|>
name|readerFinishedListeners
decl_stmt|;
comment|/** Expert: adds a {@link ReaderFinishedListener}.  The    * provided listener is also added to any sub-readers, if    * this is a composite reader.  Also, any reader reopened    * or cloned from this one will also copy the listeners at    * the time of reopen.    *    * @lucene.experimental */
DECL|method|addReaderFinishedListener
specifier|public
name|void
name|addReaderFinishedListener
parameter_list|(
name|ReaderFinishedListener
name|listener
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|readerFinishedListeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|/** Expert: remove a previously added {@link ReaderFinishedListener}.    *    * @lucene.experimental */
DECL|method|removeReaderFinishedListener
specifier|public
name|void
name|removeReaderFinishedListener
parameter_list|(
name|ReaderFinishedListener
name|listener
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|readerFinishedListeners
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
DECL|method|notifyReaderFinishedListeners
specifier|protected
name|void
name|notifyReaderFinishedListeners
parameter_list|()
block|{
comment|// Defensive (should never be null -- all impls must set
comment|// this):
if|if
condition|(
name|readerFinishedListeners
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ReaderFinishedListener
name|listener
range|:
name|readerFinishedListeners
control|)
block|{
name|listener
operator|.
name|finished
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|readerFinished
specifier|protected
name|void
name|readerFinished
parameter_list|()
block|{
name|notifyReaderFinishedListeners
argument_list|()
expr_stmt|;
block|}
comment|/**    * Constants describing field properties, for example used for    * {@link IndexReader#getFieldNames(FieldOption)}.    */
DECL|enum|FieldOption
specifier|public
specifier|static
enum|enum
name|FieldOption
block|{
comment|/** All fields */
DECL|enum constant|ALL
name|ALL
block|,
comment|/** All indexed fields */
DECL|enum constant|INDEXED
name|INDEXED
block|,
comment|/** All fields that store payloads */
DECL|enum constant|STORES_PAYLOADS
name|STORES_PAYLOADS
block|,
comment|/** All fields that omit tf */
DECL|enum constant|OMIT_TERM_FREQ_AND_POSITIONS
name|OMIT_TERM_FREQ_AND_POSITIONS
block|,
comment|/** All fields that omit positions */
DECL|enum constant|OMIT_POSITIONS
name|OMIT_POSITIONS
block|,
comment|/** All fields which are not indexed */
DECL|enum constant|UNINDEXED
name|UNINDEXED
block|,
comment|/** All fields which are indexed with termvectors enabled */
DECL|enum constant|INDEXED_WITH_TERMVECTOR
name|INDEXED_WITH_TERMVECTOR
block|,
comment|/** All fields which are indexed but don't have termvectors enabled */
DECL|enum constant|INDEXED_NO_TERMVECTOR
name|INDEXED_NO_TERMVECTOR
block|,
comment|/** All fields with termvectors enabled. Please note that only standard termvector fields are returned */
DECL|enum constant|TERMVECTOR
name|TERMVECTOR
block|,
comment|/** All fields with termvectors with position values enabled */
DECL|enum constant|TERMVECTOR_WITH_POSITION
name|TERMVECTOR_WITH_POSITION
block|,
comment|/** All fields with termvectors with offset values enabled */
DECL|enum constant|TERMVECTOR_WITH_OFFSET
name|TERMVECTOR_WITH_OFFSET
block|,
comment|/** All fields with termvectors with offset values and position values enabled */
DECL|enum constant|TERMVECTOR_WITH_POSITION_OFFSET
name|TERMVECTOR_WITH_POSITION_OFFSET
block|,
comment|/** All fields holding doc values */
DECL|enum constant|DOC_VALUES
name|DOC_VALUES
block|}
DECL|field|closed
specifier|private
specifier|volatile
name|boolean
name|closed
decl_stmt|;
DECL|field|hasChanges
specifier|protected
name|boolean
name|hasChanges
decl_stmt|;
DECL|field|refCount
specifier|private
specifier|final
name|AtomicInteger
name|refCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|DEFAULT_TERMS_INDEX_DIVISOR
specifier|static
name|int
name|DEFAULT_TERMS_INDEX_DIVISOR
init|=
literal|1
decl_stmt|;
comment|/** Expert: returns the current refCount for this reader */
DECL|method|getRefCount
specifier|public
name|int
name|getRefCount
parameter_list|()
block|{
return|return
name|refCount
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Expert: increments the refCount of this IndexReader    * instance.  RefCounts are used to determine when a    * reader can be closed safely, i.e. as soon as there are    * no more references.  Be sure to always call a    * corresponding {@link #decRef}, in a finally clause;    * otherwise the reader may never be closed.  Note that    * {@link #close} simply calls decRef(), which means that    * the IndexReader will not really be closed until {@link    * #decRef} has been called for all outstanding    * references.    *    * @see #decRef    * @see #tryIncRef    */
DECL|method|incRef
specifier|public
name|void
name|incRef
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|refCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/**    * Expert: increments the refCount of this IndexReader    * instance only if the IndexReader has not been closed yet    * and returns<code>true</code> iff the refCount was    * successfully incremented, otherwise<code>false</code>.    * If this method returns<code>false</code> the reader is either    * already closed or is currently been closed. Either way this    * reader instance shouldn't be used by an application unless    *<code>true</code> is returned.    *<p>    * RefCounts are used to determine when a    * reader can be closed safely, i.e. as soon as there are    * no more references.  Be sure to always call a    * corresponding {@link #decRef}, in a finally clause;    * otherwise the reader may never be closed.  Note that    * {@link #close} simply calls decRef(), which means that    * the IndexReader will not really be closed until {@link    * #decRef} has been called for all outstanding    * references.    *    * @see #decRef    * @see #incRef    */
DECL|method|tryIncRef
specifier|public
name|boolean
name|tryIncRef
parameter_list|()
block|{
name|int
name|count
decl_stmt|;
while|while
condition|(
operator|(
name|count
operator|=
name|refCount
operator|.
name|get
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|refCount
operator|.
name|compareAndSet
argument_list|(
name|count
argument_list|,
name|count
operator|+
literal|1
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasChanges
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|.
name|append
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
specifier|final
name|IndexReader
index|[]
name|subReaders
init|=
name|getSequentialSubReaders
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|subReaders
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|subReaders
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|subReaders
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|subReaders
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|subReaders
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|buffer
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Expert: decreases the refCount of this IndexReader    * instance.  If the refCount drops to 0, then pending    * changes (if any) are committed to the index and this    * reader is closed.  If an exception is hit, the refCount    * is unchanged.    *    * @throws IOException in case an IOException occurs in commit() or doClose()    *    * @see #incRef    */
DECL|method|decRef
specifier|public
name|void
name|decRef
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
specifier|final
name|int
name|rc
init|=
name|refCount
operator|.
name|getAndDecrement
argument_list|()
decl_stmt|;
if|if
condition|(
name|rc
operator|==
literal|1
condition|)
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|commit
argument_list|()
expr_stmt|;
name|doClose
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// Put reference back on failure
name|refCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
name|readerFinished
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"too many decRef calls: refCount was "
operator|+
name|rc
operator|+
literal|" before decrement"
argument_list|)
throw|;
block|}
block|}
DECL|method|IndexReader
specifier|protected
name|IndexReader
parameter_list|()
block|{
name|refCount
operator|.
name|set
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * @throws AlreadyClosedException if this IndexReader is closed    */
DECL|method|ensureOpen
specifier|protected
specifier|final
name|void
name|ensureOpen
parameter_list|()
throws|throws
name|AlreadyClosedException
block|{
if|if
condition|(
name|refCount
operator|.
name|get
argument_list|()
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|AlreadyClosedException
argument_list|(
literal|"this IndexReader is closed"
argument_list|)
throw|;
block|}
block|}
comment|/** Returns a IndexReader reading the index in the given    *  Directory, with readOnly=true.    * @param directory the index directory    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|open
specifier|public
specifier|static
name|IndexReader
name|open
parameter_list|(
specifier|final
name|Directory
name|directory
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|directory
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|,
name|DEFAULT_TERMS_INDEX_DIVISOR
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Returns an IndexReader reading the index in the given    *  Directory.  You should pass readOnly=true, since it    *  gives much better concurrent performance, unless you    *  intend to do write operations (delete documents or    *  change norms) with the reader.    * @param directory the index directory    * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|open
specifier|public
specifier|static
name|IndexReader
name|open
parameter_list|(
specifier|final
name|Directory
name|directory
parameter_list|,
name|boolean
name|readOnly
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|directory
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|readOnly
argument_list|,
name|DEFAULT_TERMS_INDEX_DIVISOR
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Open a near real time IndexReader from the {@link org.apache.lucene.index.IndexWriter}.    *    * @param writer The IndexWriter to open from    * @param applyAllDeletes If true, all buffered deletes will    * be applied (made visible) in the returned reader.  If    * false, the deletes are not applied but remain buffered    * (in IndexWriter) so that they will be applied in the    * future.  Applying deletes can be costly, so if your app    * can tolerate deleted documents being returned you might    * gain some performance by passing false.    * @return The new IndexReader    * @throws CorruptIndexException    * @throws IOException if there is a low-level IO error    *    * @see #openIfChanged(IndexReader,IndexWriter,boolean)    *    * @lucene.experimental    */
DECL|method|open
specifier|public
specifier|static
name|IndexReader
name|open
parameter_list|(
specifier|final
name|IndexWriter
name|writer
parameter_list|,
name|boolean
name|applyAllDeletes
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|writer
operator|.
name|getReader
argument_list|(
name|applyAllDeletes
argument_list|)
return|;
block|}
comment|/** Expert: returns an IndexReader reading the index in the given    *  {@link IndexCommit}.  You should pass readOnly=true, since it    *  gives much better concurrent performance, unless you    *  intend to do write operations (delete documents or    *  change norms) with the reader.    * @param commit the commit point to open    * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|open
specifier|public
specifier|static
name|IndexReader
name|open
parameter_list|(
specifier|final
name|IndexCommit
name|commit
parameter_list|,
name|boolean
name|readOnly
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|commit
operator|.
name|getDirectory
argument_list|()
argument_list|,
literal|null
argument_list|,
name|commit
argument_list|,
name|readOnly
argument_list|,
name|DEFAULT_TERMS_INDEX_DIVISOR
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Expert: returns an IndexReader reading the index in    *  the given Directory, with a custom {@link    *  IndexDeletionPolicy}.  You should pass readOnly=true,    *  since it gives much better concurrent performance,    *  unless you intend to do write operations (delete    *  documents or change norms) with the reader.    * @param directory the index directory    * @param deletionPolicy a custom deletion policy (only used    *  if you use this reader to perform deletes or to set    *  norms); see {@link IndexWriter} for details.    * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|open
specifier|public
specifier|static
name|IndexReader
name|open
parameter_list|(
specifier|final
name|Directory
name|directory
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|,
name|boolean
name|readOnly
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|directory
argument_list|,
name|deletionPolicy
argument_list|,
literal|null
argument_list|,
name|readOnly
argument_list|,
name|DEFAULT_TERMS_INDEX_DIVISOR
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Expert: returns an IndexReader reading the index in    *  the given Directory, with a custom {@link    *  IndexDeletionPolicy}.  You should pass readOnly=true,    *  since it gives much better concurrent performance,    *  unless you intend to do write operations (delete    *  documents or change norms) with the reader.    * @param directory the index directory    * @param deletionPolicy a custom deletion policy (only used    *  if you use this reader to perform deletes or to set    *  norms); see {@link IndexWriter} for details.    * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader    * @param termInfosIndexDivisor Subsamples which indexed    *  terms are loaded into RAM. This has the same effect as {@link    *  IndexWriterConfig#setTermIndexInterval} except that setting    *  must be done at indexing time while this setting can be    *  set per reader.  When set to N, then one in every    *  N*termIndexInterval terms in the index is loaded into    *  memory.  By setting this to a value> 1 you can reduce    *  memory usage, at the expense of higher latency when    *  loading a TermInfo.  The default value is 1.  Set this    *  to -1 to skip loading the terms index entirely.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|open
specifier|public
specifier|static
name|IndexReader
name|open
parameter_list|(
specifier|final
name|Directory
name|directory
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|,
name|boolean
name|readOnly
parameter_list|,
name|int
name|termInfosIndexDivisor
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|directory
argument_list|,
name|deletionPolicy
argument_list|,
literal|null
argument_list|,
name|readOnly
argument_list|,
name|termInfosIndexDivisor
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Expert: returns an IndexReader reading the index in    *  the given Directory, using a specific commit and with    *  a custom {@link IndexDeletionPolicy}.  You should pass    *  readOnly=true, since it gives much better concurrent    *  performance, unless you intend to do write operations    *  (delete documents or change norms) with the reader.    * @param commit the specific {@link IndexCommit} to open;    * see {@link IndexReader#listCommits} to list all commits    * in a directory    * @param deletionPolicy a custom deletion policy (only used    *  if you use this reader to perform deletes or to set    *  norms); see {@link IndexWriter} for details.    * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|open
specifier|public
specifier|static
name|IndexReader
name|open
parameter_list|(
specifier|final
name|IndexCommit
name|commit
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|,
name|boolean
name|readOnly
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|commit
operator|.
name|getDirectory
argument_list|()
argument_list|,
name|deletionPolicy
argument_list|,
name|commit
argument_list|,
name|readOnly
argument_list|,
name|DEFAULT_TERMS_INDEX_DIVISOR
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Expert: returns an IndexReader reading the index in    *  the given Directory, using a specific commit and with    *  a custom {@link IndexDeletionPolicy}.  You should pass    *  readOnly=true, since it gives much better concurrent    *  performance, unless you intend to do write operations    *  (delete documents or change norms) with the reader.    * @param commit the specific {@link IndexCommit} to open;    * see {@link IndexReader#listCommits} to list all commits    * in a directory    * @param deletionPolicy a custom deletion policy (only used    *  if you use this reader to perform deletes or to set    *  norms); see {@link IndexWriter} for details.    * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader    * @param termInfosIndexDivisor Subsamples which indexed    *  terms are loaded into RAM. This has the same effect as {@link    *  IndexWriterConfig#setTermIndexInterval} except that setting    *  must be done at indexing time while this setting can be    *  set per reader.  When set to N, then one in every    *  N*termIndexInterval terms in the index is loaded into    *  memory.  By setting this to a value> 1 you can reduce    *  memory usage, at the expense of higher latency when    *  loading a TermInfo.  The default value is 1.  Set this    *  to -1 to skip loading the terms index entirely. This is only useful in     *  advanced situations when you will only .next() through all terms;     *  attempts to seek will hit an exception.    *      * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|open
specifier|public
specifier|static
name|IndexReader
name|open
parameter_list|(
specifier|final
name|IndexCommit
name|commit
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|,
name|boolean
name|readOnly
parameter_list|,
name|int
name|termInfosIndexDivisor
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|commit
operator|.
name|getDirectory
argument_list|()
argument_list|,
name|deletionPolicy
argument_list|,
name|commit
argument_list|,
name|readOnly
argument_list|,
name|termInfosIndexDivisor
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Expert: returns an IndexReader reading the index in    *  the given Directory, with a custom {@link    *  IndexDeletionPolicy}, and specified {@link CodecProvider}.    *  You should pass readOnly=true, since it gives much    *  better concurrent performance, unless you intend to do    *  write operations (delete documents or change norms)    *  with the reader.    * @param directory the index directory    * @param deletionPolicy a custom deletion policy (only used    *  if you use this reader to perform deletes or to set    *  norms); see {@link IndexWriter} for details.    * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader    * @param termInfosIndexDivisor Subsamples which indexed    *  terms are loaded into RAM. This has the same effect as {@link    *  IndexWriterConfig#setTermIndexInterval} except that setting    *  must be done at indexing time while this setting can be    *  set per reader.  When set to N, then one in every    *  N*termIndexInterval terms in the index is loaded into    *  memory.  By setting this to a value> 1 you can reduce    *  memory usage, at the expense of higher latency when    *  loading a TermInfo.  The default value is 1.  Set this    *  to -1 to skip loading the terms index entirely.    * @param codecs CodecProvider to use when opening index    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|open
specifier|public
specifier|static
name|IndexReader
name|open
parameter_list|(
specifier|final
name|Directory
name|directory
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|,
name|boolean
name|readOnly
parameter_list|,
name|int
name|termInfosIndexDivisor
parameter_list|,
name|CodecProvider
name|codecs
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|directory
argument_list|,
name|deletionPolicy
argument_list|,
literal|null
argument_list|,
name|readOnly
argument_list|,
name|termInfosIndexDivisor
argument_list|,
name|codecs
argument_list|)
return|;
block|}
comment|/** Expert: returns an IndexReader reading the index in    *  the given Directory, using a specific commit and with    *  a custom {@link IndexDeletionPolicy} and specified    *  {@link CodecProvider}.  You should pass readOnly=true, since    *  it gives much better concurrent performance, unless    *  you intend to do write operations (delete documents or    *  change norms) with the reader.     * @param commit the specific {@link IndexCommit} to open;    * see {@link IndexReader#listCommits} to list all commits    * in a directory    * @param deletionPolicy a custom deletion policy (only used    *  if you use this reader to perform deletes or to set    *  norms); see {@link IndexWriter} for details.    * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader    * @param termInfosIndexDivisor Subsamples which indexed    *  terms are loaded into RAM. This has the same effect as {@link    *  IndexWriterConfig#setTermIndexInterval} except that setting    *  must be done at indexing time while this setting can be    *  set per reader.  When set to N, then one in every    *  N*termIndexInterval terms in the index is loaded into    *  memory.  By setting this to a value> 1 you can reduce    *  memory usage, at the expense of higher latency when    *  loading a TermInfo.  The default value is 1.  Set this    *  to -1 to skip loading the terms index entirely.    * @param codecs CodecProvider to use when opening index    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|open
specifier|public
specifier|static
name|IndexReader
name|open
parameter_list|(
specifier|final
name|IndexCommit
name|commit
parameter_list|,
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|,
name|boolean
name|readOnly
parameter_list|,
name|int
name|termInfosIndexDivisor
parameter_list|,
name|CodecProvider
name|codecs
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|commit
operator|.
name|getDirectory
argument_list|()
argument_list|,
name|deletionPolicy
argument_list|,
name|commit
argument_list|,
name|readOnly
argument_list|,
name|termInfosIndexDivisor
argument_list|,
name|codecs
argument_list|)
return|;
block|}
DECL|method|open
specifier|private
specifier|static
name|IndexReader
name|open
parameter_list|(
specifier|final
name|Directory
name|directory
parameter_list|,
specifier|final
name|IndexDeletionPolicy
name|deletionPolicy
parameter_list|,
specifier|final
name|IndexCommit
name|commit
parameter_list|,
specifier|final
name|boolean
name|readOnly
parameter_list|,
name|int
name|termInfosIndexDivisor
parameter_list|,
name|CodecProvider
name|codecs
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
if|if
condition|(
name|codecs
operator|==
literal|null
condition|)
block|{
name|codecs
operator|=
name|CodecProvider
operator|.
name|getDefault
argument_list|()
expr_stmt|;
block|}
return|return
name|DirectoryReader
operator|.
name|open
argument_list|(
name|directory
argument_list|,
name|deletionPolicy
argument_list|,
name|commit
argument_list|,
name|readOnly
argument_list|,
name|termInfosIndexDivisor
argument_list|,
name|codecs
argument_list|)
return|;
block|}
comment|/**    * If the index has changed since the provided reader was    * opened, open and return a new reader; else, return    * null.  The new reader, if not null, will be the same    * type of reader as the previous one, ie an NRT reader    * will open a new NRT reader, a MultiReader will open a    * new MultiReader,  etc.    *    *<p>This method is typically far less costly than opening a    * fully new<code>IndexReader</code> as it shares    * resources (for example sub-readers) with the provided    *<code>IndexReader</code>, when possible.    *    *<p>The provided reader is not closed (you are responsible    * for doing so); if a new reader is returned you also    * must eventually close it.  Be sure to never close a    * reader while other threads are still using it; see    *<code>SearcherManager</code> in    *<code>contrib/misc</code> to simplify managing this.    *    *<p>If a new reader is returned, it's safe to make changes    * (deletions, norms) with it.  All shared mutable state    * with the old reader uses "copy on write" semantics to    * ensure the changes are not seen by other readers.    *    *<p><b>NOTE</b>: If the provided reader is a near real-time    * reader, this method will return another near-real-time    * reader.    *     * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    * @return null if there are no changes; else, a new    * IndexReader instance which you must eventually close    */
DECL|method|openIfChanged
specifier|public
specifier|static
name|IndexReader
name|openIfChanged
parameter_list|(
name|IndexReader
name|oldReader
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|oldReader
operator|.
name|doOpenIfChanged
argument_list|()
return|;
block|}
comment|/**    * If the index has changed since the provided reader was    * opened, open and return a new reader, with the    * specified<code>readOnly</code>; else, return    * null.    *    * @see #openIfChanged(IndexReader)    */
DECL|method|openIfChanged
specifier|public
specifier|static
name|IndexReader
name|openIfChanged
parameter_list|(
name|IndexReader
name|oldReader
parameter_list|,
name|boolean
name|readOnly
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|oldReader
operator|.
name|doOpenIfChanged
argument_list|(
name|readOnly
argument_list|)
return|;
block|}
comment|/**    * If the IndexCommit differs from what the    * provided reader is searching, or the provided reader is    * not already read-only, open and return a new    *<code>readOnly=true</code> reader; else, return null.    *    * @see #openIfChanged(IndexReader)    */
comment|// TODO: should you be able to specify readOnly?
DECL|method|openIfChanged
specifier|public
specifier|static
name|IndexReader
name|openIfChanged
parameter_list|(
name|IndexReader
name|oldReader
parameter_list|,
name|IndexCommit
name|commit
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|oldReader
operator|.
name|doOpenIfChanged
argument_list|(
name|commit
argument_list|)
return|;
block|}
comment|/**    * Expert: If there changes (committed or not) in the    * {@link IndexWriter} versus what the provided reader is    * searching, then open and return a new read-only    * IndexReader searching both committed and uncommitted    * changes from the writer; else, return null (though, the    * current implementation never returns null).    *    *<p>This provides "near real-time" searching, in that    * changes made during an {@link IndexWriter} session can be    * quickly made available for searching without closing    * the writer nor calling {@link #commit}.    *    *<p>It's<i>near</i> real-time because there is no hard    * guarantee on how quickly you can get a new reader after    * making changes with IndexWriter.  You'll have to    * experiment in your situation to determine if it's    * fast enough.  As this is a new and experimental    * feature, please report back on your findings so we can    * learn, improve and iterate.</p>    *    *<p>The very first time this method is called, this    * writer instance will make every effort to pool the    * readers that it opens for doing merges, applying    * deletes, etc.  This means additional resources (RAM,    * file descriptors, CPU time) will be consumed.</p>    *    *<p>For lower latency on reopening a reader, you should    * call {@link IndexWriterConfig#setMergedSegmentWarmer} to    * pre-warm a newly merged segment before it's committed    * to the index.  This is important for minimizing    * index-to-search delay after a large merge.</p>    *    *<p>If an addIndexes* call is running in another thread,    * then this reader will only search those segments from    * the foreign index that have been successfully copied    * over, so far.</p>    *    *<p><b>NOTE</b>: Once the writer is closed, any    * outstanding readers may continue to be used.  However,    * if you attempt to reopen any of those readers, you'll    * hit an {@link AlreadyClosedException}.</p>    *    * @return IndexReader that covers entire index plus all    * changes made so far by this IndexWriter instance, or    * null if there are no new changes    *    * @param writer The IndexWriter to open from    *    * @param applyAllDeletes If true, all buffered deletes will    * be applied (made visible) in the returned reader.  If    * false, the deletes are not applied but remain buffered    * (in IndexWriter) so that they will be applied in the    * future.  Applying deletes can be costly, so if your app    * can tolerate deleted documents being returned you might    * gain some performance by passing false.    *    * @throws IOException    *    * @lucene.experimental    */
DECL|method|openIfChanged
specifier|public
specifier|static
name|IndexReader
name|openIfChanged
parameter_list|(
name|IndexReader
name|oldReader
parameter_list|,
name|IndexWriter
name|writer
parameter_list|,
name|boolean
name|applyAllDeletes
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|oldReader
operator|.
name|doOpenIfChanged
argument_list|(
name|writer
argument_list|,
name|applyAllDeletes
argument_list|)
return|;
block|}
DECL|method|doOpenIfChanged
specifier|protected
name|IndexReader
name|doOpenIfChanged
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This reader does not support reopen()."
argument_list|)
throw|;
block|}
DECL|method|doOpenIfChanged
specifier|protected
name|IndexReader
name|doOpenIfChanged
parameter_list|(
name|boolean
name|openReadOnly
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This reader does not support reopen()."
argument_list|)
throw|;
block|}
DECL|method|doOpenIfChanged
specifier|protected
name|IndexReader
name|doOpenIfChanged
parameter_list|(
specifier|final
name|IndexCommit
name|commit
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This reader does not support reopen(IndexCommit)."
argument_list|)
throw|;
block|}
DECL|method|doOpenIfChanged
specifier|protected
name|IndexReader
name|doOpenIfChanged
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|boolean
name|applyAllDeletes
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|writer
operator|.
name|getReader
argument_list|(
name|applyAllDeletes
argument_list|)
return|;
block|}
comment|/**    * Efficiently clones the IndexReader (sharing most    * internal state).    *<p>    * On cloning a reader with pending changes (deletions,    * norms), the original reader transfers its write lock to    * the cloned reader.  This means only the cloned reader    * may make further changes to the index, and commit the    * changes to the index on close, but the old reader still    * reflects all changes made up until it was cloned.    *<p>    * Like {@link #openIfChanged(IndexReader)}, it's safe to make changes to    * either the original or the cloned reader: all shared    * mutable state obeys "copy on write" semantics to ensure    * the changes are not seen by other readers.    *<p>    */
annotation|@
name|Override
DECL|method|clone
specifier|public
specifier|synchronized
name|Object
name|clone
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This reader does not implement clone()"
argument_list|)
throw|;
block|}
comment|/**    * Clones the IndexReader and optionally changes readOnly.  A readOnly     * reader cannot open a writeable reader.      * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|clone
specifier|public
specifier|synchronized
name|IndexReader
name|clone
parameter_list|(
name|boolean
name|openReadOnly
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This reader does not implement clone()"
argument_list|)
throw|;
block|}
comment|/**     * Returns the directory associated with this index.  The Default     * implementation returns the directory specified by subclasses when     * delegating to the IndexReader(Directory) constructor, or throws an     * UnsupportedOperationException if one was not specified.    * @throws UnsupportedOperationException if no directory    */
DECL|method|directory
specifier|public
name|Directory
name|directory
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This reader does not support this method."
argument_list|)
throw|;
block|}
comment|/**    * Returns the time the index in the named directory was last modified.     * Do not use this to check whether the reader is still up-to-date, use    * {@link #isCurrent()} instead.     * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|lastModified
specifier|public
specifier|static
name|long
name|lastModified
parameter_list|(
specifier|final
name|Directory
name|directory2
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
operator|(
operator|(
name|Long
operator|)
operator|new
name|SegmentInfos
operator|.
name|FindSegmentsFile
argument_list|(
name|directory2
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Object
name|doBody
parameter_list|(
name|String
name|segmentFileName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|Long
operator|.
name|valueOf
argument_list|(
name|directory2
operator|.
name|fileModified
argument_list|(
name|segmentFileName
argument_list|)
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|()
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
comment|/**    * Reads version number from segments files. The version number is    * initialized with a timestamp and then increased by one for each change of    * the index.    *     * @param directory where the index resides.    * @return version number.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|getCurrentVersion
specifier|public
specifier|static
name|long
name|getCurrentVersion
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|getCurrentVersion
argument_list|(
name|directory
argument_list|,
name|CodecProvider
operator|.
name|getDefault
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Reads version number from segments files. The version number is    * initialized with a timestamp and then increased by one for each change of    * the index.    *     * @param directory where the index resides.    * @param codecs the {@link CodecProvider} holding all {@link Codec}s required to open the index    * @return version number.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|getCurrentVersion
specifier|public
specifier|static
name|long
name|getCurrentVersion
parameter_list|(
name|Directory
name|directory
parameter_list|,
name|CodecProvider
name|codecs
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|SegmentInfos
operator|.
name|readCurrentVersion
argument_list|(
name|directory
argument_list|,
name|codecs
argument_list|)
return|;
block|}
comment|/**    * Reads commitUserData, previously passed to {@link    * IndexWriter#commit(Map)}, from current index    * segments file.  This will return null if {@link    * IndexWriter#commit(Map)} has never been called for    * this index.    *     * @param directory where the index resides.    * @return commit userData.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    *    * @see #getCommitUserData()    */
DECL|method|getCommitUserData
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getCommitUserData
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|getCommitUserData
argument_list|(
name|directory
argument_list|,
name|CodecProvider
operator|.
name|getDefault
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Reads commitUserData, previously passed to {@link    * IndexWriter#commit(Map)}, from current index    * segments file.  This will return null if {@link    * IndexWriter#commit(Map)} has never been called for    * this index.    *     * @param directory where the index resides.    * @param codecs the {@link CodecProvider} provider holding all {@link Codec}s required to open the index    * @return commit userData.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    *    * @see #getCommitUserData()    */
DECL|method|getCommitUserData
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getCommitUserData
parameter_list|(
name|Directory
name|directory
parameter_list|,
name|CodecProvider
name|codecs
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|SegmentInfos
operator|.
name|readCurrentUserData
argument_list|(
name|directory
argument_list|,
name|codecs
argument_list|)
return|;
block|}
comment|/**    * Version number when this IndexReader was opened. Not    * implemented in the IndexReader base class.    *    *<p>If this reader is based on a Directory (ie, was    * created by calling {@link #open}, or {@link #openIfChanged} on    * a reader based on a Directory), then this method    * returns the version recorded in the commit that the    * reader opened.  This version is advanced every time    * {@link IndexWriter#commit} is called.</p>    *    *<p>If instead this reader is a near real-time reader    * (ie, obtained by a call to {@link    * IndexWriter#getReader}, or by calling {@link #openIfChanged}    * on a near real-time reader), then this method returns    * the version of the last commit done by the writer.    * Note that even as further changes are made with the    * writer, the version will not changed until a commit is    * completed.  Thus, you should not rely on this method to    * determine when a near real-time reader should be    * opened.  Use {@link #isCurrent} instead.</p>    *    * @throws UnsupportedOperationException unless overridden in subclass    */
DECL|method|getVersion
specifier|public
name|long
name|getVersion
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This reader does not support this method."
argument_list|)
throw|;
block|}
comment|/**    * Retrieve the String userData optionally passed to    * IndexWriter#commit.  This will return null if {@link    * IndexWriter#commit(Map)} has never been called for    * this index.    *    * @see #getCommitUserData(Directory)    */
DECL|method|getCommitUserData
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getCommitUserData
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This reader does not support this method."
argument_list|)
throw|;
block|}
comment|/**    * Check whether any new changes have occurred to the    * index since this reader was opened.    *    *<p>If this reader is based on a Directory (ie, was    * created by calling {@link #open}, or {@link #openIfChanged} on    * a reader based on a Directory), then this method checks    * if any further commits (see {@link IndexWriter#commit}    * have occurred in that directory).</p>    *    *<p>If instead this reader is a near real-time reader    * (ie, obtained by a call to {@link    * IndexWriter#getReader}, or by calling {@link #openIfChanged}    * on a near real-time reader), then this method checks if    * either a new commmit has occurred, or any new    * uncommitted changes have taken place via the writer.    * Note that even if the writer has only performed    * merging, this method will still return false.</p>    *    *<p>In any event, if this returns false, you should call    * {@link #openIfChanged} to get a new reader that sees the    * changes.</p>    *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException           if there is a low-level IO error    * @throws UnsupportedOperationException unless overridden in subclass    */
DECL|method|isCurrent
specifier|public
name|boolean
name|isCurrent
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This reader does not support this method."
argument_list|)
throw|;
block|}
comment|/**    * Checks is the index is optimized (if it has a single segment and     * no deletions).  Not implemented in the IndexReader base class.    * @return<code>true</code> if the index is optimized;<code>false</code> otherwise    * @throws UnsupportedOperationException unless overridden in subclass    */
DECL|method|isOptimized
specifier|public
name|boolean
name|isOptimized
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This reader does not support this method."
argument_list|)
throw|;
block|}
comment|/**    * Return an array of term frequency vectors for the specified document.    * The array contains a vector for each vectorized field in the document.    * Each vector contains terms and frequencies for all terms in a given vectorized field.    * If no such fields existed, the method returns null. The term vectors that are    * returned may either be of type {@link TermFreqVector}    * or of type {@link TermPositionVector} if    * positions or offsets have been stored.    *     * @param docNumber document for which term frequency vectors are returned    * @return array of term frequency vectors. May be null if no term vectors have been    *  stored for the specified document.    * @throws IOException if index cannot be accessed    */
DECL|method|getTermFreqVectors
specifier|abstract
specifier|public
name|TermFreqVector
index|[]
name|getTermFreqVectors
parameter_list|(
name|int
name|docNumber
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Return a term frequency vector for the specified document and field. The    * returned vector contains terms and frequencies for the terms in    * the specified field of this document, if the field had the storeTermVector    * flag set. If termvectors had been stored with positions or offsets, a     * {@link TermPositionVector} is returned.    *     * @param docNumber document for which the term frequency vector is returned    * @param field field for which the term frequency vector is returned.    * @return term frequency vector May be null if field does not exist in the specified    * document or term vector was not stored.    * @throws IOException if index cannot be accessed    */
DECL|method|getTermFreqVector
specifier|abstract
specifier|public
name|TermFreqVector
name|getTermFreqVector
parameter_list|(
name|int
name|docNumber
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Load the Term Vector into a user-defined data structure instead of relying on the parallel arrays of    * the {@link TermFreqVector}.    * @param docNumber The number of the document to load the vector for    * @param field The name of the field to load    * @param mapper The {@link TermVectorMapper} to process the vector.  Must not be null    * @throws IOException if term vectors cannot be accessed or if they do not exist on the field and doc. specified.    *     */
DECL|method|getTermFreqVector
specifier|abstract
specifier|public
name|void
name|getTermFreqVector
parameter_list|(
name|int
name|docNumber
parameter_list|,
name|String
name|field
parameter_list|,
name|TermVectorMapper
name|mapper
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Map all the term vectors for all fields in a Document    * @param docNumber The number of the document to load the vector for    * @param mapper The {@link TermVectorMapper} to process the vector.  Must not be null    * @throws IOException if term vectors cannot be accessed or if they do not exist on the field and doc. specified.    */
DECL|method|getTermFreqVector
specifier|abstract
specifier|public
name|void
name|getTermFreqVector
parameter_list|(
name|int
name|docNumber
parameter_list|,
name|TermVectorMapper
name|mapper
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Returns<code>true</code> if an index exists at the specified directory.    * @param  directory the directory to check for an index    * @return<code>true</code> if an index exists;<code>false</code> otherwise    * @throws IOException if there is a problem with accessing the index    */
DECL|method|indexExists
specifier|public
specifier|static
name|boolean
name|indexExists
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
operator|new
name|SegmentInfos
argument_list|()
operator|.
name|read
argument_list|(
name|directory
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Returns<code>true</code> if an index exists at the specified directory.    * @param  directory the directory to check for an index    * @param  codecProvider provides a CodecProvider in case the index uses non-core codecs    * @return<code>true</code> if an index exists;<code>false</code> otherwise    * @throws IOException if there is a problem with accessing the index    */
DECL|method|indexExists
specifier|public
specifier|static
name|boolean
name|indexExists
parameter_list|(
name|Directory
name|directory
parameter_list|,
name|CodecProvider
name|codecProvider
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
operator|new
name|SegmentInfos
argument_list|()
operator|.
name|read
argument_list|(
name|directory
argument_list|,
name|codecProvider
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/** Returns the number of documents in this index. */
DECL|method|numDocs
specifier|public
specifier|abstract
name|int
name|numDocs
parameter_list|()
function_decl|;
comment|/** Returns one greater than the largest possible document number.    * This may be used to, e.g., determine how big to allocate an array which    * will have an element for every document number in an index.    */
DECL|method|maxDoc
specifier|public
specifier|abstract
name|int
name|maxDoc
parameter_list|()
function_decl|;
comment|/** Returns the number of deleted documents. */
DECL|method|numDeletedDocs
specifier|public
name|int
name|numDeletedDocs
parameter_list|()
block|{
return|return
name|maxDoc
argument_list|()
operator|-
name|numDocs
argument_list|()
return|;
block|}
comment|/** Expert: visits the fields of a stored document, for    *  custom processing/loading of each field.  If you    *  simply want to load all fields, use {@link    *  #document(int)}.  If you want to load a subset, use    *  {@link DocumentStoredFieldVisitor}.  */
DECL|method|document
specifier|public
specifier|abstract
name|void
name|document
parameter_list|(
name|int
name|docID
parameter_list|,
name|StoredFieldVisitor
name|visitor
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
function_decl|;
comment|/**    * Returns the stored fields of the<code>n</code><sup>th</sup>    *<code>Document</code> in this index.  This is just    * sugar for using {@link DocumentStoredFieldVisitor}.    *<p>    *<b>NOTE:</b> for performance reasons, this method does not check if the    * requested document is deleted, and therefore asking for a deleted document    * may yield unspecified results. Usually this is not required, however you    * can test if the doc is deleted by checking the {@link    * Bits} returned from {@link MultiFields#getLiveDocs}.    *    *<b>NOTE:</b> only the content of a field is returned,    * if that field was stored during indexing.  Metadata    * like boost, omitNorm, IndexOptions, tokenized, etc.,    * are not preserved.    *     * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
comment|// TODO: we need a separate StoredField, so that the
comment|// Document returned here contains that class not
comment|// IndexableField
DECL|method|document
specifier|public
name|Document
name|document
parameter_list|(
name|int
name|docID
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|docID
operator|<
literal|0
operator|||
name|docID
operator|>=
name|maxDoc
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"docID must be>= 0 and< maxDoc="
operator|+
name|maxDoc
argument_list|()
operator|+
literal|" (got docID="
operator|+
name|docID
operator|+
literal|")"
argument_list|)
throw|;
block|}
specifier|final
name|DocumentStoredFieldVisitor
name|visitor
init|=
operator|new
name|DocumentStoredFieldVisitor
argument_list|()
decl_stmt|;
name|document
argument_list|(
name|docID
argument_list|,
name|visitor
argument_list|)
expr_stmt|;
return|return
name|visitor
operator|.
name|getDocument
argument_list|()
return|;
block|}
comment|/** Returns true if any documents have been deleted */
DECL|method|hasDeletions
specifier|public
specifier|abstract
name|boolean
name|hasDeletions
parameter_list|()
function_decl|;
comment|/** Returns true if there are norms stored for this field. */
DECL|method|hasNorms
specifier|public
name|boolean
name|hasNorms
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
comment|// backward compatible implementation.
comment|// SegmentReader has an efficient implementation.
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|norms
argument_list|(
name|field
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/** Returns the byte-encoded normalization factor for the named field of    *  every document.  This is used by the search code to score documents.    *  Returns null if norms were not indexed for this field.    *    * @see org.apache.lucene.document.Field#setBoost(float)    */
DECL|method|norms
specifier|public
specifier|abstract
name|byte
index|[]
name|norms
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Expert: Resets the normalization factor for the named field of the named    * document.  By default, the norm represents the product of the field's {@link    * org.apache.lucene.document.Field#setBoost(float) boost} and its    * length normalization}.  Thus, to preserve the length normalization    * values when resetting this, one should base the new value upon the old.    *    *<b>NOTE:</b> If this field does not index norms, then    * this method throws {@link IllegalStateException}.    *    * @see #norms(String)    * @see Similarity#computeNorm(FieldInvertState)    * @see org.apache.lucene.search.similarities.DefaultSimilarity#decodeNormValue(byte)    * @throws StaleReaderException if the index has changed    *  since this reader was opened    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if there is a low-level IO error    * @throws IllegalStateException if the field does not index norms    */
DECL|method|setNorm
specifier|public
specifier|synchronized
name|void
name|setNorm
parameter_list|(
name|int
name|doc
parameter_list|,
name|String
name|field
parameter_list|,
name|byte
name|value
parameter_list|)
throws|throws
name|StaleReaderException
throws|,
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|acquireWriteLock
argument_list|()
expr_stmt|;
name|hasChanges
operator|=
literal|true
expr_stmt|;
name|doSetNorm
argument_list|(
name|doc
argument_list|,
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** Implements setNorm in subclass.*/
DECL|method|doSetNorm
specifier|protected
specifier|abstract
name|void
name|doSetNorm
parameter_list|(
name|int
name|doc
parameter_list|,
name|String
name|field
parameter_list|,
name|byte
name|value
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
function_decl|;
comment|/**    * Returns {@link Fields} for this reader.    * This method may return null if the reader has no    * postings.    *    *<p><b>NOTE</b>: if this is a multi reader ({@link    * #getSequentialSubReaders} is not null) then this    * method will throw UnsupportedOperationException.  If    * you really need a {@link Fields} for such a reader,    * use {@link MultiFields#getFields}.  However, for    * performance reasons, it's best to get all sub-readers    * using {@link ReaderUtil#gatherSubReaders} and iterate    * through them yourself. */
DECL|method|fields
specifier|public
specifier|abstract
name|Fields
name|fields
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * Returns {@link PerDocValues} for this reader.    * This method may return null if the reader has no per-document    * values stored.    *    *<p><b>NOTE</b>: if this is a multi reader ({@link    * #getSequentialSubReaders} is not null) then this    * method will throw UnsupportedOperationException.  If    * you really need {@link PerDocValues} for such a reader,    * use {@link MultiPerDocValues#getPerDocs(IndexReader)}.  However, for    * performance reasons, it's best to get all sub-readers    * using {@link ReaderUtil#gatherSubReaders} and iterate    * through them yourself. */
DECL|method|perDocValues
specifier|public
specifier|abstract
name|PerDocValues
name|perDocValues
parameter_list|()
throws|throws
name|IOException
function_decl|;
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|(
name|Term
name|term
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|docFreq
argument_list|(
name|term
operator|.
name|field
argument_list|()
argument_list|,
name|term
operator|.
name|bytes
argument_list|()
argument_list|)
return|;
block|}
comment|/** Returns the number of documents containing the term    *<code>t</code>.  This method returns 0 if the term or    * field does not exists.  This method does not take into    * account deleted documents that have not yet been merged    * away. */
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|(
name|String
name|field
parameter_list|,
name|BytesRef
name|term
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Fields
name|fields
init|=
name|fields
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
specifier|final
name|Terms
name|terms
init|=
name|fields
operator|.
name|terms
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|terms
operator|.
name|docFreq
argument_list|(
name|term
argument_list|)
return|;
block|}
comment|/** Returns the number of documents containing the term    *<code>t</code>.  This method returns 0 if the term or    * field does not exists.  This method does not take into    * account deleted documents that have not yet been merged    * away. */
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|(
name|String
name|field
parameter_list|,
name|BytesRef
name|term
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Fields
name|fields
init|=
name|fields
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
specifier|final
name|Terms
name|terms
init|=
name|fields
operator|.
name|terms
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|terms
operator|.
name|totalTermFreq
argument_list|(
name|term
argument_list|)
return|;
block|}
comment|/** This may return null if the field does not exist.*/
DECL|method|terms
specifier|public
name|Terms
name|terms
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Fields
name|fields
init|=
name|fields
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|fields
operator|.
name|terms
argument_list|(
name|field
argument_list|)
return|;
block|}
comment|/** Returns {@link DocsEnum} for the specified field&    *  term.  This may return null, if either the field or    *  term does not exist. */
DECL|method|termDocsEnum
specifier|public
name|DocsEnum
name|termDocsEnum
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|String
name|field
parameter_list|,
name|BytesRef
name|term
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|field
operator|!=
literal|null
assert|;
assert|assert
name|term
operator|!=
literal|null
assert|;
specifier|final
name|Fields
name|fields
init|=
name|fields
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Terms
name|terms
init|=
name|fields
operator|.
name|terms
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|!=
literal|null
condition|)
block|{
return|return
name|terms
operator|.
name|docs
argument_list|(
name|liveDocs
argument_list|,
name|term
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/** Returns {@link DocsAndPositionsEnum} for the specified    *  field& term.  This may return null, if either the    *  field or term does not exist, or, positions were not    *  stored for this term. */
DECL|method|termPositionsEnum
specifier|public
name|DocsAndPositionsEnum
name|termPositionsEnum
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|String
name|field
parameter_list|,
name|BytesRef
name|term
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|field
operator|!=
literal|null
assert|;
assert|assert
name|term
operator|!=
literal|null
assert|;
specifier|final
name|Fields
name|fields
init|=
name|fields
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Terms
name|terms
init|=
name|fields
operator|.
name|terms
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|!=
literal|null
condition|)
block|{
return|return
name|terms
operator|.
name|docsAndPositions
argument_list|(
name|liveDocs
argument_list|,
name|term
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Returns {@link DocsEnum} for the specified field and    * {@link TermState}. This may return null, if either the field or the term    * does not exists or the {@link TermState} is invalid for the underlying    * implementation.*/
DECL|method|termDocsEnum
specifier|public
name|DocsEnum
name|termDocsEnum
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|String
name|field
parameter_list|,
name|BytesRef
name|term
parameter_list|,
name|TermState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|state
operator|!=
literal|null
assert|;
assert|assert
name|field
operator|!=
literal|null
assert|;
specifier|final
name|Fields
name|fields
init|=
name|fields
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Terms
name|terms
init|=
name|fields
operator|.
name|terms
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|!=
literal|null
condition|)
block|{
return|return
name|terms
operator|.
name|docs
argument_list|(
name|liveDocs
argument_list|,
name|term
argument_list|,
name|state
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Returns {@link DocsAndPositionsEnum} for the specified field and    * {@link TermState}. This may return null, if either the field or the term    * does not exists, the {@link TermState} is invalid for the underlying    * implementation, or positions were not stored for this term.*/
DECL|method|termPositionsEnum
specifier|public
name|DocsAndPositionsEnum
name|termPositionsEnum
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|String
name|field
parameter_list|,
name|BytesRef
name|term
parameter_list|,
name|TermState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|state
operator|!=
literal|null
assert|;
assert|assert
name|field
operator|!=
literal|null
assert|;
specifier|final
name|Fields
name|fields
init|=
name|fields
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Terms
name|terms
init|=
name|fields
operator|.
name|terms
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|!=
literal|null
condition|)
block|{
return|return
name|terms
operator|.
name|docsAndPositions
argument_list|(
name|liveDocs
argument_list|,
name|term
argument_list|,
name|state
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/** Deletes the document numbered<code>docNum</code>.  Once a document is    * deleted it will not appear in TermDocs or TermPositions enumerations.    * Attempts to read its field with the {@link #document}    * method will result in an error.  The presence of this document may still be    * reflected in the {@link #docFreq} statistic, though    * this will be corrected eventually as the index is further modified.    *    * @throws StaleReaderException if the index has changed    * since this reader was opened    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if there is a low-level IO error    */
DECL|method|deleteDocument
specifier|public
specifier|synchronized
name|void
name|deleteDocument
parameter_list|(
name|int
name|docNum
parameter_list|)
throws|throws
name|StaleReaderException
throws|,
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|acquireWriteLock
argument_list|()
expr_stmt|;
name|hasChanges
operator|=
literal|true
expr_stmt|;
name|doDelete
argument_list|(
name|docNum
argument_list|)
expr_stmt|;
block|}
comment|/** Implements deletion of the document numbered<code>docNum</code>.    * Applications should call {@link #deleteDocument(int)} or {@link #deleteDocuments(Term)}.    */
DECL|method|doDelete
specifier|protected
specifier|abstract
name|void
name|doDelete
parameter_list|(
name|int
name|docNum
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
function_decl|;
comment|/** Deletes all documents that have a given<code>term</code> indexed.    * This is useful if one uses a document field to hold a unique ID string for    * the document.  Then to delete such a document, one merely constructs a    * term with the appropriate field and the unique ID string as its text and    * passes it to this method.    * See {@link #deleteDocument(int)} for information about when this deletion will     * become effective.    *    * @return the number of documents deleted    * @throws StaleReaderException if the index has changed    *  since this reader was opened    * @throws CorruptIndexException if the index is corrupt    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws IOException if there is a low-level IO error    */
DECL|method|deleteDocuments
specifier|public
name|int
name|deleteDocuments
parameter_list|(
name|Term
name|term
parameter_list|)
throws|throws
name|StaleReaderException
throws|,
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|DocsEnum
name|docs
init|=
name|MultiFields
operator|.
name|getTermDocsEnum
argument_list|(
name|this
argument_list|,
name|MultiFields
operator|.
name|getLiveDocs
argument_list|(
name|this
argument_list|)
argument_list|,
name|term
operator|.
name|field
argument_list|()
argument_list|,
name|term
operator|.
name|bytes
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|docs
operator|==
literal|null
condition|)
return|return
literal|0
return|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|doc
decl_stmt|;
while|while
condition|(
operator|(
name|doc
operator|=
name|docs
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocsEnum
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|deleteDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
comment|/** Undeletes all documents currently marked as deleted in    * this index.    *    *<p>NOTE: this method can only recover documents marked    * for deletion but not yet removed from the index; when    * and how Lucene removes deleted documents is an    * implementation detail, subject to change from release    * to release.  However, you can use {@link    * #numDeletedDocs} on the current IndexReader instance to    * see how many documents will be un-deleted.    *    * @throws StaleReaderException if the index has changed    *  since this reader was opened    * @throws LockObtainFailedException if another writer    *  has this index open (<code>write.lock</code> could not    *  be obtained)    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|undeleteAll
specifier|public
specifier|synchronized
name|void
name|undeleteAll
parameter_list|()
throws|throws
name|StaleReaderException
throws|,
name|CorruptIndexException
throws|,
name|LockObtainFailedException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|acquireWriteLock
argument_list|()
expr_stmt|;
name|hasChanges
operator|=
literal|true
expr_stmt|;
name|doUndeleteAll
argument_list|()
expr_stmt|;
block|}
comment|/** Implements actual undeleteAll() in subclass. */
DECL|method|doUndeleteAll
specifier|protected
specifier|abstract
name|void
name|doUndeleteAll
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
function_decl|;
comment|/** Does nothing by default. Subclasses that require a write lock for    *  index modifications must implement this method. */
DECL|method|acquireWriteLock
specifier|protected
specifier|synchronized
name|void
name|acquireWriteLock
parameter_list|()
throws|throws
name|IOException
block|{
comment|/* NOOP */
block|}
comment|/**    *     * @throws IOException    */
DECL|method|flush
specifier|public
specifier|final
specifier|synchronized
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
block|}
comment|/**    * @param commitUserData Opaque Map (String -> String)    *  that's recorded into the segments file in the index,    *  and retrievable by {@link    *  IndexReader#getCommitUserData}.    * @throws IOException    */
DECL|method|flush
specifier|public
specifier|final
specifier|synchronized
name|void
name|flush
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commitUserData
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|commit
argument_list|(
name|commitUserData
argument_list|)
expr_stmt|;
block|}
comment|/**    * Commit changes resulting from delete, undeleteAll, or    * setNorm operations    *    * If an exception is hit, then either no changes or all    * changes will have been committed to the index    * (transactional semantics).    * @throws IOException if there is a low-level IO error    */
DECL|method|commit
specifier|protected
specifier|final
specifier|synchronized
name|void
name|commit
parameter_list|()
throws|throws
name|IOException
block|{
name|commit
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Commit changes resulting from delete, undeleteAll, or    * setNorm operations    *    * If an exception is hit, then either no changes or all    * changes will have been committed to the index    * (transactional semantics).    * @throws IOException if there is a low-level IO error    */
DECL|method|commit
specifier|public
specifier|final
specifier|synchronized
name|void
name|commit
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commitUserData
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Don't call ensureOpen since we commit() on close
name|doCommit
argument_list|(
name|commitUserData
argument_list|)
expr_stmt|;
name|hasChanges
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Implements commit.  */
DECL|method|doCommit
specifier|protected
specifier|abstract
name|void
name|doCommit
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commitUserData
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Closes files associated with this index.    * Also saves any new deletions to disk.    * No other methods should be called after this has been called.    * @throws IOException if there is a low-level IO error    */
DECL|method|close
specifier|public
specifier|final
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
name|decRef
argument_list|()
expr_stmt|;
name|closed
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/** Implements close. */
DECL|method|doClose
specifier|protected
specifier|abstract
name|void
name|doClose
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * Get a list of unique field names that exist in this index and have the specified    * field option information.    * @param fldOption specifies which field option should be available for the returned fields    * @return Collection of Strings indicating the names of the fields.    * @see IndexReader.FieldOption    */
DECL|method|getFieldNames
specifier|public
specifier|abstract
name|Collection
argument_list|<
name|String
argument_list|>
name|getFieldNames
parameter_list|(
name|FieldOption
name|fldOption
parameter_list|)
function_decl|;
comment|/** Returns the {@link Bits} representing live (not    *  deleted) docs.  A set bit indicates the doc ID has not    *  been deleted.  If this method returns null it means    *  there are no deleted documents (all documents are    *  live).    *    *  The returned instance has been safely published for    *  use by multiple threads without additional    *  synchronization.    * @lucene.experimental */
DECL|method|getLiveDocs
specifier|public
specifier|abstract
name|Bits
name|getLiveDocs
parameter_list|()
function_decl|;
comment|/**    * Expert: return the IndexCommit that this reader has    * opened.  This method is only implemented by those    * readers that correspond to a Directory with its own    * segments_N file.    *    * @lucene.experimental    */
DECL|method|getIndexCommit
specifier|public
name|IndexCommit
name|getIndexCommit
parameter_list|()
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This reader does not support this method."
argument_list|)
throw|;
block|}
comment|/**    * Prints the filename and size of each file within a given compound file.    * Add the -extract flag to extract files to the current working directory.    * In order to make the extracted version of the index work, you have to copy    * the segments file from the compound index into the directory where the extracted files are stored.    * @param args Usage: org.apache.lucene.index.IndexReader [-extract]&lt;cfsfile&gt;    */
DECL|method|main
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|String
name|filename
init|=
literal|null
decl_stmt|;
name|boolean
name|extract
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-extract"
argument_list|)
condition|)
block|{
name|extract
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filename
operator|==
literal|null
condition|)
block|{
name|filename
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|filename
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Usage: org.apache.lucene.index.IndexReader [-extract]<cfsfile>"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Directory
name|dir
init|=
literal|null
decl_stmt|;
name|CompoundFileDirectory
name|cfr
init|=
literal|null
decl_stmt|;
name|IOContext
name|context
init|=
name|IOContext
operator|.
name|READ
decl_stmt|;
try|try
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|String
name|dirname
init|=
name|file
operator|.
name|getAbsoluteFile
argument_list|()
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|filename
operator|=
name|file
operator|.
name|getName
argument_list|()
expr_stmt|;
name|dir
operator|=
name|FSDirectory
operator|.
name|open
argument_list|(
operator|new
name|File
argument_list|(
name|dirname
argument_list|)
argument_list|)
expr_stmt|;
name|cfr
operator|=
operator|new
name|CompoundFileDirectory
argument_list|(
name|dir
argument_list|,
name|filename
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|String
index|[]
name|files
init|=
name|cfr
operator|.
name|listAll
argument_list|()
decl_stmt|;
name|ArrayUtil
operator|.
name|mergeSort
argument_list|(
name|files
argument_list|)
expr_stmt|;
comment|// sort the array of filename so that the output is more readable
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|files
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|long
name|len
init|=
name|cfr
operator|.
name|fileLength
argument_list|(
name|files
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|extract
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"extract "
operator|+
name|files
index|[
name|i
index|]
operator|+
literal|" with "
operator|+
name|len
operator|+
literal|" bytes to local directory..."
argument_list|)
expr_stmt|;
name|IndexInput
name|ii
init|=
name|cfr
operator|.
name|openInput
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
name|context
argument_list|)
decl_stmt|;
name|FileOutputStream
name|f
init|=
operator|new
name|FileOutputStream
argument_list|(
name|files
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|// read and write with a small buffer, which is more effective than reading byte by byte
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|chunk
init|=
name|buffer
operator|.
name|length
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|bufLen
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|chunk
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|ii
operator|.
name|readBytes
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|bufLen
argument_list|)
expr_stmt|;
name|f
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|bufLen
argument_list|)
expr_stmt|;
name|len
operator|-=
name|bufLen
expr_stmt|;
block|}
name|f
operator|.
name|close
argument_list|()
expr_stmt|;
name|ii
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|files
index|[
name|i
index|]
operator|+
literal|": "
operator|+
name|len
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|ioe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
if|if
condition|(
name|dir
operator|!=
literal|null
condition|)
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|cfr
operator|!=
literal|null
condition|)
name|cfr
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|ioe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Returns all commit points that exist in the Directory.    *  Normally, because the default is {@link    *  KeepOnlyLastCommitDeletionPolicy}, there would be only    *  one commit point.  But if you're using a custom {@link    *  IndexDeletionPolicy} then there could be many commits.    *  Once you have a given commit, you can open a reader on    *  it by calling {@link IndexReader#open(IndexCommit,boolean)}    *  There must be at least one commit in    *  the Directory, else this method throws {@link    *  IndexNotFoundException}.  Note that if a commit is in    *  progress while this method is running, that commit    *  may or may not be returned.    *      *  @return a sorted list of {@link IndexCommit}s, from oldest     *  to latest. */
DECL|method|listCommits
specifier|public
specifier|static
name|List
argument_list|<
name|IndexCommit
argument_list|>
name|listCommits
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|DirectoryReader
operator|.
name|listCommits
argument_list|(
name|dir
argument_list|)
return|;
block|}
comment|/** Expert: returns the sequential sub readers that this    *  reader is logically composed of. If this reader is not composed    *  of sequential child readers, it should return null.    *  If this method returns an empty array, that means this    *  reader is a null reader (for example a MultiReader    *  that has no sub readers).    *<p>    *  NOTE: You should not try using sub-readers returned by    *  this method to make any changes (setNorm, deleteDocument,    *  etc.). While this might succeed for one composite reader    *  (like MultiReader), it will most likely lead to index    *  corruption for other readers (like DirectoryReader obtained    *  through {@link #open}. Use the parent reader directly. */
DECL|method|getSequentialSubReaders
specifier|public
name|IndexReader
index|[]
name|getSequentialSubReaders
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**    * Expert: Returns a the root {@link ReaderContext} for this    * {@link IndexReader}'s sub-reader tree. Iff this reader is composed of sub    * readers ,ie. this reader being a composite reader, this method returns a    * {@link CompositeReaderContext} holding the reader's direct children as well as a    * view of the reader tree's atomic leaf contexts. All sub-    * {@link ReaderContext} instances referenced from this readers top-level    * context are private to this reader and are not shared with another context    * tree. For example, IndexSearcher uses this API to drive searching by one    * atomic leaf reader at a time. If this reader is not composed of child    * readers, this method returns an {@link AtomicReaderContext}.    *<p>    * Note: Any of the sub-{@link CompositeReaderContext} instances reference from this    * top-level context holds a<code>null</code> {@link CompositeReaderContext#leaves}    * reference. Only the top-level context maintains the convenience leaf-view    * for performance reasons.    *<p>    * NOTE: You should not try using sub-readers returned by this method to make    * any changes (setNorm, deleteDocument, etc.). While this might succeed for    * one composite reader (like MultiReader), it will most likely lead to index    * corruption for other readers (like DirectoryReader obtained through    * {@link #open}. Use the top-level context's reader directly.    *     * @lucene.experimental    */
DECL|method|getTopReaderContext
specifier|public
specifier|abstract
name|ReaderContext
name|getTopReaderContext
parameter_list|()
function_decl|;
comment|/** Expert */
DECL|method|getCoreCacheKey
specifier|public
name|Object
name|getCoreCacheKey
parameter_list|()
block|{
comment|// Don't can ensureOpen since FC calls this (to evict)
comment|// on close
return|return
name|this
return|;
block|}
comment|/** Returns the number of unique terms (across all fields)    *  in this reader.    *    *  @throws UnsupportedOperationException if this count    *  cannot be easily determined (eg Multi*Readers).    *  Instead, you should call {@link    *  #getSequentialSubReaders} and ask each sub reader for    *  its unique term count. */
DECL|method|getUniqueTermCount
specifier|public
name|long
name|getUniqueTermCount
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|numTerms
init|=
literal|0
decl_stmt|;
specifier|final
name|Fields
name|fields
init|=
name|fields
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|FieldsEnum
name|it
init|=
name|fields
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|field
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|numTerms
operator|+=
name|fields
operator|.
name|terms
argument_list|(
name|field
argument_list|)
operator|.
name|getUniqueTermCount
argument_list|()
expr_stmt|;
block|}
return|return
name|numTerms
return|;
block|}
comment|/** For IndexReader implementations that use    *  TermInfosReader to read terms, this returns the    *  current indexDivisor as specified when the reader was    *  opened.    */
DECL|method|getTermInfosIndexDivisor
specifier|public
name|int
name|getTermInfosIndexDivisor
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This reader does not support this method."
argument_list|)
throw|;
block|}
DECL|method|docValues
specifier|public
specifier|final
name|IndexDocValues
name|docValues
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
specifier|final
name|PerDocValues
name|perDoc
init|=
name|perDocValues
argument_list|()
decl_stmt|;
if|if
condition|(
name|perDoc
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|perDoc
operator|.
name|docValues
argument_list|(
name|field
argument_list|)
return|;
block|}
DECL|field|fields
specifier|private
specifier|volatile
name|Fields
name|fields
decl_stmt|;
comment|/** @lucene.internal */
DECL|method|storeFields
name|void
name|storeFields
parameter_list|(
name|Fields
name|fields
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|fields
operator|=
name|fields
expr_stmt|;
block|}
comment|/** @lucene.internal */
DECL|method|retrieveFields
name|Fields
name|retrieveFields
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|fields
return|;
block|}
DECL|field|perDocValues
specifier|private
specifier|volatile
name|PerDocValues
name|perDocValues
decl_stmt|;
comment|/** @lucene.internal */
DECL|method|storePerDoc
name|void
name|storePerDoc
parameter_list|(
name|PerDocValues
name|perDocValues
parameter_list|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|perDocValues
operator|=
name|perDocValues
expr_stmt|;
block|}
comment|/** @lucene.internal */
DECL|method|retrievePerDoc
name|PerDocValues
name|retrievePerDoc
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|perDocValues
return|;
block|}
comment|/**    * A struct like class that represents a hierarchical relationship between    * {@link IndexReader} instances.     * @lucene.experimental    */
DECL|class|ReaderContext
specifier|public
specifier|static
specifier|abstract
class|class
name|ReaderContext
block|{
comment|/** The reader context for this reader's immediate parent, or null if none */
DECL|field|parent
specifier|public
specifier|final
name|ReaderContext
name|parent
decl_stmt|;
comment|/** The actual reader */
DECL|field|reader
specifier|public
specifier|final
name|IndexReader
name|reader
decl_stmt|;
comment|/**<code>true</code> iff the reader is an atomic reader */
DECL|field|isAtomic
specifier|public
specifier|final
name|boolean
name|isAtomic
decl_stmt|;
comment|/**<code>true</code> if this context struct represents the top level reader within the hierarchical context */
DECL|field|isTopLevel
specifier|public
specifier|final
name|boolean
name|isTopLevel
decl_stmt|;
comment|/** the doc base for this reader in the parent,<tt>0</tt> if parent is null */
DECL|field|docBaseInParent
specifier|public
specifier|final
name|int
name|docBaseInParent
decl_stmt|;
comment|/** the ord for this reader in the parent,<tt>0</tt> if parent is null */
DECL|field|ordInParent
specifier|public
specifier|final
name|int
name|ordInParent
decl_stmt|;
DECL|method|ReaderContext
name|ReaderContext
parameter_list|(
name|ReaderContext
name|parent
parameter_list|,
name|IndexReader
name|reader
parameter_list|,
name|boolean
name|isAtomic
parameter_list|,
name|int
name|ordInParent
parameter_list|,
name|int
name|docBaseInParent
parameter_list|)
block|{
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|reader
operator|=
name|reader
expr_stmt|;
name|this
operator|.
name|isAtomic
operator|=
name|isAtomic
expr_stmt|;
name|this
operator|.
name|docBaseInParent
operator|=
name|docBaseInParent
expr_stmt|;
name|this
operator|.
name|ordInParent
operator|=
name|ordInParent
expr_stmt|;
name|this
operator|.
name|isTopLevel
operator|=
name|parent
operator|==
literal|null
expr_stmt|;
block|}
comment|/**      * Returns the context's leaves if this context is a top-level context      * otherwise<code>null</code>.      *<p>      * Note: this is convenience method since leaves can always be obtained by      * walking the context tree.      */
DECL|method|leaves
specifier|public
name|AtomicReaderContext
index|[]
name|leaves
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**      * Returns the context's children iff this context is a composite context      * otherwise<code>null</code>.      *<p>      * Note: this method is a convenience method to prevent      *<code>instanceof</code> checks and type-casts to      * {@link CompositeReaderContext}.      */
DECL|method|children
specifier|public
name|ReaderContext
index|[]
name|children
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * {@link ReaderContext} for composite {@link IndexReader} instance.    * @lucene.experimental    */
DECL|class|CompositeReaderContext
specifier|public
specifier|static
specifier|final
class|class
name|CompositeReaderContext
extends|extends
name|ReaderContext
block|{
comment|/** the composite readers immediate children */
DECL|field|children
specifier|public
specifier|final
name|ReaderContext
index|[]
name|children
decl_stmt|;
comment|/** the composite readers leaf reader contexts if this is the top level reader in this context */
DECL|field|leaves
specifier|public
specifier|final
name|AtomicReaderContext
index|[]
name|leaves
decl_stmt|;
comment|/**      * Creates a {@link CompositeReaderContext} for intermediate readers that aren't      * not top-level readers in the current context      */
DECL|method|CompositeReaderContext
specifier|public
name|CompositeReaderContext
parameter_list|(
name|ReaderContext
name|parent
parameter_list|,
name|IndexReader
name|reader
parameter_list|,
name|int
name|ordInParent
parameter_list|,
name|int
name|docbaseInParent
parameter_list|,
name|ReaderContext
index|[]
name|children
parameter_list|)
block|{
name|this
argument_list|(
name|parent
argument_list|,
name|reader
argument_list|,
name|ordInParent
argument_list|,
name|docbaseInParent
argument_list|,
name|children
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a {@link CompositeReaderContext} for top-level readers with parent set to<code>null</code>      */
DECL|method|CompositeReaderContext
specifier|public
name|CompositeReaderContext
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|ReaderContext
index|[]
name|children
parameter_list|,
name|AtomicReaderContext
index|[]
name|leaves
parameter_list|)
block|{
name|this
argument_list|(
literal|null
argument_list|,
name|reader
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|children
argument_list|,
name|leaves
argument_list|)
expr_stmt|;
block|}
DECL|method|CompositeReaderContext
specifier|private
name|CompositeReaderContext
parameter_list|(
name|ReaderContext
name|parent
parameter_list|,
name|IndexReader
name|reader
parameter_list|,
name|int
name|ordInParent
parameter_list|,
name|int
name|docbaseInParent
parameter_list|,
name|ReaderContext
index|[]
name|children
parameter_list|,
name|AtomicReaderContext
index|[]
name|leaves
parameter_list|)
block|{
name|super
argument_list|(
name|parent
argument_list|,
name|reader
argument_list|,
literal|false
argument_list|,
name|ordInParent
argument_list|,
name|docbaseInParent
argument_list|)
expr_stmt|;
name|this
operator|.
name|children
operator|=
name|children
expr_stmt|;
name|this
operator|.
name|leaves
operator|=
name|leaves
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|leaves
specifier|public
name|AtomicReaderContext
index|[]
name|leaves
parameter_list|()
block|{
return|return
name|leaves
return|;
block|}
annotation|@
name|Override
DECL|method|children
specifier|public
name|ReaderContext
index|[]
name|children
parameter_list|()
block|{
return|return
name|children
return|;
block|}
block|}
comment|/**    * {@link ReaderContext} for atomic {@link IndexReader} instances    * @lucene.experimental    */
DECL|class|AtomicReaderContext
specifier|public
specifier|static
specifier|final
class|class
name|AtomicReaderContext
extends|extends
name|ReaderContext
block|{
comment|/** The readers ord in the top-level's leaves array */
DECL|field|ord
specifier|public
specifier|final
name|int
name|ord
decl_stmt|;
comment|/** The readers absolute doc base */
DECL|field|docBase
specifier|public
specifier|final
name|int
name|docBase
decl_stmt|;
comment|/**      * Creates a new {@link AtomicReaderContext}       */
DECL|method|AtomicReaderContext
specifier|public
name|AtomicReaderContext
parameter_list|(
name|ReaderContext
name|parent
parameter_list|,
name|IndexReader
name|reader
parameter_list|,
name|int
name|ord
parameter_list|,
name|int
name|docBase
parameter_list|,
name|int
name|leafOrd
parameter_list|,
name|int
name|leafDocBase
parameter_list|)
block|{
name|super
argument_list|(
name|parent
argument_list|,
name|reader
argument_list|,
literal|true
argument_list|,
name|ord
argument_list|,
name|docBase
argument_list|)
expr_stmt|;
assert|assert
name|reader
operator|.
name|getSequentialSubReaders
argument_list|()
operator|==
literal|null
operator|:
literal|"Atomic readers must not have subreaders"
assert|;
name|this
operator|.
name|ord
operator|=
name|leafOrd
expr_stmt|;
name|this
operator|.
name|docBase
operator|=
name|leafDocBase
expr_stmt|;
block|}
comment|/**      * Creates a new {@link AtomicReaderContext} for a atomic reader without an immediate      * parent.      */
DECL|method|AtomicReaderContext
specifier|public
name|AtomicReaderContext
parameter_list|(
name|IndexReader
name|atomicReader
parameter_list|)
block|{
name|this
argument_list|(
literal|null
argument_list|,
name|atomicReader
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
