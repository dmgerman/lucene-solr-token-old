begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|InfoStream
import|;
end_import
begin_comment
comment|/**  *  Merges segments of approximately equal size, subject to  *  an allowed number of segments per tier.  This is similar  *  to {@link LogByteSizeMergePolicy}, except this merge  *  policy is able to merge non-adjacent segment, and  *  separates how many segments are merged at once ({@link  *  #setMaxMergeAtOnce}) from how many segments are allowed  *  per tier ({@link #setSegmentsPerTier}).  This merge  *  policy also does not over-merge (ie, cascade merges).   *  *<p>For normal merging, this policy first computes a  *  "budget" of how many segments are allowed by be in the  *  index.  If the index is over-budget, then the policy  *  sorts segments by decreasing size (pro-rating by percent  *  deletes), and then finds the least-cost merge.  Merge  *  cost is measured by a combination of the "skew" of the  *  merge (size of largest seg divided by smallest seg),  *  total merge size and pct deletes reclaimed,  *  so that merges with lower skew, smaller size  *  and those reclaiming more deletes, are  *  favored.  *  *<p>If a merge will produce a segment that's larger than  *  {@link #setMaxMergedSegmentMB}, then the policy will  *  merge fewer segments (down to 1 at once, if that one has  *  deletions) to keep the segment size under budget.  *        *<p<b>NOTE</b>: this policy freely merges non-adjacent  *  segments; if this is a problem, use {@link  *  LogMergePolicy}.  *  *<p><b>NOTE</b>: This policy always merges by byte size  *  of the segments, always pro-rates by percent deletes,  *  and does not apply any maximum segment size during  *  forceMerge (unlike {@link LogByteSizeMergePolicy}).  *  *  @lucene.experimental  */
end_comment
begin_comment
comment|// TODO
end_comment
begin_comment
comment|//   - we could try to take into account whether a large
end_comment
begin_comment
comment|//     merge is already running (under CMS) and then bias
end_comment
begin_comment
comment|//     ourselves towards picking smaller merges if so (or,
end_comment
begin_comment
comment|//     maybe CMS should do so)
end_comment
begin_class
DECL|class|TieredMergePolicy
specifier|public
class|class
name|TieredMergePolicy
extends|extends
name|MergePolicy
block|{
DECL|field|maxMergeAtOnce
specifier|private
name|int
name|maxMergeAtOnce
init|=
literal|10
decl_stmt|;
DECL|field|maxMergedSegmentBytes
specifier|private
name|long
name|maxMergedSegmentBytes
init|=
literal|5
operator|*
literal|1024
operator|*
literal|1024
operator|*
literal|1024L
decl_stmt|;
DECL|field|maxMergeAtOnceExplicit
specifier|private
name|int
name|maxMergeAtOnceExplicit
init|=
literal|30
decl_stmt|;
DECL|field|floorSegmentBytes
specifier|private
name|long
name|floorSegmentBytes
init|=
literal|2
operator|*
literal|1024
operator|*
literal|1024L
decl_stmt|;
DECL|field|segsPerTier
specifier|private
name|double
name|segsPerTier
init|=
literal|10.0
decl_stmt|;
DECL|field|expungeDeletesPctAllowed
specifier|private
name|double
name|expungeDeletesPctAllowed
init|=
literal|10.0
decl_stmt|;
DECL|field|useCompoundFile
specifier|private
name|boolean
name|useCompoundFile
init|=
literal|true
decl_stmt|;
DECL|field|noCFSRatio
specifier|private
name|double
name|noCFSRatio
init|=
literal|0.1
decl_stmt|;
DECL|field|reclaimDeletesWeight
specifier|private
name|double
name|reclaimDeletesWeight
init|=
literal|2.0
decl_stmt|;
comment|/** Maximum number of segments to be merged at a time    *  during "normal" merging.  For explicit merging (eg,    *  forceMerge or expungeDeletes was called), see {@link    *  #setMaxMergeAtOnceExplicit}.  Default is 10. */
DECL|method|setMaxMergeAtOnce
specifier|public
name|TieredMergePolicy
name|setMaxMergeAtOnce
parameter_list|(
name|int
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxMergeAtOnce must be> 1 (got "
operator|+
name|v
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|maxMergeAtOnce
operator|=
name|v
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** @see #setMaxMergeAtOnce */
DECL|method|getMaxMergeAtOnce
specifier|public
name|int
name|getMaxMergeAtOnce
parameter_list|()
block|{
return|return
name|maxMergeAtOnce
return|;
block|}
comment|// TODO: should addIndexes do explicit merging, too?  And,
comment|// if user calls IW.maybeMerge "explicitly"
comment|/** Maximum number of segments to be merged at a time,    *  during forceMerge or expungeDeletes. Default is 30. */
DECL|method|setMaxMergeAtOnceExplicit
specifier|public
name|TieredMergePolicy
name|setMaxMergeAtOnceExplicit
parameter_list|(
name|int
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxMergeAtOnceExplicit must be> 1 (got "
operator|+
name|v
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|maxMergeAtOnceExplicit
operator|=
name|v
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** @see #setMaxMergeAtOnceExplicit */
DECL|method|getMaxMergeAtOnceExplicit
specifier|public
name|int
name|getMaxMergeAtOnceExplicit
parameter_list|()
block|{
return|return
name|maxMergeAtOnceExplicit
return|;
block|}
comment|/** Maximum sized segment to produce during    *  normal merging.  This setting is approximate: the    *  estimate of the merged segment size is made by summing    *  sizes of to-be-merged segments (compensating for    *  percent deleted docs).  Default is 5 GB. */
DECL|method|setMaxMergedSegmentMB
specifier|public
name|TieredMergePolicy
name|setMaxMergedSegmentMB
parameter_list|(
name|double
name|v
parameter_list|)
block|{
name|maxMergedSegmentBytes
operator|=
call|(
name|long
call|)
argument_list|(
name|v
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** @see #getMaxMergedSegmentMB */
DECL|method|getMaxMergedSegmentMB
specifier|public
name|double
name|getMaxMergedSegmentMB
parameter_list|()
block|{
return|return
name|maxMergedSegmentBytes
operator|/
literal|1024
operator|/
literal|1024.
return|;
block|}
comment|/** Controls how aggressively merges that reclaim more    *  deletions are favored.  Higher values favor selecting    *  merges that reclaim deletions.  A value of 0.0 means    *  deletions don't impact merge selection. */
DECL|method|setReclaimDeletesWeight
specifier|public
name|TieredMergePolicy
name|setReclaimDeletesWeight
parameter_list|(
name|double
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|<
literal|0.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"reclaimDeletesWeight must be>= 0.0 (got "
operator|+
name|v
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|reclaimDeletesWeight
operator|=
name|v
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** See {@link #setReclaimDeletesWeight}. */
DECL|method|getReclaimDeletesWeight
specifier|public
name|double
name|getReclaimDeletesWeight
parameter_list|()
block|{
return|return
name|reclaimDeletesWeight
return|;
block|}
comment|/** Segments smaller than this are "rounded up" to this    *  size, ie treated as equal (floor) size for merge    *  selection.  This is to prevent frequent flushing of    *  tiny segments from allowing a long tail in the index.    *  Default is 2 MB. */
DECL|method|setFloorSegmentMB
specifier|public
name|TieredMergePolicy
name|setFloorSegmentMB
parameter_list|(
name|double
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|<=
literal|0.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"floorSegmentMB must be>= 0.0 (got "
operator|+
name|v
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|floorSegmentBytes
operator|=
call|(
name|long
call|)
argument_list|(
name|v
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** @see #setFloorSegmentMB */
DECL|method|getFloorSegmentMB
specifier|public
name|double
name|getFloorSegmentMB
parameter_list|()
block|{
return|return
name|floorSegmentBytes
operator|/
literal|1024
operator|*
literal|1024.
return|;
block|}
comment|/** When expungeDeletes is called, we only merge away a    *  segment if its delete percentage is over this    *  threshold.  Default is 10%. */
DECL|method|setExpungeDeletesPctAllowed
specifier|public
name|TieredMergePolicy
name|setExpungeDeletesPctAllowed
parameter_list|(
name|double
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
argument_list|<
literal|0.0
operator|||
name|v
argument_list|>
literal|100.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"expungeDeletesPctAllowed must be between 0.0 and 100.0 inclusive (got "
operator|+
name|v
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|expungeDeletesPctAllowed
operator|=
name|v
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** @see #setExpungeDeletesPctAllowed */
DECL|method|getExpungeDeletesPctAllowed
specifier|public
name|double
name|getExpungeDeletesPctAllowed
parameter_list|()
block|{
return|return
name|expungeDeletesPctAllowed
return|;
block|}
comment|/** Sets the allowed number of segments per tier.  Smaller    *  values mean more merging but fewer segments.    *    *<p><b>NOTE</b>: this value should be>= the {@link    *  #setMaxMergeAtOnce} otherwise you'll force too much    *  merging to occur.</p>    *    *<p>Default is 10.0.</p> */
DECL|method|setSegmentsPerTier
specifier|public
name|TieredMergePolicy
name|setSegmentsPerTier
parameter_list|(
name|double
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|<
literal|2.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"segmentsPerTier must be>= 2.0 (got "
operator|+
name|v
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|segsPerTier
operator|=
name|v
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** @see #setSegmentsPerTier */
DECL|method|getSegmentsPerTier
specifier|public
name|double
name|getSegmentsPerTier
parameter_list|()
block|{
return|return
name|segsPerTier
return|;
block|}
comment|/** Sets whether compound file format should be used for    *  newly flushed and newly merged segments.  Default    *  true. */
DECL|method|setUseCompoundFile
specifier|public
name|TieredMergePolicy
name|setUseCompoundFile
parameter_list|(
name|boolean
name|useCompoundFile
parameter_list|)
block|{
name|this
operator|.
name|useCompoundFile
operator|=
name|useCompoundFile
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** @see  #setUseCompoundFile */
DECL|method|getUseCompoundFile
specifier|public
name|boolean
name|getUseCompoundFile
parameter_list|()
block|{
return|return
name|useCompoundFile
return|;
block|}
comment|/** If a merged segment will be more than this percentage    *  of the total size of the index, leave the segment as    *  non-compound file even if compound file is enabled.    *  Set to 1.0 to always use CFS regardless of merge    *  size.  Default is 0.1. */
DECL|method|setNoCFSRatio
specifier|public
name|TieredMergePolicy
name|setNoCFSRatio
parameter_list|(
name|double
name|noCFSRatio
parameter_list|)
block|{
if|if
condition|(
name|noCFSRatio
argument_list|<
literal|0.0
operator|||
name|noCFSRatio
argument_list|>
literal|1.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"noCFSRatio must be 0.0 to 1.0 inclusive; got "
operator|+
name|noCFSRatio
argument_list|)
throw|;
block|}
name|this
operator|.
name|noCFSRatio
operator|=
name|noCFSRatio
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** @see #setNoCFSRatio */
DECL|method|getNoCFSRatio
specifier|public
name|double
name|getNoCFSRatio
parameter_list|()
block|{
return|return
name|noCFSRatio
return|;
block|}
DECL|class|SegmentByteSizeDescending
specifier|private
class|class
name|SegmentByteSizeDescending
implements|implements
name|Comparator
argument_list|<
name|SegmentInfo
argument_list|>
block|{
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
name|SegmentInfo
name|o1
parameter_list|,
name|SegmentInfo
name|o2
parameter_list|)
block|{
try|try
block|{
specifier|final
name|long
name|sz1
init|=
name|size
argument_list|(
name|o1
argument_list|)
decl_stmt|;
specifier|final
name|long
name|sz2
init|=
name|size
argument_list|(
name|o2
argument_list|)
decl_stmt|;
if|if
condition|(
name|sz1
operator|>
name|sz2
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|sz2
operator|>
name|sz1
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
name|o1
operator|.
name|name
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|name
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
block|}
block|}
DECL|field|segmentByteSizeDescending
specifier|private
specifier|final
name|Comparator
argument_list|<
name|SegmentInfo
argument_list|>
name|segmentByteSizeDescending
init|=
operator|new
name|SegmentByteSizeDescending
argument_list|()
decl_stmt|;
DECL|class|MergeScore
specifier|protected
specifier|static
specifier|abstract
class|class
name|MergeScore
block|{
DECL|method|getScore
specifier|abstract
name|double
name|getScore
parameter_list|()
function_decl|;
DECL|method|getExplanation
specifier|abstract
name|String
name|getExplanation
parameter_list|()
function_decl|;
block|}
annotation|@
name|Override
DECL|method|findMerges
specifier|public
name|MergeSpecification
name|findMerges
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"findMerges: "
operator|+
name|infos
operator|.
name|size
argument_list|()
operator|+
literal|" segments"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|infos
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Collection
argument_list|<
name|SegmentInfo
argument_list|>
name|merging
init|=
name|writer
operator|.
name|get
argument_list|()
operator|.
name|getMergingSegments
argument_list|()
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|SegmentInfo
argument_list|>
name|toBeMerged
init|=
operator|new
name|HashSet
argument_list|<
name|SegmentInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SegmentInfo
argument_list|>
name|infosSorted
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentInfo
argument_list|>
argument_list|(
name|infos
operator|.
name|asList
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|infosSorted
argument_list|,
name|segmentByteSizeDescending
argument_list|)
expr_stmt|;
comment|// Compute total index bytes& print details about the index
name|long
name|totIndexBytes
init|=
literal|0
decl_stmt|;
name|long
name|minSegmentBytes
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|SegmentInfo
name|info
range|:
name|infosSorted
control|)
block|{
specifier|final
name|long
name|segBytes
init|=
name|size
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|String
name|extra
init|=
name|merging
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|?
literal|" [merging]"
else|:
literal|""
decl_stmt|;
if|if
condition|(
name|segBytes
operator|>=
name|maxMergedSegmentBytes
operator|/
literal|2.0
condition|)
block|{
name|extra
operator|+=
literal|" [skip: too large]"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|segBytes
operator|<
name|floorSegmentBytes
condition|)
block|{
name|extra
operator|+=
literal|" [floored]"
expr_stmt|;
block|}
name|message
argument_list|(
literal|"  seg="
operator|+
name|writer
operator|.
name|get
argument_list|()
operator|.
name|segString
argument_list|(
name|info
argument_list|)
operator|+
literal|" size="
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%.3f"
argument_list|,
name|segBytes
operator|/
literal|1024
operator|/
literal|1024.
argument_list|)
operator|+
literal|" MB"
operator|+
name|extra
argument_list|)
expr_stmt|;
block|}
name|minSegmentBytes
operator|=
name|Math
operator|.
name|min
argument_list|(
name|segBytes
argument_list|,
name|minSegmentBytes
argument_list|)
expr_stmt|;
comment|// Accum total byte size
name|totIndexBytes
operator|+=
name|segBytes
expr_stmt|;
block|}
comment|// If we have too-large segments, grace them out
comment|// of the maxSegmentCount:
name|int
name|tooBigCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|tooBigCount
operator|<
name|infosSorted
operator|.
name|size
argument_list|()
operator|&&
name|size
argument_list|(
name|infosSorted
operator|.
name|get
argument_list|(
name|tooBigCount
argument_list|)
argument_list|)
operator|>=
name|maxMergedSegmentBytes
operator|/
literal|2.0
condition|)
block|{
name|totIndexBytes
operator|-=
name|size
argument_list|(
name|infosSorted
operator|.
name|get
argument_list|(
name|tooBigCount
argument_list|)
argument_list|)
expr_stmt|;
name|tooBigCount
operator|++
expr_stmt|;
block|}
name|minSegmentBytes
operator|=
name|floorSize
argument_list|(
name|minSegmentBytes
argument_list|)
expr_stmt|;
comment|// Compute max allowed segs in the index
name|long
name|levelSize
init|=
name|minSegmentBytes
decl_stmt|;
name|long
name|bytesLeft
init|=
name|totIndexBytes
decl_stmt|;
name|double
name|allowedSegCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|double
name|segCountLevel
init|=
name|bytesLeft
operator|/
operator|(
name|double
operator|)
name|levelSize
decl_stmt|;
if|if
condition|(
name|segCountLevel
operator|<
name|segsPerTier
condition|)
block|{
name|allowedSegCount
operator|+=
name|Math
operator|.
name|ceil
argument_list|(
name|segCountLevel
argument_list|)
expr_stmt|;
break|break;
block|}
name|allowedSegCount
operator|+=
name|segsPerTier
expr_stmt|;
name|bytesLeft
operator|-=
name|segsPerTier
operator|*
name|levelSize
expr_stmt|;
name|levelSize
operator|*=
name|maxMergeAtOnce
expr_stmt|;
block|}
name|int
name|allowedSegCountInt
init|=
operator|(
name|int
operator|)
name|allowedSegCount
decl_stmt|;
name|MergeSpecification
name|spec
init|=
literal|null
decl_stmt|;
comment|// Cycle to possibly select more than one merge:
while|while
condition|(
literal|true
condition|)
block|{
name|long
name|mergingBytes
init|=
literal|0
decl_stmt|;
comment|// Gather eligible segments for merging, ie segments
comment|// not already being merged and not already picked (by
comment|// prior iteration of this loop) for merging:
specifier|final
name|List
argument_list|<
name|SegmentInfo
argument_list|>
name|eligible
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
name|tooBigCount
init|;
name|idx
operator|<
name|infosSorted
operator|.
name|size
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|SegmentInfo
name|info
init|=
name|infosSorted
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|merging
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|mergingBytes
operator|+=
name|info
operator|.
name|sizeInBytes
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|toBeMerged
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|eligible
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|boolean
name|maxMergeIsRunning
init|=
name|mergingBytes
operator|>=
name|maxMergedSegmentBytes
decl_stmt|;
name|message
argument_list|(
literal|"  allowedSegmentCount="
operator|+
name|allowedSegCountInt
operator|+
literal|" vs count="
operator|+
name|infosSorted
operator|.
name|size
argument_list|()
operator|+
literal|" (eligible count="
operator|+
name|eligible
operator|.
name|size
argument_list|()
operator|+
literal|") tooBigCount="
operator|+
name|tooBigCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|eligible
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|spec
return|;
block|}
if|if
condition|(
name|eligible
operator|.
name|size
argument_list|()
operator|>=
name|allowedSegCountInt
condition|)
block|{
comment|// OK we are over budget -- find best merge!
name|MergeScore
name|bestScore
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|SegmentInfo
argument_list|>
name|best
init|=
literal|null
decl_stmt|;
name|boolean
name|bestTooLarge
init|=
literal|false
decl_stmt|;
name|long
name|bestMergeBytes
init|=
literal|0
decl_stmt|;
comment|// Consider all merge starts:
for|for
control|(
name|int
name|startIdx
init|=
literal|0
init|;
name|startIdx
operator|<=
name|eligible
operator|.
name|size
argument_list|()
operator|-
name|maxMergeAtOnce
condition|;
name|startIdx
operator|++
control|)
block|{
name|long
name|totAfterMergeBytes
init|=
literal|0
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SegmentInfo
argument_list|>
name|candidate
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentInfo
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|hitTooLarge
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
name|startIdx
init|;
name|idx
operator|<
name|eligible
operator|.
name|size
argument_list|()
operator|&&
name|candidate
operator|.
name|size
argument_list|()
operator|<
name|maxMergeAtOnce
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|SegmentInfo
name|info
init|=
name|eligible
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
specifier|final
name|long
name|segBytes
init|=
name|size
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|totAfterMergeBytes
operator|+
name|segBytes
operator|>
name|maxMergedSegmentBytes
condition|)
block|{
name|hitTooLarge
operator|=
literal|true
expr_stmt|;
comment|// NOTE: we continue, so that we can try
comment|// "packing" smaller segments into this merge
comment|// to see if we can get closer to the max
comment|// size; this in general is not perfect since
comment|// this is really "bin packing" and we'd have
comment|// to try different permutations.
continue|continue;
block|}
name|candidate
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|totAfterMergeBytes
operator|+=
name|segBytes
expr_stmt|;
block|}
specifier|final
name|MergeScore
name|score
init|=
name|score
argument_list|(
name|candidate
argument_list|,
name|hitTooLarge
argument_list|,
name|mergingBytes
argument_list|)
decl_stmt|;
name|message
argument_list|(
literal|"  maybe="
operator|+
name|writer
operator|.
name|get
argument_list|()
operator|.
name|segString
argument_list|(
name|candidate
argument_list|)
operator|+
literal|" score="
operator|+
name|score
operator|.
name|getScore
argument_list|()
operator|+
literal|" "
operator|+
name|score
operator|.
name|getExplanation
argument_list|()
operator|+
literal|" tooLarge="
operator|+
name|hitTooLarge
operator|+
literal|" size="
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%.3f MB"
argument_list|,
name|totAfterMergeBytes
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
argument_list|)
expr_stmt|;
comment|// If we are already running a max sized merge
comment|// (maxMergeIsRunning), don't allow another max
comment|// sized merge to kick off:
if|if
condition|(
operator|(
name|bestScore
operator|==
literal|null
operator|||
name|score
operator|.
name|getScore
argument_list|()
operator|<
name|bestScore
operator|.
name|getScore
argument_list|()
operator|)
operator|&&
operator|(
operator|!
name|hitTooLarge
operator|||
operator|!
name|maxMergeIsRunning
operator|)
condition|)
block|{
name|best
operator|=
name|candidate
expr_stmt|;
name|bestScore
operator|=
name|score
expr_stmt|;
name|bestTooLarge
operator|=
name|hitTooLarge
expr_stmt|;
name|bestMergeBytes
operator|=
name|totAfterMergeBytes
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|spec
operator|==
literal|null
condition|)
block|{
name|spec
operator|=
operator|new
name|MergeSpecification
argument_list|()
expr_stmt|;
block|}
specifier|final
name|OneMerge
name|merge
init|=
operator|new
name|OneMerge
argument_list|(
name|best
argument_list|)
decl_stmt|;
name|spec
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
for|for
control|(
name|SegmentInfo
name|info
range|:
name|merge
operator|.
name|segments
control|)
block|{
name|toBeMerged
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"  add merge="
operator|+
name|writer
operator|.
name|get
argument_list|()
operator|.
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
operator|+
literal|" size="
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%.3f MB"
argument_list|,
name|bestMergeBytes
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
operator|+
literal|" score="
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%.3f"
argument_list|,
name|bestScore
operator|.
name|getScore
argument_list|()
argument_list|)
operator|+
literal|" "
operator|+
name|bestScore
operator|.
name|getExplanation
argument_list|()
operator|+
operator|(
name|bestTooLarge
condition|?
literal|" [max merge]"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
name|spec
return|;
block|}
block|}
else|else
block|{
return|return
name|spec
return|;
block|}
block|}
block|}
comment|/** Expert: scores one merge; subclasses can override. */
DECL|method|score
specifier|protected
name|MergeScore
name|score
parameter_list|(
name|List
argument_list|<
name|SegmentInfo
argument_list|>
name|candidate
parameter_list|,
name|boolean
name|hitTooLarge
parameter_list|,
name|long
name|mergingBytes
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|totBeforeMergeBytes
init|=
literal|0
decl_stmt|;
name|long
name|totAfterMergeBytes
init|=
literal|0
decl_stmt|;
name|long
name|totAfterMergeBytesFloored
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SegmentInfo
name|info
range|:
name|candidate
control|)
block|{
specifier|final
name|long
name|segBytes
init|=
name|size
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|totAfterMergeBytes
operator|+=
name|segBytes
expr_stmt|;
name|totAfterMergeBytesFloored
operator|+=
name|floorSize
argument_list|(
name|segBytes
argument_list|)
expr_stmt|;
name|totBeforeMergeBytes
operator|+=
name|info
operator|.
name|sizeInBytes
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Measure "skew" of the merge, which can range
comment|// from 1.0/numSegsBeingMerged (good) to 1.0
comment|// (poor):
specifier|final
name|double
name|skew
decl_stmt|;
if|if
condition|(
name|hitTooLarge
condition|)
block|{
comment|// Pretend the merge has perfect skew; skew doesn't
comment|// matter in this case because this merge will not
comment|// "cascade" and so it cannot lead to N^2 merge cost
comment|// over time:
name|skew
operator|=
literal|1.0
operator|/
name|maxMergeAtOnce
expr_stmt|;
block|}
else|else
block|{
name|skew
operator|=
operator|(
operator|(
name|double
operator|)
name|floorSize
argument_list|(
name|size
argument_list|(
name|candidate
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|/
name|totAfterMergeBytesFloored
expr_stmt|;
block|}
comment|// Strongly favor merges with less skew (smaller
comment|// mergeScore is better):
name|double
name|mergeScore
init|=
name|skew
decl_stmt|;
comment|// Gently favor smaller merges over bigger ones.  We
comment|// don't want to make this exponent too large else we
comment|// can end up doing poor merges of small segments in
comment|// order to avoid the large merges:
name|mergeScore
operator|*=
name|Math
operator|.
name|pow
argument_list|(
name|totAfterMergeBytes
argument_list|,
literal|0.05
argument_list|)
expr_stmt|;
comment|// Strongly favor merges that reclaim deletes:
specifier|final
name|double
name|nonDelRatio
init|=
operator|(
operator|(
name|double
operator|)
name|totAfterMergeBytes
operator|)
operator|/
name|totBeforeMergeBytes
decl_stmt|;
name|mergeScore
operator|*=
name|Math
operator|.
name|pow
argument_list|(
name|nonDelRatio
argument_list|,
name|reclaimDeletesWeight
argument_list|)
expr_stmt|;
specifier|final
name|double
name|finalMergeScore
init|=
name|mergeScore
decl_stmt|;
return|return
operator|new
name|MergeScore
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|double
name|getScore
parameter_list|()
block|{
return|return
name|finalMergeScore
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getExplanation
parameter_list|()
block|{
return|return
literal|"skew="
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%.3f"
argument_list|,
name|skew
argument_list|)
operator|+
literal|" nonDelRatio="
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%.3f"
argument_list|,
name|nonDelRatio
argument_list|)
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|findForcedMerges
specifier|public
name|MergeSpecification
name|findForcedMerges
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|int
name|maxSegmentCount
parameter_list|,
name|Map
argument_list|<
name|SegmentInfo
argument_list|,
name|Boolean
argument_list|>
name|segmentsToMerge
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"findForcedMerges maxSegmentCount="
operator|+
name|maxSegmentCount
operator|+
literal|" infos="
operator|+
name|writer
operator|.
name|get
argument_list|()
operator|.
name|segString
argument_list|(
name|infos
argument_list|)
operator|+
literal|" segmentsToMerge="
operator|+
name|segmentsToMerge
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|SegmentInfo
argument_list|>
name|eligible
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentInfo
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|forceMergeRunning
init|=
literal|false
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|SegmentInfo
argument_list|>
name|merging
init|=
name|writer
operator|.
name|get
argument_list|()
operator|.
name|getMergingSegments
argument_list|()
decl_stmt|;
name|boolean
name|segmentIsOriginal
init|=
literal|false
decl_stmt|;
for|for
control|(
name|SegmentInfo
name|info
range|:
name|infos
control|)
block|{
specifier|final
name|Boolean
name|isOriginal
init|=
name|segmentsToMerge
operator|.
name|get
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|isOriginal
operator|!=
literal|null
condition|)
block|{
name|segmentIsOriginal
operator|=
name|isOriginal
expr_stmt|;
if|if
condition|(
operator|!
name|merging
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|eligible
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|forceMergeRunning
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|eligible
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|(
name|maxSegmentCount
operator|>
literal|1
operator|&&
name|eligible
operator|.
name|size
argument_list|()
operator|<=
name|maxSegmentCount
operator|)
operator|||
operator|(
name|maxSegmentCount
operator|==
literal|1
operator|&&
name|eligible
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|(
operator|!
name|segmentIsOriginal
operator|||
name|isMerged
argument_list|(
name|eligible
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"already merged"
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|eligible
argument_list|,
name|segmentByteSizeDescending
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"eligible="
operator|+
name|eligible
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"forceMergeRunning="
operator|+
name|forceMergeRunning
argument_list|)
expr_stmt|;
block|}
name|int
name|end
init|=
name|eligible
operator|.
name|size
argument_list|()
decl_stmt|;
name|MergeSpecification
name|spec
init|=
literal|null
decl_stmt|;
comment|// Do full merges, first, backwards:
while|while
condition|(
name|end
operator|>=
name|maxMergeAtOnceExplicit
operator|+
name|maxSegmentCount
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|spec
operator|==
literal|null
condition|)
block|{
name|spec
operator|=
operator|new
name|MergeSpecification
argument_list|()
expr_stmt|;
block|}
specifier|final
name|OneMerge
name|merge
init|=
operator|new
name|OneMerge
argument_list|(
name|eligible
operator|.
name|subList
argument_list|(
name|end
operator|-
name|maxMergeAtOnceExplicit
argument_list|,
name|end
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"add merge="
operator|+
name|writer
operator|.
name|get
argument_list|()
operator|.
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spec
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
name|end
operator|-=
name|maxMergeAtOnceExplicit
expr_stmt|;
block|}
if|if
condition|(
name|spec
operator|==
literal|null
operator|&&
operator|!
name|forceMergeRunning
condition|)
block|{
comment|// Do final merge
specifier|final
name|int
name|numToMerge
init|=
name|end
operator|-
name|maxSegmentCount
operator|+
literal|1
decl_stmt|;
specifier|final
name|OneMerge
name|merge
init|=
operator|new
name|OneMerge
argument_list|(
name|eligible
operator|.
name|subList
argument_list|(
name|end
operator|-
name|numToMerge
argument_list|,
name|end
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"add final merge="
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|writer
operator|.
name|get
argument_list|()
operator|.
name|getDirectory
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spec
operator|=
operator|new
name|MergeSpecification
argument_list|()
expr_stmt|;
name|spec
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
block|}
return|return
name|spec
return|;
block|}
annotation|@
name|Override
DECL|method|findMergesToExpungeDeletes
specifier|public
name|MergeSpecification
name|findMergesToExpungeDeletes
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"findMergesToExpungeDeletes infos="
operator|+
name|writer
operator|.
name|get
argument_list|()
operator|.
name|segString
argument_list|(
name|infos
argument_list|)
operator|+
literal|" expungeDeletesPctAllowed="
operator|+
name|expungeDeletesPctAllowed
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|SegmentInfo
argument_list|>
name|eligible
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|SegmentInfo
argument_list|>
name|merging
init|=
name|writer
operator|.
name|get
argument_list|()
operator|.
name|getMergingSegments
argument_list|()
decl_stmt|;
for|for
control|(
name|SegmentInfo
name|info
range|:
name|infos
control|)
block|{
name|double
name|pctDeletes
init|=
literal|100.
operator|*
operator|(
operator|(
name|double
operator|)
name|writer
operator|.
name|get
argument_list|()
operator|.
name|numDeletedDocs
argument_list|(
name|info
argument_list|)
operator|)
operator|/
name|info
operator|.
name|docCount
decl_stmt|;
if|if
condition|(
name|pctDeletes
operator|>
name|expungeDeletesPctAllowed
operator|&&
operator|!
name|merging
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|eligible
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eligible
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|eligible
argument_list|,
name|segmentByteSizeDescending
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"eligible="
operator|+
name|eligible
argument_list|)
expr_stmt|;
block|}
name|int
name|start
init|=
literal|0
decl_stmt|;
name|MergeSpecification
name|spec
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|eligible
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// Don't enforce max merged size here: app is explicitly
comment|// calling expungeDeletes, and knows this may take a
comment|// long time / produce big segments (like forceMerge):
specifier|final
name|int
name|end
init|=
name|Math
operator|.
name|min
argument_list|(
name|start
operator|+
name|maxMergeAtOnceExplicit
argument_list|,
name|eligible
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|==
literal|null
condition|)
block|{
name|spec
operator|=
operator|new
name|MergeSpecification
argument_list|()
expr_stmt|;
block|}
specifier|final
name|OneMerge
name|merge
init|=
operator|new
name|OneMerge
argument_list|(
name|eligible
operator|.
name|subList
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"add merge="
operator|+
name|writer
operator|.
name|get
argument_list|()
operator|.
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spec
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
name|start
operator|=
name|end
expr_stmt|;
block|}
return|return
name|spec
return|;
block|}
annotation|@
name|Override
DECL|method|useCompoundFile
specifier|public
name|boolean
name|useCompoundFile
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|SegmentInfo
name|mergedInfo
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|boolean
name|doCFS
decl_stmt|;
if|if
condition|(
operator|!
name|useCompoundFile
condition|)
block|{
name|doCFS
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noCFSRatio
operator|==
literal|1.0
condition|)
block|{
name|doCFS
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SegmentInfo
name|info
range|:
name|infos
control|)
name|totalSize
operator|+=
name|size
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|doCFS
operator|=
name|size
argument_list|(
name|mergedInfo
argument_list|)
operator|<=
name|noCFSRatio
operator|*
name|totalSize
expr_stmt|;
block|}
return|return
name|doCFS
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{   }
DECL|method|isMerged
specifier|private
name|boolean
name|isMerged
parameter_list|(
name|SegmentInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|IndexWriter
name|w
init|=
name|writer
operator|.
name|get
argument_list|()
decl_stmt|;
assert|assert
name|w
operator|!=
literal|null
assert|;
name|boolean
name|hasDeletions
init|=
name|w
operator|.
name|numDeletedDocs
argument_list|(
name|info
argument_list|)
operator|>
literal|0
decl_stmt|;
return|return
operator|!
name|hasDeletions
operator|&&
operator|!
name|info
operator|.
name|hasSeparateNorms
argument_list|()
operator|&&
name|info
operator|.
name|dir
operator|==
name|w
operator|.
name|getDirectory
argument_list|()
operator|&&
operator|(
name|info
operator|.
name|getUseCompoundFile
argument_list|()
operator|==
name|useCompoundFile
operator|||
name|noCFSRatio
operator|<
literal|1.0
operator|)
return|;
block|}
comment|// Segment size in bytes, pro-rated by % deleted
DECL|method|size
specifier|private
name|long
name|size
parameter_list|(
name|SegmentInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|byteSize
init|=
name|info
operator|.
name|sizeInBytes
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|int
name|delCount
init|=
name|writer
operator|.
name|get
argument_list|()
operator|.
name|numDeletedDocs
argument_list|(
name|info
argument_list|)
decl_stmt|;
specifier|final
name|double
name|delRatio
init|=
operator|(
name|info
operator|.
name|docCount
operator|<=
literal|0
condition|?
literal|0.0f
else|:
operator|(
operator|(
name|double
operator|)
name|delCount
operator|/
operator|(
name|double
operator|)
name|info
operator|.
name|docCount
operator|)
operator|)
decl_stmt|;
assert|assert
name|delRatio
operator|<=
literal|1.0
assert|;
return|return
call|(
name|long
call|)
argument_list|(
name|byteSize
operator|*
operator|(
literal|1.0
operator|-
name|delRatio
operator|)
argument_list|)
return|;
block|}
DECL|method|floorSize
specifier|private
name|long
name|floorSize
parameter_list|(
name|long
name|bytes
parameter_list|)
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
name|floorSegmentBytes
argument_list|,
name|bytes
argument_list|)
return|;
block|}
DECL|method|verbose
specifier|private
name|boolean
name|verbose
parameter_list|()
block|{
name|IndexWriter
name|w
init|=
name|writer
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|w
operator|!=
literal|null
operator|&&
name|w
operator|.
name|verbose
argument_list|()
return|;
block|}
DECL|method|message
specifier|private
name|void
name|message
parameter_list|(
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
specifier|final
name|InfoStream
name|infoStream
init|=
name|writer
operator|.
name|get
argument_list|()
operator|.
name|infoStream
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"TMP"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"["
operator|+
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": "
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxMergeAtOnce="
argument_list|)
operator|.
name|append
argument_list|(
name|maxMergeAtOnce
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxMergeAtOnceExplicit="
argument_list|)
operator|.
name|append
argument_list|(
name|maxMergeAtOnceExplicit
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxMergedSegmentMB="
argument_list|)
operator|.
name|append
argument_list|(
name|maxMergedSegmentBytes
operator|/
literal|1024
operator|/
literal|1024.
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"floorSegmentMB="
argument_list|)
operator|.
name|append
argument_list|(
name|floorSegmentBytes
operator|/
literal|1024
operator|/
literal|1024.
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"expungeDeletesPctAllowed="
argument_list|)
operator|.
name|append
argument_list|(
name|expungeDeletesPctAllowed
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"segmentsPerTier="
argument_list|)
operator|.
name|append
argument_list|(
name|segsPerTier
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"useCompoundFile="
argument_list|)
operator|.
name|append
argument_list|(
name|useCompoundFile
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"noCFSRatio="
argument_list|)
operator|.
name|append
argument_list|(
name|noCFSRatio
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class
end_unit
