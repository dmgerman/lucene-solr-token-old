begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_comment
comment|/**   * An IndexReader which reads indexes with multiple segments.  * To get an instance of this reader use {@link #open(Directory)}.  */
end_comment
begin_class
DECL|class|DirectoryReader
specifier|public
specifier|final
class|class
name|DirectoryReader
extends|extends
name|BaseMultiReader
argument_list|<
name|SegmentReader
argument_list|>
block|{
DECL|field|DEFAULT_TERMS_INDEX_DIVISOR
specifier|static
name|int
name|DEFAULT_TERMS_INDEX_DIVISOR
init|=
literal|1
decl_stmt|;
DECL|field|directory
specifier|protected
specifier|final
name|Directory
name|directory
decl_stmt|;
DECL|field|writer
specifier|private
specifier|final
name|IndexWriter
name|writer
decl_stmt|;
DECL|field|segmentInfos
specifier|private
specifier|final
name|SegmentInfos
name|segmentInfos
decl_stmt|;
DECL|field|termInfosIndexDivisor
specifier|private
specifier|final
name|int
name|termInfosIndexDivisor
decl_stmt|;
DECL|field|applyAllDeletes
specifier|private
specifier|final
name|boolean
name|applyAllDeletes
decl_stmt|;
comment|/** Returns a IndexReader reading the index in the given    *  Directory    * @param directory the index directory    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|open
specifier|public
specifier|static
name|DirectoryReader
name|open
parameter_list|(
specifier|final
name|Directory
name|directory
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|directory
argument_list|,
literal|null
argument_list|,
name|DEFAULT_TERMS_INDEX_DIVISOR
argument_list|)
return|;
block|}
comment|/** Expert: Returns a IndexReader reading the index in the given    *  Directory with the given termInfosIndexDivisor.    * @param directory the index directory    * @param termInfosIndexDivisor Subsamples which indexed    *  terms are loaded into RAM. This has the same effect as {@link    *  IndexWriterConfig#setTermIndexInterval} except that setting    *  must be done at indexing time while this setting can be    *  set per reader.  When set to N, then one in every    *  N*termIndexInterval terms in the index is loaded into    *  memory.  By setting this to a value> 1 you can reduce    *  memory usage, at the expense of higher latency when    *  loading a TermInfo.  The default value is 1.  Set this    *  to -1 to skip loading the terms index entirely.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|open
specifier|public
specifier|static
name|DirectoryReader
name|open
parameter_list|(
specifier|final
name|Directory
name|directory
parameter_list|,
name|int
name|termInfosIndexDivisor
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|directory
argument_list|,
literal|null
argument_list|,
name|termInfosIndexDivisor
argument_list|)
return|;
block|}
comment|/**    * Open a near real time IndexReader from the {@link org.apache.lucene.index.IndexWriter}.    *    * @param writer The IndexWriter to open from    * @param applyAllDeletes If true, all buffered deletes will    * be applied (made visible) in the returned reader.  If    * false, the deletes are not applied but remain buffered    * (in IndexWriter) so that they will be applied in the    * future.  Applying deletes can be costly, so if your app    * can tolerate deleted documents being returned you might    * gain some performance by passing false.    * @return The new IndexReader    * @throws CorruptIndexException    * @throws IOException if there is a low-level IO error    *    * @see #openIfChanged(IndexReader,IndexWriter,boolean)    *    * @lucene.experimental    */
DECL|method|open
specifier|public
specifier|static
name|DirectoryReader
name|open
parameter_list|(
specifier|final
name|IndexWriter
name|writer
parameter_list|,
name|boolean
name|applyAllDeletes
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|writer
operator|.
name|getReader
argument_list|(
name|applyAllDeletes
argument_list|)
return|;
block|}
comment|/** Expert: returns an IndexReader reading the index in the given    *  {@link IndexCommit}.    * @param commit the commit point to open    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|open
specifier|public
specifier|static
name|DirectoryReader
name|open
parameter_list|(
specifier|final
name|IndexCommit
name|commit
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|commit
operator|.
name|getDirectory
argument_list|()
argument_list|,
name|commit
argument_list|,
name|DEFAULT_TERMS_INDEX_DIVISOR
argument_list|)
return|;
block|}
comment|/** Expert: returns an IndexReader reading the index in the given    *  {@link IndexCommit} and termInfosIndexDivisor.    * @param commit the commit point to open    * @param termInfosIndexDivisor Subsamples which indexed    *  terms are loaded into RAM. This has the same effect as {@link    *  IndexWriterConfig#setTermIndexInterval} except that setting    *  must be done at indexing time while this setting can be    *  set per reader.  When set to N, then one in every    *  N*termIndexInterval terms in the index is loaded into    *  memory.  By setting this to a value> 1 you can reduce    *  memory usage, at the expense of higher latency when    *  loading a TermInfo.  The default value is 1.  Set this    *  to -1 to skip loading the terms index entirely.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|open
specifier|public
specifier|static
name|DirectoryReader
name|open
parameter_list|(
specifier|final
name|IndexCommit
name|commit
parameter_list|,
name|int
name|termInfosIndexDivisor
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|commit
operator|.
name|getDirectory
argument_list|()
argument_list|,
name|commit
argument_list|,
name|termInfosIndexDivisor
argument_list|)
return|;
block|}
DECL|method|DirectoryReader
name|DirectoryReader
parameter_list|(
name|SegmentReader
index|[]
name|readers
parameter_list|,
name|Directory
name|directory
parameter_list|,
name|IndexWriter
name|writer
parameter_list|,
name|SegmentInfos
name|sis
parameter_list|,
name|int
name|termInfosIndexDivisor
parameter_list|,
name|boolean
name|applyAllDeletes
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|readers
argument_list|)
expr_stmt|;
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
name|this
operator|.
name|writer
operator|=
name|writer
expr_stmt|;
name|this
operator|.
name|segmentInfos
operator|=
name|sis
expr_stmt|;
name|this
operator|.
name|termInfosIndexDivisor
operator|=
name|termInfosIndexDivisor
expr_stmt|;
name|this
operator|.
name|applyAllDeletes
operator|=
name|applyAllDeletes
expr_stmt|;
block|}
DECL|method|open
specifier|private
specifier|static
name|DirectoryReader
name|open
parameter_list|(
specifier|final
name|Directory
name|directory
parameter_list|,
specifier|final
name|IndexCommit
name|commit
parameter_list|,
specifier|final
name|int
name|termInfosIndexDivisor
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
operator|(
name|DirectoryReader
operator|)
operator|new
name|SegmentInfos
operator|.
name|FindSegmentsFile
argument_list|(
name|directory
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|Object
name|doBody
parameter_list|(
name|String
name|segmentFileName
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|SegmentInfos
name|sis
init|=
operator|new
name|SegmentInfos
argument_list|()
decl_stmt|;
name|sis
operator|.
name|read
argument_list|(
name|directory
argument_list|,
name|segmentFileName
argument_list|)
expr_stmt|;
specifier|final
name|SegmentReader
index|[]
name|readers
init|=
operator|new
name|SegmentReader
index|[
name|sis
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|sis
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|IOException
name|prior
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|readers
index|[
name|i
index|]
operator|=
operator|new
name|SegmentReader
argument_list|(
name|sis
operator|.
name|info
argument_list|(
name|i
argument_list|)
argument_list|,
name|termInfosIndexDivisor
argument_list|,
name|IOContext
operator|.
name|READ
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|prior
operator|=
name|ex
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|prior
argument_list|,
name|readers
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|DirectoryReader
argument_list|(
name|readers
argument_list|,
name|directory
argument_list|,
literal|null
argument_list|,
name|sis
argument_list|,
name|termInfosIndexDivisor
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|commit
argument_list|)
return|;
block|}
comment|// Used by near real-time search
DECL|method|open
specifier|static
name|DirectoryReader
name|open
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|SegmentInfos
name|infos
parameter_list|,
name|boolean
name|applyAllDeletes
parameter_list|)
throws|throws
name|IOException
block|{
comment|// IndexWriter synchronizes externally before calling
comment|// us, which ensures infos will not change; so there's
comment|// no need to process segments in reverse order
specifier|final
name|int
name|numSegments
init|=
name|infos
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SegmentReader
argument_list|>
name|readers
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentReader
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Directory
name|dir
init|=
name|writer
operator|.
name|getDirectory
argument_list|()
decl_stmt|;
specifier|final
name|SegmentInfos
name|segmentInfos
init|=
operator|(
name|SegmentInfos
operator|)
name|infos
operator|.
name|clone
argument_list|()
decl_stmt|;
name|int
name|infosUpto
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
condition|;
name|i
operator|++
control|)
block|{
name|IOException
name|prior
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
specifier|final
name|SegmentInfo
name|info
init|=
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
assert|assert
name|info
operator|.
name|dir
operator|==
name|dir
assert|;
specifier|final
name|IndexWriter
operator|.
name|ReadersAndLiveDocs
name|rld
init|=
name|writer
operator|.
name|readerPool
operator|.
name|get
argument_list|(
name|info
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|SegmentReader
name|reader
init|=
name|rld
operator|.
name|getReadOnlyClone
argument_list|(
name|IOContext
operator|.
name|READ
argument_list|)
decl_stmt|;
if|if
condition|(
name|reader
operator|.
name|numDocs
argument_list|()
operator|>
literal|0
operator|||
name|writer
operator|.
name|getKeepFullyDeletedSegments
argument_list|()
condition|)
block|{
name|readers
operator|.
name|add
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|infosUpto
operator|++
expr_stmt|;
block|}
else|else
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|segmentInfos
operator|.
name|remove
argument_list|(
name|infosUpto
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|prior
operator|=
name|ex
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|prior
argument_list|,
name|readers
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|DirectoryReader
argument_list|(
name|readers
operator|.
name|toArray
argument_list|(
operator|new
name|SegmentReader
index|[
name|readers
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|dir
argument_list|,
name|writer
argument_list|,
name|segmentInfos
argument_list|,
name|writer
operator|.
name|getConfig
argument_list|()
operator|.
name|getReaderTermsIndexDivisor
argument_list|()
argument_list|,
name|applyAllDeletes
argument_list|)
return|;
block|}
comment|/** This constructor is only used for {@link #doOpenIfChanged()} */
DECL|method|open
specifier|private
specifier|static
name|DirectoryReader
name|open
parameter_list|(
name|Directory
name|directory
parameter_list|,
name|IndexWriter
name|writer
parameter_list|,
name|SegmentInfos
name|infos
parameter_list|,
name|SegmentReader
index|[]
name|oldReaders
parameter_list|,
name|int
name|termInfosIndexDivisor
parameter_list|)
throws|throws
name|IOException
block|{
comment|// we put the old SegmentReaders in a map, that allows us
comment|// to lookup a reader using its segment name
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|segmentReaders
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldReaders
operator|!=
literal|null
condition|)
block|{
comment|// create a Map SegmentName->SegmentReader
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldReaders
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|segmentReaders
operator|.
name|put
argument_list|(
name|oldReaders
index|[
name|i
index|]
operator|.
name|getSegmentName
argument_list|()
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SegmentReader
index|[]
name|newReaders
init|=
operator|new
name|SegmentReader
index|[
name|infos
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
comment|// remember which readers are shared between the old and the re-opened
comment|// DirectoryReader - we have to incRef those readers
name|boolean
index|[]
name|readerShared
init|=
operator|new
name|boolean
index|[
name|infos
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|infos
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|// find SegmentReader for this segment
name|Integer
name|oldReaderIndex
init|=
name|segmentReaders
operator|.
name|get
argument_list|(
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldReaderIndex
operator|==
literal|null
condition|)
block|{
comment|// this is a new segment, no old SegmentReader can be reused
name|newReaders
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// there is an old reader for this segment - we'll try to reopen it
name|newReaders
index|[
name|i
index|]
operator|=
name|oldReaders
index|[
name|oldReaderIndex
operator|.
name|intValue
argument_list|()
index|]
expr_stmt|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|IOException
name|prior
init|=
literal|null
decl_stmt|;
try|try
block|{
name|SegmentReader
name|newReader
decl_stmt|;
if|if
condition|(
name|newReaders
index|[
name|i
index|]
operator|==
literal|null
operator|||
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
operator|.
name|getUseCompoundFile
argument_list|()
operator|!=
name|newReaders
index|[
name|i
index|]
operator|.
name|getSegmentInfo
argument_list|()
operator|.
name|getUseCompoundFile
argument_list|()
condition|)
block|{
comment|// this is a new reader; in case we hit an exception we can close it safely
name|newReader
operator|=
operator|new
name|SegmentReader
argument_list|(
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
argument_list|,
name|termInfosIndexDivisor
argument_list|,
name|IOContext
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readerShared
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
name|newReaders
index|[
name|i
index|]
operator|=
name|newReader
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|newReaders
index|[
name|i
index|]
operator|.
name|getSegmentInfo
argument_list|()
operator|.
name|getDelGen
argument_list|()
operator|==
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
operator|.
name|getDelGen
argument_list|()
condition|)
block|{
comment|// No change; this reader will be shared between
comment|// the old and the new one, so we must incRef
comment|// it:
name|readerShared
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
name|newReaders
index|[
name|i
index|]
operator|.
name|incRef
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|readerShared
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
comment|// Steal the ref returned by SegmentReader ctor:
assert|assert
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
operator|.
name|dir
operator|==
name|newReaders
index|[
name|i
index|]
operator|.
name|getSegmentInfo
argument_list|()
operator|.
name|dir
assert|;
assert|assert
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
operator|.
name|hasDeletions
argument_list|()
assert|;
name|newReaders
index|[
name|i
index|]
operator|=
operator|new
name|SegmentReader
argument_list|(
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
argument_list|,
name|newReaders
index|[
name|i
index|]
operator|.
name|core
argument_list|,
name|IOContext
operator|.
name|READ
argument_list|)
expr_stmt|;
block|}
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|prior
operator|=
name|ex
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|infos
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|newReaders
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|readerShared
index|[
name|i
index|]
condition|)
block|{
comment|// this is a new subReader that is not used by the old one,
comment|// we can close it
name|newReaders
index|[
name|i
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// this subReader is also used by the old reader, so instead
comment|// closing we must decRef it
name|newReaders
index|[
name|i
index|]
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|prior
operator|==
literal|null
condition|)
name|prior
operator|=
name|ex
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// throw the first exception
if|if
condition|(
name|prior
operator|!=
literal|null
condition|)
throw|throw
name|prior
throw|;
block|}
block|}
return|return
operator|new
name|DirectoryReader
argument_list|(
name|newReaders
argument_list|,
name|directory
argument_list|,
name|writer
argument_list|,
name|infos
argument_list|,
name|termInfosIndexDivisor
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * If the index has changed since the provided reader was    * opened, open and return a new reader; else, return    * null.  The new reader, if not null, will be the same    * type of reader as the previous one, ie an NRT reader    * will open a new NRT reader, a MultiReader will open a    * new MultiReader,  etc.    *    *<p>This method is typically far less costly than opening a    * fully new<code>IndexReader</code> as it shares    * resources (for example sub-readers) with the provided    *<code>IndexReader</code>, when possible.    *    *<p>The provided reader is not closed (you are responsible    * for doing so); if a new reader is returned you also    * must eventually close it.  Be sure to never close a    * reader while other threads are still using it; see    * {@link SearcherManager} to simplify managing this.    *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    * @return null if there are no changes; else, a new    * IndexReader instance which you must eventually close    */
DECL|method|openIfChanged
specifier|public
specifier|static
name|DirectoryReader
name|openIfChanged
parameter_list|(
name|DirectoryReader
name|oldReader
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DirectoryReader
name|newReader
init|=
name|oldReader
operator|.
name|doOpenIfChanged
argument_list|()
decl_stmt|;
assert|assert
name|newReader
operator|!=
name|oldReader
assert|;
return|return
name|newReader
return|;
block|}
comment|/**    * If the IndexCommit differs from what the    * provided reader is searching, open and return a new    * reader; else, return null.    *    * @see #openIfChanged(IndexReader)    */
DECL|method|openIfChanged
specifier|public
specifier|static
name|DirectoryReader
name|openIfChanged
parameter_list|(
name|DirectoryReader
name|oldReader
parameter_list|,
name|IndexCommit
name|commit
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DirectoryReader
name|newReader
init|=
name|oldReader
operator|.
name|doOpenIfChanged
argument_list|(
name|commit
argument_list|)
decl_stmt|;
assert|assert
name|newReader
operator|!=
name|oldReader
assert|;
return|return
name|newReader
return|;
block|}
comment|/**    * Expert: If there changes (committed or not) in the    * {@link IndexWriter} versus what the provided reader is    * searching, then open and return a new    * IndexReader searching both committed and uncommitted    * changes from the writer; else, return null (though, the    * current implementation never returns null).    *    *<p>This provides "near real-time" searching, in that    * changes made during an {@link IndexWriter} session can be    * quickly made available for searching without closing    * the writer nor calling {@link IndexWriter#commit}.    *    *<p>It's<i>near</i> real-time because there is no hard    * guarantee on how quickly you can get a new reader after    * making changes with IndexWriter.  You'll have to    * experiment in your situation to determine if it's    * fast enough.  As this is a new and experimental    * feature, please report back on your findings so we can    * learn, improve and iterate.</p>    *    *<p>The very first time this method is called, this    * writer instance will make every effort to pool the    * readers that it opens for doing merges, applying    * deletes, etc.  This means additional resources (RAM,    * file descriptors, CPU time) will be consumed.</p>    *    *<p>For lower latency on reopening a reader, you should    * call {@link IndexWriterConfig#setMergedSegmentWarmer} to    * pre-warm a newly merged segment before it's committed    * to the index.  This is important for minimizing    * index-to-search delay after a large merge.</p>    *    *<p>If an addIndexes* call is running in another thread,    * then this reader will only search those segments from    * the foreign index that have been successfully copied    * over, so far.</p>    *    *<p><b>NOTE</b>: Once the writer is closed, any    * outstanding readers may continue to be used.  However,    * if you attempt to reopen any of those readers, you'll    * hit an {@link AlreadyClosedException}.</p>    *    * @return IndexReader that covers entire index plus all    * changes made so far by this IndexWriter instance, or    * null if there are no new changes    *    * @param writer The IndexWriter to open from    *    * @param applyAllDeletes If true, all buffered deletes will    * be applied (made visible) in the returned reader.  If    * false, the deletes are not applied but remain buffered    * (in IndexWriter) so that they will be applied in the    * future.  Applying deletes can be costly, so if your app    * can tolerate deleted documents being returned you might    * gain some performance by passing false.    *    * @throws IOException    *    * @lucene.experimental    */
DECL|method|openIfChanged
specifier|public
specifier|static
name|DirectoryReader
name|openIfChanged
parameter_list|(
name|DirectoryReader
name|oldReader
parameter_list|,
name|IndexWriter
name|writer
parameter_list|,
name|boolean
name|applyAllDeletes
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DirectoryReader
name|newReader
init|=
name|oldReader
operator|.
name|doOpenIfChanged
argument_list|(
name|writer
argument_list|,
name|applyAllDeletes
argument_list|)
decl_stmt|;
assert|assert
name|newReader
operator|!=
name|oldReader
assert|;
return|return
name|newReader
return|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
specifier|final
name|String
name|segmentsFile
init|=
name|segmentInfos
operator|.
name|getCurrentSegmentFileName
argument_list|()
decl_stmt|;
if|if
condition|(
name|segmentsFile
operator|!=
literal|null
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|segmentsFile
argument_list|)
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
operator|.
name|append
argument_list|(
name|segmentInfos
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|":nrt"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subReaders
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|subReaders
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|doOpenIfChanged
specifier|protected
specifier|final
name|DirectoryReader
name|doOpenIfChanged
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|doOpenIfChanged
argument_list|(
literal|null
argument_list|)
return|;
block|}
DECL|method|doOpenIfChanged
specifier|protected
specifier|final
name|DirectoryReader
name|doOpenIfChanged
parameter_list|(
specifier|final
name|IndexCommit
name|commit
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
comment|// If we were obtained by writer.getReader(), re-ask the
comment|// writer to get a new reader.
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
return|return
name|doOpenFromWriter
argument_list|(
name|commit
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|doOpenNoWriter
argument_list|(
name|commit
argument_list|)
return|;
block|}
block|}
DECL|method|doOpenIfChanged
specifier|protected
specifier|final
name|DirectoryReader
name|doOpenIfChanged
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|boolean
name|applyAllDeletes
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|writer
operator|==
name|this
operator|.
name|writer
operator|&&
name|applyAllDeletes
operator|==
name|this
operator|.
name|applyAllDeletes
condition|)
block|{
return|return
name|doOpenFromWriter
argument_list|(
literal|null
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|writer
operator|.
name|getReader
argument_list|(
name|applyAllDeletes
argument_list|)
return|;
block|}
block|}
DECL|method|doOpenFromWriter
specifier|private
specifier|final
name|DirectoryReader
name|doOpenFromWriter
parameter_list|(
name|IndexCommit
name|commit
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
if|if
condition|(
name|commit
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"a reader obtained from IndexWriter.getReader() cannot currently accept a commit"
argument_list|)
throw|;
block|}
if|if
condition|(
name|writer
operator|.
name|nrtIsCurrent
argument_list|(
name|segmentInfos
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|DirectoryReader
name|reader
init|=
name|writer
operator|.
name|getReader
argument_list|(
name|applyAllDeletes
argument_list|)
decl_stmt|;
comment|// If in fact no changes took place, return null:
if|if
condition|(
name|reader
operator|.
name|getVersion
argument_list|()
operator|==
name|segmentInfos
operator|.
name|getVersion
argument_list|()
condition|)
block|{
name|reader
operator|.
name|decRef
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|reader
return|;
block|}
DECL|method|doOpenNoWriter
specifier|private
specifier|synchronized
name|DirectoryReader
name|doOpenNoWriter
parameter_list|(
name|IndexCommit
name|commit
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
if|if
condition|(
name|commit
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isCurrent
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|directory
operator|!=
name|commit
operator|.
name|getDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"the specified commit does not match the specified Directory"
argument_list|)
throw|;
block|}
if|if
condition|(
name|segmentInfos
operator|!=
literal|null
operator|&&
name|commit
operator|.
name|getSegmentsFileName
argument_list|()
operator|.
name|equals
argument_list|(
name|segmentInfos
operator|.
name|getCurrentSegmentFileName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
operator|(
name|DirectoryReader
operator|)
operator|new
name|SegmentInfos
operator|.
name|FindSegmentsFile
argument_list|(
name|directory
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|Object
name|doBody
parameter_list|(
name|String
name|segmentFileName
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
specifier|final
name|SegmentInfos
name|infos
init|=
operator|new
name|SegmentInfos
argument_list|()
decl_stmt|;
name|infos
operator|.
name|read
argument_list|(
name|directory
argument_list|,
name|segmentFileName
argument_list|)
expr_stmt|;
return|return
name|doOpenIfChanged
argument_list|(
name|infos
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|commit
argument_list|)
return|;
block|}
DECL|method|doOpenIfChanged
specifier|private
specifier|synchronized
name|DirectoryReader
name|doOpenIfChanged
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|IndexWriter
name|writer
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|DirectoryReader
operator|.
name|open
argument_list|(
name|directory
argument_list|,
name|writer
argument_list|,
name|infos
argument_list|,
name|subReaders
argument_list|,
name|termInfosIndexDivisor
argument_list|)
return|;
block|}
comment|/**    * Version number when this IndexReader was opened. Not    * implemented in the IndexReader base class.    *    *<p>This method    * returns the version recorded in the commit that the    * reader opened.  This version is advanced every time    * a change is made with {@link IndexWriter}.</p>    */
DECL|method|getVersion
specifier|public
name|long
name|getVersion
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|segmentInfos
operator|.
name|getVersion
argument_list|()
return|;
block|}
DECL|method|getCommitUserData
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getCommitUserData
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|segmentInfos
operator|.
name|getUserData
argument_list|()
return|;
block|}
DECL|method|isCurrent
specifier|public
name|boolean
name|isCurrent
parameter_list|()
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|writer
operator|==
literal|null
operator|||
name|writer
operator|.
name|isClosed
argument_list|()
condition|)
block|{
comment|// we loaded SegmentInfos from the directory
return|return
name|SegmentInfos
operator|.
name|readCurrentVersion
argument_list|(
name|directory
argument_list|)
operator|==
name|segmentInfos
operator|.
name|getVersion
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|writer
operator|.
name|nrtIsCurrent
argument_list|(
name|segmentInfos
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|doClose
specifier|protected
specifier|synchronized
name|void
name|doClose
parameter_list|()
throws|throws
name|IOException
block|{
name|IOException
name|ioe
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subReaders
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// try to close each reader, even if an exception is thrown
try|try
block|{
name|subReaders
index|[
name|i
index|]
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|ioe
operator|==
literal|null
condition|)
name|ioe
operator|=
name|e
expr_stmt|;
block|}
block|}
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
comment|// Since we just closed, writer may now be able to
comment|// delete unused files:
name|writer
operator|.
name|deletePendingFiles
argument_list|()
expr_stmt|;
block|}
comment|// throw the first exception
if|if
condition|(
name|ioe
operator|!=
literal|null
condition|)
throw|throw
name|ioe
throw|;
block|}
comment|/** Returns the directory this index resides in. */
DECL|method|directory
specifier|public
name|Directory
name|directory
parameter_list|()
block|{
comment|// Don't ensureOpen here -- in certain cases, when a
comment|// cloned/reopened reader needs to commit, it may call
comment|// this method on the closed original reader
return|return
name|directory
return|;
block|}
DECL|method|getTermInfosIndexDivisor
specifier|public
name|int
name|getTermInfosIndexDivisor
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|termInfosIndexDivisor
return|;
block|}
comment|/**    * Expert: return the IndexCommit that this reader has opened.    *<p/>    * @lucene.experimental    */
DECL|method|getIndexCommit
specifier|public
name|IndexCommit
name|getIndexCommit
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
operator|new
name|ReaderCommit
argument_list|(
name|segmentInfos
argument_list|,
name|directory
argument_list|)
return|;
block|}
comment|/** @see org.apache.lucene.index.IndexReader#listCommits */
DECL|method|listCommits
specifier|public
specifier|static
name|List
argument_list|<
name|IndexCommit
argument_list|>
name|listCommits
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
index|[]
name|files
init|=
name|dir
operator|.
name|listAll
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|IndexCommit
argument_list|>
name|commits
init|=
operator|new
name|ArrayList
argument_list|<
name|IndexCommit
argument_list|>
argument_list|()
decl_stmt|;
name|SegmentInfos
name|latest
init|=
operator|new
name|SegmentInfos
argument_list|()
decl_stmt|;
name|latest
operator|.
name|read
argument_list|(
name|dir
argument_list|)
expr_stmt|;
specifier|final
name|long
name|currentGen
init|=
name|latest
operator|.
name|getGeneration
argument_list|()
decl_stmt|;
name|commits
operator|.
name|add
argument_list|(
operator|new
name|ReaderCommit
argument_list|(
name|latest
argument_list|,
name|dir
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|files
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|String
name|fileName
init|=
name|files
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|fileName
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|)
operator|&&
operator|!
name|fileName
operator|.
name|equals
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS_GEN
argument_list|)
operator|&&
name|SegmentInfos
operator|.
name|generationFromSegmentsFileName
argument_list|(
name|fileName
argument_list|)
operator|<
name|currentGen
condition|)
block|{
name|SegmentInfos
name|sis
init|=
operator|new
name|SegmentInfos
argument_list|()
decl_stmt|;
try|try
block|{
comment|// IOException allowed to throw there, in case
comment|// segments_N is corrupt
name|sis
operator|.
name|read
argument_list|(
name|dir
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
comment|// LUCENE-948: on NFS (and maybe others), if
comment|// you have writers switching back and forth
comment|// between machines, it's very likely that the
comment|// dir listing will be stale and will claim a
comment|// file segments_X exists when in fact it
comment|// doesn't.  So, we catch this and handle it
comment|// as if the file does not exist
name|sis
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|sis
operator|!=
literal|null
condition|)
name|commits
operator|.
name|add
argument_list|(
operator|new
name|ReaderCommit
argument_list|(
name|sis
argument_list|,
name|dir
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Ensure that the commit points are sorted in ascending order.
name|Collections
operator|.
name|sort
argument_list|(
name|commits
argument_list|)
expr_stmt|;
return|return
name|commits
return|;
block|}
comment|/**    * Reads version number from segments files. The version number is    * initialized with a timestamp and then increased by one for each change of    * the index.    *     * @param directory where the index resides.    * @return version number.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|getCurrentVersion
specifier|public
specifier|static
name|long
name|getCurrentVersion
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|SegmentInfos
operator|.
name|readCurrentVersion
argument_list|(
name|directory
argument_list|)
return|;
block|}
comment|/**    * Reads commitUserData, previously passed to {@link    * IndexWriter#commit(Map)}, from current index    * segments file.  This will return null if {@link    * IndexWriter#commit(Map)} has never been called for    * this index.    *     * @param directory where the index resides.    * @return commit userData.    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    *    * @see #getCommitUserData()    */
DECL|method|getCommitUserData
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getCommitUserData
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|SegmentInfos
operator|.
name|readCurrentUserData
argument_list|(
name|directory
argument_list|)
return|;
block|}
comment|/**    * Returns<code>true</code> if an index exists at the specified directory.    * @param  directory the directory to check for an index    * @return<code>true</code> if an index exists;<code>false</code> otherwise    * @throws IOException if there is a problem with accessing the index    */
DECL|method|indexExists
specifier|public
specifier|static
name|boolean
name|indexExists
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
operator|new
name|SegmentInfos
argument_list|()
operator|.
name|read
argument_list|(
name|directory
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|class|ReaderCommit
specifier|private
specifier|static
specifier|final
class|class
name|ReaderCommit
extends|extends
name|IndexCommit
block|{
DECL|field|segmentsFileName
specifier|private
name|String
name|segmentsFileName
decl_stmt|;
DECL|field|files
name|Collection
argument_list|<
name|String
argument_list|>
name|files
decl_stmt|;
DECL|field|dir
name|Directory
name|dir
decl_stmt|;
DECL|field|generation
name|long
name|generation
decl_stmt|;
DECL|field|userData
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|userData
decl_stmt|;
DECL|field|segmentCount
specifier|private
specifier|final
name|int
name|segmentCount
decl_stmt|;
DECL|method|ReaderCommit
name|ReaderCommit
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
name|segmentsFileName
operator|=
name|infos
operator|.
name|getCurrentSegmentFileName
argument_list|()
expr_stmt|;
name|this
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
name|userData
operator|=
name|infos
operator|.
name|getUserData
argument_list|()
expr_stmt|;
name|files
operator|=
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|infos
operator|.
name|files
argument_list|(
name|dir
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|generation
operator|=
name|infos
operator|.
name|getGeneration
argument_list|()
expr_stmt|;
name|segmentCount
operator|=
name|infos
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"DirectoryReader.ReaderCommit("
operator|+
name|segmentsFileName
operator|+
literal|")"
return|;
block|}
annotation|@
name|Override
DECL|method|getSegmentCount
specifier|public
name|int
name|getSegmentCount
parameter_list|()
block|{
return|return
name|segmentCount
return|;
block|}
annotation|@
name|Override
DECL|method|getSegmentsFileName
specifier|public
name|String
name|getSegmentsFileName
parameter_list|()
block|{
return|return
name|segmentsFileName
return|;
block|}
annotation|@
name|Override
DECL|method|getFileNames
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getFileNames
parameter_list|()
block|{
return|return
name|files
return|;
block|}
annotation|@
name|Override
DECL|method|getDirectory
specifier|public
name|Directory
name|getDirectory
parameter_list|()
block|{
return|return
name|dir
return|;
block|}
annotation|@
name|Override
DECL|method|getGeneration
specifier|public
name|long
name|getGeneration
parameter_list|()
block|{
return|return
name|generation
return|;
block|}
annotation|@
name|Override
DECL|method|isDeleted
specifier|public
name|boolean
name|isDeleted
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|getUserData
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getUserData
parameter_list|()
block|{
return|return
name|userData
return|;
block|}
annotation|@
name|Override
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This IndexCommit does not support deletions"
argument_list|)
throw|;
block|}
block|}
block|}
end_class
end_unit
