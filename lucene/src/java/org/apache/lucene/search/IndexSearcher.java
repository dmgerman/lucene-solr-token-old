begin_unit
begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletionService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorCompletionService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldSelector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CorruptIndexException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
operator|.
name|AtomicReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
operator|.
name|ReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Weight
operator|.
name|ScorerContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|NIOFSDirectory
import|;
end_import
begin_comment
comment|// javadoc
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ReaderUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ThreadInterruptedException
import|;
end_import
begin_comment
comment|/** Implements search over a single IndexReader.  *  *<p>Applications usually need only call the inherited  * {@link #search(Query,int)}  * or {@link #search(Query,Filter,int)} methods. For performance reasons it is   * recommended to open only one IndexSearcher and use it for all of your searches.  *   *<a name="thread-safety"></a><p><b>NOTE</b>:<code>{@link  * IndexSearcher}</code> instances are completely  * thread safe, meaning multiple threads can call any of its  * methods, concurrently.  If your application requires  * external synchronization, you should<b>not</b>  * synchronize on the<code>IndexSearcher</code> instance;  * use your own (non-Lucene) objects instead.</p>  */
end_comment
begin_class
DECL|class|IndexSearcher
specifier|public
class|class
name|IndexSearcher
block|{
DECL|field|reader
specifier|final
name|IndexReader
name|reader
decl_stmt|;
comment|// package private for testing!
DECL|field|closeReader
specifier|private
name|boolean
name|closeReader
decl_stmt|;
comment|// NOTE: these members might change in incompatible ways
comment|// in the next release
DECL|field|readerContext
specifier|protected
specifier|final
name|ReaderContext
name|readerContext
decl_stmt|;
DECL|field|leafContexts
specifier|protected
specifier|final
name|AtomicReaderContext
index|[]
name|leafContexts
decl_stmt|;
comment|// These are only used for multi-threaded search
DECL|field|executor
specifier|private
specifier|final
name|ExecutorService
name|executor
decl_stmt|;
DECL|field|subSearchers
specifier|protected
specifier|final
name|IndexSearcher
index|[]
name|subSearchers
decl_stmt|;
comment|/** The Similarity implementation used by this searcher. */
DECL|field|similarity
specifier|private
name|Similarity
name|similarity
init|=
name|Similarity
operator|.
name|getDefault
argument_list|()
decl_stmt|;
comment|/** Creates a searcher searching the index in the named    *  directory, with readOnly=true    * @param path directory where IndexReader will be opened    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|Directory
name|path
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|this
argument_list|(
name|IndexReader
operator|.
name|open
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a searcher searching the index in the named    *  directory.  You should pass readOnly=true, since it    *  gives much better concurrent performance, unless you    *  intend to do write operations (delete documents or    *  change norms) with the underlying IndexReader.    * @param path directory where IndexReader will be opened    * @param readOnly if true, the underlying IndexReader    * will be opened readOnly    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|Directory
name|path
parameter_list|,
name|boolean
name|readOnly
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|this
argument_list|(
name|IndexReader
operator|.
name|open
argument_list|(
name|path
argument_list|,
name|readOnly
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a searcher searching the provided index. */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|IndexReader
name|r
parameter_list|)
block|{
name|this
argument_list|(
name|r
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/** Runs searches for each segment separately, using the    *  provided ExecutorService.  IndexSearcher will not    *  shutdown/awaitTermination this ExecutorService on    *  close; you must do so, eventually, on your own.  NOTE:    *  if you are using {@link NIOFSDirectory}, do not use    *  the shutdownNow method of ExecutorService as this uses    *  Thread.interrupt under-the-hood which can silently    *  close file descriptors (see<a    *  href="https://issues.apache.org/jira/browse/LUCENE-2239">LUCENE-2239</a>).    *     * @lucene.experimental */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|IndexReader
name|r
parameter_list|,
name|ExecutorService
name|executor
parameter_list|)
block|{
name|this
argument_list|(
name|r
argument_list|,
literal|false
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a searcher searching the provided top-level {@link ReaderContext}.    *<p>    * Given a non-<code>null</code> {@link ExecutorService} this method runs    * searches for each segment separately, using the provided ExecutorService.    * IndexSearcher will not shutdown/awaitTermination this ExecutorService on    * close; you must do so, eventually, on your own. NOTE: if you are using    * {@link NIOFSDirectory}, do not use the shutdownNow method of    * ExecutorService as this uses Thread.interrupt under-the-hood which can    * silently close file descriptors (see<a    * href="https://issues.apache.org/jira/browse/LUCENE-2239">LUCENE-2239</a>).    *     * @see ReaderContext    * @see IndexReader#getTopReaderContext()    * @lucene.experimental    */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|ReaderContext
name|context
parameter_list|,
name|ExecutorService
name|executor
parameter_list|)
block|{
name|this
argument_list|(
name|context
argument_list|,
literal|false
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a searcher searching the provided top-level {@link ReaderContext}.    *    * @see ReaderContext    * @see IndexReader#getTopReaderContext()    * @lucene.experimental    */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|ReaderContext
name|context
parameter_list|)
block|{
name|this
argument_list|(
name|context
argument_list|,
operator|(
name|ExecutorService
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// convenience ctor for other IR based ctors
DECL|method|IndexSearcher
specifier|private
name|IndexSearcher
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|boolean
name|closeReader
parameter_list|,
name|ExecutorService
name|executor
parameter_list|)
block|{
name|this
argument_list|(
name|reader
operator|.
name|getTopReaderContext
argument_list|()
argument_list|,
name|closeReader
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
DECL|method|IndexSearcher
specifier|private
name|IndexSearcher
parameter_list|(
name|ReaderContext
name|context
parameter_list|,
name|boolean
name|closeReader
parameter_list|,
name|ExecutorService
name|executor
parameter_list|)
block|{
assert|assert
name|context
operator|.
name|isTopLevel
operator|:
literal|"IndexSearcher's ReaderContext must be topLevel for reader"
operator|+
name|context
operator|.
name|reader
assert|;
name|reader
operator|=
name|context
operator|.
name|reader
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
name|this
operator|.
name|closeReader
operator|=
name|closeReader
expr_stmt|;
name|this
operator|.
name|readerContext
operator|=
name|context
expr_stmt|;
name|leafContexts
operator|=
name|ReaderUtil
operator|.
name|leaves
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
block|{
name|subSearchers
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|subSearchers
operator|=
operator|new
name|IndexSearcher
index|[
name|this
operator|.
name|leafContexts
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subSearchers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|leafContexts
index|[
name|i
index|]
operator|.
name|reader
operator|==
name|context
operator|.
name|reader
condition|)
block|{
name|subSearchers
index|[
name|i
index|]
operator|=
name|this
expr_stmt|;
block|}
else|else
block|{
name|subSearchers
index|[
name|i
index|]
operator|=
operator|new
name|IndexSearcher
argument_list|(
name|context
argument_list|,
name|leafContexts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Expert: Creates a searcher from a top-level {@link ReaderContext} with and    * executes searches on the given leave slice exclusively instead of searching    * over all leaves. This constructor should be used to run one or more leaves    * within a single thread. Hence, for scorer and filter this looks like an    * ordinary search in the hierarchy such that there is no difference between    * single and multi-threaded.    *     * @lucene.experimental    * */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|ReaderContext
name|topLevel
parameter_list|,
name|AtomicReaderContext
modifier|...
name|leaves
parameter_list|)
block|{
assert|assert
name|assertLeaves
argument_list|(
name|topLevel
argument_list|,
name|leaves
argument_list|)
assert|;
name|readerContext
operator|=
name|topLevel
expr_stmt|;
name|reader
operator|=
name|topLevel
operator|.
name|reader
expr_stmt|;
name|leafContexts
operator|=
name|leaves
expr_stmt|;
name|executor
operator|=
literal|null
expr_stmt|;
name|subSearchers
operator|=
literal|null
expr_stmt|;
name|closeReader
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|assertLeaves
specifier|private
name|boolean
name|assertLeaves
parameter_list|(
name|ReaderContext
name|topLevel
parameter_list|,
name|AtomicReaderContext
modifier|...
name|leaves
parameter_list|)
block|{
for|for
control|(
name|AtomicReaderContext
name|leaf
range|:
name|leaves
control|)
block|{
assert|assert
name|ReaderUtil
operator|.
name|getTopLevelContext
argument_list|(
name|leaf
argument_list|)
operator|==
name|topLevel
operator|:
literal|"leaf context is not a leaf of the given top-level context"
assert|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Return the {@link IndexReader} this searches. */
DECL|method|getIndexReader
specifier|public
name|IndexReader
name|getIndexReader
parameter_list|()
block|{
return|return
name|reader
return|;
block|}
comment|/** Expert: Returns one greater than the largest possible document number.    *     * @see org.apache.lucene.index.IndexReader#maxDoc()    */
DECL|method|maxDoc
specifier|public
name|int
name|maxDoc
parameter_list|()
block|{
return|return
name|reader
operator|.
name|maxDoc
argument_list|()
return|;
block|}
comment|/** Returns total docFreq for this term. */
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|(
specifier|final
name|Term
name|term
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
block|{
return|return
name|reader
operator|.
name|docFreq
argument_list|(
name|term
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|ExecutionHelper
argument_list|<
name|Integer
argument_list|>
name|runner
init|=
operator|new
name|ExecutionHelper
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|executor
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subSearchers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|IndexSearcher
name|searchable
init|=
name|subSearchers
index|[
name|i
index|]
decl_stmt|;
name|runner
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|Integer
name|call
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Integer
operator|.
name|valueOf
argument_list|(
name|searchable
operator|.
name|docFreq
argument_list|(
name|term
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|int
name|docFreq
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Integer
name|num
range|:
name|runner
control|)
block|{
name|docFreq
operator|+=
name|num
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
return|return
name|docFreq
return|;
block|}
block|}
comment|/* Sugar for .getIndexReader().document(docID) */
DECL|method|doc
specifier|public
name|Document
name|doc
parameter_list|(
name|int
name|docID
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|reader
operator|.
name|document
argument_list|(
name|docID
argument_list|)
return|;
block|}
comment|/* Sugar for .getIndexReader().document(docID, fieldSelector) */
DECL|method|doc
specifier|public
name|Document
name|doc
parameter_list|(
name|int
name|docID
parameter_list|,
name|FieldSelector
name|fieldSelector
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|reader
operator|.
name|document
argument_list|(
name|docID
argument_list|,
name|fieldSelector
argument_list|)
return|;
block|}
comment|/** Expert: Set the Similarity implementation used by this Searcher.    *    * @see Similarity#setDefault(Similarity)    */
DECL|method|setSimilarity
specifier|public
name|void
name|setSimilarity
parameter_list|(
name|Similarity
name|similarity
parameter_list|)
block|{
name|this
operator|.
name|similarity
operator|=
name|similarity
expr_stmt|;
block|}
DECL|method|getSimilarity
specifier|public
name|Similarity
name|getSimilarity
parameter_list|()
block|{
return|return
name|similarity
return|;
block|}
comment|/**    * Note that the underlying IndexReader is not closed, if    * IndexSearcher was constructed with IndexSearcher(IndexReader r).    * If the IndexReader was supplied implicitly by specifying a directory, then    * the IndexReader is closed.    */
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closeReader
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Finds the top<code>n</code>    * hits for<code>query</code>.    *    * @throws BooleanQuery.TooManyClauses    */
DECL|method|search
specifier|public
name|TopDocs
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|n
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Finds the top<code>n</code>    * hits for<code>query</code>, applying<code>filter</code> if non-null.    *    * @throws BooleanQuery.TooManyClauses    */
DECL|method|search
specifier|public
name|TopDocs
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|n
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|createWeight
argument_list|(
name|query
argument_list|)
argument_list|,
name|filter
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Lower-level search API.    *    *<p>{@link Collector#collect(int)} is called for every matching    * document.    *<br>Collector-based access to remote indexes is discouraged.    *    *<p>Applications should only use this if they need<i>all</i> of the    * matching documents.  The high-level search API ({@link    * IndexSearcher#search(Query, Filter, int)}) is usually more efficient, as it skips    * non-high-scoring hits.    *    * @param query to match documents    * @param filter if non-null, used to permit documents to be collected.    * @param results to receive hits    * @throws BooleanQuery.TooManyClauses    */
DECL|method|search
specifier|public
name|void
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|Collector
name|results
parameter_list|)
throws|throws
name|IOException
block|{
name|search
argument_list|(
name|createWeight
argument_list|(
name|query
argument_list|)
argument_list|,
name|filter
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
comment|/** Lower-level search API.   *   *<p>{@link Collector#collect(int)} is called for every matching document.   *   *<p>Applications should only use this if they need<i>all</i> of the   * matching documents.  The high-level search API ({@link   * IndexSearcher#search(Query, int)}) is usually more efficient, as it skips   * non-high-scoring hits.   *<p>Note: The<code>score</code> passed to this method is a raw score.   * In other words, the score will not necessarily be a float whose value is   * between 0 and 1.   * @throws BooleanQuery.TooManyClauses   */
DECL|method|search
specifier|public
name|void
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|Collector
name|results
parameter_list|)
throws|throws
name|IOException
block|{
name|search
argument_list|(
name|createWeight
argument_list|(
name|query
argument_list|)
argument_list|,
literal|null
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
comment|/** Search implementation with arbitrary sorting.  Finds    * the top<code>n</code> hits for<code>query</code>, applying    *<code>filter</code> if non-null, and sorting the hits by the criteria in    *<code>sort</code>.    *     *<p>NOTE: this does not compute scores by default; use    * {@link IndexSearcher#setDefaultFieldSortScoring} to    * enable scoring.    *    * @throws BooleanQuery.TooManyClauses    */
DECL|method|search
specifier|public
name|TopFieldDocs
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|n
parameter_list|,
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|createWeight
argument_list|(
name|query
argument_list|)
argument_list|,
name|filter
argument_list|,
name|n
argument_list|,
name|sort
argument_list|)
return|;
block|}
comment|/**    * Search implementation with arbitrary sorting and no filter.    * @param query The query to search for    * @param n Return only the top n results    * @param sort The {@link org.apache.lucene.search.Sort} object    * @return The top docs, sorted according to the supplied {@link org.apache.lucene.search.Sort} instance    * @throws IOException    */
DECL|method|search
specifier|public
name|TopFieldDocs
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|n
parameter_list|,
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|createWeight
argument_list|(
name|query
argument_list|)
argument_list|,
literal|null
argument_list|,
name|n
argument_list|,
name|sort
argument_list|)
return|;
block|}
comment|/** Expert: Low-level search implementation.  Finds the top<code>n</code>    * hits for<code>query</code>, applying<code>filter</code> if non-null.    *    *<p>Applications should usually call {@link IndexSearcher#search(Query,int)} or    * {@link IndexSearcher#search(Query,Filter,int)} instead.    * @throws BooleanQuery.TooManyClauses    */
DECL|method|search
specifier|protected
name|TopDocs
name|search
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|nDocs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
block|{
comment|// single thread
name|int
name|limit
init|=
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
block|{
name|limit
operator|=
literal|1
expr_stmt|;
block|}
name|nDocs
operator|=
name|Math
operator|.
name|min
argument_list|(
name|nDocs
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|TopScoreDocCollector
name|collector
init|=
name|TopScoreDocCollector
operator|.
name|create
argument_list|(
name|nDocs
argument_list|,
operator|!
name|weight
operator|.
name|scoresDocsOutOfOrder
argument_list|()
argument_list|)
decl_stmt|;
name|search
argument_list|(
name|weight
argument_list|,
name|filter
argument_list|,
name|collector
argument_list|)
expr_stmt|;
return|return
name|collector
operator|.
name|topDocs
argument_list|()
return|;
block|}
else|else
block|{
specifier|final
name|HitQueue
name|hq
init|=
operator|new
name|HitQueue
argument_list|(
name|nDocs
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|Lock
name|lock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|final
name|ExecutionHelper
argument_list|<
name|TopDocs
argument_list|>
name|runner
init|=
operator|new
name|ExecutionHelper
argument_list|<
name|TopDocs
argument_list|>
argument_list|(
name|executor
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subSearchers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// search each sub
name|runner
operator|.
name|submit
argument_list|(
operator|new
name|SearcherCallableNoSort
argument_list|(
name|lock
argument_list|,
name|subSearchers
index|[
name|i
index|]
argument_list|,
name|weight
argument_list|,
name|filter
argument_list|,
name|nDocs
argument_list|,
name|hq
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|totalHits
init|=
literal|0
decl_stmt|;
name|float
name|maxScore
init|=
name|Float
operator|.
name|NEGATIVE_INFINITY
decl_stmt|;
for|for
control|(
specifier|final
name|TopDocs
name|topDocs
range|:
name|runner
control|)
block|{
name|totalHits
operator|+=
name|topDocs
operator|.
name|totalHits
expr_stmt|;
name|maxScore
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxScore
argument_list|,
name|topDocs
operator|.
name|getMaxScore
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ScoreDoc
index|[]
name|scoreDocs
init|=
operator|new
name|ScoreDoc
index|[
name|hq
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|hq
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
comment|// put docs in array
name|scoreDocs
index|[
name|i
index|]
operator|=
name|hq
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
operator|new
name|TopDocs
argument_list|(
name|totalHits
argument_list|,
name|scoreDocs
argument_list|,
name|maxScore
argument_list|)
return|;
block|}
block|}
comment|/** Expert: Low-level search implementation with arbitrary sorting.  Finds    * the top<code>n</code> hits for<code>query</code>, applying    *<code>filter</code> if non-null, and sorting the hits by the criteria in    *<code>sort</code>.    *    *<p>Applications should usually call {@link    * IndexSearcher#search(Query,Filter,int,Sort)} instead.    *     * @throws BooleanQuery.TooManyClauses    */
DECL|method|search
specifier|protected
name|TopFieldDocs
name|search
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
specifier|final
name|int
name|nDocs
parameter_list|,
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|weight
argument_list|,
name|filter
argument_list|,
name|nDocs
argument_list|,
name|sort
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Just like {@link #search(Weight, Filter, int, Sort)}, but you choose    * whether or not the fields in the returned {@link FieldDoc} instances should    * be set by specifying fillFields.    *    *<p>NOTE: this does not compute scores by default.  If you    * need scores, create a {@link TopFieldCollector}    * instance by calling {@link TopFieldCollector#create} and    * then pass that to {@link #search(Weight, Filter,    * Collector)}.</p>    */
DECL|method|search
specifier|protected
name|TopFieldDocs
name|search
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|nDocs
parameter_list|,
name|Sort
name|sort
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|sort
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
block|{
comment|// single thread
name|int
name|limit
init|=
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
block|{
name|limit
operator|=
literal|1
expr_stmt|;
block|}
name|nDocs
operator|=
name|Math
operator|.
name|min
argument_list|(
name|nDocs
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|TopFieldCollector
name|collector
init|=
name|TopFieldCollector
operator|.
name|create
argument_list|(
name|sort
argument_list|,
name|nDocs
argument_list|,
name|fillFields
argument_list|,
name|fieldSortDoTrackScores
argument_list|,
name|fieldSortDoMaxScore
argument_list|,
operator|!
name|weight
operator|.
name|scoresDocsOutOfOrder
argument_list|()
argument_list|)
decl_stmt|;
name|search
argument_list|(
name|weight
argument_list|,
name|filter
argument_list|,
name|collector
argument_list|)
expr_stmt|;
return|return
operator|(
name|TopFieldDocs
operator|)
name|collector
operator|.
name|topDocs
argument_list|()
return|;
block|}
else|else
block|{
comment|// TODO: make this respect fillFields
specifier|final
name|FieldDocSortedHitQueue
name|hq
init|=
operator|new
name|FieldDocSortedHitQueue
argument_list|(
name|nDocs
argument_list|)
decl_stmt|;
specifier|final
name|Lock
name|lock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|final
name|ExecutionHelper
argument_list|<
name|TopFieldDocs
argument_list|>
name|runner
init|=
operator|new
name|ExecutionHelper
argument_list|<
name|TopFieldDocs
argument_list|>
argument_list|(
name|executor
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subSearchers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// search each sub
name|runner
operator|.
name|submit
argument_list|(
operator|new
name|SearcherCallableWithSort
argument_list|(
name|lock
argument_list|,
name|subSearchers
index|[
name|i
index|]
argument_list|,
name|weight
argument_list|,
name|filter
argument_list|,
name|nDocs
argument_list|,
name|hq
argument_list|,
name|sort
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|totalHits
init|=
literal|0
decl_stmt|;
name|float
name|maxScore
init|=
name|Float
operator|.
name|NEGATIVE_INFINITY
decl_stmt|;
for|for
control|(
specifier|final
name|TopFieldDocs
name|topFieldDocs
range|:
name|runner
control|)
block|{
name|totalHits
operator|+=
name|topFieldDocs
operator|.
name|totalHits
expr_stmt|;
name|maxScore
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxScore
argument_list|,
name|topFieldDocs
operator|.
name|getMaxScore
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ScoreDoc
index|[]
name|scoreDocs
init|=
operator|new
name|ScoreDoc
index|[
name|hq
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|hq
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
comment|// put docs in array
name|scoreDocs
index|[
name|i
index|]
operator|=
name|hq
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
operator|new
name|TopFieldDocs
argument_list|(
name|totalHits
argument_list|,
name|scoreDocs
argument_list|,
name|hq
operator|.
name|getFields
argument_list|()
argument_list|,
name|maxScore
argument_list|)
return|;
block|}
block|}
comment|/**    * Lower-level search API.    *     *<p>    * {@link Collector#collect(int)} is called for every document.<br>    * Collector-based access to remote indexes is discouraged.    *     *<p>    * Applications should only use this if they need<i>all</i> of the matching    * documents. The high-level search API ({@link IndexSearcher#search(Query,int)}) is    * usually more efficient, as it skips non-high-scoring hits.    *     * @param weight    *          to match documents    * @param filter    *          if non-null, used to permit documents to be collected.    * @param collector    *          to receive hits    * @throws BooleanQuery.TooManyClauses    */
DECL|method|search
specifier|protected
name|void
name|search
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|Collector
name|collector
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: should we make this
comment|// threaded...?  the Collector could be sync'd?
name|ScorerContext
name|scorerContext
init|=
name|ScorerContext
operator|.
name|def
argument_list|()
operator|.
name|scoreDocsInOrder
argument_list|(
literal|true
argument_list|)
operator|.
name|topScorer
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|// always use single thread:
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leafContexts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// search each subreader
name|collector
operator|.
name|setNextReader
argument_list|(
name|leafContexts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|scorerContext
operator|=
name|scorerContext
operator|.
name|scoreDocsInOrder
argument_list|(
operator|!
name|collector
operator|.
name|acceptsDocsOutOfOrder
argument_list|()
argument_list|)
expr_stmt|;
name|Scorer
name|scorer
init|=
name|weight
operator|.
name|scorer
argument_list|(
name|leafContexts
index|[
name|i
index|]
argument_list|,
name|scorerContext
argument_list|)
decl_stmt|;
if|if
condition|(
name|scorer
operator|!=
literal|null
condition|)
block|{
name|scorer
operator|.
name|score
argument_list|(
name|collector
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leafContexts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// search each subreader
name|collector
operator|.
name|setNextReader
argument_list|(
name|leafContexts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|searchWithFilter
argument_list|(
name|leafContexts
index|[
name|i
index|]
argument_list|,
name|weight
argument_list|,
name|filter
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|searchWithFilter
specifier|private
name|void
name|searchWithFilter
parameter_list|(
name|AtomicReaderContext
name|context
parameter_list|,
name|Weight
name|weight
parameter_list|,
specifier|final
name|Filter
name|filter
parameter_list|,
specifier|final
name|Collector
name|collector
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|filter
operator|!=
literal|null
assert|;
name|Scorer
name|scorer
init|=
name|weight
operator|.
name|scorer
argument_list|(
name|context
argument_list|,
name|ScorerContext
operator|.
name|def
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|scorer
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|int
name|docID
init|=
name|scorer
operator|.
name|docID
argument_list|()
decl_stmt|;
assert|assert
name|docID
operator|==
operator|-
literal|1
operator|||
name|docID
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
assert|;
comment|// CHECKME: use ConjunctionScorer here?
name|DocIdSet
name|filterDocIdSet
init|=
name|filter
operator|.
name|getDocIdSet
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|filterDocIdSet
operator|==
literal|null
condition|)
block|{
comment|// this means the filter does not accept any documents.
return|return;
block|}
name|DocIdSetIterator
name|filterIter
init|=
name|filterDocIdSet
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|filterIter
operator|==
literal|null
condition|)
block|{
comment|// this means the filter does not accept any documents.
return|return;
block|}
name|int
name|filterDoc
init|=
name|filterIter
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
name|int
name|scorerDoc
init|=
name|scorer
operator|.
name|advance
argument_list|(
name|filterDoc
argument_list|)
decl_stmt|;
name|collector
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|scorerDoc
operator|==
name|filterDoc
condition|)
block|{
comment|// Check if scorer has exhausted, only before collecting.
if|if
condition|(
name|scorerDoc
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
break|break;
block|}
name|collector
operator|.
name|collect
argument_list|(
name|scorerDoc
argument_list|)
expr_stmt|;
name|filterDoc
operator|=
name|filterIter
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
name|scorerDoc
operator|=
name|scorer
operator|.
name|advance
argument_list|(
name|filterDoc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scorerDoc
operator|>
name|filterDoc
condition|)
block|{
name|filterDoc
operator|=
name|filterIter
operator|.
name|advance
argument_list|(
name|scorerDoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scorerDoc
operator|=
name|scorer
operator|.
name|advance
argument_list|(
name|filterDoc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Expert: called to re-write queries into primitive queries.    * @throws BooleanQuery.TooManyClauses    */
DECL|method|rewrite
specifier|public
name|Query
name|rewrite
parameter_list|(
name|Query
name|original
parameter_list|)
throws|throws
name|IOException
block|{
name|Query
name|query
init|=
name|original
decl_stmt|;
for|for
control|(
name|Query
name|rewrittenQuery
init|=
name|query
operator|.
name|rewrite
argument_list|(
name|reader
argument_list|)
init|;
name|rewrittenQuery
operator|!=
name|query
condition|;
name|rewrittenQuery
operator|=
name|query
operator|.
name|rewrite
argument_list|(
name|reader
argument_list|)
control|)
block|{
name|query
operator|=
name|rewrittenQuery
expr_stmt|;
block|}
return|return
name|query
return|;
block|}
comment|/** Returns an Explanation that describes how<code>doc</code> scored against    *<code>query</code>.    *    *<p>This is intended to be used in developing Similarity implementations,    * and, for good performance, should not be displayed with every hit.    * Computing an explanation is as expensive as executing the query over the    * entire index.    */
DECL|method|explain
specifier|public
name|Explanation
name|explain
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|explain
argument_list|(
name|createWeight
argument_list|(
name|query
argument_list|)
argument_list|,
name|doc
argument_list|)
return|;
block|}
comment|/** Expert: low-level implementation method    * Returns an Explanation that describes how<code>doc</code> scored against    *<code>weight</code>.    *    *<p>This is intended to be used in developing Similarity implementations,    * and, for good performance, should not be displayed with every hit.    * Computing an explanation is as expensive as executing the query over the    * entire index.    *<p>Applications should call {@link IndexSearcher#explain(Query, int)}.    * @throws BooleanQuery.TooManyClauses    */
DECL|method|explain
specifier|protected
name|Explanation
name|explain
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|n
init|=
name|ReaderUtil
operator|.
name|subIndex
argument_list|(
name|doc
argument_list|,
name|leafContexts
argument_list|)
decl_stmt|;
name|int
name|deBasedDoc
init|=
name|doc
operator|-
name|leafContexts
index|[
name|n
index|]
operator|.
name|docBase
decl_stmt|;
return|return
name|weight
operator|.
name|explain
argument_list|(
name|leafContexts
index|[
name|n
index|]
argument_list|,
name|deBasedDoc
argument_list|)
return|;
block|}
DECL|field|fieldSortDoTrackScores
specifier|private
name|boolean
name|fieldSortDoTrackScores
decl_stmt|;
DECL|field|fieldSortDoMaxScore
specifier|private
name|boolean
name|fieldSortDoMaxScore
decl_stmt|;
comment|/** By default, no scores are computed when sorting by    *  field (using {@link #search(Query,Filter,int,Sort)}).    *  You can change that, per IndexSearcher instance, by    *  calling this method.  Note that this will incur a CPU    *  cost.    *     *  @param doTrackScores If true, then scores are    *  returned for every matching document in {@link    *  TopFieldDocs}.    *    *  @param doMaxScore If true, then the max score for all    *  matching docs is computed. */
DECL|method|setDefaultFieldSortScoring
specifier|public
name|void
name|setDefaultFieldSortScoring
parameter_list|(
name|boolean
name|doTrackScores
parameter_list|,
name|boolean
name|doMaxScore
parameter_list|)
block|{
name|fieldSortDoTrackScores
operator|=
name|doTrackScores
expr_stmt|;
name|fieldSortDoMaxScore
operator|=
name|doMaxScore
expr_stmt|;
block|}
comment|/**    * creates a weight for<code>query</code>    * @return new weight    */
DECL|method|createWeight
specifier|protected
name|Weight
name|createWeight
parameter_list|(
name|Query
name|query
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|query
operator|.
name|weight
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Returns this searchers the top-level {@link ReaderContext}.    * @see IndexReader#getTopReaderContext()    */
comment|/* Sugar for .getIndexReader().getTopReaderContext() */
DECL|method|getTopReaderContext
specifier|public
name|ReaderContext
name|getTopReaderContext
parameter_list|()
block|{
return|return
name|readerContext
return|;
block|}
comment|/**    * A thread subclass for searching a single searchable     */
DECL|class|SearcherCallableNoSort
specifier|private
specifier|static
specifier|final
class|class
name|SearcherCallableNoSort
implements|implements
name|Callable
argument_list|<
name|TopDocs
argument_list|>
block|{
DECL|field|lock
specifier|private
specifier|final
name|Lock
name|lock
decl_stmt|;
DECL|field|searchable
specifier|private
specifier|final
name|IndexSearcher
name|searchable
decl_stmt|;
DECL|field|weight
specifier|private
specifier|final
name|Weight
name|weight
decl_stmt|;
DECL|field|filter
specifier|private
specifier|final
name|Filter
name|filter
decl_stmt|;
DECL|field|nDocs
specifier|private
specifier|final
name|int
name|nDocs
decl_stmt|;
DECL|field|hq
specifier|private
specifier|final
name|HitQueue
name|hq
decl_stmt|;
DECL|method|SearcherCallableNoSort
specifier|public
name|SearcherCallableNoSort
parameter_list|(
name|Lock
name|lock
parameter_list|,
name|IndexSearcher
name|searchable
parameter_list|,
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|nDocs
parameter_list|,
name|HitQueue
name|hq
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|=
name|lock
expr_stmt|;
name|this
operator|.
name|searchable
operator|=
name|searchable
expr_stmt|;
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
name|this
operator|.
name|nDocs
operator|=
name|nDocs
expr_stmt|;
name|this
operator|.
name|hq
operator|=
name|hq
expr_stmt|;
block|}
DECL|method|call
specifier|public
name|TopDocs
name|call
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|TopDocs
name|docs
init|=
name|searchable
operator|.
name|search
argument_list|(
name|weight
argument_list|,
name|filter
argument_list|,
name|nDocs
argument_list|)
decl_stmt|;
specifier|final
name|ScoreDoc
index|[]
name|scoreDocs
init|=
name|docs
operator|.
name|scoreDocs
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|scoreDocs
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
comment|// merge scoreDocs into hq
specifier|final
name|ScoreDoc
name|scoreDoc
init|=
name|scoreDocs
index|[
name|j
index|]
decl_stmt|;
comment|//it would be so nice if we had a thread-safe insert
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|scoreDoc
operator|==
name|hq
operator|.
name|insertWithOverflow
argument_list|(
name|scoreDoc
argument_list|)
condition|)
break|break;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|docs
return|;
block|}
block|}
comment|/**    * A thread subclass for searching a single searchable     */
DECL|class|SearcherCallableWithSort
specifier|private
specifier|static
specifier|final
class|class
name|SearcherCallableWithSort
implements|implements
name|Callable
argument_list|<
name|TopFieldDocs
argument_list|>
block|{
DECL|field|lock
specifier|private
specifier|final
name|Lock
name|lock
decl_stmt|;
DECL|field|searchable
specifier|private
specifier|final
name|IndexSearcher
name|searchable
decl_stmt|;
DECL|field|weight
specifier|private
specifier|final
name|Weight
name|weight
decl_stmt|;
DECL|field|filter
specifier|private
specifier|final
name|Filter
name|filter
decl_stmt|;
DECL|field|nDocs
specifier|private
specifier|final
name|int
name|nDocs
decl_stmt|;
DECL|field|hq
specifier|private
specifier|final
name|FieldDocSortedHitQueue
name|hq
decl_stmt|;
DECL|field|sort
specifier|private
specifier|final
name|Sort
name|sort
decl_stmt|;
DECL|method|SearcherCallableWithSort
specifier|public
name|SearcherCallableWithSort
parameter_list|(
name|Lock
name|lock
parameter_list|,
name|IndexSearcher
name|searchable
parameter_list|,
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|nDocs
parameter_list|,
name|FieldDocSortedHitQueue
name|hq
parameter_list|,
name|Sort
name|sort
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|=
name|lock
expr_stmt|;
name|this
operator|.
name|searchable
operator|=
name|searchable
expr_stmt|;
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
name|this
operator|.
name|nDocs
operator|=
name|nDocs
expr_stmt|;
name|this
operator|.
name|hq
operator|=
name|hq
expr_stmt|;
name|this
operator|.
name|sort
operator|=
name|sort
expr_stmt|;
block|}
DECL|method|call
specifier|public
name|TopFieldDocs
name|call
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|TopFieldDocs
name|docs
init|=
name|searchable
operator|.
name|search
argument_list|(
name|weight
argument_list|,
name|filter
argument_list|,
name|nDocs
argument_list|,
name|sort
argument_list|)
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|hq
operator|.
name|setFields
argument_list|(
name|docs
operator|.
name|fields
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
specifier|final
name|ScoreDoc
index|[]
name|scoreDocs
init|=
name|docs
operator|.
name|scoreDocs
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|scoreDocs
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
comment|// merge scoreDocs into hq
specifier|final
name|FieldDoc
name|fieldDoc
init|=
operator|(
name|FieldDoc
operator|)
name|scoreDocs
index|[
name|j
index|]
decl_stmt|;
comment|//it would be so nice if we had a thread-safe insert
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|fieldDoc
operator|==
name|hq
operator|.
name|insertWithOverflow
argument_list|(
name|fieldDoc
argument_list|)
condition|)
break|break;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|docs
return|;
block|}
block|}
comment|/**    * A helper class that wraps a {@link CompletionService} and provides an    * iterable interface to the completed {@link Callable} instances.    *     * @param<T>    *          the type of the {@link Callable} return value    */
DECL|class|ExecutionHelper
specifier|private
specifier|static
specifier|final
class|class
name|ExecutionHelper
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Iterator
argument_list|<
name|T
argument_list|>
implements|,
name|Iterable
argument_list|<
name|T
argument_list|>
block|{
DECL|field|service
specifier|private
specifier|final
name|CompletionService
argument_list|<
name|T
argument_list|>
name|service
decl_stmt|;
DECL|field|numTasks
specifier|private
name|int
name|numTasks
decl_stmt|;
DECL|method|ExecutionHelper
name|ExecutionHelper
parameter_list|(
specifier|final
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|service
operator|=
operator|new
name|ExecutorCompletionService
argument_list|<
name|T
argument_list|>
argument_list|(
name|executor
argument_list|)
expr_stmt|;
block|}
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|numTasks
operator|>
literal|0
return|;
block|}
DECL|method|submit
specifier|public
name|void
name|submit
parameter_list|(
name|Callable
argument_list|<
name|T
argument_list|>
name|task
parameter_list|)
block|{
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
name|task
argument_list|)
expr_stmt|;
operator|++
name|numTasks
expr_stmt|;
block|}
DECL|method|next
specifier|public
name|T
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|hasNext
argument_list|()
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
try|try
block|{
return|return
name|service
operator|.
name|take
argument_list|()
operator|.
name|get
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ThreadInterruptedException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
operator|--
name|numTasks
expr_stmt|;
block|}
block|}
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
comment|// use the shortcut here - this is only used in a privat context
return|return
name|this
return|;
block|}
block|}
block|}
end_class
end_unit
