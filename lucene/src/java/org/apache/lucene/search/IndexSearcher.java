begin_unit
begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletionService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorCompletionService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CorruptIndexException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
operator|.
name|AtomicReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
operator|.
name|ReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StoredFieldVisitor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Weight
operator|.
name|ScorerContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|DefaultSimilarityProvider
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|SimilarityProvider
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|NIOFSDirectory
import|;
end_import
begin_comment
comment|// javadoc
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ReaderUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ThreadInterruptedException
import|;
end_import
begin_comment
comment|/** Implements search over a single IndexReader.  *  *<p>Applications usually need only call the inherited  * {@link #search(Query,int)}  * or {@link #search(Query,Filter,int)} methods. For  * performance reasons, if your index is unchanging, you  * should share a single IndexSearcher instance across  * multiple searches instead of creating a new one  * per-search.  If your index has changed and you wish to  * see the changes reflected in searching, you should  * use {@link IndexReader#reopen} to obtain a new reader and  * then create a new IndexSearcher from that.  Also, for  * low-latency turnaround it's best to use a near-real-time  * reader ({@link IndexReader#open(IndexWriter,boolean)}).  * Once you have a new {@link IndexReader}, it's relatively  * cheap to create a new IndexSearcher from it.  *   *<a name="thread-safety"></a><p><b>NOTE</b>:<code>{@link  * IndexSearcher}</code> instances are completely  * thread safe, meaning multiple threads can call any of its  * methods, concurrently.  If your application requires  * external synchronization, you should<b>not</b>  * synchronize on the<code>IndexSearcher</code> instance;  * use your own (non-Lucene) objects instead.</p>  */
end_comment
begin_class
DECL|class|IndexSearcher
specifier|public
class|class
name|IndexSearcher
implements|implements
name|Closeable
block|{
DECL|field|reader
specifier|final
name|IndexReader
name|reader
decl_stmt|;
comment|// package private for testing!
DECL|field|closeReader
specifier|private
name|boolean
name|closeReader
decl_stmt|;
comment|// NOTE: these members might change in incompatible ways
comment|// in the next release
DECL|field|readerContext
specifier|protected
specifier|final
name|ReaderContext
name|readerContext
decl_stmt|;
DECL|field|leafContexts
specifier|protected
specifier|final
name|AtomicReaderContext
index|[]
name|leafContexts
decl_stmt|;
comment|// used with executor - each slice holds a set of leafs executed within one thread
DECL|field|leafSlices
specifier|protected
specifier|final
name|LeafSlice
index|[]
name|leafSlices
decl_stmt|;
comment|// These are only used for multi-threaded search
DECL|field|executor
specifier|private
specifier|final
name|ExecutorService
name|executor
decl_stmt|;
comment|// the default SimilarityProvider
DECL|field|defaultProvider
specifier|private
specifier|static
specifier|final
name|SimilarityProvider
name|defaultProvider
init|=
operator|new
name|DefaultSimilarityProvider
argument_list|()
decl_stmt|;
comment|/**    * Expert: returns a default SimilarityProvider instance.    * In general, this method is only called to initialize searchers and writers.    * User code and query implementations should respect    * {@link IndexSearcher#getSimilarityProvider()}.    * @lucene.internal    */
DECL|method|getDefaultSimilarityProvider
specifier|public
specifier|static
name|SimilarityProvider
name|getDefaultSimilarityProvider
parameter_list|()
block|{
return|return
name|defaultProvider
return|;
block|}
comment|/** The SimilarityProvider implementation used by this searcher. */
DECL|field|similarityProvider
specifier|private
name|SimilarityProvider
name|similarityProvider
init|=
name|defaultProvider
decl_stmt|;
comment|/** Creates a searcher searching the index in the named    *  directory, with readOnly=true    * @param path directory where IndexReader will be opened    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|Directory
name|path
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|this
argument_list|(
name|IndexReader
operator|.
name|open
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a searcher searching the index in the named    *  directory.  You should pass readOnly=true, since it    *  gives much better concurrent performance, unless you    *  intend to do write operations (delete documents or    *  change norms) with the underlying IndexReader.    * @param path directory where IndexReader will be opened    * @param readOnly if true, the underlying IndexReader    * will be opened readOnly    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|Directory
name|path
parameter_list|,
name|boolean
name|readOnly
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|this
argument_list|(
name|IndexReader
operator|.
name|open
argument_list|(
name|path
argument_list|,
name|readOnly
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a searcher searching the provided index. */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|IndexReader
name|r
parameter_list|)
block|{
name|this
argument_list|(
name|r
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/** Runs searches for each segment separately, using the    *  provided ExecutorService.  IndexSearcher will not    *  shutdown/awaitTermination this ExecutorService on    *  close; you must do so, eventually, on your own.  NOTE:    *  if you are using {@link NIOFSDirectory}, do not use    *  the shutdownNow method of ExecutorService as this uses    *  Thread.interrupt under-the-hood which can silently    *  close file descriptors (see<a    *  href="https://issues.apache.org/jira/browse/LUCENE-2239">LUCENE-2239</a>).    *     * @lucene.experimental */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|IndexReader
name|r
parameter_list|,
name|ExecutorService
name|executor
parameter_list|)
block|{
name|this
argument_list|(
name|r
argument_list|,
literal|false
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a searcher searching the provided top-level {@link ReaderContext}.    *<p>    * Given a non-<code>null</code> {@link ExecutorService} this method runs    * searches for each segment separately, using the provided ExecutorService.    * IndexSearcher will not shutdown/awaitTermination this ExecutorService on    * close; you must do so, eventually, on your own. NOTE: if you are using    * {@link NIOFSDirectory}, do not use the shutdownNow method of    * ExecutorService as this uses Thread.interrupt under-the-hood which can    * silently close file descriptors (see<a    * href="https://issues.apache.org/jira/browse/LUCENE-2239">LUCENE-2239</a>).    *     * @see ReaderContext    * @see IndexReader#getTopReaderContext()    * @lucene.experimental    */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|ReaderContext
name|context
parameter_list|,
name|ExecutorService
name|executor
parameter_list|)
block|{
name|this
argument_list|(
name|context
argument_list|,
literal|false
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a searcher searching the provided top-level {@link ReaderContext}.    *    * @see ReaderContext    * @see IndexReader#getTopReaderContext()    * @lucene.experimental    */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|ReaderContext
name|context
parameter_list|)
block|{
name|this
argument_list|(
name|context
argument_list|,
operator|(
name|ExecutorService
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// convenience ctor for other IR based ctors
DECL|method|IndexSearcher
specifier|private
name|IndexSearcher
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|boolean
name|closeReader
parameter_list|,
name|ExecutorService
name|executor
parameter_list|)
block|{
name|this
argument_list|(
name|reader
operator|.
name|getTopReaderContext
argument_list|()
argument_list|,
name|closeReader
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
DECL|method|IndexSearcher
specifier|private
name|IndexSearcher
parameter_list|(
name|ReaderContext
name|context
parameter_list|,
name|boolean
name|closeReader
parameter_list|,
name|ExecutorService
name|executor
parameter_list|)
block|{
assert|assert
name|context
operator|.
name|isTopLevel
operator|:
literal|"IndexSearcher's ReaderContext must be topLevel for reader"
operator|+
name|context
operator|.
name|reader
assert|;
name|reader
operator|=
name|context
operator|.
name|reader
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
name|this
operator|.
name|closeReader
operator|=
name|closeReader
expr_stmt|;
name|this
operator|.
name|readerContext
operator|=
name|context
expr_stmt|;
name|leafContexts
operator|=
name|ReaderUtil
operator|.
name|leaves
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|this
operator|.
name|leafSlices
operator|=
name|executor
operator|==
literal|null
condition|?
literal|null
else|:
name|slices
argument_list|(
name|leafContexts
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expert: Creates an array of leaf slices each holding a subset of the given leaves.    * Each {@link LeafSlice} is executed in a single thread. By default there    * will be one {@link LeafSlice} per leaf ({@link AtomicReaderContext}).    */
DECL|method|slices
specifier|protected
name|LeafSlice
index|[]
name|slices
parameter_list|(
name|AtomicReaderContext
modifier|...
name|leaves
parameter_list|)
block|{
name|LeafSlice
index|[]
name|slices
init|=
operator|new
name|LeafSlice
index|[
name|leaves
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|slices
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|slices
index|[
name|i
index|]
operator|=
operator|new
name|LeafSlice
argument_list|(
name|leaves
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|slices
return|;
block|}
comment|/** Return the {@link IndexReader} this searches. */
DECL|method|getIndexReader
specifier|public
name|IndexReader
name|getIndexReader
parameter_list|()
block|{
return|return
name|reader
return|;
block|}
comment|/** Expert: Returns one greater than the largest possible document number.    *     * @see org.apache.lucene.index.IndexReader#maxDoc()    */
DECL|method|maxDoc
specifier|public
name|int
name|maxDoc
parameter_list|()
block|{
return|return
name|reader
operator|.
name|maxDoc
argument_list|()
return|;
block|}
comment|/** Returns total docFreq for this term. */
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|(
specifier|final
name|Term
name|term
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
block|{
return|return
name|reader
operator|.
name|docFreq
argument_list|(
name|term
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|ExecutionHelper
argument_list|<
name|Integer
argument_list|>
name|runner
init|=
operator|new
name|ExecutionHelper
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|executor
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leafContexts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|IndexReader
name|leaf
init|=
name|leafContexts
index|[
name|i
index|]
operator|.
name|reader
decl_stmt|;
name|runner
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|Integer
name|call
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Integer
operator|.
name|valueOf
argument_list|(
name|leaf
operator|.
name|docFreq
argument_list|(
name|term
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|int
name|docFreq
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Integer
name|num
range|:
name|runner
control|)
block|{
name|docFreq
operator|+=
name|num
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
return|return
name|docFreq
return|;
block|}
block|}
comment|/* Sugar for<code>.getIndexReader().document(docID)</code> */
DECL|method|doc
specifier|public
name|Document
name|doc
parameter_list|(
name|int
name|docID
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
return|return
name|reader
operator|.
name|document
argument_list|(
name|docID
argument_list|)
return|;
block|}
comment|/* Sugar for<code>.getIndexReader().document(docID, fieldVisitor)</code> */
DECL|method|doc
specifier|public
name|void
name|doc
parameter_list|(
name|int
name|docID
parameter_list|,
name|StoredFieldVisitor
name|fieldVisitor
parameter_list|)
throws|throws
name|CorruptIndexException
throws|,
name|IOException
block|{
name|reader
operator|.
name|document
argument_list|(
name|docID
argument_list|,
name|fieldVisitor
argument_list|)
expr_stmt|;
block|}
comment|/** Expert: Set the SimilarityProvider implementation used by this Searcher.    *    */
DECL|method|setSimilarityProvider
specifier|public
name|void
name|setSimilarityProvider
parameter_list|(
name|SimilarityProvider
name|similarityProvider
parameter_list|)
block|{
name|this
operator|.
name|similarityProvider
operator|=
name|similarityProvider
expr_stmt|;
block|}
DECL|method|getSimilarityProvider
specifier|public
name|SimilarityProvider
name|getSimilarityProvider
parameter_list|()
block|{
return|return
name|similarityProvider
return|;
block|}
comment|/**    * Note that the underlying IndexReader is not closed, if    * IndexSearcher was constructed with IndexSearcher(IndexReader r).    * If the IndexReader was supplied implicitly by specifying a directory, then    * the IndexReader is closed.    */
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closeReader
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Finds the top<code>n</code>    * hits for<code>query</code> where all results are after a previous     * result (<code>after</code>).    *<p>    * By passing the bottom result from a previous page as<code>after</code>,    * this method can be used for efficient 'deep-paging' across potentially    * large result sets.    *    * @throws BooleanQuery.TooManyClauses    */
DECL|method|searchAfter
specifier|public
name|TopDocs
name|searchAfter
parameter_list|(
name|ScoreDoc
name|after
parameter_list|,
name|Query
name|query
parameter_list|,
name|int
name|n
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|searchAfter
argument_list|(
name|after
argument_list|,
name|query
argument_list|,
literal|null
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Finds the top<code>n</code>    * hits for<code>query</code>, applying<code>filter</code> if non-null,    * where all results are after a previous result (<code>after</code>).    *<p>    * By passing the bottom result from a previous page as<code>after</code>,    * this method can be used for efficient 'deep-paging' across potentially    * large result sets.    *    * @throws BooleanQuery.TooManyClauses    */
DECL|method|searchAfter
specifier|public
name|TopDocs
name|searchAfter
parameter_list|(
name|ScoreDoc
name|after
parameter_list|,
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|n
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|createNormalizedWeight
argument_list|(
name|query
argument_list|)
argument_list|,
name|filter
argument_list|,
name|after
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Finds the top<code>n</code>    * hits for<code>query</code>.    *    * @throws BooleanQuery.TooManyClauses    */
DECL|method|search
specifier|public
name|TopDocs
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|n
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Finds the top<code>n</code>    * hits for<code>query</code>, applying<code>filter</code> if non-null.    *    * @throws BooleanQuery.TooManyClauses    */
DECL|method|search
specifier|public
name|TopDocs
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|n
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|createNormalizedWeight
argument_list|(
name|query
argument_list|)
argument_list|,
name|filter
argument_list|,
literal|null
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Lower-level search API.    *    *<p>{@link Collector#collect(int)} is called for every matching    * document.    *<br>Collector-based access to remote indexes is discouraged.    *    *<p>Applications should only use this if they need<i>all</i> of the    * matching documents.  The high-level search API ({@link    * IndexSearcher#search(Query, Filter, int)}) is usually more efficient, as it skips    * non-high-scoring hits.    *    * @param query to match documents    * @param filter if non-null, used to permit documents to be collected.    * @param results to receive hits    * @throws BooleanQuery.TooManyClauses    */
DECL|method|search
specifier|public
name|void
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|Collector
name|results
parameter_list|)
throws|throws
name|IOException
block|{
name|search
argument_list|(
name|leafContexts
argument_list|,
name|createNormalizedWeight
argument_list|(
name|query
argument_list|)
argument_list|,
name|filter
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
comment|/** Lower-level search API.   *   *<p>{@link Collector#collect(int)} is called for every matching document.   *   *<p>Applications should only use this if they need<i>all</i> of the   * matching documents.  The high-level search API ({@link   * IndexSearcher#search(Query, int)}) is usually more efficient, as it skips   * non-high-scoring hits.   *<p>Note: The<code>score</code> passed to this method is a raw score.   * In other words, the score will not necessarily be a float whose value is   * between 0 and 1.   * @throws BooleanQuery.TooManyClauses   */
DECL|method|search
specifier|public
name|void
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|Collector
name|results
parameter_list|)
throws|throws
name|IOException
block|{
name|search
argument_list|(
name|leafContexts
argument_list|,
name|createNormalizedWeight
argument_list|(
name|query
argument_list|)
argument_list|,
literal|null
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
comment|/** Search implementation with arbitrary sorting.  Finds    * the top<code>n</code> hits for<code>query</code>, applying    *<code>filter</code> if non-null, and sorting the hits by the criteria in    *<code>sort</code>.    *     *<p>NOTE: this does not compute scores by default; use    * {@link IndexSearcher#setDefaultFieldSortScoring} to    * enable scoring.    *    * @throws BooleanQuery.TooManyClauses    */
DECL|method|search
specifier|public
name|TopFieldDocs
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|n
parameter_list|,
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|createNormalizedWeight
argument_list|(
name|query
argument_list|)
argument_list|,
name|filter
argument_list|,
name|n
argument_list|,
name|sort
argument_list|)
return|;
block|}
comment|/**    * Search implementation with arbitrary sorting and no filter.    * @param query The query to search for    * @param n Return only the top n results    * @param sort The {@link org.apache.lucene.search.Sort} object    * @return The top docs, sorted according to the supplied {@link org.apache.lucene.search.Sort} instance    * @throws IOException    */
DECL|method|search
specifier|public
name|TopFieldDocs
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|n
parameter_list|,
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|createNormalizedWeight
argument_list|(
name|query
argument_list|)
argument_list|,
literal|null
argument_list|,
name|n
argument_list|,
name|sort
argument_list|)
return|;
block|}
comment|/** Expert: Low-level search implementation.  Finds the top<code>n</code>    * hits for<code>query</code>, applying<code>filter</code> if non-null.    *    *<p>Applications should usually call {@link IndexSearcher#search(Query,int)} or    * {@link IndexSearcher#search(Query,Filter,int)} instead.    * @throws BooleanQuery.TooManyClauses    */
DECL|method|search
specifier|protected
name|TopDocs
name|search
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|ScoreDoc
name|after
parameter_list|,
name|int
name|nDocs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
block|{
return|return
name|search
argument_list|(
name|leafContexts
argument_list|,
name|weight
argument_list|,
name|filter
argument_list|,
name|after
argument_list|,
name|nDocs
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|HitQueue
name|hq
init|=
operator|new
name|HitQueue
argument_list|(
name|nDocs
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|Lock
name|lock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|final
name|ExecutionHelper
argument_list|<
name|TopDocs
argument_list|>
name|runner
init|=
operator|new
name|ExecutionHelper
argument_list|<
name|TopDocs
argument_list|>
argument_list|(
name|executor
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leafSlices
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// search each sub
name|runner
operator|.
name|submit
argument_list|(
operator|new
name|SearcherCallableNoSort
argument_list|(
name|lock
argument_list|,
name|this
argument_list|,
name|leafSlices
index|[
name|i
index|]
argument_list|,
name|weight
argument_list|,
name|filter
argument_list|,
name|after
argument_list|,
name|nDocs
argument_list|,
name|hq
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|totalHits
init|=
literal|0
decl_stmt|;
name|float
name|maxScore
init|=
name|Float
operator|.
name|NEGATIVE_INFINITY
decl_stmt|;
for|for
control|(
specifier|final
name|TopDocs
name|topDocs
range|:
name|runner
control|)
block|{
if|if
condition|(
name|topDocs
operator|.
name|totalHits
operator|!=
literal|0
condition|)
block|{
name|totalHits
operator|+=
name|topDocs
operator|.
name|totalHits
expr_stmt|;
name|maxScore
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxScore
argument_list|,
name|topDocs
operator|.
name|getMaxScore
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|ScoreDoc
index|[]
name|scoreDocs
init|=
operator|new
name|ScoreDoc
index|[
name|hq
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|hq
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
comment|// put docs in array
name|scoreDocs
index|[
name|i
index|]
operator|=
name|hq
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
operator|new
name|TopDocs
argument_list|(
name|totalHits
argument_list|,
name|scoreDocs
argument_list|,
name|maxScore
argument_list|)
return|;
block|}
block|}
comment|/** Expert: Low-level search implementation.  Finds the top<code>n</code>    * hits for<code>query</code>, using the given leaf readers applying<code>filter</code> if non-null.    *    *<p>Applications should usually call {@link IndexSearcher#search(Query,int)} or    * {@link IndexSearcher#search(Query,Filter,int)} instead.    * @throws BooleanQuery.TooManyClauses    */
DECL|method|search
specifier|protected
name|TopDocs
name|search
parameter_list|(
name|AtomicReaderContext
index|[]
name|leaves
parameter_list|,
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|ScoreDoc
name|after
parameter_list|,
name|int
name|nDocs
parameter_list|)
throws|throws
name|IOException
block|{
comment|// single thread
name|int
name|limit
init|=
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
block|{
name|limit
operator|=
literal|1
expr_stmt|;
block|}
name|nDocs
operator|=
name|Math
operator|.
name|min
argument_list|(
name|nDocs
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|TopScoreDocCollector
name|collector
init|=
name|TopScoreDocCollector
operator|.
name|create
argument_list|(
name|nDocs
argument_list|,
name|after
argument_list|,
operator|!
name|weight
operator|.
name|scoresDocsOutOfOrder
argument_list|()
argument_list|)
decl_stmt|;
name|search
argument_list|(
name|leaves
argument_list|,
name|weight
argument_list|,
name|filter
argument_list|,
name|collector
argument_list|)
expr_stmt|;
return|return
name|collector
operator|.
name|topDocs
argument_list|()
return|;
block|}
comment|/** Expert: Low-level search implementation with arbitrary sorting.  Finds    * the top<code>n</code> hits for<code>query</code>, applying    *<code>filter</code> if non-null, and sorting the hits by the criteria in    *<code>sort</code>.    *    *<p>Applications should usually call {@link    * IndexSearcher#search(Query,Filter,int,Sort)} instead.    *     * @throws BooleanQuery.TooManyClauses    */
DECL|method|search
specifier|protected
name|TopFieldDocs
name|search
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
specifier|final
name|int
name|nDocs
parameter_list|,
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|weight
argument_list|,
name|filter
argument_list|,
name|nDocs
argument_list|,
name|sort
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Just like {@link #search(Weight, Filter, int, Sort)}, but you choose    * whether or not the fields in the returned {@link FieldDoc} instances should    * be set by specifying fillFields.    *    *<p>NOTE: this does not compute scores by default.  If you    * need scores, create a {@link TopFieldCollector}    * instance by calling {@link TopFieldCollector#create} and    * then pass that to {@link #search(IndexReader.AtomicReaderContext[], Weight, Filter,    * Collector)}.</p>    */
DECL|method|search
specifier|protected
name|TopFieldDocs
name|search
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|nDocs
parameter_list|,
name|Sort
name|sort
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|sort
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
block|{
comment|// use all leaves here!
return|return
name|search
argument_list|(
name|leafContexts
argument_list|,
name|weight
argument_list|,
name|filter
argument_list|,
name|nDocs
argument_list|,
name|sort
argument_list|,
name|fillFields
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|TopFieldCollector
name|topCollector
init|=
name|TopFieldCollector
operator|.
name|create
argument_list|(
name|sort
argument_list|,
name|nDocs
argument_list|,
name|fillFields
argument_list|,
name|fieldSortDoTrackScores
argument_list|,
name|fieldSortDoMaxScore
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|Lock
name|lock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|final
name|ExecutionHelper
argument_list|<
name|TopFieldDocs
argument_list|>
name|runner
init|=
operator|new
name|ExecutionHelper
argument_list|<
name|TopFieldDocs
argument_list|>
argument_list|(
name|executor
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leafSlices
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// search each leaf slice
name|runner
operator|.
name|submit
argument_list|(
operator|new
name|SearcherCallableWithSort
argument_list|(
name|lock
argument_list|,
name|this
argument_list|,
name|leafSlices
index|[
name|i
index|]
argument_list|,
name|weight
argument_list|,
name|filter
argument_list|,
name|nDocs
argument_list|,
name|topCollector
argument_list|,
name|sort
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|totalHits
init|=
literal|0
decl_stmt|;
name|float
name|maxScore
init|=
name|Float
operator|.
name|NEGATIVE_INFINITY
decl_stmt|;
for|for
control|(
specifier|final
name|TopFieldDocs
name|topFieldDocs
range|:
name|runner
control|)
block|{
if|if
condition|(
name|topFieldDocs
operator|.
name|totalHits
operator|!=
literal|0
condition|)
block|{
name|totalHits
operator|+=
name|topFieldDocs
operator|.
name|totalHits
expr_stmt|;
name|maxScore
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxScore
argument_list|,
name|topFieldDocs
operator|.
name|getMaxScore
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|TopFieldDocs
name|topDocs
init|=
operator|(
name|TopFieldDocs
operator|)
name|topCollector
operator|.
name|topDocs
argument_list|()
decl_stmt|;
return|return
operator|new
name|TopFieldDocs
argument_list|(
name|totalHits
argument_list|,
name|topDocs
operator|.
name|scoreDocs
argument_list|,
name|topDocs
operator|.
name|fields
argument_list|,
name|topDocs
operator|.
name|getMaxScore
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Just like {@link #search(Weight, Filter, int, Sort)}, but you choose    * whether or not the fields in the returned {@link FieldDoc} instances should    * be set by specifying fillFields.    *    *<p>NOTE: this does not compute scores by default.  If you    * need scores, create a {@link TopFieldCollector}    * instance by calling {@link TopFieldCollector#create} and    * then pass that to {@link #search(IndexReader.AtomicReaderContext[], Weight, Filter,    * Collector)}.</p>    */
DECL|method|search
specifier|protected
name|TopFieldDocs
name|search
parameter_list|(
name|AtomicReaderContext
index|[]
name|leaves
parameter_list|,
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|nDocs
parameter_list|,
name|Sort
name|sort
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
throws|throws
name|IOException
block|{
comment|// single thread
name|int
name|limit
init|=
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
block|{
name|limit
operator|=
literal|1
expr_stmt|;
block|}
name|nDocs
operator|=
name|Math
operator|.
name|min
argument_list|(
name|nDocs
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|TopFieldCollector
name|collector
init|=
name|TopFieldCollector
operator|.
name|create
argument_list|(
name|sort
argument_list|,
name|nDocs
argument_list|,
name|fillFields
argument_list|,
name|fieldSortDoTrackScores
argument_list|,
name|fieldSortDoMaxScore
argument_list|,
operator|!
name|weight
operator|.
name|scoresDocsOutOfOrder
argument_list|()
argument_list|)
decl_stmt|;
name|search
argument_list|(
name|leaves
argument_list|,
name|weight
argument_list|,
name|filter
argument_list|,
name|collector
argument_list|)
expr_stmt|;
return|return
operator|(
name|TopFieldDocs
operator|)
name|collector
operator|.
name|topDocs
argument_list|()
return|;
block|}
comment|/**    * Lower-level search API.    *     *<p>    * {@link Collector#collect(int)} is called for every document.<br>    * Collector-based access to remote indexes is discouraged.    *     *<p>    * Applications should only use this if they need<i>all</i> of the matching    * documents. The high-level search API ({@link IndexSearcher#search(Query,int)}) is    * usually more efficient, as it skips non-high-scoring hits.    *     *<p>    * NOTE: this method executes the searches on all given leaves exclusively.    * To search across all the searchers leaves use {@link #leafContexts}.    *     * @param leaves     *          the searchers leaves to execute the searches on    * @param weight    *          to match documents    * @param filter    *          if non-null, used to permit documents to be collected.    * @param collector    *          to receive hits    * @throws BooleanQuery.TooManyClauses    */
DECL|method|search
specifier|protected
name|void
name|search
parameter_list|(
name|AtomicReaderContext
index|[]
name|leaves
parameter_list|,
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|Collector
name|collector
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: should we make this
comment|// threaded...?  the Collector could be sync'd?
name|ScorerContext
name|scorerContext
init|=
name|ScorerContext
operator|.
name|def
argument_list|()
operator|.
name|scoreDocsInOrder
argument_list|(
literal|true
argument_list|)
operator|.
name|topScorer
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|// always use single thread:
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leaves
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// search each subreader
name|collector
operator|.
name|setNextReader
argument_list|(
name|leaves
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|scorerContext
operator|=
name|scorerContext
operator|.
name|scoreDocsInOrder
argument_list|(
operator|!
name|collector
operator|.
name|acceptsDocsOutOfOrder
argument_list|()
argument_list|)
expr_stmt|;
name|Scorer
name|scorer
init|=
name|weight
operator|.
name|scorer
argument_list|(
name|leaves
index|[
name|i
index|]
argument_list|,
name|scorerContext
argument_list|)
decl_stmt|;
if|if
condition|(
name|scorer
operator|!=
literal|null
condition|)
block|{
name|scorer
operator|.
name|score
argument_list|(
name|collector
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leaves
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// search each subreader
name|collector
operator|.
name|setNextReader
argument_list|(
name|leaves
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|searchWithFilter
argument_list|(
name|leaves
index|[
name|i
index|]
argument_list|,
name|weight
argument_list|,
name|filter
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|searchWithFilter
specifier|private
name|void
name|searchWithFilter
parameter_list|(
name|AtomicReaderContext
name|context
parameter_list|,
name|Weight
name|weight
parameter_list|,
specifier|final
name|Filter
name|filter
parameter_list|,
specifier|final
name|Collector
name|collector
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|filter
operator|!=
literal|null
assert|;
name|Scorer
name|scorer
init|=
name|weight
operator|.
name|scorer
argument_list|(
name|context
argument_list|,
name|ScorerContext
operator|.
name|def
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|scorer
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|int
name|docID
init|=
name|scorer
operator|.
name|docID
argument_list|()
decl_stmt|;
assert|assert
name|docID
operator|==
operator|-
literal|1
operator|||
name|docID
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
assert|;
comment|// CHECKME: use ConjunctionScorer here?
name|DocIdSet
name|filterDocIdSet
init|=
name|filter
operator|.
name|getDocIdSet
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|filterDocIdSet
operator|==
literal|null
condition|)
block|{
comment|// this means the filter does not accept any documents.
return|return;
block|}
name|DocIdSetIterator
name|filterIter
init|=
name|filterDocIdSet
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|filterIter
operator|==
literal|null
condition|)
block|{
comment|// this means the filter does not accept any documents.
return|return;
block|}
name|int
name|filterDoc
init|=
name|filterIter
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
name|int
name|scorerDoc
init|=
name|scorer
operator|.
name|advance
argument_list|(
name|filterDoc
argument_list|)
decl_stmt|;
name|collector
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|scorerDoc
operator|==
name|filterDoc
condition|)
block|{
comment|// Check if scorer has exhausted, only before collecting.
if|if
condition|(
name|scorerDoc
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
break|break;
block|}
name|collector
operator|.
name|collect
argument_list|(
name|scorerDoc
argument_list|)
expr_stmt|;
name|filterDoc
operator|=
name|filterIter
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
name|scorerDoc
operator|=
name|scorer
operator|.
name|advance
argument_list|(
name|filterDoc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scorerDoc
operator|>
name|filterDoc
condition|)
block|{
name|filterDoc
operator|=
name|filterIter
operator|.
name|advance
argument_list|(
name|scorerDoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scorerDoc
operator|=
name|scorer
operator|.
name|advance
argument_list|(
name|filterDoc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Expert: called to re-write queries into primitive queries.    * @throws BooleanQuery.TooManyClauses    */
DECL|method|rewrite
specifier|public
name|Query
name|rewrite
parameter_list|(
name|Query
name|original
parameter_list|)
throws|throws
name|IOException
block|{
name|Query
name|query
init|=
name|original
decl_stmt|;
for|for
control|(
name|Query
name|rewrittenQuery
init|=
name|query
operator|.
name|rewrite
argument_list|(
name|reader
argument_list|)
init|;
name|rewrittenQuery
operator|!=
name|query
condition|;
name|rewrittenQuery
operator|=
name|query
operator|.
name|rewrite
argument_list|(
name|reader
argument_list|)
control|)
block|{
name|query
operator|=
name|rewrittenQuery
expr_stmt|;
block|}
return|return
name|query
return|;
block|}
comment|/** Returns an Explanation that describes how<code>doc</code> scored against    *<code>query</code>.    *    *<p>This is intended to be used in developing Similarity implementations,    * and, for good performance, should not be displayed with every hit.    * Computing an explanation is as expensive as executing the query over the    * entire index.    */
DECL|method|explain
specifier|public
name|Explanation
name|explain
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|explain
argument_list|(
name|createNormalizedWeight
argument_list|(
name|query
argument_list|)
argument_list|,
name|doc
argument_list|)
return|;
block|}
comment|/** Expert: low-level implementation method    * Returns an Explanation that describes how<code>doc</code> scored against    *<code>weight</code>.    *    *<p>This is intended to be used in developing Similarity implementations,    * and, for good performance, should not be displayed with every hit.    * Computing an explanation is as expensive as executing the query over the    * entire index.    *<p>Applications should call {@link IndexSearcher#explain(Query, int)}.    * @throws BooleanQuery.TooManyClauses    */
DECL|method|explain
specifier|protected
name|Explanation
name|explain
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|n
init|=
name|ReaderUtil
operator|.
name|subIndex
argument_list|(
name|doc
argument_list|,
name|leafContexts
argument_list|)
decl_stmt|;
name|int
name|deBasedDoc
init|=
name|doc
operator|-
name|leafContexts
index|[
name|n
index|]
operator|.
name|docBase
decl_stmt|;
return|return
name|weight
operator|.
name|explain
argument_list|(
name|leafContexts
index|[
name|n
index|]
argument_list|,
name|deBasedDoc
argument_list|)
return|;
block|}
DECL|field|fieldSortDoTrackScores
specifier|private
name|boolean
name|fieldSortDoTrackScores
decl_stmt|;
DECL|field|fieldSortDoMaxScore
specifier|private
name|boolean
name|fieldSortDoMaxScore
decl_stmt|;
comment|/** By default, no scores are computed when sorting by    *  field (using {@link #search(Query,Filter,int,Sort)}).    *  You can change that, per IndexSearcher instance, by    *  calling this method.  Note that this will incur a CPU    *  cost.    *     *  @param doTrackScores If true, then scores are    *  returned for every matching document in {@link    *  TopFieldDocs}.    *    *  @param doMaxScore If true, then the max score for all    *  matching docs is computed. */
DECL|method|setDefaultFieldSortScoring
specifier|public
name|void
name|setDefaultFieldSortScoring
parameter_list|(
name|boolean
name|doTrackScores
parameter_list|,
name|boolean
name|doMaxScore
parameter_list|)
block|{
name|fieldSortDoTrackScores
operator|=
name|doTrackScores
expr_stmt|;
name|fieldSortDoMaxScore
operator|=
name|doMaxScore
expr_stmt|;
block|}
comment|/**    * Creates a normalized weight for a top-level {@link Query}.    * The query is rewritten by this method and {@link Query#createWeight} called,    * afterwards the {@link Weight} is normalized. The returned {@code Weight}    * can then directly be used to get a {@link Scorer}.    * @lucene.internal    */
DECL|method|createNormalizedWeight
specifier|public
name|Weight
name|createNormalizedWeight
parameter_list|(
name|Query
name|query
parameter_list|)
throws|throws
name|IOException
block|{
name|query
operator|=
name|rewrite
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|Weight
name|weight
init|=
name|query
operator|.
name|createWeight
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|float
name|v
init|=
name|weight
operator|.
name|getValueForNormalization
argument_list|()
decl_stmt|;
name|float
name|norm
init|=
name|getSimilarityProvider
argument_list|()
operator|.
name|queryNorm
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|Float
operator|.
name|isInfinite
argument_list|(
name|norm
argument_list|)
operator|||
name|Float
operator|.
name|isNaN
argument_list|(
name|norm
argument_list|)
condition|)
name|norm
operator|=
literal|1.0f
expr_stmt|;
name|weight
operator|.
name|normalize
argument_list|(
name|norm
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
return|return
name|weight
return|;
block|}
comment|/**    * Returns this searchers the top-level {@link ReaderContext}.    * @see IndexReader#getTopReaderContext()    */
comment|/* sugar for #getReader().getTopReaderContext() */
DECL|method|getTopReaderContext
specifier|public
name|ReaderContext
name|getTopReaderContext
parameter_list|()
block|{
return|return
name|readerContext
return|;
block|}
comment|/**    * A thread subclass for searching a single searchable     */
DECL|class|SearcherCallableNoSort
specifier|private
specifier|static
specifier|final
class|class
name|SearcherCallableNoSort
implements|implements
name|Callable
argument_list|<
name|TopDocs
argument_list|>
block|{
DECL|field|lock
specifier|private
specifier|final
name|Lock
name|lock
decl_stmt|;
DECL|field|searcher
specifier|private
specifier|final
name|IndexSearcher
name|searcher
decl_stmt|;
DECL|field|weight
specifier|private
specifier|final
name|Weight
name|weight
decl_stmt|;
DECL|field|filter
specifier|private
specifier|final
name|Filter
name|filter
decl_stmt|;
DECL|field|after
specifier|private
specifier|final
name|ScoreDoc
name|after
decl_stmt|;
DECL|field|nDocs
specifier|private
specifier|final
name|int
name|nDocs
decl_stmt|;
DECL|field|hq
specifier|private
specifier|final
name|HitQueue
name|hq
decl_stmt|;
DECL|field|slice
specifier|private
specifier|final
name|LeafSlice
name|slice
decl_stmt|;
DECL|method|SearcherCallableNoSort
specifier|public
name|SearcherCallableNoSort
parameter_list|(
name|Lock
name|lock
parameter_list|,
name|IndexSearcher
name|searcher
parameter_list|,
name|LeafSlice
name|slice
parameter_list|,
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|ScoreDoc
name|after
parameter_list|,
name|int
name|nDocs
parameter_list|,
name|HitQueue
name|hq
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|=
name|lock
expr_stmt|;
name|this
operator|.
name|searcher
operator|=
name|searcher
expr_stmt|;
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
name|this
operator|.
name|after
operator|=
name|after
expr_stmt|;
name|this
operator|.
name|nDocs
operator|=
name|nDocs
expr_stmt|;
name|this
operator|.
name|hq
operator|=
name|hq
expr_stmt|;
name|this
operator|.
name|slice
operator|=
name|slice
expr_stmt|;
block|}
DECL|method|call
specifier|public
name|TopDocs
name|call
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|TopDocs
name|docs
init|=
name|searcher
operator|.
name|search
argument_list|(
name|slice
operator|.
name|leaves
argument_list|,
name|weight
argument_list|,
name|filter
argument_list|,
name|after
argument_list|,
name|nDocs
argument_list|)
decl_stmt|;
specifier|final
name|ScoreDoc
index|[]
name|scoreDocs
init|=
name|docs
operator|.
name|scoreDocs
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|scoreDocs
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
comment|// merge scoreDocs into hq
specifier|final
name|ScoreDoc
name|scoreDoc
init|=
name|scoreDocs
index|[
name|j
index|]
decl_stmt|;
comment|//it would be so nice if we had a thread-safe insert
if|if
condition|(
name|scoreDoc
operator|==
name|hq
operator|.
name|insertWithOverflow
argument_list|(
name|scoreDoc
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|docs
return|;
block|}
block|}
comment|/**    * A thread subclass for searching a single searchable     */
DECL|class|SearcherCallableWithSort
specifier|private
specifier|static
specifier|final
class|class
name|SearcherCallableWithSort
implements|implements
name|Callable
argument_list|<
name|TopFieldDocs
argument_list|>
block|{
DECL|field|lock
specifier|private
specifier|final
name|Lock
name|lock
decl_stmt|;
DECL|field|searcher
specifier|private
specifier|final
name|IndexSearcher
name|searcher
decl_stmt|;
DECL|field|weight
specifier|private
specifier|final
name|Weight
name|weight
decl_stmt|;
DECL|field|filter
specifier|private
specifier|final
name|Filter
name|filter
decl_stmt|;
DECL|field|nDocs
specifier|private
specifier|final
name|int
name|nDocs
decl_stmt|;
DECL|field|hq
specifier|private
specifier|final
name|TopFieldCollector
name|hq
decl_stmt|;
DECL|field|sort
specifier|private
specifier|final
name|Sort
name|sort
decl_stmt|;
DECL|field|slice
specifier|private
specifier|final
name|LeafSlice
name|slice
decl_stmt|;
DECL|method|SearcherCallableWithSort
specifier|public
name|SearcherCallableWithSort
parameter_list|(
name|Lock
name|lock
parameter_list|,
name|IndexSearcher
name|searcher
parameter_list|,
name|LeafSlice
name|slice
parameter_list|,
name|Weight
name|weight
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|nDocs
parameter_list|,
name|TopFieldCollector
name|hq
parameter_list|,
name|Sort
name|sort
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|=
name|lock
expr_stmt|;
name|this
operator|.
name|searcher
operator|=
name|searcher
expr_stmt|;
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
name|this
operator|.
name|nDocs
operator|=
name|nDocs
expr_stmt|;
name|this
operator|.
name|hq
operator|=
name|hq
expr_stmt|;
name|this
operator|.
name|sort
operator|=
name|sort
expr_stmt|;
name|this
operator|.
name|slice
operator|=
name|slice
expr_stmt|;
block|}
DECL|class|FakeScorer
specifier|private
specifier|final
class|class
name|FakeScorer
extends|extends
name|Scorer
block|{
DECL|field|score
name|float
name|score
decl_stmt|;
DECL|field|doc
name|int
name|doc
decl_stmt|;
DECL|method|FakeScorer
specifier|public
name|FakeScorer
parameter_list|()
block|{
name|super
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|float
name|freq
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|score
specifier|public
name|float
name|score
parameter_list|()
block|{
return|return
name|score
return|;
block|}
block|}
DECL|field|fakeScorer
specifier|private
specifier|final
name|FakeScorer
name|fakeScorer
init|=
operator|new
name|FakeScorer
argument_list|()
decl_stmt|;
DECL|method|call
specifier|public
name|TopFieldDocs
name|call
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|slice
operator|.
name|leaves
operator|.
name|length
operator|==
literal|1
assert|;
specifier|final
name|TopFieldDocs
name|docs
init|=
name|searcher
operator|.
name|search
argument_list|(
name|slice
operator|.
name|leaves
argument_list|,
name|weight
argument_list|,
name|filter
argument_list|,
name|nDocs
argument_list|,
name|sort
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|int
name|base
init|=
name|slice
operator|.
name|leaves
index|[
literal|0
index|]
operator|.
name|docBase
decl_stmt|;
name|hq
operator|.
name|setNextReader
argument_list|(
name|slice
operator|.
name|leaves
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|hq
operator|.
name|setScorer
argument_list|(
name|fakeScorer
argument_list|)
expr_stmt|;
for|for
control|(
name|ScoreDoc
name|scoreDoc
range|:
name|docs
operator|.
name|scoreDocs
control|)
block|{
name|fakeScorer
operator|.
name|doc
operator|=
name|scoreDoc
operator|.
name|doc
operator|-
name|base
expr_stmt|;
name|fakeScorer
operator|.
name|score
operator|=
name|scoreDoc
operator|.
name|score
expr_stmt|;
name|hq
operator|.
name|collect
argument_list|(
name|scoreDoc
operator|.
name|doc
operator|-
name|base
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|docs
return|;
block|}
block|}
comment|/**    * A helper class that wraps a {@link CompletionService} and provides an    * iterable interface to the completed {@link Callable} instances.    *     * @param<T>    *          the type of the {@link Callable} return value    */
DECL|class|ExecutionHelper
specifier|private
specifier|static
specifier|final
class|class
name|ExecutionHelper
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Iterator
argument_list|<
name|T
argument_list|>
implements|,
name|Iterable
argument_list|<
name|T
argument_list|>
block|{
DECL|field|service
specifier|private
specifier|final
name|CompletionService
argument_list|<
name|T
argument_list|>
name|service
decl_stmt|;
DECL|field|numTasks
specifier|private
name|int
name|numTasks
decl_stmt|;
DECL|method|ExecutionHelper
name|ExecutionHelper
parameter_list|(
specifier|final
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|service
operator|=
operator|new
name|ExecutorCompletionService
argument_list|<
name|T
argument_list|>
argument_list|(
name|executor
argument_list|)
expr_stmt|;
block|}
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|numTasks
operator|>
literal|0
return|;
block|}
DECL|method|submit
specifier|public
name|void
name|submit
parameter_list|(
name|Callable
argument_list|<
name|T
argument_list|>
name|task
parameter_list|)
block|{
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
name|task
argument_list|)
expr_stmt|;
operator|++
name|numTasks
expr_stmt|;
block|}
DECL|method|next
specifier|public
name|T
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|hasNext
argument_list|()
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
try|try
block|{
return|return
name|service
operator|.
name|take
argument_list|()
operator|.
name|get
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ThreadInterruptedException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
operator|--
name|numTasks
expr_stmt|;
block|}
block|}
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
comment|// use the shortcut here - this is only used in a private context
return|return
name|this
return|;
block|}
block|}
comment|/**    * A class holding a subset of the {@link IndexSearcher}s leaf contexts to be    * executed within a single thread.    *     * @lucene.experimental    */
DECL|class|LeafSlice
specifier|public
specifier|static
class|class
name|LeafSlice
block|{
DECL|field|leaves
specifier|final
name|AtomicReaderContext
index|[]
name|leaves
decl_stmt|;
DECL|method|LeafSlice
specifier|public
name|LeafSlice
parameter_list|(
name|AtomicReaderContext
modifier|...
name|leaves
parameter_list|)
block|{
name|this
operator|.
name|leaves
operator|=
name|leaves
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"IndexSearcher("
operator|+
name|reader
operator|+
literal|"; executor="
operator|+
name|executor
operator|+
literal|")"
return|;
block|}
block|}
end_class
end_unit
