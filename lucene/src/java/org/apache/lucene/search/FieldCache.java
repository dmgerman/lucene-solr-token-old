begin_unit
begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DecimalFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|NumericTokenStream
import|;
end_import
begin_comment
comment|// for javadocs
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|NumericField
import|;
end_import
begin_comment
comment|// for javadocs
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocTermOrds
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|NumericUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|PackedInts
import|;
end_import
begin_comment
comment|/**  * Expert: Maintains caches of term values.  *  *<p>Created: May 19, 2004 11:13:14 AM  *  * @since   lucene 1.4  * @see org.apache.lucene.util.FieldCacheSanityChecker  */
end_comment
begin_interface
DECL|interface|FieldCache
specifier|public
interface|interface
name|FieldCache
block|{
DECL|class|CreationPlaceholder
specifier|public
specifier|static
specifier|final
class|class
name|CreationPlaceholder
block|{
DECL|field|value
name|Object
name|value
decl_stmt|;
block|}
comment|/**    * Hack: When thrown from a Parser (NUMERIC_UTILS_* ones), this stops    * processing terms and returns the current FieldCache    * array.    */
DECL|class|StopFillCacheException
specifier|public
specifier|static
specifier|final
class|class
name|StopFillCacheException
extends|extends
name|RuntimeException
block|{   }
comment|/**    * Marker interface as super-interface to all parsers. It    * is used to specify a custom parser to {@link    * SortField#SortField(String, FieldCache.Parser)}.    */
DECL|interface|Parser
specifier|public
interface|interface
name|Parser
block|{   }
comment|/** Interface to parse bytes from document fields.    * @see FieldCache#getBytes(IndexReader, String, FieldCache.ByteParser, boolean)    */
DECL|interface|ByteParser
specifier|public
interface|interface
name|ByteParser
extends|extends
name|Parser
block|{
comment|/** Return a single Byte representation of this field's value. */
DECL|method|parseByte
specifier|public
name|byte
name|parseByte
parameter_list|(
name|BytesRef
name|term
parameter_list|)
function_decl|;
block|}
comment|/** Interface to parse shorts from document fields.    * @see FieldCache#getShorts(IndexReader, String, FieldCache.ShortParser, boolean)    */
DECL|interface|ShortParser
specifier|public
interface|interface
name|ShortParser
extends|extends
name|Parser
block|{
comment|/** Return a short representation of this field's value. */
DECL|method|parseShort
specifier|public
name|short
name|parseShort
parameter_list|(
name|BytesRef
name|term
parameter_list|)
function_decl|;
block|}
comment|/** Interface to parse ints from document fields.    * @see FieldCache#getInts(IndexReader, String, FieldCache.IntParser, boolean)    */
DECL|interface|IntParser
specifier|public
interface|interface
name|IntParser
extends|extends
name|Parser
block|{
comment|/** Return an integer representation of this field's value. */
DECL|method|parseInt
specifier|public
name|int
name|parseInt
parameter_list|(
name|BytesRef
name|term
parameter_list|)
function_decl|;
block|}
comment|/** Interface to parse floats from document fields.    * @see FieldCache#getFloats(IndexReader, String, FieldCache.FloatParser, boolean)    */
DECL|interface|FloatParser
specifier|public
interface|interface
name|FloatParser
extends|extends
name|Parser
block|{
comment|/** Return an float representation of this field's value. */
DECL|method|parseFloat
specifier|public
name|float
name|parseFloat
parameter_list|(
name|BytesRef
name|term
parameter_list|)
function_decl|;
block|}
comment|/** Interface to parse long from document fields.    * @see FieldCache#getLongs(IndexReader, String, FieldCache.LongParser, boolean)    */
DECL|interface|LongParser
specifier|public
interface|interface
name|LongParser
extends|extends
name|Parser
block|{
comment|/** Return an long representation of this field's value. */
DECL|method|parseLong
specifier|public
name|long
name|parseLong
parameter_list|(
name|BytesRef
name|term
parameter_list|)
function_decl|;
block|}
comment|/** Interface to parse doubles from document fields.    * @see FieldCache#getDoubles(IndexReader, String, FieldCache.DoubleParser, boolean)    */
DECL|interface|DoubleParser
specifier|public
interface|interface
name|DoubleParser
extends|extends
name|Parser
block|{
comment|/** Return an long representation of this field's value. */
DECL|method|parseDouble
specifier|public
name|double
name|parseDouble
parameter_list|(
name|BytesRef
name|term
parameter_list|)
function_decl|;
block|}
comment|/** Expert: The cache used internally by sorting and range query classes. */
DECL|field|DEFAULT
specifier|public
specifier|static
name|FieldCache
name|DEFAULT
init|=
operator|new
name|FieldCacheImpl
argument_list|()
decl_stmt|;
comment|/** The default parser for byte values, which are encoded by {@link Byte#toString(byte)} */
DECL|field|DEFAULT_BYTE_PARSER
specifier|public
specifier|static
specifier|final
name|ByteParser
name|DEFAULT_BYTE_PARSER
init|=
operator|new
name|ByteParser
argument_list|()
block|{
specifier|public
name|byte
name|parseByte
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
comment|// TODO: would be far better to directly parse from
comment|// UTF8 bytes... but really users should use
comment|// NumericField, instead, which already decodes
comment|// directly from byte[]
return|return
name|Byte
operator|.
name|parseByte
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
name|Object
name|readResolve
parameter_list|()
block|{
return|return
name|DEFAULT_BYTE_PARSER
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".DEFAULT_BYTE_PARSER"
return|;
block|}
block|}
decl_stmt|;
comment|/** The default parser for short values, which are encoded by {@link Short#toString(short)} */
DECL|field|DEFAULT_SHORT_PARSER
specifier|public
specifier|static
specifier|final
name|ShortParser
name|DEFAULT_SHORT_PARSER
init|=
operator|new
name|ShortParser
argument_list|()
block|{
specifier|public
name|short
name|parseShort
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
comment|// TODO: would be far better to directly parse from
comment|// UTF8 bytes... but really users should use
comment|// NumericField, instead, which already decodes
comment|// directly from byte[]
return|return
name|Short
operator|.
name|parseShort
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
name|Object
name|readResolve
parameter_list|()
block|{
return|return
name|DEFAULT_SHORT_PARSER
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".DEFAULT_SHORT_PARSER"
return|;
block|}
block|}
decl_stmt|;
comment|/** The default parser for int values, which are encoded by {@link Integer#toString(int)} */
DECL|field|DEFAULT_INT_PARSER
specifier|public
specifier|static
specifier|final
name|IntParser
name|DEFAULT_INT_PARSER
init|=
operator|new
name|IntParser
argument_list|()
block|{
specifier|public
name|int
name|parseInt
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
comment|// TODO: would be far better to directly parse from
comment|// UTF8 bytes... but really users should use
comment|// NumericField, instead, which already decodes
comment|// directly from byte[]
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
name|Object
name|readResolve
parameter_list|()
block|{
return|return
name|DEFAULT_INT_PARSER
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".DEFAULT_INT_PARSER"
return|;
block|}
block|}
decl_stmt|;
comment|/** The default parser for float values, which are encoded by {@link Float#toString(float)} */
DECL|field|DEFAULT_FLOAT_PARSER
specifier|public
specifier|static
specifier|final
name|FloatParser
name|DEFAULT_FLOAT_PARSER
init|=
operator|new
name|FloatParser
argument_list|()
block|{
specifier|public
name|float
name|parseFloat
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
comment|// TODO: would be far better to directly parse from
comment|// UTF8 bytes... but really users should use
comment|// NumericField, instead, which already decodes
comment|// directly from byte[]
return|return
name|Float
operator|.
name|parseFloat
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
name|Object
name|readResolve
parameter_list|()
block|{
return|return
name|DEFAULT_FLOAT_PARSER
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".DEFAULT_FLOAT_PARSER"
return|;
block|}
block|}
decl_stmt|;
comment|/** The default parser for long values, which are encoded by {@link Long#toString(long)} */
DECL|field|DEFAULT_LONG_PARSER
specifier|public
specifier|static
specifier|final
name|LongParser
name|DEFAULT_LONG_PARSER
init|=
operator|new
name|LongParser
argument_list|()
block|{
specifier|public
name|long
name|parseLong
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
comment|// TODO: would be far better to directly parse from
comment|// UTF8 bytes... but really users should use
comment|// NumericField, instead, which already decodes
comment|// directly from byte[]
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
name|Object
name|readResolve
parameter_list|()
block|{
return|return
name|DEFAULT_LONG_PARSER
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".DEFAULT_LONG_PARSER"
return|;
block|}
block|}
decl_stmt|;
comment|/** The default parser for double values, which are encoded by {@link Double#toString(double)} */
DECL|field|DEFAULT_DOUBLE_PARSER
specifier|public
specifier|static
specifier|final
name|DoubleParser
name|DEFAULT_DOUBLE_PARSER
init|=
operator|new
name|DoubleParser
argument_list|()
block|{
specifier|public
name|double
name|parseDouble
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
comment|// TODO: would be far better to directly parse from
comment|// UTF8 bytes... but really users should use
comment|// NumericField, instead, which already decodes
comment|// directly from byte[]
return|return
name|Double
operator|.
name|parseDouble
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
name|Object
name|readResolve
parameter_list|()
block|{
return|return
name|DEFAULT_DOUBLE_PARSER
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".DEFAULT_DOUBLE_PARSER"
return|;
block|}
block|}
decl_stmt|;
comment|/**    * A parser instance for int values encoded by {@link NumericUtils}, e.g. when indexed    * via {@link NumericField}/{@link NumericTokenStream}.    */
DECL|field|NUMERIC_UTILS_INT_PARSER
specifier|public
specifier|static
specifier|final
name|IntParser
name|NUMERIC_UTILS_INT_PARSER
init|=
operator|new
name|IntParser
argument_list|()
block|{
specifier|public
name|int
name|parseInt
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
if|if
condition|(
name|NumericUtils
operator|.
name|getPrefixCodedIntShift
argument_list|(
name|term
argument_list|)
operator|>
literal|0
condition|)
throw|throw
operator|new
name|FieldCacheImpl
operator|.
name|StopFillCacheException
argument_list|()
throw|;
return|return
name|NumericUtils
operator|.
name|prefixCodedToInt
argument_list|(
name|term
argument_list|)
return|;
block|}
specifier|protected
name|Object
name|readResolve
parameter_list|()
block|{
return|return
name|NUMERIC_UTILS_INT_PARSER
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".NUMERIC_UTILS_INT_PARSER"
return|;
block|}
block|}
decl_stmt|;
comment|/**    * A parser instance for float values encoded with {@link NumericUtils}, e.g. when indexed    * via {@link NumericField}/{@link NumericTokenStream}.    */
DECL|field|NUMERIC_UTILS_FLOAT_PARSER
specifier|public
specifier|static
specifier|final
name|FloatParser
name|NUMERIC_UTILS_FLOAT_PARSER
init|=
operator|new
name|FloatParser
argument_list|()
block|{
specifier|public
name|float
name|parseFloat
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
if|if
condition|(
name|NumericUtils
operator|.
name|getPrefixCodedIntShift
argument_list|(
name|term
argument_list|)
operator|>
literal|0
condition|)
throw|throw
operator|new
name|FieldCacheImpl
operator|.
name|StopFillCacheException
argument_list|()
throw|;
return|return
name|NumericUtils
operator|.
name|sortableIntToFloat
argument_list|(
name|NumericUtils
operator|.
name|prefixCodedToInt
argument_list|(
name|term
argument_list|)
argument_list|)
return|;
block|}
specifier|protected
name|Object
name|readResolve
parameter_list|()
block|{
return|return
name|NUMERIC_UTILS_FLOAT_PARSER
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".NUMERIC_UTILS_FLOAT_PARSER"
return|;
block|}
block|}
decl_stmt|;
comment|/**    * A parser instance for long values encoded by {@link NumericUtils}, e.g. when indexed    * via {@link NumericField}/{@link NumericTokenStream}.    */
DECL|field|NUMERIC_UTILS_LONG_PARSER
specifier|public
specifier|static
specifier|final
name|LongParser
name|NUMERIC_UTILS_LONG_PARSER
init|=
operator|new
name|LongParser
argument_list|()
block|{
specifier|public
name|long
name|parseLong
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
if|if
condition|(
name|NumericUtils
operator|.
name|getPrefixCodedLongShift
argument_list|(
name|term
argument_list|)
operator|>
literal|0
condition|)
throw|throw
operator|new
name|FieldCacheImpl
operator|.
name|StopFillCacheException
argument_list|()
throw|;
return|return
name|NumericUtils
operator|.
name|prefixCodedToLong
argument_list|(
name|term
argument_list|)
return|;
block|}
specifier|protected
name|Object
name|readResolve
parameter_list|()
block|{
return|return
name|NUMERIC_UTILS_LONG_PARSER
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".NUMERIC_UTILS_LONG_PARSER"
return|;
block|}
block|}
decl_stmt|;
comment|/**    * A parser instance for double values encoded with {@link NumericUtils}, e.g. when indexed    * via {@link NumericField}/{@link NumericTokenStream}.    */
DECL|field|NUMERIC_UTILS_DOUBLE_PARSER
specifier|public
specifier|static
specifier|final
name|DoubleParser
name|NUMERIC_UTILS_DOUBLE_PARSER
init|=
operator|new
name|DoubleParser
argument_list|()
block|{
specifier|public
name|double
name|parseDouble
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
if|if
condition|(
name|NumericUtils
operator|.
name|getPrefixCodedLongShift
argument_list|(
name|term
argument_list|)
operator|>
literal|0
condition|)
throw|throw
operator|new
name|FieldCacheImpl
operator|.
name|StopFillCacheException
argument_list|()
throw|;
return|return
name|NumericUtils
operator|.
name|sortableLongToDouble
argument_list|(
name|NumericUtils
operator|.
name|prefixCodedToLong
argument_list|(
name|term
argument_list|)
argument_list|)
return|;
block|}
specifier|protected
name|Object
name|readResolve
parameter_list|()
block|{
return|return
name|NUMERIC_UTILS_DOUBLE_PARSER
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".NUMERIC_UTILS_DOUBLE_PARSER"
return|;
block|}
block|}
decl_stmt|;
comment|/** Checks the internal cache for an appropriate entry, and if none is found,    * reads the terms in<code>field</code> and returns a bit set at the size of    *<code>reader.maxDoc()</code>, with turned on bits for each docid that     * does have a value for this field.    */
DECL|method|getDocsWithField
specifier|public
name|Bits
name|getDocsWithField
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if none is    * found, reads the terms in<code>field</code> as a single byte and returns an array    * of size<code>reader.maxDoc()</code> of the value each document    * has in the given field.    * @param reader  Used to get field values.    * @param field   Which field contains the single byte values.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getBytes
specifier|public
name|byte
index|[]
name|getBytes
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if none is found,    * reads the terms in<code>field</code> as bytes and returns an array of    * size<code>reader.maxDoc()</code> of the value each document has in the    * given field.    * @param reader  Used to get field values.    * @param field   Which field contains the bytes.    * @param parser  Computes byte for string values.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getBytes
specifier|public
name|byte
index|[]
name|getBytes
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|ByteParser
name|parser
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if none is    * found, reads the terms in<code>field</code> as shorts and returns an array    * of size<code>reader.maxDoc()</code> of the value each document    * has in the given field.    * @param reader  Used to get field values.    * @param field   Which field contains the shorts.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getShorts
specifier|public
name|short
index|[]
name|getShorts
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if none is found,    * reads the terms in<code>field</code> as shorts and returns an array of    * size<code>reader.maxDoc()</code> of the value each document has in the    * given field.    * @param reader  Used to get field values.    * @param field   Which field contains the shorts.    * @param parser  Computes short for string values.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getShorts
specifier|public
name|short
index|[]
name|getShorts
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|ShortParser
name|parser
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if none is    * found, reads the terms in<code>field</code> as integers and returns an array    * of size<code>reader.maxDoc()</code> of the value each document    * has in the given field.    * @param reader  Used to get field values.    * @param field   Which field contains the integers.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getInts
specifier|public
name|int
index|[]
name|getInts
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if none is found,    * reads the terms in<code>field</code> as integers and returns an array of    * size<code>reader.maxDoc()</code> of the value each document has in the    * given field.    * @param reader  Used to get field values.    * @param field   Which field contains the integers.    * @param parser  Computes integer for string values.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getInts
specifier|public
name|int
index|[]
name|getInts
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|IntParser
name|parser
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if    * none is found, reads the terms in<code>field</code> as floats and returns an array    * of size<code>reader.maxDoc()</code> of the value each document    * has in the given field.    * @param reader  Used to get field values.    * @param field   Which field contains the floats.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getFloats
specifier|public
name|float
index|[]
name|getFloats
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if    * none is found, reads the terms in<code>field</code> as floats and returns an array    * of size<code>reader.maxDoc()</code> of the value each document    * has in the given field.    * @param reader  Used to get field values.    * @param field   Which field contains the floats.    * @param parser  Computes float for string values.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getFloats
specifier|public
name|float
index|[]
name|getFloats
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|FloatParser
name|parser
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Checks the internal cache for an appropriate entry, and if none is    * found, reads the terms in<code>field</code> as longs and returns an array    * of size<code>reader.maxDoc()</code> of the value each document    * has in the given field.    *    * @param reader Used to get field values.    * @param field  Which field contains the longs.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws java.io.IOException If any error occurs.    */
DECL|method|getLongs
specifier|public
name|long
index|[]
name|getLongs
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Checks the internal cache for an appropriate entry, and if none is found,    * reads the terms in<code>field</code> as longs and returns an array of    * size<code>reader.maxDoc()</code> of the value each document has in the    * given field.    *    * @param reader Used to get field values.    * @param field  Which field contains the longs.    * @param parser Computes integer for string values.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException If any error occurs.    */
DECL|method|getLongs
specifier|public
name|long
index|[]
name|getLongs
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|LongParser
name|parser
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Checks the internal cache for an appropriate entry, and if none is    * found, reads the terms in<code>field</code> as integers and returns an array    * of size<code>reader.maxDoc()</code> of the value each document    * has in the given field.    *    * @param reader Used to get field values.    * @param field  Which field contains the doubles.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException If any error occurs.    */
DECL|method|getDoubles
specifier|public
name|double
index|[]
name|getDoubles
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Checks the internal cache for an appropriate entry, and if none is found,    * reads the terms in<code>field</code> as doubles and returns an array of    * size<code>reader.maxDoc()</code> of the value each document has in the    * given field.    *    * @param reader Used to get field values.    * @param field  Which field contains the doubles.    * @param parser Computes integer for string values.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException If any error occurs.    */
DECL|method|getDoubles
specifier|public
name|double
index|[]
name|getDoubles
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|DoubleParser
name|parser
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Returned by {@link #getTerms} */
DECL|class|DocTerms
specifier|public
specifier|abstract
specifier|static
class|class
name|DocTerms
block|{
comment|/** The BytesRef argument must not be null; the method      *  returns the same BytesRef, or an empty (length=0)      *  BytesRef if the doc did not have this field or was      *  deleted. */
DECL|method|getTerm
specifier|public
specifier|abstract
name|BytesRef
name|getTerm
parameter_list|(
name|int
name|docID
parameter_list|,
name|BytesRef
name|ret
parameter_list|)
function_decl|;
comment|/** Returns true if this doc has this field and is not      *  deleted. */
DECL|method|exists
specifier|public
specifier|abstract
name|boolean
name|exists
parameter_list|(
name|int
name|docID
parameter_list|)
function_decl|;
comment|/** Number of documents */
DECL|method|size
specifier|public
specifier|abstract
name|int
name|size
parameter_list|()
function_decl|;
block|}
comment|/** Checks the internal cache for an appropriate entry, and if none    * is found, reads the term values in<code>field</code>    * and returns a {@link DocTerms} instance, providing a    * method to retrieve the term (as a BytesRef) per document.    * @param reader  Used to get field values.    * @param field   Which field contains the strings.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getTerms
specifier|public
name|DocTerms
name|getTerms
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Expert: just like {@link #getTerms(IndexReader,String)},    *  but you can specify whether more RAM should be consumed in exchange for    *  faster lookups (default is "true").  Note that the    *  first call for a given reader and field "wins",    *  subsequent calls will share the same cache entry. */
DECL|method|getTerms
specifier|public
name|DocTerms
name|getTerms
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|boolean
name|fasterButMoreRAM
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Returned by {@link #getTermsIndex} */
DECL|class|DocTermsIndex
specifier|public
specifier|abstract
specifier|static
class|class
name|DocTermsIndex
block|{
DECL|method|binarySearchLookup
specifier|public
name|int
name|binarySearchLookup
parameter_list|(
name|BytesRef
name|key
parameter_list|,
name|BytesRef
name|spare
parameter_list|)
block|{
comment|// this special case is the reason that Arrays.binarySearch() isn't useful.
if|if
condition|(
name|key
operator|==
literal|null
condition|)
return|return
literal|0
return|;
name|int
name|low
init|=
literal|1
decl_stmt|;
name|int
name|high
init|=
name|numOrd
argument_list|()
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|int
name|cmp
init|=
name|lookup
argument_list|(
name|mid
argument_list|,
name|spare
argument_list|)
operator|.
name|compareTo
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
else|else
return|return
name|mid
return|;
comment|// key found
block|}
return|return
operator|-
operator|(
name|low
operator|+
literal|1
operator|)
return|;
comment|// key not found.
block|}
comment|/** The BytesRef argument must not be null; the method      *  returns the same BytesRef, or an empty (length=0)      *  BytesRef if this ord is the null ord (0). */
DECL|method|lookup
specifier|public
specifier|abstract
name|BytesRef
name|lookup
parameter_list|(
name|int
name|ord
parameter_list|,
name|BytesRef
name|reuse
parameter_list|)
function_decl|;
comment|/** Convenience method, to lookup the Term for a doc.      *  If this doc is deleted or did not have this field,      *  this will return an empty (length=0) BytesRef. */
DECL|method|getTerm
specifier|public
name|BytesRef
name|getTerm
parameter_list|(
name|int
name|docID
parameter_list|,
name|BytesRef
name|reuse
parameter_list|)
block|{
return|return
name|lookup
argument_list|(
name|getOrd
argument_list|(
name|docID
argument_list|)
argument_list|,
name|reuse
argument_list|)
return|;
block|}
comment|/** Returns sort ord for this document.  Ord 0 is      *  reserved for docs that are deleted or did not have      *  this field.  */
DECL|method|getOrd
specifier|public
specifier|abstract
name|int
name|getOrd
parameter_list|(
name|int
name|docID
parameter_list|)
function_decl|;
comment|/** Returns total unique ord count; this includes +1 for      *  the null ord (always 0). */
DECL|method|numOrd
specifier|public
specifier|abstract
name|int
name|numOrd
parameter_list|()
function_decl|;
comment|/** Number of documents */
DECL|method|size
specifier|public
specifier|abstract
name|int
name|size
parameter_list|()
function_decl|;
comment|/** Returns a TermsEnum that can iterate over the values in this index entry */
DECL|method|getTermsEnum
specifier|public
specifier|abstract
name|TermsEnum
name|getTermsEnum
parameter_list|()
function_decl|;
comment|/** @lucene.internal */
DECL|method|getDocToOrd
specifier|public
specifier|abstract
name|PackedInts
operator|.
name|Reader
name|getDocToOrd
parameter_list|()
function_decl|;
block|}
comment|/** Checks the internal cache for an appropriate entry, and if none    * is found, reads the term values in<code>field</code>    * and returns a {@link DocTerms} instance, providing a    * method to retrieve the term (as a BytesRef) per document.    * @param reader  Used to get field values.    * @param field   Which field contains the strings.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getTermsIndex
specifier|public
name|DocTermsIndex
name|getTermsIndex
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Expert: just like {@link    *  #getTermsIndex(IndexReader,String)}, but you can specify    *  whether more RAM should be consumed in exchange for    *  faster lookups (default is "true").  Note that the    *  first call for a given reader and field "wins",    *  subsequent calls will share the same cache entry. */
DECL|method|getTermsIndex
specifier|public
name|DocTermsIndex
name|getTermsIndex
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|boolean
name|fasterButMoreRAM
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Checks the internal cache for an appropriate entry, and if none is found, reads the term values    * in<code>field</code> and returns a {@link DocTermOrds} instance, providing a method to retrieve    * the terms (as ords) per document.    *    * @param reader  Used to build a {@link DocTermOrds} instance    * @param field   Which field contains the strings.    * @return a {@link DocTermOrds} instance    * @throws IOException  If any error occurs.    */
DECL|method|getDocTermOrds
specifier|public
name|DocTermOrds
name|getDocTermOrds
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * EXPERT: A unique Identifier/Description for each item in the FieldCache.     * Can be useful for logging/debugging.    * @lucene.experimental    */
DECL|class|CacheEntry
specifier|public
specifier|static
specifier|abstract
class|class
name|CacheEntry
block|{
DECL|method|getReaderKey
specifier|public
specifier|abstract
name|Object
name|getReaderKey
parameter_list|()
function_decl|;
DECL|method|getFieldName
specifier|public
specifier|abstract
name|String
name|getFieldName
parameter_list|()
function_decl|;
DECL|method|getCacheType
specifier|public
specifier|abstract
name|Class
argument_list|<
name|?
argument_list|>
name|getCacheType
parameter_list|()
function_decl|;
DECL|method|getCustom
specifier|public
specifier|abstract
name|Object
name|getCustom
parameter_list|()
function_decl|;
DECL|method|getValue
specifier|public
specifier|abstract
name|Object
name|getValue
parameter_list|()
function_decl|;
DECL|field|size
specifier|private
name|String
name|size
init|=
literal|null
decl_stmt|;
DECL|method|setEstimatedSize
specifier|protected
specifier|final
name|void
name|setEstimatedSize
parameter_list|(
name|String
name|size
parameter_list|)
block|{
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
comment|/**       * @see #estimateSize(RamUsageEstimator)      */
DECL|method|estimateSize
specifier|public
name|void
name|estimateSize
parameter_list|()
block|{
name|estimateSize
argument_list|(
operator|new
name|RamUsageEstimator
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// doesn't check for interned
block|}
comment|/**       * Computes (and stores) the estimated size of the cache Value       * @see #getEstimatedSize      */
DECL|method|estimateSize
specifier|public
name|void
name|estimateSize
parameter_list|(
name|RamUsageEstimator
name|ramCalc
parameter_list|)
block|{
name|long
name|size
init|=
name|ramCalc
operator|.
name|estimateRamUsage
argument_list|(
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|setEstimatedSize
argument_list|(
name|RamUsageEstimator
operator|.
name|humanReadableUnits
argument_list|(
name|size
argument_list|,
operator|new
name|DecimalFormat
argument_list|(
literal|"0.#"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * The most recently estimated size of the value, null unless       * estimateSize has been called.      */
DECL|method|getEstimatedSize
specifier|public
specifier|final
name|String
name|getEstimatedSize
parameter_list|()
block|{
return|return
name|size
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
operator|.
name|append
argument_list|(
name|getReaderKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"'=>"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
operator|.
name|append
argument_list|(
name|getFieldName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"',"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|getCacheType
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
operator|.
name|append
argument_list|(
name|getCustom
argument_list|()
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"=>"
argument_list|)
operator|.
name|append
argument_list|(
name|getValue
argument_list|()
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"#"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|System
operator|.
name|identityHashCode
argument_list|(
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|s
init|=
name|getEstimatedSize
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|s
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" (size =~ "
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * EXPERT: Generates an array of CacheEntry objects representing all items     * currently in the FieldCache.    *<p>    * NOTE: These CacheEntry objects maintain a strong reference to the     * Cached Values.  Maintaining references to a CacheEntry the IndexReader     * associated with it has garbage collected will prevent the Value itself    * from being garbage collected when the Cache drops the WeakReference.    *</p>    * @lucene.experimental    */
DECL|method|getCacheEntries
specifier|public
specifier|abstract
name|CacheEntry
index|[]
name|getCacheEntries
parameter_list|()
function_decl|;
comment|/**    *<p>    * EXPERT: Instructs the FieldCache to forcibly expunge all entries     * from the underlying caches.  This is intended only to be used for     * test methods as a way to ensure a known base state of the Cache     * (with out needing to rely on GC to free WeakReferences).      * It should not be relied on for "Cache maintenance" in general     * application code.    *</p>    * @lucene.experimental    */
DECL|method|purgeAllCaches
specifier|public
specifier|abstract
name|void
name|purgeAllCaches
parameter_list|()
function_decl|;
comment|/**    * Expert: drops all cache entries associated with this    * reader.  NOTE: this reader must precisely match the    * reader that the cache entry is keyed on. If you pass a    * top-level reader, it usually will have no effect as    * Lucene now caches at the segment reader level.    */
DECL|method|purge
specifier|public
specifier|abstract
name|void
name|purge
parameter_list|(
name|IndexReader
name|r
parameter_list|)
function_decl|;
comment|/**    * If non-null, FieldCacheImpl will warn whenever    * entries are created that are not sane according to    * {@link org.apache.lucene.util.FieldCacheSanityChecker}.    */
DECL|method|setInfoStream
specifier|public
name|void
name|setInfoStream
parameter_list|(
name|PrintStream
name|stream
parameter_list|)
function_decl|;
comment|/** counterpart of {@link #setInfoStream(PrintStream)} */
DECL|method|getInfoStream
specifier|public
name|PrintStream
name|getInfoStream
parameter_list|()
function_decl|;
block|}
end_interface
end_unit
