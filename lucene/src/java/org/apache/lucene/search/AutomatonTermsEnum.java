begin_unit
begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|Automaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|ByteRunAutomaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|SpecialOperations
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|State
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|Transition
import|;
end_import
begin_comment
comment|/**  * A FilteredTermsEnum that enumerates terms based upon what is accepted by a  * DFA.  *<p>  * The algorithm is such:  *<ol>  *<li>As long as matches are successful, keep reading sequentially.  *<li>When a match fails, skip to the next string in lexicographic order that  * does not enter a reject state.  *</ol>  *<p>  * The algorithm does not attempt to actually skip to the next string that is  * completely accepted. This is not possible when the language accepted by the  * FSM is not finite (i.e. * operator).  *</p>  * @lucene.experimental  */
end_comment
begin_class
DECL|class|AutomatonTermsEnum
specifier|public
class|class
name|AutomatonTermsEnum
extends|extends
name|FilteredTermsEnum
block|{
comment|// the object-oriented form of the DFA
DECL|field|automaton
specifier|private
specifier|final
name|Automaton
name|automaton
decl_stmt|;
comment|// a tableized array-based form of the DFA
DECL|field|runAutomaton
specifier|private
specifier|final
name|ByteRunAutomaton
name|runAutomaton
decl_stmt|;
comment|// common suffix of the automaton
DECL|field|commonSuffixRef
specifier|private
specifier|final
name|BytesRef
name|commonSuffixRef
decl_stmt|;
comment|// true if the automaton accepts a finite language
DECL|field|finite
specifier|private
specifier|final
name|boolean
name|finite
decl_stmt|;
comment|// array of sorted transitions for each state, indexed by state number
DECL|field|allTransitions
specifier|private
specifier|final
name|Transition
index|[]
index|[]
name|allTransitions
decl_stmt|;
comment|// for path tracking: each long records gen when we last
comment|// visited the state; we use gens to avoid having to clear
DECL|field|visited
specifier|private
specifier|final
name|long
index|[]
name|visited
decl_stmt|;
DECL|field|curGen
specifier|private
name|long
name|curGen
decl_stmt|;
comment|// the reference used for seeking forwards through the term dictionary
DECL|field|seekBytesRef
specifier|private
specifier|final
name|BytesRef
name|seekBytesRef
init|=
operator|new
name|BytesRef
argument_list|(
literal|10
argument_list|)
decl_stmt|;
comment|// true if we are enumerating an infinite portion of the DFA.
comment|// in this case it is faster to drive the query based on the terms dictionary.
comment|// when this is true, linearUpperBound indicate the end of range
comment|// of terms where we should simply do sequential reads instead.
DECL|field|linear
specifier|private
name|boolean
name|linear
init|=
literal|false
decl_stmt|;
DECL|field|linearUpperBound
specifier|private
specifier|final
name|BytesRef
name|linearUpperBound
init|=
operator|new
name|BytesRef
argument_list|(
literal|10
argument_list|)
decl_stmt|;
DECL|field|termComp
specifier|private
specifier|final
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|termComp
decl_stmt|;
comment|/**    * Expert ctor:    * Construct an enumerator based upon an automaton, enumerating the specified    * field, working on a supplied reader.    *<p>    * @lucene.internal Use the public ctor instead.     *<p>    * @param runAutomaton pre-compiled ByteRunAutomaton    * @param finite true if the automaton accepts a finite language    */
DECL|method|AutomatonTermsEnum
name|AutomatonTermsEnum
parameter_list|(
name|ByteRunAutomaton
name|runAutomaton
parameter_list|,
name|String
name|field
parameter_list|,
name|IndexReader
name|reader
parameter_list|,
name|boolean
name|finite
parameter_list|,
name|BytesRef
name|commonSuffixRef
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|reader
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|this
operator|.
name|automaton
operator|=
name|runAutomaton
operator|.
name|getAutomaton
argument_list|()
expr_stmt|;
name|this
operator|.
name|finite
operator|=
name|finite
expr_stmt|;
name|this
operator|.
name|runAutomaton
operator|=
name|runAutomaton
expr_stmt|;
if|if
condition|(
name|finite
condition|)
block|{
comment|// don't use suffix w/ finite DFAs
name|this
operator|.
name|commonSuffixRef
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|commonSuffixRef
operator|==
literal|null
condition|)
block|{
comment|// compute now
name|this
operator|.
name|commonSuffixRef
operator|=
name|SpecialOperations
operator|.
name|getCommonSuffixBytesRef
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// precomputed
name|this
operator|.
name|commonSuffixRef
operator|=
name|commonSuffixRef
expr_stmt|;
block|}
comment|// build a cache of sorted transitions for every state
name|allTransitions
operator|=
operator|new
name|Transition
index|[
name|runAutomaton
operator|.
name|getSize
argument_list|()
index|]
index|[]
expr_stmt|;
for|for
control|(
name|State
name|state
range|:
name|this
operator|.
name|automaton
operator|.
name|getNumberedStates
argument_list|()
control|)
block|{
name|state
operator|.
name|sortTransitions
argument_list|(
name|Transition
operator|.
name|CompareByMinMaxThenDest
argument_list|)
expr_stmt|;
name|state
operator|.
name|trimTransitionsArray
argument_list|()
expr_stmt|;
name|allTransitions
index|[
name|state
operator|.
name|getNumber
argument_list|()
index|]
operator|=
name|state
operator|.
name|transitionsArray
expr_stmt|;
block|}
comment|// used for path tracking, where each bit is a numbered state.
name|visited
operator|=
operator|new
name|long
index|[
name|runAutomaton
operator|.
name|getSize
argument_list|()
index|]
expr_stmt|;
name|setUseTermsCache
argument_list|(
name|finite
argument_list|)
expr_stmt|;
name|termComp
operator|=
name|getComparator
argument_list|()
expr_stmt|;
block|}
comment|/**    * Construct an enumerator based upon an automaton, enumerating the specified    * field, working on a supplied reader.    *<p>    * It will automatically calculate whether or not the automaton is finite    */
DECL|method|AutomatonTermsEnum
specifier|public
name|AutomatonTermsEnum
parameter_list|(
name|Automaton
name|automaton
parameter_list|,
name|String
name|field
parameter_list|,
name|IndexReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
operator|new
name|ByteRunAutomaton
argument_list|(
name|automaton
argument_list|)
argument_list|,
name|field
argument_list|,
name|reader
argument_list|,
name|SpecialOperations
operator|.
name|isFinite
argument_list|(
name|automaton
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns true if the term matches the automaton. Also stashes away the term    * to assist with smart enumeration.    */
annotation|@
name|Override
DECL|method|accept
specifier|protected
name|AcceptStatus
name|accept
parameter_list|(
specifier|final
name|BytesRef
name|term
parameter_list|)
block|{
if|if
condition|(
name|commonSuffixRef
operator|==
literal|null
operator|||
name|term
operator|.
name|endsWith
argument_list|(
name|commonSuffixRef
argument_list|)
condition|)
block|{
if|if
condition|(
name|runAutomaton
operator|.
name|run
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|term
operator|.
name|offset
argument_list|,
name|term
operator|.
name|length
argument_list|)
condition|)
return|return
name|linear
condition|?
name|AcceptStatus
operator|.
name|YES
else|:
name|AcceptStatus
operator|.
name|YES_AND_SEEK
return|;
else|else
return|return
operator|(
name|linear
operator|&&
name|termComp
operator|.
name|compare
argument_list|(
name|term
argument_list|,
name|linearUpperBound
argument_list|)
operator|<
literal|0
operator|)
condition|?
name|AcceptStatus
operator|.
name|NO
else|:
name|AcceptStatus
operator|.
name|NO_AND_SEEK
return|;
block|}
else|else
block|{
return|return
operator|(
name|linear
operator|&&
name|termComp
operator|.
name|compare
argument_list|(
name|term
argument_list|,
name|linearUpperBound
argument_list|)
operator|<
literal|0
operator|)
condition|?
name|AcceptStatus
operator|.
name|NO
else|:
name|AcceptStatus
operator|.
name|NO_AND_SEEK
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|nextSeekTerm
specifier|protected
name|BytesRef
name|nextSeekTerm
parameter_list|(
specifier|final
name|BytesRef
name|term
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|term
operator|==
literal|null
condition|)
block|{
name|seekBytesRef
operator|.
name|copy
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// return the empty term, as its valid
if|if
condition|(
name|runAutomaton
operator|.
name|run
argument_list|(
name|seekBytesRef
operator|.
name|bytes
argument_list|,
name|seekBytesRef
operator|.
name|offset
argument_list|,
name|seekBytesRef
operator|.
name|length
argument_list|)
condition|)
block|{
return|return
name|seekBytesRef
return|;
block|}
block|}
else|else
block|{
name|seekBytesRef
operator|.
name|copy
argument_list|(
name|term
argument_list|)
expr_stmt|;
block|}
comment|// seek to the next possible string;
if|if
condition|(
name|nextString
argument_list|()
condition|)
block|{
comment|// reposition
if|if
condition|(
name|linear
condition|)
name|setLinear
argument_list|(
name|infinitePosition
argument_list|)
expr_stmt|;
return|return
name|seekBytesRef
return|;
block|}
comment|// no more possible strings can match
return|return
literal|null
return|;
block|}
comment|// this instance prevents unicode conversion during backtracking,
comment|// we can just call setLinear once at the end.
DECL|field|infinitePosition
name|int
name|infinitePosition
decl_stmt|;
comment|/**    * Sets the enum to operate in linear fashion, as we have found    * a looping transition at position    */
DECL|method|setLinear
specifier|private
name|void
name|setLinear
parameter_list|(
name|int
name|position
parameter_list|)
block|{
name|int
name|state
init|=
name|runAutomaton
operator|.
name|getInitialState
argument_list|()
decl_stmt|;
name|int
name|maxInterval
init|=
literal|0xef
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|position
condition|;
name|i
operator|++
control|)
block|{
name|state
operator|=
name|runAutomaton
operator|.
name|step
argument_list|(
name|state
argument_list|,
name|seekBytesRef
operator|.
name|bytes
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
assert|assert
name|state
operator|>=
literal|0
operator|:
literal|"state="
operator|+
name|state
assert|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|allTransitions
index|[
name|state
index|]
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Transition
name|t
init|=
name|allTransitions
index|[
name|state
index|]
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|getMin
argument_list|()
operator|<=
operator|(
name|seekBytesRef
operator|.
name|bytes
index|[
name|position
index|]
operator|&
literal|0xff
operator|)
operator|&&
operator|(
name|seekBytesRef
operator|.
name|bytes
index|[
name|position
index|]
operator|&
literal|0xff
operator|)
operator|<=
name|t
operator|.
name|getMax
argument_list|()
condition|)
block|{
name|maxInterval
operator|=
name|t
operator|.
name|getMax
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
comment|// 0xff terms don't get the optimization... not worth the trouble.
if|if
condition|(
name|maxInterval
operator|!=
literal|0xff
condition|)
name|maxInterval
operator|=
name|incrementUTF8
argument_list|(
name|maxInterval
argument_list|)
expr_stmt|;
name|int
name|length
init|=
name|position
operator|+
literal|1
decl_stmt|;
comment|/* position + maxTransition */
if|if
condition|(
name|linearUpperBound
operator|.
name|bytes
operator|.
name|length
operator|<
name|length
condition|)
name|linearUpperBound
operator|.
name|bytes
operator|=
operator|new
name|byte
index|[
name|length
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|seekBytesRef
operator|.
name|bytes
argument_list|,
literal|0
argument_list|,
name|linearUpperBound
operator|.
name|bytes
argument_list|,
literal|0
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|linearUpperBound
operator|.
name|bytes
index|[
name|position
index|]
operator|=
operator|(
name|byte
operator|)
name|maxInterval
expr_stmt|;
name|linearUpperBound
operator|.
name|length
operator|=
name|length
expr_stmt|;
block|}
comment|/**    * Increments the utf16 buffer to the next String in lexicographic order after s that will not put    * the machine into a reject state. If such a string does not exist, returns    * false.    *     * The correctness of this method depends upon the automaton being deterministic,    * and having no transitions to dead states.    *     * @return true if more possible solutions exist for the DFA    */
DECL|method|nextString
specifier|private
name|boolean
name|nextString
parameter_list|()
block|{
name|int
name|state
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|curGen
operator|++
expr_stmt|;
name|linear
operator|=
literal|false
expr_stmt|;
name|state
operator|=
name|runAutomaton
operator|.
name|getInitialState
argument_list|()
expr_stmt|;
comment|// walk the automaton until a character is rejected.
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|seekBytesRef
operator|.
name|length
condition|;
name|pos
operator|++
control|)
block|{
name|visited
index|[
name|state
index|]
operator|=
name|curGen
expr_stmt|;
name|int
name|nextState
init|=
name|runAutomaton
operator|.
name|step
argument_list|(
name|state
argument_list|,
name|seekBytesRef
operator|.
name|bytes
index|[
name|pos
index|]
operator|&
literal|0xff
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextState
operator|==
operator|-
literal|1
condition|)
break|break;
comment|// we found a loop, record it for faster enumeration
if|if
condition|(
operator|!
name|finite
operator|&&
operator|!
name|linear
operator|&&
name|visited
index|[
name|nextState
index|]
operator|==
name|curGen
condition|)
block|{
name|linear
operator|=
literal|true
expr_stmt|;
name|infinitePosition
operator|=
name|pos
expr_stmt|;
block|}
name|state
operator|=
name|nextState
expr_stmt|;
block|}
comment|// take the useful portion, and the last non-reject state, and attempt to
comment|// append characters that will match.
if|if
condition|(
name|nextString
argument_list|(
name|state
argument_list|,
name|pos
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
comment|/* no more solutions exist from this useful portion, backtrack */
if|if
condition|(
operator|!
name|backtrack
argument_list|(
name|pos
argument_list|)
condition|)
comment|/* no more solutions at all */
return|return
literal|false
return|;
elseif|else
if|if
condition|(
name|runAutomaton
operator|.
name|run
argument_list|(
name|seekBytesRef
operator|.
name|bytes
argument_list|,
literal|0
argument_list|,
name|seekBytesRef
operator|.
name|length
argument_list|)
condition|)
comment|/* String is good to go as-is */
return|return
literal|true
return|;
comment|/* else advance further */
block|}
block|}
block|}
comment|/**    * Returns the next String in lexicographic order that will not put    * the machine into a reject state.     *     * This method traverses the DFA from the given position in the String,    * starting at the given state.    *     * If this cannot satisfy the machine, returns false. This method will    * walk the minimal path, in lexicographic order, as long as possible.    *     * If this method returns false, then there might still be more solutions,    * it is necessary to backtrack to find out.    *     * @param state current non-reject state    * @param position useful portion of the string    * @return true if more possible solutions exist for the DFA from this    *         position    */
DECL|method|nextString
specifier|private
name|boolean
name|nextString
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|position
parameter_list|)
block|{
comment|/*       * the next lexicographic character must be greater than the existing      * character, if it exists.      */
name|int
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|position
operator|<
name|seekBytesRef
operator|.
name|length
condition|)
block|{
name|c
operator|=
name|seekBytesRef
operator|.
name|bytes
index|[
name|position
index|]
operator|&
literal|0xff
expr_stmt|;
comment|// if the next character is U+FFFF and is not part of the useful portion,
comment|// then by definition it puts us in a reject state, and therefore this
comment|// path is dead. there cannot be any higher transitions. backtrack.
name|c
operator|=
name|incrementUTF8
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
block|}
name|seekBytesRef
operator|.
name|length
operator|=
name|position
expr_stmt|;
name|visited
index|[
name|state
index|]
operator|=
name|curGen
expr_stmt|;
name|Transition
name|transitions
index|[]
init|=
name|allTransitions
index|[
name|state
index|]
decl_stmt|;
comment|// find the minimal path (lexicographic order) that is>= c
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|transitions
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Transition
name|transition
init|=
name|transitions
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|transition
operator|.
name|getMax
argument_list|()
operator|>=
name|c
condition|)
block|{
name|int
name|nextChar
init|=
name|Math
operator|.
name|max
argument_list|(
name|c
argument_list|,
name|transition
operator|.
name|getMin
argument_list|()
argument_list|)
decl_stmt|;
comment|// append either the next sequential char, or the minimum transition
name|seekBytesRef
operator|.
name|grow
argument_list|(
name|seekBytesRef
operator|.
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|seekBytesRef
operator|.
name|length
operator|++
expr_stmt|;
name|seekBytesRef
operator|.
name|bytes
index|[
name|seekBytesRef
operator|.
name|length
operator|-
literal|1
index|]
operator|=
operator|(
name|byte
operator|)
name|nextChar
expr_stmt|;
name|state
operator|=
name|transition
operator|.
name|getDest
argument_list|()
operator|.
name|getNumber
argument_list|()
expr_stmt|;
comment|/*           * as long as is possible, continue down the minimal path in          * lexicographic order. if a loop or accept state is encountered, stop.          */
while|while
condition|(
name|visited
index|[
name|state
index|]
operator|!=
name|curGen
operator|&&
operator|!
name|runAutomaton
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|visited
index|[
name|state
index|]
operator|=
name|curGen
expr_stmt|;
comment|/*             * Note: we work with a DFA with no transitions to dead states.            * so the below is ok, if it is not an accept state,            * then there MUST be at least one transition.            */
name|transition
operator|=
name|allTransitions
index|[
name|state
index|]
index|[
literal|0
index|]
expr_stmt|;
name|state
operator|=
name|transition
operator|.
name|getDest
argument_list|()
operator|.
name|getNumber
argument_list|()
expr_stmt|;
comment|// we found a loop, record it for faster enumeration
if|if
condition|(
operator|!
name|finite
operator|&&
operator|!
name|linear
operator|&&
name|visited
index|[
name|state
index|]
operator|==
name|curGen
condition|)
block|{
name|linear
operator|=
literal|true
expr_stmt|;
name|infinitePosition
operator|=
name|seekBytesRef
operator|.
name|length
expr_stmt|;
block|}
comment|// append the minimum transition
name|seekBytesRef
operator|.
name|grow
argument_list|(
name|seekBytesRef
operator|.
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|seekBytesRef
operator|.
name|length
operator|++
expr_stmt|;
name|seekBytesRef
operator|.
name|bytes
index|[
name|seekBytesRef
operator|.
name|length
operator|-
literal|1
index|]
operator|=
operator|(
name|byte
operator|)
name|transition
operator|.
name|getMin
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Attempts to backtrack thru the string after encountering a dead end    * at some given position. Returns false if no more possible strings     * can match.    *     * @param position current position in the input String    * @return true if more possible solutions exist for the DFA    */
DECL|method|backtrack
specifier|private
name|boolean
name|backtrack
parameter_list|(
name|int
name|position
parameter_list|)
block|{
while|while
condition|(
name|position
operator|>
literal|0
condition|)
block|{
name|int
name|nextChar
init|=
name|seekBytesRef
operator|.
name|bytes
index|[
name|position
operator|-
literal|1
index|]
operator|&
literal|0xff
decl_stmt|;
comment|// if a character is 0xff its a dead-end too,
comment|// because there is no higher character in UTF-8 sort order.
name|nextChar
operator|=
name|incrementUTF8
argument_list|(
name|nextChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextChar
operator|!=
operator|-
literal|1
condition|)
block|{
name|seekBytesRef
operator|.
name|bytes
index|[
name|position
operator|-
literal|1
index|]
operator|=
operator|(
name|byte
operator|)
name|nextChar
expr_stmt|;
name|seekBytesRef
operator|.
name|length
operator|=
name|position
expr_stmt|;
return|return
literal|true
return|;
block|}
name|position
operator|--
expr_stmt|;
block|}
return|return
literal|false
return|;
comment|/* all solutions exhausted */
block|}
comment|/* return the next utf8 byte in utf8 order, or -1 if exhausted */
DECL|method|incrementUTF8
specifier|private
specifier|final
name|int
name|incrementUTF8
parameter_list|(
name|int
name|utf8
parameter_list|)
block|{
switch|switch
condition|(
name|utf8
condition|)
block|{
case|case
literal|0xff
case|:
return|return
operator|-
literal|1
return|;
default|default:
return|return
name|utf8
operator|+
literal|1
return|;
block|}
block|}
block|}
end_class
end_unit
