begin_unit
begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|UnicodeUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|Automaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|BasicAutomata
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|BasicOperations
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|ByteRunAutomaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|LevenshteinAutomata
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_comment
comment|/** Subclass of TermsEnum for enumerating all terms that are similar  * to the specified filter term.  *  *<p>Term enumerations are always ordered by  * {@link #getComparator}.  Each term in the enumeration is  * greater than all that precede it.</p>  */
end_comment
begin_class
DECL|class|FuzzyTermsEnum
specifier|public
specifier|final
class|class
name|FuzzyTermsEnum
extends|extends
name|TermsEnum
block|{
DECL|field|actualEnum
specifier|private
name|TermsEnum
name|actualEnum
decl_stmt|;
DECL|field|actualBoostAtt
specifier|private
name|MultiTermQuery
operator|.
name|BoostAttribute
name|actualBoostAtt
decl_stmt|;
DECL|field|boostAtt
specifier|private
specifier|final
name|MultiTermQuery
operator|.
name|BoostAttribute
name|boostAtt
init|=
name|attributes
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|MultiTermQuery
operator|.
name|BoostAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|bottom
specifier|private
name|float
name|bottom
init|=
name|boostAtt
operator|.
name|getMaxNonCompetitiveBoost
argument_list|()
decl_stmt|;
DECL|field|minSimilarity
specifier|private
specifier|final
name|float
name|minSimilarity
decl_stmt|;
DECL|field|scale_factor
specifier|private
specifier|final
name|float
name|scale_factor
decl_stmt|;
DECL|field|termLength
specifier|private
specifier|final
name|int
name|termLength
decl_stmt|;
DECL|field|maxEdits
specifier|private
name|int
name|maxEdits
decl_stmt|;
DECL|field|runAutomata
specifier|private
name|List
argument_list|<
name|ByteRunAutomaton
argument_list|>
name|runAutomata
decl_stmt|;
DECL|field|reader
specifier|private
specifier|final
name|IndexReader
name|reader
decl_stmt|;
DECL|field|term
specifier|private
specifier|final
name|Term
name|term
decl_stmt|;
DECL|field|termText
specifier|private
specifier|final
name|int
name|termText
index|[]
decl_stmt|;
DECL|field|realPrefixLength
specifier|private
specifier|final
name|int
name|realPrefixLength
decl_stmt|;
comment|/**    * Constructor for enumeration of all terms from specified<code>reader</code> which share a prefix of    * length<code>prefixLength</code> with<code>term</code> and which have a fuzzy similarity&gt;    *<code>minSimilarity</code>.    *<p>    * After calling the constructor the enumeration is already pointing to the first     * valid term if such a term exists.     *     * @param reader Delivers terms.    * @param term Pattern term.    * @param minSimilarity Minimum required similarity for terms from the reader. Default value is 0.5f.    * @param prefixLength Length of required common prefix. Default value is 0.    * @throws IOException    */
DECL|method|FuzzyTermsEnum
specifier|public
name|FuzzyTermsEnum
parameter_list|(
name|IndexReader
name|reader
parameter_list|,
name|Term
name|term
parameter_list|,
specifier|final
name|float
name|minSimilarity
parameter_list|,
specifier|final
name|int
name|prefixLength
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|minSimilarity
operator|>=
literal|1.0f
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"minimumSimilarity cannot be greater than or equal to 1"
argument_list|)
throw|;
elseif|else
if|if
condition|(
name|minSimilarity
operator|<
literal|0.0f
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"minimumSimilarity cannot be less than 0"
argument_list|)
throw|;
if|if
condition|(
name|prefixLength
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"prefixLength cannot be less than 0"
argument_list|)
throw|;
name|this
operator|.
name|reader
operator|=
name|reader
expr_stmt|;
name|this
operator|.
name|term
operator|=
name|term
expr_stmt|;
comment|// convert the string into a utf32 int[] representation for fast comparisons
specifier|final
name|String
name|utf16
init|=
name|term
operator|.
name|text
argument_list|()
decl_stmt|;
name|this
operator|.
name|termText
operator|=
operator|new
name|int
index|[
name|utf16
operator|.
name|codePointCount
argument_list|(
literal|0
argument_list|,
name|utf16
operator|.
name|length
argument_list|()
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|int
name|cp
init|,
name|i
init|=
literal|0
init|,
name|j
init|=
literal|0
init|;
name|i
operator|<
name|utf16
operator|.
name|length
argument_list|()
condition|;
name|i
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|cp
argument_list|)
control|)
name|termText
index|[
name|j
operator|++
index|]
operator|=
name|cp
operator|=
name|utf16
operator|.
name|codePointAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|this
operator|.
name|termLength
operator|=
name|termText
operator|.
name|length
expr_stmt|;
comment|//The prefix could be longer than the word.
comment|//It's kind of silly though.  It means we must match the entire word.
name|this
operator|.
name|realPrefixLength
operator|=
name|prefixLength
operator|>
name|termLength
condition|?
name|termLength
else|:
name|prefixLength
expr_stmt|;
name|this
operator|.
name|minSimilarity
operator|=
name|minSimilarity
expr_stmt|;
name|this
operator|.
name|scale_factor
operator|=
literal|1.0f
operator|/
operator|(
literal|1.0f
operator|-
name|minSimilarity
operator|)
expr_stmt|;
comment|// calculate the maximum k edits for this similarity
name|maxEdits
operator|=
name|initialMaxDistance
argument_list|(
name|minSimilarity
argument_list|,
name|termLength
argument_list|)
expr_stmt|;
name|TermsEnum
name|subEnum
init|=
name|getAutomatonEnum
argument_list|(
name|maxEdits
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|setEnum
argument_list|(
name|subEnum
operator|!=
literal|null
condition|?
name|subEnum
else|:
operator|new
name|LinearFuzzyTermsEnum
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * return an automata-based enum for matching up to editDistance from    * lastTerm, if possible    */
DECL|method|getAutomatonEnum
specifier|private
name|TermsEnum
name|getAutomatonEnum
parameter_list|(
name|int
name|editDistance
parameter_list|,
name|BytesRef
name|lastTerm
parameter_list|)
throws|throws
name|IOException
block|{
name|initAutomata
argument_list|(
name|editDistance
argument_list|)
expr_stmt|;
if|if
condition|(
name|runAutomata
operator|!=
literal|null
operator|&&
name|editDistance
operator|<
name|runAutomata
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
operator|new
name|AutomatonFuzzyTermsEnum
argument_list|(
name|runAutomata
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|editDistance
operator|+
literal|1
argument_list|)
operator|.
name|toArray
argument_list|(
operator|new
name|ByteRunAutomaton
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|lastTerm
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/** initialize levenshtein DFAs up to maxDistance, if possible */
DECL|method|initAutomata
specifier|private
name|void
name|initAutomata
parameter_list|(
name|int
name|maxDistance
parameter_list|)
block|{
if|if
condition|(
name|runAutomata
operator|==
literal|null
operator|&&
name|maxDistance
operator|<=
name|LevenshteinAutomata
operator|.
name|MAXIMUM_SUPPORTED_DISTANCE
condition|)
block|{
name|LevenshteinAutomata
name|builder
init|=
operator|new
name|LevenshteinAutomata
argument_list|(
name|UnicodeUtil
operator|.
name|newString
argument_list|(
name|termText
argument_list|,
name|realPrefixLength
argument_list|,
name|termText
operator|.
name|length
operator|-
name|realPrefixLength
argument_list|)
argument_list|)
decl_stmt|;
name|runAutomata
operator|=
operator|new
name|ArrayList
argument_list|<
name|ByteRunAutomaton
argument_list|>
argument_list|(
name|maxDistance
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|maxDistance
condition|;
name|i
operator|++
control|)
block|{
name|Automaton
name|a
init|=
name|builder
operator|.
name|toAutomaton
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// constant prefix
if|if
condition|(
name|realPrefixLength
operator|>
literal|0
condition|)
block|{
name|Automaton
name|prefix
init|=
name|BasicAutomata
operator|.
name|makeString
argument_list|(
name|UnicodeUtil
operator|.
name|newString
argument_list|(
name|termText
argument_list|,
literal|0
argument_list|,
name|realPrefixLength
argument_list|)
argument_list|)
decl_stmt|;
name|a
operator|=
name|BasicOperations
operator|.
name|concatenate
argument_list|(
name|prefix
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
name|runAutomata
operator|.
name|add
argument_list|(
operator|new
name|ByteRunAutomaton
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** swap in a new actual enum to proxy to */
DECL|method|setEnum
specifier|private
name|void
name|setEnum
parameter_list|(
name|TermsEnum
name|actualEnum
parameter_list|)
block|{
name|this
operator|.
name|actualEnum
operator|=
name|actualEnum
expr_stmt|;
name|this
operator|.
name|actualBoostAtt
operator|=
name|actualEnum
operator|.
name|attributes
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|MultiTermQuery
operator|.
name|BoostAttribute
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/**    * fired when the max non-competitive boost has changed. this is the hook to    * swap in a smarter actualEnum    */
DECL|method|bottomChanged
specifier|private
name|void
name|bottomChanged
parameter_list|(
name|float
name|boostValue
parameter_list|,
name|BytesRef
name|lastTerm
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|oldMaxEdits
init|=
name|maxEdits
decl_stmt|;
comment|// as long as the max non-competitive boost is>= the max boost
comment|// for some edit distance, keep dropping the max edit distance.
while|while
condition|(
name|maxEdits
operator|>
literal|0
operator|&&
name|boostValue
operator|>=
name|calculateMaxBoost
argument_list|(
name|maxEdits
argument_list|)
condition|)
name|maxEdits
operator|--
expr_stmt|;
if|if
condition|(
name|oldMaxEdits
operator|!=
name|maxEdits
condition|)
block|{
comment|// the maximum n has changed
name|TermsEnum
name|newEnum
init|=
name|getAutomatonEnum
argument_list|(
name|maxEdits
argument_list|,
name|lastTerm
argument_list|)
decl_stmt|;
if|if
condition|(
name|newEnum
operator|!=
literal|null
condition|)
block|{
name|setEnum
argument_list|(
name|newEnum
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO, besides changing linear -> automaton, and swapping in a smaller
comment|// automaton, we can also use this information to optimize the linear case
comment|// itself: re-init maxDistances so the fast-fail happens for more terms due
comment|// to the now stricter constraints.
block|}
comment|// for some raw min similarity and input term length, the maximum # of edits
DECL|method|initialMaxDistance
specifier|private
name|int
name|initialMaxDistance
parameter_list|(
name|float
name|minimumSimilarity
parameter_list|,
name|int
name|termLen
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
operator|(
literal|1
operator|-
name|minimumSimilarity
operator|)
operator|*
name|termLen
argument_list|)
return|;
block|}
comment|// for some number of edits, the maximum possible scaled boost
DECL|method|calculateMaxBoost
specifier|private
name|float
name|calculateMaxBoost
parameter_list|(
name|int
name|nEdits
parameter_list|)
block|{
specifier|final
name|float
name|similarity
init|=
literal|1.0f
operator|-
operator|(
operator|(
name|float
operator|)
name|nEdits
operator|/
call|(
name|float
call|)
argument_list|(
name|termLength
argument_list|)
operator|)
decl_stmt|;
return|return
operator|(
name|similarity
operator|-
name|minSimilarity
operator|)
operator|*
name|scale_factor
return|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
throws|throws
name|IOException
block|{
name|BytesRef
name|term
init|=
name|actualEnum
operator|.
name|next
argument_list|()
decl_stmt|;
name|boostAtt
operator|.
name|setBoost
argument_list|(
name|actualBoostAtt
operator|.
name|getBoost
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|float
name|bottom
init|=
name|boostAtt
operator|.
name|getMaxNonCompetitiveBoost
argument_list|()
decl_stmt|;
if|if
condition|(
name|bottom
operator|!=
name|this
operator|.
name|bottom
condition|)
block|{
name|this
operator|.
name|bottom
operator|=
name|bottom
expr_stmt|;
comment|// clone the term before potentially doing something with it
comment|// this is a rare but wonderful occurrence anyway
name|bottomChanged
argument_list|(
name|bottom
argument_list|,
name|term
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|BytesRef
operator|)
name|term
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|term
return|;
block|}
comment|// proxy all other enum calls to the actual enum
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
block|{
return|return
name|actualEnum
operator|.
name|docFreq
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|actualEnum
operator|.
name|docs
argument_list|(
name|skipDocs
argument_list|,
name|reuse
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|actualEnum
operator|.
name|docsAndPositions
argument_list|(
name|skipDocs
argument_list|,
name|reuse
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|actualEnum
operator|.
name|getComparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|actualEnum
operator|.
name|ord
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|seek
specifier|public
name|SeekStatus
name|seek
parameter_list|(
name|BytesRef
name|text
parameter_list|,
name|boolean
name|useCache
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|actualEnum
operator|.
name|seek
argument_list|(
name|text
argument_list|,
name|useCache
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|seek
specifier|public
name|SeekStatus
name|seek
parameter_list|(
name|long
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|actualEnum
operator|.
name|seek
argument_list|(
name|ord
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|actualEnum
operator|.
name|term
argument_list|()
return|;
block|}
comment|/**    * Finds and returns the smallest of three integers     */
DECL|method|min
specifier|private
specifier|static
specifier|final
name|int
name|min
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|c
parameter_list|)
block|{
specifier|final
name|int
name|t
init|=
operator|(
name|a
operator|<
name|b
operator|)
condition|?
name|a
else|:
name|b
decl_stmt|;
return|return
operator|(
name|t
operator|<
name|c
operator|)
condition|?
name|t
else|:
name|c
return|;
block|}
comment|/**    * Implement fuzzy enumeration with automaton.    *<p>    * This is the fastest method as opposed to LinearFuzzyTermsEnum:    * as enumeration is logarithmic to the number of terms (instead of linear)    * and comparison is linear to length of the term (rather than quadratic)    */
DECL|class|AutomatonFuzzyTermsEnum
specifier|private
class|class
name|AutomatonFuzzyTermsEnum
extends|extends
name|AutomatonTermsEnum
block|{
DECL|field|matchers
specifier|private
specifier|final
name|ByteRunAutomaton
name|matchers
index|[]
decl_stmt|;
DECL|field|termRef
specifier|private
specifier|final
name|BytesRef
name|termRef
decl_stmt|;
DECL|field|lastTerm
specifier|private
specifier|final
name|BytesRef
name|lastTerm
decl_stmt|;
DECL|field|boostAtt
specifier|private
specifier|final
name|MultiTermQuery
operator|.
name|BoostAttribute
name|boostAtt
init|=
name|attributes
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|MultiTermQuery
operator|.
name|BoostAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|AutomatonFuzzyTermsEnum
specifier|public
name|AutomatonFuzzyTermsEnum
parameter_list|(
name|ByteRunAutomaton
name|matchers
index|[]
parameter_list|,
name|BytesRef
name|lastTerm
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|matchers
index|[
name|matchers
operator|.
name|length
operator|-
literal|1
index|]
argument_list|,
name|term
operator|.
name|field
argument_list|()
argument_list|,
name|reader
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|matchers
operator|=
name|matchers
expr_stmt|;
name|this
operator|.
name|lastTerm
operator|=
name|lastTerm
expr_stmt|;
name|termRef
operator|=
operator|new
name|BytesRef
argument_list|(
name|term
operator|.
name|text
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** finds the smallest Lev(n) DFA that accepts the term. */
annotation|@
name|Override
DECL|method|accept
specifier|protected
name|AcceptStatus
name|accept
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
if|if
condition|(
name|term
operator|.
name|equals
argument_list|(
name|termRef
argument_list|)
condition|)
block|{
comment|// ed = 0
name|boostAtt
operator|.
name|setBoost
argument_list|(
literal|1.0F
argument_list|)
expr_stmt|;
return|return
name|AcceptStatus
operator|.
name|YES_AND_SEEK
return|;
block|}
name|int
name|codePointCount
init|=
operator|-
literal|1
decl_stmt|;
comment|// TODO: benchmark doing this backwards
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|matchers
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|matchers
index|[
name|i
index|]
operator|.
name|run
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
literal|0
argument_list|,
name|term
operator|.
name|length
argument_list|)
condition|)
block|{
comment|// this sucks, we convert just to score based on length.
if|if
condition|(
name|codePointCount
operator|==
operator|-
literal|1
condition|)
block|{
name|codePointCount
operator|=
name|UnicodeUtil
operator|.
name|codePointCount
argument_list|(
name|term
argument_list|)
expr_stmt|;
block|}
specifier|final
name|float
name|similarity
init|=
literal|1.0f
operator|-
operator|(
operator|(
name|float
operator|)
name|i
operator|/
call|(
name|float
call|)
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|codePointCount
argument_list|,
name|termLength
argument_list|)
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|similarity
operator|>
name|minSimilarity
condition|)
block|{
name|boostAtt
operator|.
name|setBoost
argument_list|(
call|(
name|float
call|)
argument_list|(
operator|(
name|similarity
operator|-
name|minSimilarity
operator|)
operator|*
name|scale_factor
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|AcceptStatus
operator|.
name|YES_AND_SEEK
return|;
block|}
else|else
block|{
return|return
name|AcceptStatus
operator|.
name|NO_AND_SEEK
return|;
block|}
block|}
return|return
name|AcceptStatus
operator|.
name|NO_AND_SEEK
return|;
block|}
comment|/** defers to superclass, except can start at an arbitrary location */
annotation|@
name|Override
DECL|method|nextSeekTerm
specifier|protected
name|BytesRef
name|nextSeekTerm
parameter_list|(
name|BytesRef
name|term
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|term
operator|==
literal|null
condition|)
name|term
operator|=
name|lastTerm
expr_stmt|;
return|return
name|super
operator|.
name|nextSeekTerm
argument_list|(
name|term
argument_list|)
return|;
block|}
block|}
comment|/**    * Implement fuzzy enumeration with linear brute force.    */
DECL|class|LinearFuzzyTermsEnum
specifier|private
class|class
name|LinearFuzzyTermsEnum
extends|extends
name|FilteredTermsEnum
block|{
comment|/* This should be somewhere around the average long word.      * If it is longer, we waste time and space. If it is shorter, we waste a      * little bit of time growing the array as we encounter longer words.      */
DECL|field|TYPICAL_LONGEST_WORD_IN_INDEX
specifier|private
specifier|static
specifier|final
name|int
name|TYPICAL_LONGEST_WORD_IN_INDEX
init|=
literal|19
decl_stmt|;
comment|/* Allows us save time required to create a new array      * every time similarity is called.      */
DECL|field|d
specifier|private
name|int
index|[]
index|[]
name|d
decl_stmt|;
comment|// this is the text, minus the prefix
DECL|field|text
specifier|private
specifier|final
name|int
index|[]
name|text
decl_stmt|;
DECL|field|maxDistances
specifier|private
specifier|final
name|int
index|[]
name|maxDistances
init|=
operator|new
name|int
index|[
name|TYPICAL_LONGEST_WORD_IN_INDEX
index|]
decl_stmt|;
DECL|field|boostAtt
specifier|private
specifier|final
name|MultiTermQuery
operator|.
name|BoostAttribute
name|boostAtt
init|=
name|attributes
argument_list|()
operator|.
name|addAttribute
argument_list|(
name|MultiTermQuery
operator|.
name|BoostAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Constructor for enumeration of all terms from specified<code>reader</code> which share a prefix of      * length<code>prefixLength</code> with<code>term</code> and which have a fuzzy similarity&gt;      *<code>minSimilarity</code>.      *<p>      * After calling the constructor the enumeration is already pointing to the first       * valid term if such a term exists.       *       * @param reader Delivers terms.      * @param term Pattern term.      * @param minSimilarity Minimum required similarity for terms from the reader. Default value is 0.5f.      * @param prefixLength Length of required common prefix. Default value is 0.      * @throws IOException      */
DECL|method|LinearFuzzyTermsEnum
specifier|public
name|LinearFuzzyTermsEnum
parameter_list|()
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|reader
argument_list|,
name|term
operator|.
name|field
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|text
operator|=
operator|new
name|int
index|[
name|termLength
operator|-
name|realPrefixLength
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|termText
argument_list|,
name|realPrefixLength
argument_list|,
name|text
argument_list|,
literal|0
argument_list|,
name|text
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|String
name|prefix
init|=
name|UnicodeUtil
operator|.
name|newString
argument_list|(
name|termText
argument_list|,
literal|0
argument_list|,
name|realPrefixLength
argument_list|)
decl_stmt|;
name|prefixBytesRef
operator|=
operator|new
name|BytesRef
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|initializeMaxDistances
argument_list|()
expr_stmt|;
name|this
operator|.
name|d
operator|=
name|initDistanceArray
argument_list|()
expr_stmt|;
name|setInitialSeekTerm
argument_list|(
name|prefixBytesRef
argument_list|)
expr_stmt|;
block|}
DECL|field|prefixBytesRef
specifier|private
specifier|final
name|BytesRef
name|prefixBytesRef
decl_stmt|;
comment|// used for unicode conversion from BytesRef byte[] to int[]
DECL|field|utf32
specifier|private
specifier|final
name|IntsRef
name|utf32
init|=
operator|new
name|IntsRef
argument_list|(
name|TYPICAL_LONGEST_WORD_IN_INDEX
argument_list|)
decl_stmt|;
comment|/**      * The termCompare method in FuzzyTermEnum uses Levenshtein distance to       * calculate the distance between the given term and the comparing term.       */
annotation|@
name|Override
DECL|method|accept
specifier|protected
specifier|final
name|AcceptStatus
name|accept
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
if|if
condition|(
name|term
operator|.
name|startsWith
argument_list|(
name|prefixBytesRef
argument_list|)
condition|)
block|{
name|UnicodeUtil
operator|.
name|UTF8toUTF32
argument_list|(
name|term
argument_list|,
name|utf32
argument_list|)
expr_stmt|;
specifier|final
name|float
name|similarity
init|=
name|similarity
argument_list|(
name|utf32
operator|.
name|ints
argument_list|,
name|realPrefixLength
argument_list|,
name|utf32
operator|.
name|length
operator|-
name|realPrefixLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|similarity
operator|>
name|minSimilarity
condition|)
block|{
name|boostAtt
operator|.
name|setBoost
argument_list|(
call|(
name|float
call|)
argument_list|(
operator|(
name|similarity
operator|-
name|minSimilarity
operator|)
operator|*
name|scale_factor
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|AcceptStatus
operator|.
name|YES
return|;
block|}
else|else
return|return
name|AcceptStatus
operator|.
name|NO
return|;
block|}
else|else
block|{
return|return
name|AcceptStatus
operator|.
name|END
return|;
block|}
block|}
comment|/******************************      * Compute Levenshtein distance      ******************************/
DECL|method|initDistanceArray
specifier|private
specifier|final
name|int
index|[]
index|[]
name|initDistanceArray
parameter_list|()
block|{
return|return
operator|new
name|int
index|[
name|this
operator|.
name|text
operator|.
name|length
operator|+
literal|1
index|]
index|[
name|TYPICAL_LONGEST_WORD_IN_INDEX
index|]
return|;
block|}
comment|/**      *<p>Similarity returns a number that is 1.0f or less (including negative numbers)      * based on how similar the Term is compared to a target term.  It returns      * exactly 0.0f when      *<pre>      *    editDistance&gt; maximumEditDistance</pre>      * Otherwise it returns:      *<pre>      *    1 - (editDistance / length)</pre>      * where length is the length of the shortest term (text or target) including a      * prefix that are identical and editDistance is the Levenshtein distance for      * the two words.</p>      *      *<p>Embedded within this algorithm is a fail-fast Levenshtein distance      * algorithm.  The fail-fast algorithm differs from the standard Levenshtein      * distance algorithm in that it is aborted if it is discovered that the      * minimum distance between the words is greater than some threshold.      *      *<p>To calculate the maximum distance threshold we use the following formula:      *<pre>      *     (1 - minimumSimilarity) * length</pre>      * where length is the shortest term including any prefix that is not part of the      * similarity comparison.  This formula was derived by solving for what maximum value      * of distance returns false for the following statements:      *<pre>      *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));      *   return (similarity> minimumSimilarity);</pre>      * where distance is the Levenshtein distance for the two words.      *</p>      *<p>Levenshtein distance (also known as edit distance) is a measure of similarity      * between two strings where the distance is measured as the number of character      * deletions, insertions or substitutions required to transform one string to      * the other string.      * @param target the target word or phrase      * @return the similarity,  0.0 or less indicates that it matches less than the required      * threshold and 1.0 indicates that the text and target are identical      */
DECL|method|similarity
specifier|private
specifier|final
name|float
name|similarity
parameter_list|(
specifier|final
name|int
index|[]
name|target
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
specifier|final
name|int
name|m
init|=
name|length
decl_stmt|;
specifier|final
name|int
name|n
init|=
name|text
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|//we don't have anything to compare.  That means if we just add
comment|//the letters for m we get the new word
return|return
name|realPrefixLength
operator|==
literal|0
condition|?
literal|0.0f
else|:
literal|1.0f
operator|-
operator|(
operator|(
name|float
operator|)
name|m
operator|/
name|realPrefixLength
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
return|return
name|realPrefixLength
operator|==
literal|0
condition|?
literal|0.0f
else|:
literal|1.0f
operator|-
operator|(
operator|(
name|float
operator|)
name|n
operator|/
name|realPrefixLength
operator|)
return|;
block|}
specifier|final
name|int
name|maxDistance
init|=
name|getMaxDistance
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxDistance
operator|<
name|Math
operator|.
name|abs
argument_list|(
name|m
operator|-
name|n
argument_list|)
condition|)
block|{
comment|//just adding the characters of m to n or vice-versa results in
comment|//too many edits
comment|//for example "pre" length is 3 and "prefixes" length is 8.  We can see that
comment|//given this optimal circumstance, the edit distance cannot be less than 5.
comment|//which is 8-3 or more precisely Math.abs(3-8).
comment|//if our maximum edit distance is 4, then we can discard this word
comment|//without looking at it.
return|return
literal|0.0f
return|;
block|}
comment|//let's make sure we have enough room in our array to do the distance calculations.
if|if
condition|(
name|d
index|[
literal|0
index|]
operator|.
name|length
operator|<=
name|m
condition|)
block|{
name|growDistanceArray
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|// init matrix d
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
name|d
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<=
name|m
condition|;
name|j
operator|++
control|)
name|d
index|[
literal|0
index|]
index|[
name|j
index|]
operator|=
name|j
expr_stmt|;
comment|// start computing edit distance
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bestPossibleEditDistance
init|=
name|m
decl_stmt|;
specifier|final
name|int
name|s_i
init|=
name|text
index|[
name|i
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<=
name|m
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|s_i
operator|!=
name|target
index|[
name|offset
operator|+
name|j
operator|-
literal|1
index|]
condition|)
block|{
name|d
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|min
argument_list|(
name|d
index|[
name|i
operator|-
literal|1
index|]
index|[
name|j
index|]
argument_list|,
name|d
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
argument_list|,
name|d
index|[
name|i
operator|-
literal|1
index|]
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|d
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|min
argument_list|(
name|d
index|[
name|i
operator|-
literal|1
index|]
index|[
name|j
index|]
operator|+
literal|1
argument_list|,
name|d
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
operator|+
literal|1
argument_list|,
name|d
index|[
name|i
operator|-
literal|1
index|]
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|bestPossibleEditDistance
operator|=
name|Math
operator|.
name|min
argument_list|(
name|bestPossibleEditDistance
argument_list|,
name|d
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|//After calculating row i, the best possible edit distance
comment|//can be found by found by finding the smallest value in a given column.
comment|//If the bestPossibleEditDistance is greater than the max distance, abort.
if|if
condition|(
name|i
operator|>
name|maxDistance
operator|&&
name|bestPossibleEditDistance
operator|>
name|maxDistance
condition|)
block|{
comment|//equal is okay, but not greater
comment|//the closest the target can be to the text is just too far away.
comment|//this target is leaving the party early.
return|return
literal|0.0f
return|;
block|}
block|}
comment|// this will return less than 0.0 when the edit distance is
comment|// greater than the number of characters in the shorter word.
comment|// but this was the formula that was previously used in FuzzyTermEnum,
comment|// so it has not been changed (even though minimumSimilarity must be
comment|// greater than 0.0)
return|return
literal|1.0f
operator|-
operator|(
operator|(
name|float
operator|)
name|d
index|[
name|n
index|]
index|[
name|m
index|]
operator|/
call|(
name|float
call|)
argument_list|(
name|realPrefixLength
operator|+
name|Math
operator|.
name|min
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
argument_list|)
operator|)
return|;
block|}
comment|/**      * Grow the second dimension of the array, so that we can calculate the      * Levenshtein difference.      */
DECL|method|growDistanceArray
specifier|private
name|void
name|growDistanceArray
parameter_list|(
name|int
name|m
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
operator|new
name|int
index|[
name|m
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
comment|/**      * The max Distance is the maximum Levenshtein distance for the text      * compared to some other value that results in score that is      * better than the minimum similarity.      * @param m the length of the "other value"      * @return the maximum levenshtein distance that we care about      */
DECL|method|getMaxDistance
specifier|private
specifier|final
name|int
name|getMaxDistance
parameter_list|(
name|int
name|m
parameter_list|)
block|{
return|return
operator|(
name|m
operator|<
name|maxDistances
operator|.
name|length
operator|)
condition|?
name|maxDistances
index|[
name|m
index|]
else|:
name|calculateMaxDistance
argument_list|(
name|m
argument_list|)
return|;
block|}
DECL|method|initializeMaxDistances
specifier|private
name|void
name|initializeMaxDistances
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxDistances
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|maxDistances
index|[
name|i
index|]
operator|=
name|calculateMaxDistance
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|calculateMaxDistance
specifier|private
name|int
name|calculateMaxDistance
parameter_list|(
name|int
name|m
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
operator|(
literal|1
operator|-
name|minSimilarity
operator|)
operator|*
operator|(
name|Math
operator|.
name|min
argument_list|(
name|text
operator|.
name|length
argument_list|,
name|m
argument_list|)
operator|+
name|realPrefixLength
operator|)
argument_list|)
return|;
block|}
block|}
block|}
end_class
end_unit
