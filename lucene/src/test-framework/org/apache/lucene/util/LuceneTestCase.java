begin_unit
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Documented
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Inherited
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Retention
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|RetentionPolicy
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
operator|.
name|Index
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
operator|.
name|Store
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
operator|.
name|TermVector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|CodecProvider
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|mockintblock
operator|.
name|MockFixedIntBlockCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|mockintblock
operator|.
name|MockVariableIntBlockCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|mocksep
operator|.
name|MockSepCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|mockrandom
operator|.
name|MockRandomCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|preflex
operator|.
name|PreFlexCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|preflexrw
operator|.
name|PreFlexRWCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|pulsing
operator|.
name|PulsingCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|simpletext
operator|.
name|SimpleTextCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|codecs
operator|.
name|standard
operator|.
name|StandardCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FieldCache
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FieldCache
operator|.
name|CacheEntry
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|LockFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MockDirectoryWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|FieldCacheSanityChecker
operator|.
name|Insanity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|TestWatchman
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|Description
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|RunWith
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|manipulation
operator|.
name|Filter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|manipulation
operator|.
name|NoTestsRemainException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|notification
operator|.
name|RunNotifier
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|BlockJUnit4ClassRunner
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|model
operator|.
name|FrameworkMethod
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|model
operator|.
name|InitializationError
import|;
end_import
begin_comment
comment|/**  * Base class for all Lucene unit tests, Junit3 or Junit4 variant.  *<p>  *</p>  *<p>  * If you  * override either<code>setUp()</code> or  *<code>tearDown()</code> in your unit test, make sure you  * call<code>super.setUp()</code> and  *<code>super.tearDown()</code>  *</p>  *  *<code>@After</code> - replaces setup  *<code>@Before</code> - replaces teardown  *<code>@Test</code> - any public method with this annotation is a test case, regardless  * of its name  *<p>  *<p>  * See Junit4<a href="http://junit.org/junit/javadoc/4.7/">documentation</a> for a complete list of features.  *<p>  * Import from org.junit rather than junit.framework.  *<p>  * You should be able to use this class anywhere you used LuceneTestCase  * if you annotate your derived class correctly with the annotations above  * @see #assertSaneFieldCaches(String)  */
end_comment
begin_class
annotation|@
name|RunWith
argument_list|(
name|LuceneTestCase
operator|.
name|LuceneTestCaseRunner
operator|.
name|class
argument_list|)
DECL|class|LuceneTestCase
specifier|public
specifier|abstract
class|class
name|LuceneTestCase
extends|extends
name|Assert
block|{
comment|/**    * true iff tests are run in verbose mode. Note: if it is false, tests are not    * expected to print any messages.    */
DECL|field|VERBOSE
specifier|public
specifier|static
specifier|final
name|boolean
name|VERBOSE
init|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"tests.verbose"
argument_list|)
decl_stmt|;
comment|/** Use this constant when creating Analyzers and any other version-dependent stuff.    *<p><b>NOTE:</b> Change this when development starts for new Lucene version:    */
DECL|field|TEST_VERSION_CURRENT
specifier|public
specifier|static
specifier|final
name|Version
name|TEST_VERSION_CURRENT
init|=
name|Version
operator|.
name|LUCENE_40
decl_stmt|;
comment|/**    * If this is set, it is the only method that should run.    */
DECL|field|TEST_METHOD
specifier|static
specifier|final
name|String
name|TEST_METHOD
decl_stmt|;
comment|/** Create indexes in this directory, optimally use a subdir, named after the test */
DECL|field|TEMP_DIR
specifier|public
specifier|static
specifier|final
name|File
name|TEMP_DIR
decl_stmt|;
static|static
block|{
name|String
name|method
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"testmethod"
argument_list|,
literal|""
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|TEST_METHOD
operator|=
name|method
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|method
expr_stmt|;
name|String
name|s
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tempDir"
argument_list|,
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.io.tmpdir"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"To run tests, you need to define system property 'tempDir' or 'java.io.tmpdir'."
argument_list|)
throw|;
name|TEMP_DIR
operator|=
operator|new
name|File
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|TEMP_DIR
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
block|}
comment|/** set of directories we created, in afterclass we try to clean these up */
DECL|field|tempDirs
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|tempDirs
init|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|// by default we randomly pick a different codec for
comment|// each test case (non-J4 tests) and each test class (J4
comment|// tests)
comment|/** Gets the codec to run tests with. */
DECL|field|TEST_CODEC
specifier|public
specifier|static
specifier|final
name|String
name|TEST_CODEC
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.codec"
argument_list|,
literal|"randomPerField"
argument_list|)
decl_stmt|;
comment|/** Gets the locale to run tests with */
DECL|field|TEST_LOCALE
specifier|public
specifier|static
specifier|final
name|String
name|TEST_LOCALE
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.locale"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** Gets the timezone to run tests with */
DECL|field|TEST_TIMEZONE
specifier|public
specifier|static
specifier|final
name|String
name|TEST_TIMEZONE
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.timezone"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** Gets the directory to run tests with */
DECL|field|TEST_DIRECTORY
specifier|public
specifier|static
specifier|final
name|String
name|TEST_DIRECTORY
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.directory"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** Get the number of times to run tests */
DECL|field|TEST_ITER
specifier|public
specifier|static
specifier|final
name|int
name|TEST_ITER
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.iter"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
decl_stmt|;
comment|/** Get the minimum number of times to run tests until a failure happens */
DECL|field|TEST_ITER_MIN
specifier|public
specifier|static
specifier|final
name|int
name|TEST_ITER_MIN
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.iter.min"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|TEST_ITER
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/** Get the random seed for tests */
DECL|field|TEST_SEED
specifier|public
specifier|static
specifier|final
name|String
name|TEST_SEED
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.seed"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** whether or not nightly tests should run */
DECL|field|TEST_NIGHTLY
specifier|public
specifier|static
specifier|final
name|boolean
name|TEST_NIGHTLY
init|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.nightly"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
comment|/** the line file used by LineFileDocs */
DECL|field|TEST_LINE_DOCS_FILE
specifier|public
specifier|static
specifier|final
name|String
name|TEST_LINE_DOCS_FILE
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.linedocsfile"
argument_list|,
literal|"europarl.lines.txt.gz"
argument_list|)
decl_stmt|;
comment|/** whether or not to clean threads between test invocations: "false", "perMethod", "perClass" */
DECL|field|TEST_CLEAN_THREADS
specifier|public
specifier|static
specifier|final
name|String
name|TEST_CLEAN_THREADS
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.cleanthreads"
argument_list|,
literal|"perClass"
argument_list|)
decl_stmt|;
DECL|field|codecWithParam
specifier|private
specifier|static
specifier|final
name|Pattern
name|codecWithParam
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"(.*)\\(\\s*(\\d+)\\s*\\)"
argument_list|)
decl_stmt|;
comment|/**    * A random multiplier which you should use when writing random tests:    * multiply it by the number of iterations    */
DECL|field|RANDOM_MULTIPLIER
specifier|public
specifier|static
specifier|final
name|int
name|RANDOM_MULTIPLIER
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.multiplier"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|savedBoolMaxClauseCount
specifier|private
name|int
name|savedBoolMaxClauseCount
decl_stmt|;
DECL|field|savedUncaughtExceptionHandler
specifier|private
specifier|volatile
name|Thread
operator|.
name|UncaughtExceptionHandler
name|savedUncaughtExceptionHandler
init|=
literal|null
decl_stmt|;
comment|/** Used to track if setUp and tearDown are called correctly from subclasses */
DECL|field|setup
specifier|private
name|boolean
name|setup
decl_stmt|;
comment|/**    * Some tests expect the directory to contain a single segment, and want to do tests on that segment's reader.    * This is an utility method to help them.    */
DECL|method|getOnlySegmentReader
specifier|public
specifier|static
name|SegmentReader
name|getOnlySegmentReader
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
block|{
if|if
condition|(
name|reader
operator|instanceof
name|SegmentReader
condition|)
return|return
operator|(
name|SegmentReader
operator|)
name|reader
return|;
name|IndexReader
index|[]
name|subReaders
init|=
name|reader
operator|.
name|getSequentialSubReaders
argument_list|()
decl_stmt|;
if|if
condition|(
name|subReaders
operator|.
name|length
operator|!=
literal|1
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|reader
operator|+
literal|" has "
operator|+
name|subReaders
operator|.
name|length
operator|+
literal|" segments instead of exactly one"
argument_list|)
throw|;
return|return
operator|(
name|SegmentReader
operator|)
name|subReaders
index|[
literal|0
index|]
return|;
block|}
DECL|class|UncaughtExceptionEntry
specifier|private
specifier|static
class|class
name|UncaughtExceptionEntry
block|{
DECL|field|thread
specifier|public
specifier|final
name|Thread
name|thread
decl_stmt|;
DECL|field|exception
specifier|public
specifier|final
name|Throwable
name|exception
decl_stmt|;
DECL|method|UncaughtExceptionEntry
specifier|public
name|UncaughtExceptionEntry
parameter_list|(
name|Thread
name|thread
parameter_list|,
name|Throwable
name|exception
parameter_list|)
block|{
name|this
operator|.
name|thread
operator|=
name|thread
expr_stmt|;
name|this
operator|.
name|exception
operator|=
name|exception
expr_stmt|;
block|}
block|}
DECL|field|uncaughtExceptions
specifier|private
name|List
argument_list|<
name|UncaughtExceptionEntry
argument_list|>
name|uncaughtExceptions
init|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|UncaughtExceptionEntry
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|// saves default codec: we do this statically as many build indexes in @beforeClass
DECL|field|savedDefaultCodec
specifier|private
specifier|static
name|String
name|savedDefaultCodec
decl_stmt|;
comment|// default codec: not set when we use a per-field provider.
DECL|field|codec
specifier|private
specifier|static
name|Codec
name|codec
decl_stmt|;
comment|// default codec provider
DECL|field|savedCodecProvider
specifier|private
specifier|static
name|CodecProvider
name|savedCodecProvider
decl_stmt|;
DECL|field|locale
specifier|private
specifier|static
name|Locale
name|locale
decl_stmt|;
DECL|field|savedLocale
specifier|private
specifier|static
name|Locale
name|savedLocale
decl_stmt|;
DECL|field|timeZone
specifier|private
specifier|static
name|TimeZone
name|timeZone
decl_stmt|;
DECL|field|savedTimeZone
specifier|private
specifier|static
name|TimeZone
name|savedTimeZone
decl_stmt|;
DECL|field|stores
specifier|private
specifier|static
name|Map
argument_list|<
name|MockDirectoryWrapper
argument_list|,
name|StackTraceElement
index|[]
argument_list|>
name|stores
decl_stmt|;
DECL|field|TEST_CODECS
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|TEST_CODECS
init|=
operator|new
name|String
index|[]
block|{
literal|"MockSep"
block|,
literal|"MockFixedIntBlock"
block|,
literal|"MockVariableIntBlock"
block|,
literal|"MockRandom"
block|}
decl_stmt|;
DECL|method|swapCodec
specifier|private
specifier|static
name|void
name|swapCodec
parameter_list|(
name|Codec
name|c
parameter_list|,
name|CodecProvider
name|cp
parameter_list|)
block|{
name|Codec
name|prior
init|=
literal|null
decl_stmt|;
try|try
block|{
name|prior
operator|=
name|cp
operator|.
name|lookup
argument_list|(
name|c
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{     }
if|if
condition|(
name|prior
operator|!=
literal|null
condition|)
block|{
name|cp
operator|.
name|unregister
argument_list|(
name|prior
argument_list|)
expr_stmt|;
block|}
name|cp
operator|.
name|register
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|// returns current default codec
DECL|method|installTestCodecs
specifier|static
name|Codec
name|installTestCodecs
parameter_list|(
name|String
name|codec
parameter_list|,
name|CodecProvider
name|cp
parameter_list|)
block|{
name|savedDefaultCodec
operator|=
name|cp
operator|.
name|getDefaultFieldCodec
argument_list|()
expr_stmt|;
specifier|final
name|boolean
name|codecHasParam
decl_stmt|;
name|int
name|codecParam
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|codec
operator|.
name|equals
argument_list|(
literal|"randomPerField"
argument_list|)
condition|)
block|{
comment|// lie
name|codec
operator|=
literal|"Standard"
expr_stmt|;
name|codecHasParam
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|codec
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
block|{
name|codec
operator|=
name|pickRandomCodec
argument_list|(
name|random
argument_list|)
expr_stmt|;
name|codecHasParam
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|Matcher
name|m
init|=
name|codecWithParam
operator|.
name|matcher
argument_list|(
name|codec
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|matches
argument_list|()
condition|)
block|{
comment|// codec has a fixed param
name|codecHasParam
operator|=
literal|true
expr_stmt|;
name|codec
operator|=
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|codecParam
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|m
operator|.
name|group
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|codecHasParam
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|cp
operator|.
name|setDefaultFieldCodec
argument_list|(
name|codec
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|.
name|equals
argument_list|(
literal|"PreFlex"
argument_list|)
condition|)
block|{
comment|// If we're running w/ PreFlex codec we must swap in the
comment|// test-only PreFlexRW codec (since core PreFlex can
comment|// only read segments):
name|swapCodec
argument_list|(
operator|new
name|PreFlexRWCodec
argument_list|()
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
name|swapCodec
argument_list|(
operator|new
name|MockSepCodec
argument_list|()
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|swapCodec
argument_list|(
operator|new
name|PulsingCodec
argument_list|(
name|codecHasParam
operator|&&
literal|"Pulsing"
operator|.
name|equals
argument_list|(
name|codec
argument_list|)
condition|?
name|codecParam
else|:
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|20
argument_list|)
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|swapCodec
argument_list|(
operator|new
name|MockFixedIntBlockCodec
argument_list|(
name|codecHasParam
operator|&&
literal|"MockFixedIntBlock"
operator|.
name|equals
argument_list|(
name|codec
argument_list|)
condition|?
name|codecParam
else|:
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|2000
argument_list|)
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|// baseBlockSize cannot be over 127:
name|swapCodec
argument_list|(
operator|new
name|MockVariableIntBlockCodec
argument_list|(
name|codecHasParam
operator|&&
literal|"MockVariableIntBlock"
operator|.
name|equals
argument_list|(
name|codec
argument_list|)
condition|?
name|codecParam
else|:
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|127
argument_list|)
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|swapCodec
argument_list|(
operator|new
name|MockRandomCodec
argument_list|(
name|random
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|cp
operator|.
name|lookup
argument_list|(
name|codec
argument_list|)
return|;
block|}
comment|// returns current PreFlex codec
DECL|method|removeTestCodecs
specifier|static
name|void
name|removeTestCodecs
parameter_list|(
name|Codec
name|codec
parameter_list|,
name|CodecProvider
name|cp
parameter_list|)
block|{
if|if
condition|(
name|codec
operator|.
name|name
operator|.
name|equals
argument_list|(
literal|"PreFlex"
argument_list|)
condition|)
block|{
specifier|final
name|Codec
name|preFlex
init|=
name|cp
operator|.
name|lookup
argument_list|(
literal|"PreFlex"
argument_list|)
decl_stmt|;
if|if
condition|(
name|preFlex
operator|!=
literal|null
condition|)
block|{
name|cp
operator|.
name|unregister
argument_list|(
name|preFlex
argument_list|)
expr_stmt|;
block|}
name|cp
operator|.
name|register
argument_list|(
operator|new
name|PreFlexCodec
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|cp
operator|.
name|unregister
argument_list|(
name|cp
operator|.
name|lookup
argument_list|(
literal|"MockSep"
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|.
name|unregister
argument_list|(
name|cp
operator|.
name|lookup
argument_list|(
literal|"MockFixedIntBlock"
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|.
name|unregister
argument_list|(
name|cp
operator|.
name|lookup
argument_list|(
literal|"MockVariableIntBlock"
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|.
name|unregister
argument_list|(
name|cp
operator|.
name|lookup
argument_list|(
literal|"MockRandom"
argument_list|)
argument_list|)
expr_stmt|;
name|swapCodec
argument_list|(
operator|new
name|PulsingCodec
argument_list|(
literal|1
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|.
name|setDefaultFieldCodec
argument_list|(
name|savedDefaultCodec
argument_list|)
expr_stmt|;
block|}
comment|// randomly picks from core and test codecs
DECL|method|pickRandomCodec
specifier|static
name|String
name|pickRandomCodec
parameter_list|(
name|Random
name|rnd
parameter_list|)
block|{
name|int
name|idx
init|=
name|rnd
operator|.
name|nextInt
argument_list|(
name|CodecProvider
operator|.
name|CORE_CODECS
operator|.
name|length
operator|+
name|TEST_CODECS
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|<
name|CodecProvider
operator|.
name|CORE_CODECS
operator|.
name|length
condition|)
block|{
return|return
name|CodecProvider
operator|.
name|CORE_CODECS
index|[
name|idx
index|]
return|;
block|}
else|else
block|{
return|return
name|TEST_CODECS
index|[
name|idx
operator|-
name|CodecProvider
operator|.
name|CORE_CODECS
operator|.
name|length
index|]
return|;
block|}
block|}
DECL|class|TwoLongs
specifier|private
specifier|static
class|class
name|TwoLongs
block|{
DECL|field|l1
DECL|field|l2
specifier|public
specifier|final
name|long
name|l1
decl_stmt|,
name|l2
decl_stmt|;
DECL|method|TwoLongs
specifier|public
name|TwoLongs
parameter_list|(
name|long
name|l1
parameter_list|,
name|long
name|l2
parameter_list|)
block|{
name|this
operator|.
name|l1
operator|=
name|l1
expr_stmt|;
name|this
operator|.
name|l2
operator|=
name|l2
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|l1
operator|+
literal|":"
operator|+
name|l2
return|;
block|}
DECL|method|fromString
specifier|public
specifier|static
name|TwoLongs
name|fromString
parameter_list|(
name|String
name|s
parameter_list|)
block|{
specifier|final
name|int
name|i
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
assert|assert
name|i
operator|!=
operator|-
literal|1
assert|;
return|return
operator|new
name|TwoLongs
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|Long
operator|.
name|parseLong
argument_list|(
name|s
operator|.
name|substring
argument_list|(
literal|1
operator|+
name|i
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** @deprecated (4.0) until we fix no-fork problems in solr tests */
annotation|@
name|Deprecated
DECL|field|testClassesRun
specifier|private
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|testClassesRun
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
annotation|@
name|BeforeClass
DECL|method|beforeClassLuceneTestCaseJ4
specifier|public
specifier|static
name|void
name|beforeClassLuceneTestCaseJ4
parameter_list|()
block|{
name|staticSeed
operator|=
literal|"random"
operator|.
name|equals
argument_list|(
name|TEST_SEED
argument_list|)
condition|?
name|seedRand
operator|.
name|nextLong
argument_list|()
else|:
name|TwoLongs
operator|.
name|fromString
argument_list|(
name|TEST_SEED
argument_list|)
operator|.
name|l1
expr_stmt|;
name|random
operator|.
name|setSeed
argument_list|(
name|staticSeed
argument_list|)
expr_stmt|;
name|tempDirs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|stores
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|IdentityHashMap
argument_list|<
name|MockDirectoryWrapper
argument_list|,
name|StackTraceElement
index|[]
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|savedCodecProvider
operator|=
name|CodecProvider
operator|.
name|getDefault
argument_list|()
expr_stmt|;
if|if
condition|(
literal|"randomPerField"
operator|.
name|equals
argument_list|(
name|TEST_CODEC
argument_list|)
condition|)
block|{
if|if
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// preflex-only setup
name|codec
operator|=
name|installTestCodecs
argument_list|(
literal|"PreFlex"
argument_list|,
name|CodecProvider
operator|.
name|getDefault
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// per-field setup
name|CodecProvider
operator|.
name|setDefault
argument_list|(
operator|new
name|RandomCodecProvider
argument_list|(
name|random
argument_list|)
argument_list|)
expr_stmt|;
name|codec
operator|=
name|installTestCodecs
argument_list|(
name|TEST_CODEC
argument_list|,
name|CodecProvider
operator|.
name|getDefault
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// ordinary setup
name|codec
operator|=
name|installTestCodecs
argument_list|(
name|TEST_CODEC
argument_list|,
name|CodecProvider
operator|.
name|getDefault
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|savedLocale
operator|=
name|Locale
operator|.
name|getDefault
argument_list|()
expr_stmt|;
name|locale
operator|=
name|TEST_LOCALE
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|?
name|randomLocale
argument_list|(
name|random
argument_list|)
else|:
name|localeForName
argument_list|(
name|TEST_LOCALE
argument_list|)
expr_stmt|;
name|Locale
operator|.
name|setDefault
argument_list|(
name|locale
argument_list|)
expr_stmt|;
name|savedTimeZone
operator|=
name|TimeZone
operator|.
name|getDefault
argument_list|()
expr_stmt|;
name|timeZone
operator|=
name|TEST_TIMEZONE
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|?
name|randomTimeZone
argument_list|(
name|random
argument_list|)
else|:
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
name|TEST_TIMEZONE
argument_list|)
expr_stmt|;
name|TimeZone
operator|.
name|setDefault
argument_list|(
name|timeZone
argument_list|)
expr_stmt|;
name|testsFailed
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|AfterClass
DECL|method|afterClassLuceneTestCaseJ4
specifier|public
specifier|static
name|void
name|afterClassLuceneTestCaseJ4
parameter_list|()
block|{
if|if
condition|(
operator|!
literal|"false"
operator|.
name|equals
argument_list|(
name|TEST_CLEAN_THREADS
argument_list|)
condition|)
block|{
name|int
name|rogueThreads
init|=
name|threadCleanup
argument_list|(
literal|"test class"
argument_list|)
decl_stmt|;
if|if
condition|(
name|rogueThreads
operator|>
literal|0
condition|)
block|{
comment|// TODO: fail here once the leaks are fixed.
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"RESOURCE LEAK: test class left "
operator|+
name|rogueThreads
operator|+
literal|" thread(s) running"
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|codecDescription
decl_stmt|;
name|CodecProvider
name|cp
init|=
name|CodecProvider
operator|.
name|getDefault
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"randomPerField"
operator|.
name|equals
argument_list|(
name|TEST_CODEC
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp
operator|instanceof
name|RandomCodecProvider
condition|)
name|codecDescription
operator|=
name|cp
operator|.
name|toString
argument_list|()
expr_stmt|;
else|else
name|codecDescription
operator|=
literal|"PreFlex"
expr_stmt|;
block|}
else|else
block|{
name|codecDescription
operator|=
name|codec
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|CodecProvider
operator|.
name|getDefault
argument_list|()
operator|==
name|savedCodecProvider
condition|)
name|removeTestCodecs
argument_list|(
name|codec
argument_list|,
name|CodecProvider
operator|.
name|getDefault
argument_list|()
argument_list|)
expr_stmt|;
name|CodecProvider
operator|.
name|setDefault
argument_list|(
name|savedCodecProvider
argument_list|)
expr_stmt|;
name|Locale
operator|.
name|setDefault
argument_list|(
name|savedLocale
argument_list|)
expr_stmt|;
name|TimeZone
operator|.
name|setDefault
argument_list|(
name|savedTimeZone
argument_list|)
expr_stmt|;
name|System
operator|.
name|clearProperty
argument_list|(
literal|"solr.solr.home"
argument_list|)
expr_stmt|;
name|System
operator|.
name|clearProperty
argument_list|(
literal|"solr.data.dir"
argument_list|)
expr_stmt|;
comment|// now look for unclosed resources
if|if
condition|(
operator|!
name|testsFailed
condition|)
for|for
control|(
name|MockDirectoryWrapper
name|d
range|:
name|stores
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|d
operator|.
name|isOpen
argument_list|()
condition|)
block|{
name|StackTraceElement
name|elements
index|[]
init|=
name|stores
operator|.
name|get
argument_list|(
name|d
argument_list|)
decl_stmt|;
comment|// Look for the first class that is not LuceneTestCase that requested
comment|// a Directory. The first two items are of Thread's, so skipping over
comment|// them.
name|StackTraceElement
name|element
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|elements
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|StackTraceElement
name|ste
init|=
name|elements
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ste
operator|.
name|getClassName
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"LuceneTestCase"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|element
operator|=
name|ste
expr_stmt|;
break|break;
block|}
block|}
name|fail
argument_list|(
literal|"directory of test was not closed, opened from: "
operator|+
name|element
argument_list|)
expr_stmt|;
block|}
block|}
name|stores
operator|=
literal|null
expr_stmt|;
comment|// if verbose or tests failed, report some information back
if|if
condition|(
name|VERBOSE
operator|||
name|testsFailed
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"NOTE: test params are: codec="
operator|+
name|codecDescription
operator|+
literal|", locale="
operator|+
name|locale
operator|+
literal|", timezone="
operator|+
operator|(
name|timeZone
operator|==
literal|null
condition|?
literal|"(null)"
else|:
name|timeZone
operator|.
name|getID
argument_list|()
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|testsFailed
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"NOTE: all tests run in this JVM:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|Arrays
operator|.
name|toString
argument_list|(
name|testClassesRun
operator|.
name|toArray
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"NOTE: "
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.name"
argument_list|)
operator|+
literal|" "
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.version"
argument_list|)
operator|+
literal|" "
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.arch"
argument_list|)
operator|+
literal|"/"
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.vendor"
argument_list|)
operator|+
literal|" "
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.version"
argument_list|)
operator|+
literal|" "
operator|+
operator|(
name|Constants
operator|.
name|JRE_IS_64BIT
condition|?
literal|"(64-bit)"
else|:
literal|"(32-bit)"
operator|)
operator|+
literal|"/"
operator|+
literal|"cpus="
operator|+
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
operator|+
literal|","
operator|+
literal|"threads="
operator|+
name|Thread
operator|.
name|activeCount
argument_list|()
operator|+
literal|","
operator|+
literal|"free="
operator|+
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|freeMemory
argument_list|()
operator|+
literal|","
operator|+
literal|"total="
operator|+
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|totalMemory
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// clear out any temp directories if we can
if|if
condition|(
operator|!
name|testsFailed
condition|)
block|{
for|for
control|(
name|String
name|path
range|:
name|tempDirs
control|)
block|{
try|try
block|{
name|_TestUtil
operator|.
name|rmDir
argument_list|(
operator|new
name|File
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|field|testsFailed
specifier|private
specifier|static
name|boolean
name|testsFailed
decl_stmt|;
comment|/* true if any tests failed */
comment|// This is how we get control when errors occur.
comment|// Think of this as start/end/success/failed
comment|// events.
annotation|@
name|Rule
DECL|field|intercept
specifier|public
specifier|final
name|TestWatchman
name|intercept
init|=
operator|new
name|TestWatchman
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|failed
parameter_list|(
name|Throwable
name|e
parameter_list|,
name|FrameworkMethod
name|method
parameter_list|)
block|{
comment|// org.junit.internal.AssumptionViolatedException in older releases
comment|// org.junit.Assume.AssumptionViolatedException in recent ones
if|if
condition|(
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|"AssumptionViolatedException"
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|TestIgnoredException
condition|)
name|e
operator|=
name|e
operator|.
name|getCause
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|print
argument_list|(
literal|"NOTE: Assume failed in '"
operator|+
name|method
operator|.
name|getName
argument_list|()
operator|+
literal|"' (ignored):"
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|print
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|testsFailed
operator|=
literal|true
expr_stmt|;
name|reportAdditionalFailureInfo
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|failed
argument_list|(
name|e
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|starting
parameter_list|(
name|FrameworkMethod
name|method
parameter_list|)
block|{
comment|// set current method name for logging
name|LuceneTestCase
operator|.
name|this
operator|.
name|name
operator|=
name|method
operator|.
name|getName
argument_list|()
expr_stmt|;
name|super
operator|.
name|starting
argument_list|(
name|method
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
annotation|@
name|Before
DECL|method|setUp
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|seed
operator|=
literal|"random"
operator|.
name|equals
argument_list|(
name|TEST_SEED
argument_list|)
condition|?
name|seedRand
operator|.
name|nextLong
argument_list|()
else|:
name|TwoLongs
operator|.
name|fromString
argument_list|(
name|TEST_SEED
argument_list|)
operator|.
name|l2
expr_stmt|;
name|random
operator|.
name|setSeed
argument_list|(
name|seed
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"ensure your tearDown() calls super.tearDown()!!!"
argument_list|,
name|setup
argument_list|)
expr_stmt|;
name|setup
operator|=
literal|true
expr_stmt|;
name|savedUncaughtExceptionHandler
operator|=
name|Thread
operator|.
name|getDefaultUncaughtExceptionHandler
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|setDefaultUncaughtExceptionHandler
argument_list|(
operator|new
name|Thread
operator|.
name|UncaughtExceptionHandler
argument_list|()
block|{
specifier|public
name|void
name|uncaughtException
parameter_list|(
name|Thread
name|t
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
name|testsFailed
operator|=
literal|true
expr_stmt|;
name|uncaughtExceptions
operator|.
name|add
argument_list|(
operator|new
name|UncaughtExceptionEntry
argument_list|(
name|t
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|savedUncaughtExceptionHandler
operator|!=
literal|null
condition|)
name|savedUncaughtExceptionHandler
operator|.
name|uncaughtException
argument_list|(
name|t
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|savedBoolMaxClauseCount
operator|=
name|BooleanQuery
operator|.
name|getMaxClauseCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Forcible purges all cache entries from the FieldCache.    *<p>    * This method will be called by tearDown to clean up FieldCache.DEFAULT.    * If a (poorly written) test has some expectation that the FieldCache    * will persist across test methods (ie: a static IndexReader) this    * method can be overridden to do nothing.    *</p>    *    * @see FieldCache#purgeAllCaches()    */
DECL|method|purgeFieldCache
specifier|protected
name|void
name|purgeFieldCache
parameter_list|(
specifier|final
name|FieldCache
name|fc
parameter_list|)
block|{
name|fc
operator|.
name|purgeAllCaches
argument_list|()
expr_stmt|;
block|}
DECL|method|getTestLabel
specifier|protected
name|String
name|getTestLabel
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"."
operator|+
name|getName
argument_list|()
return|;
block|}
annotation|@
name|After
DECL|method|tearDown
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
name|assertTrue
argument_list|(
literal|"ensure your setUp() calls super.setUp()!!!"
argument_list|,
name|setup
argument_list|)
expr_stmt|;
name|setup
operator|=
literal|false
expr_stmt|;
name|BooleanQuery
operator|.
name|setMaxClauseCount
argument_list|(
name|savedBoolMaxClauseCount
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"perMethod"
operator|.
name|equals
argument_list|(
name|TEST_CLEAN_THREADS
argument_list|)
condition|)
block|{
name|int
name|rogueThreads
init|=
name|threadCleanup
argument_list|(
literal|"test method: '"
operator|+
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
decl_stmt|;
if|if
condition|(
name|rogueThreads
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"RESOURCE LEAK: test method: '"
operator|+
name|getName
argument_list|()
operator|+
literal|"' left "
operator|+
name|rogueThreads
operator|+
literal|" thread(s) running"
argument_list|)
expr_stmt|;
comment|// TODO: fail, but print seed for now.
if|if
condition|(
operator|!
name|testsFailed
operator|&&
name|uncaughtExceptions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|reportAdditionalFailureInfo
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|Thread
operator|.
name|setDefaultUncaughtExceptionHandler
argument_list|(
name|savedUncaughtExceptionHandler
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|uncaughtExceptions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|testsFailed
operator|=
literal|true
expr_stmt|;
name|reportAdditionalFailureInfo
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"The following exceptions were thrown by threads:"
argument_list|)
expr_stmt|;
for|for
control|(
name|UncaughtExceptionEntry
name|entry
range|:
name|uncaughtExceptions
control|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"*** Thread: "
operator|+
name|entry
operator|.
name|thread
operator|.
name|getName
argument_list|()
operator|+
literal|" ***"
argument_list|)
expr_stmt|;
name|entry
operator|.
name|exception
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
block|}
name|fail
argument_list|(
literal|"Some threads threw uncaught exceptions!"
argument_list|)
expr_stmt|;
block|}
comment|// calling assertSaneFieldCaches here isn't as useful as having test
comment|// classes call it directly from the scope where the index readers
comment|// are used, because they could be gc'ed just before this tearDown
comment|// method is called.
comment|//
comment|// But it's better then nothing.
comment|//
comment|// If you are testing functionality that you know for a fact
comment|// "violates" FieldCache sanity, then you should either explicitly
comment|// call purgeFieldCache at the end of your test method, or refactor
comment|// your Test class so that the inconsistant FieldCache usages are
comment|// isolated in distinct test methods
name|assertSaneFieldCaches
argument_list|(
name|getTestLabel
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|purgeFieldCache
argument_list|(
name|FieldCache
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|THREAD_STOP_GRACE_MSEC
specifier|private
specifier|final
specifier|static
name|int
name|THREAD_STOP_GRACE_MSEC
init|=
literal|50
decl_stmt|;
comment|// jvm-wide list of 'rogue threads' we found, so they only get reported once.
DECL|field|rogueThreads
specifier|private
specifier|final
specifier|static
name|IdentityHashMap
argument_list|<
name|Thread
argument_list|,
name|Boolean
argument_list|>
name|rogueThreads
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|Thread
argument_list|,
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
comment|// just a hack for things like eclipse test-runner threads
for|for
control|(
name|Thread
name|t
range|:
name|Thread
operator|.
name|getAllStackTraces
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
name|rogueThreads
operator|.
name|put
argument_list|(
name|t
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Looks for leftover running threads, trying to kill them off,    * so they don't fail future tests.    * returns the number of rogue threads that it found.    */
DECL|method|threadCleanup
specifier|private
specifier|static
name|int
name|threadCleanup
parameter_list|(
name|String
name|context
parameter_list|)
block|{
comment|// educated guess
name|Thread
index|[]
name|stillRunning
init|=
operator|new
name|Thread
index|[
name|Thread
operator|.
name|activeCount
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|threadCount
init|=
literal|0
decl_stmt|;
name|int
name|rogueCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|threadCount
operator|=
name|Thread
operator|.
name|enumerate
argument_list|(
name|stillRunning
argument_list|)
operator|)
operator|>
literal|1
condition|)
block|{
while|while
condition|(
name|threadCount
operator|==
name|stillRunning
operator|.
name|length
condition|)
block|{
comment|// truncated response
name|stillRunning
operator|=
operator|new
name|Thread
index|[
name|stillRunning
operator|.
name|length
operator|*
literal|2
index|]
expr_stmt|;
name|threadCount
operator|=
name|Thread
operator|.
name|enumerate
argument_list|(
name|stillRunning
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadCount
condition|;
name|i
operator|++
control|)
block|{
name|Thread
name|t
init|=
name|stillRunning
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|isAlive
argument_list|()
operator|&&
operator|!
name|rogueThreads
operator|.
name|containsKey
argument_list|(
name|t
argument_list|)
operator|&&
name|t
operator|!=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|&&
comment|/* its ok to keep your searcher across test cases */
operator|(
name|t
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"LuceneTestCase"
argument_list|)
operator|&&
name|context
operator|.
name|startsWith
argument_list|(
literal|"test method"
argument_list|)
operator|)
operator|==
literal|false
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"WARNING: "
operator|+
name|context
operator|+
literal|" left thread running: "
operator|+
name|t
argument_list|)
expr_stmt|;
name|rogueThreads
operator|.
name|put
argument_list|(
name|t
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|rogueCount
operator|++
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"LuceneTestCase"
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"PLEASE CLOSE YOUR INDEXSEARCHERS IN YOUR TEST!!!!"
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|// wait on the thread to die of natural causes
try|try
block|{
name|t
operator|.
name|join
argument_list|(
name|THREAD_STOP_GRACE_MSEC
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|// try to stop the thread:
name|t
operator|.
name|setUncaughtExceptionHandler
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|setDefaultUncaughtExceptionHandler
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"SyncThread"
argument_list|)
condition|)
comment|// avoid zookeeper jre crash
name|t
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|rogueCount
return|;
block|}
comment|/**    * Asserts that FieldCacheSanityChecker does not detect any    * problems with FieldCache.DEFAULT.    *<p>    * If any problems are found, they are logged to System.err    * (allong with the msg) when the Assertion is thrown.    *</p>    *<p>    * This method is called by tearDown after every test method,    * however IndexReaders scoped inside test methods may be garbage    * collected prior to this method being called, causing errors to    * be overlooked. Tests are encouraged to keep their IndexReaders    * scoped at the class level, or to explicitly call this method    * directly in the same scope as the IndexReader.    *</p>    *    * @see org.apache.lucene.util.FieldCacheSanityChecker    */
DECL|method|assertSaneFieldCaches
specifier|protected
name|void
name|assertSaneFieldCaches
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|)
block|{
specifier|final
name|CacheEntry
index|[]
name|entries
init|=
name|FieldCache
operator|.
name|DEFAULT
operator|.
name|getCacheEntries
argument_list|()
decl_stmt|;
name|Insanity
index|[]
name|insanity
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|insanity
operator|=
name|FieldCacheSanityChecker
operator|.
name|checkSanity
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|dumpArray
argument_list|(
name|msg
operator|+
literal|": FieldCache"
argument_list|,
name|entries
argument_list|,
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|assertEquals
argument_list|(
name|msg
operator|+
literal|": Insane FieldCache usage(s) found"
argument_list|,
literal|0
argument_list|,
name|insanity
operator|.
name|length
argument_list|)
expr_stmt|;
name|insanity
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
comment|// report this in the event of any exception/failure
comment|// if no failure, then insanity will be null anyway
if|if
condition|(
literal|null
operator|!=
name|insanity
condition|)
block|{
name|dumpArray
argument_list|(
name|msg
operator|+
literal|": Insane FieldCache usage(s)"
argument_list|,
name|insanity
argument_list|,
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// @deprecated (4.0) These deprecated methods should be removed soon, when all tests using no Epsilon are fixed:
annotation|@
name|Deprecated
DECL|method|assertEquals
specifier|static
specifier|public
name|void
name|assertEquals
parameter_list|(
name|double
name|expected
parameter_list|,
name|double
name|actual
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|null
argument_list|,
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Deprecated
DECL|method|assertEquals
specifier|static
specifier|public
name|void
name|assertEquals
parameter_list|(
name|String
name|message
parameter_list|,
name|double
name|expected
parameter_list|,
name|double
name|actual
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|message
argument_list|,
name|Double
operator|.
name|valueOf
argument_list|(
name|expected
argument_list|)
argument_list|,
name|Double
operator|.
name|valueOf
argument_list|(
name|actual
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Deprecated
DECL|method|assertEquals
specifier|static
specifier|public
name|void
name|assertEquals
parameter_list|(
name|float
name|expected
parameter_list|,
name|float
name|actual
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|null
argument_list|,
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Deprecated
DECL|method|assertEquals
specifier|static
specifier|public
name|void
name|assertEquals
parameter_list|(
name|String
name|message
parameter_list|,
name|float
name|expected
parameter_list|,
name|float
name|actual
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|message
argument_list|,
name|Float
operator|.
name|valueOf
argument_list|(
name|expected
argument_list|)
argument_list|,
name|Float
operator|.
name|valueOf
argument_list|(
name|actual
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Replacement for Assume jUnit class, so we can add a message with explanation:
DECL|class|TestIgnoredException
specifier|private
specifier|static
specifier|final
class|class
name|TestIgnoredException
extends|extends
name|RuntimeException
block|{
DECL|method|TestIgnoredException
name|TestIgnoredException
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
DECL|method|TestIgnoredException
name|TestIgnoredException
parameter_list|(
name|String
name|msg
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getMessage
specifier|public
name|String
name|getMessage
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|super
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|getCause
argument_list|()
operator|!=
literal|null
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" - "
argument_list|)
operator|.
name|append
argument_list|(
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// only this one is called by our code, exception is not used outside this class:
annotation|@
name|Override
DECL|method|printStackTrace
specifier|public
name|void
name|printStackTrace
parameter_list|(
name|PrintStream
name|s
parameter_list|)
block|{
if|if
condition|(
name|getCause
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|println
argument_list|(
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|" - Caused by:"
argument_list|)
expr_stmt|;
name|getCause
argument_list|()
operator|.
name|printStackTrace
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|super
operator|.
name|printStackTrace
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|assumeTrue
specifier|public
specifier|static
name|void
name|assumeTrue
parameter_list|(
name|String
name|msg
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
name|Assume
operator|.
name|assumeNoException
argument_list|(
name|b
condition|?
literal|null
else|:
operator|new
name|TestIgnoredException
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|assumeFalse
specifier|public
specifier|static
name|void
name|assumeFalse
parameter_list|(
name|String
name|msg
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
name|assumeTrue
argument_list|(
name|msg
argument_list|,
operator|!
name|b
argument_list|)
expr_stmt|;
block|}
DECL|method|assumeNoException
specifier|public
specifier|static
name|void
name|assumeNoException
parameter_list|(
name|String
name|msg
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|Assume
operator|.
name|assumeNoException
argument_list|(
name|e
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|TestIgnoredException
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|asSet
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Set
argument_list|<
name|T
argument_list|>
name|asSet
parameter_list|(
name|T
modifier|...
name|args
parameter_list|)
block|{
return|return
operator|new
name|HashSet
argument_list|<
name|T
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|args
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Convinience method for logging an iterator.    *    * @param label  String logged before/after the items in the iterator    * @param iter   Each next() is toString()ed and logged on it's own line. If iter is null this is logged differnetly then an empty iterator.    * @param stream Stream to log messages to.    */
DECL|method|dumpIterator
specifier|public
specifier|static
name|void
name|dumpIterator
parameter_list|(
name|String
name|label
parameter_list|,
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
parameter_list|,
name|PrintStream
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|println
argument_list|(
literal|"*** BEGIN "
operator|+
name|label
operator|+
literal|" ***"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|iter
condition|)
block|{
name|stream
operator|.
name|println
argument_list|(
literal|" ... NULL ..."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|stream
operator|.
name|println
argument_list|(
name|iter
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|stream
operator|.
name|println
argument_list|(
literal|"*** END "
operator|+
name|label
operator|+
literal|" ***"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Convinience method for logging an array.  Wraps the array in an iterator and delegates    *    * @see #dumpIterator(String,Iterator,PrintStream)    */
DECL|method|dumpArray
specifier|public
specifier|static
name|void
name|dumpArray
parameter_list|(
name|String
name|label
parameter_list|,
name|Object
index|[]
name|objs
parameter_list|,
name|PrintStream
name|stream
parameter_list|)
block|{
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
init|=
operator|(
literal|null
operator|==
name|objs
operator|)
condition|?
literal|null
else|:
name|Arrays
operator|.
name|asList
argument_list|(
name|objs
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|dumpIterator
argument_list|(
name|label
argument_list|,
name|iter
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/** create a new index writer config with random defaults */
DECL|method|newIndexWriterConfig
specifier|public
specifier|static
name|IndexWriterConfig
name|newIndexWriterConfig
parameter_list|(
name|Version
name|v
parameter_list|,
name|Analyzer
name|a
parameter_list|)
block|{
return|return
name|newIndexWriterConfig
argument_list|(
name|random
argument_list|,
name|v
argument_list|,
name|a
argument_list|)
return|;
block|}
DECL|method|newIndexWriterConfig
specifier|public
specifier|static
name|IndexWriterConfig
name|newIndexWriterConfig
parameter_list|(
name|Random
name|r
parameter_list|,
name|Version
name|v
parameter_list|,
name|Analyzer
name|a
parameter_list|)
block|{
name|IndexWriterConfig
name|c
init|=
operator|new
name|IndexWriterConfig
argument_list|(
name|v
argument_list|,
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|c
operator|.
name|setMergeScheduler
argument_list|(
operator|new
name|SerialMergeScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|r
operator|.
name|nextInt
argument_list|(
literal|20
argument_list|)
operator|==
literal|17
condition|)
block|{
name|c
operator|.
name|setMaxBufferedDocs
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|.
name|setMaxBufferedDocs
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|c
operator|.
name|setTermIndexInterval
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|c
operator|.
name|setIndexerThreadPool
argument_list|(
operator|new
name|ThreadAffinityDocumentsWriterThreadPool
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
literal|20
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|c
operator|.
name|setMergePolicy
argument_list|(
name|newTieredMergePolicy
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|c
operator|.
name|setMergePolicy
argument_list|(
name|newLogMergePolicy
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|.
name|setMergePolicy
argument_list|(
operator|new
name|MockRandomMergePolicy
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|.
name|setReaderPooling
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|c
operator|.
name|setReaderTermsIndexDivisor
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|()
block|{
return|return
name|newLogMergePolicy
argument_list|(
name|random
argument_list|)
return|;
block|}
DECL|method|newTieredMergePolicy
specifier|public
specifier|static
name|TieredMergePolicy
name|newTieredMergePolicy
parameter_list|()
block|{
return|return
name|newTieredMergePolicy
argument_list|(
name|random
argument_list|)
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|r
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|LogDocMergePolicy
argument_list|()
else|:
operator|new
name|LogByteSizeMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setUseCompoundFile
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|logmp
operator|.
name|setCalibrateSizeByDeletes
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|==
literal|2
condition|)
block|{
name|logmp
operator|.
name|setMergeFactor
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|20
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|logmp
return|;
block|}
DECL|method|newTieredMergePolicy
specifier|public
specifier|static
name|TieredMergePolicy
name|newTieredMergePolicy
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
name|TieredMergePolicy
name|tmp
init|=
operator|new
name|TieredMergePolicy
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|==
literal|2
condition|)
block|{
name|tmp
operator|.
name|setMaxMergeAtOnce
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setMaxMergeAtOnceExplicit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|setMaxMergeAtOnce
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|20
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setMaxMergeAtOnceExplicit
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|30
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|.
name|setMaxMergedSegmentMB
argument_list|(
literal|0.2
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|2.0
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setFloorSegmentMB
argument_list|(
literal|0.2
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|2.0
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setExpungeDeletesPctAllowed
argument_list|(
literal|0.0
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|30.0
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setSegmentsPerTier
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|20
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setUseCompoundFile
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setNoCFSRatio
argument_list|(
literal|0.1
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|0.8
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|(
name|boolean
name|useCFS
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|newLogMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setUseCompoundFile
argument_list|(
name|useCFS
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|(
name|boolean
name|useCFS
parameter_list|,
name|int
name|mergeFactor
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|newLogMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setUseCompoundFile
argument_list|(
name|useCFS
argument_list|)
expr_stmt|;
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|mergeFactor
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|(
name|int
name|mergeFactor
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|newLogMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|mergeFactor
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
comment|/**    * Returns a new Directory instance. Use this when the test does not    * care about the specific Directory implementation (most tests).    *<p>    * The Directory is wrapped with {@link MockDirectoryWrapper}.    * By default this means it will be picky, such as ensuring that you    * properly close it and all open files in your test. It will emulate    * some features of Windows, such as not allowing open files to be    * overwritten.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newDirectory
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|newDirectory
argument_list|(
name|random
argument_list|)
return|;
block|}
DECL|method|newDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newDirectory
parameter_list|(
name|Random
name|r
parameter_list|)
throws|throws
name|IOException
block|{
name|Directory
name|impl
init|=
name|newDirectoryImpl
argument_list|(
name|r
argument_list|,
name|TEST_DIRECTORY
argument_list|)
decl_stmt|;
name|MockDirectoryWrapper
name|dir
init|=
operator|new
name|MockDirectoryWrapper
argument_list|(
name|r
argument_list|,
name|impl
argument_list|)
decl_stmt|;
name|stores
operator|.
name|put
argument_list|(
name|dir
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getStackTrace
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|dir
return|;
block|}
comment|/**    * Returns a new Directory instance, with contents copied from the    * provided directory. See {@link #newDirectory()} for more    * information.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newDirectory
parameter_list|(
name|Directory
name|d
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|newDirectory
argument_list|(
name|random
argument_list|,
name|d
argument_list|)
return|;
block|}
comment|/** Returns a new FSDirectory instance over the given file, which must be a folder. */
DECL|method|newFSDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newFSDirectory
parameter_list|(
name|File
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|newFSDirectory
argument_list|(
name|f
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Returns a new FSDirectory instance over the given file, which must be a folder. */
DECL|method|newFSDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newFSDirectory
parameter_list|(
name|File
name|f
parameter_list|,
name|LockFactory
name|lf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|fsdirClass
init|=
name|TEST_DIRECTORY
decl_stmt|;
if|if
condition|(
name|fsdirClass
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
block|{
name|fsdirClass
operator|=
name|FS_DIRECTORIES
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|FS_DIRECTORIES
operator|.
name|length
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
name|fsdirClass
operator|.
name|indexOf
argument_list|(
literal|"."
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|// if not fully qualified, assume .store
name|fsdirClass
operator|=
literal|"org.apache.lucene.store."
operator|+
name|fsdirClass
expr_stmt|;
block|}
name|Class
argument_list|<
name|?
extends|extends
name|FSDirectory
argument_list|>
name|clazz
decl_stmt|;
try|try
block|{
try|try
block|{
name|clazz
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|fsdirClass
argument_list|)
operator|.
name|asSubclass
argument_list|(
name|FSDirectory
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
comment|// TEST_DIRECTORY is not a sub-class of FSDirectory, so draw one at random
name|fsdirClass
operator|=
name|FS_DIRECTORIES
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|FS_DIRECTORIES
operator|.
name|length
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|fsdirClass
operator|.
name|indexOf
argument_list|(
literal|"."
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|// if not fully qualified, assume .store
name|fsdirClass
operator|=
literal|"org.apache.lucene.store."
operator|+
name|fsdirClass
expr_stmt|;
block|}
name|clazz
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|fsdirClass
argument_list|)
operator|.
name|asSubclass
argument_list|(
name|FSDirectory
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
name|MockDirectoryWrapper
name|dir
init|=
operator|new
name|MockDirectoryWrapper
argument_list|(
name|random
argument_list|,
name|newFSDirectoryImpl
argument_list|(
name|clazz
argument_list|,
name|f
argument_list|,
name|lf
argument_list|)
argument_list|)
decl_stmt|;
name|stores
operator|.
name|put
argument_list|(
name|dir
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getStackTrace
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|dir
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|newDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newDirectory
parameter_list|(
name|Random
name|r
parameter_list|,
name|Directory
name|d
parameter_list|)
throws|throws
name|IOException
block|{
name|Directory
name|impl
init|=
name|newDirectoryImpl
argument_list|(
name|r
argument_list|,
name|TEST_DIRECTORY
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|d
operator|.
name|listAll
argument_list|()
control|)
block|{
name|d
operator|.
name|copy
argument_list|(
name|impl
argument_list|,
name|file
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|MockDirectoryWrapper
name|dir
init|=
operator|new
name|MockDirectoryWrapper
argument_list|(
name|r
argument_list|,
name|impl
argument_list|)
decl_stmt|;
name|stores
operator|.
name|put
argument_list|(
name|dir
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getStackTrace
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|dir
return|;
block|}
comment|/** Returns a new field instance.     * See {@link #newField(String, String, Field.Store, Field.Index, Field.TermVector)} for more information */
DECL|method|newField
specifier|public
specifier|static
name|Field
name|newField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Index
name|index
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|index
argument_list|)
return|;
block|}
comment|/** Returns a new field instance.     * See {@link #newField(String, String, Field.Store, Field.Index, Field.TermVector)} for more information */
DECL|method|newField
specifier|public
specifier|static
name|Field
name|newField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Store
name|store
parameter_list|,
name|Index
name|index
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|store
argument_list|,
name|index
argument_list|)
return|;
block|}
comment|/**    * Returns a new Field instance. Use this when the test does not    * care about some specific field settings (most tests)    *<ul>    *<li>If the store value is set to Store.NO, sometimes the field will be randomly stored.    *<li>More term vector data than you ask for might be indexed, for example if you choose YES    *      it might index term vectors with offsets too.    *</ul>    */
DECL|method|newField
specifier|public
specifier|static
name|Field
name|newField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Store
name|store
parameter_list|,
name|Index
name|index
parameter_list|,
name|TermVector
name|tv
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|store
argument_list|,
name|index
argument_list|,
name|tv
argument_list|)
return|;
block|}
comment|/** Returns a new field instance, using the specified random.     * See {@link #newField(String, String, Field.Store, Field.Index, Field.TermVector)} for more information */
DECL|method|newField
specifier|public
specifier|static
name|Field
name|newField
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Index
name|index
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|Store
operator|.
name|NO
argument_list|,
name|index
argument_list|)
return|;
block|}
comment|/** Returns a new field instance, using the specified random.     * See {@link #newField(String, String, Field.Store, Field.Index, Field.TermVector)} for more information */
DECL|method|newField
specifier|public
specifier|static
name|Field
name|newField
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Store
name|store
parameter_list|,
name|Index
name|index
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|store
argument_list|,
name|index
argument_list|,
name|TermVector
operator|.
name|NO
argument_list|)
return|;
block|}
comment|/** Returns a new field instance, using the specified random.     * See {@link #newField(String, String, Field.Store, Field.Index, Field.TermVector)} for more information */
DECL|method|newField
specifier|public
specifier|static
name|Field
name|newField
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Store
name|store
parameter_list|,
name|Index
name|index
parameter_list|,
name|TermVector
name|tv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|index
operator|.
name|isIndexed
argument_list|()
condition|)
return|return
operator|new
name|Field
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|store
argument_list|,
name|index
argument_list|)
return|;
if|if
condition|(
operator|!
name|store
operator|.
name|isStored
argument_list|()
operator|&&
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
name|store
operator|=
name|Store
operator|.
name|YES
expr_stmt|;
comment|// randomly store it
name|tv
operator|=
name|randomTVSetting
argument_list|(
name|random
argument_list|,
name|tv
argument_list|)
expr_stmt|;
return|return
operator|new
name|Field
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|store
argument_list|,
name|index
argument_list|,
name|tv
argument_list|)
return|;
block|}
DECL|field|tvSettings
specifier|static
specifier|final
name|TermVector
name|tvSettings
index|[]
init|=
block|{
name|TermVector
operator|.
name|NO
block|,
name|TermVector
operator|.
name|YES
block|,
name|TermVector
operator|.
name|WITH_OFFSETS
block|,
name|TermVector
operator|.
name|WITH_POSITIONS
block|,
name|TermVector
operator|.
name|WITH_POSITIONS_OFFSETS
block|}
decl_stmt|;
DECL|method|randomTVSetting
specifier|private
specifier|static
name|TermVector
name|randomTVSetting
parameter_list|(
name|Random
name|random
parameter_list|,
name|TermVector
name|minimum
parameter_list|)
block|{
switch|switch
condition|(
name|minimum
condition|)
block|{
case|case
name|NO
case|:
return|return
name|tvSettings
index|[
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
name|tvSettings
operator|.
name|length
operator|-
literal|1
argument_list|)
index|]
return|;
case|case
name|YES
case|:
return|return
name|tvSettings
index|[
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
name|tvSettings
operator|.
name|length
operator|-
literal|1
argument_list|)
index|]
return|;
case|case
name|WITH_OFFSETS
case|:
return|return
name|random
operator|.
name|nextBoolean
argument_list|()
condition|?
name|TermVector
operator|.
name|WITH_OFFSETS
else|:
name|TermVector
operator|.
name|WITH_POSITIONS_OFFSETS
return|;
case|case
name|WITH_POSITIONS
case|:
return|return
name|random
operator|.
name|nextBoolean
argument_list|()
condition|?
name|TermVector
operator|.
name|WITH_POSITIONS
else|:
name|TermVector
operator|.
name|WITH_POSITIONS_OFFSETS
return|;
default|default:
return|return
name|TermVector
operator|.
name|WITH_POSITIONS_OFFSETS
return|;
block|}
block|}
comment|/** return a random Locale from the available locales on the system */
DECL|method|randomLocale
specifier|public
specifier|static
name|Locale
name|randomLocale
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|Locale
name|locales
index|[]
init|=
name|Locale
operator|.
name|getAvailableLocales
argument_list|()
decl_stmt|;
return|return
name|locales
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|locales
operator|.
name|length
argument_list|)
index|]
return|;
block|}
comment|/** return a random TimeZone from the available timezones on the system */
DECL|method|randomTimeZone
specifier|public
specifier|static
name|TimeZone
name|randomTimeZone
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|String
name|tzIds
index|[]
init|=
name|TimeZone
operator|.
name|getAvailableIDs
argument_list|()
decl_stmt|;
return|return
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
name|tzIds
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|tzIds
operator|.
name|length
argument_list|)
index|]
argument_list|)
return|;
block|}
comment|/** return a Locale object equivalent to its programmatic name */
DECL|method|localeForName
specifier|public
specifier|static
name|Locale
name|localeForName
parameter_list|(
name|String
name|localeName
parameter_list|)
block|{
name|String
name|elements
index|[]
init|=
name|localeName
operator|.
name|split
argument_list|(
literal|"\\_"
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|elements
operator|.
name|length
condition|)
block|{
case|case
literal|3
case|:
return|return
operator|new
name|Locale
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|,
name|elements
index|[
literal|1
index|]
argument_list|,
name|elements
index|[
literal|2
index|]
argument_list|)
return|;
case|case
literal|2
case|:
return|return
operator|new
name|Locale
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|,
name|elements
index|[
literal|1
index|]
argument_list|)
return|;
case|case
literal|1
case|:
return|return
operator|new
name|Locale
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid Locale: "
operator|+
name|localeName
argument_list|)
throw|;
block|}
block|}
DECL|field|FS_DIRECTORIES
specifier|private
specifier|static
specifier|final
name|String
name|FS_DIRECTORIES
index|[]
init|=
block|{
literal|"SimpleFSDirectory"
block|,
literal|"NIOFSDirectory"
block|,
literal|"MMapDirectory"
block|}
decl_stmt|;
DECL|field|CORE_DIRECTORIES
specifier|private
specifier|static
specifier|final
name|String
name|CORE_DIRECTORIES
index|[]
init|=
block|{
literal|"RAMDirectory"
block|,
name|FS_DIRECTORIES
index|[
literal|0
index|]
block|,
name|FS_DIRECTORIES
index|[
literal|1
index|]
block|,
name|FS_DIRECTORIES
index|[
literal|2
index|]
block|}
decl_stmt|;
DECL|method|randomDirectory
specifier|public
specifier|static
name|String
name|randomDirectory
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
if|if
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|CORE_DIRECTORIES
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|CORE_DIRECTORIES
operator|.
name|length
argument_list|)
index|]
return|;
block|}
else|else
block|{
return|return
literal|"RAMDirectory"
return|;
block|}
block|}
DECL|method|newFSDirectoryImpl
specifier|private
specifier|static
name|Directory
name|newFSDirectoryImpl
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|FSDirectory
argument_list|>
name|clazz
parameter_list|,
name|File
name|file
parameter_list|,
name|LockFactory
name|lockFactory
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
comment|// Assuming every FSDirectory has a ctor(File), but not all may take a
comment|// LockFactory too, so setting it afterwards.
name|Constructor
argument_list|<
name|?
extends|extends
name|FSDirectory
argument_list|>
name|ctor
init|=
name|clazz
operator|.
name|getConstructor
argument_list|(
name|File
operator|.
name|class
argument_list|)
decl_stmt|;
name|FSDirectory
name|d
init|=
name|ctor
operator|.
name|newInstance
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|lockFactory
operator|!=
literal|null
condition|)
block|{
name|d
operator|.
name|setLockFactory
argument_list|(
name|lockFactory
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
name|FSDirectory
operator|.
name|open
argument_list|(
name|file
argument_list|)
return|;
block|}
block|}
DECL|method|newDirectoryImpl
specifier|static
name|Directory
name|newDirectoryImpl
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|clazzName
parameter_list|)
block|{
if|if
condition|(
name|clazzName
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
name|clazzName
operator|=
name|randomDirectory
argument_list|(
name|random
argument_list|)
expr_stmt|;
if|if
condition|(
name|clazzName
operator|.
name|indexOf
argument_list|(
literal|"."
argument_list|)
operator|==
operator|-
literal|1
condition|)
comment|// if not fully qualified, assume .store
name|clazzName
operator|=
literal|"org.apache.lucene.store."
operator|+
name|clazzName
expr_stmt|;
try|try
block|{
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Directory
argument_list|>
name|clazz
init|=
name|Class
operator|.
name|forName
argument_list|(
name|clazzName
argument_list|)
operator|.
name|asSubclass
argument_list|(
name|Directory
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// If it is a FSDirectory type, try its ctor(File)
if|if
condition|(
name|FSDirectory
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|clazz
argument_list|)
condition|)
block|{
specifier|final
name|File
name|tmpFile
init|=
name|File
operator|.
name|createTempFile
argument_list|(
literal|"test"
argument_list|,
literal|"tmp"
argument_list|,
name|TEMP_DIR
argument_list|)
decl_stmt|;
name|tmpFile
operator|.
name|delete
argument_list|()
expr_stmt|;
name|tmpFile
operator|.
name|mkdir
argument_list|()
expr_stmt|;
name|tempDirs
operator|.
name|add
argument_list|(
name|tmpFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|newFSDirectoryImpl
argument_list|(
name|clazz
operator|.
name|asSubclass
argument_list|(
name|FSDirectory
operator|.
name|class
argument_list|)
argument_list|,
name|tmpFile
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|// try empty ctor
return|return
name|clazz
operator|.
name|newInstance
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** create a new searcher over the reader */
DECL|method|newSearcher
specifier|public
specifier|static
name|IndexSearcher
name|newSearcher
parameter_list|(
name|IndexReader
name|r
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
return|return
operator|new
name|IndexSearcher
argument_list|(
name|r
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|threads
init|=
literal|0
decl_stmt|;
specifier|final
name|ExecutorService
name|ex
init|=
operator|(
name|random
operator|.
name|nextBoolean
argument_list|()
operator|)
condition|?
literal|null
else|:
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|threads
operator|=
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|)
argument_list|,
operator|new
name|NamedThreadFactory
argument_list|(
literal|"LuceneTestCase"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ex
operator|!=
literal|null
operator|&&
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"NOTE: newSearcher using ExecutorService with "
operator|+
name|threads
operator|+
literal|" threads"
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|IndexSearcher
argument_list|(
name|r
operator|.
name|getTopReaderContext
argument_list|()
argument_list|,
name|ex
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
block|{
name|ex
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
name|ex
operator|.
name|awaitTermination
argument_list|(
literal|1000
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
return|;
block|}
block|}
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|this
operator|.
name|name
return|;
block|}
comment|/** Gets a resource from the classpath as {@link File}. This method should only be used,    * if a real file is needed. To get a stream, code should prefer    * {@link Class#getResourceAsStream} using {@code this.getClass()}.    */
DECL|method|getDataFile
specifier|protected
name|File
name|getDataFile
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
operator|new
name|File
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getResource
argument_list|(
name|name
argument_list|)
operator|.
name|toURI
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot find resource: "
operator|+
name|name
argument_list|)
throw|;
block|}
block|}
comment|// We get here from InterceptTestCaseEvents on the 'failed' event....
DECL|method|reportAdditionalFailureInfo
specifier|public
name|void
name|reportAdditionalFailureInfo
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"NOTE: reproduce with: ant test -Dtestcase="
operator|+
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" -Dtestmethod="
operator|+
name|getName
argument_list|()
operator|+
literal|" -Dtests.seed="
operator|+
operator|new
name|TwoLongs
argument_list|(
name|staticSeed
argument_list|,
name|seed
argument_list|)
operator|+
name|reproduceWithExtraParams
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// extra params that were overridden needed to reproduce the command
DECL|method|reproduceWithExtraParams
specifier|private
name|String
name|reproduceWithExtraParams
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|TEST_CODEC
operator|.
name|equals
argument_list|(
literal|"randomPerField"
argument_list|)
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" -Dtests.codec="
argument_list|)
operator|.
name|append
argument_list|(
name|TEST_CODEC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_LOCALE
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" -Dtests.locale="
argument_list|)
operator|.
name|append
argument_list|(
name|TEST_LOCALE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_TIMEZONE
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" -Dtests.timezone="
argument_list|)
operator|.
name|append
argument_list|(
name|TEST_TIMEZONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_DIRECTORY
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" -Dtests.directory="
argument_list|)
operator|.
name|append
argument_list|(
name|TEST_DIRECTORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|RANDOM_MULTIPLIER
operator|>
literal|1
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" -Dtests.multiplier="
argument_list|)
operator|.
name|append
argument_list|(
name|RANDOM_MULTIPLIER
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// recorded seed: for beforeClass
DECL|field|staticSeed
specifier|private
specifier|static
name|long
name|staticSeed
decl_stmt|;
comment|// seed for individual test methods, changed in @before
DECL|field|seed
specifier|private
name|long
name|seed
decl_stmt|;
DECL|field|seedRand
specifier|private
specifier|static
specifier|final
name|Random
name|seedRand
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
DECL|field|random
specifier|protected
specifier|static
specifier|final
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|name
specifier|private
name|String
name|name
init|=
literal|"<unknown>"
decl_stmt|;
comment|/**    * Annotation for tests that should only be run during nightly builds.    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
DECL|interface|Nightly
specifier|public
annotation_defn|@interface
name|Nightly
block|{}
comment|/** optionally filters the tests to be run by TEST_METHOD */
DECL|class|LuceneTestCaseRunner
specifier|public
specifier|static
class|class
name|LuceneTestCaseRunner
extends|extends
name|BlockJUnit4ClassRunner
block|{
DECL|field|testMethods
specifier|private
name|List
argument_list|<
name|FrameworkMethod
argument_list|>
name|testMethods
decl_stmt|;
annotation|@
name|Override
DECL|method|computeTestMethods
specifier|protected
name|List
argument_list|<
name|FrameworkMethod
argument_list|>
name|computeTestMethods
parameter_list|()
block|{
if|if
condition|(
name|testMethods
operator|!=
literal|null
condition|)
return|return
name|testMethods
return|;
name|testClassesRun
operator|.
name|add
argument_list|(
name|getTestClass
argument_list|()
operator|.
name|getJavaClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|testMethods
operator|=
operator|new
name|ArrayList
argument_list|<
name|FrameworkMethod
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|Method
name|m
range|:
name|getTestClass
argument_list|()
operator|.
name|getJavaClass
argument_list|()
operator|.
name|getMethods
argument_list|()
control|)
block|{
comment|// check if the current test's class has methods annotated with @Ignore
specifier|final
name|Ignore
name|ignored
init|=
name|m
operator|.
name|getAnnotation
argument_list|(
name|Ignore
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|ignored
operator|!=
literal|null
operator|&&
operator|!
name|m
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"alwaysIgnoredTestMethod"
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"NOTE: Ignoring test method '"
operator|+
name|m
operator|.
name|getName
argument_list|()
operator|+
literal|"': "
operator|+
name|ignored
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// add methods starting with "test"
specifier|final
name|int
name|mod
init|=
name|m
operator|.
name|getModifiers
argument_list|()
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|getAnnotation
argument_list|(
name|Test
operator|.
name|class
argument_list|)
operator|!=
literal|null
operator|||
operator|(
name|m
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"test"
argument_list|)
operator|&&
operator|!
name|Modifier
operator|.
name|isAbstract
argument_list|(
name|mod
argument_list|)
operator|&&
name|m
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
operator|==
literal|0
operator|&&
name|m
operator|.
name|getReturnType
argument_list|()
operator|==
name|Void
operator|.
name|TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|Modifier
operator|.
name|isStatic
argument_list|(
name|mod
argument_list|)
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Test methods must not be static."
argument_list|)
throw|;
name|testMethods
operator|.
name|add
argument_list|(
operator|new
name|FrameworkMethod
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|testMethods
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"No runnable methods!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|TEST_NIGHTLY
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|getTestClass
argument_list|()
operator|.
name|getJavaClass
argument_list|()
operator|.
name|isAnnotationPresent
argument_list|(
name|Nightly
operator|.
name|class
argument_list|)
condition|)
block|{
comment|/* the test class is annotated with nightly, remove all methods */
name|String
name|className
init|=
name|getTestClass
argument_list|()
operator|.
name|getJavaClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
decl_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"NOTE: Ignoring nightly-only test class '"
operator|+
name|className
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|testMethods
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* remove all nightly-only methods */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|testMethods
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|FrameworkMethod
name|m
init|=
name|testMethods
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|getAnnotation
argument_list|(
name|Nightly
operator|.
name|class
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"NOTE: Ignoring nightly-only test method '"
operator|+
name|m
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|testMethods
operator|.
name|remove
argument_list|(
name|i
operator|--
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* dodge a possible "no-runnable methods" exception by adding a fake ignored test */
if|if
condition|(
name|testMethods
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|testMethods
operator|.
name|add
argument_list|(
operator|new
name|FrameworkMethod
argument_list|(
name|LuceneTestCase
operator|.
name|class
operator|.
name|getMethod
argument_list|(
literal|"alwaysIgnoredTestMethod"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|testMethods
return|;
block|}
annotation|@
name|Override
DECL|method|runChild
specifier|protected
name|void
name|runChild
parameter_list|(
name|FrameworkMethod
name|arg0
parameter_list|,
name|RunNotifier
name|arg1
parameter_list|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nNOTE: running test "
operator|+
name|arg0
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// only print iteration info if the user requested more than one iterations
name|boolean
name|verbose
init|=
name|VERBOSE
operator|&&
name|TEST_ITER
operator|>
literal|1
decl_stmt|;
name|int
name|lastIterFailed
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|TEST_ITER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nNOTE: running iter="
operator|+
operator|(
literal|1
operator|+
name|i
operator|)
operator|+
literal|" of "
operator|+
name|TEST_ITER
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|runChild
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|testsFailed
condition|)
block|{
name|lastIterFailed
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|TEST_ITER_MIN
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nNOTE: iteration "
operator|+
name|lastIterFailed
operator|+
literal|" failed !"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
DECL|method|LuceneTestCaseRunner
specifier|public
name|LuceneTestCaseRunner
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|)
throws|throws
name|InitializationError
block|{
name|super
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
name|Filter
name|f
init|=
operator|new
name|Filter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|describe
parameter_list|()
block|{
return|return
literal|"filters according to TEST_METHOD"
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|shouldRun
parameter_list|(
name|Description
name|d
parameter_list|)
block|{
return|return
name|TEST_METHOD
operator|==
literal|null
operator|||
name|d
operator|.
name|getMethodName
argument_list|()
operator|.
name|equals
argument_list|(
name|TEST_METHOD
argument_list|)
return|;
block|}
block|}
decl_stmt|;
try|try
block|{
name|f
operator|.
name|apply
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoTestsRemainException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|class|RandomCodecProvider
specifier|private
specifier|static
class|class
name|RandomCodecProvider
extends|extends
name|CodecProvider
block|{
DECL|field|knownCodecs
specifier|private
name|List
argument_list|<
name|Codec
argument_list|>
name|knownCodecs
init|=
operator|new
name|ArrayList
argument_list|<
name|Codec
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|previousMappings
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Codec
argument_list|>
name|previousMappings
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Codec
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|perFieldSeed
specifier|private
specifier|final
name|int
name|perFieldSeed
decl_stmt|;
DECL|method|RandomCodecProvider
name|RandomCodecProvider
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|this
operator|.
name|perFieldSeed
operator|=
name|random
operator|.
name|nextInt
argument_list|()
expr_stmt|;
name|register
argument_list|(
operator|new
name|StandardCodec
argument_list|()
argument_list|)
expr_stmt|;
name|register
argument_list|(
operator|new
name|PreFlexCodec
argument_list|()
argument_list|)
expr_stmt|;
name|register
argument_list|(
operator|new
name|PulsingCodec
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|register
argument_list|(
operator|new
name|SimpleTextCodec
argument_list|()
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|knownCodecs
argument_list|,
name|random
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|register
specifier|public
specifier|synchronized
name|void
name|register
parameter_list|(
name|Codec
name|codec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|codec
operator|.
name|name
operator|.
name|equals
argument_list|(
literal|"PreFlex"
argument_list|)
condition|)
name|knownCodecs
operator|.
name|add
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|super
operator|.
name|register
argument_list|(
name|codec
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|unregister
specifier|public
specifier|synchronized
name|void
name|unregister
parameter_list|(
name|Codec
name|codec
parameter_list|)
block|{
name|knownCodecs
operator|.
name|remove
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|super
operator|.
name|unregister
argument_list|(
name|codec
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getFieldCodec
specifier|public
specifier|synchronized
name|String
name|getFieldCodec
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|Codec
name|codec
init|=
name|previousMappings
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|codec
operator|==
literal|null
condition|)
block|{
name|codec
operator|=
name|knownCodecs
operator|.
name|get
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|perFieldSeed
operator|^
name|name
operator|.
name|hashCode
argument_list|()
argument_list|)
operator|%
name|knownCodecs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|previousMappings
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|codec
argument_list|)
expr_stmt|;
block|}
return|return
name|codec
operator|.
name|name
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"RandomCodecProvider: "
operator|+
name|previousMappings
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
annotation|@
name|Ignore
argument_list|(
literal|"just a hack"
argument_list|)
DECL|method|alwaysIgnoredTestMethod
specifier|public
specifier|final
name|void
name|alwaysIgnoredTestMethod
parameter_list|()
block|{}
block|}
end_class
end_unit
