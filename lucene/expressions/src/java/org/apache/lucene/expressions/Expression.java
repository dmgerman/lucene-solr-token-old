begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.expressions
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|expressions
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|expressions
operator|.
name|js
operator|.
name|JavascriptCompiler
import|;
end_import
begin_comment
comment|// javadocs
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|FunctionValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|ValueSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Rescorer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|SortField
import|;
end_import
begin_comment
comment|/**  * Base class that computes the value of an expression for a document.  *<p>  * Example usage:  *<pre class="prettyprint">  *   // compile an expression:  *   Expression expr = JavascriptCompiler.compile("sqrt(_score) + ln(popularity)");  *     *   // SimpleBindings just maps variables to SortField instances  *   SimpleBindings bindings = new SimpleBindings();      *   bindings.add(new SortField("_score", SortField.Type.SCORE));  *   bindings.add(new SortField("popularity", SortField.Type.INT));  *     *   // create a sort field and sort by it (reverse order)  *   Sort sort = new Sort(expr.getSortField(bindings, true));  *   Query query = new TermQuery(new Term("body", "contents"));  *   searcher.search(query, null, 10, sort);  *</pre>  * @see JavascriptCompiler#compile  * @lucene.experimental  */
end_comment
begin_class
DECL|class|Expression
specifier|public
specifier|abstract
class|class
name|Expression
block|{
comment|/** The original source text */
DECL|field|sourceText
specifier|public
specifier|final
name|String
name|sourceText
decl_stmt|;
comment|/** Named variables referred to by this expression */
DECL|field|variables
specifier|public
specifier|final
name|String
index|[]
name|variables
decl_stmt|;
comment|/**    * Creates a new {@code Expression}.    *    * @param sourceText Source text for the expression: e.g. {@code ln(popularity)}    * @param variables Names of external variables referred to by the expression    */
DECL|method|Expression
specifier|protected
name|Expression
parameter_list|(
name|String
name|sourceText
parameter_list|,
name|String
index|[]
name|variables
parameter_list|)
block|{
name|this
operator|.
name|sourceText
operator|=
name|sourceText
expr_stmt|;
name|this
operator|.
name|variables
operator|=
name|variables
expr_stmt|;
block|}
comment|/**    * Evaluates the expression for the given document.    *    * @param document<code>docId</code> of the document to compute a value for    * @param functionValues {@link FunctionValues} for each element of {@link #variables}.    * @return The computed value of the expression for the given document.    */
DECL|method|evaluate
specifier|public
specifier|abstract
name|double
name|evaluate
parameter_list|(
name|int
name|document
parameter_list|,
name|FunctionValues
index|[]
name|functionValues
parameter_list|)
function_decl|;
comment|/**    * Get a value source which can compute the value of this expression in the context of the given bindings.    * @param bindings Bindings to use for external values in this expression    * @return A value source which will evaluate this expression when used    */
DECL|method|getValueSource
specifier|public
name|ValueSource
name|getValueSource
parameter_list|(
name|Bindings
name|bindings
parameter_list|)
block|{
return|return
operator|new
name|ExpressionValueSource
argument_list|(
name|bindings
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/** Get a sort field which can be used to rank documents by this expression. */
DECL|method|getSortField
specifier|public
name|SortField
name|getSortField
parameter_list|(
name|Bindings
name|bindings
parameter_list|,
name|boolean
name|reverse
parameter_list|)
block|{
return|return
name|getValueSource
argument_list|(
name|bindings
argument_list|)
operator|.
name|getSortField
argument_list|(
name|reverse
argument_list|)
return|;
block|}
comment|/** Get a {@link Rescorer}, to rescore first-pass hits    *  using this expression. */
DECL|method|getRescorer
specifier|public
name|Rescorer
name|getRescorer
parameter_list|(
name|Bindings
name|bindings
parameter_list|)
block|{
return|return
operator|new
name|ExpressionRescorer
argument_list|(
name|this
argument_list|,
name|bindings
argument_list|)
return|;
block|}
block|}
end_class
end_unit
