begin_unit
begin_package
DECL|package|org.apache.lucene.queries.mlt
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|mlt
package|;
end_package
begin_comment
comment|/**  * Copyright 2004-2005 The Apache Software Foundation.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|CharTermAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Fields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiFields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StorableField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StoredDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|DefaultSimilarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|TFIDFSimilarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CharsRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_comment
comment|/**  * Generate "more like this" similarity queries.  * Based on this mail:  *<pre><code>  * Lucene does let you access the document frequency of terms, with IndexReader.docFreq().  * Term frequencies can be computed by re-tokenizing the text, which, for a single document,  * is usually fast enough.  But looking up the docFreq() of every term in the document is  * probably too slow.  *   * You can use some heuristics to prune the set of terms, to avoid calling docFreq() too much,  * or at all.  Since you're trying to maximize a tf*idf score, you're probably most interested  * in terms with a high tf. Choosing a tf threshold even as low as two or three will radically  * reduce the number of terms under consideration.  Another heuristic is that terms with a  * high idf (i.e., a low df) tend to be longer.  So you could threshold the terms by the  * number of characters, not selecting anything less than, e.g., six or seven characters.  * With these sorts of heuristics you can usually find small set of, e.g., ten or fewer terms  * that do a pretty good job of characterizing a document.  *   * It all depends on what you're trying to do.  If you're trying to eek out that last percent  * of precision and recall regardless of computational difficulty so that you can win a TREC  * competition, then the techniques I mention above are useless.  But if you're trying to  * provide a "more like this" button on a search results page that does a decent job and has  * good performance, such techniques might be useful.  *   * An efficient, effective "more-like-this" query generator would be a great contribution, if  * anyone's interested.  I'd imagine that it would take a Reader or a String (the document's  * text), analyzer Analyzer, and return a set of representative terms using heuristics like those  * above.  The frequency and length thresholds could be parameters, etc.  *   * Doug  *</code></pre>  *<h3>Initial Usage</h3>  *<p>  * This class has lots of options to try to make it efficient and flexible.  * The simplest possible usage is as follows. The bold  * fragment is specific to this class.  *<br>  *<pre class="prettyprint">  * IndexReader ir = ...  * IndexSearcher is = ...  *  * MoreLikeThis mlt = new MoreLikeThis(ir);  * Reader target = ... // orig source of doc you want to find similarities to  * Query query = mlt.like( target);  *   * Hits hits = is.search(query);  * // now the usual iteration thru 'hits' - the only thing to watch for is to make sure  * //you ignore the doc if it matches your 'target' document, as it should be similar to itself  *  *</pre>  *<p>  * Thus you:  *<ol>  *<li> do your normal, Lucene setup for searching,  *<li> create a MoreLikeThis,  *<li> get the text of the doc you want to find similarities to  *<li> then call one of the like() calls to generate a similarity query  *<li> call the searcher to find the similar docs  *</ol>  *<br>  *<h3>More Advanced Usage</h3>  *<p>  * You may want to use {@link #setFieldNames setFieldNames(...)} so you can examine  * multiple fields (e.g. body and title) for similarity.  *<p>  * Depending on the size of your index and the size and makeup of your documents you  * may want to call the other set methods to control how the similarity queries are  * generated:  *<ul>  *<li> {@link #setMinTermFreq setMinTermFreq(...)}  *<li> {@link #setMinDocFreq setMinDocFreq(...)}  *<li> {@link #setMaxDocFreq setMaxDocFreq(...)}  *<li> {@link #setMaxDocFreqPct setMaxDocFreqPct(...)}  *<li> {@link #setMinWordLen setMinWordLen(...)}  *<li> {@link #setMaxWordLen setMaxWordLen(...)}  *<li> {@link #setMaxQueryTerms setMaxQueryTerms(...)}  *<li> {@link #setMaxNumTokensParsed setMaxNumTokensParsed(...)}  *<li> {@link #setStopWords setStopWord(...)}  *</ul>  *<br>  *<hr>  *<pre>  * Changes: Mark Harwood 29/02/04  * Some bugfixing, some refactoring, some optimisation.  * - bugfix: retrieveTerms(int docNum) was not working for indexes without a termvector -added missing code  * - bugfix: No significant terms being created for fields with a termvector - because  * was only counting one occurrence per term/field pair in calculations(ie not including frequency info from TermVector)  * - refactor: moved common code into isNoiseWord()  * - optimise: when no termvector support available - used maxNumTermsParsed to limit amount of tokenization  *</pre>  */
end_comment
begin_class
DECL|class|MoreLikeThis
specifier|public
specifier|final
class|class
name|MoreLikeThis
block|{
comment|/**    * Default maximum number of tokens to parse in each example doc field that is not stored with TermVector support.    *    * @see #getMaxNumTokensParsed    */
DECL|field|DEFAULT_MAX_NUM_TOKENS_PARSED
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_NUM_TOKENS_PARSED
init|=
literal|5000
decl_stmt|;
comment|/**    * Ignore terms with less than this frequency in the source doc.    *    * @see #getMinTermFreq    * @see #setMinTermFreq    */
DECL|field|DEFAULT_MIN_TERM_FREQ
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_TERM_FREQ
init|=
literal|2
decl_stmt|;
comment|/**    * Ignore words which do not occur in at least this many docs.    *    * @see #getMinDocFreq    * @see #setMinDocFreq    */
DECL|field|DEFAULT_MIN_DOC_FREQ
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_DOC_FREQ
init|=
literal|5
decl_stmt|;
comment|/**    * Ignore words which occur in more than this many docs.    *    * @see #getMaxDocFreq    * @see #setMaxDocFreq    * @see #setMaxDocFreqPct    */
DECL|field|DEFAULT_MAX_DOC_FREQ
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_DOC_FREQ
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
comment|/**    * Boost terms in query based on score.    *    * @see #isBoost    * @see #setBoost    */
DECL|field|DEFAULT_BOOST
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_BOOST
init|=
literal|false
decl_stmt|;
comment|/**    * Default field names. Null is used to specify that the field names should be looked    * up at runtime from the provided reader.    */
DECL|field|DEFAULT_FIELD_NAMES
specifier|public
specifier|static
specifier|final
name|String
index|[]
name|DEFAULT_FIELD_NAMES
init|=
operator|new
name|String
index|[]
block|{
literal|"contents"
block|}
decl_stmt|;
comment|/**    * Ignore words less than this length or if 0 then this has no effect.    *    * @see #getMinWordLen    * @see #setMinWordLen    */
DECL|field|DEFAULT_MIN_WORD_LENGTH
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_WORD_LENGTH
init|=
literal|0
decl_stmt|;
comment|/**    * Ignore words greater than this length or if 0 then this has no effect.    *    * @see #getMaxWordLen    * @see #setMaxWordLen    */
DECL|field|DEFAULT_MAX_WORD_LENGTH
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_WORD_LENGTH
init|=
literal|0
decl_stmt|;
comment|/**    * Default set of stopwords.    * If null means to allow stop words.    *    * @see #setStopWords    * @see #getStopWords    */
DECL|field|DEFAULT_STOP_WORDS
specifier|public
specifier|static
specifier|final
name|Set
argument_list|<
name|?
argument_list|>
name|DEFAULT_STOP_WORDS
init|=
literal|null
decl_stmt|;
comment|/**    * Current set of stop words.    */
DECL|field|stopWords
specifier|private
name|Set
argument_list|<
name|?
argument_list|>
name|stopWords
init|=
name|DEFAULT_STOP_WORDS
decl_stmt|;
comment|/**    * Return a Query with no more than this many terms.    *    * @see BooleanQuery#getMaxClauseCount    * @see #getMaxQueryTerms    * @see #setMaxQueryTerms    */
DECL|field|DEFAULT_MAX_QUERY_TERMS
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_QUERY_TERMS
init|=
literal|25
decl_stmt|;
comment|/**    * Analyzer that will be used to parse the doc.    */
DECL|field|analyzer
specifier|private
name|Analyzer
name|analyzer
init|=
literal|null
decl_stmt|;
comment|/**    * Ignore words less frequent that this.    */
DECL|field|minTermFreq
specifier|private
name|int
name|minTermFreq
init|=
name|DEFAULT_MIN_TERM_FREQ
decl_stmt|;
comment|/**    * Ignore words which do not occur in at least this many docs.    */
DECL|field|minDocFreq
specifier|private
name|int
name|minDocFreq
init|=
name|DEFAULT_MIN_DOC_FREQ
decl_stmt|;
comment|/**    * Ignore words which occur in more than this many docs.    */
DECL|field|maxDocFreq
specifier|private
name|int
name|maxDocFreq
init|=
name|DEFAULT_MAX_DOC_FREQ
decl_stmt|;
comment|/**    * Should we apply a boost to the Query based on the scores?    */
DECL|field|boost
specifier|private
name|boolean
name|boost
init|=
name|DEFAULT_BOOST
decl_stmt|;
comment|/**    * Field name we'll analyze.    */
DECL|field|fieldNames
specifier|private
name|String
index|[]
name|fieldNames
init|=
name|DEFAULT_FIELD_NAMES
decl_stmt|;
comment|/**    * The maximum number of tokens to parse in each example doc field that is not stored with TermVector support    */
DECL|field|maxNumTokensParsed
specifier|private
name|int
name|maxNumTokensParsed
init|=
name|DEFAULT_MAX_NUM_TOKENS_PARSED
decl_stmt|;
comment|/**    * Ignore words if less than this len.    */
DECL|field|minWordLen
specifier|private
name|int
name|minWordLen
init|=
name|DEFAULT_MIN_WORD_LENGTH
decl_stmt|;
comment|/**    * Ignore words if greater than this len.    */
DECL|field|maxWordLen
specifier|private
name|int
name|maxWordLen
init|=
name|DEFAULT_MAX_WORD_LENGTH
decl_stmt|;
comment|/**    * Don't return a query longer than this.    */
DECL|field|maxQueryTerms
specifier|private
name|int
name|maxQueryTerms
init|=
name|DEFAULT_MAX_QUERY_TERMS
decl_stmt|;
comment|/**    * For idf() calculations.    */
DECL|field|similarity
specifier|private
name|TFIDFSimilarity
name|similarity
decl_stmt|;
comment|// = new DefaultSimilarity();
comment|/**    * IndexReader to use    */
DECL|field|ir
specifier|private
specifier|final
name|IndexReader
name|ir
decl_stmt|;
comment|/**    * Boost factor to use when boosting the terms    */
DECL|field|boostFactor
specifier|private
name|float
name|boostFactor
init|=
literal|1
decl_stmt|;
comment|/**    * Returns the boost factor used when boosting terms    *    * @return the boost factor used when boosting terms    * @see #setBoostFactor(float)    */
DECL|method|getBoostFactor
specifier|public
name|float
name|getBoostFactor
parameter_list|()
block|{
return|return
name|boostFactor
return|;
block|}
comment|/**    * Sets the boost factor to use when boosting terms    *    * @see #getBoostFactor()    */
DECL|method|setBoostFactor
specifier|public
name|void
name|setBoostFactor
parameter_list|(
name|float
name|boostFactor
parameter_list|)
block|{
name|this
operator|.
name|boostFactor
operator|=
name|boostFactor
expr_stmt|;
block|}
comment|/**    * Constructor requiring an IndexReader.    */
DECL|method|MoreLikeThis
specifier|public
name|MoreLikeThis
parameter_list|(
name|IndexReader
name|ir
parameter_list|)
block|{
name|this
argument_list|(
name|ir
argument_list|,
operator|new
name|DefaultSimilarity
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|MoreLikeThis
specifier|public
name|MoreLikeThis
parameter_list|(
name|IndexReader
name|ir
parameter_list|,
name|TFIDFSimilarity
name|sim
parameter_list|)
block|{
name|this
operator|.
name|ir
operator|=
name|ir
expr_stmt|;
name|this
operator|.
name|similarity
operator|=
name|sim
expr_stmt|;
block|}
DECL|method|getSimilarity
specifier|public
name|TFIDFSimilarity
name|getSimilarity
parameter_list|()
block|{
return|return
name|similarity
return|;
block|}
DECL|method|setSimilarity
specifier|public
name|void
name|setSimilarity
parameter_list|(
name|TFIDFSimilarity
name|similarity
parameter_list|)
block|{
name|this
operator|.
name|similarity
operator|=
name|similarity
expr_stmt|;
block|}
comment|/**    * Returns an analyzer that will be used to parse source doc with. The default analyzer    * is not set.    *    * @return the analyzer that will be used to parse source doc with.    */
DECL|method|getAnalyzer
specifier|public
name|Analyzer
name|getAnalyzer
parameter_list|()
block|{
return|return
name|analyzer
return|;
block|}
comment|/**    * Sets the analyzer to use. An analyzer is not required for generating a query with the    * {@link #like(int)} method, all other 'like' methods require an analyzer.    *    * @param analyzer the analyzer to use to tokenize text.    */
DECL|method|setAnalyzer
specifier|public
name|void
name|setAnalyzer
parameter_list|(
name|Analyzer
name|analyzer
parameter_list|)
block|{
name|this
operator|.
name|analyzer
operator|=
name|analyzer
expr_stmt|;
block|}
comment|/**    * Returns the frequency below which terms will be ignored in the source doc. The default    * frequency is the {@link #DEFAULT_MIN_TERM_FREQ}.    *    * @return the frequency below which terms will be ignored in the source doc.    */
DECL|method|getMinTermFreq
specifier|public
name|int
name|getMinTermFreq
parameter_list|()
block|{
return|return
name|minTermFreq
return|;
block|}
comment|/**    * Sets the frequency below which terms will be ignored in the source doc.    *    * @param minTermFreq the frequency below which terms will be ignored in the source doc.    */
DECL|method|setMinTermFreq
specifier|public
name|void
name|setMinTermFreq
parameter_list|(
name|int
name|minTermFreq
parameter_list|)
block|{
name|this
operator|.
name|minTermFreq
operator|=
name|minTermFreq
expr_stmt|;
block|}
comment|/**    * Returns the frequency at which words will be ignored which do not occur in at least this    * many docs. The default frequency is {@link #DEFAULT_MIN_DOC_FREQ}.    *    * @return the frequency at which words will be ignored which do not occur in at least this    *         many docs.    */
DECL|method|getMinDocFreq
specifier|public
name|int
name|getMinDocFreq
parameter_list|()
block|{
return|return
name|minDocFreq
return|;
block|}
comment|/**    * Sets the frequency at which words will be ignored which do not occur in at least this    * many docs.    *    * @param minDocFreq the frequency at which words will be ignored which do not occur in at    * least this many docs.    */
DECL|method|setMinDocFreq
specifier|public
name|void
name|setMinDocFreq
parameter_list|(
name|int
name|minDocFreq
parameter_list|)
block|{
name|this
operator|.
name|minDocFreq
operator|=
name|minDocFreq
expr_stmt|;
block|}
comment|/**    * Returns the maximum frequency in which words may still appear.    * Words that appear in more than this many docs will be ignored. The default frequency is    * {@link #DEFAULT_MAX_DOC_FREQ}.    *    * @return get the maximum frequency at which words are still allowed,    *         words which occur in more docs than this are ignored.    */
DECL|method|getMaxDocFreq
specifier|public
name|int
name|getMaxDocFreq
parameter_list|()
block|{
return|return
name|maxDocFreq
return|;
block|}
comment|/**    * Set the maximum frequency in which words may still appear. Words that appear    * in more than this many docs will be ignored.    *    * @param maxFreq the maximum count of documents that a term may appear    * in to be still considered relevant    */
DECL|method|setMaxDocFreq
specifier|public
name|void
name|setMaxDocFreq
parameter_list|(
name|int
name|maxFreq
parameter_list|)
block|{
name|this
operator|.
name|maxDocFreq
operator|=
name|maxFreq
expr_stmt|;
block|}
comment|/**    * Set the maximum percentage in which words may still appear. Words that appear    * in more than this many percent of all docs will be ignored.    *    * @param maxPercentage the maximum percentage of documents (0-100) that a term may appear    * in to be still considered relevant    */
DECL|method|setMaxDocFreqPct
specifier|public
name|void
name|setMaxDocFreqPct
parameter_list|(
name|int
name|maxPercentage
parameter_list|)
block|{
name|this
operator|.
name|maxDocFreq
operator|=
name|maxPercentage
operator|*
name|ir
operator|.
name|numDocs
argument_list|()
operator|/
literal|100
expr_stmt|;
block|}
comment|/**    * Returns whether to boost terms in query based on "score" or not. The default is    * {@link #DEFAULT_BOOST}.    *    * @return whether to boost terms in query based on "score" or not.    * @see #setBoost    */
DECL|method|isBoost
specifier|public
name|boolean
name|isBoost
parameter_list|()
block|{
return|return
name|boost
return|;
block|}
comment|/**    * Sets whether to boost terms in query based on "score" or not.    *    * @param boost true to boost terms in query based on "score", false otherwise.    * @see #isBoost    */
DECL|method|setBoost
specifier|public
name|void
name|setBoost
parameter_list|(
name|boolean
name|boost
parameter_list|)
block|{
name|this
operator|.
name|boost
operator|=
name|boost
expr_stmt|;
block|}
comment|/**    * Returns the field names that will be used when generating the 'More Like This' query.    * The default field names that will be used is {@link #DEFAULT_FIELD_NAMES}.    *    * @return the field names that will be used when generating the 'More Like This' query.    */
DECL|method|getFieldNames
specifier|public
name|String
index|[]
name|getFieldNames
parameter_list|()
block|{
return|return
name|fieldNames
return|;
block|}
comment|/**    * Sets the field names that will be used when generating the 'More Like This' query.    * Set this to null for the field names to be determined at runtime from the IndexReader    * provided in the constructor.    *    * @param fieldNames the field names that will be used when generating the 'More Like This'    * query.    */
DECL|method|setFieldNames
specifier|public
name|void
name|setFieldNames
parameter_list|(
name|String
index|[]
name|fieldNames
parameter_list|)
block|{
name|this
operator|.
name|fieldNames
operator|=
name|fieldNames
expr_stmt|;
block|}
comment|/**    * Returns the minimum word length below which words will be ignored. Set this to 0 for no    * minimum word length. The default is {@link #DEFAULT_MIN_WORD_LENGTH}.    *    * @return the minimum word length below which words will be ignored.    */
DECL|method|getMinWordLen
specifier|public
name|int
name|getMinWordLen
parameter_list|()
block|{
return|return
name|minWordLen
return|;
block|}
comment|/**    * Sets the minimum word length below which words will be ignored.    *    * @param minWordLen the minimum word length below which words will be ignored.    */
DECL|method|setMinWordLen
specifier|public
name|void
name|setMinWordLen
parameter_list|(
name|int
name|minWordLen
parameter_list|)
block|{
name|this
operator|.
name|minWordLen
operator|=
name|minWordLen
expr_stmt|;
block|}
comment|/**    * Returns the maximum word length above which words will be ignored. Set this to 0 for no    * maximum word length. The default is {@link #DEFAULT_MAX_WORD_LENGTH}.    *    * @return the maximum word length above which words will be ignored.    */
DECL|method|getMaxWordLen
specifier|public
name|int
name|getMaxWordLen
parameter_list|()
block|{
return|return
name|maxWordLen
return|;
block|}
comment|/**    * Sets the maximum word length above which words will be ignored.    *    * @param maxWordLen the maximum word length above which words will be ignored.    */
DECL|method|setMaxWordLen
specifier|public
name|void
name|setMaxWordLen
parameter_list|(
name|int
name|maxWordLen
parameter_list|)
block|{
name|this
operator|.
name|maxWordLen
operator|=
name|maxWordLen
expr_stmt|;
block|}
comment|/**    * Set the set of stopwords.    * Any word in this set is considered "uninteresting" and ignored.    * Even if your Analyzer allows stopwords, you might want to tell the MoreLikeThis code to ignore them, as    * for the purposes of document similarity it seems reasonable to assume that "a stop word is never interesting".    *    * @param stopWords set of stopwords, if null it means to allow stop words    * @see #getStopWords    */
DECL|method|setStopWords
specifier|public
name|void
name|setStopWords
parameter_list|(
name|Set
argument_list|<
name|?
argument_list|>
name|stopWords
parameter_list|)
block|{
name|this
operator|.
name|stopWords
operator|=
name|stopWords
expr_stmt|;
block|}
comment|/**    * Get the current stop words being used.    *    * @see #setStopWords    */
DECL|method|getStopWords
specifier|public
name|Set
argument_list|<
name|?
argument_list|>
name|getStopWords
parameter_list|()
block|{
return|return
name|stopWords
return|;
block|}
comment|/**    * Returns the maximum number of query terms that will be included in any generated query.    * The default is {@link #DEFAULT_MAX_QUERY_TERMS}.    *    * @return the maximum number of query terms that will be included in any generated query.    */
DECL|method|getMaxQueryTerms
specifier|public
name|int
name|getMaxQueryTerms
parameter_list|()
block|{
return|return
name|maxQueryTerms
return|;
block|}
comment|/**    * Sets the maximum number of query terms that will be included in any generated query.    *    * @param maxQueryTerms the maximum number of query terms that will be included in any    * generated query.    */
DECL|method|setMaxQueryTerms
specifier|public
name|void
name|setMaxQueryTerms
parameter_list|(
name|int
name|maxQueryTerms
parameter_list|)
block|{
name|this
operator|.
name|maxQueryTerms
operator|=
name|maxQueryTerms
expr_stmt|;
block|}
comment|/**    * @return The maximum number of tokens to parse in each example doc field that is not stored with TermVector support    * @see #DEFAULT_MAX_NUM_TOKENS_PARSED    */
DECL|method|getMaxNumTokensParsed
specifier|public
name|int
name|getMaxNumTokensParsed
parameter_list|()
block|{
return|return
name|maxNumTokensParsed
return|;
block|}
comment|/**    * @param i The maximum number of tokens to parse in each example doc field that is not stored with TermVector support    */
DECL|method|setMaxNumTokensParsed
specifier|public
name|void
name|setMaxNumTokensParsed
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|maxNumTokensParsed
operator|=
name|i
expr_stmt|;
block|}
comment|/**    * Return a query that will return docs like the passed lucene document ID.    *    * @param docNum the documentID of the lucene doc to generate the 'More Like This" query for.    * @return a query that will return docs like the passed lucene document ID.    */
DECL|method|like
specifier|public
name|Query
name|like
parameter_list|(
name|int
name|docNum
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fieldNames
operator|==
literal|null
condition|)
block|{
comment|// gather list of valid fields from lucene
name|Collection
argument_list|<
name|String
argument_list|>
name|fields
init|=
name|MultiFields
operator|.
name|getIndexedFields
argument_list|(
name|ir
argument_list|)
decl_stmt|;
name|fieldNames
operator|=
name|fields
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|fields
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|createQuery
argument_list|(
name|retrieveTerms
argument_list|(
name|docNum
argument_list|)
argument_list|)
return|;
block|}
comment|/**    *     * @param filteredDocument Document with field values extracted for selected fields.    * @return More Like This query for the passed document.    */
DECL|method|like
specifier|public
name|Query
name|like
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|Object
argument_list|>
argument_list|>
name|filteredDocument
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fieldNames
operator|==
literal|null
condition|)
block|{
comment|// gather list of valid fields from lucene
name|Collection
argument_list|<
name|String
argument_list|>
name|fields
init|=
name|MultiFields
operator|.
name|getIndexedFields
argument_list|(
name|ir
argument_list|)
decl_stmt|;
name|fieldNames
operator|=
name|fields
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|fields
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|createQuery
argument_list|(
name|retrieveTerms
argument_list|(
name|filteredDocument
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Return a query that will return docs like the passed Readers.    * This was added in order to treat multi-value fields.    *    * @return a query that will return docs like the passed Readers.    */
DECL|method|like
specifier|public
name|Query
name|like
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
modifier|...
name|readers
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Int
argument_list|>
name|words
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Reader
name|r
range|:
name|readers
control|)
block|{
name|addTermFrequencies
argument_list|(
name|r
argument_list|,
name|words
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|createQuery
argument_list|(
name|createQueue
argument_list|(
name|words
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Create the More like query from a PriorityQueue    */
DECL|method|createQuery
specifier|private
name|Query
name|createQuery
parameter_list|(
name|PriorityQueue
argument_list|<
name|ScoreTerm
argument_list|>
name|q
parameter_list|)
block|{
name|BooleanQuery
operator|.
name|Builder
name|query
init|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|ScoreTerm
name|scoreTerm
decl_stmt|;
name|float
name|bestScore
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|(
name|scoreTerm
operator|=
name|q
operator|.
name|pop
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|TermQuery
name|tq
init|=
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
name|scoreTerm
operator|.
name|topField
argument_list|,
name|scoreTerm
operator|.
name|word
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|boost
condition|)
block|{
if|if
condition|(
name|bestScore
operator|==
operator|-
literal|1
condition|)
block|{
name|bestScore
operator|=
operator|(
name|scoreTerm
operator|.
name|score
operator|)
expr_stmt|;
block|}
name|float
name|myScore
init|=
operator|(
name|scoreTerm
operator|.
name|score
operator|)
decl_stmt|;
name|tq
operator|.
name|setBoost
argument_list|(
name|boostFactor
operator|*
name|myScore
operator|/
name|bestScore
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|query
operator|.
name|add
argument_list|(
name|tq
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BooleanQuery
operator|.
name|TooManyClauses
name|ignore
parameter_list|)
block|{
break|break;
block|}
block|}
return|return
name|query
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Create a PriorityQueue from a word-&gt;tf map.    *    * @param words a map of words keyed on the word(String) with Int objects as the values.    */
DECL|method|createQueue
specifier|private
name|PriorityQueue
argument_list|<
name|ScoreTerm
argument_list|>
name|createQueue
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Int
argument_list|>
name|words
parameter_list|)
throws|throws
name|IOException
block|{
comment|// have collected all words in doc and their freqs
name|int
name|numDocs
init|=
name|ir
operator|.
name|numDocs
argument_list|()
decl_stmt|;
specifier|final
name|int
name|limit
init|=
name|Math
operator|.
name|min
argument_list|(
name|maxQueryTerms
argument_list|,
name|words
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|FreqQ
name|queue
init|=
operator|new
name|FreqQ
argument_list|(
name|limit
argument_list|)
decl_stmt|;
comment|// will order words by score
for|for
control|(
name|String
name|word
range|:
name|words
operator|.
name|keySet
argument_list|()
control|)
block|{
comment|// for every word
name|int
name|tf
init|=
name|words
operator|.
name|get
argument_list|(
name|word
argument_list|)
operator|.
name|x
decl_stmt|;
comment|// term freq in the source doc
if|if
condition|(
name|minTermFreq
operator|>
literal|0
operator|&&
name|tf
operator|<
name|minTermFreq
condition|)
block|{
continue|continue;
comment|// filter out words that don't occur enough times in the source
block|}
comment|// go through all the fields and find the largest document frequency
name|String
name|topField
init|=
name|fieldNames
index|[
literal|0
index|]
decl_stmt|;
name|int
name|docFreq
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
name|int
name|freq
init|=
name|ir
operator|.
name|docFreq
argument_list|(
operator|new
name|Term
argument_list|(
name|fieldName
argument_list|,
name|word
argument_list|)
argument_list|)
decl_stmt|;
name|topField
operator|=
operator|(
name|freq
operator|>
name|docFreq
operator|)
condition|?
name|fieldName
else|:
name|topField
expr_stmt|;
name|docFreq
operator|=
operator|(
name|freq
operator|>
name|docFreq
operator|)
condition|?
name|freq
else|:
name|docFreq
expr_stmt|;
block|}
if|if
condition|(
name|minDocFreq
operator|>
literal|0
operator|&&
name|docFreq
operator|<
name|minDocFreq
condition|)
block|{
continue|continue;
comment|// filter out words that don't occur in enough docs
block|}
if|if
condition|(
name|docFreq
operator|>
name|maxDocFreq
condition|)
block|{
continue|continue;
comment|// filter out words that occur in too many docs
block|}
if|if
condition|(
name|docFreq
operator|==
literal|0
condition|)
block|{
continue|continue;
comment|// index update problem?
block|}
name|float
name|idf
init|=
name|similarity
operator|.
name|idf
argument_list|(
name|docFreq
argument_list|,
name|numDocs
argument_list|)
decl_stmt|;
name|float
name|score
init|=
name|tf
operator|*
name|idf
decl_stmt|;
if|if
condition|(
name|queue
operator|.
name|size
argument_list|()
operator|<
name|limit
condition|)
block|{
comment|// there is still space in the queue
name|queue
operator|.
name|add
argument_list|(
operator|new
name|ScoreTerm
argument_list|(
name|word
argument_list|,
name|topField
argument_list|,
name|score
argument_list|,
name|idf
argument_list|,
name|docFreq
argument_list|,
name|tf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ScoreTerm
name|term
init|=
name|queue
operator|.
name|top
argument_list|()
decl_stmt|;
if|if
condition|(
name|term
operator|.
name|score
operator|<
name|score
condition|)
block|{
comment|// update the smallest in the queue in place and update the queue.
name|term
operator|.
name|update
argument_list|(
name|word
argument_list|,
name|topField
argument_list|,
name|score
argument_list|,
name|idf
argument_list|,
name|docFreq
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|queue
operator|.
name|updateTop
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|queue
return|;
block|}
comment|/**    * Describe the parameters that control how the "more like this" query is formed.    */
DECL|method|describeParams
specifier|public
name|String
name|describeParams
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
literal|"maxQueryTerms  : "
argument_list|)
operator|.
name|append
argument_list|(
name|maxQueryTerms
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
literal|"minWordLen     : "
argument_list|)
operator|.
name|append
argument_list|(
name|minWordLen
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
literal|"maxWordLen     : "
argument_list|)
operator|.
name|append
argument_list|(
name|maxWordLen
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
literal|"fieldNames     : "
argument_list|)
expr_stmt|;
name|String
name|delim
init|=
literal|""
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|delim
argument_list|)
operator|.
name|append
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
name|delim
operator|=
literal|", "
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
literal|"boost          : "
argument_list|)
operator|.
name|append
argument_list|(
name|boost
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
literal|"minTermFreq    : "
argument_list|)
operator|.
name|append
argument_list|(
name|minTermFreq
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
literal|"minDocFreq     : "
argument_list|)
operator|.
name|append
argument_list|(
name|minDocFreq
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Find words for a more-like-this query former.    *    * @param docNum the id of the lucene document from which to find terms    */
DECL|method|retrieveTerms
specifier|private
name|PriorityQueue
argument_list|<
name|ScoreTerm
argument_list|>
name|retrieveTerms
parameter_list|(
name|int
name|docNum
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Int
argument_list|>
name|termFreqMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
specifier|final
name|Fields
name|vectors
init|=
name|ir
operator|.
name|getTermVectors
argument_list|(
name|docNum
argument_list|)
decl_stmt|;
specifier|final
name|Terms
name|vector
decl_stmt|;
if|if
condition|(
name|vectors
operator|!=
literal|null
condition|)
block|{
name|vector
operator|=
name|vectors
operator|.
name|terms
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vector
operator|=
literal|null
expr_stmt|;
block|}
comment|// field does not store term vector info
if|if
condition|(
name|vector
operator|==
literal|null
condition|)
block|{
name|StoredDocument
name|d
init|=
name|ir
operator|.
name|document
argument_list|(
name|docNum
argument_list|)
decl_stmt|;
name|StorableField
index|[]
name|fields
init|=
name|d
operator|.
name|getFields
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
for|for
control|(
name|StorableField
name|field
range|:
name|fields
control|)
block|{
specifier|final
name|String
name|stringValue
init|=
name|field
operator|.
name|stringValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|stringValue
operator|!=
literal|null
condition|)
block|{
name|addTermFrequencies
argument_list|(
operator|new
name|StringReader
argument_list|(
name|stringValue
argument_list|)
argument_list|,
name|termFreqMap
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|addTermFrequencies
argument_list|(
name|termFreqMap
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|createQueue
argument_list|(
name|termFreqMap
argument_list|)
return|;
block|}
DECL|method|retrieveTerms
specifier|private
name|PriorityQueue
argument_list|<
name|ScoreTerm
argument_list|>
name|retrieveTerms
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|Object
argument_list|>
argument_list|>
name|fields
parameter_list|)
throws|throws
name|IOException
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Int
argument_list|>
name|termFreqMap
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
for|for
control|(
name|String
name|field
range|:
name|fields
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Collection
argument_list|<
name|Object
argument_list|>
name|fieldValues
init|=
name|fields
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
name|fieldValue
range|:
name|fieldValues
control|)
block|{
if|if
condition|(
name|fieldValue
operator|!=
literal|null
condition|)
block|{
name|addTermFrequencies
argument_list|(
operator|new
name|StringReader
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|fieldValue
argument_list|)
argument_list|)
argument_list|,
name|termFreqMap
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|createQueue
argument_list|(
name|termFreqMap
argument_list|)
return|;
block|}
comment|/**    * Adds terms and frequencies found in vector into the Map termFreqMap    *    * @param termFreqMap a Map of terms and their frequencies    * @param vector List of terms and their frequencies for a doc/field    */
DECL|method|addTermFrequencies
specifier|private
name|void
name|addTermFrequencies
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Int
argument_list|>
name|termFreqMap
parameter_list|,
name|Terms
name|vector
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|TermsEnum
name|termsEnum
init|=
name|vector
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|final
name|CharsRefBuilder
name|spare
init|=
operator|new
name|CharsRefBuilder
argument_list|()
decl_stmt|;
name|BytesRef
name|text
decl_stmt|;
while|while
condition|(
operator|(
name|text
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|spare
operator|.
name|copyUTF8Bytes
argument_list|(
name|text
argument_list|)
expr_stmt|;
specifier|final
name|String
name|term
init|=
name|spare
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|isNoiseWord
argument_list|(
name|term
argument_list|)
condition|)
block|{
continue|continue;
block|}
specifier|final
name|int
name|freq
init|=
operator|(
name|int
operator|)
name|termsEnum
operator|.
name|totalTermFreq
argument_list|()
decl_stmt|;
comment|// increment frequency
name|Int
name|cnt
init|=
name|termFreqMap
operator|.
name|get
argument_list|(
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|null
condition|)
block|{
name|cnt
operator|=
operator|new
name|Int
argument_list|()
expr_stmt|;
name|termFreqMap
operator|.
name|put
argument_list|(
name|term
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|x
operator|=
name|freq
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|.
name|x
operator|+=
name|freq
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Adds term frequencies found by tokenizing text from reader into the Map words    *    * @param r a source of text to be tokenized    * @param termFreqMap a Map of terms and their frequencies    * @param fieldName Used by analyzer for any special per-field analysis    */
DECL|method|addTermFrequencies
specifier|private
name|void
name|addTermFrequencies
parameter_list|(
name|Reader
name|r
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Int
argument_list|>
name|termFreqMap
parameter_list|,
name|String
name|fieldName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|analyzer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"To use MoreLikeThis without "
operator|+
literal|"term vectors, you must provide an Analyzer"
argument_list|)
throw|;
block|}
try|try
init|(
name|TokenStream
name|ts
init|=
name|analyzer
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
name|r
argument_list|)
init|)
block|{
name|int
name|tokenCount
init|=
literal|0
decl_stmt|;
comment|// for every token
name|CharTermAttribute
name|termAtt
init|=
name|ts
operator|.
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|ts
operator|.
name|reset
argument_list|()
expr_stmt|;
while|while
condition|(
name|ts
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
name|String
name|word
init|=
name|termAtt
operator|.
name|toString
argument_list|()
decl_stmt|;
name|tokenCount
operator|++
expr_stmt|;
if|if
condition|(
name|tokenCount
operator|>
name|maxNumTokensParsed
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|isNoiseWord
argument_list|(
name|word
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// increment frequency
name|Int
name|cnt
init|=
name|termFreqMap
operator|.
name|get
argument_list|(
name|word
argument_list|)
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|null
condition|)
block|{
name|termFreqMap
operator|.
name|put
argument_list|(
name|word
argument_list|,
operator|new
name|Int
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|.
name|x
operator|++
expr_stmt|;
block|}
block|}
name|ts
operator|.
name|end
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * determines if the passed term is likely to be of interest in "more like" comparisons    *    * @param term The word being considered    * @return true if should be ignored, false if should be used in further analysis    */
DECL|method|isNoiseWord
specifier|private
name|boolean
name|isNoiseWord
parameter_list|(
name|String
name|term
parameter_list|)
block|{
name|int
name|len
init|=
name|term
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|minWordLen
operator|>
literal|0
operator|&&
name|len
operator|<
name|minWordLen
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|maxWordLen
operator|>
literal|0
operator|&&
name|len
operator|>
name|maxWordLen
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|stopWords
operator|!=
literal|null
operator|&&
name|stopWords
operator|.
name|contains
argument_list|(
name|term
argument_list|)
return|;
block|}
comment|/**    * Find words for a more-like-this query former.    * The result is a priority queue of arrays with one entry for<b>every word</b> in the document.    * Each array has 6 elements.    * The elements are:    *<ol>    *<li> The word (String)    *<li> The top field that this word comes from (String)    *<li> The score for this word (Float)    *<li> The IDF value (Float)    *<li> The frequency of this word in the index (Integer)    *<li> The frequency of this word in the source document (Integer)    *</ol>    * This is a somewhat "advanced" routine, and in general only the 1st entry in the array is of interest.    * This method is exposed so that you can identify the "interesting words" in a document.    * For an easier method to call see {@link #retrieveInterestingTerms retrieveInterestingTerms()}.    *    * @param r the reader that has the content of the document    * @param fieldName field passed to the analyzer to use when analyzing the content    * @return the most interesting words in the document ordered by score, with the highest scoring, or best entry, first    * @see #retrieveInterestingTerms    */
DECL|method|retrieveTerms
specifier|private
name|PriorityQueue
argument_list|<
name|ScoreTerm
argument_list|>
name|retrieveTerms
parameter_list|(
name|Reader
name|r
parameter_list|,
name|String
name|fieldName
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Int
argument_list|>
name|words
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|addTermFrequencies
argument_list|(
name|r
argument_list|,
name|words
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
return|return
name|createQueue
argument_list|(
name|words
argument_list|)
return|;
block|}
comment|/**    * @see #retrieveInterestingTerms(java.io.Reader, String)    */
DECL|method|retrieveInterestingTerms
specifier|public
name|String
index|[]
name|retrieveInterestingTerms
parameter_list|(
name|int
name|docNum
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|Object
argument_list|>
name|al
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|maxQueryTerms
argument_list|)
decl_stmt|;
name|PriorityQueue
argument_list|<
name|ScoreTerm
argument_list|>
name|pq
init|=
name|retrieveTerms
argument_list|(
name|docNum
argument_list|)
decl_stmt|;
name|ScoreTerm
name|scoreTerm
decl_stmt|;
name|int
name|lim
init|=
name|maxQueryTerms
decl_stmt|;
comment|// have to be careful, retrieveTerms returns all words but that's probably not useful to our caller...
comment|// we just want to return the top words
while|while
condition|(
operator|(
operator|(
name|scoreTerm
operator|=
name|pq
operator|.
name|pop
argument_list|()
operator|)
operator|!=
literal|null
operator|)
operator|&&
name|lim
operator|--
operator|>
literal|0
condition|)
block|{
name|al
operator|.
name|add
argument_list|(
name|scoreTerm
operator|.
name|word
argument_list|)
expr_stmt|;
comment|// the 1st entry is the interesting word
block|}
name|String
index|[]
name|res
init|=
operator|new
name|String
index|[
name|al
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
return|return
name|al
operator|.
name|toArray
argument_list|(
name|res
argument_list|)
return|;
block|}
comment|/**    * Convenience routine to make it easy to return the most interesting words in a document.    * More advanced users will call {@link #retrieveTerms(Reader, String) retrieveTerms()} directly.    *    * @param r the source document    * @param fieldName field passed to analyzer to use when analyzing the content    * @return the most interesting words in the document    * @see #retrieveTerms(java.io.Reader, String)    * @see #setMaxQueryTerms    */
DECL|method|retrieveInterestingTerms
specifier|public
name|String
index|[]
name|retrieveInterestingTerms
parameter_list|(
name|Reader
name|r
parameter_list|,
name|String
name|fieldName
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|Object
argument_list|>
name|al
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|maxQueryTerms
argument_list|)
decl_stmt|;
name|PriorityQueue
argument_list|<
name|ScoreTerm
argument_list|>
name|pq
init|=
name|retrieveTerms
argument_list|(
name|r
argument_list|,
name|fieldName
argument_list|)
decl_stmt|;
name|ScoreTerm
name|scoreTerm
decl_stmt|;
name|int
name|lim
init|=
name|maxQueryTerms
decl_stmt|;
comment|// have to be careful, retrieveTerms returns all words but that's probably not useful to our caller...
comment|// we just want to return the top words
while|while
condition|(
operator|(
operator|(
name|scoreTerm
operator|=
name|pq
operator|.
name|pop
argument_list|()
operator|)
operator|!=
literal|null
operator|)
operator|&&
name|lim
operator|--
operator|>
literal|0
condition|)
block|{
name|al
operator|.
name|add
argument_list|(
name|scoreTerm
operator|.
name|word
argument_list|)
expr_stmt|;
comment|// the 1st entry is the interesting word
block|}
name|String
index|[]
name|res
init|=
operator|new
name|String
index|[
name|al
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
return|return
name|al
operator|.
name|toArray
argument_list|(
name|res
argument_list|)
return|;
block|}
comment|/**    * PriorityQueue that orders words by score.    */
DECL|class|FreqQ
specifier|private
specifier|static
class|class
name|FreqQ
extends|extends
name|PriorityQueue
argument_list|<
name|ScoreTerm
argument_list|>
block|{
DECL|method|FreqQ
name|FreqQ
parameter_list|(
name|int
name|maxSize
parameter_list|)
block|{
name|super
argument_list|(
name|maxSize
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|lessThan
specifier|protected
name|boolean
name|lessThan
parameter_list|(
name|ScoreTerm
name|a
parameter_list|,
name|ScoreTerm
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|score
operator|<
name|b
operator|.
name|score
return|;
block|}
block|}
DECL|class|ScoreTerm
specifier|private
specifier|static
class|class
name|ScoreTerm
block|{
comment|// only really need 1st 3 entries, other ones are for troubleshooting
DECL|field|word
name|String
name|word
decl_stmt|;
DECL|field|topField
name|String
name|topField
decl_stmt|;
DECL|field|score
name|float
name|score
decl_stmt|;
DECL|field|idf
name|float
name|idf
decl_stmt|;
DECL|field|docFreq
name|int
name|docFreq
decl_stmt|;
DECL|field|tf
name|int
name|tf
decl_stmt|;
DECL|method|ScoreTerm
name|ScoreTerm
parameter_list|(
name|String
name|word
parameter_list|,
name|String
name|topField
parameter_list|,
name|float
name|score
parameter_list|,
name|float
name|idf
parameter_list|,
name|int
name|docFreq
parameter_list|,
name|int
name|tf
parameter_list|)
block|{
name|this
operator|.
name|word
operator|=
name|word
expr_stmt|;
name|this
operator|.
name|topField
operator|=
name|topField
expr_stmt|;
name|this
operator|.
name|score
operator|=
name|score
expr_stmt|;
name|this
operator|.
name|idf
operator|=
name|idf
expr_stmt|;
name|this
operator|.
name|docFreq
operator|=
name|docFreq
expr_stmt|;
name|this
operator|.
name|tf
operator|=
name|tf
expr_stmt|;
block|}
DECL|method|update
name|void
name|update
parameter_list|(
name|String
name|word
parameter_list|,
name|String
name|topField
parameter_list|,
name|float
name|score
parameter_list|,
name|float
name|idf
parameter_list|,
name|int
name|docFreq
parameter_list|,
name|int
name|tf
parameter_list|)
block|{
name|this
operator|.
name|word
operator|=
name|word
expr_stmt|;
name|this
operator|.
name|topField
operator|=
name|topField
expr_stmt|;
name|this
operator|.
name|score
operator|=
name|score
expr_stmt|;
name|this
operator|.
name|idf
operator|=
name|idf
expr_stmt|;
name|this
operator|.
name|docFreq
operator|=
name|docFreq
expr_stmt|;
name|this
operator|.
name|tf
operator|=
name|tf
expr_stmt|;
block|}
block|}
comment|/**    * Use for frequencies and to avoid renewing Integers.    */
DECL|class|Int
specifier|private
specifier|static
class|class
name|Int
block|{
DECL|field|x
name|int
name|x
decl_stmt|;
DECL|method|Int
name|Int
parameter_list|()
block|{
name|x
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
