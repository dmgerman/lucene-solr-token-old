begin_unit
begin_package
DECL|package|org.apache.lucene.facet.taxonomy
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|taxonomy
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|LockObtainFailedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RAMDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|taxonomy
operator|.
name|TaxonomyReader
operator|.
name|ChildrenArrays
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|taxonomy
operator|.
name|directory
operator|.
name|DirectoryTaxonomyReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|taxonomy
operator|.
name|directory
operator|.
name|DirectoryTaxonomyWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|SlowRAMDirectory
import|;
end_import
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_class
DECL|class|TestTaxonomyCombined
specifier|public
class|class
name|TestTaxonomyCombined
extends|extends
name|LuceneTestCase
block|{
comment|/**  The following categories will be added to the taxonomy by     fillTaxonomy(), and tested by all tests below:   */
DECL|field|categories
specifier|private
specifier|final
specifier|static
name|String
index|[]
index|[]
name|categories
init|=
block|{
block|{
literal|"Author"
block|,
literal|"Tom Clancy"
block|}
block|,
block|{
literal|"Author"
block|,
literal|"Richard Dawkins"
block|}
block|,
block|{
literal|"Author"
block|,
literal|"Richard Adams"
block|}
block|,
block|{
literal|"Price"
block|,
literal|"10"
block|,
literal|"11"
block|}
block|,
block|{
literal|"Price"
block|,
literal|"10"
block|,
literal|"12"
block|}
block|,
block|{
literal|"Price"
block|,
literal|"20"
block|,
literal|"27"
block|}
block|,
block|{
literal|"Date"
block|,
literal|"2006"
block|,
literal|"05"
block|}
block|,
block|{
literal|"Date"
block|,
literal|"2005"
block|}
block|,
block|{
literal|"Date"
block|,
literal|"2006"
block|}
block|,
block|{
literal|"Subject"
block|,
literal|"Nonfiction"
block|,
literal|"Children"
block|,
literal|"Animals"
block|}
block|,
block|{
literal|"Author"
block|,
literal|"Stephen Jay Gould"
block|}
block|,
block|{
literal|"Author"
block|,
literal|"\u05e0\u05d3\u05d1\u3042\u0628"
block|}
block|,   }
decl_stmt|;
comment|/**  When adding the above categories with TaxonomyWriter.addCategory(),      the following paths are expected to be returned:     (note that currently the full path is not returned, and therefore     not tested - rather, just the last component, the ordinal, is returned     and tested.   */
DECL|field|expectedPaths
specifier|private
specifier|final
specifier|static
name|int
index|[]
index|[]
name|expectedPaths
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|1
block|,
literal|4
block|}
block|,
block|{
literal|5
block|,
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|5
block|,
literal|6
block|,
literal|8
block|}
block|,
block|{
literal|5
block|,
literal|9
block|,
literal|10
block|}
block|,
block|{
literal|11
block|,
literal|12
block|,
literal|13
block|}
block|,
block|{
literal|11
block|,
literal|14
block|}
block|,
block|{
literal|11
block|,
literal|12
block|}
block|,
block|{
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|}
block|,
block|{
literal|1
block|,
literal|19
block|}
block|,
block|{
literal|1
block|,
literal|20
block|}
block|}
decl_stmt|;
comment|/**  The taxonomy index is expected to then contain the following     generated categories, with increasing ordinals (note how parent     categories are be added automatically when subcategories are added).    */
DECL|field|expectedCategories
specifier|private
specifier|final
specifier|static
name|String
index|[]
index|[]
name|expectedCategories
init|=
block|{
block|{ }
block|,
comment|// the root category
block|{
literal|"Author"
block|}
block|,
block|{
literal|"Author"
block|,
literal|"Tom Clancy"
block|}
block|,
block|{
literal|"Author"
block|,
literal|"Richard Dawkins"
block|}
block|,
block|{
literal|"Author"
block|,
literal|"Richard Adams"
block|}
block|,
block|{
literal|"Price"
block|}
block|,
block|{
literal|"Price"
block|,
literal|"10"
block|}
block|,
block|{
literal|"Price"
block|,
literal|"10"
block|,
literal|"11"
block|}
block|,
block|{
literal|"Price"
block|,
literal|"10"
block|,
literal|"12"
block|}
block|,
block|{
literal|"Price"
block|,
literal|"20"
block|}
block|,
block|{
literal|"Price"
block|,
literal|"20"
block|,
literal|"27"
block|}
block|,
block|{
literal|"Date"
block|}
block|,
block|{
literal|"Date"
block|,
literal|"2006"
block|}
block|,
block|{
literal|"Date"
block|,
literal|"2006"
block|,
literal|"05"
block|}
block|,
block|{
literal|"Date"
block|,
literal|"2005"
block|}
block|,
block|{
literal|"Subject"
block|}
block|,
block|{
literal|"Subject"
block|,
literal|"Nonfiction"
block|}
block|,
block|{
literal|"Subject"
block|,
literal|"Nonfiction"
block|,
literal|"Children"
block|}
block|,
block|{
literal|"Subject"
block|,
literal|"Nonfiction"
block|,
literal|"Children"
block|,
literal|"Animals"
block|}
block|,
block|{
literal|"Author"
block|,
literal|"Stephen Jay Gould"
block|}
block|,
block|{
literal|"Author"
block|,
literal|"\u05e0\u05d3\u05d1\u3042\u0628"
block|}
block|,   }
decl_stmt|;
comment|/**  fillTaxonomy adds the categories in the categories[] array, and asserts     that the additions return exactly the ordinals (in the past - paths)     specified in expectedPaths[].     Note that this assumes that fillTaxonomy() is called on an empty taxonomy     index. Calling it after something else was already added to the taxonomy     index will surely have this method fail.    */
DECL|method|fillTaxonomy
specifier|public
specifier|static
name|void
name|fillTaxonomy
parameter_list|(
name|TaxonomyWriter
name|tw
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|categories
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ordinal
init|=
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
name|categories
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|expectedOrdinal
init|=
name|expectedPaths
index|[
name|i
index|]
index|[
name|expectedPaths
index|[
name|i
index|]
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|ordinal
operator|!=
name|expectedOrdinal
condition|)
block|{
name|fail
argument_list|(
literal|"For category "
operator|+
name|showcat
argument_list|(
name|categories
index|[
name|i
index|]
argument_list|)
operator|+
literal|" expected ordinal "
operator|+
name|expectedOrdinal
operator|+
literal|", but got "
operator|+
name|ordinal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|showcat
specifier|public
specifier|static
name|String
name|showcat
parameter_list|(
name|String
index|[]
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
return|return
literal|"<null>"
return|;
block|}
if|if
condition|(
name|path
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|"<empty>"
return|;
block|}
if|if
condition|(
name|path
operator|.
name|length
operator|==
literal|1
operator|&&
name|path
index|[
literal|0
index|]
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|"<\"\">"
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|path
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|showcat
specifier|private
name|String
name|showcat
parameter_list|(
name|CategoryPath
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
return|return
literal|"<null>"
return|;
block|}
if|if
condition|(
name|path
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|"<empty>"
return|;
block|}
return|return
literal|"<"
operator|+
name|path
operator|.
name|toString
argument_list|(
literal|'/'
argument_list|)
operator|+
literal|">"
return|;
block|}
comment|/**  Basic tests for TaxonomyWriter. Basically, we test that     IndexWriter.addCategory works, i.e. returns the expected ordinals     (this is tested by calling the fillTaxonomy() method above).     We do not test here that after writing the index can be read -     this will be done in more tests below.    */
annotation|@
name|Test
DECL|method|testWriter
specifier|public
name|void
name|testWriter
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
comment|// Also check TaxonomyWriter.getSize() - see that the taxonomy's size
comment|// is what we expect it to be.
name|assertEquals
argument_list|(
name|expectedCategories
operator|.
name|length
argument_list|,
name|tw
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**  testWriterTwice is exactly like testWriter, except that after adding     all the categories, we add them again, and see that we get the same     old ids again - not new categories.    */
annotation|@
name|Test
DECL|method|testWriterTwice
specifier|public
name|void
name|testWriterTwice
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
comment|// run fillTaxonomy again - this will try to add the same categories
comment|// again, and check that we see the same ordinal paths again, not
comment|// different ones.
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
comment|// Let's check the number of categories again, to see that no
comment|// extraneous categories were created:
name|assertEquals
argument_list|(
name|expectedCategories
operator|.
name|length
argument_list|,
name|tw
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**  testWriterTwice2 is similar to testWriterTwice, except that the index     is closed and reopened before attempting to write to it the same     categories again. While testWriterTwice can get along with writing     and reading correctly just to the cache, testWriterTwice2 checks also     the actual disk read part of the writer:    */
annotation|@
name|Test
DECL|method|testWriterTwice2
specifier|public
name|void
name|testWriterTwice2
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|tw
operator|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
expr_stmt|;
comment|// run fillTaxonomy again - this will try to add the same categories
comment|// again, and check that we see the same ordinals again, not different
comment|// ones, and that the number of categories hasn't grown by the new
comment|// additions
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expectedCategories
operator|.
name|length
argument_list|,
name|tw
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * testWriterTwice3 is yet another test which tests creating a taxonomy    * in two separate writing sessions. This test used to fail because of    * a bug involving commit(), explained below, and now should succeed.    */
annotation|@
name|Test
DECL|method|testWriterTwice3
specifier|public
name|void
name|testWriterTwice3
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
comment|// First, create and fill the taxonomy
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Now, open the same taxonomy and add the same categories again.
comment|// After a few categories, the LuceneTaxonomyWriter implementation
comment|// will stop looking for each category on disk, and rather read them
comment|// all into memory and close it's reader. The bug was that it closed
comment|// the reader, but forgot that it did (because it didn't set the reader
comment|// reference to null).
name|tw
operator|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
expr_stmt|;
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
comment|// Add one new category, just to make commit() do something:
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"hi"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Do a commit(). Here was a bug - if tw had a reader open, it should
comment|// be reopened after the commit. However, in our case the reader should
comment|// not be open (as explained above) but because it was not set to null,
comment|// we forgot that, tried to reopen it, and got an AlreadyClosedException.
name|tw
operator|.
name|commit
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|expectedCategories
operator|.
name|length
operator|+
literal|1
argument_list|,
name|tw
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**  Another set of tests for the writer, which don't use an array and    *  try to distill the different cases, and therefore may be more helpful    *  for debugging a problem than testWriter() which is hard to know why    *  or where it failed.     */
annotation|@
name|Test
DECL|method|testWriterSimpler
specifier|public
name|void
name|testWriterSimpler
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|tw
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// the root only
comment|// Test that adding a new top-level category works
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"a"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|tw
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// Test that adding the same category again is noticed, and the
comment|// same ordinal (and not a new one) is returned.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"a"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|tw
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// Test that adding another top-level category returns a new ordinal,
comment|// not the same one
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"b"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|tw
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// Test that adding a category inside one of the above adds just one
comment|// new ordinal:
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"a"
argument_list|,
literal|"c"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|tw
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// Test that adding the same second-level category doesn't do anything:
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"a"
argument_list|,
literal|"c"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|tw
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// Test that adding a second-level category with two new components
comment|// indeed adds two categories
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"d"
argument_list|,
literal|"e"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|tw
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// Verify that the parents were added above in the order we expected
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"d"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Similar, but inside a category that already exists:
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"b"
argument_list|,
literal|"d"
argument_list|,
literal|"e"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|8
argument_list|,
name|tw
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// And now inside two levels of categories that already exist:
name|assertEquals
argument_list|(
literal|8
argument_list|,
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"b"
argument_list|,
literal|"d"
argument_list|,
literal|"f"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|9
argument_list|,
name|tw
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**  Test writing an empty index, and seeing that a reader finds in it     the root category, and only it. We check all the methods on that     root category return the expected results.    */
annotation|@
name|Test
DECL|method|testRootOnly
specifier|public
name|void
name|testRootOnly
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
comment|// right after opening the index, it should already contain the
comment|// root, so have size 1:
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|tw
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|TaxonomyReader
name|tr
init|=
operator|new
name|DirectoryTaxonomyReader
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|tr
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|,
name|tr
operator|.
name|getParent
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|tr
operator|.
name|getOrdinal
argument_list|(
operator|new
name|CategoryPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|tr
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**  The following test is exactly the same as testRootOnly, except we    *  do not close the writer before opening the reader. We want to see    *  that the root is visible to the reader not only after the writer is    *  closed, but immediately after it is created.    */
annotation|@
name|Test
DECL|method|testRootOnly2
specifier|public
name|void
name|testRootOnly2
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|tw
operator|.
name|commit
argument_list|()
expr_stmt|;
name|TaxonomyReader
name|tr
init|=
operator|new
name|DirectoryTaxonomyReader
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|tr
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|,
name|tr
operator|.
name|getParent
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|tr
operator|.
name|getOrdinal
argument_list|(
operator|new
name|CategoryPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|tr
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**  Basic tests for TaxonomyReader's category<=> ordinal transformations     (getSize(), getCategory() and getOrdinal()).     We test that after writing the index, it can be read and all the     categories and ordinals are there just as we expected them to be.    */
annotation|@
name|Test
DECL|method|testReaderBasic
specifier|public
name|void
name|testReaderBasic
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|TaxonomyReader
name|tr
init|=
operator|new
name|DirectoryTaxonomyReader
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
comment|// test TaxonomyReader.getSize():
name|assertEquals
argument_list|(
name|expectedCategories
operator|.
name|length
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// test round trips of ordinal => category => ordinal
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tr
operator|.
name|getSize
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|i
argument_list|,
name|tr
operator|.
name|getOrdinal
argument_list|(
name|tr
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// test TaxonomyReader.getCategory():
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tr
operator|.
name|getSize
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|CategoryPath
name|expectedCategory
init|=
operator|new
name|CategoryPath
argument_list|(
name|expectedCategories
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|CategoryPath
name|category
init|=
name|tr
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|expectedCategory
operator|.
name|equals
argument_list|(
name|category
argument_list|)
condition|)
block|{
name|fail
argument_list|(
literal|"For ordinal "
operator|+
name|i
operator|+
literal|" expected category "
operator|+
name|showcat
argument_list|(
name|expectedCategory
argument_list|)
operator|+
literal|", but got "
operator|+
name|showcat
argument_list|(
name|category
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//  (also test invalid ordinals:)
name|assertNull
argument_list|(
name|tr
operator|.
name|getPath
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|tr
operator|.
name|getPath
argument_list|(
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|tr
operator|.
name|getPath
argument_list|(
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|)
argument_list|)
expr_stmt|;
comment|// test TaxonomyReader.getOrdinal():
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expectedCategories
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|expectedOrdinal
init|=
name|i
decl_stmt|;
name|int
name|ordinal
init|=
name|tr
operator|.
name|getOrdinal
argument_list|(
operator|new
name|CategoryPath
argument_list|(
name|expectedCategories
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedOrdinal
operator|!=
name|ordinal
condition|)
block|{
name|fail
argument_list|(
literal|"For category "
operator|+
name|showcat
argument_list|(
name|expectedCategories
index|[
name|i
index|]
argument_list|)
operator|+
literal|" expected ordinal "
operator|+
name|expectedOrdinal
operator|+
literal|", but got "
operator|+
name|ordinal
argument_list|)
expr_stmt|;
block|}
block|}
comment|// (also test invalid categories:)
name|assertEquals
argument_list|(
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|,
name|tr
operator|.
name|getOrdinal
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"non-existant"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|,
name|tr
operator|.
name|getOrdinal
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"Author"
argument_list|,
literal|"Jules Verne"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tr
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**  Tests for TaxonomyReader's getParent() method.     We check it by comparing its results to those we could have gotten by     looking at the category string paths (where the parentage is obvious).     Note that after testReaderBasic(), we already know we can trust the     ordinal<=> category conversions.          Note: At the moment, the parent methods in the reader are deprecated,     but this does not mean they should not be tested! Until they are     removed (*if* they are removed), these tests should remain to see     that they still work correctly.    */
annotation|@
name|Test
DECL|method|testReaderParent
specifier|public
name|void
name|testReaderParent
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|TaxonomyReader
name|tr
init|=
operator|new
name|DirectoryTaxonomyReader
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
comment|// check that the parent of the root ordinal is the invalid ordinal:
name|assertEquals
argument_list|(
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|,
name|tr
operator|.
name|getParent
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// check parent of non-root ordinals:
for|for
control|(
name|int
name|ordinal
init|=
literal|1
init|;
name|ordinal
operator|<
name|tr
operator|.
name|getSize
argument_list|()
condition|;
name|ordinal
operator|++
control|)
block|{
name|CategoryPath
name|me
init|=
name|tr
operator|.
name|getPath
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
name|int
name|parentOrdinal
init|=
name|tr
operator|.
name|getParent
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
name|CategoryPath
name|parent
init|=
name|tr
operator|.
name|getPath
argument_list|(
name|parentOrdinal
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
name|fail
argument_list|(
literal|"Parent of "
operator|+
name|ordinal
operator|+
literal|" is "
operator|+
name|parentOrdinal
operator|+
literal|", but this is not a valid category."
argument_list|)
expr_stmt|;
block|}
comment|// verify that the parent is indeed my parent, according to the strings
if|if
condition|(
operator|!
operator|new
name|CategoryPath
argument_list|(
name|me
argument_list|,
name|me
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|equals
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|fail
argument_list|(
literal|"Got parent "
operator|+
name|parentOrdinal
operator|+
literal|" for ordinal "
operator|+
name|ordinal
operator|+
literal|" but categories are "
operator|+
name|showcat
argument_list|(
name|parent
argument_list|)
operator|+
literal|" and "
operator|+
name|showcat
argument_list|(
name|me
argument_list|)
operator|+
literal|" respectively."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check parent of of invalid ordinals:
try|try
block|{
name|tr
operator|.
name|getParent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"getParent for -1 should throw exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// ok
block|}
try|try
block|{
name|tr
operator|.
name|getParent
argument_list|(
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"getParent for INVALID_ORDINAL should throw exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// ok
block|}
try|try
block|{
name|int
name|parent
init|=
name|tr
operator|.
name|getParent
argument_list|(
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"getParent for getSize() should throw exception, but returned "
operator|+
name|parent
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// ok
block|}
name|tr
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Tests for TaxonomyWriter's getParent() method. We check it by comparing    * its results to those we could have gotten by looking at the category    * string paths using a TaxonomyReader (where the parentage is obvious).    * Note that after testReaderBasic(), we already know we can trust the    * ordinal<=> category conversions from TaxonomyReader.    *    * The difference between testWriterParent1 and testWriterParent2 is that    * the former closes the taxonomy writer before reopening it, while the    * latter does not.    *     * This test code is virtually identical to that of testReaderParent().    */
annotation|@
name|Test
DECL|method|testWriterParent1
specifier|public
name|void
name|testWriterParent1
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|tw
operator|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
expr_stmt|;
name|TaxonomyReader
name|tr
init|=
operator|new
name|DirectoryTaxonomyReader
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|checkWriterParent
argument_list|(
name|tr
argument_list|,
name|tw
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|tr
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testWriterParent2
specifier|public
name|void
name|testWriterParent2
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|tw
operator|.
name|commit
argument_list|()
expr_stmt|;
name|TaxonomyReader
name|tr
init|=
operator|new
name|DirectoryTaxonomyReader
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|checkWriterParent
argument_list|(
name|tr
argument_list|,
name|tw
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|tr
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|checkWriterParent
specifier|private
name|void
name|checkWriterParent
parameter_list|(
name|TaxonomyReader
name|tr
parameter_list|,
name|TaxonomyWriter
name|tw
parameter_list|)
throws|throws
name|Exception
block|{
comment|// check that the parent of the root ordinal is the invalid ordinal:
name|assertEquals
argument_list|(
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|,
name|tw
operator|.
name|getParent
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// check parent of non-root ordinals:
for|for
control|(
name|int
name|ordinal
init|=
literal|1
init|;
name|ordinal
operator|<
name|tr
operator|.
name|getSize
argument_list|()
condition|;
name|ordinal
operator|++
control|)
block|{
name|CategoryPath
name|me
init|=
name|tr
operator|.
name|getPath
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
name|int
name|parentOrdinal
init|=
name|tw
operator|.
name|getParent
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
name|CategoryPath
name|parent
init|=
name|tr
operator|.
name|getPath
argument_list|(
name|parentOrdinal
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
name|fail
argument_list|(
literal|"Parent of "
operator|+
name|ordinal
operator|+
literal|" is "
operator|+
name|parentOrdinal
operator|+
literal|", but this is not a valid category."
argument_list|)
expr_stmt|;
block|}
comment|// verify that the parent is indeed my parent, according to the
comment|// strings
if|if
condition|(
operator|!
operator|new
name|CategoryPath
argument_list|(
name|me
argument_list|,
name|me
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|equals
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|fail
argument_list|(
literal|"Got parent "
operator|+
name|parentOrdinal
operator|+
literal|" for ordinal "
operator|+
name|ordinal
operator|+
literal|" but categories are "
operator|+
name|showcat
argument_list|(
name|parent
argument_list|)
operator|+
literal|" and "
operator|+
name|showcat
argument_list|(
name|me
argument_list|)
operator|+
literal|" respectively."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check parent of of invalid ordinals:
try|try
block|{
name|tw
operator|.
name|getParent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"getParent for -1 should throw exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// ok
block|}
try|try
block|{
name|tw
operator|.
name|getParent
argument_list|(
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"getParent for INVALID_ORDINAL should throw exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// ok
block|}
try|try
block|{
name|int
name|parent
init|=
name|tw
operator|.
name|getParent
argument_list|(
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"getParent for getSize() should throw exception, but returned "
operator|+
name|parent
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// ok
block|}
block|}
comment|/**  Tests TaxonomyReader's getParentArray() method. We do not test this     method directly, but rather just compare its results to those from     other methods (which we have already tested above).    */
annotation|@
name|Test
DECL|method|testReaderParentArray
specifier|public
name|void
name|testReaderParentArray
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|TaxonomyReader
name|tr
init|=
operator|new
name|DirectoryTaxonomyReader
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|int
index|[]
name|parents
init|=
name|tr
operator|.
name|getParentArray
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|tr
operator|.
name|getSize
argument_list|()
argument_list|,
name|parents
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tr
operator|.
name|getSize
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|tr
operator|.
name|getParent
argument_list|(
name|i
argument_list|)
argument_list|,
name|parents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|tr
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Test TaxonomyReader's child browsing method, getChildrenArrays()    * This only tests for correctness of the data on one example - we have    * below further tests on data refresh etc.    */
annotation|@
name|Test
DECL|method|testChildrenArrays
specifier|public
name|void
name|testChildrenArrays
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|TaxonomyReader
name|tr
init|=
operator|new
name|DirectoryTaxonomyReader
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|ChildrenArrays
name|ca
init|=
name|tr
operator|.
name|getChildrenArrays
argument_list|()
decl_stmt|;
name|int
index|[]
name|youngestChildArray
init|=
name|ca
operator|.
name|getYoungestChildArray
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|tr
operator|.
name|getSize
argument_list|()
argument_list|,
name|youngestChildArray
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
index|[]
name|olderSiblingArray
init|=
name|ca
operator|.
name|getOlderSiblingArray
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|tr
operator|.
name|getSize
argument_list|()
argument_list|,
name|olderSiblingArray
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expectedCategories
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// find expected children by looking at all expectedCategories
comment|// for children
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|expectedChildren
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|expectedCategories
operator|.
name|length
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|expectedCategories
index|[
name|j
index|]
operator|.
name|length
operator|!=
name|expectedCategories
index|[
name|i
index|]
operator|.
name|length
operator|+
literal|1
condition|)
block|{
continue|continue;
comment|// not longer by 1, so can't be a child
block|}
name|boolean
name|ischild
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|expectedCategories
index|[
name|i
index|]
operator|.
name|length
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|expectedCategories
index|[
name|j
index|]
index|[
name|k
index|]
operator|.
name|equals
argument_list|(
name|expectedCategories
index|[
name|i
index|]
index|[
name|k
index|]
argument_list|)
condition|)
block|{
name|ischild
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ischild
condition|)
block|{
name|expectedChildren
operator|.
name|add
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check that children and expectedChildren are the same, with the
comment|// correct reverse (youngest to oldest) order:
if|if
condition|(
name|expectedChildren
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|assertEquals
argument_list|(
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|,
name|youngestChildArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|child
init|=
name|youngestChildArray
index|[
name|i
index|]
decl_stmt|;
name|assertEquals
argument_list|(
name|expectedChildren
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|expectedChildren
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|child
operator|=
name|olderSiblingArray
index|[
name|child
index|]
expr_stmt|;
name|assertEquals
argument_list|(
name|expectedChildren
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
comment|// if child is INVALID_ORDINAL we should stop, but
comment|// assertEquals would fail in this case anyway.
block|}
comment|// When we're done comparing, olderSiblingArray should now point
comment|// to INVALID_ORDINAL, saying there are no more children. If it
comment|// doesn't, we found too many children...
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|olderSiblingArray
index|[
name|child
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|tr
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Similar to testChildrenArrays, except rather than look at    * expected results, we test for several "invariants" that the results    * should uphold, e.g., that a child of a category indeed has this category    * as its parent. This sort of test can more easily be extended to larger    * example taxonomies, because we do not need to build the expected list    * of categories like we did in the above test.    */
annotation|@
name|Test
DECL|method|testChildrenArraysInvariants
specifier|public
name|void
name|testChildrenArraysInvariants
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|TaxonomyReader
name|tr
init|=
operator|new
name|DirectoryTaxonomyReader
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|ChildrenArrays
name|ca
init|=
name|tr
operator|.
name|getChildrenArrays
argument_list|()
decl_stmt|;
name|int
index|[]
name|youngestChildArray
init|=
name|ca
operator|.
name|getYoungestChildArray
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|tr
operator|.
name|getSize
argument_list|()
argument_list|,
name|youngestChildArray
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
index|[]
name|olderSiblingArray
init|=
name|ca
operator|.
name|getOlderSiblingArray
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|tr
operator|.
name|getSize
argument_list|()
argument_list|,
name|olderSiblingArray
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// test that the "youngest child" of every category is indeed a child:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tr
operator|.
name|getSize
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|youngestChild
init|=
name|youngestChildArray
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|youngestChild
operator|!=
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
condition|)
block|{
name|assertEquals
argument_list|(
name|i
argument_list|,
name|tr
operator|.
name|getParent
argument_list|(
name|youngestChild
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// test that the "older sibling" of every category is indeed older (lower)
comment|// (it can also be INVALID_ORDINAL, which is lower than any ordinal)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tr
operator|.
name|getSize
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|assertTrue
argument_list|(
literal|"olderSiblingArray["
operator|+
name|i
operator|+
literal|"] should be<"
operator|+
name|i
argument_list|,
name|olderSiblingArray
index|[
name|i
index|]
operator|<
name|i
argument_list|)
expr_stmt|;
block|}
comment|// test that the "older sibling" of every category is indeed a sibling
comment|// (they share the same parent)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tr
operator|.
name|getSize
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|sibling
init|=
name|olderSiblingArray
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|sibling
operator|==
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
condition|)
block|{
continue|continue;
block|}
name|assertEquals
argument_list|(
name|tr
operator|.
name|getParent
argument_list|(
name|i
argument_list|)
argument_list|,
name|tr
operator|.
name|getParent
argument_list|(
name|sibling
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// And now for slightly more complex (and less "invariant-like"...)
comment|// tests:
comment|// test that the "youngest child" is indeed the youngest (so we don't
comment|// miss the first children in the chain)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tr
operator|.
name|getSize
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// Find the really youngest child:
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|tr
operator|.
name|getSize
argument_list|()
operator|-
literal|1
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|tr
operator|.
name|getParent
argument_list|(
name|j
argument_list|)
operator|==
name|i
condition|)
block|{
break|break;
comment|// found youngest child
block|}
block|}
if|if
condition|(
name|j
operator|==
name|i
condition|)
block|{
comment|// no child found
name|j
operator|=
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|j
argument_list|,
name|youngestChildArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// test that the "older sibling" is indeed the least oldest one - and
comment|// not a too old one or -1 (so we didn't miss some children in the
comment|// middle or the end of the chain).
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tr
operator|.
name|getSize
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// Find the youngest older sibling:
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|tr
operator|.
name|getParent
argument_list|(
name|j
argument_list|)
operator|==
name|tr
operator|.
name|getParent
argument_list|(
name|i
argument_list|)
condition|)
block|{
break|break;
comment|// found youngest older sibling
block|}
block|}
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
comment|// no sibling found
name|j
operator|=
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|j
argument_list|,
name|olderSiblingArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|tr
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Test how getChildrenArrays() deals with the taxonomy's growth:    */
annotation|@
name|Test
DECL|method|testChildrenArraysGrowth
specifier|public
name|void
name|testChildrenArraysGrowth
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"hi"
argument_list|,
literal|"there"
argument_list|)
argument_list|)
expr_stmt|;
name|tw
operator|.
name|commit
argument_list|()
expr_stmt|;
name|TaxonomyReader
name|tr
init|=
operator|new
name|DirectoryTaxonomyReader
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|ChildrenArrays
name|ca
init|=
name|tr
operator|.
name|getChildrenArrays
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|ca
operator|.
name|getOlderSiblingArray
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|ca
operator|.
name|getYoungestChildArray
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|}
argument_list|,
name|ca
operator|.
name|getYoungestChildArray
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
operator|new
name|int
index|[]
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
argument_list|,
name|ca
operator|.
name|getOlderSiblingArray
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"hi"
argument_list|,
literal|"ho"
argument_list|)
argument_list|)
expr_stmt|;
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"hello"
argument_list|)
argument_list|)
expr_stmt|;
name|tw
operator|.
name|commit
argument_list|()
expr_stmt|;
comment|// Before refresh, nothing changed..
name|ChildrenArrays
name|newca
init|=
name|tr
operator|.
name|getChildrenArrays
argument_list|()
decl_stmt|;
name|assertSame
argument_list|(
name|newca
argument_list|,
name|ca
argument_list|)
expr_stmt|;
comment|// we got exactly the same object
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|ca
operator|.
name|getOlderSiblingArray
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|ca
operator|.
name|getYoungestChildArray
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// After the refresh, things change:
name|tr
operator|.
name|refresh
argument_list|()
expr_stmt|;
name|ca
operator|=
name|tr
operator|.
name|getChildrenArrays
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|ca
operator|.
name|getOlderSiblingArray
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|ca
operator|.
name|getYoungestChildArray
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
operator|new
name|int
index|[]
block|{
literal|4
block|,
literal|3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
argument_list|,
name|ca
operator|.
name|getYoungestChildArray
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
operator|new
name|int
index|[]
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|2
block|,
literal|1
block|}
argument_list|,
name|ca
operator|.
name|getOlderSiblingArray
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|tr
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Test that getParentArrays is valid when retrieved during refresh    */
annotation|@
name|Test
annotation|@
name|Ignore
DECL|method|testTaxonomyReaderRefreshRaces
specifier|public
name|void
name|testTaxonomyReaderRefreshRaces
parameter_list|()
throws|throws
name|Exception
block|{
comment|// compute base child arrays - after first chunk, and after the other
name|Directory
name|indexDirBase
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|twBase
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDirBase
argument_list|)
decl_stmt|;
name|twBase
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"a"
argument_list|,
literal|"0"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|CategoryPath
name|abPath
init|=
operator|new
name|CategoryPath
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|twBase
operator|.
name|addCategory
argument_list|(
name|abPath
argument_list|)
expr_stmt|;
name|twBase
operator|.
name|commit
argument_list|()
expr_stmt|;
name|TaxonomyReader
name|trBase
init|=
operator|new
name|DirectoryTaxonomyReader
argument_list|(
name|indexDirBase
argument_list|)
decl_stmt|;
specifier|final
name|ChildrenArrays
name|ca1
init|=
name|trBase
operator|.
name|getChildrenArrays
argument_list|()
decl_stmt|;
specifier|final
name|int
name|abOrd
init|=
name|trBase
operator|.
name|getOrdinal
argument_list|(
name|abPath
argument_list|)
decl_stmt|;
specifier|final
name|int
name|abYoungChildBase1
init|=
name|ca1
operator|.
name|getYoungestChildArray
argument_list|()
index|[
name|abOrd
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|1
operator|<<
literal|10
condition|;
name|i
operator|++
control|)
block|{
comment|//1024 facets
name|twBase
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|twBase
operator|.
name|commit
argument_list|()
expr_stmt|;
name|trBase
operator|.
name|refresh
argument_list|()
expr_stmt|;
specifier|final
name|ChildrenArrays
name|ca2
init|=
name|trBase
operator|.
name|getChildrenArrays
argument_list|()
decl_stmt|;
specifier|final
name|int
name|abYoungChildBase2
init|=
name|ca2
operator|.
name|getYoungestChildArray
argument_list|()
index|[
name|abOrd
index|]
decl_stmt|;
for|for
control|(
name|int
name|retry
init|=
literal|0
init|;
name|retry
operator|<
literal|100
condition|;
name|retry
operator|++
control|)
block|{
name|assertConsistentYoungestChild
argument_list|(
name|abPath
argument_list|,
name|abOrd
argument_list|,
name|abYoungChildBase1
argument_list|,
name|abYoungChildBase2
argument_list|,
name|retry
argument_list|)
expr_stmt|;
block|}
name|indexDirBase
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|assertConsistentYoungestChild
specifier|private
name|void
name|assertConsistentYoungestChild
parameter_list|(
specifier|final
name|CategoryPath
name|abPath
parameter_list|,
specifier|final
name|int
name|abOrd
parameter_list|,
specifier|final
name|int
name|abYoungChildBase1
parameter_list|,
specifier|final
name|int
name|abYoungChildBase2
parameter_list|,
specifier|final
name|int
name|retry
parameter_list|)
throws|throws
name|Exception
block|{
name|SlowRAMDirectory
name|indexDir
init|=
operator|new
name|SlowRAMDirectory
argument_list|(
operator|-
literal|1
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// no slowness for intialization
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"a"
argument_list|,
literal|"0"
argument_list|)
argument_list|)
expr_stmt|;
name|tw
operator|.
name|addCategory
argument_list|(
name|abPath
argument_list|)
expr_stmt|;
name|tw
operator|.
name|commit
argument_list|()
expr_stmt|;
specifier|final
name|TaxonomyReader
name|tr
init|=
operator|new
name|DirectoryTaxonomyReader
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|1
operator|<<
literal|10
condition|;
name|i
operator|++
control|)
block|{
comment|//1024 facets
specifier|final
name|CategoryPath
name|cp
init|=
operator|new
name|CategoryPath
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tw
operator|.
name|addCategory
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Ordinal of "
operator|+
name|cp
operator|+
literal|" must be invalid until Taxonomy Reader was refreshed"
argument_list|,
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|,
name|tr
operator|.
name|getOrdinal
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tw
operator|.
name|commit
argument_list|()
expr_stmt|;
specifier|final
name|boolean
index|[]
name|stop
init|=
operator|new
name|boolean
index|[]
block|{
literal|false
block|}
decl_stmt|;
specifier|final
name|Throwable
index|[]
name|error
init|=
operator|new
name|Throwable
index|[]
block|{
literal|null
block|}
decl_stmt|;
specifier|final
name|int
name|retrieval
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|Thread
name|thread
init|=
operator|new
name|Thread
argument_list|(
literal|"Child Arrays Verifier"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|setPriority
argument_list|(
literal|1
operator|+
name|getPriority
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|stop
index|[
literal|0
index|]
condition|)
block|{
name|int
name|lastOrd
init|=
name|tr
operator|.
name|getParentArray
argument_list|()
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"path of last-ord "
operator|+
name|lastOrd
operator|+
literal|" is not found!"
argument_list|,
name|tr
operator|.
name|getPath
argument_list|(
name|lastOrd
argument_list|)
argument_list|)
expr_stmt|;
name|assertChildrenArrays
argument_list|(
name|tr
operator|.
name|getChildrenArrays
argument_list|()
argument_list|,
name|retry
argument_list|,
name|retrieval
index|[
literal|0
index|]
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|error
index|[
literal|0
index|]
operator|=
name|e
expr_stmt|;
name|stop
index|[
literal|0
index|]
operator|=
literal|true
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|assertChildrenArrays
parameter_list|(
name|ChildrenArrays
name|ca
parameter_list|,
name|int
name|retry
parameter_list|,
name|int
name|retrieval
parameter_list|)
block|{
specifier|final
name|int
name|abYoungChild
init|=
name|ca
operator|.
name|getYoungestChildArray
argument_list|()
index|[
name|abOrd
index|]
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Retry "
operator|+
name|retry
operator|+
literal|": retrieval: "
operator|+
name|retrieval
operator|+
literal|": wrong youngest child for category "
operator|+
name|abPath
operator|+
literal|" (ord="
operator|+
name|abOrd
operator|+
literal|") - must be either "
operator|+
name|abYoungChildBase1
operator|+
literal|" or "
operator|+
name|abYoungChildBase2
operator|+
literal|" but was: "
operator|+
name|abYoungChild
argument_list|,
name|abYoungChildBase1
operator|==
name|abYoungChild
operator|||
name|abYoungChildBase2
operator|==
name|ca
operator|.
name|getYoungestChildArray
argument_list|()
index|[
name|abOrd
index|]
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|setSleepMillis
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// some delay for refresh
name|tr
operator|.
name|refresh
argument_list|()
expr_stmt|;
name|stop
index|[
literal|0
index|]
operator|=
literal|true
expr_stmt|;
name|thread
operator|.
name|join
argument_list|()
expr_stmt|;
name|assertNull
argument_list|(
literal|"Unexpcted exception at retry "
operator|+
name|retry
operator|+
literal|" retrieval "
operator|+
name|retrieval
index|[
literal|0
index|]
operator|+
literal|": \n"
operator|+
name|stackTraceStr
argument_list|(
name|error
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|error
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|tr
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Grab the stack trace into a string since the exception was thrown in a thread and we want the assert     * outside the thread to show the stack trace in case of failure.   */
DECL|method|stackTraceStr
specifier|private
name|String
name|stackTraceStr
parameter_list|(
specifier|final
name|Throwable
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|error
operator|.
name|printStackTrace
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**  Test that if separate reader and writer objects are opened, new     categories written into the writer are available to a reader only     after a commit().     Note that this test obviously doesn't cover all the different     concurrency scenarios, all different methods, and so on. We may     want to write more tests of this sort.      This test simulates what would happen when there are two separate     processes, one doing indexing, and the other searching, and each opens     its own object (with obviously no connection between the objects) using     the same disk files. Note, though, that this test does not test what     happens when the two processes do their actual work at exactly the same     time.     It also doesn't test multi-threading.    */
annotation|@
name|Test
DECL|method|testSeparateReaderAndWriter
specifier|public
name|void
name|testSeparateReaderAndWriter
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|tw
operator|.
name|commit
argument_list|()
expr_stmt|;
name|TaxonomyReader
name|tr
init|=
operator|new
name|DirectoryTaxonomyReader
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|int
name|author
init|=
literal|1
decl_stmt|;
comment|// getParent() and getSize() test:
try|try
block|{
name|tr
operator|.
name|getParent
argument_list|(
name|author
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Initially, getParent for "
operator|+
name|author
operator|+
literal|" should throw exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// ok
block|}
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// the empty taxonomy has size 1 (the root)
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"Author"
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|tr
operator|.
name|getParent
argument_list|(
name|author
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Before commit() and refresh(), getParent for "
operator|+
name|author
operator|+
literal|" should still throw exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// ok
block|}
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// still root only...
name|tr
operator|.
name|refresh
argument_list|()
expr_stmt|;
comment|// this is not enough, because tw.commit() hasn't been done yet
try|try
block|{
name|tr
operator|.
name|getParent
argument_list|(
name|author
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Before commit() and refresh(), getParent for "
operator|+
name|author
operator|+
literal|" should still throw exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// ok
block|}
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// still root only...
name|tw
operator|.
name|commit
argument_list|()
expr_stmt|;
try|try
block|{
name|tr
operator|.
name|getParent
argument_list|(
name|author
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Before refresh(), getParent for "
operator|+
name|author
operator|+
literal|" should still throw exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// ok
block|}
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// still root only...
name|tr
operator|.
name|refresh
argument_list|()
expr_stmt|;
try|try
block|{
name|assertEquals
argument_list|(
name|TaxonomyReader
operator|.
name|ROOT_ORDINAL
argument_list|,
name|tr
operator|.
name|getParent
argument_list|(
name|author
argument_list|)
argument_list|)
expr_stmt|;
comment|// ok
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
name|fail
argument_list|(
literal|"After category addition, commit() and refresh(), getParent for "
operator|+
name|author
operator|+
literal|" should NOT throw exception"
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// finally, see there are two categories
comment|// now, add another category, and verify that after commit and refresh
comment|// the parent of this category is correct (this requires the reader
comment|// to correctly update its prefetched parent vector), and that the
comment|// old information also wasn't ruined:
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"Author"
argument_list|,
literal|"Richard Dawkins"
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|dawkins
init|=
literal|2
decl_stmt|;
name|tw
operator|.
name|commit
argument_list|()
expr_stmt|;
name|tr
operator|.
name|refresh
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|author
argument_list|,
name|tr
operator|.
name|getParent
argument_list|(
name|dawkins
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|TaxonomyReader
operator|.
name|ROOT_ORDINAL
argument_list|,
name|tr
operator|.
name|getParent
argument_list|(
name|author
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|,
name|tr
operator|.
name|getParent
argument_list|(
name|TaxonomyReader
operator|.
name|ROOT_ORDINAL
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|tr
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSeparateReaderAndWriter2
specifier|public
name|void
name|testSeparateReaderAndWriter2
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|tw
operator|.
name|commit
argument_list|()
expr_stmt|;
name|TaxonomyReader
name|tr
init|=
operator|new
name|DirectoryTaxonomyReader
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
comment|// Test getOrdinal():
name|CategoryPath
name|author
init|=
operator|new
name|CategoryPath
argument_list|(
literal|"Author"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// the empty taxonomy has size 1 (the root)
name|assertEquals
argument_list|(
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|,
name|tr
operator|.
name|getOrdinal
argument_list|(
name|author
argument_list|)
argument_list|)
expr_stmt|;
name|tw
operator|.
name|addCategory
argument_list|(
name|author
argument_list|)
expr_stmt|;
comment|// before commit and refresh, no change:
name|assertEquals
argument_list|(
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|,
name|tr
operator|.
name|getOrdinal
argument_list|(
name|author
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// still root only...
name|tr
operator|.
name|refresh
argument_list|()
expr_stmt|;
comment|// this is not enough, because tw.commit() hasn't been done yet
name|assertEquals
argument_list|(
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|,
name|tr
operator|.
name|getOrdinal
argument_list|(
name|author
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// still root only...
name|tw
operator|.
name|commit
argument_list|()
expr_stmt|;
comment|// still not enough before refresh:
name|assertEquals
argument_list|(
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|,
name|tr
operator|.
name|getOrdinal
argument_list|(
name|author
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// still root only...
name|tr
operator|.
name|refresh
argument_list|()
expr_stmt|;
comment|// finally
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|tr
operator|.
name|getOrdinal
argument_list|(
name|author
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|tr
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// still root only...
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|tr
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Test what happens if we try to write to a locked taxonomy writer,    * and see that we can unlock it and continue.    */
annotation|@
name|Test
DECL|method|testWriterLock
specifier|public
name|void
name|testWriterLock
parameter_list|()
throws|throws
name|Exception
block|{
comment|// native fslock impl gets angry if we use it, so use RAMDirectory explicitly.
name|Directory
name|indexDir
init|=
operator|new
name|RAMDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"hi"
argument_list|,
literal|"there"
argument_list|)
argument_list|)
expr_stmt|;
name|tw
operator|.
name|commit
argument_list|()
expr_stmt|;
comment|// we deliberately not close the write now, and keep it open and
comment|// locked.
comment|// Verify that the writer worked:
name|TaxonomyReader
name|tr
init|=
operator|new
name|DirectoryTaxonomyReader
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|tr
operator|.
name|getOrdinal
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"hi"
argument_list|,
literal|"there"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Try to open a second writer, with the first one locking the directory.
comment|// We expect to get a LockObtainFailedException.
try|try
block|{
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"should have failed to write in locked directory"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockObtainFailedException
name|e
parameter_list|)
block|{
comment|// this is what we expect to happen.
block|}
comment|// Remove the lock, and now the open should succeed, and we can
comment|// write to the new writer.
name|DirectoryTaxonomyWriter
operator|.
name|unlock
argument_list|(
name|indexDir
argument_list|)
expr_stmt|;
name|TaxonomyWriter
name|tw2
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|tw2
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"hey"
argument_list|)
argument_list|)
expr_stmt|;
name|tw2
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// See that the writer indeed wrote:
name|tr
operator|.
name|refresh
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|tr
operator|.
name|getOrdinal
argument_list|(
operator|new
name|CategoryPath
argument_list|(
literal|"hey"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tr
operator|.
name|close
argument_list|()
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * fillTaxonomyCheckPaths adds the categories in the categories[] array,    * and asserts that the additions return exactly paths specified in    * expectedPaths[]. This is the same add fillTaxonomy() but also checks    * the correctness of getParent(), not just addCategory().    * Note that this assumes that fillTaxonomyCheckPaths() is called on an empty    * taxonomy index. Calling it after something else was already added to the    * taxonomy index will surely have this method fail.    */
DECL|method|fillTaxonomyCheckPaths
specifier|public
specifier|static
name|void
name|fillTaxonomyCheckPaths
parameter_list|(
name|TaxonomyWriter
name|tw
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|categories
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ordinal
init|=
name|tw
operator|.
name|addCategory
argument_list|(
operator|new
name|CategoryPath
argument_list|(
name|categories
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|expectedOrdinal
init|=
name|expectedPaths
index|[
name|i
index|]
index|[
name|expectedPaths
index|[
name|i
index|]
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|ordinal
operator|!=
name|expectedOrdinal
condition|)
block|{
name|fail
argument_list|(
literal|"For category "
operator|+
name|showcat
argument_list|(
name|categories
index|[
name|i
index|]
argument_list|)
operator|+
literal|" expected ordinal "
operator|+
name|expectedOrdinal
operator|+
literal|", but got "
operator|+
name|ordinal
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
name|expectedPaths
index|[
name|i
index|]
operator|.
name|length
operator|-
literal|2
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|ordinal
operator|=
name|tw
operator|.
name|getParent
argument_list|(
name|ordinal
argument_list|)
expr_stmt|;
name|expectedOrdinal
operator|=
name|expectedPaths
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|ordinal
operator|!=
name|expectedOrdinal
condition|)
block|{
name|fail
argument_list|(
literal|"For category "
operator|+
name|showcat
argument_list|(
name|categories
index|[
name|i
index|]
argument_list|)
operator|+
literal|" expected ancestor level "
operator|+
operator|(
name|expectedPaths
index|[
name|i
index|]
operator|.
name|length
operator|-
literal|1
operator|-
name|j
operator|)
operator|+
literal|" was "
operator|+
name|expectedOrdinal
operator|+
literal|", but got "
operator|+
name|ordinal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// After fillTaxonomy returned successfully, checkPaths() checks that
comment|// the getParent() calls return as expected, from the table
DECL|method|checkPaths
specifier|public
specifier|static
name|void
name|checkPaths
parameter_list|(
name|TaxonomyWriter
name|tw
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|categories
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ordinal
init|=
name|expectedPaths
index|[
name|i
index|]
index|[
name|expectedPaths
index|[
name|i
index|]
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|expectedPaths
index|[
name|i
index|]
operator|.
name|length
operator|-
literal|2
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|ordinal
operator|=
name|tw
operator|.
name|getParent
argument_list|(
name|ordinal
argument_list|)
expr_stmt|;
name|int
name|expectedOrdinal
init|=
name|expectedPaths
index|[
name|i
index|]
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|ordinal
operator|!=
name|expectedOrdinal
condition|)
block|{
name|fail
argument_list|(
literal|"For category "
operator|+
name|showcat
argument_list|(
name|categories
index|[
name|i
index|]
argument_list|)
operator|+
literal|" expected ancestor level "
operator|+
operator|(
name|expectedPaths
index|[
name|i
index|]
operator|.
name|length
operator|-
literal|1
operator|-
name|j
operator|)
operator|+
literal|" was "
operator|+
name|expectedOrdinal
operator|+
literal|", but got "
operator|+
name|ordinal
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
name|TaxonomyReader
operator|.
name|ROOT_ORDINAL
argument_list|,
name|tw
operator|.
name|getParent
argument_list|(
name|expectedPaths
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
argument_list|,
name|tw
operator|.
name|getParent
argument_list|(
name|TaxonomyReader
operator|.
name|ROOT_ORDINAL
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Basic test for TaxonomyWriter.getParent(). This is similar to testWriter    * above, except we also check the parents of the added categories, not just    * the categories themselves.    */
annotation|@
name|Test
DECL|method|testWriterCheckPaths
specifier|public
name|void
name|testWriterCheckPaths
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|fillTaxonomyCheckPaths
argument_list|(
name|tw
argument_list|)
expr_stmt|;
comment|// Also check TaxonomyWriter.getSize() - see that the taxonomy's size
comment|// is what we expect it to be.
name|assertEquals
argument_list|(
name|expectedCategories
operator|.
name|length
argument_list|,
name|tw
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * testWriterCheckPaths2 is the path-checking variant of testWriterTwice    * and testWriterTwice2. After adding all the categories, we add them again,    * and see that we get the same old ids and paths. We repeat the path checking    * yet again after closing and opening the index for writing again - to see    * that the reading of existing data from disk works as well.    */
annotation|@
name|Test
DECL|method|testWriterCheckPaths2
specifier|public
name|void
name|testWriterCheckPaths2
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|indexDir
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|TaxonomyWriter
name|tw
init|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
decl_stmt|;
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|checkPaths
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|checkPaths
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|tw
operator|=
operator|new
name|DirectoryTaxonomyWriter
argument_list|(
name|indexDir
argument_list|)
expr_stmt|;
name|checkPaths
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|fillTaxonomy
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|checkPaths
argument_list|(
name|tw
argument_list|)
expr_stmt|;
name|tw
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexDir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|//  TODO (Facet): test multiple readers, one writer. Have the multiple readers
comment|//  using the same object (simulating threads) or different objects
comment|//  (simulating processes).
block|}
end_class
end_unit
