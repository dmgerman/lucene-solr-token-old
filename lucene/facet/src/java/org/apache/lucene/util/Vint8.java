begin_unit
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  * Variable-length encoding of 32-bit integers, into 8-bit bytes. A number is encoded as follows:  *<ul>  *<li>If it is less than 127 and non-negative (i.e., if the number uses only 7 bits), it is encoded as   *  as single byte: 0bbbbbbb.  *<li>If its highest nonzero bit is greater than bit 6 (0x40), it is represented as a series of  * bytes, each byte's  * 7 LSB containing bits from the original value, with the MSB set for all but the last  * byte. The first encoded byte contains the highest nonzero bits from the  * original; the second byte contains the next 7 MSB; and so on, with the last byte  * containing the 7 LSB of the original.  *</ul>  * Examples:   *<ol>  *<li>n = 117 = 1110101: This has fewer than 8 significant bits, and so is encoded as  *   01110101 = 0x75.  *<li>n = 100000 = (binary) 11000011010100000. This has 17 significant bits, and so needs   *   three Vint8 bytes. Left-zero-pad it to a multiple of 7 bits, then split it into chunks of 7   *   and add an MSB, 0 for the last byte, 1 for the others: 1|0000110 1|0001101 0|0100000  *   = 0x86 0x8D 0x20.  *</ol>     * This encoder/decoder will correctly handle any 32-bit integer, but for negative numbers,  * and positive numbers with more than 28 significant bits, encoding requires 5 bytes; this  * is not an efficient encoding scheme for large  * positive numbers or any negative number.  *<p>  *<b>Compatibility:</b><br>  * This class has been used in products that have shipped to customers, and is needed to  * decode legacy data. Do not modify this class in ways that will break compatibility.  *   * @lucene.experimental  */
end_comment
begin_class
DECL|class|Vint8
specifier|public
class|class
name|Vint8
block|{
comment|/**    * Because Java lacks call-by-reference, this class boxes the decoding position, which    * is initially set by the caller, and returned after decoding, incremented by the number    * of bytes processed.    */
DECL|class|Position
specifier|public
specifier|static
class|class
name|Position
block|{
comment|/**      * Creates a position value set to zero.      */
DECL|method|Position
specifier|public
name|Position
parameter_list|()
block|{
comment|// The initial position is zero by default.
block|}
comment|/**      * Creates a position set to {@code initialPosition}.      * @param initialPosition The starting decoding position in the source buffer.      */
DECL|method|Position
specifier|public
name|Position
parameter_list|(
name|int
name|initialPosition
parameter_list|)
block|{
name|this
operator|.
name|pos
operator|=
name|initialPosition
expr_stmt|;
block|}
comment|/**      * The value passed by reference.      */
DECL|field|pos
specifier|public
name|int
name|pos
decl_stmt|;
block|}
comment|/**    * Returns the number of bytes needed to encode {@code number}.    * @param number The number whose encoded length is needed.    * @return The number of bytes needed to encode {@code number}.    */
DECL|method|bytesNeeded
specifier|public
specifier|static
name|int
name|bytesNeeded
parameter_list|(
name|int
name|number
parameter_list|)
block|{
if|if
condition|(
operator|(
name|number
operator|&
operator|~
literal|0x7F
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|number
operator|&
operator|~
literal|0x3FFF
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|2
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|number
operator|&
operator|~
literal|0x1FFFFF
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|3
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|number
operator|&
operator|~
literal|0xFFFFFFF
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|4
return|;
block|}
else|else
block|{
return|return
literal|5
return|;
block|}
block|}
comment|/**    * The maximum number of bytes needed to encode a number using {@code Vint8}.    */
DECL|field|MAXIMUM_BYTES_NEEDED
specifier|public
specifier|static
specifier|final
name|int
name|MAXIMUM_BYTES_NEEDED
init|=
literal|5
decl_stmt|;
comment|/**    * Encodes {@code number} to {@code out}.    * @param number The value to be written in encoded form, to {@code out}.    * @param out The output stream receiving the encoded bytes.    * @exception IOException If there is a problem writing to {@code out}.    */
DECL|method|encode
specifier|public
specifier|static
name|void
name|encode
parameter_list|(
name|int
name|number
parameter_list|,
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|number
operator|&
operator|~
literal|0x7F
operator|)
operator|==
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|number
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|number
operator|&
operator|~
literal|0x3FFF
operator|)
operator|==
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
literal|0x80
operator||
operator|(
name|number
operator|>>
literal|7
operator|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|0x7F
operator|&
name|number
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|number
operator|&
operator|~
literal|0x1FFFFF
operator|)
operator|==
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
literal|0x80
operator||
operator|(
name|number
operator|>>
literal|14
operator|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|0x80
operator||
operator|(
name|number
operator|>>
literal|7
operator|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|0x7F
operator|&
name|number
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|number
operator|&
operator|~
literal|0xFFFFFFF
operator|)
operator|==
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
literal|0x80
operator||
operator|(
name|number
operator|>>
literal|21
operator|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|0x80
operator||
operator|(
name|number
operator|>>
literal|14
operator|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|0x80
operator||
operator|(
name|number
operator|>>
literal|7
operator|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|0x7F
operator|&
name|number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|write
argument_list|(
literal|0x80
operator||
operator|(
name|number
operator|>>
literal|28
operator|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|0x80
operator||
operator|(
name|number
operator|>>
literal|21
operator|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|0x80
operator||
operator|(
name|number
operator|>>
literal|14
operator|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|0x80
operator||
operator|(
name|number
operator|>>
literal|7
operator|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|0x7F
operator|&
name|number
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Encodes {@code number} into {@code dest}, starting at offset {@code start} from    * the beginning of the array. This method assumes {@code dest} is large enough to    * hold the required number of bytes.    * @param number The number to be encoded.    * @param dest The destination array.    * @param start The starting offset in the array.    * @return The number of bytes used in the array.    */
DECL|method|encode
specifier|public
specifier|static
name|int
name|encode
parameter_list|(
name|int
name|number
parameter_list|,
name|byte
index|[]
name|dest
parameter_list|,
name|int
name|start
parameter_list|)
block|{
if|if
condition|(
operator|(
name|number
operator|&
operator|~
literal|0x7F
operator|)
operator|==
literal|0
condition|)
block|{
name|dest
index|[
name|start
index|]
operator|=
operator|(
name|byte
operator|)
name|number
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|number
operator|&
operator|~
literal|0x3FFF
operator|)
operator|==
literal|0
condition|)
block|{
name|dest
index|[
name|start
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|number
operator|&
literal|0x3F80
operator|)
operator|>>
literal|7
operator|)
argument_list|)
expr_stmt|;
name|dest
index|[
name|start
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|number
operator|&
literal|0x7F
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|number
operator|&
operator|~
literal|0x1FFFFF
operator|)
operator|==
literal|0
condition|)
block|{
name|dest
index|[
name|start
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|number
operator|&
literal|0x1FC000
operator|)
operator|>>
literal|14
operator|)
argument_list|)
expr_stmt|;
name|dest
index|[
name|start
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|number
operator|&
literal|0x3F80
operator|)
operator|>>
literal|7
operator|)
argument_list|)
expr_stmt|;
name|dest
index|[
name|start
operator|+
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|number
operator|&
literal|0x7F
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|number
operator|&
operator|~
literal|0xFFFFFFF
operator|)
operator|==
literal|0
condition|)
block|{
name|dest
index|[
name|start
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|number
operator|&
literal|0xFE00000
operator|)
operator|>>
literal|21
operator|)
argument_list|)
expr_stmt|;
name|dest
index|[
name|start
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|number
operator|&
literal|0x1FC000
operator|)
operator|>>
literal|14
operator|)
argument_list|)
expr_stmt|;
name|dest
index|[
name|start
operator|+
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|number
operator|&
literal|0x3F80
operator|)
operator|>>
literal|7
operator|)
argument_list|)
expr_stmt|;
name|dest
index|[
name|start
operator|+
literal|3
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|number
operator|&
literal|0x7F
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
else|else
block|{
name|dest
index|[
name|start
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|number
operator|&
literal|0xF0000000
operator|)
operator|>>
literal|28
operator|)
argument_list|)
expr_stmt|;
name|dest
index|[
name|start
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|number
operator|&
literal|0xFE00000
operator|)
operator|>>
literal|21
operator|)
argument_list|)
expr_stmt|;
name|dest
index|[
name|start
operator|+
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|number
operator|&
literal|0x1FC000
operator|)
operator|>>
literal|14
operator|)
argument_list|)
expr_stmt|;
name|dest
index|[
name|start
operator|+
literal|3
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|number
operator|&
literal|0x3F80
operator|)
operator|>>
literal|7
operator|)
argument_list|)
expr_stmt|;
name|dest
index|[
name|start
operator|+
literal|4
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|number
operator|&
literal|0x7F
argument_list|)
expr_stmt|;
return|return
literal|5
return|;
block|}
block|}
comment|/**     * Decodes a 32-bit integer from {@code bytes}, beginning at offset {@code pos.pos}.    * The decoded value is returned, and {@code pos.pos} is incremented by the number of    * bytes processed.    * @param bytes The byte array containing an encoded value.    * @param pos On entry, the starting position in the array; on return, one greater    * than the position of the last byte decoded in the call.    * @return The decoded value.    */
DECL|method|decode
specifier|public
specifier|static
name|int
name|decode
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|Position
name|pos
parameter_list|)
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|byte
name|first
init|=
name|bytes
index|[
name|pos
operator|.
name|pos
index|]
decl_stmt|;
operator|++
name|pos
operator|.
name|pos
expr_stmt|;
name|value
operator||=
name|first
operator|&
literal|0x7F
expr_stmt|;
if|if
condition|(
operator|(
name|first
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|value
return|;
block|}
name|value
operator|<<=
literal|7
expr_stmt|;
block|}
block|}
comment|/**    * Decodes a 32-bit integer from bytes read from {@code in}. Bytes are read,    * one at a time, from {@code in}, and it is assumed they represent a 32-bit    * integer encoded using this class's encoding scheme. The decoded value is    * returned.    * @param in The input stream containing the encoded bytes.    * @return The decoded value.    * @exception EOFException If the stream ends before a value has been decoded.    */
DECL|method|decode
specifier|public
specifier|static
name|int
name|decode
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|first
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
name|value
operator||=
name|first
operator|&
literal|0x7F
expr_stmt|;
if|if
condition|(
operator|(
name|first
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|value
return|;
block|}
name|value
operator|<<=
literal|7
expr_stmt|;
block|}
block|}
comment|/**    * The default ctor is made private because all methods of this class are static.    */
DECL|method|Vint8
specifier|private
name|Vint8
parameter_list|()
block|{
comment|// Just making it impossible to instantiate.
block|}
block|}
end_class
end_unit
