begin_unit
begin_package
DECL|package|org.apache.lucene.facet.sampling
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|sampling
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|old
operator|.
name|ScoredDocIDs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|old
operator|.
name|ScoredDocIDsIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|old
operator|.
name|ScoredDocIdsUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  * Take random samples of large collections.  * @lucene.experimental  */
end_comment
begin_class
DECL|class|RepeatableSampler
specifier|public
class|class
name|RepeatableSampler
extends|extends
name|Sampler
block|{
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|RepeatableSampler
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|method|RepeatableSampler
specifier|public
name|RepeatableSampler
parameter_list|(
name|SamplingParams
name|params
parameter_list|)
block|{
name|super
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createSample
specifier|protected
name|SampleResult
name|createSample
parameter_list|(
name|ScoredDocIDs
name|docids
parameter_list|,
name|int
name|actualSize
parameter_list|,
name|int
name|sampleSetSize
parameter_list|)
throws|throws
name|IOException
block|{
name|int
index|[]
name|sampleSet
init|=
literal|null
decl_stmt|;
try|try
block|{
name|sampleSet
operator|=
name|repeatableSample
argument_list|(
name|docids
argument_list|,
name|actualSize
argument_list|,
name|sampleSetSize
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|logger
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|)
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"sampling failed: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|" - falling back to no sampling!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SampleResult
argument_list|(
name|docids
argument_list|,
literal|1d
argument_list|)
return|;
block|}
name|ScoredDocIDs
name|sampled
init|=
name|ScoredDocIdsUtils
operator|.
name|createScoredDocIDsSubset
argument_list|(
name|docids
argument_list|,
name|sampleSet
argument_list|)
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINEST
argument_list|)
condition|)
block|{
name|logger
operator|.
name|finest
argument_list|(
literal|"******************** "
operator|+
name|sampled
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SampleResult
argument_list|(
name|sampled
argument_list|,
name|sampled
operator|.
name|size
argument_list|()
operator|/
operator|(
name|double
operator|)
name|docids
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns<code>sampleSize</code> values from the first<code>collectionSize</code>    * locations of<code>collection</code>, chosen using    * the<code>TRAVERSAL</code> algorithm. The sample values are not sorted.    * @param collection The values from which a sample is wanted.    * @param collectionSize The number of values (from the first) from which to draw the sample.    * @param sampleSize The number of values to return.    * @return An array of values chosen from the collection.    * @see Algorithm#TRAVERSAL    */
DECL|method|repeatableSample
specifier|private
specifier|static
name|int
index|[]
name|repeatableSample
parameter_list|(
name|ScoredDocIDs
name|collection
parameter_list|,
name|int
name|collectionSize
parameter_list|,
name|int
name|sampleSize
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|repeatableSample
argument_list|(
name|collection
argument_list|,
name|collectionSize
argument_list|,
name|sampleSize
argument_list|,
name|Algorithm
operator|.
name|HASHING
argument_list|,
name|Sorted
operator|.
name|NO
argument_list|)
return|;
block|}
comment|/**    * Returns<code>sampleSize</code> values from the first<code>collectionSize</code>    * locations of<code>collection</code>, chosen using<code>algorithm</code>.    * @param collection The values from which a sample is wanted.    * @param collectionSize The number of values (from the first) from which to draw the sample.    * @param sampleSize The number of values to return.    * @param algorithm Which algorithm to use.    * @param sorted Sorted.YES to sort the sample values in ascending order before returning;    * Sorted.NO to return them in essentially random order.    * @return An array of values chosen from the collection.    */
DECL|method|repeatableSample
specifier|private
specifier|static
name|int
index|[]
name|repeatableSample
parameter_list|(
name|ScoredDocIDs
name|collection
parameter_list|,
name|int
name|collectionSize
parameter_list|,
name|int
name|sampleSize
parameter_list|,
name|Algorithm
name|algorithm
parameter_list|,
name|Sorted
name|sorted
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"docIdSet is null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|sampleSize
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"sampleSize< 1 ("
operator|+
name|sampleSize
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|collectionSize
operator|<
name|sampleSize
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"collectionSize ("
operator|+
name|collectionSize
operator|+
literal|") less than sampleSize ("
operator|+
name|sampleSize
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|int
index|[]
name|sample
init|=
operator|new
name|int
index|[
name|sampleSize
index|]
decl_stmt|;
name|long
index|[]
name|times
init|=
operator|new
name|long
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|algorithm
operator|==
name|Algorithm
operator|.
name|TRAVERSAL
condition|)
block|{
name|sample1
argument_list|(
name|collection
argument_list|,
name|collectionSize
argument_list|,
name|sample
argument_list|,
name|times
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|algorithm
operator|==
name|Algorithm
operator|.
name|HASHING
condition|)
block|{
name|sample2
argument_list|(
name|collection
argument_list|,
name|collectionSize
argument_list|,
name|sample
argument_list|,
name|times
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid algorithm selection"
argument_list|)
throw|;
block|}
if|if
condition|(
name|sorted
operator|==
name|Sorted
operator|.
name|YES
condition|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|sample
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|returnTimings
condition|)
block|{
name|times
index|[
literal|3
index|]
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINEST
argument_list|)
condition|)
block|{
name|logger
operator|.
name|finest
argument_list|(
literal|"Times: "
operator|+
operator|(
name|times
index|[
literal|1
index|]
operator|-
name|times
index|[
literal|0
index|]
operator|)
operator|+
literal|"ms, "
operator|+
operator|(
name|times
index|[
literal|2
index|]
operator|-
name|times
index|[
literal|1
index|]
operator|)
operator|+
literal|"ms, "
operator|+
operator|(
name|times
index|[
literal|3
index|]
operator|-
name|times
index|[
literal|2
index|]
operator|)
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sample
return|;
block|}
comment|/**    * Returns<code>sample</code>.length values chosen from the first<code>collectionSize</code>    * locations of<code>collection</code>, using the TRAVERSAL algorithm. The sample is    * pseudorandom: no subset of the original collection    * is in principle more likely to occur than any other, but for a given collection    * and sample size, the same sample will always be returned. This algorithm walks the    * original collection in a methodical way that is guaranteed not to visit any location    * more than once, which makes sampling without replacement faster because removals don't    * have to be tracked, and the number of operations is proportional to the sample size,    * not the collection size.    * Times for performance measurement    * are returned in<code>times</code>, which must be an array of at least three longs, containing    * nanosecond event times. The first    * is set when the algorithm starts; the second, when the step size has been calculated;    * and the third when the sample has been taken.    * @param collection The set to be sampled.    * @param collectionSize The number of values to use (starting from first).    * @param sample The array in which to return the sample.    * @param times The times of three events, for measuring performance.    */
DECL|method|sample1
specifier|private
specifier|static
name|void
name|sample1
parameter_list|(
name|ScoredDocIDs
name|collection
parameter_list|,
name|int
name|collectionSize
parameter_list|,
name|int
index|[]
name|sample
parameter_list|,
name|long
index|[]
name|times
parameter_list|)
throws|throws
name|IOException
block|{
name|ScoredDocIDsIterator
name|it
init|=
name|collection
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|returnTimings
condition|)
block|{
name|times
index|[
literal|0
index|]
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
name|int
name|sampleSize
init|=
name|sample
operator|.
name|length
decl_stmt|;
name|int
name|prime
init|=
name|findGoodStepSize
argument_list|(
name|collectionSize
argument_list|,
name|sampleSize
argument_list|)
decl_stmt|;
name|int
name|mod
init|=
name|prime
operator|%
name|collectionSize
decl_stmt|;
if|if
condition|(
name|returnTimings
condition|)
block|{
name|times
index|[
literal|1
index|]
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
name|int
name|sampleCount
init|=
literal|0
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|sampleCount
operator|<
name|sampleSize
condition|;
control|)
block|{
if|if
condition|(
name|index
operator|+
name|mod
operator|<
name|collectionSize
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mod
condition|;
name|i
operator|++
operator|,
name|index
operator|++
control|)
block|{
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|index
operator|=
name|index
operator|+
name|mod
operator|-
name|collectionSize
expr_stmt|;
name|it
operator|=
name|collection
operator|.
name|iterator
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|index
condition|;
name|i
operator|++
control|)
block|{
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
name|sample
index|[
name|sampleCount
operator|++
index|]
operator|=
name|it
operator|.
name|getDocID
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|returnTimings
condition|)
block|{
name|times
index|[
literal|2
index|]
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns a value which will allow the caller to walk    * a collection of<code>collectionSize</code> values, without repeating or missing    * any, and spanning the collection from beginning to end at least once with    *<code>sampleSize</code> visited locations. Choosing a value    * that is relatively prime to the collection size ensures that stepping by that size (modulo    * the collection size) will hit all locations without repeating, eliminating the need to    * track previously visited locations for a "without replacement" sample. Starting with the    * square root of the collection size ensures that either the first or second prime tried will    * work (they can't both divide the collection size). It also has the property that N steps of    * size N will span a collection of N**2 elements once. If the sample is bigger than N, it will    * wrap multiple times (without repeating). If the sample is smaller, a step size is chosen    * that will result in at least one spanning of the collection.    *     * @param collectionSize The number of values in the collection to be sampled.    * @param sampleSize The number of values wanted in the sample.    * @return A good increment value for walking the collection.    */
DECL|method|findGoodStepSize
specifier|private
specifier|static
name|int
name|findGoodStepSize
parameter_list|(
name|int
name|collectionSize
parameter_list|,
name|int
name|sampleSize
parameter_list|)
block|{
name|int
name|i
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|sqrt
argument_list|(
name|collectionSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|sampleSize
operator|<
name|i
condition|)
block|{
name|i
operator|=
name|collectionSize
operator|/
name|sampleSize
expr_stmt|;
block|}
do|do
block|{
name|i
operator|=
name|findNextPrimeAfter
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|collectionSize
operator|%
name|i
operator|==
literal|0
condition|)
do|;
return|return
name|i
return|;
block|}
comment|/**    * Returns the first prime number that is larger than<code>n</code>.    * @param n A number less than the prime to be returned.    * @return The smallest prime larger than<code>n</code>.    */
DECL|method|findNextPrimeAfter
specifier|private
specifier|static
name|int
name|findNextPrimeAfter
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|n
operator|+=
operator|(
name|n
operator|%
literal|2
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
comment|// next odd
name|foundFactor
label|:
for|for
control|(
init|;
condition|;
name|n
operator|+=
literal|2
control|)
block|{
comment|//TODO labels??!!
name|int
name|sri
init|=
call|(
name|int
call|)
argument_list|(
name|Math
operator|.
name|sqrt
argument_list|(
name|n
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|primeIndex
init|=
literal|0
init|;
name|primeIndex
operator|<
name|N_PRIMES
condition|;
name|primeIndex
operator|++
control|)
block|{
name|int
name|p
init|=
name|primes
index|[
name|primeIndex
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|>
name|sri
condition|)
block|{
return|return
name|n
return|;
block|}
if|if
condition|(
name|n
operator|%
name|p
operator|==
literal|0
condition|)
block|{
continue|continue
name|foundFactor
continue|;
block|}
block|}
for|for
control|(
name|int
name|p
init|=
name|primes
index|[
name|N_PRIMES
operator|-
literal|1
index|]
operator|+
literal|2
init|;
condition|;
name|p
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|p
operator|>
name|sri
condition|)
block|{
return|return
name|n
return|;
block|}
if|if
condition|(
name|n
operator|%
name|p
operator|==
literal|0
condition|)
block|{
continue|continue
name|foundFactor
continue|;
block|}
block|}
block|}
block|}
comment|/**    * The first N_PRIMES primes, after 2.    */
DECL|field|N_PRIMES
specifier|private
specifier|static
specifier|final
name|int
name|N_PRIMES
init|=
literal|4000
decl_stmt|;
DECL|field|primes
specifier|private
specifier|static
name|int
index|[]
name|primes
init|=
operator|new
name|int
index|[
name|N_PRIMES
index|]
decl_stmt|;
static|static
block|{
name|primes
index|[
literal|0
index|]
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|int
name|count
init|=
literal|1
init|;
name|count
operator|<
name|N_PRIMES
condition|;
name|count
operator|++
control|)
block|{
name|primes
index|[
name|count
index|]
operator|=
name|findNextPrimeAfter
argument_list|(
name|primes
index|[
name|count
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns<code>sample</code>.length values chosen from the first<code>collectionSize</code>    * locations of<code>collection</code>, using the HASHING algorithm. Performance measurements    * are returned in<code>times</code>, which must be an array of at least three longs. The first    * will be set when the algorithm starts; the second, when a hash key has been calculated and    * inserted into the priority queue for every element in the collection; and the third when the    * original elements associated with the keys remaining in the PQ have been stored in the sample    * array for return.    *<P>    * This algorithm slows as the sample size becomes a significant fraction of the collection    * size, because the PQ is as large as the sample set, and will not do early rejection of values    * below the minimum until it fills up, and a larger PQ contains more small values to be purged,    * resulting in less early rejection and more logN insertions.    *     * @param collection The set to be sampled.    * @param collectionSize The number of values to use (starting from first).    * @param sample The array in which to return the sample.    * @param times The times of three events, for measuring performance.    */
DECL|method|sample2
specifier|private
specifier|static
name|void
name|sample2
parameter_list|(
name|ScoredDocIDs
name|collection
parameter_list|,
name|int
name|collectionSize
parameter_list|,
name|int
index|[]
name|sample
parameter_list|,
name|long
index|[]
name|times
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|returnTimings
condition|)
block|{
name|times
index|[
literal|0
index|]
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
name|int
name|sampleSize
init|=
name|sample
operator|.
name|length
decl_stmt|;
name|IntPriorityQueue
name|pq
init|=
operator|new
name|IntPriorityQueue
argument_list|(
name|sampleSize
argument_list|)
decl_stmt|;
comment|/*      * Convert every value in the collection to a hashed "weight" value, and insert      * into a bounded PQ (retains only sampleSize highest weights).      */
name|ScoredDocIDsIterator
name|it
init|=
name|collection
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|MI
name|mi
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|next
argument_list|()
condition|)
block|{
if|if
condition|(
name|mi
operator|==
literal|null
condition|)
block|{
name|mi
operator|=
operator|new
name|MI
argument_list|()
expr_stmt|;
block|}
name|mi
operator|.
name|value
operator|=
call|(
name|int
call|)
argument_list|(
name|it
operator|.
name|getDocID
argument_list|()
operator|*
name|PHI_32
argument_list|)
operator|&
literal|0x7FFFFFFF
expr_stmt|;
name|mi
operator|=
name|pq
operator|.
name|insertWithOverflow
argument_list|(
name|mi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|returnTimings
condition|)
block|{
name|times
index|[
literal|1
index|]
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
comment|/*      * Extract heap, convert weights back to original values, and return as integers.      */
name|Object
index|[]
name|heap
init|=
name|pq
operator|.
name|getHeap
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|si
init|=
literal|0
init|;
name|si
operator|<
name|sampleSize
condition|;
name|si
operator|++
control|)
block|{
name|sample
index|[
name|si
index|]
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|MI
operator|)
name|heap
index|[
name|si
operator|+
literal|1
index|]
operator|)
operator|.
name|value
operator|*
name|PHI_32I
argument_list|)
operator|&
literal|0x7FFFFFFF
expr_stmt|;
block|}
if|if
condition|(
name|returnTimings
condition|)
block|{
name|times
index|[
literal|2
index|]
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * A mutable integer that lets queue objects be reused once they start overflowing.    */
DECL|class|MI
specifier|private
specifier|static
class|class
name|MI
block|{
DECL|method|MI
name|MI
parameter_list|()
block|{ }
DECL|field|value
specifier|public
name|int
name|value
decl_stmt|;
block|}
comment|/**    * A bounded priority queue for Integers, to retain a specified number of    * the highest-weighted values for return as a random sample.    */
DECL|class|IntPriorityQueue
specifier|private
specifier|static
class|class
name|IntPriorityQueue
extends|extends
name|PriorityQueue
argument_list|<
name|MI
argument_list|>
block|{
comment|/**      * Creates a bounded PQ of size<code>size</code>.      * @param size The number of elements to retain.      */
DECL|method|IntPriorityQueue
specifier|public
name|IntPriorityQueue
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|super
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the underlying data structure for faster access. Extracting elements      * one at a time would require N logN time, and since we want the elements sorted      * in ascending order by value (not weight), the array is useful as-is.      * @return The underlying heap array.      */
DECL|method|getHeap
specifier|public
name|Object
index|[]
name|getHeap
parameter_list|()
block|{
return|return
name|getHeapArray
argument_list|()
return|;
block|}
comment|/**      * Returns true if<code>o1<code>'s weight is less than that of<code>o2</code>, for      * ordering in the PQ.      * @return True if<code>o1</code> weighs less than<code>o2</code>.      */
annotation|@
name|Override
DECL|method|lessThan
specifier|public
name|boolean
name|lessThan
parameter_list|(
name|MI
name|o1
parameter_list|,
name|MI
name|o2
parameter_list|)
block|{
return|return
name|o1
operator|.
name|value
operator|<
name|o2
operator|.
name|value
return|;
block|}
block|}
comment|/**    * For specifying which sampling algorithm to use.    */
DECL|enum|Algorithm
specifier|private
enum|enum
name|Algorithm
block|{
comment|/**      * Specifies a methodical traversal algorithm, which is guaranteed to span the collection      * at least once, and never to return duplicates. Faster than the hashing algorithm and      * uses much less space, but the randomness of the sample may be affected by systematic      * variations in the collection. Requires only an array for the sample, and visits only      * the number of elements in the sample set, not the full set.      */
comment|// TODO (Facet): This one produces a bimodal distribution (very flat around
comment|// each peak!) for collection size 10M and sample sizes 10k and 10544.
comment|// Figure out why.
DECL|enum constant|TRAVERSAL
name|TRAVERSAL
block|,
comment|/**      * Specifies a Fibonacci-style hash algorithm (see Knuth, S&S), which generates a less      * systematically distributed subset of the sampled collection than the traversal method,      * but requires a bounded priority queue the size of the sample, and creates an object      * containing a sampled value and its hash, for every element in the full set.       */
DECL|enum constant|HASHING
name|HASHING
block|}
comment|/**    * For specifying whether to sort the sample.    */
DECL|enum|Sorted
specifier|private
enum|enum
name|Sorted
block|{
comment|/**      * Sort resulting sample before returning.      */
DECL|enum constant|YES
name|YES
block|,
comment|/**      *Do not sort the resulting sample.       */
DECL|enum constant|NO
name|NO
block|}
comment|/**    * Magic number 1: prime closest to phi, in 32 bits.    */
DECL|field|PHI_32
specifier|private
specifier|static
specifier|final
name|long
name|PHI_32
init|=
literal|2654435769L
decl_stmt|;
comment|/**    * Magic number 2: multiplicative inverse of PHI_32, modulo 2**32.    */
DECL|field|PHI_32I
specifier|private
specifier|static
specifier|final
name|long
name|PHI_32I
init|=
literal|340573321L
decl_stmt|;
comment|/**    * Switch to cause methods to return timings.    */
DECL|field|returnTimings
specifier|private
specifier|static
name|boolean
name|returnTimings
init|=
literal|false
decl_stmt|;
block|}
end_class
end_unit
