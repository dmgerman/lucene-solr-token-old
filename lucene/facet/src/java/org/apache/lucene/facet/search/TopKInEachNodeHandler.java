begin_unit
begin_package
DECL|package|org.apache.lucene.facet.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|search
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|search
operator|.
name|params
operator|.
name|FacetRequest
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|search
operator|.
name|params
operator|.
name|FacetRequest
operator|.
name|SortOrder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|search
operator|.
name|results
operator|.
name|FacetResult
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|search
operator|.
name|results
operator|.
name|FacetResultNode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|search
operator|.
name|results
operator|.
name|IntermediateFacetResult
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|search
operator|.
name|results
operator|.
name|MutableFacetResultNode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|taxonomy
operator|.
name|TaxonomyReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|taxonomy
operator|.
name|directory
operator|.
name|ParallelTaxonomyArrays
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|collections
operator|.
name|IntIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|collections
operator|.
name|IntToObjectMap
import|;
end_import
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  * Generates {@link FacetResult} from the count arrays aggregated for a  * particular {@link FacetRequest}. The generated {@link FacetResult} is a  * subtree of the taxonomy tree. Its root node,  * {@link FacetResult#getFacetResultNode()}, is the facet specified by  * {@link FacetRequest#categoryPath}, and the enumerated children,  * {@link FacetResultNode#getSubResults()}, of each node in that  * {@link FacetResult} are the top K ( = {@link FacetRequest#getNumResults()})  * among its children in the taxonomy. Top in the sense  * {@link FacetRequest#getSortBy()}, which can be by the values aggregated in  * the count arrays, or by ordinal numbers; also specified is the sort order,  * {@link FacetRequest#getSortOrder()}, ascending or descending, of these values  * or ordinals before their top K are selected. The depth (number of levels  * excluding the root) of the {@link FacetResult} tree is specified by  * {@link FacetRequest#getDepth()}.  *<p>  * Because the number of selected children of each node is restricted, and not  * the overall number of nodes in the {@link FacetResult}, facets not selected  * into {@link FacetResult} might have better values, or ordinals, (typically,  * higher counts), than facets that are selected into the {@link FacetResult}.  *<p>  * The generated {@link FacetResult} also provides with  * {@link FacetResult#getNumValidDescendants()}, which returns the total number  * of facets that are descendants of the root node, no deeper than  * {@link FacetRequest#getDepth()}, and which have valid value. The rootnode  * itself is not counted here. Valid value is determined by the  * {@link FacetResultsHandler}. {@link TopKInEachNodeHandler} defines valid as  * != 0.  *<p>  *<b>NOTE:</b> this code relies on the assumption that  * {@link TaxonomyReader#INVALID_ORDINAL} == -1, a smaller value than any valid  * ordinal.  *   * @lucene.experimental  */
end_comment
begin_class
DECL|class|TopKInEachNodeHandler
specifier|public
class|class
name|TopKInEachNodeHandler
extends|extends
name|FacetResultsHandler
block|{
DECL|method|TopKInEachNodeHandler
specifier|public
name|TopKInEachNodeHandler
parameter_list|(
name|TaxonomyReader
name|taxonomyReader
parameter_list|,
name|FacetRequest
name|facetRequest
parameter_list|)
block|{
name|super
argument_list|(
name|taxonomyReader
argument_list|,
name|facetRequest
argument_list|)
expr_stmt|;
block|}
comment|/**    * Recursively explore all facets that can be potentially included in the    * {@link FacetResult} to be generated, and that belong to the given    * partition, so that values can be examined and collected. For each such    * node, gather its top K ({@link FacetRequest#getNumResults()}) children    * among its children that are encountered in the given particular partition    * (aka current counting list).    *     * @return {@link IntermediateFacetResult} consisting of    *         {@link IntToObjectMap} that maps potential    *         {@link FacetResult} nodes to their top K children encountered in    *         the current partition. Note that the mapped potential tree nodes    *         need not belong to the given partition, only the top K children    *         mapped to. The aim is to identify nodes that are certainly excluded    *         from the {@link FacetResult} to be eventually (after going through    *         all the partitions) returned by this handler, because they have K    *         better siblings, already identified in this partition. For the    *         identified excluded nodes, we only count number of their    *         descendants in the subtree (to be included in    *         {@link FacetResult#getNumValidDescendants()}), but not bother with    *         selecting top K in these generations, which, by definition, are,    *         too, excluded from the FacetResult tree.    * @param arrays the already filled in count array, potentially only covering    *        one partition: the ordinals ranging from    * @param offset to<code>offset</code> + the length of the count arrays    *        within<code>arrays</code> (exclusive)    * @throws IOException in case    *         {@link TaxonomyReader#getOrdinal(org.apache.lucene.facet.taxonomy.CategoryPath)}    *         does.    * @see FacetResultsHandler#fetchPartitionResult(FacetArrays, int)    */
annotation|@
name|Override
DECL|method|fetchPartitionResult
specifier|public
name|IntermediateFacetResult
name|fetchPartitionResult
parameter_list|(
name|FacetArrays
name|arrays
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
comment|// get the root of the result tree to be returned, and the depth of that result tree
comment|// (depth means number of node levels excluding the root).
name|int
name|rootNode
init|=
name|this
operator|.
name|taxonomyReader
operator|.
name|getOrdinal
argument_list|(
name|facetRequest
operator|.
name|categoryPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|rootNode
operator|==
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|K
init|=
name|Math
operator|.
name|min
argument_list|(
name|facetRequest
operator|.
name|getNumResults
argument_list|()
argument_list|,
name|taxonomyReader
operator|.
name|getSize
argument_list|()
argument_list|)
decl_stmt|;
comment|// number of best results in each node
comment|// this will grow into the returned IntermediateFacetResult
name|IntToObjectMap
argument_list|<
name|AACO
argument_list|>
name|AACOsOfOnePartition
init|=
operator|new
name|IntToObjectMap
argument_list|<
name|AACO
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|partitionSize
init|=
name|arrays
operator|.
name|arrayLength
decl_stmt|;
comment|// all partitions, except, possibly, the last,
comment|// have the same length. Hence modulo is OK.
name|int
name|depth
init|=
name|facetRequest
operator|.
name|getDepth
argument_list|()
decl_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
block|{
comment|// Need to only have root node.
name|IntermediateFacetResultWithHash
name|tempFRWH
init|=
operator|new
name|IntermediateFacetResultWithHash
argument_list|(
name|facetRequest
argument_list|,
name|AACOsOfOnePartition
argument_list|)
decl_stmt|;
if|if
condition|(
name|isSelfPartition
argument_list|(
name|rootNode
argument_list|,
name|arrays
argument_list|,
name|offset
argument_list|)
condition|)
block|{
name|tempFRWH
operator|.
name|isRootNodeIncluded
operator|=
literal|true
expr_stmt|;
name|tempFRWH
operator|.
name|rootNodeValue
operator|=
name|this
operator|.
name|facetRequest
operator|.
name|getValueOf
argument_list|(
name|arrays
argument_list|,
name|rootNode
operator|%
name|partitionSize
argument_list|)
expr_stmt|;
block|}
return|return
name|tempFRWH
return|;
block|}
if|if
condition|(
name|depth
operator|>
name|Short
operator|.
name|MAX_VALUE
operator|-
literal|3
condition|)
block|{
name|depth
operator|=
name|Short
operator|.
name|MAX_VALUE
operator|-
literal|3
expr_stmt|;
block|}
name|int
name|endOffset
init|=
name|offset
operator|+
name|partitionSize
decl_stmt|;
comment|// one past the largest ordinal in the partition
name|ParallelTaxonomyArrays
name|childrenArray
init|=
name|taxonomyReader
operator|.
name|getParallelTaxonomyArrays
argument_list|()
decl_stmt|;
name|int
index|[]
name|children
init|=
name|childrenArray
operator|.
name|children
argument_list|()
decl_stmt|;
name|int
index|[]
name|siblings
init|=
name|childrenArray
operator|.
name|siblings
argument_list|()
decl_stmt|;
name|int
name|totalNumOfDescendantsConsidered
init|=
literal|0
decl_stmt|;
comment|// total number of facets with value != 0,
comment|// in the tree. These include those selected as top K in each node, and all the others that
comment|// were not. Not including rootNode
comment|// the following priority queue will be used again and again for each node recursed into
comment|// to select its best K children among its children encountered in the given partition
name|PriorityQueue
argument_list|<
name|AggregatedCategory
argument_list|>
name|pq
init|=
operator|new
name|AggregatedCategoryHeap
argument_list|(
name|K
argument_list|,
name|this
operator|.
name|getSuitableACComparator
argument_list|()
argument_list|)
decl_stmt|;
comment|// reusables will feed the priority queue in each use
name|AggregatedCategory
index|[]
name|reusables
init|=
operator|new
name|AggregatedCategory
index|[
literal|2
operator|+
name|K
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|reusables
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|reusables
index|[
name|i
index|]
operator|=
operator|new
name|AggregatedCategory
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * The returned map is built by a recursive visit of potential tree nodes. Nodes       * determined to be excluded from the FacetResult are not recursively explored as others,      * they are only recursed in order to count the number of their descendants.      * Also, nodes that they and any of their descendants can not be mapped into facets encountered       * in this partition, are, too, explored no further. These are facets whose ordinal       * numbers are greater than the ordinals of the given partition. (recall that the Taxonomy      * maintains that a parent ordinal is smaller than any of its descendants' ordinals).        * So, when scanning over all children of a potential tree node n: (1) all children with ordinal number      * greater than those in the given partition are skipped over, (2) among the children of n residing      * in this partition, the best K children are selected (using pq) for usual further recursion       * and the rest (those rejected out from the pq) are only recursed for counting total number      * of descendants, and (3) all the children of ordinal numbers smaller than the given partition       * are further explored in the usual way, since these may lead to descendants residing in this partition.      *       * ordinalStack drives the recursive descent.       * Top of stack holds the current node which we recurse from.      * ordinalStack[0] holds the root of the facetRequest, and      * it is always maintained that parent(ordianlStack[i]) = ordinalStack[i-1].       * localDepth points to the current top of ordinalStack.      * Only top of ordinalStack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if      * the element below it explored all its relevant children.      */
name|int
index|[]
name|ordinalStack
init|=
operator|new
name|int
index|[
name|depth
operator|+
literal|2
index|]
decl_stmt|;
comment|// for 0 and for invalid on top
name|ordinalStack
index|[
literal|0
index|]
operator|=
name|rootNode
expr_stmt|;
name|int
name|localDepth
init|=
literal|0
decl_stmt|;
comment|/*       * bestSignlingsStack[i] maintains the best K children of ordinalStack[i-1], namely,      * the best K siblings of ordinalStack[i], best K among those residing in the given partition.      * Note that the residents of ordinalStack need not belong      * to the current partition, only the residents of bestSignlingsStack.      * When exploring the children of ordianlStack[i-1] that reside in the current partition      * (after the top K of them have been determined and stored into bestSignlingsStack[i]),      * siblingExplored[i] points into bestSignlingsStack[i], to the child now explored, hence      * residing in ordinalStack[i], and firstToTheLeftOfPartition[i] holds the largest ordinal of      * a sibling smaller than the ordinals in the partition.        * When siblingExplored[i] == max int, the top K siblings of ordinalStack[i] among those siblings      * that reside in this partition have not been determined yet.       * if siblingExplored[i]< 0, the node in ordinalStack[i] is to the left of partition       * (i.e. of a smaller ordinal than the current partition)       * (step (3) above is executed for the children of ordianlStack[i-1])         */
name|int
index|[]
index|[]
name|bestSignlingsStack
init|=
operator|new
name|int
index|[
name|depth
operator|+
literal|2
index|]
index|[]
decl_stmt|;
name|int
index|[]
name|siblingExplored
init|=
operator|new
name|int
index|[
name|depth
operator|+
literal|2
index|]
decl_stmt|;
name|int
index|[]
name|firstToTheLeftOfPartition
init|=
operator|new
name|int
index|[
name|depth
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|tosOrdinal
decl_stmt|;
comment|// top of stack element, the ordinal at the top of stack
comment|/*      * to start the loop, complete the datastructures for root node:       * push its youngest child to ordinalStack; make a note in siblingExplored[] that the children      * of rootNode, which reside in the current partition have not been read yet to select the top      * K of them.  Also, make rootNode as if, related to its parent, rootNode belongs to the children      * of ordinal numbers smaller than those of the current partition (this will ease on end condition --       * we can continue to the older sibling of rootNode once the localDepth goes down, before we verify that       * it went that down)      */
name|ordinalStack
index|[
operator|++
name|localDepth
index|]
operator|=
name|children
index|[
name|rootNode
index|]
expr_stmt|;
name|siblingExplored
index|[
name|localDepth
index|]
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
comment|// we have not verified position wrt current partition
name|siblingExplored
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|// as if rootNode resides to the left of current position
comment|/*      * now the whole recursion: loop as long as stack is not empty of elements descendants of       * facetRequest's root.      */
while|while
condition|(
name|localDepth
operator|>
literal|0
condition|)
block|{
name|tosOrdinal
operator|=
name|ordinalStack
index|[
name|localDepth
index|]
expr_stmt|;
if|if
condition|(
name|tosOrdinal
operator|==
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
condition|)
block|{
comment|// the brotherhood that has been occupying the top of stack is all exhausted.
comment|// Hence, element below tos, namely, father of tos, has all its children,
comment|// and itself, all explored.
name|localDepth
operator|--
expr_stmt|;
comment|// replace this father, now on top of stack, by this father's sibling:
comment|// this parent's ordinal can not be greater than current partition, as otherwise
comment|// its child, now just removed, would not have been pushed on it.
comment|// so the father is either inside the partition, or smaller ordinal
if|if
condition|(
name|siblingExplored
index|[
name|localDepth
index|]
operator|<
literal|0
condition|)
block|{
name|ordinalStack
index|[
name|localDepth
index|]
operator|=
name|siblings
index|[
name|ordinalStack
index|[
name|localDepth
index|]
index|]
expr_stmt|;
continue|continue;
block|}
comment|// in this point, siblingExplored[localDepth] between 0 and number of bestSiblings
comment|// it can not be max int
name|siblingExplored
index|[
name|localDepth
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|siblingExplored
index|[
name|localDepth
index|]
operator|==
operator|-
literal|1
condition|)
block|{
comment|//siblings residing in the partition have been all processed, we now move
comment|// to those of ordinal numbers smaller than the partition
name|ordinalStack
index|[
name|localDepth
index|]
operator|=
name|firstToTheLeftOfPartition
index|[
name|localDepth
index|]
expr_stmt|;
block|}
else|else
block|{
comment|// still explore siblings residing in the partition
comment|// just move to the next one
name|ordinalStack
index|[
name|localDepth
index|]
operator|=
name|bestSignlingsStack
index|[
name|localDepth
index|]
index|[
name|siblingExplored
index|[
name|localDepth
index|]
index|]
expr_stmt|;
block|}
continue|continue;
block|}
comment|// endof tosOrdinal is invalid, and hence removed, and its parent was replaced by this
comment|// parent's sibling
comment|// now try to push a kid, but first look at tos whether it 'deserves' its kids explored:
comment|// it is not to the right of current partition, and we know whether to only count or to
comment|// select best K siblings.
if|if
condition|(
name|siblingExplored
index|[
name|localDepth
index|]
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
comment|//tosOrdinal was not examined yet for its position relative to current partition
comment|// and the best K of current partition, among its siblings, have not been determined yet
while|while
condition|(
name|tosOrdinal
operator|>=
name|endOffset
condition|)
block|{
name|tosOrdinal
operator|=
name|siblings
index|[
name|tosOrdinal
index|]
expr_stmt|;
block|}
comment|// now it is inside. Run it and all its siblings inside the partition through a heap
comment|// and in doing so, count them, find best K, and sum into residue
name|double
name|residue
init|=
literal|0f
decl_stmt|;
comment|// the sum of all the siblings from this partition that do not make
comment|// it to top K
name|pq
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|//reusables are consumed as from a stack. The stack starts full and returns full.
name|int
name|tosReuslables
init|=
name|reusables
operator|.
name|length
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|tosOrdinal
operator|>=
name|offset
condition|)
block|{
comment|// while tosOrdinal belongs to the given partition; here, too, we use the fact
comment|// that TaxonomyReader.INVALID_ORDINAL == -1< offset
name|double
name|value
init|=
name|facetRequest
operator|.
name|getValueOf
argument_list|(
name|arrays
argument_list|,
name|tosOrdinal
operator|%
name|partitionSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
comment|// the value of yc is not 0, it is to be considered.
name|totalNumOfDescendantsConsidered
operator|++
expr_stmt|;
comment|// consume one reusable, and push to the priority queue
name|AggregatedCategory
name|ac
init|=
name|reusables
index|[
name|tosReuslables
operator|--
index|]
decl_stmt|;
name|ac
operator|.
name|ordinal
operator|=
name|tosOrdinal
expr_stmt|;
name|ac
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|ac
operator|=
name|pq
operator|.
name|insertWithOverflow
argument_list|(
name|ac
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|ac
condition|)
block|{
name|residue
operator|+=
name|ac
operator|.
name|value
expr_stmt|;
comment|// TODO (Facet): could it be that we need to do something
comment|// else, not add, depending on the aggregator?
comment|/* when a facet is excluded from top K, because already in this partition it has                * K better siblings, it is only recursed for count only.                */
comment|// update totalNumOfDescendants by the now excluded node and all its descendants
name|totalNumOfDescendantsConsidered
operator|--
expr_stmt|;
comment|// reduce the 1 earned when the excluded node entered the heap
comment|// and now return it and all its descendants. These will never make it to FacetResult
name|totalNumOfDescendantsConsidered
operator|+=
name|countOnly
argument_list|(
name|ac
operator|.
name|ordinal
argument_list|,
name|children
argument_list|,
name|siblings
argument_list|,
name|arrays
argument_list|,
name|partitionSize
argument_list|,
name|offset
argument_list|,
name|endOffset
argument_list|,
name|localDepth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|reusables
index|[
operator|++
name|tosReuslables
index|]
operator|=
name|ac
expr_stmt|;
block|}
block|}
name|tosOrdinal
operator|=
name|siblings
index|[
name|tosOrdinal
index|]
expr_stmt|;
block|}
comment|// now pq has best K children of ordinals that belong to the given partition.
comment|// Populate a new AACO with them.
comment|// tosOrdinal is now first sibling smaller than partition, make a note of that
name|firstToTheLeftOfPartition
index|[
name|localDepth
index|]
operator|=
name|tosOrdinal
expr_stmt|;
name|int
name|aaci
init|=
name|pq
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
index|[]
name|ords
init|=
operator|new
name|int
index|[
name|aaci
index|]
decl_stmt|;
name|double
index|[]
name|vals
init|=
operator|new
name|double
index|[
name|aaci
index|]
decl_stmt|;
while|while
condition|(
name|aaci
operator|>
literal|0
condition|)
block|{
name|AggregatedCategory
name|ac
init|=
name|pq
operator|.
name|pop
argument_list|()
decl_stmt|;
name|ords
index|[
operator|--
name|aaci
index|]
operator|=
name|ac
operator|.
name|ordinal
expr_stmt|;
name|vals
index|[
name|aaci
index|]
operator|=
name|ac
operator|.
name|value
expr_stmt|;
name|reusables
index|[
operator|++
name|tosReuslables
index|]
operator|=
name|ac
expr_stmt|;
block|}
comment|// if more than 0 ordinals, add this AACO to the map to be returned,
comment|// and add ords to sibling stack, and make a note in siblingExplored that these are to
comment|// be visited now
if|if
condition|(
name|ords
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|AACOsOfOnePartition
operator|.
name|put
argument_list|(
name|ordinalStack
index|[
name|localDepth
operator|-
literal|1
index|]
argument_list|,
operator|new
name|AACO
argument_list|(
name|ords
argument_list|,
name|vals
argument_list|,
name|residue
argument_list|)
argument_list|)
expr_stmt|;
name|bestSignlingsStack
index|[
name|localDepth
index|]
operator|=
name|ords
expr_stmt|;
name|siblingExplored
index|[
name|localDepth
index|]
operator|=
name|ords
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|ordinalStack
index|[
name|localDepth
index|]
operator|=
name|ords
index|[
name|ords
operator|.
name|length
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
comment|// no ordinals siblings of tosOrdinal in current partition, move to the left of it
comment|// tosOrdinal is already there (to the left of partition).
comment|// make a note of it in siblingExplored
name|ordinalStack
index|[
name|localDepth
index|]
operator|=
name|tosOrdinal
expr_stmt|;
name|siblingExplored
index|[
name|localDepth
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
comment|// endof we did not check the position of a valid ordinal wrt partition
comment|// now tosOrdinal is a valid ordinal, inside partition or to the left of it, we need
comment|// to push its kids on top of it, if not too deep.
comment|// Make a note that we did not check them yet
if|if
condition|(
name|localDepth
operator|>=
name|depth
condition|)
block|{
comment|// localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL
name|ordinalStack
index|[
operator|++
name|localDepth
index|]
operator|=
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
expr_stmt|;
continue|continue;
block|}
name|ordinalStack
index|[
operator|++
name|localDepth
index|]
operator|=
name|children
index|[
name|tosOrdinal
index|]
expr_stmt|;
name|siblingExplored
index|[
name|localDepth
index|]
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
comment|// endof loop while stack is not empty
comment|// now generate a TempFacetResult from AACOsOfOnePartition, and consider self.
name|IntermediateFacetResultWithHash
name|tempFRWH
init|=
operator|new
name|IntermediateFacetResultWithHash
argument_list|(
name|facetRequest
argument_list|,
name|AACOsOfOnePartition
argument_list|)
decl_stmt|;
if|if
condition|(
name|isSelfPartition
argument_list|(
name|rootNode
argument_list|,
name|arrays
argument_list|,
name|offset
argument_list|)
condition|)
block|{
name|tempFRWH
operator|.
name|isRootNodeIncluded
operator|=
literal|true
expr_stmt|;
name|tempFRWH
operator|.
name|rootNodeValue
operator|=
name|this
operator|.
name|facetRequest
operator|.
name|getValueOf
argument_list|(
name|arrays
argument_list|,
name|rootNode
operator|%
name|partitionSize
argument_list|)
expr_stmt|;
block|}
name|tempFRWH
operator|.
name|totalNumOfFacetsConsidered
operator|=
name|totalNumOfDescendantsConsidered
expr_stmt|;
return|return
name|tempFRWH
return|;
block|}
comment|/**    * Recursively count<code>ordinal</code>, whose depth is<code>currentDepth</code>,     * and all its descendants down to<code>maxDepth</code> (including),     * descendants whose value in the count arrays,<code>arrays</code>, is != 0.     * The count arrays only includes the current partition, from<code>offset</code>, to (exclusive)     *<code>endOffset</code>.    * It is assumed that<code>ordinal</code><<code>endOffset</code>,     * otherwise, not<code>ordinal</code>, and none of its descendants, reside in    * the current partition.<code>ordinal</code><<code>offset</code> is allowed,     * as ordinal's descendants might be>=<code>offeset</code>.    *     * @param ordinal a facet ordinal.     * @param youngestChild mapping a given ordinal to its youngest child in the taxonomy (of largest ordinal number),    * or to -1 if has no children.      * @param olderSibling  mapping a given ordinal to its older sibling, or to -1    * @param arrays  values for the ordinals in the given partition    * @param offset  the first (smallest) ordinal in the given partition    * @param partitionSize  number of ordinals in the given partition    * @param endOffset one larger than the largest ordinal that belong to this partition    * @param currentDepth the depth or ordinal in the TaxonomyTree (relative to rootnode of the facetRequest)    * @param maxDepth maximal depth of descendants to be considered here (measured relative to rootnode of the     * facetRequest).    *     * @return the number of nodes, from ordinal down its descendants, of depth<= maxDepth,    * which reside in the current partition, and whose value != 0    */
DECL|method|countOnly
specifier|private
name|int
name|countOnly
parameter_list|(
name|int
name|ordinal
parameter_list|,
name|int
index|[]
name|youngestChild
parameter_list|,
name|int
index|[]
name|olderSibling
parameter_list|,
name|FacetArrays
name|arrays
parameter_list|,
name|int
name|partitionSize
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|endOffset
parameter_list|,
name|int
name|currentDepth
parameter_list|,
name|int
name|maxDepth
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|offset
operator|<=
name|ordinal
condition|)
block|{
comment|// ordinal belongs to the current partition
if|if
condition|(
literal|0
operator|!=
name|facetRequest
operator|.
name|getValueOf
argument_list|(
name|arrays
argument_list|,
name|ordinal
operator|%
name|partitionSize
argument_list|)
condition|)
block|{
name|ret
operator|++
expr_stmt|;
block|}
block|}
comment|// now consider children of ordinal, if not too deep
if|if
condition|(
name|currentDepth
operator|>=
name|maxDepth
condition|)
block|{
return|return
name|ret
return|;
block|}
name|int
name|yc
init|=
name|youngestChild
index|[
name|ordinal
index|]
decl_stmt|;
while|while
condition|(
name|yc
operator|>=
name|endOffset
condition|)
block|{
name|yc
operator|=
name|olderSibling
index|[
name|yc
index|]
expr_stmt|;
block|}
while|while
condition|(
name|yc
operator|>
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
condition|)
block|{
comment|// assuming this is -1, smaller than any legal ordinal
name|ret
operator|+=
name|countOnly
argument_list|(
name|yc
argument_list|,
name|youngestChild
argument_list|,
name|olderSibling
argument_list|,
name|arrays
argument_list|,
name|partitionSize
argument_list|,
name|offset
argument_list|,
name|endOffset
argument_list|,
name|currentDepth
operator|+
literal|1
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|yc
operator|=
name|olderSibling
index|[
name|yc
index|]
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Merge several partitions' {@link IntermediateFacetResult}-s into one of the    * same format    *     * @see FacetResultsHandler#mergeResults(IntermediateFacetResult...)    */
annotation|@
name|Override
DECL|method|mergeResults
specifier|public
name|IntermediateFacetResult
name|mergeResults
parameter_list|(
name|IntermediateFacetResult
modifier|...
name|tmpResults
parameter_list|)
throws|throws
name|ClassCastException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|tmpResults
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|// skip over null tmpResults
for|for
control|(
init|;
operator|(
name|i
operator|<
name|tmpResults
operator|.
name|length
operator|)
operator|&&
operator|(
name|tmpResults
index|[
name|i
index|]
operator|==
literal|null
operator|)
condition|;
name|i
operator|++
control|)
block|{}
if|if
condition|(
name|i
operator|==
name|tmpResults
operator|.
name|length
condition|)
block|{
comment|// all inputs are null
return|return
literal|null
return|;
block|}
comment|// i points to the first non-null input
name|int
name|K
init|=
name|this
operator|.
name|facetRequest
operator|.
name|getNumResults
argument_list|()
decl_stmt|;
comment|// number of best result in each node
name|IntermediateFacetResultWithHash
name|tmpToReturn
init|=
operator|(
name|IntermediateFacetResultWithHash
operator|)
name|tmpResults
index|[
name|i
operator|++
index|]
decl_stmt|;
comment|// now loop over the rest of tmpResults and merge each into tmpToReturn
for|for
control|(
init|;
name|i
operator|<
name|tmpResults
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|IntermediateFacetResultWithHash
name|tfr
init|=
operator|(
name|IntermediateFacetResultWithHash
operator|)
name|tmpResults
index|[
name|i
index|]
decl_stmt|;
name|tmpToReturn
operator|.
name|totalNumOfFacetsConsidered
operator|+=
name|tfr
operator|.
name|totalNumOfFacetsConsidered
expr_stmt|;
if|if
condition|(
name|tfr
operator|.
name|isRootNodeIncluded
condition|)
block|{
name|tmpToReturn
operator|.
name|isRootNodeIncluded
operator|=
literal|true
expr_stmt|;
name|tmpToReturn
operator|.
name|rootNodeValue
operator|=
name|tfr
operator|.
name|rootNodeValue
expr_stmt|;
block|}
comment|// now merge the HashMap of tfr into this of tmpToReturn
name|IntToObjectMap
argument_list|<
name|AACO
argument_list|>
name|tmpToReturnMapToACCOs
init|=
name|tmpToReturn
operator|.
name|mapToAACOs
decl_stmt|;
name|IntToObjectMap
argument_list|<
name|AACO
argument_list|>
name|tfrMapToACCOs
init|=
name|tfr
operator|.
name|mapToAACOs
decl_stmt|;
name|IntIterator
name|tfrIntIterator
init|=
name|tfrMapToACCOs
operator|.
name|keyIterator
argument_list|()
decl_stmt|;
comment|//iterate over all ordinals in tfr that are maps to their children (and the residue over
comment|// non included chilren)
while|while
condition|(
name|tfrIntIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|tfrkey
init|=
name|tfrIntIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|AACO
name|tmpToReturnAACO
init|=
literal|null
decl_stmt|;
if|if
condition|(
literal|null
operator|==
operator|(
name|tmpToReturnAACO
operator|=
name|tmpToReturnMapToACCOs
operator|.
name|get
argument_list|(
name|tfrkey
argument_list|)
operator|)
condition|)
block|{
comment|// if tmpToReturn does not have any kids of tfrkey, map all the kids
comment|// from tfr to it as one package, along with their redisude
name|tmpToReturnMapToACCOs
operator|.
name|put
argument_list|(
name|tfrkey
argument_list|,
name|tfrMapToACCOs
operator|.
name|get
argument_list|(
name|tfrkey
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// merge the best K children of tfrkey as appear in tmpToReturn and in tfr
name|AACO
name|tfrAACO
init|=
name|tfrMapToACCOs
operator|.
name|get
argument_list|(
name|tfrkey
argument_list|)
decl_stmt|;
name|int
name|resLength
init|=
name|tfrAACO
operator|.
name|ordinals
operator|.
name|length
operator|+
name|tmpToReturnAACO
operator|.
name|ordinals
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|K
operator|<
name|resLength
condition|)
block|{
name|resLength
operator|=
name|K
expr_stmt|;
block|}
name|int
index|[]
name|resOrds
init|=
operator|new
name|int
index|[
name|resLength
index|]
decl_stmt|;
name|double
index|[]
name|resVals
init|=
operator|new
name|double
index|[
name|resLength
index|]
decl_stmt|;
name|double
name|resResidue
init|=
name|tmpToReturnAACO
operator|.
name|residue
operator|+
name|tfrAACO
operator|.
name|residue
decl_stmt|;
name|int
name|indexIntoTmpToReturn
init|=
literal|0
decl_stmt|;
name|int
name|indexIntoTFR
init|=
literal|0
decl_stmt|;
name|ACComparator
name|merger
init|=
name|getSuitableACComparator
argument_list|()
decl_stmt|;
comment|// by facet Request
for|for
control|(
name|int
name|indexIntoRes
init|=
literal|0
init|;
name|indexIntoRes
operator|<
name|resLength
condition|;
name|indexIntoRes
operator|++
control|)
block|{
if|if
condition|(
name|indexIntoTmpToReturn
operator|>=
name|tmpToReturnAACO
operator|.
name|ordinals
operator|.
name|length
condition|)
block|{
comment|//tmpToReturnAACO (former result to return) ran out of indices
comment|// it is all merged into resOrds and resVal
name|resOrds
index|[
name|indexIntoRes
index|]
operator|=
name|tfrAACO
operator|.
name|ordinals
index|[
name|indexIntoTFR
index|]
expr_stmt|;
name|resVals
index|[
name|indexIntoRes
index|]
operator|=
name|tfrAACO
operator|.
name|values
index|[
name|indexIntoTFR
index|]
expr_stmt|;
name|indexIntoTFR
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|indexIntoTFR
operator|>=
name|tfrAACO
operator|.
name|ordinals
operator|.
name|length
condition|)
block|{
comment|// tfr ran out of indices
name|resOrds
index|[
name|indexIntoRes
index|]
operator|=
name|tmpToReturnAACO
operator|.
name|ordinals
index|[
name|indexIntoTmpToReturn
index|]
expr_stmt|;
name|resVals
index|[
name|indexIntoRes
index|]
operator|=
name|tmpToReturnAACO
operator|.
name|values
index|[
name|indexIntoTmpToReturn
index|]
expr_stmt|;
name|indexIntoTmpToReturn
operator|++
expr_stmt|;
continue|continue;
block|}
comment|// select which goes now to res: next (ord, value) from tmpToReturn or from tfr:
if|if
condition|(
name|merger
operator|.
name|leftGoesNow
argument_list|(
name|tmpToReturnAACO
operator|.
name|ordinals
index|[
name|indexIntoTmpToReturn
index|]
argument_list|,
name|tmpToReturnAACO
operator|.
name|values
index|[
name|indexIntoTmpToReturn
index|]
argument_list|,
name|tfrAACO
operator|.
name|ordinals
index|[
name|indexIntoTFR
index|]
argument_list|,
name|tfrAACO
operator|.
name|values
index|[
name|indexIntoTFR
index|]
argument_list|)
condition|)
block|{
name|resOrds
index|[
name|indexIntoRes
index|]
operator|=
name|tmpToReturnAACO
operator|.
name|ordinals
index|[
name|indexIntoTmpToReturn
index|]
expr_stmt|;
name|resVals
index|[
name|indexIntoRes
index|]
operator|=
name|tmpToReturnAACO
operator|.
name|values
index|[
name|indexIntoTmpToReturn
index|]
expr_stmt|;
name|indexIntoTmpToReturn
operator|++
expr_stmt|;
block|}
else|else
block|{
name|resOrds
index|[
name|indexIntoRes
index|]
operator|=
name|tfrAACO
operator|.
name|ordinals
index|[
name|indexIntoTFR
index|]
expr_stmt|;
name|resVals
index|[
name|indexIntoRes
index|]
operator|=
name|tfrAACO
operator|.
name|values
index|[
name|indexIntoTFR
index|]
expr_stmt|;
name|indexIntoTFR
operator|++
expr_stmt|;
block|}
block|}
comment|// end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr
comment|// altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of
comment|// tmpToReturn
while|while
condition|(
name|indexIntoTmpToReturn
operator|<
name|tmpToReturnAACO
operator|.
name|ordinals
operator|.
name|length
condition|)
block|{
name|resResidue
operator|+=
name|tmpToReturnAACO
operator|.
name|values
index|[
name|indexIntoTmpToReturn
operator|++
index|]
expr_stmt|;
block|}
while|while
condition|(
name|indexIntoTFR
operator|<
name|tfrAACO
operator|.
name|ordinals
operator|.
name|length
condition|)
block|{
name|resResidue
operator|+=
name|tfrAACO
operator|.
name|values
index|[
name|indexIntoTFR
operator|++
index|]
expr_stmt|;
block|}
comment|//update the list of best kids of tfrkey as appear in tmpToReturn
name|tmpToReturnMapToACCOs
operator|.
name|put
argument_list|(
name|tfrkey
argument_list|,
operator|new
name|AACO
argument_list|(
name|resOrds
argument_list|,
name|resVals
argument_list|,
name|resResidue
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// endof need to merge both AACO -- children and residue for same ordinal
block|}
comment|// endof loop over all ordinals in tfr
block|}
comment|// endof loop over all temporary facet results to merge
return|return
name|tmpToReturn
return|;
block|}
DECL|class|AggregatedCategoryHeap
specifier|private
specifier|static
class|class
name|AggregatedCategoryHeap
extends|extends
name|PriorityQueue
argument_list|<
name|AggregatedCategory
argument_list|>
block|{
DECL|field|merger
specifier|private
name|ACComparator
name|merger
decl_stmt|;
DECL|method|AggregatedCategoryHeap
specifier|public
name|AggregatedCategoryHeap
parameter_list|(
name|int
name|size
parameter_list|,
name|ACComparator
name|merger
parameter_list|)
block|{
name|super
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|this
operator|.
name|merger
operator|=
name|merger
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|lessThan
specifier|protected
name|boolean
name|lessThan
parameter_list|(
name|AggregatedCategory
name|arg1
parameter_list|,
name|AggregatedCategory
name|arg2
parameter_list|)
block|{
return|return
name|merger
operator|.
name|leftGoesNow
argument_list|(
name|arg2
operator|.
name|ordinal
argument_list|,
name|arg2
operator|.
name|value
argument_list|,
name|arg1
operator|.
name|ordinal
argument_list|,
name|arg1
operator|.
name|value
argument_list|)
return|;
block|}
block|}
DECL|class|ResultNodeHeap
specifier|private
specifier|static
class|class
name|ResultNodeHeap
extends|extends
name|PriorityQueue
argument_list|<
name|FacetResultNode
argument_list|>
block|{
DECL|field|merger
specifier|private
name|ACComparator
name|merger
decl_stmt|;
DECL|method|ResultNodeHeap
specifier|public
name|ResultNodeHeap
parameter_list|(
name|int
name|size
parameter_list|,
name|ACComparator
name|merger
parameter_list|)
block|{
name|super
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|this
operator|.
name|merger
operator|=
name|merger
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|lessThan
specifier|protected
name|boolean
name|lessThan
parameter_list|(
name|FacetResultNode
name|arg1
parameter_list|,
name|FacetResultNode
name|arg2
parameter_list|)
block|{
return|return
name|merger
operator|.
name|leftGoesNow
argument_list|(
name|arg2
operator|.
name|getOrdinal
argument_list|()
argument_list|,
name|arg2
operator|.
name|getValue
argument_list|()
argument_list|,
name|arg1
operator|.
name|getOrdinal
argument_list|()
argument_list|,
name|arg1
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * @return the {@link ACComparator} that reflects the order,    * expressed in the {@link FacetRequest}, of     * facets in the {@link FacetResult}.     */
DECL|method|getSuitableACComparator
specifier|private
name|ACComparator
name|getSuitableACComparator
parameter_list|()
block|{
if|if
condition|(
name|facetRequest
operator|.
name|getSortOrder
argument_list|()
operator|==
name|SortOrder
operator|.
name|ASCENDING
condition|)
block|{
switch|switch
condition|(
name|facetRequest
operator|.
name|getSortBy
argument_list|()
condition|)
block|{
case|case
name|VALUE
case|:
return|return
operator|new
name|AscValueACComparator
argument_list|()
return|;
case|case
name|ORDINAL
case|:
return|return
operator|new
name|AscOrdACComparator
argument_list|()
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|facetRequest
operator|.
name|getSortBy
argument_list|()
condition|)
block|{
case|case
name|VALUE
case|:
return|return
operator|new
name|DescValueACComparator
argument_list|()
return|;
case|case
name|ORDINAL
case|:
return|return
operator|new
name|DescOrdACComparator
argument_list|()
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * A comparator of two Aggregated Categories according to the order    * (ascending / descending) and item (ordinal or value) specified in the     * FacetRequest for the FacetResult to be generated    */
DECL|class|ACComparator
specifier|private
specifier|static
specifier|abstract
class|class
name|ACComparator
block|{
DECL|method|ACComparator
name|ACComparator
parameter_list|()
block|{ }
DECL|method|leftGoesNow
specifier|protected
specifier|abstract
name|boolean
name|leftGoesNow
parameter_list|(
name|int
name|ord1
parameter_list|,
name|double
name|val1
parameter_list|,
name|int
name|ord2
parameter_list|,
name|double
name|val2
parameter_list|)
function_decl|;
block|}
DECL|class|AscValueACComparator
specifier|private
specifier|static
specifier|final
class|class
name|AscValueACComparator
extends|extends
name|ACComparator
block|{
DECL|method|AscValueACComparator
name|AscValueACComparator
parameter_list|()
block|{ }
annotation|@
name|Override
DECL|method|leftGoesNow
specifier|protected
name|boolean
name|leftGoesNow
parameter_list|(
name|int
name|ord1
parameter_list|,
name|double
name|val1
parameter_list|,
name|int
name|ord2
parameter_list|,
name|double
name|val2
parameter_list|)
block|{
return|return
operator|(
name|val1
operator|==
name|val2
operator|)
condition|?
operator|(
name|ord1
operator|<
name|ord2
operator|)
else|:
operator|(
name|val1
operator|<
name|val2
operator|)
return|;
block|}
block|}
DECL|class|DescValueACComparator
specifier|private
specifier|static
specifier|final
class|class
name|DescValueACComparator
extends|extends
name|ACComparator
block|{
DECL|method|DescValueACComparator
name|DescValueACComparator
parameter_list|()
block|{ }
annotation|@
name|Override
DECL|method|leftGoesNow
specifier|protected
name|boolean
name|leftGoesNow
parameter_list|(
name|int
name|ord1
parameter_list|,
name|double
name|val1
parameter_list|,
name|int
name|ord2
parameter_list|,
name|double
name|val2
parameter_list|)
block|{
return|return
operator|(
name|val1
operator|==
name|val2
operator|)
condition|?
operator|(
name|ord1
operator|>
name|ord2
operator|)
else|:
operator|(
name|val1
operator|>
name|val2
operator|)
return|;
block|}
block|}
DECL|class|AscOrdACComparator
specifier|private
specifier|static
specifier|final
class|class
name|AscOrdACComparator
extends|extends
name|ACComparator
block|{
DECL|method|AscOrdACComparator
name|AscOrdACComparator
parameter_list|()
block|{ }
annotation|@
name|Override
DECL|method|leftGoesNow
specifier|protected
name|boolean
name|leftGoesNow
parameter_list|(
name|int
name|ord1
parameter_list|,
name|double
name|val1
parameter_list|,
name|int
name|ord2
parameter_list|,
name|double
name|val2
parameter_list|)
block|{
return|return
operator|(
name|ord1
operator|<
name|ord2
operator|)
return|;
block|}
block|}
DECL|class|DescOrdACComparator
specifier|private
specifier|static
specifier|final
class|class
name|DescOrdACComparator
extends|extends
name|ACComparator
block|{
DECL|method|DescOrdACComparator
name|DescOrdACComparator
parameter_list|()
block|{ }
annotation|@
name|Override
DECL|method|leftGoesNow
specifier|protected
name|boolean
name|leftGoesNow
parameter_list|(
name|int
name|ord1
parameter_list|,
name|double
name|val1
parameter_list|,
name|int
name|ord2
parameter_list|,
name|double
name|val2
parameter_list|)
block|{
return|return
operator|(
name|ord1
operator|>
name|ord2
operator|)
return|;
block|}
block|}
comment|/**    * Intermediate result to hold counts from one or more partitions processed    * thus far. Its main field, constructor parameter<i>mapToAACOs</i>, is a map    * from ordinals to AACOs. The AACOs mapped to contain ordinals and values    * encountered in the count arrays of the partitions processed thus far. The    * ordinals mapped from are their parents, and they may be not contained in    * the partitions processed thus far. All nodes belong to the taxonomy subtree    * defined at the facet request, constructor parameter<i>facetReq</i>, by its    * root and depth.    */
DECL|class|IntermediateFacetResultWithHash
specifier|public
specifier|static
class|class
name|IntermediateFacetResultWithHash
implements|implements
name|IntermediateFacetResult
block|{
DECL|field|mapToAACOs
specifier|protected
name|IntToObjectMap
argument_list|<
name|AACO
argument_list|>
name|mapToAACOs
decl_stmt|;
DECL|field|facetRequest
name|FacetRequest
name|facetRequest
decl_stmt|;
DECL|field|isRootNodeIncluded
name|boolean
name|isRootNodeIncluded
decl_stmt|;
comment|// among the ordinals in the partitions
comment|// processed thus far
DECL|field|rootNodeValue
name|double
name|rootNodeValue
decl_stmt|;
comment|// the value of it, in case encountered.
DECL|field|totalNumOfFacetsConsidered
name|int
name|totalNumOfFacetsConsidered
decl_stmt|;
comment|// total number of facets
comment|// which belong to facetRequest subtree and have value != 0,
comment|// and have been encountered thus far in the partitions processed.
comment|// root node of result tree is not included in this count.
DECL|method|IntermediateFacetResultWithHash
specifier|public
name|IntermediateFacetResultWithHash
parameter_list|(
name|FacetRequest
name|facetReq
parameter_list|,
name|IntToObjectMap
argument_list|<
name|AACO
argument_list|>
name|mapToAACOs
parameter_list|)
block|{
name|this
operator|.
name|mapToAACOs
operator|=
name|mapToAACOs
expr_stmt|;
name|this
operator|.
name|facetRequest
operator|=
name|facetReq
expr_stmt|;
name|this
operator|.
name|isRootNodeIncluded
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|rootNodeValue
operator|=
literal|0.0
expr_stmt|;
name|this
operator|.
name|totalNumOfFacetsConsidered
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getFacetRequest
specifier|public
name|FacetRequest
name|getFacetRequest
parameter_list|()
block|{
return|return
name|this
operator|.
name|facetRequest
return|;
block|}
block|}
comment|// endof FacetResultWithHash
comment|/**    * Maintains info of one entry in the filled up count array:    * an ordinal number of a category and the value aggregated for it     * (typically, that value is the count for that ordinal).    */
DECL|class|AggregatedCategory
specifier|private
specifier|static
specifier|final
class|class
name|AggregatedCategory
block|{
DECL|field|ordinal
name|int
name|ordinal
decl_stmt|;
DECL|field|value
name|double
name|value
decl_stmt|;
DECL|method|AggregatedCategory
name|AggregatedCategory
parameter_list|(
name|int
name|ord
parameter_list|,
name|double
name|val
parameter_list|)
block|{
name|this
operator|.
name|ordinal
operator|=
name|ord
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|val
expr_stmt|;
block|}
block|}
comment|/**    * Maintains an array of<code>AggregatedCategory</code>. For space consideration, this is implemented as     * a pair of arrays,<i>ordinals</i> and<i>values</i>, rather than one array of pairs.    * Enumerated in<i>ordinals</i> are siblings,      * potential nodes of the {@link FacetResult} tree      * (i.e., the descendants of the root node, no deeper than the specified depth).    * No more than K ( = {@link FacetRequest#getNumResults()})     * siblings are enumerated, and      *<i>residue</i> holds the sum of values of the siblings rejected from the     * enumerated top K.    * @lucene.internal    */
DECL|class|AACO
specifier|protected
specifier|static
specifier|final
class|class
name|AACO
block|{
DECL|field|ordinals
name|int
index|[]
name|ordinals
decl_stmt|;
comment|// ordinals of the best K children, sorted from best to least
DECL|field|values
name|double
index|[]
name|values
decl_stmt|;
comment|// the respective values for these children
DECL|field|residue
name|double
name|residue
decl_stmt|;
comment|// sum of values of all other children, that did not get into top K
DECL|method|AACO
name|AACO
parameter_list|(
name|int
index|[]
name|ords
parameter_list|,
name|double
index|[]
name|vals
parameter_list|,
name|double
name|r
parameter_list|)
block|{
name|this
operator|.
name|ordinals
operator|=
name|ords
expr_stmt|;
name|this
operator|.
name|values
operator|=
name|vals
expr_stmt|;
name|this
operator|.
name|residue
operator|=
name|r
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|/**    * Recursively label the first facetRequest.getNumLabel() sub results     * of the root of a given {@link FacetResult}, or of an already labeled node in it.    * I.e., a node is labeled only if it is the root or all its ancestors are labeled.     */
DECL|method|labelResult
specifier|public
name|void
name|labelResult
parameter_list|(
name|FacetResult
name|facetResult
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|facetResult
operator|==
literal|null
condition|)
block|{
return|return;
comment|// any result to label?
block|}
name|FacetResultNode
name|rootNode
init|=
name|facetResult
operator|.
name|getFacetResultNode
argument_list|()
decl_stmt|;
name|recursivelyLabel
argument_list|(
name|rootNode
argument_list|,
name|facetRequest
operator|.
name|getNumLabel
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|recursivelyLabel
specifier|private
name|void
name|recursivelyLabel
parameter_list|(
name|FacetResultNode
name|node
parameter_list|,
name|int
name|numToLabel
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|node
operator|.
name|getLabel
argument_list|(
name|this
operator|.
name|taxonomyReader
argument_list|)
expr_stmt|;
comment|// attach a label -- category path -- to the node
if|if
condition|(
literal|null
operator|==
name|node
operator|.
name|getSubResults
argument_list|()
condition|)
block|{
return|return;
comment|// if node has no children -- done
block|}
comment|// otherwise, label the first numToLabel of these children, and recursively -- their children.
name|int
name|numLabeled
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FacetResultNode
name|frn
range|:
name|node
operator|.
name|getSubResults
argument_list|()
control|)
block|{
comment|// go over the children of node from first to last, no more than numToLable of them
name|recursivelyLabel
argument_list|(
name|frn
argument_list|,
name|numToLabel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|numLabeled
operator|>=
name|numToLabel
condition|)
block|{
return|return;
block|}
block|}
block|}
annotation|@
name|Override
comment|// verifies that the children of each node are sorted by the order
comment|// specified by the facetRequest.
comment|// the values in these nodes may have changed due to a re-count, for example
comment|// following the accumulation by Sampling.
comment|// so now we test and re-order if necessary.
DECL|method|rearrangeFacetResult
specifier|public
name|FacetResult
name|rearrangeFacetResult
parameter_list|(
name|FacetResult
name|facetResult
parameter_list|)
block|{
name|PriorityQueue
argument_list|<
name|FacetResultNode
argument_list|>
name|nodesHeap
init|=
operator|new
name|ResultNodeHeap
argument_list|(
name|this
operator|.
name|facetRequest
operator|.
name|getNumResults
argument_list|()
argument_list|,
name|this
operator|.
name|getSuitableACComparator
argument_list|()
argument_list|)
decl_stmt|;
name|MutableFacetResultNode
name|topFrn
init|=
operator|(
name|MutableFacetResultNode
operator|)
name|facetResult
operator|.
name|getFacetResultNode
argument_list|()
decl_stmt|;
comment|// safe cast
name|rearrangeChilrenOfNode
argument_list|(
name|topFrn
argument_list|,
name|nodesHeap
argument_list|)
expr_stmt|;
return|return
name|facetResult
return|;
block|}
DECL|method|rearrangeChilrenOfNode
specifier|private
name|void
name|rearrangeChilrenOfNode
parameter_list|(
name|FacetResultNode
name|node
parameter_list|,
name|PriorityQueue
argument_list|<
name|FacetResultNode
argument_list|>
name|nodesHeap
parameter_list|)
block|{
name|nodesHeap
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// just to be safe
for|for
control|(
name|FacetResultNode
name|frn
range|:
name|node
operator|.
name|getSubResults
argument_list|()
control|)
block|{
name|nodesHeap
operator|.
name|add
argument_list|(
name|frn
argument_list|)
expr_stmt|;
block|}
name|int
name|size
init|=
name|nodesHeap
operator|.
name|size
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|FacetResultNode
argument_list|>
name|subResults
init|=
operator|new
name|ArrayList
argument_list|<
name|FacetResultNode
argument_list|>
argument_list|(
name|size
argument_list|)
decl_stmt|;
while|while
condition|(
name|nodesHeap
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|subResults
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|nodesHeap
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
name|MutableFacetResultNode
operator|)
name|node
operator|)
operator|.
name|setSubResults
argument_list|(
name|subResults
argument_list|)
expr_stmt|;
for|for
control|(
name|FacetResultNode
name|frn
range|:
name|node
operator|.
name|getSubResults
argument_list|()
control|)
block|{
name|rearrangeChilrenOfNode
argument_list|(
name|frn
argument_list|,
name|nodesHeap
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|renderFacetResult
specifier|public
name|FacetResult
name|renderFacetResult
parameter_list|(
name|IntermediateFacetResult
name|tmpResult
parameter_list|)
throws|throws
name|IOException
block|{
name|IntermediateFacetResultWithHash
name|tmp
init|=
operator|(
name|IntermediateFacetResultWithHash
operator|)
name|tmpResult
decl_stmt|;
name|int
name|ordinal
init|=
name|this
operator|.
name|taxonomyReader
operator|.
name|getOrdinal
argument_list|(
name|this
operator|.
name|facetRequest
operator|.
name|categoryPath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|==
literal|null
operator|)
operator|||
operator|(
name|ordinal
operator|==
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|double
name|value
init|=
name|Double
operator|.
name|NaN
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|isRootNodeIncluded
condition|)
block|{
name|value
operator|=
name|tmp
operator|.
name|rootNodeValue
expr_stmt|;
block|}
name|MutableFacetResultNode
name|root
init|=
name|generateNode
argument_list|(
name|ordinal
argument_list|,
name|value
argument_list|,
name|tmp
operator|.
name|mapToAACOs
argument_list|)
decl_stmt|;
return|return
operator|new
name|FacetResult
argument_list|(
name|tmp
operator|.
name|facetRequest
argument_list|,
name|root
argument_list|,
name|tmp
operator|.
name|totalNumOfFacetsConsidered
argument_list|)
return|;
block|}
DECL|method|generateNode
specifier|private
name|MutableFacetResultNode
name|generateNode
parameter_list|(
name|int
name|ordinal
parameter_list|,
name|double
name|val
parameter_list|,
name|IntToObjectMap
argument_list|<
name|AACO
argument_list|>
name|mapToAACOs
parameter_list|)
block|{
name|MutableFacetResultNode
name|node
init|=
operator|new
name|MutableFacetResultNode
argument_list|(
name|ordinal
argument_list|,
name|val
argument_list|)
decl_stmt|;
name|AACO
name|aaco
init|=
name|mapToAACOs
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|aaco
condition|)
block|{
return|return
name|node
return|;
block|}
name|List
argument_list|<
name|FacetResultNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|FacetResultNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aaco
operator|.
name|ordinals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|generateNode
argument_list|(
name|aaco
operator|.
name|ordinals
index|[
name|i
index|]
argument_list|,
name|aaco
operator|.
name|values
index|[
name|i
index|]
argument_list|,
name|mapToAACOs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|setSubResults
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|node
operator|.
name|setResidue
argument_list|(
name|aaco
operator|.
name|residue
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
block|}
end_class
end_unit
