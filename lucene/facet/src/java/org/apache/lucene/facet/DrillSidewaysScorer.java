begin_unit
begin_package
DECL|package|org.apache.lucene.facet
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|PostingsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BulkScorer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Collector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|LeafCollector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Scorer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TwoPhaseIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Weight
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|FixedBitSet
import|;
end_import
begin_class
DECL|class|DrillSidewaysScorer
class|class
name|DrillSidewaysScorer
extends|extends
name|BulkScorer
block|{
comment|//private static boolean DEBUG = false;
DECL|field|drillDownCollector
specifier|private
specifier|final
name|Collector
name|drillDownCollector
decl_stmt|;
DECL|field|drillDownLeafCollector
specifier|private
name|LeafCollector
name|drillDownLeafCollector
decl_stmt|;
DECL|field|dims
specifier|private
specifier|final
name|DocsAndCost
index|[]
name|dims
decl_stmt|;
comment|// DrillDown DocsEnums:
DECL|field|baseScorer
specifier|private
specifier|final
name|Scorer
name|baseScorer
decl_stmt|;
DECL|field|context
specifier|private
specifier|final
name|LeafReaderContext
name|context
decl_stmt|;
DECL|field|scoreSubDocsAtOnce
specifier|final
name|boolean
name|scoreSubDocsAtOnce
decl_stmt|;
DECL|field|CHUNK
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK
init|=
literal|2048
decl_stmt|;
DECL|field|MASK
specifier|private
specifier|static
specifier|final
name|int
name|MASK
init|=
name|CHUNK
operator|-
literal|1
decl_stmt|;
DECL|field|collectDocID
specifier|private
name|int
name|collectDocID
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|collectScore
specifier|private
name|float
name|collectScore
decl_stmt|;
DECL|method|DrillSidewaysScorer
name|DrillSidewaysScorer
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|,
name|Scorer
name|baseScorer
parameter_list|,
name|Collector
name|drillDownCollector
parameter_list|,
name|DocsAndCost
index|[]
name|dims
parameter_list|,
name|boolean
name|scoreSubDocsAtOnce
parameter_list|)
block|{
name|this
operator|.
name|dims
operator|=
name|dims
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|this
operator|.
name|baseScorer
operator|=
name|baseScorer
expr_stmt|;
name|this
operator|.
name|drillDownCollector
operator|=
name|drillDownCollector
expr_stmt|;
name|this
operator|.
name|scoreSubDocsAtOnce
operator|=
name|scoreSubDocsAtOnce
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|baseScorer
operator|.
name|cost
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|score
specifier|public
name|int
name|score
parameter_list|(
name|LeafCollector
name|collector
parameter_list|,
name|Bits
name|acceptDocs
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|maxDoc
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|min
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"min must be 0, got "
operator|+
name|min
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxDoc
operator|!=
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxDoc must be Integer.MAX_VALUE"
argument_list|)
throw|;
block|}
comment|//if (DEBUG) {
comment|//  System.out.println("\nscore: reader=" + context.reader());
comment|//}
comment|//System.out.println("score r=" + context.reader());
name|FakeScorer
name|scorer
init|=
operator|new
name|FakeScorer
argument_list|()
decl_stmt|;
name|collector
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
if|if
condition|(
name|drillDownCollector
operator|!=
literal|null
condition|)
block|{
name|drillDownLeafCollector
operator|=
name|drillDownCollector
operator|.
name|getLeafCollector
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|drillDownLeafCollector
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drillDownLeafCollector
operator|=
literal|null
expr_stmt|;
block|}
for|for
control|(
name|DocsAndCost
name|dim
range|:
name|dims
control|)
block|{
name|dim
operator|.
name|sidewaysLeafCollector
operator|=
name|dim
operator|.
name|sidewaysCollector
operator|.
name|getLeafCollector
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|dim
operator|.
name|sidewaysLeafCollector
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
block|}
comment|// TODO: if we ever allow null baseScorer ... it will
comment|// mean we DO score docs out of order ... hmm, or if we
comment|// change up the order of the conjuntions below
assert|assert
name|baseScorer
operator|!=
literal|null
assert|;
comment|// some scorers, eg ReqExlScorer, can hit NPE if cost is called after nextDoc
name|long
name|baseQueryCost
init|=
name|baseScorer
operator|.
name|cost
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numDims
init|=
name|dims
operator|.
name|length
decl_stmt|;
name|long
name|drillDownCost
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|dim
init|=
literal|0
init|;
name|dim
operator|<
name|numDims
condition|;
name|dim
operator|++
control|)
block|{
name|drillDownCost
operator|+=
name|dims
index|[
name|dim
index|]
operator|.
name|approximation
operator|.
name|cost
argument_list|()
expr_stmt|;
block|}
name|long
name|drillDownAdvancedCost
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|numDims
operator|>
literal|1
condition|)
block|{
name|drillDownAdvancedCost
operator|=
name|dims
index|[
literal|1
index|]
operator|.
name|approximation
operator|.
name|cost
argument_list|()
expr_stmt|;
block|}
comment|// Position all scorers to their first matching doc:
name|baseScorer
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
for|for
control|(
name|DocsAndCost
name|dim
range|:
name|dims
control|)
block|{
name|dim
operator|.
name|approximation
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
block|}
comment|/*     System.out.println("\nbaseDocID=" + baseScorer.docID() + " est=" + estBaseHitCount);     System.out.println("  maxDoc=" + context.reader().maxDoc());     System.out.println("  maxCost=" + maxCost);     System.out.println("  dims[0].freq=" + dims[0].freq);     if (numDims> 1) {       System.out.println("  dims[1].freq=" + dims[1].freq);     }     */
if|if
condition|(
name|scoreSubDocsAtOnce
operator|||
name|baseQueryCost
operator|<
name|drillDownCost
operator|/
literal|10
condition|)
block|{
comment|//System.out.println("queryFirst: baseScorer=" + baseScorer + " disis.length=" + disis.length + " bits.length=" + bits.length);
name|doQueryFirstScoring
argument_list|(
name|acceptDocs
argument_list|,
name|collector
argument_list|,
name|dims
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numDims
operator|>
literal|1
operator|&&
name|drillDownAdvancedCost
operator|<
name|baseQueryCost
operator|/
literal|10
condition|)
block|{
comment|//System.out.println("drillDownAdvance");
name|doDrillDownAdvanceScoring
argument_list|(
name|acceptDocs
argument_list|,
name|collector
argument_list|,
name|dims
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//System.out.println("union");
name|doUnionScoring
argument_list|(
name|acceptDocs
argument_list|,
name|collector
argument_list|,
name|dims
argument_list|)
expr_stmt|;
block|}
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
comment|/** Used when base query is highly constraining vs the    *  drilldowns, or when the docs must be scored at once    *  (i.e., like BooleanScorer2, not BooleanScorer).  In    *  this case we just .next() on base and .advance() on    *  the dim filters. */
DECL|method|doQueryFirstScoring
specifier|private
name|void
name|doQueryFirstScoring
parameter_list|(
name|Bits
name|acceptDocs
parameter_list|,
name|LeafCollector
name|collector
parameter_list|,
name|DocsAndCost
index|[]
name|dims
parameter_list|)
throws|throws
name|IOException
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("  doQueryFirstScoring");
comment|//}
name|int
name|docID
init|=
name|baseScorer
operator|.
name|docID
argument_list|()
decl_stmt|;
name|nextDoc
label|:
while|while
condition|(
name|docID
operator|!=
name|PostingsEnum
operator|.
name|NO_MORE_DOCS
condition|)
block|{
if|if
condition|(
name|acceptDocs
operator|!=
literal|null
operator|&&
name|acceptDocs
operator|.
name|get
argument_list|(
name|docID
argument_list|)
operator|==
literal|false
condition|)
block|{
name|docID
operator|=
name|baseScorer
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|LeafCollector
name|failedCollector
init|=
literal|null
decl_stmt|;
for|for
control|(
name|DocsAndCost
name|dim
range|:
name|dims
control|)
block|{
comment|// TODO: should we sort this 2nd dimension of
comment|// docsEnums from most frequent to least?
if|if
condition|(
name|dim
operator|.
name|approximation
operator|.
name|docID
argument_list|()
operator|<
name|docID
condition|)
block|{
name|dim
operator|.
name|approximation
operator|.
name|advance
argument_list|(
name|docID
argument_list|)
expr_stmt|;
block|}
name|boolean
name|matches
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|dim
operator|.
name|approximation
operator|.
name|docID
argument_list|()
operator|==
name|docID
condition|)
block|{
if|if
condition|(
name|dim
operator|.
name|twoPhase
operator|==
literal|null
condition|)
block|{
name|matches
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|matches
operator|=
name|dim
operator|.
name|twoPhase
operator|.
name|matches
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|matches
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|failedCollector
operator|!=
literal|null
condition|)
block|{
comment|// More than one dim fails on this document, so
comment|// it's neither a hit nor a near-miss; move to
comment|// next doc:
name|docID
operator|=
name|baseScorer
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
continue|continue
name|nextDoc
continue|;
block|}
else|else
block|{
name|failedCollector
operator|=
name|dim
operator|.
name|sidewaysLeafCollector
expr_stmt|;
block|}
block|}
block|}
name|collectDocID
operator|=
name|docID
expr_stmt|;
comment|// TODO: we could score on demand instead since we are
comment|// daat here:
name|collectScore
operator|=
name|baseScorer
operator|.
name|score
argument_list|()
expr_stmt|;
if|if
condition|(
name|failedCollector
operator|==
literal|null
condition|)
block|{
comment|// Hit passed all filters, so it's "real":
name|collectHit
argument_list|(
name|collector
argument_list|,
name|dims
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Hit missed exactly one filter:
name|collectNearMiss
argument_list|(
name|failedCollector
argument_list|)
expr_stmt|;
block|}
name|docID
operator|=
name|baseScorer
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Used when drill downs are highly constraining vs    *  baseQuery. */
DECL|method|doDrillDownAdvanceScoring
specifier|private
name|void
name|doDrillDownAdvanceScoring
parameter_list|(
name|Bits
name|acceptDocs
parameter_list|,
name|LeafCollector
name|collector
parameter_list|,
name|DocsAndCost
index|[]
name|dims
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|maxDoc
init|=
name|context
operator|.
name|reader
argument_list|()
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numDims
init|=
name|dims
operator|.
name|length
decl_stmt|;
comment|//if (DEBUG) {
comment|//  System.out.println("  doDrillDownAdvanceScoring");
comment|//}
comment|// TODO: maybe a class like BS, instead of parallel arrays
name|int
index|[]
name|filledSlots
init|=
operator|new
name|int
index|[
name|CHUNK
index|]
decl_stmt|;
name|int
index|[]
name|docIDs
init|=
operator|new
name|int
index|[
name|CHUNK
index|]
decl_stmt|;
name|float
index|[]
name|scores
init|=
operator|new
name|float
index|[
name|CHUNK
index|]
decl_stmt|;
name|int
index|[]
name|missingDims
init|=
operator|new
name|int
index|[
name|CHUNK
index|]
decl_stmt|;
name|int
index|[]
name|counts
init|=
operator|new
name|int
index|[
name|CHUNK
index|]
decl_stmt|;
name|docIDs
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|int
name|nextChunkStart
init|=
name|CHUNK
decl_stmt|;
specifier|final
name|FixedBitSet
name|seen
init|=
operator|new
name|FixedBitSet
argument_list|(
name|CHUNK
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("\ncycle nextChunkStart=" + nextChunkStart + " docIds[0]=" + docIDs[0]);
comment|//}
comment|// First dim:
comment|//if (DEBUG) {
comment|//  System.out.println("  dim0");
comment|//}
name|DocsAndCost
name|dc
init|=
name|dims
index|[
literal|0
index|]
decl_stmt|;
name|int
name|docID
init|=
name|dc
operator|.
name|approximation
operator|.
name|docID
argument_list|()
decl_stmt|;
while|while
condition|(
name|docID
operator|<
name|nextChunkStart
condition|)
block|{
if|if
condition|(
name|acceptDocs
operator|==
literal|null
operator|||
name|acceptDocs
operator|.
name|get
argument_list|(
name|docID
argument_list|)
condition|)
block|{
name|int
name|slot
init|=
name|docID
operator|&
name|MASK
decl_stmt|;
if|if
condition|(
name|docIDs
index|[
name|slot
index|]
operator|!=
name|docID
operator|&&
operator|(
name|dc
operator|.
name|twoPhase
operator|==
literal|null
operator|||
name|dc
operator|.
name|twoPhase
operator|.
name|matches
argument_list|()
operator|)
condition|)
block|{
name|seen
operator|.
name|set
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|// Mark slot as valid:
comment|//if (DEBUG) {
comment|//  System.out.println("    set docID=" + docID + " id=" + context.reader().document(docID).get("id"));
comment|//}
name|docIDs
index|[
name|slot
index|]
operator|=
name|docID
expr_stmt|;
name|missingDims
index|[
name|slot
index|]
operator|=
literal|1
expr_stmt|;
name|counts
index|[
name|slot
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|docID
operator|=
name|dc
operator|.
name|approximation
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
block|}
comment|// Second dim:
comment|//if (DEBUG) {
comment|//  System.out.println("  dim1");
comment|//}
name|dc
operator|=
name|dims
index|[
literal|1
index|]
expr_stmt|;
name|docID
operator|=
name|dc
operator|.
name|approximation
operator|.
name|docID
argument_list|()
expr_stmt|;
while|while
condition|(
name|docID
operator|<
name|nextChunkStart
condition|)
block|{
if|if
condition|(
name|acceptDocs
operator|==
literal|null
operator|||
name|acceptDocs
operator|.
name|get
argument_list|(
name|docID
argument_list|)
operator|&&
operator|(
name|dc
operator|.
name|twoPhase
operator|==
literal|null
operator|||
name|dc
operator|.
name|twoPhase
operator|.
name|matches
argument_list|()
operator|)
condition|)
block|{
name|int
name|slot
init|=
name|docID
operator|&
name|MASK
decl_stmt|;
if|if
condition|(
name|docIDs
index|[
name|slot
index|]
operator|!=
name|docID
condition|)
block|{
comment|// Mark slot as valid:
name|seen
operator|.
name|set
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|//if (DEBUG) {
comment|//  System.out.println("    set docID=" + docID + " missingDim=0 id=" + context.reader().document(docID).get("id"));
comment|//}
name|docIDs
index|[
name|slot
index|]
operator|=
name|docID
expr_stmt|;
name|missingDims
index|[
name|slot
index|]
operator|=
literal|0
expr_stmt|;
name|counts
index|[
name|slot
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: single-valued dims will always be true
comment|// below; we could somehow specialize
if|if
condition|(
name|missingDims
index|[
name|slot
index|]
operator|>=
literal|1
condition|)
block|{
name|missingDims
index|[
name|slot
index|]
operator|=
literal|2
expr_stmt|;
name|counts
index|[
name|slot
index|]
operator|=
literal|2
expr_stmt|;
comment|//if (DEBUG) {
comment|//  System.out.println("    set docID=" + docID + " missingDim=2 id=" + context.reader().document(docID).get("id"));
comment|//}
block|}
else|else
block|{
name|counts
index|[
name|slot
index|]
operator|=
literal|1
expr_stmt|;
comment|//if (DEBUG) {
comment|//  System.out.println("    set docID=" + docID + " missingDim=" + missingDims[slot] + " id=" + context.reader().document(docID).get("id"));
comment|//}
block|}
block|}
block|}
name|docID
operator|=
name|dc
operator|.
name|approximation
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
block|}
comment|// After this we can "upgrade" to conjunction, because
comment|// any doc not seen by either dim 0 or dim 1 cannot be
comment|// a hit or a near miss:
comment|//if (DEBUG) {
comment|//  System.out.println("  baseScorer");
comment|//}
comment|// Fold in baseScorer, using advance:
name|int
name|filledCount
init|=
literal|0
decl_stmt|;
name|int
name|slot0
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|slot0
operator|<
name|CHUNK
operator|&&
operator|(
name|slot0
operator|=
name|seen
operator|.
name|nextSetBit
argument_list|(
name|slot0
argument_list|)
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|int
name|ddDocID
init|=
name|docIDs
index|[
name|slot0
index|]
decl_stmt|;
assert|assert
name|ddDocID
operator|!=
operator|-
literal|1
assert|;
name|int
name|baseDocID
init|=
name|baseScorer
operator|.
name|docID
argument_list|()
decl_stmt|;
if|if
condition|(
name|baseDocID
operator|<
name|ddDocID
condition|)
block|{
name|baseDocID
operator|=
name|baseScorer
operator|.
name|advance
argument_list|(
name|ddDocID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|baseDocID
operator|==
name|ddDocID
condition|)
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("    keep docID=" + ddDocID + " id=" + context.reader().document(ddDocID).get("id"));
comment|//}
name|scores
index|[
name|slot0
index|]
operator|=
name|baseScorer
operator|.
name|score
argument_list|()
expr_stmt|;
name|filledSlots
index|[
name|filledCount
operator|++
index|]
operator|=
name|slot0
expr_stmt|;
name|counts
index|[
name|slot0
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("    no docID=" + ddDocID + " id=" + context.reader().document(ddDocID).get("id"));
comment|//}
name|docIDs
index|[
name|slot0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|// TODO: we could jump slot0 forward to the
comment|// baseDocID ... but we'd need to set docIDs for
comment|// intervening slots to -1
block|}
name|slot0
operator|++
expr_stmt|;
block|}
name|seen
operator|.
name|clear
argument_list|(
literal|0
argument_list|,
name|CHUNK
argument_list|)
expr_stmt|;
if|if
condition|(
name|filledCount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nextChunkStart
operator|>=
name|maxDoc
condition|)
block|{
break|break;
block|}
name|nextChunkStart
operator|+=
name|CHUNK
expr_stmt|;
continue|continue;
block|}
comment|// TODO: factor this out& share w/ union scorer,
comment|// except we start from dim=2 instead:
for|for
control|(
name|int
name|dim
init|=
literal|2
init|;
name|dim
operator|<
name|numDims
condition|;
name|dim
operator|++
control|)
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("  dim=" + dim + " [" + dims[dim].dim + "]");
comment|//}
name|dc
operator|=
name|dims
index|[
name|dim
index|]
expr_stmt|;
name|docID
operator|=
name|dc
operator|.
name|approximation
operator|.
name|docID
argument_list|()
expr_stmt|;
while|while
condition|(
name|docID
operator|<
name|nextChunkStart
condition|)
block|{
name|int
name|slot
init|=
name|docID
operator|&
name|MASK
decl_stmt|;
if|if
condition|(
name|docIDs
index|[
name|slot
index|]
operator|==
name|docID
operator|&&
name|counts
index|[
name|slot
index|]
operator|>=
name|dim
operator|&&
operator|(
name|dc
operator|.
name|twoPhase
operator|==
literal|null
operator|||
name|dc
operator|.
name|twoPhase
operator|.
name|matches
argument_list|()
operator|)
condition|)
block|{
comment|// TODO: single-valued dims will always be true
comment|// below; we could somehow specialize
if|if
condition|(
name|missingDims
index|[
name|slot
index|]
operator|>=
name|dim
condition|)
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("    set docID=" + docID + " count=" + (dim+2));
comment|//}
name|missingDims
index|[
name|slot
index|]
operator|=
name|dim
operator|+
literal|1
expr_stmt|;
name|counts
index|[
name|slot
index|]
operator|=
name|dim
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("    set docID=" + docID + " missing count=" + (dim+1));
comment|//}
name|counts
index|[
name|slot
index|]
operator|=
name|dim
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|// TODO: sometimes use advance?
name|docID
operator|=
name|dc
operator|.
name|approximation
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Collect:
comment|//if (DEBUG) {
comment|//  System.out.println("  now collect: " + filledCount + " hits");
comment|//}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|filledCount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|slot
init|=
name|filledSlots
index|[
name|i
index|]
decl_stmt|;
name|collectDocID
operator|=
name|docIDs
index|[
name|slot
index|]
expr_stmt|;
name|collectScore
operator|=
name|scores
index|[
name|slot
index|]
expr_stmt|;
comment|//if (DEBUG) {
comment|//  System.out.println("    docID=" + docIDs[slot] + " count=" + counts[slot]);
comment|//}
if|if
condition|(
name|counts
index|[
name|slot
index|]
operator|==
literal|1
operator|+
name|numDims
condition|)
block|{
name|collectHit
argument_list|(
name|collector
argument_list|,
name|dims
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|counts
index|[
name|slot
index|]
operator|==
name|numDims
condition|)
block|{
name|collectNearMiss
argument_list|(
name|dims
index|[
name|missingDims
index|[
name|slot
index|]
index|]
operator|.
name|sidewaysLeafCollector
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nextChunkStart
operator|>=
name|maxDoc
condition|)
block|{
break|break;
block|}
name|nextChunkStart
operator|+=
name|CHUNK
expr_stmt|;
block|}
block|}
DECL|method|doUnionScoring
specifier|private
name|void
name|doUnionScoring
parameter_list|(
name|Bits
name|acceptDocs
parameter_list|,
name|LeafCollector
name|collector
parameter_list|,
name|DocsAndCost
index|[]
name|dims
parameter_list|)
throws|throws
name|IOException
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("  doUnionScoring");
comment|//}
specifier|final
name|int
name|maxDoc
init|=
name|context
operator|.
name|reader
argument_list|()
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numDims
init|=
name|dims
operator|.
name|length
decl_stmt|;
comment|// TODO: maybe a class like BS, instead of parallel arrays
name|int
index|[]
name|filledSlots
init|=
operator|new
name|int
index|[
name|CHUNK
index|]
decl_stmt|;
name|int
index|[]
name|docIDs
init|=
operator|new
name|int
index|[
name|CHUNK
index|]
decl_stmt|;
name|float
index|[]
name|scores
init|=
operator|new
name|float
index|[
name|CHUNK
index|]
decl_stmt|;
name|int
index|[]
name|missingDims
init|=
operator|new
name|int
index|[
name|CHUNK
index|]
decl_stmt|;
name|int
index|[]
name|counts
init|=
operator|new
name|int
index|[
name|CHUNK
index|]
decl_stmt|;
name|docIDs
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|// NOTE: this is basically a specialized version of
comment|// BooleanScorer, to the minShouldMatch=N-1 case, but
comment|// carefully tracking which dimension failed to match
name|int
name|nextChunkStart
init|=
name|CHUNK
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("\ncycle nextChunkStart=" + nextChunkStart + " docIds[0]=" + docIDs[0]);
comment|//}
name|int
name|filledCount
init|=
literal|0
decl_stmt|;
name|int
name|docID
init|=
name|baseScorer
operator|.
name|docID
argument_list|()
decl_stmt|;
comment|//if (DEBUG) {
comment|//  System.out.println("  base docID=" + docID);
comment|//}
while|while
condition|(
name|docID
operator|<
name|nextChunkStart
condition|)
block|{
if|if
condition|(
name|acceptDocs
operator|==
literal|null
operator|||
name|acceptDocs
operator|.
name|get
argument_list|(
name|docID
argument_list|)
condition|)
block|{
name|int
name|slot
init|=
name|docID
operator|&
name|MASK
decl_stmt|;
comment|//if (DEBUG) {
comment|//  System.out.println("    docIDs[slot=" + slot + "]=" + docID + " id=" + context.reader().document(docID).get("id"));
comment|//}
comment|// Mark slot as valid:
assert|assert
name|docIDs
index|[
name|slot
index|]
operator|!=
name|docID
operator|:
literal|"slot="
operator|+
name|slot
operator|+
literal|" docID="
operator|+
name|docID
assert|;
name|docIDs
index|[
name|slot
index|]
operator|=
name|docID
expr_stmt|;
name|scores
index|[
name|slot
index|]
operator|=
name|baseScorer
operator|.
name|score
argument_list|()
expr_stmt|;
name|filledSlots
index|[
name|filledCount
operator|++
index|]
operator|=
name|slot
expr_stmt|;
name|missingDims
index|[
name|slot
index|]
operator|=
literal|0
expr_stmt|;
name|counts
index|[
name|slot
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|docID
operator|=
name|baseScorer
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|filledCount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nextChunkStart
operator|>=
name|maxDoc
condition|)
block|{
break|break;
block|}
name|nextChunkStart
operator|+=
name|CHUNK
expr_stmt|;
continue|continue;
block|}
comment|// First drill-down dim, basically adds SHOULD onto
comment|// the baseQuery:
comment|//if (DEBUG) {
comment|//  System.out.println("  dim=0 [" + dims[0].dim + "]");
comment|//}
block|{
name|DocsAndCost
name|dc
init|=
name|dims
index|[
literal|0
index|]
decl_stmt|;
name|docID
operator|=
name|dc
operator|.
name|approximation
operator|.
name|docID
argument_list|()
expr_stmt|;
comment|//if (DEBUG) {
comment|//  System.out.println("    start docID=" + docID);
comment|//}
while|while
condition|(
name|docID
operator|<
name|nextChunkStart
condition|)
block|{
name|int
name|slot
init|=
name|docID
operator|&
name|MASK
decl_stmt|;
if|if
condition|(
name|docIDs
index|[
name|slot
index|]
operator|==
name|docID
comment|// this also checks that the doc is not deleted
operator|&&
operator|(
name|dc
operator|.
name|twoPhase
operator|==
literal|null
operator|||
name|dc
operator|.
name|twoPhase
operator|.
name|matches
argument_list|()
operator|)
condition|)
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("      set docID=" + docID + " count=2");
comment|//}
name|missingDims
index|[
name|slot
index|]
operator|=
literal|1
expr_stmt|;
name|counts
index|[
name|slot
index|]
operator|=
literal|2
expr_stmt|;
block|}
name|docID
operator|=
name|dc
operator|.
name|approximation
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|dim
init|=
literal|1
init|;
name|dim
operator|<
name|numDims
condition|;
name|dim
operator|++
control|)
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("  dim=" + dim + " [" + dims[dim].dim + "]");
comment|//}
name|DocsAndCost
name|dc
init|=
name|dims
index|[
name|dim
index|]
decl_stmt|;
name|docID
operator|=
name|dc
operator|.
name|approximation
operator|.
name|docID
argument_list|()
expr_stmt|;
comment|//if (DEBUG) {
comment|//  System.out.println("    start docID=" + docID);
comment|//}
while|while
condition|(
name|docID
operator|<
name|nextChunkStart
condition|)
block|{
name|int
name|slot
init|=
name|docID
operator|&
name|MASK
decl_stmt|;
if|if
condition|(
name|docIDs
index|[
name|slot
index|]
operator|==
name|docID
comment|// also means that the doc is not deleted
operator|&&
name|counts
index|[
name|slot
index|]
operator|>=
name|dim
operator|&&
operator|(
name|dc
operator|.
name|twoPhase
operator|==
literal|null
operator|||
name|dc
operator|.
name|twoPhase
operator|.
name|matches
argument_list|()
operator|)
condition|)
block|{
comment|// This doc is still in the running...
comment|// TODO: single-valued dims will always be true
comment|// below; we could somehow specialize
if|if
condition|(
name|missingDims
index|[
name|slot
index|]
operator|>=
name|dim
condition|)
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("      set docID=" + docID + " count=" + (dim+2));
comment|//}
name|missingDims
index|[
name|slot
index|]
operator|=
name|dim
operator|+
literal|1
expr_stmt|;
name|counts
index|[
name|slot
index|]
operator|=
name|dim
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("      set docID=" + docID + " missing count=" + (dim+1));
comment|//}
name|counts
index|[
name|slot
index|]
operator|=
name|dim
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|docID
operator|=
name|dc
operator|.
name|approximation
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Collect:
comment|//System.out.println("  now collect: " + filledCount + " hits");
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|filledCount
condition|;
name|i
operator|++
control|)
block|{
comment|// NOTE: This is actually in-order collection,
comment|// because we only accept docs originally returned by
comment|// the baseScorer (ie that Scorer is AND'd)
name|int
name|slot
init|=
name|filledSlots
index|[
name|i
index|]
decl_stmt|;
name|collectDocID
operator|=
name|docIDs
index|[
name|slot
index|]
expr_stmt|;
name|collectScore
operator|=
name|scores
index|[
name|slot
index|]
expr_stmt|;
comment|//if (DEBUG) {
comment|//  System.out.println("    docID=" + docIDs[slot] + " count=" + counts[slot]);
comment|//}
comment|//System.out.println("  collect doc=" + collectDocID + " main.freq=" + (counts[slot]-1) + " main.doc=" + collectDocID + " exactCount=" + numDims);
if|if
condition|(
name|counts
index|[
name|slot
index|]
operator|==
literal|1
operator|+
name|numDims
condition|)
block|{
comment|//System.out.println("    hit");
name|collectHit
argument_list|(
name|collector
argument_list|,
name|dims
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|counts
index|[
name|slot
index|]
operator|==
name|numDims
condition|)
block|{
comment|//System.out.println("    sw");
name|collectNearMiss
argument_list|(
name|dims
index|[
name|missingDims
index|[
name|slot
index|]
index|]
operator|.
name|sidewaysLeafCollector
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nextChunkStart
operator|>=
name|maxDoc
condition|)
block|{
break|break;
block|}
name|nextChunkStart
operator|+=
name|CHUNK
expr_stmt|;
block|}
block|}
DECL|method|collectHit
specifier|private
name|void
name|collectHit
parameter_list|(
name|LeafCollector
name|collector
parameter_list|,
name|DocsAndCost
index|[]
name|dims
parameter_list|)
throws|throws
name|IOException
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("      hit");
comment|//}
name|collector
operator|.
name|collect
argument_list|(
name|collectDocID
argument_list|)
expr_stmt|;
if|if
condition|(
name|drillDownCollector
operator|!=
literal|null
condition|)
block|{
name|drillDownLeafCollector
operator|.
name|collect
argument_list|(
name|collectDocID
argument_list|)
expr_stmt|;
block|}
comment|// TODO: we could "fix" faceting of the sideways counts
comment|// to do this "union" (of the drill down hits) in the
comment|// end instead:
comment|// Tally sideways counts:
for|for
control|(
name|DocsAndCost
name|dim
range|:
name|dims
control|)
block|{
name|dim
operator|.
name|sidewaysLeafCollector
operator|.
name|collect
argument_list|(
name|collectDocID
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|collectNearMiss
specifier|private
name|void
name|collectNearMiss
parameter_list|(
name|LeafCollector
name|sidewaysCollector
parameter_list|)
throws|throws
name|IOException
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("      missingDim=" + dim);
comment|//}
name|sidewaysCollector
operator|.
name|collect
argument_list|(
name|collectDocID
argument_list|)
expr_stmt|;
block|}
DECL|class|FakeScorer
specifier|private
specifier|final
class|class
name|FakeScorer
extends|extends
name|Scorer
block|{
DECL|method|FakeScorer
specifier|public
name|FakeScorer
parameter_list|()
block|{
name|super
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"FakeScorer doesn't support advance(int)"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|collectDocID
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
block|{
return|return
literal|1
operator|+
name|dims
operator|.
name|length
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"FakeScorer doesn't support nextDoc()"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|score
specifier|public
name|float
name|score
parameter_list|()
block|{
return|return
name|collectScore
return|;
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|baseScorer
operator|.
name|cost
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getChildren
specifier|public
name|Collection
argument_list|<
name|ChildScorer
argument_list|>
name|getChildren
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|singletonList
argument_list|(
operator|new
name|ChildScorer
argument_list|(
name|baseScorer
argument_list|,
literal|"MUST"
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getWeight
specifier|public
name|Weight
name|getWeight
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
DECL|class|DocsAndCost
specifier|static
class|class
name|DocsAndCost
block|{
comment|// approximation of matching docs, or the scorer itself
DECL|field|approximation
specifier|final
name|DocIdSetIterator
name|approximation
decl_stmt|;
comment|// two-phase confirmation, or null if the approximation is accurate
DECL|field|twoPhase
specifier|final
name|TwoPhaseIterator
name|twoPhase
decl_stmt|;
DECL|field|sidewaysCollector
specifier|final
name|Collector
name|sidewaysCollector
decl_stmt|;
DECL|field|sidewaysLeafCollector
name|LeafCollector
name|sidewaysLeafCollector
decl_stmt|;
DECL|method|DocsAndCost
name|DocsAndCost
parameter_list|(
name|Scorer
name|scorer
parameter_list|,
name|Collector
name|sidewaysCollector
parameter_list|)
block|{
specifier|final
name|TwoPhaseIterator
name|twoPhase
init|=
name|scorer
operator|.
name|asTwoPhaseIterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|twoPhase
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|approximation
operator|=
name|scorer
expr_stmt|;
name|this
operator|.
name|twoPhase
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|approximation
operator|=
name|twoPhase
operator|.
name|approximation
argument_list|()
expr_stmt|;
name|this
operator|.
name|twoPhase
operator|=
name|twoPhase
expr_stmt|;
block|}
name|this
operator|.
name|sidewaysCollector
operator|=
name|sidewaysCollector
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
