begin_unit
begin_package
DECL|package|org.apache.lucene.facet.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|search
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedQueue
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|index
operator|.
name|params
operator|.
name|CategoryListParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|index
operator|.
name|params
operator|.
name|FacetIndexingParams
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|search
operator|.
name|cache
operator|.
name|CategoryListCache
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|taxonomy
operator|.
name|TaxonomyReader
import|;
end_import
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  * Manage an LRU cache for {@link TotalFacetCounts} per index, taxonomy, and  * facet indexing params.  *   * @lucene.experimental  */
end_comment
begin_class
DECL|class|TotalFacetCountsCache
specifier|public
specifier|final
class|class
name|TotalFacetCountsCache
block|{
comment|/**    * Default size of in memory cache for computed total facet counts.    * Set to 2 for the case when an application reopened a reader and     * the original one is still in use (Otherwise there will be     * switching again and again between the two.)     */
DECL|field|DEFAULT_CACHE_SIZE
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_CACHE_SIZE
init|=
literal|2
decl_stmt|;
DECL|field|singleton
specifier|private
specifier|static
specifier|final
name|TotalFacetCountsCache
name|singleton
init|=
operator|new
name|TotalFacetCountsCache
argument_list|()
decl_stmt|;
comment|/**    * Get the single instance of this cache    */
DECL|method|getSingleton
specifier|public
specifier|static
name|TotalFacetCountsCache
name|getSingleton
parameter_list|()
block|{
return|return
name|singleton
return|;
block|}
comment|/**    * In-memory cache of TFCs.    *<ul>      *<li>It's size is kept within limits through {@link #trimCache()}.    *<li>An LRU eviction policy is applied, by maintaining active keys in {@link #lruKeys}.     *<li>After each addition to the cache, trimCache is called, to remove entries least recently used.    *</ul>      * @see #markRecentlyUsed(TFCKey)    */
DECL|field|cache
specifier|private
name|ConcurrentHashMap
argument_list|<
name|TFCKey
argument_list|,
name|TotalFacetCounts
argument_list|>
name|cache
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|TFCKey
argument_list|,
name|TotalFacetCounts
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * A queue of active keys for applying LRU policy on eviction from the {@link #cache}.    * @see #markRecentlyUsed(TFCKey)    */
DECL|field|lruKeys
specifier|private
name|ConcurrentLinkedQueue
argument_list|<
name|TFCKey
argument_list|>
name|lruKeys
init|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<
name|TFCKey
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|maxCacheSize
specifier|private
name|int
name|maxCacheSize
init|=
name|DEFAULT_CACHE_SIZE
decl_stmt|;
comment|/** private constructor for singleton pattern */
DECL|method|TotalFacetCountsCache
specifier|private
name|TotalFacetCountsCache
parameter_list|()
block|{   }
comment|/**    * Get the total facet counts for a reader/taxonomy pair and facet indexing parameters.    * If not in cache, computed here and added to the cache for later use.    * @param indexReader the documents index    * @param taxonomy the taxonomy index    * @param facetIndexingParams facet indexing parameters    * @param clCache category list cache for faster computation, can be null     * @return the total facet counts.    */
DECL|method|getTotalCounts
specifier|public
name|TotalFacetCounts
name|getTotalCounts
parameter_list|(
name|IndexReader
name|indexReader
parameter_list|,
name|TaxonomyReader
name|taxonomy
parameter_list|,
name|FacetIndexingParams
name|facetIndexingParams
parameter_list|,
name|CategoryListCache
name|clCache
parameter_list|)
throws|throws
name|IOException
block|{
comment|// create the key
name|TFCKey
name|key
init|=
operator|new
name|TFCKey
argument_list|(
name|indexReader
argument_list|,
name|taxonomy
argument_list|,
name|facetIndexingParams
argument_list|)
decl_stmt|;
comment|// it is important that this call is not synchronized, so that available TFC
comment|// would not wait for one that needs to be computed.
name|TotalFacetCounts
name|tfc
init|=
name|cache
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|tfc
operator|!=
literal|null
condition|)
block|{
name|markRecentlyUsed
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|tfc
return|;
block|}
return|return
name|computeAndCache
argument_list|(
name|key
argument_list|,
name|clCache
argument_list|)
return|;
block|}
comment|/**    * Mark key as it as recently used.    *<p>    *<b>Implementation notes: Synchronization considerations and the interaction between lruKeys and cache:</b>    *<ol>    *<li>A concurrent {@link LinkedHashMap} would have made this class much simpler.    *      But unfortunately, Java does not provide one.    *      Instead, we combine two concurrent objects:    *<ul>    *<li>{@link ConcurrentHashMap} for the cached TFCs.    *<li>{@link ConcurrentLinkedQueue} for active keys    *</ul>    *<li>Both {@link #lruKeys} and {@link #cache} are concurrently safe.    *<li>Checks for a cached item through getTotalCounts() are not synchronized.    *      Therefore, the case that a needed TFC is in the cache is very fast:    *      it does not wait for the computation of other TFCs.    *<li>computeAndCache() is synchronized, and, has a (double) check of the required    *       TFC, to avoid computing the same TFC twice.     *<li>A race condition in this method (markRecentlyUsed) might result in two copies     *      of the same 'key' in lruKeys, but this is handled by the loop in trimCache(),     *      where an attempt to remove the same key twice is a no-op.    *</ol>    */
DECL|method|markRecentlyUsed
specifier|private
name|void
name|markRecentlyUsed
parameter_list|(
name|TFCKey
name|key
parameter_list|)
block|{
name|lruKeys
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|lruKeys
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
DECL|method|trimCache
specifier|private
specifier|synchronized
name|void
name|trimCache
parameter_list|()
block|{
comment|// loop until cache is of desired  size.
while|while
condition|(
name|cache
operator|.
name|size
argument_list|()
operator|>
name|maxCacheSize
condition|)
block|{
name|TFCKey
name|key
init|=
name|lruKeys
operator|.
name|poll
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
comment|//defensive
comment|// it is defensive since lruKeys presumably covers the cache keys
name|key
operator|=
name|cache
operator|.
name|keys
argument_list|()
operator|.
name|nextElement
argument_list|()
expr_stmt|;
block|}
comment|// remove this element. Note that an attempt to remove with the same key again is a no-op,
comment|// which gracefully handles the possible race in markRecentlyUsed().
name|cache
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * compute TFC and cache it, after verifying it was not just added - for this    * matter this method is synchronized, which is not too bad, because there is    * lots of work done in the computations.    */
DECL|method|computeAndCache
specifier|private
specifier|synchronized
name|TotalFacetCounts
name|computeAndCache
parameter_list|(
name|TFCKey
name|key
parameter_list|,
name|CategoryListCache
name|clCache
parameter_list|)
throws|throws
name|IOException
block|{
name|TotalFacetCounts
name|tfc
init|=
name|cache
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|tfc
operator|==
literal|null
condition|)
block|{
name|tfc
operator|=
name|TotalFacetCounts
operator|.
name|compute
argument_list|(
name|key
operator|.
name|indexReader
argument_list|,
name|key
operator|.
name|taxonomy
argument_list|,
name|key
operator|.
name|facetIndexingParams
argument_list|,
name|clCache
argument_list|)
expr_stmt|;
name|lruKeys
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|cache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|tfc
argument_list|)
expr_stmt|;
name|trimCache
argument_list|()
expr_stmt|;
block|}
return|return
name|tfc
return|;
block|}
comment|/**    * Load {@link TotalFacetCounts} matching input parameters from the provided outputFile     * and add them into the cache for the provided indexReader, taxonomy, and facetIndexingParams.    * If a {@link TotalFacetCounts} for these parameters already exists in the cache, it will be    * replaced by the loaded one.    * @param inputFile file from which to read the data     * @param indexReader the documents index    * @param taxonomy the taxonomy index    * @param facetIndexingParams the facet indexing parameters    * @throws IOException on error    * @see #store(File, IndexReader, TaxonomyReader, FacetIndexingParams, CategoryListCache)    */
DECL|method|load
specifier|public
specifier|synchronized
name|void
name|load
parameter_list|(
name|File
name|inputFile
parameter_list|,
name|IndexReader
name|indexReader
parameter_list|,
name|TaxonomyReader
name|taxonomy
parameter_list|,
name|FacetIndexingParams
name|facetIndexingParams
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|inputFile
operator|.
name|isFile
argument_list|()
operator|||
operator|!
name|inputFile
operator|.
name|exists
argument_list|()
operator|||
operator|!
name|inputFile
operator|.
name|canRead
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Exepecting an existing readable file: "
operator|+
name|inputFile
argument_list|)
throw|;
block|}
name|TFCKey
name|key
init|=
operator|new
name|TFCKey
argument_list|(
name|indexReader
argument_list|,
name|taxonomy
argument_list|,
name|facetIndexingParams
argument_list|)
decl_stmt|;
name|TotalFacetCounts
name|tfc
init|=
name|TotalFacetCounts
operator|.
name|loadFromFile
argument_list|(
name|inputFile
argument_list|,
name|taxonomy
argument_list|,
name|facetIndexingParams
argument_list|)
decl_stmt|;
name|cache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|tfc
argument_list|)
expr_stmt|;
name|trimCache
argument_list|()
expr_stmt|;
name|markRecentlyUsed
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
comment|/**    * Store the {@link TotalFacetCounts} matching input parameters into the provided outputFile,    * making them available for a later call to {@link #load(File, IndexReader, TaxonomyReader, FacetIndexingParams)}.    * If these {@link TotalFacetCounts} are available in the cache, they are used. But if they are    * not in the cache, this call will first compute them (which will also add them to the cache).     * @param outputFile file to store in.    * @param indexReader the documents index    * @param taxonomy the taxonomy index    * @param facetIndexingParams the facet indexing parameters    * @param clCache category list cache for faster computation, can be null    * @throws IOException on error    * @see #load(File, IndexReader, TaxonomyReader, FacetIndexingParams)    * @see #getTotalCounts(IndexReader, TaxonomyReader, FacetIndexingParams, CategoryListCache)    */
DECL|method|store
specifier|public
name|void
name|store
parameter_list|(
name|File
name|outputFile
parameter_list|,
name|IndexReader
name|indexReader
parameter_list|,
name|TaxonomyReader
name|taxonomy
parameter_list|,
name|FacetIndexingParams
name|facetIndexingParams
parameter_list|,
name|CategoryListCache
name|clCache
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|parentFile
init|=
name|outputFile
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|outputFile
operator|.
name|exists
argument_list|()
operator|&&
operator|(
operator|!
name|outputFile
operator|.
name|isFile
argument_list|()
operator|||
operator|!
name|outputFile
operator|.
name|canWrite
argument_list|()
operator|)
operator|)
operator|||
operator|(
operator|!
name|outputFile
operator|.
name|exists
argument_list|()
operator|&&
operator|(
operator|!
name|parentFile
operator|.
name|isDirectory
argument_list|()
operator|||
operator|!
name|parentFile
operator|.
name|canWrite
argument_list|()
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Exepecting a writable file: "
operator|+
name|outputFile
argument_list|)
throw|;
block|}
name|TotalFacetCounts
name|tfc
init|=
name|getTotalCounts
argument_list|(
name|indexReader
argument_list|,
name|taxonomy
argument_list|,
name|facetIndexingParams
argument_list|,
name|clCache
argument_list|)
decl_stmt|;
name|TotalFacetCounts
operator|.
name|storeToFile
argument_list|(
name|outputFile
argument_list|,
name|tfc
argument_list|)
expr_stmt|;
block|}
DECL|class|TFCKey
specifier|private
specifier|static
class|class
name|TFCKey
block|{
DECL|field|indexReader
specifier|final
name|IndexReader
name|indexReader
decl_stmt|;
DECL|field|taxonomy
specifier|final
name|TaxonomyReader
name|taxonomy
decl_stmt|;
DECL|field|clps
specifier|private
specifier|final
name|Iterable
argument_list|<
name|CategoryListParams
argument_list|>
name|clps
decl_stmt|;
DECL|field|hashCode
specifier|private
specifier|final
name|int
name|hashCode
decl_stmt|;
DECL|field|nDels
specifier|private
specifier|final
name|int
name|nDels
decl_stmt|;
comment|// needed when a reader used for faceted search was just used for deletion.
DECL|field|facetIndexingParams
specifier|final
name|FacetIndexingParams
name|facetIndexingParams
decl_stmt|;
DECL|method|TFCKey
specifier|public
name|TFCKey
parameter_list|(
name|IndexReader
name|indexReader
parameter_list|,
name|TaxonomyReader
name|taxonomy
parameter_list|,
name|FacetIndexingParams
name|facetIndexingParams
parameter_list|)
block|{
name|this
operator|.
name|indexReader
operator|=
name|indexReader
expr_stmt|;
name|this
operator|.
name|taxonomy
operator|=
name|taxonomy
expr_stmt|;
name|this
operator|.
name|facetIndexingParams
operator|=
name|facetIndexingParams
expr_stmt|;
name|this
operator|.
name|clps
operator|=
name|facetIndexingParams
operator|.
name|getAllCategoryListParams
argument_list|()
expr_stmt|;
name|this
operator|.
name|nDels
operator|=
name|indexReader
operator|.
name|numDeletedDocs
argument_list|()
expr_stmt|;
name|hashCode
operator|=
name|indexReader
operator|.
name|hashCode
argument_list|()
operator|^
name|taxonomy
operator|.
name|hashCode
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|hashCode
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
name|TFCKey
name|o
init|=
operator|(
name|TFCKey
operator|)
name|other
decl_stmt|;
if|if
condition|(
name|indexReader
operator|!=
name|o
operator|.
name|indexReader
operator|||
name|taxonomy
operator|!=
name|o
operator|.
name|taxonomy
operator|||
name|nDels
operator|!=
name|o
operator|.
name|nDels
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Iterator
argument_list|<
name|CategoryListParams
argument_list|>
name|it1
init|=
name|clps
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|CategoryListParams
argument_list|>
name|it2
init|=
name|o
operator|.
name|clps
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it1
operator|.
name|hasNext
argument_list|()
operator|&&
name|it2
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|it1
operator|.
name|next
argument_list|()
operator|.
name|equals
argument_list|(
name|it2
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|it1
operator|.
name|hasNext
argument_list|()
operator|==
name|it2
operator|.
name|hasNext
argument_list|()
return|;
block|}
block|}
comment|/**    * Clear the cache.    */
DECL|method|clear
specifier|public
specifier|synchronized
name|void
name|clear
parameter_list|()
block|{
name|cache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|lruKeys
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * @return the maximal cache size    */
DECL|method|getCacheSize
specifier|public
name|int
name|getCacheSize
parameter_list|()
block|{
return|return
name|maxCacheSize
return|;
block|}
comment|/**    * Set the number of TotalFacetCounts arrays that will remain in memory cache.    *<p>    * If new size is smaller than current size, the cache is appropriately trimmed.    *<p>    * Minimal size is 1, so passing zero or negative size would result in size of 1.    * @param size new size to set    */
DECL|method|setCacheSize
specifier|public
name|void
name|setCacheSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<
literal|1
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|int
name|origSize
init|=
name|maxCacheSize
decl_stmt|;
name|maxCacheSize
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|maxCacheSize
operator|<
name|origSize
condition|)
block|{
comment|// need to trim only if the cache was reduced
name|trimCache
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
