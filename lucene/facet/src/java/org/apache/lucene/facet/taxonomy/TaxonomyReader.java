begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.facet.taxonomy
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
operator|.
name|taxonomy
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import
begin_comment
comment|/**  * TaxonomyReader is the read-only interface with which the faceted-search  * library uses the taxonomy during search time.  *<P>  * A TaxonomyReader holds a list of categories. Each category has a serial  * number which we call an "ordinal", and a hierarchical "path" name:  *<UL>  *<LI>  * The ordinal is an integer that starts at 0 for the first category (which is  * always the root category), and grows contiguously as more categories are  * added; Note that once a category is added, it can never be deleted.  *<LI>  * The path is a CategoryPath object specifying the category's position in the  * hierarchy.  *</UL>  *<B>Notes about concurrent access to the taxonomy:</B>  *<P>  * An implementation must allow multiple readers to be active concurrently  * with a single writer. Readers follow so-called "point in time" semantics,  * i.e., a TaxonomyReader object will only see taxonomy entries which were  * available at the time it was created. What the writer writes is only  * available to (new) readers after the writer's commit() is called.  *<P>  * In faceted search, two separate indices are used: the main Lucene index,  * and the taxonomy. Because the main index refers to the categories listed  * in the taxonomy, it is important to open the taxonomy *after* opening the  * main index, and it is also necessary to reopen() the taxonomy after  * reopen()ing the main index.  *<P>  * This order is important, otherwise it would be possible for the main index  * to refer to a category which is not yet visible in the old snapshot of  * the taxonomy. Note that it is indeed fine for the the taxonomy to be opened  * after the main index - even a long time after. The reason is that once  * a category is added to the taxonomy, it can never be changed or deleted,  * so there is no danger that a "too new" taxonomy not being consistent with  * an older index.  *   * @lucene.experimental  */
end_comment
begin_class
DECL|class|TaxonomyReader
specifier|public
specifier|abstract
class|class
name|TaxonomyReader
implements|implements
name|Closeable
block|{
comment|/** An iterator over a category's children. */
DECL|class|ChildrenIterator
specifier|public
specifier|static
class|class
name|ChildrenIterator
block|{
DECL|field|siblings
specifier|private
specifier|final
name|int
index|[]
name|siblings
decl_stmt|;
DECL|field|child
specifier|private
name|int
name|child
decl_stmt|;
DECL|method|ChildrenIterator
name|ChildrenIterator
parameter_list|(
name|int
name|child
parameter_list|,
name|int
index|[]
name|siblings
parameter_list|)
block|{
name|this
operator|.
name|siblings
operator|=
name|siblings
expr_stmt|;
name|this
operator|.
name|child
operator|=
name|child
expr_stmt|;
block|}
comment|/**      * Return the next child ordinal, or {@link TaxonomyReader#INVALID_ORDINAL}      * if no more children.      */
DECL|method|next
specifier|public
name|int
name|next
parameter_list|()
block|{
name|int
name|res
init|=
name|child
decl_stmt|;
if|if
condition|(
name|child
operator|!=
name|TaxonomyReader
operator|.
name|INVALID_ORDINAL
condition|)
block|{
name|child
operator|=
name|siblings
index|[
name|child
index|]
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
block|}
comment|/** Sole constructor. */
DECL|method|TaxonomyReader
specifier|public
name|TaxonomyReader
parameter_list|()
block|{   }
comment|/**    * The root category (the category with the empty path) always has the ordinal    * 0, to which we give a name ROOT_ORDINAL. {@link #getOrdinal(FacetLabel)}    * of an empty path will always return {@code ROOT_ORDINAL}, and    * {@link #getPath(int)} with {@code ROOT_ORDINAL} will return the empty path.    */
DECL|field|ROOT_ORDINAL
specifier|public
specifier|final
specifier|static
name|int
name|ROOT_ORDINAL
init|=
literal|0
decl_stmt|;
comment|/**    * Ordinals are always non-negative, so a negative ordinal can be used to    * signify an error. Methods here return INVALID_ORDINAL (-1) in this case.    */
DECL|field|INVALID_ORDINAL
specifier|public
specifier|final
specifier|static
name|int
name|INVALID_ORDINAL
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * If the taxonomy has changed since the provided reader was opened, open and    * return a new {@link TaxonomyReader}; else, return {@code null}. The new    * reader, if not {@code null}, will be the same type of reader as the one    * given to this method.    *     *<p>    * This method is typically far less costly than opening a fully new    * {@link TaxonomyReader} as it shares resources with the provided    * {@link TaxonomyReader}, when possible.    */
DECL|method|openIfChanged
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|TaxonomyReader
parameter_list|>
name|T
name|openIfChanged
parameter_list|(
name|T
name|oldTaxoReader
parameter_list|)
throws|throws
name|IOException
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|T
name|newTaxoReader
init|=
operator|(
name|T
operator|)
name|oldTaxoReader
operator|.
name|doOpenIfChanged
argument_list|()
decl_stmt|;
assert|assert
name|newTaxoReader
operator|!=
name|oldTaxoReader
assert|;
return|return
name|newTaxoReader
return|;
block|}
DECL|field|closed
specifier|private
specifier|volatile
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
comment|// set refCount to 1 at start
DECL|field|refCount
specifier|private
specifier|final
name|AtomicInteger
name|refCount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/**    * performs the actual task of closing the resources that are used by the    * taxonomy reader.    */
DECL|method|doClose
specifier|protected
specifier|abstract
name|void
name|doClose
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * Implements the actual opening of a new {@link TaxonomyReader} instance if    * the taxonomy has changed.    *     * @see #openIfChanged(TaxonomyReader)    */
DECL|method|doOpenIfChanged
specifier|protected
specifier|abstract
name|TaxonomyReader
name|doOpenIfChanged
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * Throws {@link AlreadyClosedException} if this IndexReader is closed    */
DECL|method|ensureOpen
specifier|protected
specifier|final
name|void
name|ensureOpen
parameter_list|()
throws|throws
name|AlreadyClosedException
block|{
if|if
condition|(
name|getRefCount
argument_list|()
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|AlreadyClosedException
argument_list|(
literal|"this TaxonomyReader is closed"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
specifier|final
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
name|decRef
argument_list|()
expr_stmt|;
name|closed
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Expert: decreases the refCount of this TaxonomyReader instance. If the    * refCount drops to 0 this taxonomy reader is closed.    */
DECL|method|decRef
specifier|public
specifier|final
name|void
name|decRef
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
specifier|final
name|int
name|rc
init|=
name|refCount
operator|.
name|decrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|doClose
argument_list|()
expr_stmt|;
name|closed
operator|=
literal|true
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// Put reference back on failure
name|refCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"too many decRef calls: refCount is "
operator|+
name|rc
operator|+
literal|" after decrement"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns a {@link ParallelTaxonomyArrays} object which can be used to    * efficiently traverse the taxonomy tree.    */
DECL|method|getParallelTaxonomyArrays
specifier|public
specifier|abstract
name|ParallelTaxonomyArrays
name|getParallelTaxonomyArrays
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Returns an iterator over the children of the given ordinal. */
DECL|method|getChildren
specifier|public
name|ChildrenIterator
name|getChildren
parameter_list|(
specifier|final
name|int
name|ordinal
parameter_list|)
throws|throws
name|IOException
block|{
name|ParallelTaxonomyArrays
name|arrays
init|=
name|getParallelTaxonomyArrays
argument_list|()
decl_stmt|;
name|int
name|child
init|=
name|ordinal
operator|>=
literal|0
condition|?
name|arrays
operator|.
name|children
argument_list|()
index|[
name|ordinal
index|]
else|:
name|INVALID_ORDINAL
decl_stmt|;
return|return
operator|new
name|ChildrenIterator
argument_list|(
name|child
argument_list|,
name|arrays
operator|.
name|siblings
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Retrieve user committed data.    *     * @see TaxonomyWriter#setCommitData(Map)    */
DECL|method|getCommitUserData
specifier|public
specifier|abstract
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getCommitUserData
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * Returns the ordinal of the category given as a path. The ordinal is the    * category's serial number, an integer which starts with 0 and grows as more    * categories are added (note that once a category is added, it can never be    * deleted).    *     * @return the category's ordinal or {@link #INVALID_ORDINAL} if the category    *         wasn't foun.    */
DECL|method|getOrdinal
specifier|public
specifier|abstract
name|int
name|getOrdinal
parameter_list|(
name|FacetLabel
name|categoryPath
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Returns ordinal for the dim + path. */
DECL|method|getOrdinal
specifier|public
name|int
name|getOrdinal
parameter_list|(
name|String
name|dim
parameter_list|,
name|String
index|[]
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|String
index|[]
name|fullPath
init|=
operator|new
name|String
index|[
name|path
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|fullPath
index|[
literal|0
index|]
operator|=
name|dim
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|fullPath
argument_list|,
literal|1
argument_list|,
name|path
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|getOrdinal
argument_list|(
operator|new
name|FacetLabel
argument_list|(
name|fullPath
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns the path name of the category with the given ordinal. */
DECL|method|getPath
specifier|public
specifier|abstract
name|FacetLabel
name|getPath
parameter_list|(
name|int
name|ordinal
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Returns the current refCount for this taxonomy reader. */
DECL|method|getRefCount
specifier|public
specifier|final
name|int
name|getRefCount
parameter_list|()
block|{
return|return
name|refCount
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Returns the number of categories in the taxonomy. Note that the number of    * categories returned is often slightly higher than the number of categories    * inserted into the taxonomy; This is because when a category is added to the    * taxonomy, its ancestors are also added automatically (including the root,    * which always get ordinal 0).    */
DECL|method|getSize
specifier|public
specifier|abstract
name|int
name|getSize
parameter_list|()
function_decl|;
comment|/**    * Expert: increments the refCount of this TaxonomyReader instance. RefCounts    * can be used to determine when a taxonomy reader can be closed safely, i.e.    * as soon as there are no more references. Be sure to always call a    * corresponding decRef(), in a finally clause; otherwise the reader may never    * be closed.    */
DECL|method|incRef
specifier|public
specifier|final
name|void
name|incRef
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|refCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/** Expert: increments the refCount of this TaxonomyReader    *  instance only if it has not been closed yet.  Returns    *  true on success. */
DECL|method|tryIncRef
specifier|public
specifier|final
name|boolean
name|tryIncRef
parameter_list|()
block|{
name|int
name|count
decl_stmt|;
while|while
condition|(
operator|(
name|count
operator|=
name|refCount
operator|.
name|get
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|refCount
operator|.
name|compareAndSet
argument_list|(
name|count
argument_list|,
name|count
operator|+
literal|1
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
end_class
end_unit
