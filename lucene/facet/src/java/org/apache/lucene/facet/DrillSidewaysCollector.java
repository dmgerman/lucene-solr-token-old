begin_unit
begin_package
DECL|package|org.apache.lucene.facet
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|facet
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|AtomicReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Collector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Scorer
operator|.
name|ChildScorer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Scorer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Weight
import|;
end_import
begin_comment
comment|/** Collector that scrutinizes each hit to determine if it  *  passed all constraints (a true hit) or if it missed  *  exactly one dimension (a near-miss, to count for  *  drill-sideways counts on that dimension). */
end_comment
begin_class
DECL|class|DrillSidewaysCollector
class|class
name|DrillSidewaysCollector
extends|extends
name|Collector
block|{
DECL|field|hitCollector
specifier|private
specifier|final
name|Collector
name|hitCollector
decl_stmt|;
DECL|field|drillDownCollector
specifier|private
specifier|final
name|Collector
name|drillDownCollector
decl_stmt|;
DECL|field|drillSidewaysCollectors
specifier|private
specifier|final
name|Collector
index|[]
name|drillSidewaysCollectors
decl_stmt|;
DECL|field|subScorers
specifier|private
specifier|final
name|Scorer
index|[]
name|subScorers
decl_stmt|;
DECL|field|exactCount
specifier|private
specifier|final
name|int
name|exactCount
decl_stmt|;
comment|// Maps Weight to either -1 (mainQuery) or to integer
comment|// index of the dims drillDown.  We needs this when
comment|// visiting the child scorers to correlate back to the
comment|// right scorers:
DECL|field|weightToIndex
specifier|private
specifier|final
name|Map
argument_list|<
name|Weight
argument_list|,
name|Integer
argument_list|>
name|weightToIndex
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|Weight
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|mainScorer
specifier|private
name|Scorer
name|mainScorer
decl_stmt|;
DECL|method|DrillSidewaysCollector
specifier|public
name|DrillSidewaysCollector
parameter_list|(
name|Collector
name|hitCollector
parameter_list|,
name|Collector
name|drillDownCollector
parameter_list|,
name|Collector
index|[]
name|drillSidewaysCollectors
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|dims
parameter_list|)
block|{
name|this
operator|.
name|hitCollector
operator|=
name|hitCollector
expr_stmt|;
name|this
operator|.
name|drillDownCollector
operator|=
name|drillDownCollector
expr_stmt|;
name|this
operator|.
name|drillSidewaysCollectors
operator|=
name|drillSidewaysCollectors
expr_stmt|;
name|subScorers
operator|=
operator|new
name|Scorer
index|[
name|dims
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
if|if
condition|(
name|dims
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// When we have only one dim, we insert the
comment|// MatchAllDocsQuery, bringing the clause count to
comment|// 2:
name|exactCount
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|exactCount
operator|=
name|dims
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("collect doc=" + doc + " main.freq=" + mainScorer.freq() + " main.doc=" + mainScorer.docID() + " exactCount=" + exactCount);
if|if
condition|(
name|mainScorer
operator|==
literal|null
condition|)
block|{
comment|// This segment did not have any docs with any
comment|// drill-down field& value:
return|return;
block|}
if|if
condition|(
name|mainScorer
operator|.
name|freq
argument_list|()
operator|==
name|exactCount
condition|)
block|{
comment|// All sub-clauses from the drill-down filters
comment|// matched, so this is a "real" hit, so we first
comment|// collect in both the hitCollector and the
comment|// drillDown collector:
comment|//System.out.println("  hit " + drillDownCollector);
name|hitCollector
operator|.
name|collect
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|drillDownCollector
operator|!=
literal|null
condition|)
block|{
name|drillDownCollector
operator|.
name|collect
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
comment|// Also collect across all drill-sideways counts so
comment|// we "merge in" drill-down counts for this
comment|// dimension.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subScorers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// This cannot be null, because it was a hit,
comment|// meaning all drill-down dims matched, so all
comment|// dims must have non-null scorers:
assert|assert
name|subScorers
index|[
name|i
index|]
operator|!=
literal|null
assert|;
name|int
name|subDoc
init|=
name|subScorers
index|[
name|i
index|]
operator|.
name|docID
argument_list|()
decl_stmt|;
assert|assert
name|subDoc
operator|==
name|doc
assert|;
name|drillSidewaysCollectors
index|[
name|i
index|]
operator|.
name|collect
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subScorers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|subScorers
index|[
name|i
index|]
operator|==
literal|null
condition|)
block|{
comment|// This segment did not have any docs with this
comment|// drill-down field& value:
name|drillSidewaysCollectors
index|[
name|i
index|]
operator|.
name|collect
argument_list|(
name|doc
argument_list|)
expr_stmt|;
assert|assert
name|allMatchesFrom
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|doc
argument_list|)
assert|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|int
name|subDoc
init|=
name|subScorers
index|[
name|i
index|]
operator|.
name|docID
argument_list|()
decl_stmt|;
comment|//System.out.println("  i=" + i + " sub: " + subDoc);
if|if
condition|(
name|subDoc
operator|!=
name|doc
condition|)
block|{
comment|//System.out.println("  +ds[" + i + "]");
assert|assert
name|subDoc
operator|>
name|doc
operator|:
literal|"subDoc="
operator|+
name|subDoc
operator|+
literal|" doc="
operator|+
name|doc
assert|;
name|drillSidewaysCollectors
index|[
name|i
index|]
operator|.
name|collect
argument_list|(
name|doc
argument_list|)
expr_stmt|;
assert|assert
name|allMatchesFrom
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|doc
argument_list|)
assert|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
assert|assert
name|found
assert|;
block|}
block|}
comment|// Only used by assert:
DECL|method|allMatchesFrom
specifier|private
name|boolean
name|allMatchesFrom
parameter_list|(
name|int
name|startFrom
parameter_list|,
name|int
name|doc
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|startFrom
init|;
name|i
operator|<
name|subScorers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
assert|assert
name|subScorers
index|[
name|i
index|]
operator|.
name|docID
argument_list|()
operator|==
name|doc
assert|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|acceptsDocsOutOfOrder
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
comment|// We actually could accept docs out of order, but, we
comment|// need to force BooleanScorer2 so that the
comment|// sub-scorers are "on" each docID we are collecting:
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|setNextReader
specifier|public
name|void
name|setNextReader
parameter_list|(
name|AtomicReaderContext
name|leaf
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("DS.setNextReader reader=" + leaf.reader());
name|hitCollector
operator|.
name|setNextReader
argument_list|(
name|leaf
argument_list|)
expr_stmt|;
if|if
condition|(
name|drillDownCollector
operator|!=
literal|null
condition|)
block|{
name|drillDownCollector
operator|.
name|setNextReader
argument_list|(
name|leaf
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Collector
name|dsc
range|:
name|drillSidewaysCollectors
control|)
block|{
name|dsc
operator|.
name|setNextReader
argument_list|(
name|leaf
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setWeight
name|void
name|setWeight
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|int
name|index
parameter_list|)
block|{
assert|assert
operator|!
name|weightToIndex
operator|.
name|containsKey
argument_list|(
name|weight
argument_list|)
assert|;
name|weightToIndex
operator|.
name|put
argument_list|(
name|weight
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
DECL|method|findScorers
specifier|private
name|void
name|findScorers
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
block|{
name|Integer
name|index
init|=
name|weightToIndex
operator|.
name|get
argument_list|(
name|scorer
operator|.
name|getWeight
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|index
operator|.
name|intValue
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|mainScorer
operator|=
name|scorer
expr_stmt|;
block|}
else|else
block|{
name|subScorers
index|[
name|index
index|]
operator|=
name|scorer
expr_stmt|;
block|}
block|}
for|for
control|(
name|ChildScorer
name|child
range|:
name|scorer
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|findScorers
argument_list|(
name|child
operator|.
name|child
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|setScorer
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|mainScorer
operator|=
literal|null
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|subScorers
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|findScorers
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
name|hitCollector
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
if|if
condition|(
name|drillDownCollector
operator|!=
literal|null
condition|)
block|{
name|drillDownCollector
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Collector
name|dsc
range|:
name|drillSidewaysCollectors
control|)
block|{
name|dsc
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
