begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.spatial3d
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|FilterCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|PointsFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|PointsReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|PointsWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene60
operator|.
name|Lucene60PointsReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene60
operator|.
name|Lucene60PointsWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|NumericDocValuesField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|geo
operator|.
name|GeoTestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|geo
operator|.
name|Polygon
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|geo
operator|.
name|Rectangle
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriterConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|NumericDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|PointValues
operator|.
name|IntersectVisitor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|PointValues
operator|.
name|Relation
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|ReaderUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentReadState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentWriteState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|SimpleCollector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
operator|.
name|XYZSolid
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
operator|.
name|XYZSolidFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
operator|.
name|GeoArea
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
operator|.
name|GeoAreaFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
operator|.
name|GeoBBox
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
operator|.
name|GeoBBoxFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
operator|.
name|GeoCircleFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
operator|.
name|GeoPathFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
operator|.
name|GeoPoint
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
operator|.
name|GeoPolygon
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
operator|.
name|GeoPolygonFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
operator|.
name|GeoShape
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
operator|.
name|Plane
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
operator|.
name|PlanetModel
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
operator|.
name|SidedPlane
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
operator|.
name|XYZBounds
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|DocIdSetBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|FixedBitSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|NumericUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|generators
operator|.
name|RandomInts
import|;
end_import
begin_class
DECL|class|TestGeo3DPoint
specifier|public
class|class
name|TestGeo3DPoint
extends|extends
name|LuceneTestCase
block|{
DECL|method|getCodec
specifier|private
specifier|static
name|Codec
name|getCodec
parameter_list|()
block|{
if|if
condition|(
name|Codec
operator|.
name|getDefault
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"Lucene60"
argument_list|)
condition|)
block|{
name|int
name|maxPointsInLeafNode
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|16
argument_list|,
literal|2048
argument_list|)
decl_stmt|;
name|double
name|maxMBSortInHeap
init|=
literal|3.0
operator|+
operator|(
literal|3
operator|*
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: using Lucene60PointsFormat with maxPointsInLeafNode="
operator|+
name|maxPointsInLeafNode
operator|+
literal|" and maxMBSortInHeap="
operator|+
name|maxMBSortInHeap
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|FilterCodec
argument_list|(
literal|"Lucene60"
argument_list|,
name|Codec
operator|.
name|getDefault
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|PointsFormat
name|pointsFormat
parameter_list|()
block|{
return|return
operator|new
name|PointsFormat
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|PointsWriter
name|fieldsWriter
parameter_list|(
name|SegmentWriteState
name|writeState
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|Lucene60PointsWriter
argument_list|(
name|writeState
argument_list|,
name|maxPointsInLeafNode
argument_list|,
name|maxMBSortInHeap
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|PointsReader
name|fieldsReader
parameter_list|(
name|SegmentReadState
name|readState
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|Lucene60PointsReader
argument_list|(
name|readState
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
else|else
block|{
return|return
name|Codec
operator|.
name|getDefault
argument_list|()
return|;
block|}
block|}
DECL|method|testBasic
specifier|public
name|void
name|testBasic
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|()
decl_stmt|;
name|IndexWriterConfig
name|iwc
init|=
name|newIndexWriterConfig
argument_list|()
decl_stmt|;
name|iwc
operator|.
name|setCodec
argument_list|(
name|getCodec
argument_list|()
argument_list|)
expr_stmt|;
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|iwc
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|Geo3DPoint
argument_list|(
literal|"field"
argument_list|,
literal|50.7345267
argument_list|,
operator|-
literal|97.5303555
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|IndexReader
name|r
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|w
argument_list|)
decl_stmt|;
comment|// We can't wrap with "exotic" readers because the query must see the BKD3DDVFormat:
name|IndexSearcher
name|s
init|=
name|newSearcher
argument_list|(
name|r
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|s
operator|.
name|search
argument_list|(
name|Geo3DPoint
operator|.
name|newShapeQuery
argument_list|(
literal|"field"
argument_list|,
name|GeoCircleFactory
operator|.
name|makeGeoCircle
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|toRadians
argument_list|(
literal|50
argument_list|)
argument_list|,
name|toRadians
argument_list|(
operator|-
literal|97
argument_list|)
argument_list|,
name|Math
operator|.
name|PI
operator|/
literal|180.
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|.
name|totalHits
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|toRadians
specifier|private
specifier|static
name|double
name|toRadians
parameter_list|(
name|double
name|degrees
parameter_list|)
block|{
return|return
name|degrees
operator|*
name|Geo3DPoint
operator|.
name|RADIANS_PER_DEGREE
return|;
block|}
DECL|class|Cell
specifier|private
specifier|static
class|class
name|Cell
block|{
DECL|field|nextCellID
specifier|static
name|int
name|nextCellID
decl_stmt|;
DECL|field|parent
specifier|final
name|Cell
name|parent
decl_stmt|;
DECL|field|cellID
specifier|final
name|int
name|cellID
decl_stmt|;
DECL|field|xMinEnc
DECL|field|xMaxEnc
specifier|final
name|int
name|xMinEnc
decl_stmt|,
name|xMaxEnc
decl_stmt|;
DECL|field|yMinEnc
DECL|field|yMaxEnc
specifier|final
name|int
name|yMinEnc
decl_stmt|,
name|yMaxEnc
decl_stmt|;
DECL|field|zMinEnc
DECL|field|zMaxEnc
specifier|final
name|int
name|zMinEnc
decl_stmt|,
name|zMaxEnc
decl_stmt|;
DECL|field|splitCount
specifier|final
name|int
name|splitCount
decl_stmt|;
DECL|method|Cell
specifier|public
name|Cell
parameter_list|(
name|Cell
name|parent
parameter_list|,
name|int
name|xMinEnc
parameter_list|,
name|int
name|xMaxEnc
parameter_list|,
name|int
name|yMinEnc
parameter_list|,
name|int
name|yMaxEnc
parameter_list|,
name|int
name|zMinEnc
parameter_list|,
name|int
name|zMaxEnc
parameter_list|,
name|int
name|splitCount
parameter_list|)
block|{
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|xMinEnc
operator|=
name|xMinEnc
expr_stmt|;
name|this
operator|.
name|xMaxEnc
operator|=
name|xMaxEnc
expr_stmt|;
name|this
operator|.
name|yMinEnc
operator|=
name|yMinEnc
expr_stmt|;
name|this
operator|.
name|yMaxEnc
operator|=
name|yMaxEnc
expr_stmt|;
name|this
operator|.
name|zMinEnc
operator|=
name|zMinEnc
expr_stmt|;
name|this
operator|.
name|zMaxEnc
operator|=
name|zMaxEnc
expr_stmt|;
name|this
operator|.
name|cellID
operator|=
name|nextCellID
operator|++
expr_stmt|;
name|this
operator|.
name|splitCount
operator|=
name|splitCount
expr_stmt|;
block|}
comment|/** Returns true if the quantized point lies within this cell, inclusive on all bounds. */
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|GeoPoint
name|point
parameter_list|)
block|{
name|int
name|docX
init|=
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|point
operator|.
name|x
argument_list|)
decl_stmt|;
name|int
name|docY
init|=
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|point
operator|.
name|y
argument_list|)
decl_stmt|;
name|int
name|docZ
init|=
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|point
operator|.
name|z
argument_list|)
decl_stmt|;
return|return
name|docX
operator|>=
name|xMinEnc
operator|&&
name|docX
operator|<=
name|xMaxEnc
operator|&&
name|docY
operator|>=
name|yMinEnc
operator|&&
name|docY
operator|<=
name|yMaxEnc
operator|&&
name|docZ
operator|>=
name|zMinEnc
operator|&&
name|docZ
operator|<=
name|zMaxEnc
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"cell="
operator|+
name|cellID
operator|+
operator|(
name|parent
operator|==
literal|null
condition|?
literal|""
else|:
literal|" parentCellID="
operator|+
name|parent
operator|.
name|cellID
operator|)
operator|+
literal|" x: "
operator|+
name|xMinEnc
operator|+
literal|" TO "
operator|+
name|xMaxEnc
operator|+
literal|", y: "
operator|+
name|yMinEnc
operator|+
literal|" TO "
operator|+
name|yMaxEnc
operator|+
literal|", z: "
operator|+
name|zMinEnc
operator|+
literal|" TO "
operator|+
name|zMaxEnc
operator|+
literal|", splits: "
operator|+
name|splitCount
return|;
block|}
block|}
DECL|method|quantize
specifier|private
specifier|static
name|double
name|quantize
parameter_list|(
name|double
name|xyzValue
parameter_list|)
block|{
return|return
name|Geo3DUtil
operator|.
name|decodeValue
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|xyzValue
argument_list|)
argument_list|)
return|;
block|}
DECL|method|quantize
specifier|private
specifier|static
name|GeoPoint
name|quantize
parameter_list|(
name|GeoPoint
name|point
parameter_list|)
block|{
return|return
operator|new
name|GeoPoint
argument_list|(
name|quantize
argument_list|(
name|point
operator|.
name|x
argument_list|)
argument_list|,
name|quantize
argument_list|(
name|point
operator|.
name|y
argument_list|)
argument_list|,
name|quantize
argument_list|(
name|point
operator|.
name|z
argument_list|)
argument_list|)
return|;
block|}
comment|/** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */
DECL|method|testGeo3DRelations
specifier|public
name|void
name|testGeo3DRelations
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|numDocs
init|=
name|atLeast
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: "
operator|+
name|numDocs
operator|+
literal|" docs"
argument_list|)
expr_stmt|;
block|}
name|GeoPoint
index|[]
name|docs
init|=
operator|new
name|GeoPoint
index|[
name|numDocs
index|]
decl_stmt|;
name|GeoPoint
index|[]
name|unquantizedDocs
init|=
operator|new
name|GeoPoint
index|[
name|numDocs
index|]
decl_stmt|;
for|for
control|(
name|int
name|docID
init|=
literal|0
init|;
name|docID
operator|<
name|numDocs
condition|;
name|docID
operator|++
control|)
block|{
name|unquantizedDocs
index|[
name|docID
index|]
operator|=
operator|new
name|GeoPoint
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLatitude
argument_list|()
argument_list|)
argument_list|,
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLongitude
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|docs
index|[
name|docID
index|]
operator|=
name|quantize
argument_list|(
name|unquantizedDocs
index|[
name|docID
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  doc="
operator|+
name|docID
operator|+
literal|": "
operator|+
name|docs
index|[
name|docID
index|]
operator|+
literal|"; unquantized: "
operator|+
name|unquantizedDocs
index|[
name|docID
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|iters
init|=
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|int
name|recurseDepth
init|=
name|RandomInts
operator|.
name|randomIntBetween
argument_list|(
name|random
argument_list|()
argument_list|,
literal|5
argument_list|,
literal|15
argument_list|)
decl_stmt|;
name|iters
operator|=
name|atLeast
argument_list|(
literal|50
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|iters
condition|;
name|iter
operator|++
control|)
block|{
name|GeoShape
name|shape
init|=
name|randomShape
argument_list|()
decl_stmt|;
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|PrintWriter
name|log
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"TEST: iter="
operator|+
name|iter
operator|+
literal|" shape="
operator|+
name|shape
argument_list|)
expr_stmt|;
block|}
name|XYZBounds
name|bounds
init|=
operator|new
name|XYZBounds
argument_list|()
decl_stmt|;
name|shape
operator|.
name|getBounds
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
comment|// Start with the root cell that fully contains the shape:
name|Cell
name|root
init|=
operator|new
name|Cell
argument_list|(
literal|null
argument_list|,
name|encodeValueLenient
argument_list|(
name|bounds
operator|.
name|getMinimumX
argument_list|()
argument_list|)
argument_list|,
name|encodeValueLenient
argument_list|(
name|bounds
operator|.
name|getMaximumX
argument_list|()
argument_list|)
argument_list|,
name|encodeValueLenient
argument_list|(
name|bounds
operator|.
name|getMinimumY
argument_list|()
argument_list|)
argument_list|,
name|encodeValueLenient
argument_list|(
name|bounds
operator|.
name|getMaximumY
argument_list|()
argument_list|)
argument_list|,
name|encodeValueLenient
argument_list|(
name|bounds
operator|.
name|getMinimumZ
argument_list|()
argument_list|)
argument_list|,
name|encodeValueLenient
argument_list|(
name|bounds
operator|.
name|getMaximumZ
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"  root cell: "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Cell
argument_list|>
name|queue
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|hits
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|queue
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Cell
name|cell
init|=
name|queue
operator|.
name|get
argument_list|(
name|queue
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|queue
operator|.
name|remove
argument_list|(
name|queue
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"  cycle: "
operator|+
name|cell
operator|+
literal|" queue.size()="
operator|+
name|queue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
operator|==
literal|7
operator|||
name|cell
operator|.
name|splitCount
operator|>
name|recurseDepth
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"    leaf"
argument_list|)
expr_stmt|;
block|}
comment|// Leaf cell: brute force check all docs that fall within this cell:
for|for
control|(
name|int
name|docID
init|=
literal|0
init|;
name|docID
operator|<
name|numDocs
condition|;
name|docID
operator|++
control|)
block|{
name|GeoPoint
name|point
init|=
name|docs
index|[
name|docID
index|]
decl_stmt|;
name|GeoPoint
name|mappedPoint
init|=
name|unquantizedDocs
index|[
name|docID
index|]
decl_stmt|;
name|boolean
name|pointWithinShape
init|=
name|shape
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
decl_stmt|;
name|boolean
name|mappedPointWithinShape
init|=
name|shape
operator|.
name|isWithin
argument_list|(
name|mappedPoint
argument_list|)
decl_stmt|;
if|if
condition|(
name|cell
operator|.
name|contains
argument_list|(
name|point
argument_list|)
condition|)
block|{
if|if
condition|(
name|mappedPointWithinShape
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"    check doc="
operator|+
name|docID
operator|+
literal|": match!  Actual quantized point within: "
operator|+
name|pointWithinShape
argument_list|)
expr_stmt|;
block|}
name|hits
operator|.
name|add
argument_list|(
name|docID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"    check doc="
operator|+
name|docID
operator|+
literal|": no match.  Quantized point within: "
operator|+
name|pointWithinShape
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|GeoArea
name|xyzSolid
init|=
name|GeoAreaFactory
operator|.
name|makeGeoArea
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|Geo3DUtil
operator|.
name|decodeValueFloor
argument_list|(
name|cell
operator|.
name|xMinEnc
argument_list|)
argument_list|,
name|Geo3DUtil
operator|.
name|decodeValueCeil
argument_list|(
name|cell
operator|.
name|xMaxEnc
argument_list|)
argument_list|,
name|Geo3DUtil
operator|.
name|decodeValueFloor
argument_list|(
name|cell
operator|.
name|yMinEnc
argument_list|)
argument_list|,
name|Geo3DUtil
operator|.
name|decodeValueCeil
argument_list|(
name|cell
operator|.
name|yMaxEnc
argument_list|)
argument_list|,
name|Geo3DUtil
operator|.
name|decodeValueFloor
argument_list|(
name|cell
operator|.
name|zMinEnc
argument_list|)
argument_list|,
name|Geo3DUtil
operator|.
name|decodeValueCeil
argument_list|(
name|cell
operator|.
name|zMaxEnc
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"    minx="
operator|+
name|Geo3DUtil
operator|.
name|decodeValueFloor
argument_list|(
name|cell
operator|.
name|xMinEnc
argument_list|)
operator|+
literal|" maxx="
operator|+
name|Geo3DUtil
operator|.
name|decodeValueCeil
argument_list|(
name|cell
operator|.
name|xMaxEnc
argument_list|)
operator|+
literal|" miny="
operator|+
name|Geo3DUtil
operator|.
name|decodeValueFloor
argument_list|(
name|cell
operator|.
name|yMinEnc
argument_list|)
operator|+
literal|" maxy="
operator|+
name|Geo3DUtil
operator|.
name|decodeValueCeil
argument_list|(
name|cell
operator|.
name|yMaxEnc
argument_list|)
operator|+
literal|" minz="
operator|+
name|Geo3DUtil
operator|.
name|decodeValueFloor
argument_list|(
name|cell
operator|.
name|zMinEnc
argument_list|)
operator|+
literal|" maxz="
operator|+
name|Geo3DUtil
operator|.
name|decodeValueCeil
argument_list|(
name|cell
operator|.
name|zMaxEnc
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|xyzSolid
operator|.
name|getRelationship
argument_list|(
name|shape
argument_list|)
condition|)
block|{
case|case
name|GeoArea
operator|.
name|CONTAINS
case|:
comment|// Shape fully contains the cell: blindly add all docs in this cell:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"    GeoArea.CONTAINS: now addAll"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|docID
init|=
literal|0
init|;
name|docID
operator|<
name|numDocs
condition|;
name|docID
operator|++
control|)
block|{
if|if
condition|(
name|cell
operator|.
name|contains
argument_list|(
name|docs
index|[
name|docID
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"    addAll doc="
operator|+
name|docID
argument_list|)
expr_stmt|;
block|}
name|hits
operator|.
name|add
argument_list|(
name|docID
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
case|case
name|GeoArea
operator|.
name|OVERLAPS
case|:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"    GeoArea.OVERLAPS: keep splitting"
argument_list|)
expr_stmt|;
block|}
comment|// They do overlap but neither contains the other:
comment|//log.println("    crosses1");
break|break;
case|case
name|GeoArea
operator|.
name|WITHIN
case|:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"    GeoArea.WITHIN: keep splitting"
argument_list|)
expr_stmt|;
block|}
comment|// Cell fully contains the shape:
comment|//log.println("    crosses2");
break|break;
case|case
name|GeoArea
operator|.
name|DISJOINT
case|:
comment|// They do not overlap at all: don't recurse on this cell
comment|//log.println("    outside");
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"    GeoArea.DISJOINT: drop this cell"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|docID
init|=
literal|0
init|;
name|docID
operator|<
name|numDocs
condition|;
name|docID
operator|++
control|)
block|{
if|if
condition|(
name|cell
operator|.
name|contains
argument_list|(
name|docs
index|[
name|docID
index|]
argument_list|)
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"    skip doc="
operator|+
name|docID
argument_list|)
expr_stmt|;
block|}
block|}
block|}
continue|continue;
default|default:
assert|assert
literal|false
assert|;
block|}
comment|// Randomly split:
switch|switch
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|// Split on X:
block|{
name|int
name|splitValue
init|=
name|RandomInts
operator|.
name|randomIntBetween
argument_list|(
name|random
argument_list|()
argument_list|,
name|cell
operator|.
name|xMinEnc
argument_list|,
name|cell
operator|.
name|xMaxEnc
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"    now split on x="
operator|+
name|splitValue
argument_list|)
expr_stmt|;
block|}
name|Cell
name|cell1
init|=
operator|new
name|Cell
argument_list|(
name|cell
argument_list|,
name|cell
operator|.
name|xMinEnc
argument_list|,
name|splitValue
argument_list|,
name|cell
operator|.
name|yMinEnc
argument_list|,
name|cell
operator|.
name|yMaxEnc
argument_list|,
name|cell
operator|.
name|zMinEnc
argument_list|,
name|cell
operator|.
name|zMaxEnc
argument_list|,
name|cell
operator|.
name|splitCount
operator|+
literal|1
argument_list|)
decl_stmt|;
name|Cell
name|cell2
init|=
operator|new
name|Cell
argument_list|(
name|cell
argument_list|,
name|splitValue
argument_list|,
name|cell
operator|.
name|xMaxEnc
argument_list|,
name|cell
operator|.
name|yMinEnc
argument_list|,
name|cell
operator|.
name|yMaxEnc
argument_list|,
name|cell
operator|.
name|zMinEnc
argument_list|,
name|cell
operator|.
name|zMaxEnc
argument_list|,
name|cell
operator|.
name|splitCount
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"    split cell1: "
operator|+
name|cell1
argument_list|)
expr_stmt|;
name|log
operator|.
name|println
argument_list|(
literal|"    split cell2: "
operator|+
name|cell2
argument_list|)
expr_stmt|;
block|}
name|queue
operator|.
name|add
argument_list|(
name|cell1
argument_list|)
expr_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|cell2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|// Split on Y:
block|{
name|int
name|splitValue
init|=
name|RandomInts
operator|.
name|randomIntBetween
argument_list|(
name|random
argument_list|()
argument_list|,
name|cell
operator|.
name|yMinEnc
argument_list|,
name|cell
operator|.
name|yMaxEnc
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"    now split on y="
operator|+
name|splitValue
argument_list|)
expr_stmt|;
block|}
name|Cell
name|cell1
init|=
operator|new
name|Cell
argument_list|(
name|cell
argument_list|,
name|cell
operator|.
name|xMinEnc
argument_list|,
name|cell
operator|.
name|xMaxEnc
argument_list|,
name|cell
operator|.
name|yMinEnc
argument_list|,
name|splitValue
argument_list|,
name|cell
operator|.
name|zMinEnc
argument_list|,
name|cell
operator|.
name|zMaxEnc
argument_list|,
name|cell
operator|.
name|splitCount
operator|+
literal|1
argument_list|)
decl_stmt|;
name|Cell
name|cell2
init|=
operator|new
name|Cell
argument_list|(
name|cell
argument_list|,
name|cell
operator|.
name|xMinEnc
argument_list|,
name|cell
operator|.
name|xMaxEnc
argument_list|,
name|splitValue
argument_list|,
name|cell
operator|.
name|yMaxEnc
argument_list|,
name|cell
operator|.
name|zMinEnc
argument_list|,
name|cell
operator|.
name|zMaxEnc
argument_list|,
name|cell
operator|.
name|splitCount
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"    split cell1: "
operator|+
name|cell1
argument_list|)
expr_stmt|;
name|log
operator|.
name|println
argument_list|(
literal|"    split cell2: "
operator|+
name|cell2
argument_list|)
expr_stmt|;
block|}
name|queue
operator|.
name|add
argument_list|(
name|cell1
argument_list|)
expr_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|cell2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|// Split on Z:
block|{
name|int
name|splitValue
init|=
name|RandomInts
operator|.
name|randomIntBetween
argument_list|(
name|random
argument_list|()
argument_list|,
name|cell
operator|.
name|zMinEnc
argument_list|,
name|cell
operator|.
name|zMaxEnc
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"    now split on z="
operator|+
name|splitValue
argument_list|)
expr_stmt|;
block|}
name|Cell
name|cell1
init|=
operator|new
name|Cell
argument_list|(
name|cell
argument_list|,
name|cell
operator|.
name|xMinEnc
argument_list|,
name|cell
operator|.
name|xMaxEnc
argument_list|,
name|cell
operator|.
name|yMinEnc
argument_list|,
name|cell
operator|.
name|yMaxEnc
argument_list|,
name|cell
operator|.
name|zMinEnc
argument_list|,
name|splitValue
argument_list|,
name|cell
operator|.
name|splitCount
operator|+
literal|1
argument_list|)
decl_stmt|;
name|Cell
name|cell2
init|=
operator|new
name|Cell
argument_list|(
name|cell
argument_list|,
name|cell
operator|.
name|xMinEnc
argument_list|,
name|cell
operator|.
name|xMaxEnc
argument_list|,
name|cell
operator|.
name|yMinEnc
argument_list|,
name|cell
operator|.
name|yMaxEnc
argument_list|,
name|splitValue
argument_list|,
name|cell
operator|.
name|zMaxEnc
argument_list|,
name|cell
operator|.
name|splitCount
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"    split cell1: "
operator|+
name|cell1
argument_list|)
expr_stmt|;
name|log
operator|.
name|println
argument_list|(
literal|"    split cell2: "
operator|+
name|cell2
argument_list|)
expr_stmt|;
block|}
name|queue
operator|.
name|add
argument_list|(
name|cell1
argument_list|)
expr_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|cell2
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|hits
operator|.
name|size
argument_list|()
operator|+
literal|" hits"
argument_list|)
expr_stmt|;
block|}
comment|// Done matching, now verify:
name|boolean
name|fail
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|docID
init|=
literal|0
init|;
name|docID
operator|<
name|numDocs
condition|;
name|docID
operator|++
control|)
block|{
name|GeoPoint
name|point
init|=
name|docs
index|[
name|docID
index|]
decl_stmt|;
name|GeoPoint
name|mappedPoint
init|=
name|unquantizedDocs
index|[
name|docID
index|]
decl_stmt|;
name|boolean
name|expected
init|=
name|shape
operator|.
name|isWithin
argument_list|(
name|mappedPoint
argument_list|)
decl_stmt|;
name|boolean
name|actual
init|=
name|hits
operator|.
name|contains
argument_list|(
name|docID
argument_list|)
decl_stmt|;
if|if
condition|(
name|actual
operator|!=
name|expected
condition|)
block|{
if|if
condition|(
name|actual
condition|)
block|{
name|log
operator|.
name|println
argument_list|(
literal|"doc="
operator|+
name|docID
operator|+
literal|" should not have matched but did"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|println
argument_list|(
literal|"doc="
operator|+
name|docID
operator|+
literal|" should match but did not"
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|println
argument_list|(
literal|"  point="
operator|+
name|docs
index|[
name|docID
index|]
argument_list|)
expr_stmt|;
name|fail
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fail
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
name|sw
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"invalid hits for shape="
operator|+
name|shape
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|testRandomTiny
specifier|public
name|void
name|testRandomTiny
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Make sure single-leaf-node case is OK:
name|doTestRandom
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
DECL|method|testRandomMedium
specifier|public
name|void
name|testRandomMedium
parameter_list|()
throws|throws
name|Exception
block|{
name|doTestRandom
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Nightly
DECL|method|testRandomBig
specifier|public
name|void
name|testRandomBig
parameter_list|()
throws|throws
name|Exception
block|{
name|doTestRandom
argument_list|(
literal|200000
argument_list|)
expr_stmt|;
block|}
DECL|method|doTestRandom
specifier|private
name|void
name|doTestRandom
parameter_list|(
name|int
name|count
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|numPoints
init|=
name|atLeast
argument_list|(
name|count
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"TEST: numPoints="
operator|+
name|numPoints
argument_list|)
expr_stmt|;
block|}
name|double
index|[]
name|lats
init|=
operator|new
name|double
index|[
name|numPoints
index|]
decl_stmt|;
name|double
index|[]
name|lons
init|=
operator|new
name|double
index|[
name|numPoints
index|]
decl_stmt|;
name|boolean
name|haveRealDoc
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|docID
init|=
literal|0
init|;
name|docID
operator|<
name|numPoints
condition|;
name|docID
operator|++
control|)
block|{
name|int
name|x
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|20
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|17
condition|)
block|{
comment|// Some docs don't have a point:
name|lats
index|[
name|docID
index|]
operator|=
name|Double
operator|.
name|NaN
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  doc="
operator|+
name|docID
operator|+
literal|" is missing"
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|docID
operator|>
literal|0
operator|&&
name|x
operator|<
literal|3
operator|&&
name|haveRealDoc
condition|)
block|{
name|int
name|oldDocID
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|oldDocID
operator|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|docID
argument_list|)
expr_stmt|;
if|if
condition|(
name|Double
operator|.
name|isNaN
argument_list|(
name|lats
index|[
name|oldDocID
index|]
argument_list|)
operator|==
literal|false
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
comment|// Identical lat to old point
name|lats
index|[
name|docID
index|]
operator|=
name|lats
index|[
name|oldDocID
index|]
expr_stmt|;
name|lons
index|[
name|docID
index|]
operator|=
name|GeoTestUtil
operator|.
name|nextLongitude
argument_list|()
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  doc="
operator|+
name|docID
operator|+
literal|" lat="
operator|+
name|lats
index|[
name|docID
index|]
operator|+
literal|" lon="
operator|+
name|lons
index|[
name|docID
index|]
operator|+
literal|" (same lat as doc="
operator|+
name|oldDocID
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|1
condition|)
block|{
comment|// Identical lon to old point
name|lats
index|[
name|docID
index|]
operator|=
name|GeoTestUtil
operator|.
name|nextLatitude
argument_list|()
expr_stmt|;
name|lons
index|[
name|docID
index|]
operator|=
name|lons
index|[
name|oldDocID
index|]
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  doc="
operator|+
name|docID
operator|+
literal|" lat="
operator|+
name|lats
index|[
name|docID
index|]
operator|+
literal|" lon="
operator|+
name|lons
index|[
name|docID
index|]
operator|+
literal|" (same lon as doc="
operator|+
name|oldDocID
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|x
operator|==
literal|2
assert|;
comment|// Fully identical point:
name|lats
index|[
name|docID
index|]
operator|=
name|lats
index|[
name|oldDocID
index|]
expr_stmt|;
name|lons
index|[
name|docID
index|]
operator|=
name|lons
index|[
name|oldDocID
index|]
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  doc="
operator|+
name|docID
operator|+
literal|" lat="
operator|+
name|lats
index|[
name|docID
index|]
operator|+
literal|" lon="
operator|+
name|lons
index|[
name|docID
index|]
operator|+
literal|" (same lat/lon as doc="
operator|+
name|oldDocID
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|lats
index|[
name|docID
index|]
operator|=
name|GeoTestUtil
operator|.
name|nextLatitude
argument_list|()
expr_stmt|;
name|lons
index|[
name|docID
index|]
operator|=
name|GeoTestUtil
operator|.
name|nextLongitude
argument_list|()
expr_stmt|;
name|haveRealDoc
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  doc="
operator|+
name|docID
operator|+
literal|" lat="
operator|+
name|lats
index|[
name|docID
index|]
operator|+
literal|" lon="
operator|+
name|lons
index|[
name|docID
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|verify
argument_list|(
name|lats
argument_list|,
name|lons
argument_list|)
expr_stmt|;
block|}
DECL|method|testPolygonOrdering
specifier|public
name|void
name|testPolygonOrdering
parameter_list|()
block|{
specifier|final
name|double
index|[]
name|lats
init|=
operator|new
name|double
index|[]
block|{
literal|51.204382859999996
block|,
literal|50.89947531437482
block|,
literal|50.8093624806861
block|,
literal|50.8093624806861
block|,
literal|50.89947531437482
block|,
literal|51.204382859999996
block|,
literal|51.51015366140113
block|,
literal|51.59953838204167
block|,
literal|51.59953838204167
block|,
literal|51.51015366140113
block|,
literal|51.204382859999996
block|}
decl_stmt|;
specifier|final
name|double
index|[]
name|lons
init|=
operator|new
name|double
index|[]
block|{
literal|0.8747711978759765
block|,
literal|0.6509219832137298
block|,
literal|0.35960265165247807
block|,
literal|0.10290284834752167
block|,
operator|-
literal|0.18841648321373008
block|,
operator|-
literal|0.41226569787597667
block|,
operator|-
literal|0.18960465285650027
block|,
literal|0.10285893781346236
block|,
literal|0.35964656218653757
block|,
literal|0.6521101528565002
block|,
literal|0.8747711978759765
block|}
decl_stmt|;
specifier|final
name|Query
name|q
init|=
name|Geo3DPoint
operator|.
name|newPolygonQuery
argument_list|(
literal|"point"
argument_list|,
operator|new
name|Polygon
argument_list|(
name|lats
argument_list|,
name|lons
argument_list|)
argument_list|)
decl_stmt|;
comment|//System.out.println(q);
name|assertTrue
argument_list|(
operator|!
name|q
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
literal|"GeoConcavePolygon"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|field|MEAN_EARTH_RADIUS_METERS
specifier|private
specifier|static
specifier|final
name|double
name|MEAN_EARTH_RADIUS_METERS
init|=
name|PlanetModel
operator|.
name|WGS84_MEAN
decl_stmt|;
DECL|method|random3DQuery
specifier|private
specifier|static
name|Query
name|random3DQuery
parameter_list|(
specifier|final
name|String
name|field
parameter_list|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|shapeType
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|4
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|shapeType
condition|)
block|{
case|case
literal|0
case|:
block|{
comment|// Polygons
specifier|final
name|boolean
name|isClockwise
init|=
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|<
literal|0.5
decl_stmt|;
try|try
block|{
specifier|final
name|Query
name|q
init|=
name|Geo3DPoint
operator|.
name|newPolygonQuery
argument_list|(
name|field
argument_list|,
name|makePoly
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
operator|new
name|GeoPoint
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLatitude
argument_list|()
argument_list|)
argument_list|,
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLongitude
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|isClockwise
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
comment|//System.err.println("Generated: "+q);
comment|//assertTrue(false);
return|return
name|q
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
continue|continue;
block|}
block|}
case|case
literal|1
case|:
block|{
comment|// Circles
specifier|final
name|double
name|widthMeters
init|=
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|*
name|Math
operator|.
name|PI
operator|*
name|MEAN_EARTH_RADIUS_METERS
decl_stmt|;
try|try
block|{
return|return
name|Geo3DPoint
operator|.
name|newDistanceQuery
argument_list|(
name|field
argument_list|,
name|GeoTestUtil
operator|.
name|nextLatitude
argument_list|()
argument_list|,
name|GeoTestUtil
operator|.
name|nextLongitude
argument_list|()
argument_list|,
name|widthMeters
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
continue|continue;
block|}
block|}
case|case
literal|2
case|:
block|{
comment|// Rectangles
specifier|final
name|Rectangle
name|r
init|=
name|GeoTestUtil
operator|.
name|nextBox
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|Geo3DPoint
operator|.
name|newBoxQuery
argument_list|(
name|field
argument_list|,
name|r
operator|.
name|minLat
argument_list|,
name|r
operator|.
name|maxLat
argument_list|,
name|r
operator|.
name|minLon
argument_list|,
name|r
operator|.
name|maxLon
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
continue|continue;
block|}
block|}
case|case
literal|3
case|:
block|{
comment|// Paths
comment|// TBD: Need to rework generation to be realistic
specifier|final
name|int
name|pointCount
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|final
name|double
name|width
init|=
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|*
name|Math
operator|.
name|PI
operator|*
literal|0.5
operator|*
name|MEAN_EARTH_RADIUS_METERS
decl_stmt|;
specifier|final
name|double
index|[]
name|latitudes
init|=
operator|new
name|double
index|[
name|pointCount
index|]
decl_stmt|;
specifier|final
name|double
index|[]
name|longitudes
init|=
operator|new
name|double
index|[
name|pointCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
name|i
operator|++
control|)
block|{
name|latitudes
index|[
name|i
index|]
operator|=
name|GeoTestUtil
operator|.
name|nextLatitude
argument_list|()
expr_stmt|;
name|longitudes
index|[
name|i
index|]
operator|=
name|GeoTestUtil
operator|.
name|nextLongitude
argument_list|()
expr_stmt|;
block|}
try|try
block|{
return|return
name|Geo3DPoint
operator|.
name|newPathQuery
argument_list|(
name|field
argument_list|,
name|latitudes
argument_list|,
name|longitudes
argument_list|,
name|width
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// This is what happens when we create a shape that is invalid.  Although it is conceivable that there are cases where
comment|// the exception is thrown incorrectly, we aren't going to be able to do that in this random test.
continue|continue;
block|}
block|}
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unexpected shape type"
argument_list|)
throw|;
block|}
block|}
block|}
comment|// Poached from Geo3dRptTest.randomShape:
DECL|method|randomShape
specifier|private
specifier|static
name|GeoShape
name|randomShape
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|shapeType
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|4
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|shapeType
condition|)
block|{
case|case
literal|0
case|:
block|{
comment|// Polygons
specifier|final
name|int
name|vertexCount
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|+
literal|3
decl_stmt|;
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|geoPoints
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|geoPoints
operator|.
name|size
argument_list|()
operator|<
name|vertexCount
condition|)
block|{
specifier|final
name|GeoPoint
name|gPt
init|=
operator|new
name|GeoPoint
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLatitude
argument_list|()
argument_list|)
argument_list|,
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLongitude
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|geoPoints
operator|.
name|add
argument_list|(
name|gPt
argument_list|)
expr_stmt|;
block|}
try|try
block|{
return|return
name|GeoPolygonFactory
operator|.
name|makeGeoPolygon
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|geoPoints
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// This is what happens when we create a shape that is invalid.  Although it is conceivable that there are cases where
comment|// the exception is thrown incorrectly, we aren't going to be able to do that in this random test.
continue|continue;
block|}
block|}
case|case
literal|1
case|:
block|{
comment|// Circles
name|double
name|lat
init|=
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLatitude
argument_list|()
argument_list|)
decl_stmt|;
name|double
name|lon
init|=
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLongitude
argument_list|()
argument_list|)
decl_stmt|;
name|double
name|angle
init|=
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|*
name|Math
operator|.
name|PI
operator|/
literal|2.0
decl_stmt|;
try|try
block|{
return|return
name|GeoCircleFactory
operator|.
name|makeGeoCircle
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|lat
argument_list|,
name|lon
argument_list|,
name|angle
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// angle is too small; try again:
continue|continue;
block|}
block|}
case|case
literal|2
case|:
block|{
comment|// Rectangles
name|double
name|lat0
init|=
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLatitude
argument_list|()
argument_list|)
decl_stmt|;
name|double
name|lat1
init|=
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLatitude
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lat1
operator|<
name|lat0
condition|)
block|{
name|double
name|x
init|=
name|lat0
decl_stmt|;
name|lat0
operator|=
name|lat1
expr_stmt|;
name|lat1
operator|=
name|x
expr_stmt|;
block|}
name|double
name|lon0
init|=
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLongitude
argument_list|()
argument_list|)
decl_stmt|;
name|double
name|lon1
init|=
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLongitude
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lon1
operator|<
name|lon0
condition|)
block|{
name|double
name|x
init|=
name|lon0
decl_stmt|;
name|lon0
operator|=
name|lon1
expr_stmt|;
name|lon1
operator|=
name|x
expr_stmt|;
block|}
return|return
name|GeoBBoxFactory
operator|.
name|makeGeoBBox
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|lat1
argument_list|,
name|lat0
argument_list|,
name|lon0
argument_list|,
name|lon1
argument_list|)
return|;
block|}
case|case
literal|3
case|:
block|{
comment|// Paths
specifier|final
name|int
name|pointCount
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|final
name|double
name|width
init|=
name|toRadians
argument_list|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|89
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|points
init|=
operator|new
name|GeoPoint
index|[
name|pointCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
name|i
operator|++
control|)
block|{
name|points
index|[
name|i
index|]
operator|=
operator|new
name|GeoPoint
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLatitude
argument_list|()
argument_list|)
argument_list|,
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLongitude
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
return|return
name|GeoPathFactory
operator|.
name|makeGeoPath
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|width
argument_list|,
name|points
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// This is what happens when we create a shape that is invalid.  Although it is conceivable that there are cases where
comment|// the exception is thrown incorrectly, we aren't going to be able to do that in this random test.
continue|continue;
block|}
block|}
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unexpected shape type"
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|verify
specifier|private
specifier|static
name|void
name|verify
parameter_list|(
name|double
index|[]
name|lats
parameter_list|,
name|double
index|[]
name|lons
parameter_list|)
throws|throws
name|Exception
block|{
name|IndexWriterConfig
name|iwc
init|=
name|newIndexWriterConfig
argument_list|()
decl_stmt|;
name|GeoPoint
index|[]
name|points
init|=
operator|new
name|GeoPoint
index|[
name|lats
operator|.
name|length
index|]
decl_stmt|;
name|GeoPoint
index|[]
name|unquantizedPoints
init|=
operator|new
name|GeoPoint
index|[
name|lats
operator|.
name|length
index|]
decl_stmt|;
comment|// Pre-quantize all lat/lons:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lats
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Double
operator|.
name|isNaN
argument_list|(
name|lats
index|[
name|i
index|]
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|//System.out.println("lats[" + i + "] = " + lats[i]);
name|unquantizedPoints
index|[
name|i
index|]
operator|=
operator|new
name|GeoPoint
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|toRadians
argument_list|(
name|lats
index|[
name|i
index|]
argument_list|)
argument_list|,
name|toRadians
argument_list|(
name|lons
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|points
index|[
name|i
index|]
operator|=
name|quantize
argument_list|(
name|unquantizedPoints
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Else we can get O(N^2) merging:
name|int
name|mbd
init|=
name|iwc
operator|.
name|getMaxBufferedDocs
argument_list|()
decl_stmt|;
if|if
condition|(
name|mbd
operator|!=
operator|-
literal|1
operator|&&
name|mbd
operator|<
name|points
operator|.
name|length
operator|/
literal|100
condition|)
block|{
name|iwc
operator|.
name|setMaxBufferedDocs
argument_list|(
name|points
operator|.
name|length
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
name|iwc
operator|.
name|setCodec
argument_list|(
name|getCodec
argument_list|()
argument_list|)
expr_stmt|;
name|Directory
name|dir
decl_stmt|;
if|if
condition|(
name|points
operator|.
name|length
operator|>
literal|100000
condition|)
block|{
name|dir
operator|=
name|newFSDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"TestBKDTree"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|=
name|getDirectory
argument_list|()
expr_stmt|;
block|}
name|Set
argument_list|<
name|Integer
argument_list|>
name|deleted
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// RandomIndexWriter is too slow here:
name|IndexWriter
name|w
init|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|iwc
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|id
init|=
literal|0
init|;
name|id
operator|<
name|points
operator|.
name|length
condition|;
name|id
operator|++
control|)
block|{
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
name|id
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|NumericDocValuesField
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|GeoPoint
name|point
init|=
name|points
index|[
name|id
index|]
decl_stmt|;
if|if
condition|(
name|point
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|add
argument_list|(
operator|new
name|Geo3DPoint
argument_list|(
literal|"point"
argument_list|,
name|point
operator|.
name|x
argument_list|,
name|point
operator|.
name|y
argument_list|,
name|point
operator|.
name|z
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|>
literal|0
operator|&&
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|100
argument_list|)
operator|==
literal|42
condition|)
block|{
name|int
name|idToDelete
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|w
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"id"
argument_list|,
literal|""
operator|+
name|idToDelete
argument_list|)
argument_list|)
expr_stmt|;
name|deleted
operator|.
name|add
argument_list|(
name|idToDelete
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  delete id="
operator|+
name|idToDelete
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|w
operator|.
name|forceMerge
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|final
name|IndexReader
name|r
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|w
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: using reader "
operator|+
name|r
argument_list|)
expr_stmt|;
block|}
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// We can't wrap with "exotic" readers because the geo3d query must see the Geo3DDVFormat:
name|IndexSearcher
name|s
init|=
name|newSearcher
argument_list|(
name|r
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|int
name|iters
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|NumericDocValues
name|docIDToID
init|=
name|MultiDocValues
operator|.
name|getNumericValues
argument_list|(
name|r
argument_list|,
literal|"id"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|iters
condition|;
name|iter
operator|++
control|)
block|{
comment|/*       GeoShape shape = randomShape();        if (VERBOSE) {         System.err.println("\nTEST: iter=" + iter + " shape="+shape);       }       */
name|Query
name|query
init|=
name|random3DQuery
argument_list|(
literal|"point"
argument_list|)
decl_stmt|;
comment|// Geo3DPoint.newShapeQuery("point", shape);
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  using query: "
operator|+
name|query
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FixedBitSet
name|hits
init|=
operator|new
name|FixedBitSet
argument_list|(
name|r
operator|.
name|maxDoc
argument_list|()
argument_list|)
decl_stmt|;
name|s
operator|.
name|search
argument_list|(
name|query
argument_list|,
operator|new
name|SimpleCollector
argument_list|()
block|{
specifier|private
name|int
name|docBase
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|needsScores
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doSetNextReader
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|docBase
operator|=
name|context
operator|.
name|docBase
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
name|hits
operator|.
name|set
argument_list|(
name|docBase
operator|+
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  hitCount: "
operator|+
name|hits
operator|.
name|cardinality
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|docID
init|=
literal|0
init|;
name|docID
operator|<
name|r
operator|.
name|maxDoc
argument_list|()
condition|;
name|docID
operator|++
control|)
block|{
name|int
name|id
init|=
operator|(
name|int
operator|)
name|docIDToID
operator|.
name|get
argument_list|(
name|docID
argument_list|)
decl_stmt|;
name|GeoPoint
name|point
init|=
name|points
index|[
name|id
index|]
decl_stmt|;
name|GeoPoint
name|unquantizedPoint
init|=
name|unquantizedPoints
index|[
name|id
index|]
decl_stmt|;
if|if
condition|(
name|point
operator|!=
literal|null
operator|&&
name|unquantizedPoint
operator|!=
literal|null
condition|)
block|{
name|GeoShape
name|shape
init|=
operator|(
operator|(
name|PointInGeo3DShapeQuery
operator|)
name|query
operator|)
operator|.
name|getShape
argument_list|()
decl_stmt|;
name|XYZBounds
name|bounds
init|=
operator|new
name|XYZBounds
argument_list|()
decl_stmt|;
name|shape
operator|.
name|getBounds
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
name|XYZSolid
name|solid
init|=
name|XYZSolidFactory
operator|.
name|makeXYZSolid
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|bounds
operator|.
name|getMinimumX
argument_list|()
argument_list|,
name|bounds
operator|.
name|getMaximumX
argument_list|()
argument_list|,
name|bounds
operator|.
name|getMinimumY
argument_list|()
argument_list|,
name|bounds
operator|.
name|getMaximumY
argument_list|()
argument_list|,
name|bounds
operator|.
name|getMinimumZ
argument_list|()
argument_list|,
name|bounds
operator|.
name|getMaximumZ
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|expected
init|=
operator|(
operator|(
name|deleted
operator|.
name|contains
argument_list|(
name|id
argument_list|)
operator|==
literal|false
operator|)
operator|&&
name|shape
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|hits
operator|.
name|get
argument_list|(
name|docID
argument_list|)
operator|!=
name|expected
condition|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|expected
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"FAIL: id="
operator|+
name|id
operator|+
literal|" should have matched but did not\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|append
argument_list|(
literal|"FAIL: id="
operator|+
name|id
operator|+
literal|" should not have matched but did\n"
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|"  shape="
operator|+
name|shape
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"  bounds="
operator|+
name|bounds
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"  world bounds=("
operator|+
literal|" minX="
operator|+
name|PlanetModel
operator|.
name|WGS84
operator|.
name|getMinimumXValue
argument_list|()
operator|+
literal|" maxX="
operator|+
name|PlanetModel
operator|.
name|WGS84
operator|.
name|getMaximumXValue
argument_list|()
operator|+
literal|" minY="
operator|+
name|PlanetModel
operator|.
name|WGS84
operator|.
name|getMinimumYValue
argument_list|()
operator|+
literal|" maxY="
operator|+
name|PlanetModel
operator|.
name|WGS84
operator|.
name|getMaximumYValue
argument_list|()
operator|+
literal|" minZ="
operator|+
name|PlanetModel
operator|.
name|WGS84
operator|.
name|getMinimumZValue
argument_list|()
operator|+
literal|" maxZ="
operator|+
name|PlanetModel
operator|.
name|WGS84
operator|.
name|getMaximumZValue
argument_list|()
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"  quantized point="
operator|+
name|point
operator|+
literal|" within shape? "
operator|+
name|shape
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
operator|+
literal|" within bounds? "
operator|+
name|solid
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"  unquantized point="
operator|+
name|unquantizedPoint
operator|+
literal|" within shape? "
operator|+
name|shape
operator|.
name|isWithin
argument_list|(
name|unquantizedPoint
argument_list|)
operator|+
literal|" within bounds? "
operator|+
name|solid
operator|.
name|isWithin
argument_list|(
name|unquantizedPoint
argument_list|)
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"  docID="
operator|+
name|docID
operator|+
literal|" deleted?="
operator|+
name|deleted
operator|.
name|contains
argument_list|(
name|id
argument_list|)
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"  query="
operator|+
name|query
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"  explanation:\n    "
operator|+
name|explain
argument_list|(
literal|"point"
argument_list|,
name|shape
argument_list|,
name|point
argument_list|,
name|unquantizedPoint
argument_list|,
name|r
argument_list|,
name|docID
argument_list|)
operator|.
name|replace
argument_list|(
literal|"\n"
argument_list|,
literal|"\n  "
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|b
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assertFalse
argument_list|(
name|hits
operator|.
name|get
argument_list|(
name|docID
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|IOUtils
operator|.
name|close
argument_list|(
name|r
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
DECL|method|testToString
specifier|public
name|void
name|testToString
parameter_list|()
block|{
comment|// Don't compare entire strings because Java 9 and Java 8 have slightly different values
name|Geo3DPoint
name|point
init|=
operator|new
name|Geo3DPoint
argument_list|(
literal|"point"
argument_list|,
literal|44.244272
argument_list|,
literal|7.769736
argument_list|)
decl_stmt|;
specifier|final
name|String
name|stringToCompare
init|=
literal|"Geo3DPoint<point: x="
decl_stmt|;
name|assertEquals
argument_list|(
name|stringToCompare
argument_list|,
name|point
operator|.
name|toString
argument_list|()
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|stringToCompare
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testShapeQueryToString
specifier|public
name|void
name|testShapeQueryToString
parameter_list|()
block|{
comment|// Don't compare entire strings because Java 9 and Java 8 have slightly different values
specifier|final
name|String
name|stringToCompare
init|=
literal|"PointInGeo3DShapeQuery: field=point: Shape: GeoStandardCircle: {planetmodel=PlanetModel.WGS84, center=[lat=0.7"
decl_stmt|;
name|assertEquals
argument_list|(
name|stringToCompare
argument_list|,
name|Geo3DPoint
operator|.
name|newShapeQuery
argument_list|(
literal|"point"
argument_list|,
name|GeoCircleFactory
operator|.
name|makeGeoCircle
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|toRadians
argument_list|(
literal|44.244272
argument_list|)
argument_list|,
name|toRadians
argument_list|(
literal|7.769736
argument_list|)
argument_list|,
literal|0.1
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|stringToCompare
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getDirectory
specifier|private
specifier|static
name|Directory
name|getDirectory
parameter_list|()
block|{
return|return
name|newDirectory
argument_list|()
return|;
block|}
DECL|method|testEquals
specifier|public
name|void
name|testEquals
parameter_list|()
block|{
name|GeoShape
name|shape
init|=
name|randomShape
argument_list|()
decl_stmt|;
name|Query
name|q
init|=
name|Geo3DPoint
operator|.
name|newShapeQuery
argument_list|(
literal|"point"
argument_list|,
name|shape
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|q
argument_list|,
name|Geo3DPoint
operator|.
name|newShapeQuery
argument_list|(
literal|"point"
argument_list|,
name|shape
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|q
operator|.
name|equals
argument_list|(
name|Geo3DPoint
operator|.
name|newShapeQuery
argument_list|(
literal|"point2"
argument_list|,
name|shape
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// make a different random shape:
name|GeoShape
name|shape2
decl_stmt|;
do|do
block|{
name|shape2
operator|=
name|randomShape
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|shape
operator|.
name|equals
argument_list|(
name|shape2
argument_list|)
condition|)
do|;
name|assertFalse
argument_list|(
name|q
operator|.
name|equals
argument_list|(
name|Geo3DPoint
operator|.
name|newShapeQuery
argument_list|(
literal|"point"
argument_list|,
name|shape2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testComplexPolygons
specifier|public
name|void
name|testComplexPolygons
parameter_list|()
block|{
specifier|final
name|PlanetModel
name|pm
init|=
name|PlanetModel
operator|.
name|WGS84
decl_stmt|;
comment|// Pick a random pole
specifier|final
name|GeoPoint
name|randomPole
init|=
operator|new
name|GeoPoint
argument_list|(
name|pm
argument_list|,
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLatitude
argument_list|()
argument_list|)
argument_list|,
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLongitude
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|iters
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iters
condition|;
name|i
operator|++
control|)
block|{
comment|// Create a polygon that's less than 180 degrees
specifier|final
name|Polygon
name|clockWise
init|=
name|makePoly
argument_list|(
name|pm
argument_list|,
name|randomPole
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
block|}
name|iters
operator|=
name|atLeast
argument_list|(
literal|100
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iters
condition|;
name|i
operator|++
control|)
block|{
comment|// Create a polygon that's greater than 180 degrees
specifier|final
name|Polygon
name|counterClockWise
init|=
name|makePoly
argument_list|(
name|pm
argument_list|,
name|randomPole
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
block|}
block|}
DECL|field|MINIMUM_EDGE_ANGLE
specifier|protected
specifier|static
name|double
name|MINIMUM_EDGE_ANGLE
init|=
name|toRadians
argument_list|(
literal|5.0
argument_list|)
decl_stmt|;
DECL|field|MINIMUM_ARC_ANGLE
specifier|protected
specifier|static
name|double
name|MINIMUM_ARC_ANGLE
init|=
name|toRadians
argument_list|(
literal|1.0
argument_list|)
decl_stmt|;
comment|/** Cook up a random Polygon that makes sense, with possible nested polygon within.     * This is part of testing more complex polygons with nested holes.  Picking random points     * doesn't do it because it's almost impossible to come up with nested ones of the proper      * clockwise/counterclockwise rotation that way.     */
DECL|method|makePoly
specifier|protected
specifier|static
name|Polygon
name|makePoly
parameter_list|(
specifier|final
name|PlanetModel
name|pm
parameter_list|,
specifier|final
name|GeoPoint
name|pole
parameter_list|,
specifier|final
name|boolean
name|clockwiseDesired
parameter_list|,
specifier|final
name|boolean
name|createHoles
parameter_list|)
block|{
comment|// Polygon edges will be arranged around the provided pole, and holes will each have a pole selected within the parent
comment|// polygon.
specifier|final
name|int
name|pointCount
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|3
argument_list|,
literal|10
argument_list|)
decl_stmt|;
comment|// The point angles we pick next.  The only requirement is that they are not all on one side of the pole.
comment|// We arrange that by picking the next point within what's left of the remaining angle, but never more than 180 degrees,
comment|// and never less than what is needed to insure that the remaining point choices are less than 180 degrees always.
comment|// These are all picked in the context of the pole,
specifier|final
name|double
index|[]
name|angles
init|=
operator|new
name|double
index|[
name|pointCount
index|]
decl_stmt|;
specifier|final
name|double
index|[]
name|arcDistance
init|=
operator|new
name|double
index|[
name|pointCount
index|]
decl_stmt|;
comment|// Pick a set of points
while|while
condition|(
literal|true
condition|)
block|{
name|double
name|accumulatedAngle
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|remainingEdgeCount
init|=
name|pointCount
operator|-
name|i
decl_stmt|;
specifier|final
name|double
name|remainingAngle
init|=
literal|2.0
operator|*
name|Math
operator|.
name|PI
operator|-
name|accumulatedAngle
decl_stmt|;
if|if
condition|(
name|remainingEdgeCount
operator|==
literal|1
condition|)
block|{
name|angles
index|[
name|i
index|]
operator|=
name|remainingAngle
expr_stmt|;
block|}
else|else
block|{
comment|// The maximum angle is 180 degrees, or what's left when you give a minimal amount to each edge.
name|double
name|maximumAngle
init|=
name|remainingAngle
operator|-
operator|(
name|remainingEdgeCount
operator|-
literal|1
operator|)
operator|*
name|MINIMUM_EDGE_ANGLE
decl_stmt|;
if|if
condition|(
name|maximumAngle
operator|>
name|Math
operator|.
name|PI
condition|)
block|{
name|maximumAngle
operator|=
name|Math
operator|.
name|PI
expr_stmt|;
block|}
comment|// The minimum angle is MINIMUM_EDGE_ANGLE, or enough to be sure nobody afterwards needs more than
comment|// 180 degrees.  And since we have three points to start with, we already know that.
specifier|final
name|double
name|minimumAngle
init|=
name|MINIMUM_EDGE_ANGLE
decl_stmt|;
comment|// Pick the angle
specifier|final
name|double
name|angle
init|=
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|*
operator|(
name|maximumAngle
operator|-
name|minimumAngle
operator|)
operator|+
name|minimumAngle
decl_stmt|;
name|angles
index|[
name|i
index|]
operator|=
name|angle
expr_stmt|;
name|accumulatedAngle
operator|+=
name|angle
expr_stmt|;
block|}
comment|// Pick the arc distance randomly
name|arcDistance
index|[
name|i
index|]
operator|=
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|*
operator|(
name|Math
operator|.
name|PI
operator|-
name|MINIMUM_ARC_ANGLE
operator|)
operator|+
name|MINIMUM_ARC_ANGLE
expr_stmt|;
block|}
if|if
condition|(
name|clockwiseDesired
condition|)
block|{
comment|// Reverse the signs
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
name|i
operator|++
control|)
block|{
name|angles
index|[
name|i
index|]
operator|=
operator|-
name|angles
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|// Now, use the pole's information plus angles and arcs to create GeoPoints in the right order.
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|polyPoints
init|=
name|convertToPoints
argument_list|(
name|pm
argument_list|,
name|pole
argument_list|,
name|angles
argument_list|,
name|arcDistance
argument_list|)
decl_stmt|;
comment|// Create the geo3d polygon, so we can test out our poles.
specifier|final
name|GeoPolygon
name|poly
decl_stmt|;
try|try
block|{
name|poly
operator|=
name|GeoPolygonFactory
operator|.
name|makeGeoPolygon
argument_list|(
name|pm
argument_list|,
name|polyPoints
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// This is what happens when three adjacent points are colinear, so try again.
continue|continue;
block|}
comment|// Next, do some holes.  No more than 2 of these.  The poles for holes must always be within the polygon, so we're
comment|// going to use Geo3D to help us select those given the points we just made.
specifier|final
name|int
name|holeCount
init|=
name|createHoles
condition|?
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
else|:
literal|0
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Polygon
argument_list|>
name|holeList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|holeCount
condition|;
name|i
operator|++
control|)
block|{
comment|// Choose a pole.  The poly has to be within the polygon, but it also cannot be on the polygon edge.
comment|// If we can't find a good pole we have to give it up and not do the hole.
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
literal|500
condition|;
name|k
operator|++
control|)
block|{
specifier|final
name|GeoPoint
name|poleChoice
init|=
operator|new
name|GeoPoint
argument_list|(
name|pm
argument_list|,
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLatitude
argument_list|()
argument_list|)
argument_list|,
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLongitude
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|poly
operator|.
name|isWithin
argument_list|(
name|poleChoice
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// We have a pole within the polygon.  Now try 100 times to build a polygon that does not intersect the outside ring.
comment|// After that we give up and pick a new pole.
name|boolean
name|foundOne
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|100
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|Polygon
name|insidePoly
init|=
name|makePoly
argument_list|(
name|pm
argument_list|,
name|poleChoice
argument_list|,
operator|!
name|clockwiseDesired
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Verify that the inside polygon is OK.  If not, discard and repeat.
if|if
condition|(
operator|!
name|verifyPolygon
argument_list|(
name|pm
argument_list|,
name|insidePoly
argument_list|,
name|poly
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|holeList
operator|.
name|add
argument_list|(
name|insidePoly
argument_list|)
expr_stmt|;
name|foundOne
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|foundOne
condition|)
block|{
break|break;
block|}
block|}
block|}
specifier|final
name|Polygon
index|[]
name|holes
init|=
name|holeList
operator|.
name|toArray
argument_list|(
operator|new
name|Polygon
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|// Finally, build the polygon and return it
specifier|final
name|double
index|[]
name|lats
init|=
operator|new
name|double
index|[
name|polyPoints
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
specifier|final
name|double
index|[]
name|lons
init|=
operator|new
name|double
index|[
name|polyPoints
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|polyPoints
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|lats
index|[
name|i
index|]
operator|=
name|polyPoints
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getLatitude
argument_list|()
operator|*
literal|180.0
operator|/
name|Math
operator|.
name|PI
expr_stmt|;
name|lons
index|[
name|i
index|]
operator|=
name|polyPoints
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getLongitude
argument_list|()
operator|*
literal|180.0
operator|/
name|Math
operator|.
name|PI
expr_stmt|;
block|}
name|lats
index|[
name|polyPoints
operator|.
name|size
argument_list|()
index|]
operator|=
name|lats
index|[
literal|0
index|]
expr_stmt|;
name|lons
index|[
name|polyPoints
operator|.
name|size
argument_list|()
index|]
operator|=
name|lons
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|new
name|Polygon
argument_list|(
name|lats
argument_list|,
name|lons
argument_list|,
name|holes
argument_list|)
return|;
block|}
block|}
DECL|method|convertToPoints
specifier|protected
specifier|static
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|convertToPoints
parameter_list|(
specifier|final
name|PlanetModel
name|pm
parameter_list|,
specifier|final
name|GeoPoint
name|pole
parameter_list|,
specifier|final
name|double
index|[]
name|angles
parameter_list|,
specifier|final
name|double
index|[]
name|arcDistances
parameter_list|)
block|{
comment|// To do the point rotations, we need the sine and cosine of the pole latitude and longitude.  Get it here for performance.
specifier|final
name|double
name|sinLatitude
init|=
name|Math
operator|.
name|sin
argument_list|(
name|pole
operator|.
name|getLatitude
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|double
name|cosLatitude
init|=
name|Math
operator|.
name|cos
argument_list|(
name|pole
operator|.
name|getLatitude
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|double
name|sinLongitude
init|=
name|Math
operator|.
name|sin
argument_list|(
name|pole
operator|.
name|getLongitude
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|double
name|cosLongitude
init|=
name|Math
operator|.
name|cos
argument_list|(
name|pole
operator|.
name|getLongitude
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|rval
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|angles
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|rval
operator|.
name|add
argument_list|(
name|createPoint
argument_list|(
name|pm
argument_list|,
name|angles
index|[
name|i
index|]
argument_list|,
name|arcDistances
index|[
name|i
index|]
argument_list|,
name|sinLatitude
argument_list|,
name|cosLatitude
argument_list|,
name|sinLongitude
argument_list|,
name|cosLongitude
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
DECL|method|createPoint
specifier|protected
specifier|static
name|GeoPoint
name|createPoint
parameter_list|(
specifier|final
name|PlanetModel
name|pm
parameter_list|,
specifier|final
name|double
name|angle
parameter_list|,
specifier|final
name|double
name|arcDistance
parameter_list|,
specifier|final
name|double
name|sinLatitude
parameter_list|,
specifier|final
name|double
name|cosLatitude
parameter_list|,
specifier|final
name|double
name|sinLongitude
parameter_list|,
specifier|final
name|double
name|cosLongitude
parameter_list|)
block|{
comment|// From the angle and arc distance, convert to (x,y,z) in unit space.
comment|// We want the perspective to be looking down the x axis.  The "angle" measurement is thus in the Y-Z plane.
comment|// The arcdistance is in X.
specifier|final
name|double
name|x
init|=
name|Math
operator|.
name|cos
argument_list|(
name|arcDistance
argument_list|)
decl_stmt|;
specifier|final
name|double
name|yzScale
init|=
name|Math
operator|.
name|sin
argument_list|(
name|arcDistance
argument_list|)
decl_stmt|;
specifier|final
name|double
name|y
init|=
name|Math
operator|.
name|cos
argument_list|(
name|angle
argument_list|)
operator|*
name|yzScale
decl_stmt|;
specifier|final
name|double
name|z
init|=
name|Math
operator|.
name|sin
argument_list|(
name|angle
argument_list|)
operator|*
name|yzScale
decl_stmt|;
comment|// Now, rotate coordinates so that we shift everything from pole = x-axis to actual coordinates.
comment|// This transformation should take the point (1,0,0) and transform it to the pole's actual (x,y,z) coordinates.
comment|// Coordinate rotation formula:
comment|// x1 = x0 cos T - y0 sin T
comment|// y1 = x0 sin T + y0 cos T
comment|// We're in essence undoing the following transformation (from GeoPolygonFactory):
comment|// x1 = x0 cos az + y0 sin az
comment|// y1 = - x0 sin az + y0 cos az
comment|// z1 = z0
comment|// x2 = x1 cos al + z1 sin al
comment|// y2 = y1
comment|// z2 = - x1 sin al + z1 cos al
comment|// So, we reverse the order of the transformations, AND we transform backwards.
comment|// Transforming backwards means using these identities: sin(-angle) = -sin(angle), cos(-angle) = cos(angle)
comment|// So:
comment|// x1 = x0 cos al - z0 sin al
comment|// y1 = y0
comment|// z1 = x0 sin al + z0 cos al
comment|// x2 = x1 cos az - y1 sin az
comment|// y2 = x1 sin az + y1 cos az
comment|// z2 = z1
specifier|final
name|double
name|x1
init|=
name|x
operator|*
name|cosLatitude
operator|-
name|z
operator|*
name|sinLatitude
decl_stmt|;
specifier|final
name|double
name|y1
init|=
name|y
decl_stmt|;
specifier|final
name|double
name|z1
init|=
name|x
operator|*
name|sinLatitude
operator|+
name|z
operator|*
name|cosLatitude
decl_stmt|;
specifier|final
name|double
name|x2
init|=
name|x1
operator|*
name|cosLongitude
operator|-
name|y1
operator|*
name|sinLongitude
decl_stmt|;
specifier|final
name|double
name|y2
init|=
name|x1
operator|*
name|sinLongitude
operator|+
name|y1
operator|*
name|cosLongitude
decl_stmt|;
specifier|final
name|double
name|z2
init|=
name|z1
decl_stmt|;
comment|// Scale to put the point on the surface
return|return
name|pm
operator|.
name|createSurfacePoint
argument_list|(
name|x2
argument_list|,
name|y2
argument_list|,
name|z2
argument_list|)
return|;
block|}
DECL|method|verifyPolygon
specifier|protected
specifier|static
name|boolean
name|verifyPolygon
parameter_list|(
specifier|final
name|PlanetModel
name|pm
parameter_list|,
specifier|final
name|Polygon
name|polygon
parameter_list|,
specifier|final
name|GeoPolygon
name|outsidePolygon
parameter_list|)
block|{
comment|// Each point in the new poly should be inside the outside poly, and each edge should not intersect the outside poly edge
specifier|final
name|double
index|[]
name|lats
init|=
name|polygon
operator|.
name|getPolyLats
argument_list|()
decl_stmt|;
specifier|final
name|double
index|[]
name|lons
init|=
name|polygon
operator|.
name|getPolyLons
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|polyPoints
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|lats
operator|.
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lats
operator|.
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|GeoPoint
name|newPoint
init|=
operator|new
name|GeoPoint
argument_list|(
name|pm
argument_list|,
name|toRadians
argument_list|(
name|lats
index|[
name|i
index|]
argument_list|)
argument_list|,
name|toRadians
argument_list|(
name|lons
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|outsidePolygon
operator|.
name|isWithin
argument_list|(
name|newPoint
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|polyPoints
operator|.
name|add
argument_list|(
name|newPoint
argument_list|)
expr_stmt|;
block|}
comment|// We don't need to construct the world to find intersections -- just the bordering planes.
for|for
control|(
name|int
name|planeIndex
init|=
literal|0
init|;
name|planeIndex
operator|<
name|polyPoints
operator|.
name|size
argument_list|()
condition|;
name|planeIndex
operator|++
control|)
block|{
specifier|final
name|GeoPoint
name|startPoint
init|=
name|polyPoints
operator|.
name|get
argument_list|(
name|planeIndex
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
name|endPoint
init|=
name|polyPoints
operator|.
name|get
argument_list|(
name|legalIndex
argument_list|(
name|planeIndex
operator|+
literal|1
argument_list|,
name|polyPoints
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
name|beforeStartPoint
init|=
name|polyPoints
operator|.
name|get
argument_list|(
name|legalIndex
argument_list|(
name|planeIndex
operator|-
literal|1
argument_list|,
name|polyPoints
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
name|afterEndPoint
init|=
name|polyPoints
operator|.
name|get
argument_list|(
name|legalIndex
argument_list|(
name|planeIndex
operator|+
literal|2
argument_list|,
name|polyPoints
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SidedPlane
name|beforePlane
init|=
operator|new
name|SidedPlane
argument_list|(
name|endPoint
argument_list|,
name|beforeStartPoint
argument_list|,
name|startPoint
argument_list|)
decl_stmt|;
specifier|final
name|SidedPlane
name|afterPlane
init|=
operator|new
name|SidedPlane
argument_list|(
name|startPoint
argument_list|,
name|endPoint
argument_list|,
name|afterEndPoint
argument_list|)
decl_stmt|;
specifier|final
name|Plane
name|plane
init|=
operator|new
name|Plane
argument_list|(
name|startPoint
argument_list|,
name|endPoint
argument_list|)
decl_stmt|;
comment|// Check for intersections!!
if|if
condition|(
name|outsidePolygon
operator|.
name|intersects
argument_list|(
name|plane
argument_list|,
literal|null
argument_list|,
name|beforePlane
argument_list|,
name|afterPlane
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|legalIndex
specifier|protected
specifier|static
name|int
name|legalIndex
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|index
operator|>=
name|size
condition|)
block|{
name|index
operator|-=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|index
operator|+=
name|size
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
DECL|method|testEncodeDecodeCeil
specifier|public
name|void
name|testEncodeDecodeCeil
parameter_list|()
throws|throws
name|Exception
block|{
comment|// just for testing quantization error
specifier|final
name|double
name|ENCODING_TOLERANCE
init|=
name|Geo3DUtil
operator|.
name|DECODE
decl_stmt|;
name|int
name|iters
init|=
name|atLeast
argument_list|(
literal|10000
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|iters
condition|;
name|iter
operator|++
control|)
block|{
name|GeoPoint
name|point
init|=
operator|new
name|GeoPoint
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLatitude
argument_list|()
argument_list|)
argument_list|,
name|toRadians
argument_list|(
name|GeoTestUtil
operator|.
name|nextLongitude
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|xEnc
init|=
name|Geo3DUtil
operator|.
name|decodeValue
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|point
operator|.
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"x="
operator|+
name|point
operator|.
name|x
operator|+
literal|" xEnc="
operator|+
name|xEnc
operator|+
literal|" diff="
operator|+
operator|(
name|point
operator|.
name|x
operator|-
name|xEnc
operator|)
argument_list|,
name|point
operator|.
name|x
argument_list|,
name|xEnc
argument_list|,
name|ENCODING_TOLERANCE
argument_list|)
expr_stmt|;
name|double
name|yEnc
init|=
name|Geo3DUtil
operator|.
name|decodeValue
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|point
operator|.
name|y
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"y="
operator|+
name|point
operator|.
name|y
operator|+
literal|" yEnc="
operator|+
name|yEnc
operator|+
literal|" diff="
operator|+
operator|(
name|point
operator|.
name|y
operator|-
name|yEnc
operator|)
argument_list|,
name|point
operator|.
name|y
argument_list|,
name|yEnc
argument_list|,
name|ENCODING_TOLERANCE
argument_list|)
expr_stmt|;
name|double
name|zEnc
init|=
name|Geo3DUtil
operator|.
name|decodeValue
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|point
operator|.
name|z
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"z="
operator|+
name|point
operator|.
name|z
operator|+
literal|" zEnc="
operator|+
name|zEnc
operator|+
literal|" diff="
operator|+
operator|(
name|point
operator|.
name|z
operator|-
name|zEnc
operator|)
argument_list|,
name|point
operator|.
name|z
argument_list|,
name|zEnc
argument_list|,
name|ENCODING_TOLERANCE
argument_list|)
expr_stmt|;
block|}
comment|// check edge/interesting cases explicitly
name|double
name|planetMax
init|=
name|PlanetModel
operator|.
name|WGS84
operator|.
name|getMaximumMagnitude
argument_list|()
decl_stmt|;
for|for
control|(
name|double
name|value
range|:
operator|new
name|double
index|[]
block|{
literal|0.0
block|,
operator|-
name|planetMax
block|,
name|planetMax
block|}
control|)
block|{
name|assertEquals
argument_list|(
name|value
argument_list|,
name|Geo3DUtil
operator|.
name|decodeValue
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|ENCODING_TOLERANCE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** make sure values always go down: this is important for edge case consistency */
DECL|method|testEncodeDecodeRoundsDown
specifier|public
name|void
name|testEncodeDecodeRoundsDown
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|iters
init|=
name|atLeast
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|iters
condition|;
name|iter
operator|++
control|)
block|{
specifier|final
name|double
name|latBase
init|=
name|GeoTestUtil
operator|.
name|nextLatitude
argument_list|()
decl_stmt|;
specifier|final
name|double
name|lonBase
init|=
name|GeoTestUtil
operator|.
name|nextLongitude
argument_list|()
decl_stmt|;
comment|// test above the value
name|double
name|lat
init|=
name|latBase
decl_stmt|;
name|double
name|lon
init|=
name|lonBase
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|lat
operator|=
name|Math
operator|.
name|min
argument_list|(
literal|90
argument_list|,
name|Math
operator|.
name|nextUp
argument_list|(
name|lat
argument_list|)
argument_list|)
expr_stmt|;
name|lon
operator|=
name|Math
operator|.
name|min
argument_list|(
literal|180
argument_list|,
name|Math
operator|.
name|nextUp
argument_list|(
name|lon
argument_list|)
argument_list|)
expr_stmt|;
name|GeoPoint
name|point
init|=
operator|new
name|GeoPoint
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|toRadians
argument_list|(
name|lat
argument_list|)
argument_list|,
name|toRadians
argument_list|(
name|lon
argument_list|)
argument_list|)
decl_stmt|;
name|GeoPoint
name|pointEnc
init|=
operator|new
name|GeoPoint
argument_list|(
name|Geo3DUtil
operator|.
name|decodeValueFloor
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|point
operator|.
name|x
argument_list|)
argument_list|)
argument_list|,
name|Geo3DUtil
operator|.
name|decodeValueFloor
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|point
operator|.
name|y
argument_list|)
argument_list|)
argument_list|,
name|Geo3DUtil
operator|.
name|decodeValueFloor
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|point
operator|.
name|z
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|pointEnc
operator|.
name|x
operator|<=
name|point
operator|.
name|x
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|pointEnc
operator|.
name|y
operator|<=
name|point
operator|.
name|y
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|pointEnc
operator|.
name|z
operator|<=
name|point
operator|.
name|z
argument_list|)
expr_stmt|;
block|}
comment|// test below the value
name|lat
operator|=
name|latBase
expr_stmt|;
name|lon
operator|=
name|lonBase
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|lat
operator|=
name|Math
operator|.
name|max
argument_list|(
operator|-
literal|90
argument_list|,
name|Math
operator|.
name|nextDown
argument_list|(
name|lat
argument_list|)
argument_list|)
expr_stmt|;
name|lon
operator|=
name|Math
operator|.
name|max
argument_list|(
operator|-
literal|180
argument_list|,
name|Math
operator|.
name|nextDown
argument_list|(
name|lon
argument_list|)
argument_list|)
expr_stmt|;
name|GeoPoint
name|point
init|=
operator|new
name|GeoPoint
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|toRadians
argument_list|(
name|lat
argument_list|)
argument_list|,
name|toRadians
argument_list|(
name|lon
argument_list|)
argument_list|)
decl_stmt|;
name|GeoPoint
name|pointEnc
init|=
operator|new
name|GeoPoint
argument_list|(
name|Geo3DUtil
operator|.
name|decodeValueFloor
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|point
operator|.
name|x
argument_list|)
argument_list|)
argument_list|,
name|Geo3DUtil
operator|.
name|decodeValueFloor
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|point
operator|.
name|y
argument_list|)
argument_list|)
argument_list|,
name|Geo3DUtil
operator|.
name|decodeValueFloor
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|point
operator|.
name|z
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|pointEnc
operator|.
name|x
operator|<=
name|point
operator|.
name|x
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|pointEnc
operator|.
name|y
operator|<=
name|point
operator|.
name|y
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|pointEnc
operator|.
name|z
operator|<=
name|point
operator|.
name|z
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|testEncodeDecodeIsStable
specifier|public
name|void
name|testEncodeDecodeIsStable
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|iters
init|=
name|atLeast
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|iters
condition|;
name|iter
operator|++
control|)
block|{
name|double
name|lat
init|=
name|GeoTestUtil
operator|.
name|nextLatitude
argument_list|()
decl_stmt|;
name|double
name|lon
init|=
name|GeoTestUtil
operator|.
name|nextLongitude
argument_list|()
decl_stmt|;
name|GeoPoint
name|point
init|=
operator|new
name|GeoPoint
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|toRadians
argument_list|(
name|lat
argument_list|)
argument_list|,
name|toRadians
argument_list|(
name|lon
argument_list|)
argument_list|)
decl_stmt|;
comment|// encode point
name|GeoPoint
name|pointEnc
init|=
operator|new
name|GeoPoint
argument_list|(
name|Geo3DUtil
operator|.
name|decodeValue
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|point
operator|.
name|x
argument_list|)
argument_list|)
argument_list|,
name|Geo3DUtil
operator|.
name|decodeValue
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|point
operator|.
name|y
argument_list|)
argument_list|)
argument_list|,
name|Geo3DUtil
operator|.
name|decodeValue
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|point
operator|.
name|z
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// encode it again (double encode)
name|GeoPoint
name|pointEnc2
init|=
operator|new
name|GeoPoint
argument_list|(
name|Geo3DUtil
operator|.
name|decodeValue
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|pointEnc
operator|.
name|x
argument_list|)
argument_list|)
argument_list|,
name|Geo3DUtil
operator|.
name|decodeValue
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|pointEnc
operator|.
name|y
argument_list|)
argument_list|)
argument_list|,
name|Geo3DUtil
operator|.
name|decodeValue
argument_list|(
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|pointEnc
operator|.
name|z
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|//System.out.println("TEST " + iter + ":\n  point    =" + point + "\n  pointEnc =" + pointEnc + "\n  pointEnc2=" + pointEnc2);
name|assertEquals
argument_list|(
name|pointEnc
operator|.
name|x
argument_list|,
name|pointEnc2
operator|.
name|x
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|pointEnc
operator|.
name|y
argument_list|,
name|pointEnc2
operator|.
name|y
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|pointEnc
operator|.
name|z
argument_list|,
name|pointEnc2
operator|.
name|z
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Clips the incoming value to the allowed min/max range before encoding, instead of throwing an exception. */
DECL|method|encodeValueLenient
specifier|private
specifier|static
name|int
name|encodeValueLenient
parameter_list|(
name|double
name|x
parameter_list|)
block|{
name|double
name|planetMax
init|=
name|PlanetModel
operator|.
name|WGS84
operator|.
name|getMaximumMagnitude
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|>
name|planetMax
condition|)
block|{
name|x
operator|=
name|planetMax
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<
operator|-
name|planetMax
condition|)
block|{
name|x
operator|=
operator|-
name|planetMax
expr_stmt|;
block|}
return|return
name|Geo3DUtil
operator|.
name|encodeValue
argument_list|(
name|x
argument_list|)
return|;
block|}
DECL|class|ExplainingVisitor
specifier|private
specifier|static
class|class
name|ExplainingVisitor
implements|implements
name|IntersectVisitor
block|{
DECL|field|shape
specifier|final
name|GeoShape
name|shape
decl_stmt|;
DECL|field|targetDocPoint
specifier|final
name|GeoPoint
name|targetDocPoint
decl_stmt|;
DECL|field|scaledDocPoint
specifier|final
name|GeoPoint
name|scaledDocPoint
decl_stmt|;
DECL|field|in
specifier|final
name|IntersectVisitor
name|in
decl_stmt|;
DECL|field|stack
specifier|final
name|List
argument_list|<
name|Cell
argument_list|>
name|stack
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|stackToTargetDoc
specifier|private
name|List
argument_list|<
name|Cell
argument_list|>
name|stackToTargetDoc
decl_stmt|;
DECL|field|targetDocID
specifier|final
name|int
name|targetDocID
decl_stmt|;
DECL|field|numDims
specifier|final
name|int
name|numDims
decl_stmt|;
DECL|field|bytesPerDim
specifier|final
name|int
name|bytesPerDim
decl_stmt|;
DECL|field|targetStackUpto
specifier|private
name|int
name|targetStackUpto
decl_stmt|;
DECL|field|b
specifier|final
name|StringBuilder
name|b
decl_stmt|;
comment|// In the first phase, we always return CROSSES to do a full scan of the BKD tree to see which leaf block the document lives in
DECL|field|firstPhase
name|boolean
name|firstPhase
init|=
literal|true
decl_stmt|;
DECL|method|ExplainingVisitor
specifier|public
name|ExplainingVisitor
parameter_list|(
name|GeoShape
name|shape
parameter_list|,
name|GeoPoint
name|targetDocPoint
parameter_list|,
name|GeoPoint
name|scaledDocPoint
parameter_list|,
name|IntersectVisitor
name|in
parameter_list|,
name|int
name|targetDocID
parameter_list|,
name|int
name|numDims
parameter_list|,
name|int
name|bytesPerDim
parameter_list|,
name|StringBuilder
name|b
parameter_list|)
block|{
name|this
operator|.
name|shape
operator|=
name|shape
expr_stmt|;
name|this
operator|.
name|targetDocPoint
operator|=
name|targetDocPoint
expr_stmt|;
name|this
operator|.
name|scaledDocPoint
operator|=
name|scaledDocPoint
expr_stmt|;
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|targetDocID
operator|=
name|targetDocID
expr_stmt|;
name|this
operator|.
name|numDims
operator|=
name|numDims
expr_stmt|;
name|this
operator|.
name|bytesPerDim
operator|=
name|bytesPerDim
expr_stmt|;
name|this
operator|.
name|b
operator|=
name|b
expr_stmt|;
block|}
DECL|method|startSecondPhase
specifier|public
name|void
name|startSecondPhase
parameter_list|()
block|{
if|if
condition|(
name|firstPhase
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"already started second phase"
argument_list|)
throw|;
block|}
if|if
condition|(
name|stackToTargetDoc
operator|==
literal|null
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"target docID="
operator|+
name|targetDocID
operator|+
literal|" was never seen in points!\n"
argument_list|)
expr_stmt|;
block|}
name|firstPhase
operator|=
literal|false
expr_stmt|;
name|stack
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|visit
specifier|public
name|void
name|visit
parameter_list|(
name|int
name|docID
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|firstPhase
operator|==
literal|false
assert|;
if|if
condition|(
name|docID
operator|==
name|targetDocID
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"leaf visit docID="
operator|+
name|docID
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|visit
specifier|public
name|void
name|visit
parameter_list|(
name|int
name|docID
parameter_list|,
name|byte
index|[]
name|packedValue
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|firstPhase
condition|)
block|{
if|if
condition|(
name|docID
operator|==
name|targetDocID
condition|)
block|{
assert|assert
name|stackToTargetDoc
operator|==
literal|null
assert|;
name|stackToTargetDoc
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"  full BKD path to target doc:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|Cell
name|cell
range|:
name|stack
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"    "
operator|+
name|cell
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|docID
operator|==
name|targetDocID
condition|)
block|{
name|double
name|x
init|=
name|Geo3DPoint
operator|.
name|decodeDimension
argument_list|(
name|packedValue
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|double
name|y
init|=
name|Geo3DPoint
operator|.
name|decodeDimension
argument_list|(
name|packedValue
argument_list|,
name|Integer
operator|.
name|BYTES
argument_list|)
decl_stmt|;
name|double
name|z
init|=
name|Geo3DPoint
operator|.
name|decodeDimension
argument_list|(
name|packedValue
argument_list|,
literal|2
operator|*
name|Integer
operator|.
name|BYTES
argument_list|)
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"leaf visit docID="
operator|+
name|docID
operator|+
literal|" x="
operator|+
name|x
operator|+
literal|" y="
operator|+
name|y
operator|+
literal|" z="
operator|+
name|z
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|in
operator|.
name|visit
argument_list|(
name|docID
argument_list|,
name|packedValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|compare
specifier|public
name|Relation
name|compare
parameter_list|(
name|byte
index|[]
name|minPackedValue
parameter_list|,
name|byte
index|[]
name|maxPackedValue
parameter_list|)
block|{
name|Cell
name|cell
init|=
operator|new
name|Cell
argument_list|(
name|minPackedValue
argument_list|,
name|maxPackedValue
argument_list|)
decl_stmt|;
comment|//System.out.println("compare: " + cell);
comment|// TODO: this is a bit hacky, having to reverse-engineer where we are in the BKD tree's recursion ... but it's the lesser evil vs e.g.
comment|// polluting this visitor API, or implementing this "under the hood" in BKDReader instead?
if|if
condition|(
name|firstPhase
condition|)
block|{
comment|// Pop stack:
while|while
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|stack
operator|.
name|get
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|contains
argument_list|(
name|cell
argument_list|)
operator|==
literal|false
condition|)
block|{
name|stack
operator|.
name|remove
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//System.out.println("  pop");
block|}
comment|// Push stack:
name|stack
operator|.
name|add
argument_list|(
name|cell
argument_list|)
expr_stmt|;
comment|//System.out.println("  push");
return|return
name|Relation
operator|.
name|CELL_CROSSES_QUERY
return|;
block|}
else|else
block|{
name|Relation
name|result
init|=
name|in
operator|.
name|compare
argument_list|(
name|minPackedValue
argument_list|,
name|maxPackedValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetStackUpto
operator|<
name|stackToTargetDoc
operator|.
name|size
argument_list|()
operator|&&
name|cell
operator|.
name|equals
argument_list|(
name|stackToTargetDoc
operator|.
name|get
argument_list|(
name|targetStackUpto
argument_list|)
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"  on cell "
operator|+
name|stackToTargetDoc
operator|.
name|get
argument_list|(
name|targetStackUpto
argument_list|)
operator|+
literal|", wrapped visitor returned "
operator|+
name|result
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|targetStackUpto
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
DECL|class|Cell
specifier|private
class|class
name|Cell
block|{
DECL|field|minPackedValue
specifier|private
specifier|final
name|byte
index|[]
name|minPackedValue
decl_stmt|;
DECL|field|maxPackedValue
specifier|private
specifier|final
name|byte
index|[]
name|maxPackedValue
decl_stmt|;
DECL|method|Cell
specifier|public
name|Cell
parameter_list|(
name|byte
index|[]
name|minPackedValue
parameter_list|,
name|byte
index|[]
name|maxPackedValue
parameter_list|)
block|{
name|this
operator|.
name|minPackedValue
operator|=
name|minPackedValue
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxPackedValue
operator|=
name|maxPackedValue
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
comment|/** Returns true if this cell fully contains the other one */
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|Cell
name|other
parameter_list|)
block|{
for|for
control|(
name|int
name|dim
init|=
literal|0
init|;
name|dim
operator|<
name|numDims
condition|;
name|dim
operator|++
control|)
block|{
name|int
name|offset
init|=
name|bytesPerDim
operator|*
name|dim
decl_stmt|;
comment|// other.min< this.min?
if|if
condition|(
name|StringHelper
operator|.
name|compare
argument_list|(
name|bytesPerDim
argument_list|,
name|other
operator|.
name|minPackedValue
argument_list|,
name|offset
argument_list|,
name|minPackedValue
argument_list|,
name|offset
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// other.max< this.max?
if|if
condition|(
name|StringHelper
operator|.
name|compare
argument_list|(
name|bytesPerDim
argument_list|,
name|other
operator|.
name|maxPackedValue
argument_list|,
name|offset
argument_list|,
name|maxPackedValue
argument_list|,
name|offset
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|double
name|xMin
init|=
name|Geo3DUtil
operator|.
name|decodeValueFloor
argument_list|(
name|NumericUtils
operator|.
name|sortableBytesToInt
argument_list|(
name|minPackedValue
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|xMax
init|=
name|Geo3DUtil
operator|.
name|decodeValueCeil
argument_list|(
name|NumericUtils
operator|.
name|sortableBytesToInt
argument_list|(
name|maxPackedValue
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|yMin
init|=
name|Geo3DUtil
operator|.
name|decodeValueFloor
argument_list|(
name|NumericUtils
operator|.
name|sortableBytesToInt
argument_list|(
name|minPackedValue
argument_list|,
literal|1
operator|*
name|Integer
operator|.
name|BYTES
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|yMax
init|=
name|Geo3DUtil
operator|.
name|decodeValueCeil
argument_list|(
name|NumericUtils
operator|.
name|sortableBytesToInt
argument_list|(
name|maxPackedValue
argument_list|,
literal|1
operator|*
name|Integer
operator|.
name|BYTES
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|zMin
init|=
name|Geo3DUtil
operator|.
name|decodeValueFloor
argument_list|(
name|NumericUtils
operator|.
name|sortableBytesToInt
argument_list|(
name|minPackedValue
argument_list|,
literal|2
operator|*
name|Integer
operator|.
name|BYTES
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|zMax
init|=
name|Geo3DUtil
operator|.
name|decodeValueCeil
argument_list|(
name|NumericUtils
operator|.
name|sortableBytesToInt
argument_list|(
name|maxPackedValue
argument_list|,
literal|2
operator|*
name|Integer
operator|.
name|BYTES
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|XYZSolid
name|xyzSolid
init|=
name|XYZSolidFactory
operator|.
name|makeXYZSolid
argument_list|(
name|PlanetModel
operator|.
name|WGS84
argument_list|,
name|xMin
argument_list|,
name|xMax
argument_list|,
name|yMin
argument_list|,
name|yMax
argument_list|,
name|zMin
argument_list|,
name|zMax
argument_list|)
decl_stmt|;
specifier|final
name|int
name|relationship
init|=
name|xyzSolid
operator|.
name|getRelationship
argument_list|(
name|shape
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|pointWithinCell
init|=
name|xyzSolid
operator|.
name|isWithin
argument_list|(
name|targetDocPoint
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|scaledWithinCell
init|=
name|xyzSolid
operator|.
name|isWithin
argument_list|(
name|scaledDocPoint
argument_list|)
decl_stmt|;
specifier|final
name|String
name|relationshipString
decl_stmt|;
switch|switch
condition|(
name|relationship
condition|)
block|{
case|case
name|GeoArea
operator|.
name|CONTAINS
case|:
name|relationshipString
operator|=
literal|"CONTAINS"
expr_stmt|;
break|break;
case|case
name|GeoArea
operator|.
name|WITHIN
case|:
name|relationshipString
operator|=
literal|"WITHIN"
expr_stmt|;
break|break;
case|case
name|GeoArea
operator|.
name|OVERLAPS
case|:
name|relationshipString
operator|=
literal|"OVERLAPS"
expr_stmt|;
break|break;
case|case
name|GeoArea
operator|.
name|DISJOINT
case|:
name|relationshipString
operator|=
literal|"DISJOINT"
expr_stmt|;
break|break;
default|default:
name|relationshipString
operator|=
literal|"UNKNOWN"
expr_stmt|;
break|break;
block|}
return|return
literal|"Cell(x="
operator|+
name|xMin
operator|+
literal|" TO "
operator|+
name|xMax
operator|+
literal|" y="
operator|+
name|yMin
operator|+
literal|" TO "
operator|+
name|yMax
operator|+
literal|" z="
operator|+
name|zMin
operator|+
literal|" TO "
operator|+
name|zMax
operator|+
literal|"); Shape relationship = "
operator|+
name|relationshipString
operator|+
literal|"; Quantized point within cell = "
operator|+
name|pointWithinCell
operator|+
literal|"; Unquantized point within cell = "
operator|+
name|scaledWithinCell
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|instanceof
name|Cell
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Cell
name|otherCell
init|=
operator|(
name|Cell
operator|)
name|other
decl_stmt|;
return|return
name|Arrays
operator|.
name|equals
argument_list|(
name|minPackedValue
argument_list|,
name|otherCell
operator|.
name|minPackedValue
argument_list|)
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|maxPackedValue
argument_list|,
name|otherCell
operator|.
name|maxPackedValue
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|hashCode
argument_list|(
name|minPackedValue
argument_list|)
operator|+
name|Arrays
operator|.
name|hashCode
argument_list|(
name|maxPackedValue
argument_list|)
return|;
block|}
block|}
block|}
DECL|method|explain
specifier|public
specifier|static
name|String
name|explain
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|GeoShape
name|shape
parameter_list|,
name|GeoPoint
name|targetDocPoint
parameter_list|,
name|GeoPoint
name|scaledDocPoint
parameter_list|,
name|IndexReader
name|reader
parameter_list|,
name|int
name|docID
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|XYZBounds
name|bounds
init|=
operator|new
name|XYZBounds
argument_list|()
decl_stmt|;
name|shape
operator|.
name|getBounds
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
comment|// First find the leaf reader that owns this doc:
name|int
name|subIndex
init|=
name|ReaderUtil
operator|.
name|subIndex
argument_list|(
name|docID
argument_list|,
name|reader
operator|.
name|leaves
argument_list|()
argument_list|)
decl_stmt|;
name|LeafReader
name|leafReader
init|=
name|reader
operator|.
name|leaves
argument_list|()
operator|.
name|get
argument_list|(
name|subIndex
argument_list|)
operator|.
name|reader
argument_list|()
decl_stmt|;
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"target is in leaf "
operator|+
name|leafReader
operator|+
literal|" of full reader "
operator|+
name|reader
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|DocIdSetBuilder
name|hits
init|=
operator|new
name|DocIdSetBuilder
argument_list|(
name|leafReader
operator|.
name|maxDoc
argument_list|()
argument_list|)
decl_stmt|;
name|ExplainingVisitor
name|visitor
init|=
operator|new
name|ExplainingVisitor
argument_list|(
name|shape
argument_list|,
name|targetDocPoint
argument_list|,
name|scaledDocPoint
argument_list|,
operator|new
name|PointInShapeIntersectVisitor
argument_list|(
name|hits
argument_list|,
name|shape
argument_list|,
name|bounds
argument_list|)
argument_list|,
name|docID
operator|-
name|reader
operator|.
name|leaves
argument_list|()
operator|.
name|get
argument_list|(
name|subIndex
argument_list|)
operator|.
name|docBase
argument_list|,
literal|3
argument_list|,
name|Integer
operator|.
name|BYTES
argument_list|,
name|b
argument_list|)
decl_stmt|;
comment|// Do first phase, where we just figure out the "path" that leads to the target docID:
name|leafReader
operator|.
name|getPointValues
argument_list|()
operator|.
name|intersect
argument_list|(
name|fieldName
argument_list|,
name|visitor
argument_list|)
expr_stmt|;
comment|// Do second phase, where we we see how the wrapped visitor responded along that path:
name|visitor
operator|.
name|startSecondPhase
argument_list|()
expr_stmt|;
name|leafReader
operator|.
name|getPointValues
argument_list|()
operator|.
name|intersect
argument_list|(
name|fieldName
argument_list|,
name|visitor
argument_list|)
expr_stmt|;
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class
end_unit
