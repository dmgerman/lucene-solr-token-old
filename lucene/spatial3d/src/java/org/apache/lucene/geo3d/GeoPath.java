begin_unit
begin_package
DECL|package|org.apache.lucene.geo3d
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|geo3d
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_comment
comment|/**  * GeoShape representing a path across the surface of the globe,  * with a specified half-width.  Path is described by a series of points.  * Distances are measured from the starting point along the path, and then at right  * angles to the path.  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|GeoPath
specifier|public
class|class
name|GeoPath
extends|extends
name|GeoBaseDistanceShape
block|{
comment|/** The cutoff angle (width) */
DECL|field|cutoffAngle
specifier|protected
specifier|final
name|double
name|cutoffAngle
decl_stmt|;
comment|/** Sine of cutoff angle */
DECL|field|sinAngle
specifier|protected
specifier|final
name|double
name|sinAngle
decl_stmt|;
comment|/** Cosine of cutoff angle */
DECL|field|cosAngle
specifier|protected
specifier|final
name|double
name|cosAngle
decl_stmt|;
comment|/** The original list of path points */
DECL|field|points
specifier|protected
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|points
init|=
operator|new
name|ArrayList
argument_list|<
name|GeoPoint
argument_list|>
argument_list|()
decl_stmt|;
comment|/** A list of SegmentEndpoints */
DECL|field|endPoints
specifier|protected
name|List
argument_list|<
name|SegmentEndpoint
argument_list|>
name|endPoints
decl_stmt|;
comment|/** A list of PathSegments */
DECL|field|segments
specifier|protected
name|List
argument_list|<
name|PathSegment
argument_list|>
name|segments
decl_stmt|;
comment|/** A point on the edge */
DECL|field|edgePoints
specifier|protected
name|GeoPoint
index|[]
name|edgePoints
decl_stmt|;
comment|/** Set to true if path has been completely constructed */
DECL|field|isDone
specifier|protected
name|boolean
name|isDone
init|=
literal|false
decl_stmt|;
comment|/** Constructor.    *@param planetModel is the planet model.    *@param maxCutoffAngle is the width of the path, measured as an angle.    *@param pathPoints are the points in the path.    */
DECL|method|GeoPath
specifier|public
name|GeoPath
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|double
name|maxCutoffAngle
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|pathPoints
parameter_list|)
block|{
name|this
argument_list|(
name|planetModel
argument_list|,
name|maxCutoffAngle
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|points
argument_list|,
name|pathPoints
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
comment|/** Piece-wise constructor.  Use in conjunction with addPoint() and done().    *@param planetModel is the planet model.    *@param maxCutoffAngle is the width of the path, measured as an angle.    */
DECL|method|GeoPath
specifier|public
name|GeoPath
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|double
name|maxCutoffAngle
parameter_list|)
block|{
name|super
argument_list|(
name|planetModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxCutoffAngle
operator|<=
literal|0.0
operator|||
name|maxCutoffAngle
operator|>
name|Math
operator|.
name|PI
operator|*
literal|0.5
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cutoff angle out of bounds"
argument_list|)
throw|;
name|this
operator|.
name|cutoffAngle
operator|=
name|maxCutoffAngle
expr_stmt|;
name|this
operator|.
name|cosAngle
operator|=
name|Math
operator|.
name|cos
argument_list|(
name|maxCutoffAngle
argument_list|)
expr_stmt|;
name|this
operator|.
name|sinAngle
operator|=
name|Math
operator|.
name|sin
argument_list|(
name|maxCutoffAngle
argument_list|)
expr_stmt|;
block|}
comment|/** Add a point to the path.    *@param lat is the latitude of the point.    *@param lon is the longitude of the point.    */
DECL|method|addPoint
specifier|public
name|void
name|addPoint
parameter_list|(
specifier|final
name|double
name|lat
parameter_list|,
specifier|final
name|double
name|lon
parameter_list|)
block|{
if|if
condition|(
name|isDone
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Can't call addPoint() if done() already called"
argument_list|)
throw|;
name|points
operator|.
name|add
argument_list|(
operator|new
name|GeoPoint
argument_list|(
name|planetModel
argument_list|,
name|lat
argument_list|,
name|lon
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Complete the path.    */
DECL|method|done
specifier|public
name|void
name|done
parameter_list|()
block|{
if|if
condition|(
name|isDone
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Can't call done() twice"
argument_list|)
throw|;
if|if
condition|(
name|points
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Path must have at least one point"
argument_list|)
throw|;
name|isDone
operator|=
literal|true
expr_stmt|;
name|endPoints
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|points
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|segments
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|points
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Compute an offset to use for all segments.  This will be based on the minimum magnitude of
comment|// the entire ellipsoid.
specifier|final
name|double
name|cutoffOffset
init|=
name|this
operator|.
name|sinAngle
operator|*
name|planetModel
operator|.
name|getMinimumMagnitude
argument_list|()
decl_stmt|;
comment|// First, build all segments.  We'll then go back and build corresponding segment endpoints.
name|GeoPoint
name|lastPoint
init|=
literal|null
decl_stmt|;
for|for
control|(
specifier|final
name|GeoPoint
name|end
range|:
name|points
control|)
block|{
if|if
condition|(
name|lastPoint
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Plane
name|normalizedConnectingPlane
init|=
operator|new
name|Plane
argument_list|(
name|lastPoint
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|normalizedConnectingPlane
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|segments
operator|.
name|add
argument_list|(
operator|new
name|PathSegment
argument_list|(
name|planetModel
argument_list|,
name|lastPoint
argument_list|,
name|end
argument_list|,
name|normalizedConnectingPlane
argument_list|,
name|cutoffOffset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lastPoint
operator|=
name|end
expr_stmt|;
block|}
if|if
condition|(
name|segments
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Simple circle
name|double
name|lat
init|=
name|points
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getLatitude
argument_list|()
decl_stmt|;
name|double
name|lon
init|=
name|points
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getLongitude
argument_list|()
decl_stmt|;
comment|// Compute two points on the circle, with the right angle from the center.  We'll use these
comment|// to obtain the perpendicular plane to the circle.
name|double
name|upperLat
init|=
name|lat
operator|+
name|cutoffAngle
decl_stmt|;
name|double
name|upperLon
init|=
name|lon
decl_stmt|;
if|if
condition|(
name|upperLat
operator|>
name|Math
operator|.
name|PI
operator|*
literal|0.5
condition|)
block|{
name|upperLon
operator|+=
name|Math
operator|.
name|PI
expr_stmt|;
if|if
condition|(
name|upperLon
operator|>
name|Math
operator|.
name|PI
condition|)
name|upperLon
operator|-=
literal|2.0
operator|*
name|Math
operator|.
name|PI
expr_stmt|;
name|upperLat
operator|=
name|Math
operator|.
name|PI
operator|-
name|upperLat
expr_stmt|;
block|}
name|double
name|lowerLat
init|=
name|lat
operator|-
name|cutoffAngle
decl_stmt|;
name|double
name|lowerLon
init|=
name|lon
decl_stmt|;
if|if
condition|(
name|lowerLat
operator|<
operator|-
name|Math
operator|.
name|PI
operator|*
literal|0.5
condition|)
block|{
name|lowerLon
operator|+=
name|Math
operator|.
name|PI
expr_stmt|;
if|if
condition|(
name|lowerLon
operator|>
name|Math
operator|.
name|PI
condition|)
name|lowerLon
operator|-=
literal|2.0
operator|*
name|Math
operator|.
name|PI
expr_stmt|;
name|lowerLat
operator|=
operator|-
name|Math
operator|.
name|PI
operator|-
name|lowerLat
expr_stmt|;
block|}
specifier|final
name|GeoPoint
name|upperPoint
init|=
operator|new
name|GeoPoint
argument_list|(
name|planetModel
argument_list|,
name|upperLat
argument_list|,
name|upperLon
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
name|lowerPoint
init|=
operator|new
name|GeoPoint
argument_list|(
name|planetModel
argument_list|,
name|lowerLat
argument_list|,
name|lowerLon
argument_list|)
decl_stmt|;
specifier|final
name|SegmentEndpoint
name|onlyEndpoint
init|=
operator|new
name|SegmentEndpoint
argument_list|(
name|points
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|upperPoint
argument_list|,
name|lowerPoint
argument_list|)
decl_stmt|;
name|endPoints
operator|.
name|add
argument_list|(
name|onlyEndpoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|edgePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|upperPoint
block|}
expr_stmt|;
return|return;
block|}
comment|// Create segment endpoints.  Use an appropriate constructor for the start and end of the path.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|PathSegment
name|currentSegment
init|=
name|segments
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|// Starting endpoint
specifier|final
name|SegmentEndpoint
name|startEndpoint
init|=
operator|new
name|SegmentEndpoint
argument_list|(
name|currentSegment
operator|.
name|start
argument_list|,
name|currentSegment
operator|.
name|startCutoffPlane
argument_list|,
name|currentSegment
operator|.
name|ULHC
argument_list|,
name|currentSegment
operator|.
name|LLHC
argument_list|)
decl_stmt|;
name|endPoints
operator|.
name|add
argument_list|(
name|startEndpoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|edgePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|currentSegment
operator|.
name|ULHC
block|}
expr_stmt|;
continue|continue;
block|}
comment|// General intersection case
specifier|final
name|PathSegment
name|prevSegment
init|=
name|segments
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// We construct four separate planes, and evaluate which one includes all interior points with least overlap
specifier|final
name|SidedPlane
name|candidate1
init|=
name|SidedPlane
operator|.
name|constructNormalizedThreePointSidedPlane
argument_list|(
name|currentSegment
operator|.
name|start
argument_list|,
name|prevSegment
operator|.
name|URHC
argument_list|,
name|currentSegment
operator|.
name|ULHC
argument_list|,
name|currentSegment
operator|.
name|LLHC
argument_list|)
decl_stmt|;
specifier|final
name|SidedPlane
name|candidate2
init|=
name|SidedPlane
operator|.
name|constructNormalizedThreePointSidedPlane
argument_list|(
name|currentSegment
operator|.
name|start
argument_list|,
name|currentSegment
operator|.
name|ULHC
argument_list|,
name|currentSegment
operator|.
name|LLHC
argument_list|,
name|prevSegment
operator|.
name|LRHC
argument_list|)
decl_stmt|;
specifier|final
name|SidedPlane
name|candidate3
init|=
name|SidedPlane
operator|.
name|constructNormalizedThreePointSidedPlane
argument_list|(
name|currentSegment
operator|.
name|start
argument_list|,
name|currentSegment
operator|.
name|LLHC
argument_list|,
name|prevSegment
operator|.
name|LRHC
argument_list|,
name|prevSegment
operator|.
name|URHC
argument_list|)
decl_stmt|;
specifier|final
name|SidedPlane
name|candidate4
init|=
name|SidedPlane
operator|.
name|constructNormalizedThreePointSidedPlane
argument_list|(
name|currentSegment
operator|.
name|start
argument_list|,
name|prevSegment
operator|.
name|LRHC
argument_list|,
name|prevSegment
operator|.
name|URHC
argument_list|,
name|currentSegment
operator|.
name|ULHC
argument_list|)
decl_stmt|;
if|if
condition|(
name|candidate1
operator|==
literal|null
operator|&&
name|candidate2
operator|==
literal|null
operator|&&
name|candidate3
operator|==
literal|null
operator|&&
name|candidate4
operator|==
literal|null
condition|)
block|{
comment|// The planes are identical.  We wouldn't need a circle at all except for the possibility of
comment|// backing up, which is hard to detect here.
specifier|final
name|SegmentEndpoint
name|midEndpoint
init|=
operator|new
name|SegmentEndpoint
argument_list|(
name|currentSegment
operator|.
name|start
argument_list|,
name|prevSegment
operator|.
name|endCutoffPlane
argument_list|,
name|currentSegment
operator|.
name|startCutoffPlane
argument_list|,
name|currentSegment
operator|.
name|ULHC
argument_list|,
name|currentSegment
operator|.
name|LLHC
argument_list|)
decl_stmt|;
comment|//don't need a circle at all.  Special constructor...
name|endPoints
operator|.
name|add
argument_list|(
name|midEndpoint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|endPoints
operator|.
name|add
argument_list|(
operator|new
name|SegmentEndpoint
argument_list|(
name|currentSegment
operator|.
name|start
argument_list|,
name|prevSegment
operator|.
name|endCutoffPlane
argument_list|,
name|currentSegment
operator|.
name|startCutoffPlane
argument_list|,
name|prevSegment
operator|.
name|URHC
argument_list|,
name|prevSegment
operator|.
name|LRHC
argument_list|,
name|currentSegment
operator|.
name|ULHC
argument_list|,
name|currentSegment
operator|.
name|LLHC
argument_list|,
name|candidate1
argument_list|,
name|candidate2
argument_list|,
name|candidate3
argument_list|,
name|candidate4
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Do final endpoint
specifier|final
name|PathSegment
name|lastSegment
init|=
name|segments
operator|.
name|get
argument_list|(
name|segments
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|endPoints
operator|.
name|add
argument_list|(
operator|new
name|SegmentEndpoint
argument_list|(
name|lastSegment
operator|.
name|end
argument_list|,
name|lastSegment
operator|.
name|endCutoffPlane
argument_list|,
name|lastSegment
operator|.
name|URHC
argument_list|,
name|lastSegment
operator|.
name|LRHC
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|distance
specifier|protected
name|double
name|distance
parameter_list|(
specifier|final
name|DistanceStyle
name|distanceStyle
parameter_list|,
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
comment|// Algorithm:
comment|// (1) If the point is within any of the segments along the path, return that value.
comment|// (2) If the point is within any of the segment end circles along the path, return that value.
name|double
name|currentDistance
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|PathSegment
name|segment
range|:
name|segments
control|)
block|{
name|double
name|distance
init|=
name|segment
operator|.
name|pathDistance
argument_list|(
name|planetModel
argument_list|,
name|distanceStyle
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|!=
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|currentDistance
operator|+
name|distance
return|;
name|currentDistance
operator|+=
name|segment
operator|.
name|fullPathDistance
argument_list|(
name|distanceStyle
argument_list|)
expr_stmt|;
block|}
name|int
name|segmentIndex
init|=
literal|0
decl_stmt|;
name|currentDistance
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|SegmentEndpoint
name|endpoint
range|:
name|endPoints
control|)
block|{
name|double
name|distance
init|=
name|endpoint
operator|.
name|pathDistance
argument_list|(
name|distanceStyle
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|!=
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|currentDistance
operator|+
name|distance
return|;
if|if
condition|(
name|segmentIndex
operator|<
name|segments
operator|.
name|size
argument_list|()
condition|)
name|currentDistance
operator|+=
name|segments
operator|.
name|get
argument_list|(
name|segmentIndex
operator|++
argument_list|)
operator|.
name|fullPathDistance
argument_list|(
name|distanceStyle
argument_list|)
expr_stmt|;
block|}
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
block|}
annotation|@
name|Override
DECL|method|outsideDistance
specifier|protected
name|double
name|outsideDistance
parameter_list|(
specifier|final
name|DistanceStyle
name|distanceStyle
parameter_list|,
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
name|double
name|minDistance
init|=
name|Double
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
specifier|final
name|SegmentEndpoint
name|endpoint
range|:
name|endPoints
control|)
block|{
specifier|final
name|double
name|newDistance
init|=
name|endpoint
operator|.
name|outsideDistance
argument_list|(
name|distanceStyle
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDistance
operator|<
name|minDistance
condition|)
name|minDistance
operator|=
name|newDistance
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|PathSegment
name|segment
range|:
name|segments
control|)
block|{
specifier|final
name|double
name|newDistance
init|=
name|segment
operator|.
name|outsideDistance
argument_list|(
name|planetModel
argument_list|,
name|distanceStyle
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDistance
operator|<
name|minDistance
condition|)
name|minDistance
operator|=
name|newDistance
expr_stmt|;
block|}
return|return
name|minDistance
return|;
block|}
annotation|@
name|Override
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
for|for
control|(
name|SegmentEndpoint
name|pathPoint
range|:
name|endPoints
control|)
block|{
if|if
condition|(
name|pathPoint
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
for|for
control|(
name|PathSegment
name|pathSegment
range|:
name|segments
control|)
block|{
if|if
condition|(
name|pathSegment
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|getEdgePoints
specifier|public
name|GeoPoint
index|[]
name|getEdgePoints
parameter_list|()
block|{
return|return
name|edgePoints
return|;
block|}
annotation|@
name|Override
DECL|method|intersects
specifier|public
name|boolean
name|intersects
parameter_list|(
specifier|final
name|Plane
name|plane
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|notablePoints
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
comment|// We look for an intersection with any of the exterior edges of the path.
comment|// We also have to look for intersections with the cones described by the endpoints.
comment|// Return "true" if any such intersections are found.
comment|// For plane intersections, the basic idea is to come up with an equation of the line that is
comment|// the intersection (if any).  Then, find the intersections with the unit sphere (if any).  If
comment|// any of the intersection points are within the bounds, then we've detected an intersection.
comment|// Well, sort of.  We can detect intersections also due to overlap of segments with each other.
comment|// But that's an edge case and we won't be optimizing for it.
comment|//System.err.println(" Looking for intersection of plane "+plane+" with path "+this);
for|for
control|(
specifier|final
name|SegmentEndpoint
name|pathPoint
range|:
name|endPoints
control|)
block|{
if|if
condition|(
name|pathPoint
operator|.
name|intersects
argument_list|(
name|planetModel
argument_list|,
name|plane
argument_list|,
name|notablePoints
argument_list|,
name|bounds
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
for|for
control|(
specifier|final
name|PathSegment
name|pathSegment
range|:
name|segments
control|)
block|{
if|if
condition|(
name|pathSegment
operator|.
name|intersects
argument_list|(
name|planetModel
argument_list|,
name|plane
argument_list|,
name|notablePoints
argument_list|,
name|bounds
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|getBounds
specifier|public
name|Bounds
name|getBounds
parameter_list|(
name|Bounds
name|bounds
parameter_list|)
block|{
name|bounds
operator|=
name|super
operator|.
name|getBounds
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
comment|// For building bounds, order matters.  We want to traverse
comment|// never more than 180 degrees longitude at a pop or we risk having the
comment|// bounds object get itself inverted.  So do the edges first.
for|for
control|(
name|PathSegment
name|pathSegment
range|:
name|segments
control|)
block|{
name|pathSegment
operator|.
name|getBounds
argument_list|(
name|planetModel
argument_list|,
name|bounds
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SegmentEndpoint
name|pathPoint
range|:
name|endPoints
control|)
block|{
name|pathPoint
operator|.
name|getBounds
argument_list|(
name|planetModel
argument_list|,
name|bounds
argument_list|)
expr_stmt|;
block|}
return|return
name|bounds
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|GeoPath
operator|)
condition|)
return|return
literal|false
return|;
name|GeoPath
name|p
init|=
operator|(
name|GeoPath
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|!
name|super
operator|.
name|equals
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|cutoffAngle
operator|!=
name|p
operator|.
name|cutoffAngle
condition|)
return|return
literal|false
return|;
return|return
name|points
operator|.
name|equals
argument_list|(
name|p
operator|.
name|points
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|super
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|long
name|temp
init|=
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|cutoffAngle
argument_list|)
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
call|(
name|int
call|)
argument_list|(
name|temp
operator|^
operator|(
name|temp
operator|>>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|points
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"GeoPath: {planetmodel="
operator|+
name|planetModel
operator|+
literal|", width="
operator|+
name|cutoffAngle
operator|+
literal|"("
operator|+
name|cutoffAngle
operator|*
literal|180.0
operator|/
name|Math
operator|.
name|PI
operator|+
literal|"), points={"
operator|+
name|points
operator|+
literal|"}}"
return|;
block|}
comment|/**    * This is precalculated data for segment endpoint.    * Note well: This is not necessarily a circle.  There are four cases:    * (1) The path consists of a single endpoint.  In this case, we build a simple circle with the proper cutoff offset.    * (2) This is the end of a path.  The circle plane must be constructed to go through two supplied points and be perpendicular to a connecting plane.    * (2.5) Intersection, but the path on both sides is linear.  We generate a circle, but we use the cutoff planes to limit its influence in the straight line case.    * (3) This is an intersection in a path.  We are supplied FOUR planes.  If there are intersections within bounds for both upper and lower, then    *    we generate no circle at all.  If there is one intersection only, then we generate a plane that includes that intersection, as well as the remaining    *    cutoff plane/edge plane points.    */
DECL|class|SegmentEndpoint
specifier|public
specifier|static
class|class
name|SegmentEndpoint
block|{
comment|/** The center point of the endpoint */
DECL|field|point
specifier|public
specifier|final
name|GeoPoint
name|point
decl_stmt|;
comment|/** A plane describing the circle */
DECL|field|circlePlane
specifier|public
specifier|final
name|SidedPlane
name|circlePlane
decl_stmt|;
comment|/** Pertinent cutoff planes from adjoining segments */
DECL|field|cutoffPlanes
specifier|public
specifier|final
name|Membership
index|[]
name|cutoffPlanes
decl_stmt|;
comment|/** Notable points for this segment endpoint */
DECL|field|notablePoints
specifier|public
specifier|final
name|GeoPoint
index|[]
name|notablePoints
decl_stmt|;
comment|/** No notable points from the circle itself */
DECL|field|circlePoints
specifier|public
specifier|final
specifier|static
name|GeoPoint
index|[]
name|circlePoints
init|=
operator|new
name|GeoPoint
index|[
literal|0
index|]
decl_stmt|;
comment|/** Base case.  Does nothing at all.      */
DECL|method|SegmentEndpoint
specifier|public
name|SegmentEndpoint
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
name|this
operator|.
name|point
operator|=
name|point
expr_stmt|;
name|this
operator|.
name|circlePlane
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Constructor for case (1).      * Generate a simple circle cutoff plane.      *@param point is the center point.      *@param upperPoint is a point that must be on the circle plane.      *@param lowerPoint is another point that must be on the circle plane.      */
DECL|method|SegmentEndpoint
specifier|public
name|SegmentEndpoint
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|GeoPoint
name|upperPoint
parameter_list|,
specifier|final
name|GeoPoint
name|lowerPoint
parameter_list|)
block|{
name|this
operator|.
name|point
operator|=
name|point
expr_stmt|;
comment|// Construct normal plane
specifier|final
name|Plane
name|normalPlane
init|=
name|Plane
operator|.
name|constructNormalizedVerticalPlane
argument_list|(
name|upperPoint
argument_list|,
name|lowerPoint
argument_list|,
name|point
argument_list|)
decl_stmt|;
comment|// Construct a sided plane that goes through the two points and whose normal is in the normalPlane.
name|this
operator|.
name|circlePlane
operator|=
name|SidedPlane
operator|.
name|constructNormalizedPerpendicularSidedPlane
argument_list|(
name|point
argument_list|,
name|normalPlane
argument_list|,
name|upperPoint
argument_list|,
name|lowerPoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[
literal|0
index|]
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/** Constructor for case (2).      * Generate an endpoint, given a single cutoff plane plus upper and lower edge points.      *@param point is the center point.      *@param cutoffPlane is the plane from the adjoining path segment marking the boundary between this endpoint and that segment.      *@param topEdgePoint is a point on the cutoffPlane that should be also on the circle plane.      *@param bottomEdgePoint is another point on the cutoffPlane that should be also on the circle plane.      */
DECL|method|SegmentEndpoint
specifier|public
name|SegmentEndpoint
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|SidedPlane
name|cutoffPlane
parameter_list|,
specifier|final
name|GeoPoint
name|topEdgePoint
parameter_list|,
specifier|final
name|GeoPoint
name|bottomEdgePoint
parameter_list|)
block|{
name|this
operator|.
name|point
operator|=
name|point
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
operator|new
name|SidedPlane
argument_list|(
name|cutoffPlane
argument_list|)
block|}
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|topEdgePoint
block|,
name|bottomEdgePoint
block|}
expr_stmt|;
comment|// To construct the plane, we now just need D, which is simply the negative of the evaluation of the circle normal vector at one of the points.
name|this
operator|.
name|circlePlane
operator|=
name|SidedPlane
operator|.
name|constructNormalizedPerpendicularSidedPlane
argument_list|(
name|point
argument_list|,
name|cutoffPlane
argument_list|,
name|topEdgePoint
argument_list|,
name|bottomEdgePoint
argument_list|)
expr_stmt|;
block|}
comment|/** Constructor for case (2.5).      * Generate an endpoint, given two cutoff planes plus upper and lower edge points.      *@param point is the center.      *@param cutoffPlane1 is one adjoining path segment cutoff plane.      *@param cutoffPlane2 is another adjoining path segment cutoff plane.      *@param topEdgePoint is a point on the cutoffPlane that should be also on the circle plane.      *@param bottomEdgePoint is another point on the cutoffPlane that should be also on the circle plane.      */
DECL|method|SegmentEndpoint
specifier|public
name|SegmentEndpoint
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|SidedPlane
name|cutoffPlane1
parameter_list|,
specifier|final
name|SidedPlane
name|cutoffPlane2
parameter_list|,
specifier|final
name|GeoPoint
name|topEdgePoint
parameter_list|,
specifier|final
name|GeoPoint
name|bottomEdgePoint
parameter_list|)
block|{
name|this
operator|.
name|point
operator|=
name|point
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
operator|new
name|SidedPlane
argument_list|(
name|cutoffPlane1
argument_list|)
block|,
operator|new
name|SidedPlane
argument_list|(
name|cutoffPlane2
argument_list|)
block|}
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|topEdgePoint
block|,
name|bottomEdgePoint
block|}
expr_stmt|;
comment|// To construct the plane, we now just need D, which is simply the negative of the evaluation of the circle normal vector at one of the points.
name|this
operator|.
name|circlePlane
operator|=
name|SidedPlane
operator|.
name|constructNormalizedPerpendicularSidedPlane
argument_list|(
name|point
argument_list|,
name|cutoffPlane1
argument_list|,
name|topEdgePoint
argument_list|,
name|bottomEdgePoint
argument_list|)
expr_stmt|;
block|}
comment|/** Constructor for case (3).      * Generate an endpoint for an intersection, given four points.      *@param point is the center.      *@param prevCutoffPlane is the previous adjoining segment cutoff plane.      *@param nextCutoffPlane is the next path segment cutoff plane.      *@param notCand2Point is a point NOT on candidate2.      *@param notCand1Point is a point NOT on candidate1.      *@param notCand3Point is a point NOT on candidate3.      *@param notCand4Point is a point NOT on candidate4.      *@param candidate1 one of four candidate circle planes.      *@param candidate2 one of four candidate circle planes.      *@param candidate3 one of four candidate circle planes.      *@param candidate4 one of four candidate circle planes.      */
DECL|method|SegmentEndpoint
specifier|public
name|SegmentEndpoint
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|SidedPlane
name|prevCutoffPlane
parameter_list|,
specifier|final
name|SidedPlane
name|nextCutoffPlane
parameter_list|,
specifier|final
name|GeoPoint
name|notCand2Point
parameter_list|,
specifier|final
name|GeoPoint
name|notCand1Point
parameter_list|,
specifier|final
name|GeoPoint
name|notCand3Point
parameter_list|,
specifier|final
name|GeoPoint
name|notCand4Point
parameter_list|,
specifier|final
name|SidedPlane
name|candidate1
parameter_list|,
specifier|final
name|SidedPlane
name|candidate2
parameter_list|,
specifier|final
name|SidedPlane
name|candidate3
parameter_list|,
specifier|final
name|SidedPlane
name|candidate4
parameter_list|)
block|{
comment|// Note: What we really need is a single plane that goes through all four points.
comment|// Since that's not possible in the ellipsoid case (because three points determine a plane, not four), we
comment|// need an approximation that at least creates a boundary that has no interruptions.
comment|// There are three obvious choices for the third point: either (a) one of the two remaining points, or (b) the top or bottom edge
comment|// intersection point.  (a) has no guarantee of continuity, while (b) is capable of producing something very far from a circle if
comment|// the angle between segments is acute.
comment|// The solution is to look for the side (top or bottom) that has an intersection within the shape.  We use the two points from
comment|// the opposite side to determine the plane, AND we pick the third to be either of the two points on the intersecting side
comment|// PROVIDED that the other point is within the final circle we come up with.
name|this
operator|.
name|point
operator|=
name|point
expr_stmt|;
comment|// We construct four separate planes, and evaluate which one includes all interior points with least overlap
comment|// (Constructed beforehand because we need them for degeneracy check)
specifier|final
name|boolean
name|cand1IsOtherWithin
init|=
name|candidate1
operator|!=
literal|null
condition|?
name|candidate1
operator|.
name|isWithin
argument_list|(
name|notCand1Point
argument_list|)
else|:
literal|false
decl_stmt|;
specifier|final
name|boolean
name|cand2IsOtherWithin
init|=
name|candidate2
operator|!=
literal|null
condition|?
name|candidate2
operator|.
name|isWithin
argument_list|(
name|notCand2Point
argument_list|)
else|:
literal|false
decl_stmt|;
specifier|final
name|boolean
name|cand3IsOtherWithin
init|=
name|candidate3
operator|!=
literal|null
condition|?
name|candidate3
operator|.
name|isWithin
argument_list|(
name|notCand3Point
argument_list|)
else|:
literal|false
decl_stmt|;
specifier|final
name|boolean
name|cand4IsOtherWithin
init|=
name|candidate4
operator|!=
literal|null
condition|?
name|candidate4
operator|.
name|isWithin
argument_list|(
name|notCand4Point
argument_list|)
else|:
literal|false
decl_stmt|;
if|if
condition|(
name|cand1IsOtherWithin
operator|&&
name|cand2IsOtherWithin
operator|&&
name|cand3IsOtherWithin
operator|&&
name|cand4IsOtherWithin
condition|)
block|{
comment|// The only way we should see both within is if all four points are coplanar.  In that case, we default to the simplest treatment.
name|this
operator|.
name|circlePlane
operator|=
name|candidate1
expr_stmt|;
comment|// doesn't matter which
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|notCand2Point
block|,
name|notCand3Point
block|,
name|notCand1Point
block|,
name|notCand4Point
block|}
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
operator|new
name|SidedPlane
argument_list|(
name|prevCutoffPlane
argument_list|)
block|,
operator|new
name|SidedPlane
argument_list|(
name|nextCutoffPlane
argument_list|)
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cand1IsOtherWithin
condition|)
block|{
comment|// Use candidate1, and DON'T include prevCutoffPlane in the cutoff planes list
name|this
operator|.
name|circlePlane
operator|=
name|candidate1
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|notCand2Point
block|,
name|notCand3Point
block|,
name|notCand4Point
block|}
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
operator|new
name|SidedPlane
argument_list|(
name|nextCutoffPlane
argument_list|)
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cand2IsOtherWithin
condition|)
block|{
comment|// Use candidate2
name|this
operator|.
name|circlePlane
operator|=
name|candidate2
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|notCand3Point
block|,
name|notCand4Point
block|,
name|notCand1Point
block|}
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
operator|new
name|SidedPlane
argument_list|(
name|nextCutoffPlane
argument_list|)
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cand3IsOtherWithin
condition|)
block|{
name|this
operator|.
name|circlePlane
operator|=
name|candidate3
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|notCand4Point
block|,
name|notCand1Point
block|,
name|notCand2Point
block|}
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
operator|new
name|SidedPlane
argument_list|(
name|prevCutoffPlane
argument_list|)
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cand4IsOtherWithin
condition|)
block|{
name|this
operator|.
name|circlePlane
operator|=
name|candidate4
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|notCand1Point
block|,
name|notCand2Point
block|,
name|notCand3Point
block|}
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
operator|new
name|SidedPlane
argument_list|(
name|prevCutoffPlane
argument_list|)
block|}
expr_stmt|;
block|}
else|else
block|{
comment|// dunno what happened
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Couldn't come up with a plane through three points that included the fourth"
argument_list|)
throw|;
block|}
block|}
comment|/** Check if point is within this endpoint.      *@param point is the point.      *@return true of within.      */
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|Vector
name|point
parameter_list|)
block|{
if|if
condition|(
name|circlePlane
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|circlePlane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
return|;
block|}
comment|/** Check if point is within this endpoint.      *@param x is the point x.      *@param y is the point y.      *@param z is the point z.      *@return true of within.      */
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
if|if
condition|(
name|circlePlane
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|circlePlane
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
return|;
block|}
comment|/** Compute interior path distance.      *@param distanceStyle is the distance style.      *@param x is the point x.      *@param y is the point y.      *@param z is the point z.      *@return the distance metric.      */
DECL|method|pathDistance
specifier|public
name|double
name|pathDistance
parameter_list|(
specifier|final
name|DistanceStyle
name|distanceStyle
parameter_list|,
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
return|return
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|this
operator|.
name|point
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
return|;
block|}
comment|/** Compute external distance.      *@param distanceStyle is the distance style.      *@param x is the point x.      *@param y is the point y.      *@param z is the point z.      *@return the distance metric.      */
DECL|method|outsideDistance
specifier|public
name|double
name|outsideDistance
parameter_list|(
specifier|final
name|DistanceStyle
name|distanceStyle
parameter_list|,
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|this
operator|.
name|point
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
return|;
block|}
comment|/** Determine if this endpoint intersects a specified plane.      *@param planetModel is the planet model.      *@param p is the plane.      *@param notablePoints are the points associated with the plane.      *@param bounds are any bounds which the intersection must lie within.      *@return true if there is a matching intersection.      */
DECL|method|intersects
specifier|public
name|boolean
name|intersects
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|Plane
name|p
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|notablePoints
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|)
block|{
comment|//System.err.println("  looking for intersection between plane "+p+" and circle "+circlePlane+" on proper side of "+cutoffPlanes+" within "+bounds);
if|if
condition|(
name|circlePlane
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|circlePlane
operator|.
name|intersects
argument_list|(
name|planetModel
argument_list|,
name|p
argument_list|,
name|notablePoints
argument_list|,
name|this
operator|.
name|notablePoints
argument_list|,
name|bounds
argument_list|,
name|this
operator|.
name|cutoffPlanes
argument_list|)
return|;
block|}
comment|/** Get the bounds for a segment endpoint.      *@param planetModel is the planet model.      *@param bounds are the bounds to be modified.      */
DECL|method|getBounds
specifier|public
name|void
name|getBounds
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
name|Bounds
name|bounds
parameter_list|)
block|{
name|bounds
operator|.
name|addPoint
argument_list|(
name|point
argument_list|)
expr_stmt|;
if|if
condition|(
name|circlePlane
operator|==
literal|null
condition|)
return|return;
name|circlePlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|bounds
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|SegmentEndpoint
operator|)
condition|)
return|return
literal|false
return|;
name|SegmentEndpoint
name|other
init|=
operator|(
name|SegmentEndpoint
operator|)
name|o
decl_stmt|;
return|return
name|point
operator|.
name|equals
argument_list|(
name|other
operator|.
name|point
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|point
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|point
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * This is the pre-calculated data for a path segment.    */
DECL|class|PathSegment
specifier|public
specifier|static
class|class
name|PathSegment
block|{
comment|/** Starting point of the segment */
DECL|field|start
specifier|public
specifier|final
name|GeoPoint
name|start
decl_stmt|;
comment|/** End point of the segment */
DECL|field|end
specifier|public
specifier|final
name|GeoPoint
name|end
decl_stmt|;
comment|/** Place to keep any complete segment distances we've calculated so far */
DECL|field|fullDistanceCache
specifier|public
specifier|final
name|Map
argument_list|<
name|DistanceStyle
argument_list|,
name|Double
argument_list|>
name|fullDistanceCache
init|=
operator|new
name|HashMap
argument_list|<
name|DistanceStyle
argument_list|,
name|Double
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Normalized plane connecting the two points and going through world center */
DECL|field|normalizedConnectingPlane
specifier|public
specifier|final
name|Plane
name|normalizedConnectingPlane
decl_stmt|;
comment|/** Cutoff plane parallel to connecting plane representing one side of the path segment */
DECL|field|upperConnectingPlane
specifier|public
specifier|final
name|SidedPlane
name|upperConnectingPlane
decl_stmt|;
comment|/** Cutoff plane parallel to connecting plane representing the other side of the path segment */
DECL|field|lowerConnectingPlane
specifier|public
specifier|final
name|SidedPlane
name|lowerConnectingPlane
decl_stmt|;
comment|/** Plane going through the center and start point, marking the start edge of the segment */
DECL|field|startCutoffPlane
specifier|public
specifier|final
name|SidedPlane
name|startCutoffPlane
decl_stmt|;
comment|/** Plane going through the center and end point, marking the end edge of the segment */
DECL|field|endCutoffPlane
specifier|public
specifier|final
name|SidedPlane
name|endCutoffPlane
decl_stmt|;
comment|/** Upper right hand corner of segment */
DECL|field|URHC
specifier|public
specifier|final
name|GeoPoint
name|URHC
decl_stmt|;
comment|/** Lower right hand corner of segment */
DECL|field|LRHC
specifier|public
specifier|final
name|GeoPoint
name|LRHC
decl_stmt|;
comment|/** Upper left hand corner of segment */
DECL|field|ULHC
specifier|public
specifier|final
name|GeoPoint
name|ULHC
decl_stmt|;
comment|/** Lower left hand corner of segment */
DECL|field|LLHC
specifier|public
specifier|final
name|GeoPoint
name|LLHC
decl_stmt|;
comment|/** Notable points for the upper connecting plane */
DECL|field|upperConnectingPlanePoints
specifier|public
specifier|final
name|GeoPoint
index|[]
name|upperConnectingPlanePoints
decl_stmt|;
comment|/** Notable points for the lower connecting plane */
DECL|field|lowerConnectingPlanePoints
specifier|public
specifier|final
name|GeoPoint
index|[]
name|lowerConnectingPlanePoints
decl_stmt|;
comment|/** Notable points for the start cutoff plane */
DECL|field|startCutoffPlanePoints
specifier|public
specifier|final
name|GeoPoint
index|[]
name|startCutoffPlanePoints
decl_stmt|;
comment|/** Notable points for the end cutoff plane */
DECL|field|endCutoffPlanePoints
specifier|public
specifier|final
name|GeoPoint
index|[]
name|endCutoffPlanePoints
decl_stmt|;
DECL|method|PathSegment
specifier|public
name|PathSegment
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|GeoPoint
name|start
parameter_list|,
specifier|final
name|GeoPoint
name|end
parameter_list|,
specifier|final
name|Plane
name|normalizedConnectingPlane
parameter_list|,
specifier|final
name|double
name|planeBoundingOffset
parameter_list|)
block|{
name|this
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|this
operator|.
name|end
operator|=
name|end
expr_stmt|;
name|this
operator|.
name|normalizedConnectingPlane
operator|=
name|normalizedConnectingPlane
expr_stmt|;
comment|// Either start or end should be on the correct side
name|upperConnectingPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|start
argument_list|,
name|normalizedConnectingPlane
argument_list|,
operator|-
name|planeBoundingOffset
argument_list|)
expr_stmt|;
name|lowerConnectingPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|start
argument_list|,
name|normalizedConnectingPlane
argument_list|,
name|planeBoundingOffset
argument_list|)
expr_stmt|;
comment|// Cutoff planes use opposite endpoints as correct side examples
name|startCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|end
argument_list|,
name|normalizedConnectingPlane
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|endCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|start
argument_list|,
name|normalizedConnectingPlane
argument_list|,
name|end
argument_list|)
expr_stmt|;
specifier|final
name|Membership
index|[]
name|upperSide
init|=
operator|new
name|Membership
index|[]
block|{
name|upperConnectingPlane
block|}
decl_stmt|;
specifier|final
name|Membership
index|[]
name|lowerSide
init|=
operator|new
name|Membership
index|[]
block|{
name|lowerConnectingPlane
block|}
decl_stmt|;
specifier|final
name|Membership
index|[]
name|startSide
init|=
operator|new
name|Membership
index|[]
block|{
name|startCutoffPlane
block|}
decl_stmt|;
specifier|final
name|Membership
index|[]
name|endSide
init|=
operator|new
name|Membership
index|[]
block|{
name|endCutoffPlane
block|}
decl_stmt|;
name|GeoPoint
index|[]
name|points
decl_stmt|;
name|points
operator|=
name|upperConnectingPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|startCutoffPlane
argument_list|,
name|lowerSide
argument_list|,
name|endSide
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Some segment boundary points are off the ellipsoid; path too wide"
argument_list|)
throw|;
block|}
name|this
operator|.
name|ULHC
operator|=
name|points
index|[
literal|0
index|]
expr_stmt|;
name|points
operator|=
name|upperConnectingPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|endCutoffPlane
argument_list|,
name|lowerSide
argument_list|,
name|startSide
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Some segment boundary points are off the ellipsoid; path too wide"
argument_list|)
throw|;
block|}
name|this
operator|.
name|URHC
operator|=
name|points
index|[
literal|0
index|]
expr_stmt|;
name|points
operator|=
name|lowerConnectingPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|startCutoffPlane
argument_list|,
name|upperSide
argument_list|,
name|endSide
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Some segment boundary points are off the ellipsoid; path too wide"
argument_list|)
throw|;
block|}
name|this
operator|.
name|LLHC
operator|=
name|points
index|[
literal|0
index|]
expr_stmt|;
name|points
operator|=
name|lowerConnectingPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|endCutoffPlane
argument_list|,
name|upperSide
argument_list|,
name|startSide
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Some segment boundary points are off the ellipsoid; path too wide"
argument_list|)
throw|;
block|}
name|this
operator|.
name|LRHC
operator|=
name|points
index|[
literal|0
index|]
expr_stmt|;
name|upperConnectingPlanePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|ULHC
block|,
name|URHC
block|}
expr_stmt|;
name|lowerConnectingPlanePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|LLHC
block|,
name|LRHC
block|}
expr_stmt|;
name|startCutoffPlanePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|ULHC
block|,
name|LLHC
block|}
expr_stmt|;
name|endCutoffPlanePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|URHC
block|,
name|LRHC
block|}
expr_stmt|;
block|}
comment|/** Compute the full distance along this path segment.      *@param distanceStyle is the distance style.      *@return the distance metric.      */
DECL|method|fullPathDistance
specifier|public
name|double
name|fullPathDistance
parameter_list|(
specifier|final
name|DistanceStyle
name|distanceStyle
parameter_list|)
block|{
synchronized|synchronized
init|(
name|fullDistanceCache
init|)
block|{
name|Double
name|dist
init|=
name|fullDistanceCache
operator|.
name|get
argument_list|(
name|distanceStyle
argument_list|)
decl_stmt|;
if|if
condition|(
name|dist
operator|==
literal|null
condition|)
block|{
name|dist
operator|=
operator|new
name|Double
argument_list|(
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|start
argument_list|,
name|end
operator|.
name|x
argument_list|,
name|end
operator|.
name|y
argument_list|,
name|end
operator|.
name|z
argument_list|)
argument_list|)
expr_stmt|;
name|fullDistanceCache
operator|.
name|put
argument_list|(
name|distanceStyle
argument_list|,
name|dist
argument_list|)
expr_stmt|;
block|}
return|return
name|dist
operator|.
name|doubleValue
argument_list|()
return|;
block|}
block|}
comment|/** Check if point is within this segment.      *@param point is the point.      *@return true of within.      */
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|Vector
name|point
parameter_list|)
block|{
return|return
name|startCutoffPlane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
operator|&&
name|endCutoffPlane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
operator|&&
name|upperConnectingPlane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
operator|&&
name|lowerConnectingPlane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
return|;
block|}
comment|/** Check if point is within this segment.      *@param x is the point x.      *@param y is the point y.      *@param z is the point z.      *@return true of within.      */
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|startCutoffPlane
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
operator|&&
name|endCutoffPlane
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
operator|&&
name|upperConnectingPlane
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
operator|&&
name|lowerConnectingPlane
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
return|;
block|}
comment|/** Compute interior path distance.      *@param planetModel is the planet model.      *@param distanceStyle is the distance style.      *@param x is the point x.      *@param y is the point y.      *@param z is the point z.      *@return the distance metric.      */
DECL|method|pathDistance
specifier|public
name|double
name|pathDistance
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|DistanceStyle
name|distanceStyle
parameter_list|,
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
comment|// (1) Compute normalizedPerpPlane.  If degenerate, then return point distance from start to point.
comment|// Want no allocations or expensive operations!  so we do this the hard way
specifier|final
name|double
name|perpX
init|=
name|normalizedConnectingPlane
operator|.
name|y
operator|*
name|z
operator|-
name|normalizedConnectingPlane
operator|.
name|z
operator|*
name|y
decl_stmt|;
specifier|final
name|double
name|perpY
init|=
name|normalizedConnectingPlane
operator|.
name|z
operator|*
name|x
operator|-
name|normalizedConnectingPlane
operator|.
name|x
operator|*
name|z
decl_stmt|;
specifier|final
name|double
name|perpZ
init|=
name|normalizedConnectingPlane
operator|.
name|x
operator|*
name|y
operator|-
name|normalizedConnectingPlane
operator|.
name|y
operator|*
name|x
decl_stmt|;
specifier|final
name|double
name|magnitude
init|=
name|Math
operator|.
name|sqrt
argument_list|(
name|perpX
operator|*
name|perpX
operator|+
name|perpY
operator|*
name|perpY
operator|+
name|perpZ
operator|*
name|perpZ
argument_list|)
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|magnitude
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
condition|)
return|return
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|start
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
return|;
specifier|final
name|double
name|normFactor
init|=
literal|1.0
operator|/
name|magnitude
decl_stmt|;
specifier|final
name|Plane
name|normalizedPerpPlane
init|=
operator|new
name|Plane
argument_list|(
name|perpX
operator|*
name|normFactor
argument_list|,
name|perpY
operator|*
name|normFactor
argument_list|,
name|perpZ
operator|*
name|normFactor
argument_list|,
literal|0.0
argument_list|)
decl_stmt|;
comment|// Old computation: too expensive, because it calculates the intersection point twice.
comment|//return distanceStyle.computeDistance(planetModel, normalizedConnectingPlane, x, y, z, startCutoffPlane, endCutoffPlane) +
comment|//  distanceStyle.computeDistance(planetModel, normalizedPerpPlane, start.x, start.y, start.z, upperConnectingPlane, lowerConnectingPlane);
specifier|final
name|GeoPoint
index|[]
name|intersectionPoints
init|=
name|normalizedConnectingPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|normalizedPerpPlane
argument_list|)
decl_stmt|;
name|GeoPoint
name|thePoint
decl_stmt|;
if|if
condition|(
name|intersectionPoints
operator|.
name|length
operator|==
literal|0
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Can't find world intersection for point x="
operator|+
name|x
operator|+
literal|" y="
operator|+
name|y
operator|+
literal|" z="
operator|+
name|z
argument_list|)
throw|;
elseif|else
if|if
condition|(
name|intersectionPoints
operator|.
name|length
operator|==
literal|1
condition|)
name|thePoint
operator|=
name|intersectionPoints
index|[
literal|0
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|startCutoffPlane
operator|.
name|isWithin
argument_list|(
name|intersectionPoints
index|[
literal|0
index|]
argument_list|)
operator|&&
name|endCutoffPlane
operator|.
name|isWithin
argument_list|(
name|intersectionPoints
index|[
literal|0
index|]
argument_list|)
condition|)
name|thePoint
operator|=
name|intersectionPoints
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|startCutoffPlane
operator|.
name|isWithin
argument_list|(
name|intersectionPoints
index|[
literal|1
index|]
argument_list|)
operator|&&
name|endCutoffPlane
operator|.
name|isWithin
argument_list|(
name|intersectionPoints
index|[
literal|1
index|]
argument_list|)
condition|)
name|thePoint
operator|=
name|intersectionPoints
index|[
literal|1
index|]
expr_stmt|;
else|else
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Can't find world intersection for point x="
operator|+
name|x
operator|+
literal|" y="
operator|+
name|y
operator|+
literal|" z="
operator|+
name|z
argument_list|)
throw|;
block|}
return|return
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|thePoint
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
operator|+
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|start
argument_list|,
name|thePoint
operator|.
name|x
argument_list|,
name|thePoint
operator|.
name|y
argument_list|,
name|thePoint
operator|.
name|z
argument_list|)
return|;
block|}
comment|/** Compute external distance.      *@param planetModel is the planet model.      *@param distanceStyle is the distance style.      *@param x is the point x.      *@param y is the point y.      *@param z is the point z.      *@return the distance metric.      */
DECL|method|outsideDistance
specifier|public
name|double
name|outsideDistance
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|DistanceStyle
name|distanceStyle
parameter_list|,
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
specifier|final
name|double
name|upperDistance
init|=
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|planetModel
argument_list|,
name|upperConnectingPlane
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|lowerConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|,
name|endCutoffPlane
argument_list|)
decl_stmt|;
specifier|final
name|double
name|lowerDistance
init|=
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|planetModel
argument_list|,
name|lowerConnectingPlane
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|upperConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|,
name|endCutoffPlane
argument_list|)
decl_stmt|;
specifier|final
name|double
name|startDistance
init|=
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|planetModel
argument_list|,
name|startCutoffPlane
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|endCutoffPlane
argument_list|,
name|lowerConnectingPlane
argument_list|,
name|upperConnectingPlane
argument_list|)
decl_stmt|;
specifier|final
name|double
name|endDistance
init|=
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|planetModel
argument_list|,
name|endCutoffPlane
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|startCutoffPlane
argument_list|,
name|lowerConnectingPlane
argument_list|,
name|upperConnectingPlane
argument_list|)
decl_stmt|;
specifier|final
name|double
name|ULHCDistance
init|=
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|ULHC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
specifier|final
name|double
name|URHCDistance
init|=
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|URHC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
specifier|final
name|double
name|LLHCDistance
init|=
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|LLHC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
specifier|final
name|double
name|LRHCDistance
init|=
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|LRHC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
return|return
name|Math
operator|.
name|min
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|upperDistance
argument_list|,
name|lowerDistance
argument_list|)
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|startDistance
argument_list|,
name|endDistance
argument_list|)
argument_list|)
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|ULHCDistance
argument_list|,
name|URHCDistance
argument_list|)
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|LLHCDistance
argument_list|,
name|LRHCDistance
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/** Determine if this endpoint intersects a specified plane.      *@param planetModel is the planet model.      *@param p is the plane.      *@param notablePoints are the points associated with the plane.      *@param bounds are any bounds which the intersection must lie within.      *@return true if there is a matching intersection.      */
DECL|method|intersects
specifier|public
name|boolean
name|intersects
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|Plane
name|p
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|notablePoints
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|)
block|{
return|return
name|upperConnectingPlane
operator|.
name|intersects
argument_list|(
name|planetModel
argument_list|,
name|p
argument_list|,
name|notablePoints
argument_list|,
name|upperConnectingPlanePoints
argument_list|,
name|bounds
argument_list|,
name|lowerConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|,
name|endCutoffPlane
argument_list|)
operator|||
name|lowerConnectingPlane
operator|.
name|intersects
argument_list|(
name|planetModel
argument_list|,
name|p
argument_list|,
name|notablePoints
argument_list|,
name|lowerConnectingPlanePoints
argument_list|,
name|bounds
argument_list|,
name|upperConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|,
name|endCutoffPlane
argument_list|)
return|;
block|}
comment|/** Get the bounds for a segment endpoint.      *@param planetModel is the planet model.      *@param bounds are the bounds to be modified.      */
DECL|method|getBounds
specifier|public
name|void
name|getBounds
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
name|Bounds
name|bounds
parameter_list|)
block|{
comment|// We need to do all bounding planes as well as corner points
name|bounds
operator|.
name|addPoint
argument_list|(
name|start
argument_list|)
operator|.
name|addPoint
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|upperConnectingPlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|startCutoffPlane
argument_list|,
name|bounds
argument_list|,
name|lowerConnectingPlane
argument_list|,
name|endCutoffPlane
argument_list|)
expr_stmt|;
name|startCutoffPlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|lowerConnectingPlane
argument_list|,
name|bounds
argument_list|,
name|endCutoffPlane
argument_list|,
name|upperConnectingPlane
argument_list|)
expr_stmt|;
name|lowerConnectingPlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|endCutoffPlane
argument_list|,
name|bounds
argument_list|,
name|upperConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|)
expr_stmt|;
name|endCutoffPlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|upperConnectingPlane
argument_list|,
name|bounds
argument_list|,
name|startCutoffPlane
argument_list|,
name|lowerConnectingPlane
argument_list|)
expr_stmt|;
name|upperConnectingPlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|bounds
argument_list|,
name|lowerConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|,
name|endCutoffPlane
argument_list|)
expr_stmt|;
name|lowerConnectingPlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|bounds
argument_list|,
name|upperConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|,
name|endCutoffPlane
argument_list|)
expr_stmt|;
name|startCutoffPlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|bounds
argument_list|,
name|endCutoffPlane
argument_list|,
name|upperConnectingPlane
argument_list|,
name|lowerConnectingPlane
argument_list|)
expr_stmt|;
name|endCutoffPlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|bounds
argument_list|,
name|startCutoffPlane
argument_list|,
name|upperConnectingPlane
argument_list|,
name|lowerConnectingPlane
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
