begin_unit
begin_package
DECL|package|org.apache.lucene.geo3d
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|geo3d
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  * We know about three kinds of planes.  First kind: general plain through two points and origin  * Second kind: horizontal plane at specified height.  Third kind: vertical plane with specified x and y value, through origin.  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|Plane
specifier|public
class|class
name|Plane
extends|extends
name|Vector
block|{
DECL|field|NO_POINTS
specifier|protected
specifier|final
specifier|static
name|GeoPoint
index|[]
name|NO_POINTS
init|=
operator|new
name|GeoPoint
index|[
literal|0
index|]
decl_stmt|;
DECL|field|NO_BOUNDS
specifier|protected
specifier|final
specifier|static
name|Membership
index|[]
name|NO_BOUNDS
init|=
operator|new
name|Membership
index|[
literal|0
index|]
decl_stmt|;
DECL|field|D
specifier|public
specifier|final
name|double
name|D
decl_stmt|;
comment|/**    * Construct a plane with all four coefficients defined.    */
DECL|method|Plane
specifier|public
name|Plane
parameter_list|(
specifier|final
name|double
name|A
parameter_list|,
specifier|final
name|double
name|B
parameter_list|,
specifier|final
name|double
name|C
parameter_list|,
specifier|final
name|double
name|D
parameter_list|)
block|{
name|super
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|)
expr_stmt|;
name|this
operator|.
name|D
operator|=
name|D
expr_stmt|;
block|}
comment|/**    * Construct a plane through two points and origin.    *    * @param A is the first point (origin based).    * @param B is the second point (origin based).    */
DECL|method|Plane
specifier|public
name|Plane
parameter_list|(
specifier|final
name|Vector
name|A
parameter_list|,
specifier|final
name|Vector
name|B
parameter_list|)
block|{
name|super
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
expr_stmt|;
name|D
operator|=
literal|0.0
expr_stmt|;
block|}
comment|/**    * Construct a horizontal plane at a specified Z.    *    * @param planetModel is the planet model.    * @param sinLat is the sin(latitude).    */
DECL|method|Plane
specifier|public
name|Plane
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|double
name|sinLat
parameter_list|)
block|{
name|super
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|D
operator|=
operator|-
name|sinLat
operator|*
name|computeDesiredEllipsoidMagnitude
argument_list|(
name|planetModel
argument_list|,
name|sinLat
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct a vertical plane through a specified    * x, y and origin.    *    * @param x is the specified x value.    * @param y is the specified y value.    */
DECL|method|Plane
specifier|public
name|Plane
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|)
block|{
name|super
argument_list|(
name|y
argument_list|,
operator|-
name|x
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|D
operator|=
literal|0.0
expr_stmt|;
block|}
comment|/**    * Construct a plane with a specific vector, and D offset    * from origin.    *    * @param D is the D offset from the origin.    */
DECL|method|Plane
specifier|public
name|Plane
parameter_list|(
specifier|final
name|Vector
name|v
parameter_list|,
specifier|final
name|double
name|D
parameter_list|)
block|{
name|super
argument_list|(
name|v
operator|.
name|x
argument_list|,
name|v
operator|.
name|y
argument_list|,
name|v
operator|.
name|z
argument_list|)
expr_stmt|;
name|this
operator|.
name|D
operator|=
name|D
expr_stmt|;
block|}
comment|/** Construct the most accurate normalized, vertical plane given a set of points.  If none of the points can determine   * the plane, return null.   */
DECL|method|constructNormalizedVerticalPlane
specifier|public
specifier|static
name|Plane
name|constructNormalizedVerticalPlane
parameter_list|(
specifier|final
name|Vector
modifier|...
name|planePoints
parameter_list|)
block|{
comment|// Pick the best one (with the greatest x-y distance)
name|double
name|bestDistance
init|=
literal|0.0
decl_stmt|;
name|Vector
name|bestPoint
init|=
literal|null
decl_stmt|;
for|for
control|(
specifier|final
name|Vector
name|point
range|:
name|planePoints
control|)
block|{
specifier|final
name|double
name|pointDist
init|=
name|point
operator|.
name|x
operator|*
name|point
operator|.
name|x
operator|+
name|point
operator|.
name|y
operator|*
name|point
operator|.
name|y
decl_stmt|;
if|if
condition|(
name|pointDist
operator|>
name|bestDistance
condition|)
block|{
name|bestDistance
operator|=
name|pointDist
expr_stmt|;
name|bestPoint
operator|=
name|point
expr_stmt|;
block|}
block|}
return|return
name|constructNormalizedVerticalPlane
argument_list|(
name|bestPoint
operator|.
name|x
argument_list|,
name|bestPoint
operator|.
name|y
argument_list|)
return|;
block|}
comment|/** Construct a normalized, vertical plane through an x-y point.  If the x-y point is at (0,0), return null.   */
DECL|method|constructNormalizedVerticalPlane
specifier|public
specifier|static
name|Plane
name|constructNormalizedVerticalPlane
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|)
block|{
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|x
argument_list|)
operator|<
name|MINIMUM_RESOLUTION
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|y
argument_list|)
operator|<
name|MINIMUM_RESOLUTION
condition|)
return|return
literal|null
return|;
specifier|final
name|double
name|denom
init|=
literal|1.0
operator|/
name|Math
operator|.
name|sqrt
argument_list|(
name|x
operator|*
name|x
operator|+
name|y
operator|*
name|y
argument_list|)
decl_stmt|;
return|return
operator|new
name|Plane
argument_list|(
name|x
operator|*
name|denom
argument_list|,
name|y
operator|*
name|denom
argument_list|)
return|;
block|}
comment|/**    * Evaluate the plane equation for a given point, as represented    * by a vector.    *    * @param v is the vector.    * @return the result of the evaluation.    */
DECL|method|evaluate
specifier|public
name|double
name|evaluate
parameter_list|(
specifier|final
name|Vector
name|v
parameter_list|)
block|{
return|return
name|dotProduct
argument_list|(
name|v
argument_list|)
operator|+
name|D
return|;
block|}
comment|/**    * Evaluate the plane equation for a given point, as represented    * by a vector.    */
DECL|method|evaluate
specifier|public
name|double
name|evaluate
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|dotProduct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
operator|+
name|D
return|;
block|}
comment|/**    * Evaluate the plane equation for a given point, as represented    * by a vector.    *    * @param v is the vector.    * @return true if the result is on the plane.    */
DECL|method|evaluateIsZero
specifier|public
name|boolean
name|evaluateIsZero
parameter_list|(
specifier|final
name|Vector
name|v
parameter_list|)
block|{
return|return
name|Math
operator|.
name|abs
argument_list|(
name|evaluate
argument_list|(
name|v
argument_list|)
argument_list|)
operator|<
name|MINIMUM_RESOLUTION
return|;
block|}
comment|/**    * Evaluate the plane equation for a given point, as represented    * by a vector.    *    * @return true if the result is on the plane.    */
DECL|method|evaluateIsZero
specifier|public
name|boolean
name|evaluateIsZero
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|Math
operator|.
name|abs
argument_list|(
name|evaluate
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
argument_list|)
operator|<
name|MINIMUM_RESOLUTION
return|;
block|}
comment|/**    * Build a normalized plane, so that the vector is normalized.    *    * @return the normalized plane object, or null if the plane is indeterminate.    */
DECL|method|normalize
specifier|public
name|Plane
name|normalize
parameter_list|()
block|{
name|Vector
name|normVect
init|=
name|super
operator|.
name|normalize
argument_list|()
decl_stmt|;
if|if
condition|(
name|normVect
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|Plane
argument_list|(
name|normVect
argument_list|,
name|this
operator|.
name|D
argument_list|)
return|;
block|}
comment|/** @see #arcDistance(PlanetModel, double, double, double, Membership...) */
DECL|method|arcDistance
specifier|public
name|double
name|arcDistance
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|GeoPoint
name|v
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
return|return
name|arcDistance
argument_list|(
name|planetModel
argument_list|,
name|v
operator|.
name|x
argument_list|,
name|v
operator|.
name|y
argument_list|,
name|v
operator|.
name|z
argument_list|,
name|bounds
argument_list|)
return|;
block|}
comment|/**    * Compute arc distance from plane to a vector.    * @param x is the x vector value.    * @param y is the y vector value.    * @param z is the z vector value.    * @return the arc distance.    */
DECL|method|arcDistance
specifier|public
name|double
name|arcDistance
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
if|if
condition|(
name|evaluateIsZero
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
block|{
if|if
condition|(
name|meetsAllBounds
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|bounds
argument_list|)
condition|)
return|return
literal|0.0
return|;
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
block|}
comment|// First, compute the perpendicular plane.
specifier|final
name|Plane
name|perpPlane
init|=
operator|new
name|Plane
argument_list|(
name|this
operator|.
name|y
operator|*
name|z
operator|-
name|this
operator|.
name|z
operator|*
name|y
argument_list|,
name|this
operator|.
name|z
operator|*
name|x
operator|-
name|this
operator|.
name|x
operator|*
name|z
argument_list|,
name|this
operator|.
name|x
operator|*
name|y
operator|-
name|this
operator|.
name|y
operator|*
name|x
argument_list|,
literal|0.0
argument_list|)
decl_stmt|;
comment|// We need to compute the intersection of two planes on the geo surface: this one, and its perpendicular.
comment|// Then, we need to choose which of the two points we want to compute the distance to.  We pick the
comment|// shorter distance always.
specifier|final
name|GeoPoint
index|[]
name|intersectionPoints
init|=
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|perpPlane
argument_list|)
decl_stmt|;
comment|// For each point, compute a linear distance, and take the minimum of them
name|double
name|minDistance
init|=
name|Double
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
specifier|final
name|GeoPoint
name|intersectionPoint
range|:
name|intersectionPoints
control|)
block|{
if|if
condition|(
name|meetsAllBounds
argument_list|(
name|intersectionPoint
argument_list|,
name|bounds
argument_list|)
condition|)
block|{
specifier|final
name|double
name|theDistance
init|=
name|intersectionPoint
operator|.
name|arcDistance
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|theDistance
operator|<
name|minDistance
condition|)
block|{
name|minDistance
operator|=
name|theDistance
expr_stmt|;
block|}
block|}
block|}
return|return
name|minDistance
return|;
block|}
comment|/**    * Compute normal distance from plane to a vector.    * @param v is the vector.    * @return the normal distance.    */
DECL|method|normalDistance
specifier|public
name|double
name|normalDistance
parameter_list|(
specifier|final
name|Vector
name|v
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
return|return
name|normalDistance
argument_list|(
name|v
operator|.
name|x
argument_list|,
name|v
operator|.
name|y
argument_list|,
name|v
operator|.
name|z
argument_list|,
name|bounds
argument_list|)
return|;
block|}
comment|/**    * Compute normal distance from plane to a vector.    * @param x is the vector x.    * @param y is the vector y.    * @param z is the vector z.    * @return the normal distance.    */
DECL|method|normalDistance
specifier|public
name|double
name|normalDistance
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
specifier|final
name|double
name|dist
init|=
name|evaluate
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
specifier|final
name|double
name|perpX
init|=
name|x
operator|-
name|dist
operator|*
name|this
operator|.
name|x
decl_stmt|;
specifier|final
name|double
name|perpY
init|=
name|y
operator|-
name|dist
operator|*
name|this
operator|.
name|y
decl_stmt|;
specifier|final
name|double
name|perpZ
init|=
name|z
operator|-
name|dist
operator|*
name|this
operator|.
name|z
decl_stmt|;
if|if
condition|(
operator|!
name|meetsAllBounds
argument_list|(
name|perpX
argument_list|,
name|perpY
argument_list|,
name|perpZ
argument_list|,
name|bounds
argument_list|)
condition|)
block|{
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
block|}
return|return
name|Math
operator|.
name|abs
argument_list|(
name|dist
argument_list|)
return|;
block|}
comment|/**    * Compute normal distance squared from plane to a vector.    * @param v is the vector.    * @return the normal distance squared.    */
DECL|method|normalDistanceSquared
specifier|public
name|double
name|normalDistanceSquared
parameter_list|(
specifier|final
name|Vector
name|v
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
return|return
name|normalDistanceSquared
argument_list|(
name|v
operator|.
name|x
argument_list|,
name|v
operator|.
name|y
argument_list|,
name|v
operator|.
name|z
argument_list|,
name|bounds
argument_list|)
return|;
block|}
comment|/**    * Compute normal distance squared from plane to a vector.    * @param x is the vector x.    * @param y is the vector y.    * @param z is the vector z.    * @return the normal distance squared.    */
DECL|method|normalDistanceSquared
specifier|public
name|double
name|normalDistanceSquared
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
specifier|final
name|double
name|normal
init|=
name|normalDistance
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|bounds
argument_list|)
decl_stmt|;
if|if
condition|(
name|normal
operator|==
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|normal
return|;
return|return
name|normal
operator|*
name|normal
return|;
block|}
comment|/**    * Compute linear distance from plane to a vector.  This is defined    * as the distance from the given point to the nearest intersection of     * this plane with the planet surface.    * @param v is the vector.    * @return the linear distance.    */
DECL|method|linearDistance
specifier|public
name|double
name|linearDistance
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|GeoPoint
name|v
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
return|return
name|linearDistance
argument_list|(
name|planetModel
argument_list|,
name|v
operator|.
name|x
argument_list|,
name|v
operator|.
name|y
argument_list|,
name|v
operator|.
name|z
argument_list|,
name|bounds
argument_list|)
return|;
block|}
comment|/**    * Compute linear distance from plane to a vector.  This is defined    * as the distance from the given point to the nearest intersection of     * this plane with the planet surface.    * @param x is the vector x.    * @param y is the vector y.    * @param z is the vector z.    * @return the linear distance.    */
DECL|method|linearDistance
specifier|public
name|double
name|linearDistance
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
if|if
condition|(
name|evaluateIsZero
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
block|{
if|if
condition|(
name|meetsAllBounds
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|bounds
argument_list|)
condition|)
return|return
literal|0.0
return|;
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
block|}
comment|// First, compute the perpendicular plane.
specifier|final
name|Plane
name|perpPlane
init|=
operator|new
name|Plane
argument_list|(
name|this
operator|.
name|y
operator|*
name|z
operator|-
name|this
operator|.
name|z
operator|*
name|y
argument_list|,
name|this
operator|.
name|z
operator|*
name|x
operator|-
name|this
operator|.
name|x
operator|*
name|z
argument_list|,
name|this
operator|.
name|x
operator|*
name|y
operator|-
name|this
operator|.
name|y
operator|*
name|x
argument_list|,
literal|0.0
argument_list|)
decl_stmt|;
comment|// We need to compute the intersection of two planes on the geo surface: this one, and its perpendicular.
comment|// Then, we need to choose which of the two points we want to compute the distance to.  We pick the
comment|// shorter distance always.
specifier|final
name|GeoPoint
index|[]
name|intersectionPoints
init|=
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|perpPlane
argument_list|)
decl_stmt|;
comment|// For each point, compute a linear distance, and take the minimum of them
name|double
name|minDistance
init|=
name|Double
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
specifier|final
name|GeoPoint
name|intersectionPoint
range|:
name|intersectionPoints
control|)
block|{
if|if
condition|(
name|meetsAllBounds
argument_list|(
name|intersectionPoint
argument_list|,
name|bounds
argument_list|)
condition|)
block|{
specifier|final
name|double
name|theDistance
init|=
name|intersectionPoint
operator|.
name|linearDistance
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|theDistance
operator|<
name|minDistance
condition|)
block|{
name|minDistance
operator|=
name|theDistance
expr_stmt|;
block|}
block|}
block|}
return|return
name|minDistance
return|;
block|}
comment|/**    * Compute linear distance squared from plane to a vector.  This is defined    * as the distance from the given point to the nearest intersection of     * this plane with the planet surface.    * @param v is the vector.    * @return the linear distance squared.    */
DECL|method|linearDistanceSquared
specifier|public
name|double
name|linearDistanceSquared
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|GeoPoint
name|v
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
return|return
name|linearDistanceSquared
argument_list|(
name|planetModel
argument_list|,
name|v
operator|.
name|x
argument_list|,
name|v
operator|.
name|y
argument_list|,
name|v
operator|.
name|z
argument_list|,
name|bounds
argument_list|)
return|;
block|}
comment|/**    * Compute linear distance squared from plane to a vector.  This is defined    * as the distance from the given point to the nearest intersection of     * this plane with the planet surface.    * @param x is the vector x.    * @param y is the vector y.    * @param z is the vector z.    * @return the linear distance squared.    */
DECL|method|linearDistanceSquared
specifier|public
name|double
name|linearDistanceSquared
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
specifier|final
name|double
name|linearDistance
init|=
name|linearDistance
argument_list|(
name|planetModel
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|bounds
argument_list|)
decl_stmt|;
return|return
name|linearDistance
operator|*
name|linearDistance
return|;
block|}
comment|/**    * Find points on the boundary of the intersection of a plane and the unit sphere,    * given a starting point, and ending point, and a list of proportions of the arc (e.g. 0.25, 0.5, 0.75).    * The angle between the starting point and ending point is assumed to be less than pi.    */
DECL|method|interpolate
specifier|public
name|GeoPoint
index|[]
name|interpolate
parameter_list|(
specifier|final
name|GeoPoint
name|start
parameter_list|,
specifier|final
name|GeoPoint
name|end
parameter_list|,
specifier|final
name|double
index|[]
name|proportions
parameter_list|)
block|{
comment|// Steps:
comment|// (1) Translate (x0,y0,z0) of endpoints into origin-centered place:
comment|// x1 = x0 + D*A
comment|// y1 = y0 + D*B
comment|// z1 = z0 + D*C
comment|// (2) Rotate counterclockwise in x-y:
comment|// ra = -atan2(B,A)
comment|// x2 = x1 cos ra - y1 sin ra
comment|// y2 = x1 sin ra + y1 cos ra
comment|// z2 = z1
comment|// Faster:
comment|// cos ra = A/sqrt(A^2+B^2+C^2)
comment|// sin ra = -B/sqrt(A^2+B^2+C^2)
comment|// cos (-ra) = A/sqrt(A^2+B^2+C^2)
comment|// sin (-ra) = B/sqrt(A^2+B^2+C^2)
comment|// (3) Rotate clockwise in x-z:
comment|// ha = pi/2 - asin(C/sqrt(A^2+B^2+C^2))
comment|// x3 = x2 cos ha - z2 sin ha
comment|// y3 = y2
comment|// z3 = x2 sin ha + z2 cos ha
comment|// At this point, z3 should be zero.
comment|// Faster:
comment|// sin(ha) = cos(asin(C/sqrt(A^2+B^2+C^2))) = sqrt(1 - C^2/(A^2+B^2+C^2)) = sqrt(A^2+B^2)/sqrt(A^2+B^2+C^2)
comment|// cos(ha) = sin(asin(C/sqrt(A^2+B^2+C^2))) = C/sqrt(A^2+B^2+C^2)
comment|// (4) Compute interpolations by getting longitudes of original points
comment|// la = atan2(y3,x3)
comment|// (5) Rotate new points (xN0, yN0, zN0) counter-clockwise in x-z:
comment|// ha = -(pi - asin(C/sqrt(A^2+B^2+C^2)))
comment|// xN1 = xN0 cos ha - zN0 sin ha
comment|// yN1 = yN0
comment|// zN1 = xN0 sin ha + zN0 cos ha
comment|// (6) Rotate new points clockwise in x-y:
comment|// ra = atan2(B,A)
comment|// xN2 = xN1 cos ra - yN1 sin ra
comment|// yN2 = xN1 sin ra + yN1 cos ra
comment|// zN2 = zN1
comment|// (7) Translate new points:
comment|// xN3 = xN2 - D*A
comment|// yN3 = yN2 - D*B
comment|// zN3 = zN2 - D*C
comment|// First, calculate the angles and their sin/cos values
name|double
name|A
init|=
name|x
decl_stmt|;
name|double
name|B
init|=
name|y
decl_stmt|;
name|double
name|C
init|=
name|z
decl_stmt|;
comment|// Translation amounts
specifier|final
name|double
name|transX
init|=
operator|-
name|D
operator|*
name|A
decl_stmt|;
specifier|final
name|double
name|transY
init|=
operator|-
name|D
operator|*
name|B
decl_stmt|;
specifier|final
name|double
name|transZ
init|=
operator|-
name|D
operator|*
name|C
decl_stmt|;
name|double
name|cosRA
decl_stmt|;
name|double
name|sinRA
decl_stmt|;
name|double
name|cosHA
decl_stmt|;
name|double
name|sinHA
decl_stmt|;
name|double
name|magnitude
init|=
name|magnitude
argument_list|()
decl_stmt|;
if|if
condition|(
name|magnitude
operator|>=
name|MINIMUM_RESOLUTION
condition|)
block|{
specifier|final
name|double
name|denom
init|=
literal|1.0
operator|/
name|magnitude
decl_stmt|;
name|A
operator|*=
name|denom
expr_stmt|;
name|B
operator|*=
name|denom
expr_stmt|;
name|C
operator|*=
name|denom
expr_stmt|;
comment|// cos ra = A/sqrt(A^2+B^2+C^2)
comment|// sin ra = -B/sqrt(A^2+B^2+C^2)
comment|// cos (-ra) = A/sqrt(A^2+B^2+C^2)
comment|// sin (-ra) = B/sqrt(A^2+B^2+C^2)
specifier|final
name|double
name|xyMagnitude
init|=
name|Math
operator|.
name|sqrt
argument_list|(
name|A
operator|*
name|A
operator|+
name|B
operator|*
name|B
argument_list|)
decl_stmt|;
if|if
condition|(
name|xyMagnitude
operator|>=
name|MINIMUM_RESOLUTION
condition|)
block|{
specifier|final
name|double
name|xyDenom
init|=
literal|1.0
operator|/
name|xyMagnitude
decl_stmt|;
name|cosRA
operator|=
name|A
operator|*
name|xyDenom
expr_stmt|;
name|sinRA
operator|=
operator|-
name|B
operator|*
name|xyDenom
expr_stmt|;
block|}
else|else
block|{
name|cosRA
operator|=
literal|1.0
expr_stmt|;
name|sinRA
operator|=
literal|0.0
expr_stmt|;
block|}
comment|// sin(ha) = cos(asin(C/sqrt(A^2+B^2+C^2))) = sqrt(1 - C^2/(A^2+B^2+C^2)) = sqrt(A^2+B^2)/sqrt(A^2+B^2+C^2)
comment|// cos(ha) = sin(asin(C/sqrt(A^2+B^2+C^2))) = C/sqrt(A^2+B^2+C^2)
name|sinHA
operator|=
name|xyMagnitude
expr_stmt|;
name|cosHA
operator|=
name|C
expr_stmt|;
block|}
else|else
block|{
name|cosRA
operator|=
literal|1.0
expr_stmt|;
name|sinRA
operator|=
literal|0.0
expr_stmt|;
name|cosHA
operator|=
literal|1.0
expr_stmt|;
name|sinHA
operator|=
literal|0.0
expr_stmt|;
block|}
comment|// Forward-translate the start and end points
specifier|final
name|Vector
name|modifiedStart
init|=
name|modify
argument_list|(
name|start
argument_list|,
name|transX
argument_list|,
name|transY
argument_list|,
name|transZ
argument_list|,
name|sinRA
argument_list|,
name|cosRA
argument_list|,
name|sinHA
argument_list|,
name|cosHA
argument_list|)
decl_stmt|;
specifier|final
name|Vector
name|modifiedEnd
init|=
name|modify
argument_list|(
name|end
argument_list|,
name|transX
argument_list|,
name|transY
argument_list|,
name|transZ
argument_list|,
name|sinRA
argument_list|,
name|cosRA
argument_list|,
name|sinHA
argument_list|,
name|cosHA
argument_list|)
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|modifiedStart
operator|.
name|z
argument_list|)
operator|>=
name|MINIMUM_RESOLUTION
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Start point was not on plane: "
operator|+
name|modifiedStart
operator|.
name|z
argument_list|)
throw|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|modifiedEnd
operator|.
name|z
argument_list|)
operator|>=
name|MINIMUM_RESOLUTION
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"End point was not on plane: "
operator|+
name|modifiedEnd
operator|.
name|z
argument_list|)
throw|;
comment|// Compute the angular distance between start and end point
specifier|final
name|double
name|startAngle
init|=
name|Math
operator|.
name|atan2
argument_list|(
name|modifiedStart
operator|.
name|y
argument_list|,
name|modifiedStart
operator|.
name|x
argument_list|)
decl_stmt|;
specifier|final
name|double
name|endAngle
init|=
name|Math
operator|.
name|atan2
argument_list|(
name|modifiedEnd
operator|.
name|y
argument_list|,
name|modifiedEnd
operator|.
name|x
argument_list|)
decl_stmt|;
specifier|final
name|double
name|startMagnitude
init|=
name|Math
operator|.
name|sqrt
argument_list|(
name|modifiedStart
operator|.
name|x
operator|*
name|modifiedStart
operator|.
name|x
operator|+
name|modifiedStart
operator|.
name|y
operator|*
name|modifiedStart
operator|.
name|y
argument_list|)
decl_stmt|;
name|double
name|delta
decl_stmt|;
name|double
name|beginAngle
decl_stmt|;
name|double
name|newEndAngle
init|=
name|endAngle
decl_stmt|;
while|while
condition|(
name|newEndAngle
operator|<
name|startAngle
condition|)
block|{
name|newEndAngle
operator|+=
name|Math
operator|.
name|PI
operator|*
literal|2.0
expr_stmt|;
block|}
if|if
condition|(
name|newEndAngle
operator|-
name|startAngle
operator|<=
name|Math
operator|.
name|PI
condition|)
block|{
name|delta
operator|=
name|newEndAngle
operator|-
name|startAngle
expr_stmt|;
name|beginAngle
operator|=
name|startAngle
expr_stmt|;
block|}
else|else
block|{
name|double
name|newStartAngle
init|=
name|startAngle
decl_stmt|;
while|while
condition|(
name|newStartAngle
operator|<
name|endAngle
condition|)
block|{
name|newStartAngle
operator|+=
name|Math
operator|.
name|PI
operator|*
literal|2.0
expr_stmt|;
block|}
name|delta
operator|=
name|newStartAngle
operator|-
name|endAngle
expr_stmt|;
name|beginAngle
operator|=
name|endAngle
expr_stmt|;
block|}
specifier|final
name|GeoPoint
index|[]
name|returnValues
init|=
operator|new
name|GeoPoint
index|[
name|proportions
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|returnValues
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|double
name|newAngle
init|=
name|startAngle
operator|+
name|proportions
index|[
name|i
index|]
operator|*
name|delta
decl_stmt|;
specifier|final
name|double
name|sinNewAngle
init|=
name|Math
operator|.
name|sin
argument_list|(
name|newAngle
argument_list|)
decl_stmt|;
specifier|final
name|double
name|cosNewAngle
init|=
name|Math
operator|.
name|cos
argument_list|(
name|newAngle
argument_list|)
decl_stmt|;
specifier|final
name|Vector
name|newVector
init|=
operator|new
name|Vector
argument_list|(
name|cosNewAngle
operator|*
name|startMagnitude
argument_list|,
name|sinNewAngle
operator|*
name|startMagnitude
argument_list|,
literal|0.0
argument_list|)
decl_stmt|;
name|returnValues
index|[
name|i
index|]
operator|=
name|reverseModify
argument_list|(
name|newVector
argument_list|,
name|transX
argument_list|,
name|transY
argument_list|,
name|transZ
argument_list|,
name|sinRA
argument_list|,
name|cosRA
argument_list|,
name|sinHA
argument_list|,
name|cosHA
argument_list|)
expr_stmt|;
block|}
return|return
name|returnValues
return|;
block|}
comment|/**    * Modify a point to produce a vector in translated/rotated space.    */
DECL|method|modify
specifier|protected
specifier|static
name|Vector
name|modify
parameter_list|(
specifier|final
name|GeoPoint
name|start
parameter_list|,
specifier|final
name|double
name|transX
parameter_list|,
specifier|final
name|double
name|transY
parameter_list|,
specifier|final
name|double
name|transZ
parameter_list|,
specifier|final
name|double
name|sinRA
parameter_list|,
specifier|final
name|double
name|cosRA
parameter_list|,
specifier|final
name|double
name|sinHA
parameter_list|,
specifier|final
name|double
name|cosHA
parameter_list|)
block|{
return|return
name|start
operator|.
name|translate
argument_list|(
name|transX
argument_list|,
name|transY
argument_list|,
name|transZ
argument_list|)
operator|.
name|rotateXY
argument_list|(
name|sinRA
argument_list|,
name|cosRA
argument_list|)
operator|.
name|rotateXZ
argument_list|(
name|sinHA
argument_list|,
name|cosHA
argument_list|)
return|;
block|}
comment|/**    * Reverse modify a point to produce a GeoPoint in normal space.    */
DECL|method|reverseModify
specifier|protected
specifier|static
name|GeoPoint
name|reverseModify
parameter_list|(
specifier|final
name|Vector
name|point
parameter_list|,
specifier|final
name|double
name|transX
parameter_list|,
specifier|final
name|double
name|transY
parameter_list|,
specifier|final
name|double
name|transZ
parameter_list|,
specifier|final
name|double
name|sinRA
parameter_list|,
specifier|final
name|double
name|cosRA
parameter_list|,
specifier|final
name|double
name|sinHA
parameter_list|,
specifier|final
name|double
name|cosHA
parameter_list|)
block|{
specifier|final
name|Vector
name|result
init|=
name|point
operator|.
name|rotateXZ
argument_list|(
operator|-
name|sinHA
argument_list|,
name|cosHA
argument_list|)
operator|.
name|rotateXY
argument_list|(
operator|-
name|sinRA
argument_list|,
name|cosRA
argument_list|)
operator|.
name|translate
argument_list|(
operator|-
name|transX
argument_list|,
operator|-
name|transY
argument_list|,
operator|-
name|transZ
argument_list|)
decl_stmt|;
return|return
operator|new
name|GeoPoint
argument_list|(
name|result
operator|.
name|x
argument_list|,
name|result
operator|.
name|y
argument_list|,
name|result
operator|.
name|z
argument_list|)
return|;
block|}
comment|/**    * Public version of findIntersections.    */
DECL|method|findIntersections
specifier|public
name|GeoPoint
index|[]
name|findIntersections
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|Plane
name|q
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
if|if
condition|(
name|isNumericallyIdentical
argument_list|(
name|q
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|q
argument_list|,
name|bounds
argument_list|,
name|NO_BOUNDS
argument_list|)
return|;
block|}
comment|/**    * Find the intersection points between two planes, given a set of bounds.    *    * @param planetModel is the planet model to use in finding points.    * @param q          is the plane to intersect with.    * @param bounds     is the set of bounds.    * @param moreBounds is another set of bounds.    * @return the intersection point(s) on the unit sphere, if there are any.    */
DECL|method|findIntersections
specifier|protected
name|GeoPoint
index|[]
name|findIntersections
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|Plane
name|q
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|,
specifier|final
name|Membership
index|[]
name|moreBounds
parameter_list|)
block|{
comment|//System.err.println("Looking for intersection between plane "+this+" and plane "+q+" within bounds");
comment|// Unnormalized, unchecked...
specifier|final
name|Vector
name|lineVector
init|=
operator|new
name|Vector
argument_list|(
name|y
operator|*
name|q
operator|.
name|z
operator|-
name|z
operator|*
name|q
operator|.
name|y
argument_list|,
name|z
operator|*
name|q
operator|.
name|x
operator|-
name|x
operator|*
name|q
operator|.
name|z
argument_list|,
name|x
operator|*
name|q
operator|.
name|y
operator|-
name|y
operator|*
name|q
operator|.
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|lineVector
operator|.
name|x
argument_list|)
operator|<
name|MINIMUM_RESOLUTION
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|lineVector
operator|.
name|y
argument_list|)
operator|<
name|MINIMUM_RESOLUTION
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|lineVector
operator|.
name|z
argument_list|)
operator|<
name|MINIMUM_RESOLUTION
condition|)
block|{
comment|// Degenerate case: parallel planes
comment|//System.err.println(" planes are parallel - no intersection");
return|return
name|NO_POINTS
return|;
block|}
comment|// The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.
comment|// We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.
comment|// To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations
comment|// simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:
comment|// 0.7 x + 0.3 y + 0.1 z + 0.0 = 0
comment|// and
comment|// 0.9 x - 0.1 y + 0.2 z + 4.0 = 0
comment|// Then we'd pick z = 0, so the equations to solve for x and y would be:
comment|// 0.7 x + 0.3y = 0.0
comment|// 0.9 x - 0.1y = -4.0
comment|// ... which can readily be solved using standard linear algebra.  Generally:
comment|// Q0 x + R0 y = S0
comment|// Q1 x + R1 y = S1
comment|// ... can be solved by Cramer's rule:
comment|// x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)
comment|// y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)
comment|// ... where det( a b / c d ) = ad - bc, so:
comment|// x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)
comment|// y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)
name|double
name|x0
decl_stmt|;
name|double
name|y0
decl_stmt|;
name|double
name|z0
decl_stmt|;
comment|// We try to maximize the determinant in the denominator
specifier|final
name|double
name|denomYZ
init|=
name|this
operator|.
name|y
operator|*
name|q
operator|.
name|z
operator|-
name|this
operator|.
name|z
operator|*
name|q
operator|.
name|y
decl_stmt|;
specifier|final
name|double
name|denomXZ
init|=
name|this
operator|.
name|x
operator|*
name|q
operator|.
name|z
operator|-
name|this
operator|.
name|z
operator|*
name|q
operator|.
name|x
decl_stmt|;
specifier|final
name|double
name|denomXY
init|=
name|this
operator|.
name|x
operator|*
name|q
operator|.
name|y
operator|-
name|this
operator|.
name|y
operator|*
name|q
operator|.
name|x
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|denomYZ
argument_list|)
operator|>=
name|Math
operator|.
name|abs
argument_list|(
name|denomXZ
argument_list|)
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|denomYZ
argument_list|)
operator|>=
name|Math
operator|.
name|abs
argument_list|(
name|denomXY
argument_list|)
condition|)
block|{
comment|// X is the biggest, so our point will have x0 = 0.0
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|denomYZ
argument_list|)
operator|<
name|MINIMUM_RESOLUTION_SQUARED
condition|)
block|{
comment|//System.err.println(" Denominator is zero: no intersection");
return|return
name|NO_POINTS
return|;
block|}
specifier|final
name|double
name|denom
init|=
literal|1.0
operator|/
name|denomYZ
decl_stmt|;
name|x0
operator|=
literal|0.0
expr_stmt|;
name|y0
operator|=
operator|(
operator|-
name|this
operator|.
name|D
operator|*
name|q
operator|.
name|z
operator|-
name|this
operator|.
name|z
operator|*
operator|-
name|q
operator|.
name|D
operator|)
operator|*
name|denom
expr_stmt|;
name|z0
operator|=
operator|(
name|this
operator|.
name|y
operator|*
operator|-
name|q
operator|.
name|D
operator|+
name|this
operator|.
name|D
operator|*
name|q
operator|.
name|y
operator|)
operator|*
name|denom
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|denomXZ
argument_list|)
operator|>=
name|Math
operator|.
name|abs
argument_list|(
name|denomXY
argument_list|)
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|denomXZ
argument_list|)
operator|>=
name|Math
operator|.
name|abs
argument_list|(
name|denomYZ
argument_list|)
condition|)
block|{
comment|// Y is the biggest, so y0 = 0.0
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|denomXZ
argument_list|)
operator|<
name|MINIMUM_RESOLUTION_SQUARED
condition|)
block|{
comment|//System.err.println(" Denominator is zero: no intersection");
return|return
name|NO_POINTS
return|;
block|}
specifier|final
name|double
name|denom
init|=
literal|1.0
operator|/
name|denomXZ
decl_stmt|;
name|x0
operator|=
operator|(
operator|-
name|this
operator|.
name|D
operator|*
name|q
operator|.
name|z
operator|-
name|this
operator|.
name|z
operator|*
operator|-
name|q
operator|.
name|D
operator|)
operator|*
name|denom
expr_stmt|;
name|y0
operator|=
literal|0.0
expr_stmt|;
name|z0
operator|=
operator|(
name|this
operator|.
name|x
operator|*
operator|-
name|q
operator|.
name|D
operator|+
name|this
operator|.
name|D
operator|*
name|q
operator|.
name|x
operator|)
operator|*
name|denom
expr_stmt|;
block|}
else|else
block|{
comment|// Z is the biggest, so Z0 = 0.0
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|denomXY
argument_list|)
operator|<
name|MINIMUM_RESOLUTION_SQUARED
condition|)
block|{
comment|//System.err.println(" Denominator is zero: no intersection");
return|return
name|NO_POINTS
return|;
block|}
specifier|final
name|double
name|denom
init|=
literal|1.0
operator|/
name|denomXY
decl_stmt|;
name|x0
operator|=
operator|(
operator|-
name|this
operator|.
name|D
operator|*
name|q
operator|.
name|y
operator|-
name|this
operator|.
name|y
operator|*
operator|-
name|q
operator|.
name|D
operator|)
operator|*
name|denom
expr_stmt|;
name|y0
operator|=
operator|(
name|this
operator|.
name|x
operator|*
operator|-
name|q
operator|.
name|D
operator|+
name|this
operator|.
name|D
operator|*
name|q
operator|.
name|x
operator|)
operator|*
name|denom
expr_stmt|;
name|z0
operator|=
literal|0.0
expr_stmt|;
block|}
comment|// Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which
comment|// will yield zero, one, or two points.
comment|// The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2
comment|// 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2
comment|// A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0
comment|// [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0
comment|// Use the quadratic formula to determine t values and candidate point(s)
specifier|final
name|double
name|A
init|=
name|lineVector
operator|.
name|x
operator|*
name|lineVector
operator|.
name|x
operator|*
name|planetModel
operator|.
name|inverseAbSquared
operator|+
name|lineVector
operator|.
name|y
operator|*
name|lineVector
operator|.
name|y
operator|*
name|planetModel
operator|.
name|inverseAbSquared
operator|+
name|lineVector
operator|.
name|z
operator|*
name|lineVector
operator|.
name|z
operator|*
name|planetModel
operator|.
name|inverseCSquared
decl_stmt|;
specifier|final
name|double
name|B
init|=
literal|2.0
operator|*
operator|(
name|lineVector
operator|.
name|x
operator|*
name|x0
operator|*
name|planetModel
operator|.
name|inverseAbSquared
operator|+
name|lineVector
operator|.
name|y
operator|*
name|y0
operator|*
name|planetModel
operator|.
name|inverseAbSquared
operator|+
name|lineVector
operator|.
name|z
operator|*
name|z0
operator|*
name|planetModel
operator|.
name|inverseCSquared
operator|)
decl_stmt|;
specifier|final
name|double
name|C
init|=
name|x0
operator|*
name|x0
operator|*
name|planetModel
operator|.
name|inverseAbSquared
operator|+
name|y0
operator|*
name|y0
operator|*
name|planetModel
operator|.
name|inverseAbSquared
operator|+
name|z0
operator|*
name|z0
operator|*
name|planetModel
operator|.
name|inverseCSquared
operator|-
literal|1.0
decl_stmt|;
specifier|final
name|double
name|BsquaredMinus
init|=
name|B
operator|*
name|B
operator|-
literal|4.0
operator|*
name|A
operator|*
name|C
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|BsquaredMinus
argument_list|)
operator|<
name|MINIMUM_RESOLUTION_SQUARED
condition|)
block|{
comment|//System.err.println(" One point of intersection");
specifier|final
name|double
name|inverse2A
init|=
literal|1.0
operator|/
operator|(
literal|2.0
operator|*
name|A
operator|)
decl_stmt|;
comment|// One solution only
specifier|final
name|double
name|t
init|=
operator|-
name|B
operator|*
name|inverse2A
decl_stmt|;
name|GeoPoint
name|point
init|=
operator|new
name|GeoPoint
argument_list|(
name|lineVector
operator|.
name|x
operator|*
name|t
operator|+
name|x0
argument_list|,
name|lineVector
operator|.
name|y
operator|*
name|t
operator|+
name|y0
argument_list|,
name|lineVector
operator|.
name|z
operator|*
name|t
operator|+
name|z0
argument_list|)
decl_stmt|;
comment|//System.err.println("  point: "+point);
comment|//verifyPoint(planetModel, point, q);
if|if
condition|(
name|point
operator|.
name|isWithin
argument_list|(
name|bounds
argument_list|,
name|moreBounds
argument_list|)
condition|)
return|return
operator|new
name|GeoPoint
index|[]
block|{
name|point
block|}
return|;
return|return
name|NO_POINTS
return|;
block|}
elseif|else
if|if
condition|(
name|BsquaredMinus
operator|>
literal|0.0
condition|)
block|{
comment|//System.err.println(" Two points of intersection");
specifier|final
name|double
name|inverse2A
init|=
literal|1.0
operator|/
operator|(
literal|2.0
operator|*
name|A
operator|)
decl_stmt|;
comment|// Two solutions
specifier|final
name|double
name|sqrtTerm
init|=
name|Math
operator|.
name|sqrt
argument_list|(
name|BsquaredMinus
argument_list|)
decl_stmt|;
specifier|final
name|double
name|t1
init|=
operator|(
operator|-
name|B
operator|+
name|sqrtTerm
operator|)
operator|*
name|inverse2A
decl_stmt|;
specifier|final
name|double
name|t2
init|=
operator|(
operator|-
name|B
operator|-
name|sqrtTerm
operator|)
operator|*
name|inverse2A
decl_stmt|;
name|GeoPoint
name|point1
init|=
operator|new
name|GeoPoint
argument_list|(
name|lineVector
operator|.
name|x
operator|*
name|t1
operator|+
name|x0
argument_list|,
name|lineVector
operator|.
name|y
operator|*
name|t1
operator|+
name|y0
argument_list|,
name|lineVector
operator|.
name|z
operator|*
name|t1
operator|+
name|z0
argument_list|)
decl_stmt|;
name|GeoPoint
name|point2
init|=
operator|new
name|GeoPoint
argument_list|(
name|lineVector
operator|.
name|x
operator|*
name|t2
operator|+
name|x0
argument_list|,
name|lineVector
operator|.
name|y
operator|*
name|t2
operator|+
name|y0
argument_list|,
name|lineVector
operator|.
name|z
operator|*
name|t2
operator|+
name|z0
argument_list|)
decl_stmt|;
comment|//verifyPoint(planetModel, point1, q);
comment|//verifyPoint(planetModel, point2, q);
comment|//System.err.println("  "+point1+" and "+point2);
if|if
condition|(
name|point1
operator|.
name|isWithin
argument_list|(
name|bounds
argument_list|,
name|moreBounds
argument_list|)
condition|)
block|{
if|if
condition|(
name|point2
operator|.
name|isWithin
argument_list|(
name|bounds
argument_list|,
name|moreBounds
argument_list|)
condition|)
return|return
operator|new
name|GeoPoint
index|[]
block|{
name|point1
block|,
name|point2
block|}
return|;
return|return
operator|new
name|GeoPoint
index|[]
block|{
name|point1
block|}
return|;
block|}
if|if
condition|(
name|point2
operator|.
name|isWithin
argument_list|(
name|bounds
argument_list|,
name|moreBounds
argument_list|)
condition|)
return|return
operator|new
name|GeoPoint
index|[]
block|{
name|point2
block|}
return|;
return|return
name|NO_POINTS
return|;
block|}
else|else
block|{
comment|//System.err.println(" no solutions - no intersection");
return|return
name|NO_POINTS
return|;
block|}
block|}
comment|/*   protected void verifyPoint(final PlanetModel planetModel, final GeoPoint point, final Plane q) {     if (!evaluateIsZero(point))       throw new RuntimeException("Intersection point not on original plane; point="+point+", plane="+this);     if (!q.evaluateIsZero(point))       throw new RuntimeException("Intersection point not on intersected plane; point="+point+", plane="+q);     if (Math.abs(point.x * point.x * planetModel.inverseASquared + point.y * point.y * planetModel.inverseBSquared + point.z * point.z * planetModel.inverseCSquared - 1.0)>= MINIMUM_RESOLUTION)        throw new RuntimeException("Intersection point not on ellipsoid; point="+point);   }   */
comment|/**    * Accumulate bounds information for this plane, intersected with another plane    * and with the unit sphere.    * Updates both latitude and longitude information, using max/min points found    * within the specified bounds.    *    * @param planetModel is the planet model to use to determine bounding points    * @param q          is the plane to intersect with.    * @param boundsInfo is the info to update with additional bounding information.    * @param bounds     are the surfaces delineating what's inside the shape.    */
DECL|method|recordBounds
specifier|public
name|void
name|recordBounds
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|Plane
name|q
parameter_list|,
specifier|final
name|Bounds
name|boundsInfo
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
specifier|final
name|GeoPoint
index|[]
name|intersectionPoints
init|=
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|q
argument_list|,
name|bounds
argument_list|,
name|NO_BOUNDS
argument_list|)
decl_stmt|;
for|for
control|(
name|GeoPoint
name|intersectionPoint
range|:
name|intersectionPoints
control|)
block|{
name|boundsInfo
operator|.
name|addPoint
argument_list|(
name|intersectionPoint
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Accumulate bounds information for this plane, intersected with the unit sphere.    * Updates both latitude and longitude information, using max/min points found    * within the specified bounds.    *    * @param planetModel is the planet model to use in determining bounds.    * @param boundsInfo is the info to update with additional bounding information.    * @param bounds     are the surfaces delineating what's inside the shape.    */
DECL|method|recordBounds
specifier|public
name|void
name|recordBounds
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|Bounds
name|boundsInfo
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
comment|// For clarity, load local variables with good names
specifier|final
name|double
name|A
init|=
name|this
operator|.
name|x
decl_stmt|;
specifier|final
name|double
name|B
init|=
name|this
operator|.
name|y
decl_stmt|;
specifier|final
name|double
name|C
init|=
name|this
operator|.
name|z
decl_stmt|;
comment|// Now compute latitude min/max points
if|if
condition|(
operator|!
name|boundsInfo
operator|.
name|checkNoTopLatitudeBound
argument_list|()
operator|||
operator|!
name|boundsInfo
operator|.
name|checkNoBottomLatitudeBound
argument_list|()
condition|)
block|{
comment|//System.err.println("Looking at latitude for plane "+this);
comment|// With ellipsoids, we really have only one viable way to do this computation.
comment|// Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and
comment|// then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use
comment|// as bounds.
comment|// There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for
comment|// the y, and we use all four resulting points in the bounds computation.
if|if
condition|(
operator|(
name|Math
operator|.
name|abs
argument_list|(
name|A
argument_list|)
operator|>=
name|MINIMUM_RESOLUTION
operator|||
name|Math
operator|.
name|abs
argument_list|(
name|B
argument_list|)
operator|>=
name|MINIMUM_RESOLUTION
operator|)
condition|)
block|{
comment|// NOT a horizontal circle!
comment|//System.err.println(" Not a horizontal circle");
specifier|final
name|Plane
name|verticalPlane
init|=
name|constructNormalizedVerticalPlane
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|points
init|=
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|verticalPlane
argument_list|,
name|NO_BOUNDS
argument_list|,
name|NO_BOUNDS
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|GeoPoint
name|point
range|:
name|points
control|)
block|{
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|point
operator|.
name|x
argument_list|,
name|point
operator|.
name|y
argument_list|,
name|point
operator|.
name|z
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Horizontal circle.  Since a==b, one vertical plane suffices.
specifier|final
name|Plane
name|verticalPlane
init|=
operator|new
name|Plane
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|points
init|=
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|verticalPlane
argument_list|,
name|NO_BOUNDS
argument_list|,
name|NO_BOUNDS
argument_list|)
decl_stmt|;
comment|// There will always be two points; we only need one.
specifier|final
name|GeoPoint
name|point
init|=
name|points
index|[
literal|0
index|]
decl_stmt|;
name|boundsInfo
operator|.
name|addHorizontalCircle
argument_list|(
name|point
operator|.
name|z
operator|/
name|Math
operator|.
name|sqrt
argument_list|(
name|point
operator|.
name|x
operator|*
name|point
operator|.
name|x
operator|+
name|point
operator|.
name|y
operator|*
name|point
operator|.
name|y
operator|+
name|point
operator|.
name|z
operator|*
name|point
operator|.
name|z
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//System.err.println("Done latitude bounds");
block|}
comment|// First, figure out our longitude bounds, unless we no longer need to consider that
if|if
condition|(
operator|!
name|boundsInfo
operator|.
name|checkNoLongitudeBound
argument_list|()
condition|)
block|{
comment|//System.err.println("Computing longitude bounds for "+this);
comment|//System.out.println("A = "+A+" B = "+B+" C = "+C+" D = "+D);
comment|// Compute longitude bounds
name|double
name|a
decl_stmt|;
name|double
name|b
decl_stmt|;
name|double
name|c
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|C
argument_list|)
operator|<
name|MINIMUM_RESOLUTION
condition|)
block|{
comment|// Degenerate; the equation describes a line
comment|//System.out.println("It's a zero-width ellipse");
comment|// Ax + By + D = 0
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|D
argument_list|)
operator|>=
name|MINIMUM_RESOLUTION
condition|)
block|{
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|A
argument_list|)
operator|>
name|Math
operator|.
name|abs
argument_list|(
name|B
argument_list|)
condition|)
block|{
comment|// Use equation suitable for A != 0
comment|// We need to find the endpoints of the zero-width ellipse.
comment|// Geometrically, we have a line segment in x-y space.  We need to locate the endpoints
comment|// of that line.  But luckily, we know some things: specifically, since it is a
comment|// degenerate situation in projection, the C value had to have been 0.  That
comment|// means that our line's endpoints will coincide with the projected ellipse.  All we
comment|// need to do then is to find the intersection of the projected ellipse and the line
comment|// equation:
comment|//
comment|// A x + B y + D = 0
comment|//
comment|// Since A != 0:
comment|// x = (-By - D)/A
comment|//
comment|// The projected ellipse:
comment|// x^2/a^2 + y^2/b^2 - 1 = 0
comment|// Substitute:
comment|// [(-By-D)/A]^2/a^2 + y^2/b^2 -1 = 0
comment|// Multiply through by A^2:
comment|// [-By - D]^2/a^2 + A^2*y^2/b^2 - A^2 = 0
comment|// Multiply out:
comment|// B^2*y^2/a^2 + 2BDy/a^2 + D^2/a^2 + A^2*y^2/b^2 - A^2 = 0
comment|// Group:
comment|// y^2 * [B^2/a^2 + A^2/b^2] + y [2BD/a^2] + [D^2/a^2-A^2] = 0
name|a
operator|=
name|B
operator|*
name|B
operator|*
name|planetModel
operator|.
name|inverseAbSquared
operator|+
name|A
operator|*
name|A
operator|*
name|planetModel
operator|.
name|inverseAbSquared
expr_stmt|;
name|b
operator|=
literal|2.0
operator|*
name|B
operator|*
name|D
operator|*
name|planetModel
operator|.
name|inverseAbSquared
expr_stmt|;
name|c
operator|=
name|D
operator|*
name|D
operator|*
name|planetModel
operator|.
name|inverseAbSquared
operator|-
name|A
operator|*
name|A
expr_stmt|;
name|double
name|sqrtClause
init|=
name|b
operator|*
name|b
operator|-
literal|4.0
operator|*
name|a
operator|*
name|c
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|sqrtClause
argument_list|)
operator|<
name|MINIMUM_RESOLUTION_SQUARED
condition|)
block|{
name|double
name|y0
init|=
operator|-
name|b
operator|/
operator|(
literal|2.0
operator|*
name|a
operator|)
decl_stmt|;
name|double
name|x0
init|=
operator|(
operator|-
name|D
operator|-
name|B
operator|*
name|y0
operator|)
operator|/
name|A
decl_stmt|;
name|double
name|z0
init|=
literal|0.0
decl_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|z0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sqrtClause
operator|>
literal|0.0
condition|)
block|{
name|double
name|sqrtResult
init|=
name|Math
operator|.
name|sqrt
argument_list|(
name|sqrtClause
argument_list|)
decl_stmt|;
name|double
name|denom
init|=
literal|1.0
operator|/
operator|(
literal|2.0
operator|*
name|a
operator|)
decl_stmt|;
name|double
name|Hdenom
init|=
literal|1.0
operator|/
name|A
decl_stmt|;
name|double
name|y0a
init|=
operator|(
operator|-
name|b
operator|+
name|sqrtResult
operator|)
operator|*
name|denom
decl_stmt|;
name|double
name|y0b
init|=
operator|(
operator|-
name|b
operator|-
name|sqrtResult
operator|)
operator|*
name|denom
decl_stmt|;
name|double
name|x0a
init|=
operator|(
operator|-
name|D
operator|-
name|B
operator|*
name|y0a
operator|)
operator|*
name|Hdenom
decl_stmt|;
name|double
name|x0b
init|=
operator|(
operator|-
name|D
operator|-
name|B
operator|*
name|y0b
operator|)
operator|*
name|Hdenom
decl_stmt|;
name|double
name|z0a
init|=
literal|0.0
decl_stmt|;
name|double
name|z0b
init|=
literal|0.0
decl_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0a
argument_list|,
name|y0a
argument_list|,
name|z0a
argument_list|)
expr_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0b
argument_list|,
name|y0b
argument_list|,
name|z0b
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Use equation suitable for B != 0
comment|// Since I != 0, we rewrite:
comment|// y = (-Ax - D)/B
name|a
operator|=
name|B
operator|*
name|B
operator|*
name|planetModel
operator|.
name|inverseAbSquared
operator|+
name|A
operator|*
name|A
operator|*
name|planetModel
operator|.
name|inverseAbSquared
expr_stmt|;
name|b
operator|=
literal|2.0
operator|*
name|A
operator|*
name|D
operator|*
name|planetModel
operator|.
name|inverseAbSquared
expr_stmt|;
name|c
operator|=
name|D
operator|*
name|D
operator|*
name|planetModel
operator|.
name|inverseAbSquared
operator|-
name|B
operator|*
name|B
expr_stmt|;
name|double
name|sqrtClause
init|=
name|b
operator|*
name|b
operator|-
literal|4.0
operator|*
name|a
operator|*
name|c
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|sqrtClause
argument_list|)
operator|<
name|MINIMUM_RESOLUTION_SQUARED
condition|)
block|{
name|double
name|x0
init|=
operator|-
name|b
operator|/
operator|(
literal|2.0
operator|*
name|a
operator|)
decl_stmt|;
name|double
name|y0
init|=
operator|(
operator|-
name|D
operator|-
name|A
operator|*
name|x0
operator|)
operator|/
name|B
decl_stmt|;
name|double
name|z0
init|=
literal|0.0
decl_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|z0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sqrtClause
operator|>
literal|0.0
condition|)
block|{
name|double
name|sqrtResult
init|=
name|Math
operator|.
name|sqrt
argument_list|(
name|sqrtClause
argument_list|)
decl_stmt|;
name|double
name|denom
init|=
literal|1.0
operator|/
operator|(
literal|2.0
operator|*
name|a
operator|)
decl_stmt|;
name|double
name|Idenom
init|=
literal|1.0
operator|/
name|B
decl_stmt|;
name|double
name|x0a
init|=
operator|(
operator|-
name|b
operator|+
name|sqrtResult
operator|)
operator|*
name|denom
decl_stmt|;
name|double
name|x0b
init|=
operator|(
operator|-
name|b
operator|-
name|sqrtResult
operator|)
operator|*
name|denom
decl_stmt|;
name|double
name|y0a
init|=
operator|(
operator|-
name|D
operator|-
name|A
operator|*
name|x0a
operator|)
operator|*
name|Idenom
decl_stmt|;
name|double
name|y0b
init|=
operator|(
operator|-
name|D
operator|-
name|A
operator|*
name|x0b
operator|)
operator|*
name|Idenom
decl_stmt|;
name|double
name|z0a
init|=
literal|0.0
decl_stmt|;
name|double
name|z0b
init|=
literal|0.0
decl_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0a
argument_list|,
name|y0a
argument_list|,
name|z0a
argument_list|)
expr_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0b
argument_list|,
name|y0b
argument_list|,
name|z0b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|//System.err.println("General longitude bounds...");
comment|// NOTE WELL: The x,y,z values generated here are NOT on the unit sphere.
comment|// They are for lat/lon calculation purposes only.  x-y is meant to be used for longitude determination,
comment|// and z for latitude, and that's all the values are good for.
comment|// (1) Intersect the plane and the ellipsoid, and project the results into the x-y plane:
comment|// From plane:
comment|// z = (-Ax - By - D) / C
comment|// From ellipsoid:
comment|// x^2/a^2 + y^2/b^2 + [(-Ax - By - D) / C]^2/c^2 = 1
comment|// Simplify/expand:
comment|// C^2*x^2/a^2 + C^2*y^2/b^2 + (-Ax - By - D)^2/c^2 = C^2
comment|//
comment|// x^2 * C^2/a^2 + y^2 * C^2/b^2 + x^2 * A^2/c^2 + ABxy/c^2 + ADx/c^2 + ABxy/c^2 + y^2 * B^2/c^2 + BDy/c^2 + ADx/c^2 + BDy/c^2 + D^2/c^2 = C^2
comment|// Group:
comment|// [A^2/c^2 + C^2/a^2] x^2 + [B^2/c^2 + C^2/b^2] y^2 + [2AB/c^2]xy + [2AD/c^2]x + [2BD/c^2]y + [D^2/c^2-C^2] = 0
comment|// For convenience, introduce post-projection coefficient variables to make life easier.
comment|// E x^2 + F y^2 + G xy + H x + I y + J = 0
name|double
name|E
init|=
name|A
operator|*
name|A
operator|*
name|planetModel
operator|.
name|inverseCSquared
operator|+
name|C
operator|*
name|C
operator|*
name|planetModel
operator|.
name|inverseAbSquared
decl_stmt|;
name|double
name|F
init|=
name|B
operator|*
name|B
operator|*
name|planetModel
operator|.
name|inverseCSquared
operator|+
name|C
operator|*
name|C
operator|*
name|planetModel
operator|.
name|inverseAbSquared
decl_stmt|;
name|double
name|G
init|=
literal|2.0
operator|*
name|A
operator|*
name|B
operator|*
name|planetModel
operator|.
name|inverseCSquared
decl_stmt|;
name|double
name|H
init|=
literal|2.0
operator|*
name|A
operator|*
name|D
operator|*
name|planetModel
operator|.
name|inverseCSquared
decl_stmt|;
name|double
name|I
init|=
literal|2.0
operator|*
name|B
operator|*
name|D
operator|*
name|planetModel
operator|.
name|inverseCSquared
decl_stmt|;
name|double
name|J
init|=
name|D
operator|*
name|D
operator|*
name|planetModel
operator|.
name|inverseCSquared
operator|-
name|C
operator|*
name|C
decl_stmt|;
comment|//System.err.println("E = " + E + " F = " + F + " G = " + G + " H = "+ H + " I = " + I + " J = " + J);
comment|// Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|J
argument_list|)
operator|>=
name|MINIMUM_RESOLUTION
operator|&&
name|J
operator|>
literal|0.0
condition|)
block|{
comment|// The derivative of the curve above is:
comment|// 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0
comment|// (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0
comment|// dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)
comment|//
comment|// The equation of a line going through the origin with the slope dy/dx is:
comment|// y = dy/dx x
comment|// y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x
comment|// Rearrange:
comment|// (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0
comment|// 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0
comment|// 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0
comment|//
comment|// Multiply the original equation by 2:
comment|// 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0
comment|// Subtract one from the other, to remove the high-order terms:
comment|// Hx + Iy + 2J = 0
comment|// Now, we can substitute either x = or y = into the derivative equation, or into the original equation.
comment|// But we will need to base this on which coefficient is non-zero
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|H
argument_list|)
operator|>
name|Math
operator|.
name|abs
argument_list|(
name|I
argument_list|)
condition|)
block|{
comment|//System.err.println(" Using the y quadratic");
comment|// x = (-2J - Iy)/H
comment|// Plug into the original equation:
comment|// E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0
comment|// E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0
comment|// Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.
comment|// Plug into derivative equation:
comment|// 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0
comment|// 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0
comment|// E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0
comment|// Multiply by H^2 to make manipulation easier
comment|// E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0
comment|// Do the square
comment|// E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0
comment|// Multiply it out
comment|// 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0
comment|// Group:
comment|// y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0
name|a
operator|=
name|E
operator|*
name|I
operator|*
name|I
operator|-
name|G
operator|*
name|H
operator|*
name|I
operator|+
name|F
operator|*
name|H
operator|*
name|H
expr_stmt|;
name|b
operator|=
literal|4.0
operator|*
name|E
operator|*
name|I
operator|*
name|J
operator|-
literal|2.0
operator|*
name|G
operator|*
name|H
operator|*
name|J
expr_stmt|;
name|c
operator|=
literal|4.0
operator|*
name|E
operator|*
name|J
operator|*
name|J
operator|-
name|J
operator|*
name|H
operator|*
name|H
expr_stmt|;
comment|//System.out.println("a="+a+" b="+b+" c="+c);
name|double
name|sqrtClause
init|=
name|b
operator|*
name|b
operator|-
literal|4.0
operator|*
name|a
operator|*
name|c
decl_stmt|;
comment|//System.out.println("sqrtClause="+sqrtClause);
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|sqrtClause
argument_list|)
operator|<
name|MINIMUM_RESOLUTION_CUBED
condition|)
block|{
comment|//System.err.println(" One solution");
name|double
name|y0
init|=
operator|-
name|b
operator|/
operator|(
literal|2.0
operator|*
name|a
operator|)
decl_stmt|;
name|double
name|x0
init|=
operator|(
operator|-
literal|2.0
operator|*
name|J
operator|-
name|I
operator|*
name|y0
operator|)
operator|/
name|H
decl_stmt|;
name|double
name|z0
init|=
operator|(
operator|-
name|A
operator|*
name|x0
operator|-
name|B
operator|*
name|y0
operator|-
name|D
operator|)
operator|/
name|C
decl_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|z0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sqrtClause
operator|>
literal|0.0
condition|)
block|{
comment|//System.err.println(" Two solutions");
name|double
name|sqrtResult
init|=
name|Math
operator|.
name|sqrt
argument_list|(
name|sqrtClause
argument_list|)
decl_stmt|;
name|double
name|denom
init|=
literal|1.0
operator|/
operator|(
literal|2.0
operator|*
name|a
operator|)
decl_stmt|;
name|double
name|Hdenom
init|=
literal|1.0
operator|/
name|H
decl_stmt|;
name|double
name|Cdenom
init|=
literal|1.0
operator|/
name|C
decl_stmt|;
name|double
name|y0a
init|=
operator|(
operator|-
name|b
operator|+
name|sqrtResult
operator|)
operator|*
name|denom
decl_stmt|;
name|double
name|y0b
init|=
operator|(
operator|-
name|b
operator|-
name|sqrtResult
operator|)
operator|*
name|denom
decl_stmt|;
name|double
name|x0a
init|=
operator|(
operator|-
literal|2.0
operator|*
name|J
operator|-
name|I
operator|*
name|y0a
operator|)
operator|*
name|Hdenom
decl_stmt|;
name|double
name|x0b
init|=
operator|(
operator|-
literal|2.0
operator|*
name|J
operator|-
name|I
operator|*
name|y0b
operator|)
operator|*
name|Hdenom
decl_stmt|;
name|double
name|z0a
init|=
operator|(
operator|-
name|A
operator|*
name|x0a
operator|-
name|B
operator|*
name|y0a
operator|-
name|D
operator|)
operator|*
name|Cdenom
decl_stmt|;
name|double
name|z0b
init|=
operator|(
operator|-
name|A
operator|*
name|x0b
operator|-
name|B
operator|*
name|y0b
operator|-
name|D
operator|)
operator|*
name|Cdenom
decl_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0a
argument_list|,
name|y0a
argument_list|,
name|z0a
argument_list|)
expr_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0b
argument_list|,
name|y0b
argument_list|,
name|z0b
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//System.err.println(" Using the x quadratic");
comment|// y = (-2J - Hx)/I
comment|// Plug into the original equation:
comment|// E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0
comment|// Multiply by I^2 to make manipulation easier
comment|// E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0
comment|// Do the square
comment|// E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0
comment|// Multiply it out
comment|// E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0
comment|// Group:
comment|// x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0
comment|// E x^2 + F y^2 + G xy + H x + I y + J = 0
name|a
operator|=
name|E
operator|*
name|I
operator|*
name|I
operator|-
name|G
operator|*
name|H
operator|*
name|I
operator|+
name|F
operator|*
name|H
operator|*
name|H
expr_stmt|;
name|b
operator|=
literal|4.0
operator|*
name|F
operator|*
name|H
operator|*
name|J
operator|-
literal|2.0
operator|*
name|G
operator|*
name|I
operator|*
name|J
expr_stmt|;
name|c
operator|=
literal|4.0
operator|*
name|F
operator|*
name|J
operator|*
name|J
operator|-
name|J
operator|*
name|I
operator|*
name|I
expr_stmt|;
comment|//System.out.println("a="+a+" b="+b+" c="+c);
name|double
name|sqrtClause
init|=
name|b
operator|*
name|b
operator|-
literal|4.0
operator|*
name|a
operator|*
name|c
decl_stmt|;
comment|//System.out.println("sqrtClause="+sqrtClause);
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|sqrtClause
argument_list|)
operator|<
name|MINIMUM_RESOLUTION_CUBED
condition|)
block|{
comment|//System.err.println(" One solution; sqrt clause was "+sqrtClause);
name|double
name|x0
init|=
operator|-
name|b
operator|/
operator|(
literal|2.0
operator|*
name|a
operator|)
decl_stmt|;
name|double
name|y0
init|=
operator|(
operator|-
literal|2.0
operator|*
name|J
operator|-
name|H
operator|*
name|x0
operator|)
operator|/
name|I
decl_stmt|;
name|double
name|z0
init|=
operator|(
operator|-
name|A
operator|*
name|x0
operator|-
name|B
operator|*
name|y0
operator|-
name|D
operator|)
operator|/
name|C
decl_stmt|;
comment|// Verify that x&y fulfill the equation
comment|// 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|z0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sqrtClause
operator|>
literal|0.0
condition|)
block|{
comment|//System.err.println(" Two solutions");
name|double
name|sqrtResult
init|=
name|Math
operator|.
name|sqrt
argument_list|(
name|sqrtClause
argument_list|)
decl_stmt|;
name|double
name|denom
init|=
literal|1.0
operator|/
operator|(
literal|2.0
operator|*
name|a
operator|)
decl_stmt|;
name|double
name|Idenom
init|=
literal|1.0
operator|/
name|I
decl_stmt|;
name|double
name|Cdenom
init|=
literal|1.0
operator|/
name|C
decl_stmt|;
name|double
name|x0a
init|=
operator|(
operator|-
name|b
operator|+
name|sqrtResult
operator|)
operator|*
name|denom
decl_stmt|;
name|double
name|x0b
init|=
operator|(
operator|-
name|b
operator|-
name|sqrtResult
operator|)
operator|*
name|denom
decl_stmt|;
name|double
name|y0a
init|=
operator|(
operator|-
literal|2.0
operator|*
name|J
operator|-
name|H
operator|*
name|x0a
operator|)
operator|*
name|Idenom
decl_stmt|;
name|double
name|y0b
init|=
operator|(
operator|-
literal|2.0
operator|*
name|J
operator|-
name|H
operator|*
name|x0b
operator|)
operator|*
name|Idenom
decl_stmt|;
name|double
name|z0a
init|=
operator|(
operator|-
name|A
operator|*
name|x0a
operator|-
name|B
operator|*
name|y0a
operator|-
name|D
operator|)
operator|*
name|Cdenom
decl_stmt|;
name|double
name|z0b
init|=
operator|(
operator|-
name|A
operator|*
name|x0b
operator|-
name|B
operator|*
name|y0b
operator|-
name|D
operator|)
operator|*
name|Cdenom
decl_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0a
argument_list|,
name|y0a
argument_list|,
name|z0a
argument_list|)
expr_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0b
argument_list|,
name|y0b
argument_list|,
name|z0b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
DECL|method|addPoint
specifier|protected
specifier|static
name|void
name|addPoint
parameter_list|(
specifier|final
name|Bounds
name|boundsInfo
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|,
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
comment|//System.err.println(" Want to add point x="+x+" y="+y+" z="+z);
comment|// Make sure the discovered point is within the bounds
for|for
control|(
name|Membership
name|bound
range|:
name|bounds
control|)
block|{
if|if
condition|(
operator|!
name|bound
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
return|return;
block|}
comment|// Add the point
comment|//System.err.println("  point added");
comment|//System.out.println("Adding point x="+x+" y="+y+" z="+z);
name|boundsInfo
operator|.
name|addPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
comment|/**    * Determine whether the plane intersects another plane within the    * bounds provided.    *    * @param planetModel is the planet model to use in determining intersection.    * @param q                 is the other plane.    * @param notablePoints     are points to look at to disambiguate cases when the two planes are identical.    * @param moreNotablePoints are additional points to look at to disambiguate cases when the two planes are identical.    * @param bounds            is one part of the bounds.    * @param moreBounds        are more bounds.    * @return true if there's an intersection.    */
DECL|method|intersects
specifier|public
name|boolean
name|intersects
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|Plane
name|q
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|notablePoints
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|moreNotablePoints
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|,
specifier|final
name|Membership
modifier|...
name|moreBounds
parameter_list|)
block|{
comment|//System.err.println("Does plane "+this+" intersect with plane "+q);
comment|// If the two planes are identical, then the math will find no points of intersection.
comment|// So a special case of this is to check for plane equality.  But that is not enough, because
comment|// what we really need at that point is to determine whether overlap occurs between the two parts of the intersection
comment|// of plane and circle.  That is, are there *any* points on the plane that are within the bounds described?
if|if
condition|(
name|isNumericallyIdentical
argument_list|(
name|q
argument_list|)
condition|)
block|{
comment|//System.err.println(" Identical plane");
comment|// The only way to efficiently figure this out will be to have a list of trial points available to evaluate.
comment|// We look for any point that fulfills all the bounds.
for|for
control|(
name|GeoPoint
name|p
range|:
name|notablePoints
control|)
block|{
if|if
condition|(
name|meetsAllBounds
argument_list|(
name|p
argument_list|,
name|bounds
argument_list|,
name|moreBounds
argument_list|)
condition|)
block|{
comment|//System.err.println("  found a notable point in bounds, so intersects");
return|return
literal|true
return|;
block|}
block|}
for|for
control|(
name|GeoPoint
name|p
range|:
name|moreNotablePoints
control|)
block|{
if|if
condition|(
name|meetsAllBounds
argument_list|(
name|p
argument_list|,
name|bounds
argument_list|,
name|moreBounds
argument_list|)
condition|)
block|{
comment|//System.err.println("  found a notable point in bounds, so intersects");
return|return
literal|true
return|;
block|}
block|}
comment|//System.err.println("  no notable points inside found; no intersection");
return|return
literal|false
return|;
block|}
return|return
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|q
argument_list|,
name|bounds
argument_list|,
name|moreBounds
argument_list|)
operator|.
name|length
operator|>
literal|0
return|;
block|}
comment|/**    * Returns true if this plane and the other plane are identical within the margin of error.    */
DECL|method|isNumericallyIdentical
specifier|protected
name|boolean
name|isNumericallyIdentical
parameter_list|(
specifier|final
name|Plane
name|p
parameter_list|)
block|{
comment|// We can get the correlation by just doing a parallel plane check.  If that passes, then compute a point on the plane
comment|// (using D) and see if it also on the other plane.
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|this
operator|.
name|y
operator|*
name|p
operator|.
name|z
operator|-
name|this
operator|.
name|z
operator|*
name|p
operator|.
name|y
argument_list|)
operator|>=
name|MINIMUM_RESOLUTION
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|this
operator|.
name|z
operator|*
name|p
operator|.
name|x
operator|-
name|this
operator|.
name|x
operator|*
name|p
operator|.
name|z
argument_list|)
operator|>=
name|MINIMUM_RESOLUTION
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|this
operator|.
name|x
operator|*
name|p
operator|.
name|y
operator|-
name|this
operator|.
name|y
operator|*
name|p
operator|.
name|x
argument_list|)
operator|>=
name|MINIMUM_RESOLUTION
condition|)
return|return
literal|false
return|;
comment|// Now, see whether the parallel planes are in fact on top of one another.
comment|// The math:
comment|// We need a single point that fulfills:
comment|// Ax + By + Cz + D = 0
comment|// Pick:
comment|// x0 = -(A * D) / (A^2 + B^2 + C^2)
comment|// y0 = -(B * D) / (A^2 + B^2 + C^2)
comment|// z0 = -(C * D) / (A^2 + B^2 + C^2)
comment|// Check:
comment|// A (x0) + B (y0) + C (z0) + D =? 0
comment|// A (-(A * D) / (A^2 + B^2 + C^2)) + B (-(B * D) / (A^2 + B^2 + C^2)) + C (-(C * D) / (A^2 + B^2 + C^2)) + D ?= 0
comment|// -D [ A^2 / (A^2 + B^2 + C^2) + B^2 / (A^2 + B^2 + C^2) + C^2 / (A^2 + B^2 + C^2)] + D ?= 0
comment|// Yes.
specifier|final
name|double
name|denom
init|=
literal|1.0
operator|/
operator|(
name|p
operator|.
name|x
operator|*
name|p
operator|.
name|x
operator|+
name|p
operator|.
name|y
operator|*
name|p
operator|.
name|y
operator|+
name|p
operator|.
name|z
operator|*
name|p
operator|.
name|z
operator|)
decl_stmt|;
return|return
name|evaluateIsZero
argument_list|(
operator|-
name|p
operator|.
name|x
operator|*
name|p
operator|.
name|D
operator|*
name|denom
argument_list|,
operator|-
name|p
operator|.
name|y
operator|*
name|p
operator|.
name|D
operator|*
name|denom
argument_list|,
operator|-
name|p
operator|.
name|z
operator|*
name|p
operator|.
name|D
operator|*
name|denom
argument_list|)
return|;
block|}
DECL|method|meetsAllBounds
specifier|protected
specifier|static
name|boolean
name|meetsAllBounds
parameter_list|(
specifier|final
name|Vector
name|p
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|)
block|{
return|return
name|meetsAllBounds
argument_list|(
name|p
operator|.
name|x
argument_list|,
name|p
operator|.
name|y
argument_list|,
name|p
operator|.
name|z
argument_list|,
name|bounds
argument_list|)
return|;
block|}
DECL|method|meetsAllBounds
specifier|protected
specifier|static
name|boolean
name|meetsAllBounds
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|)
block|{
for|for
control|(
specifier|final
name|Membership
name|bound
range|:
name|bounds
control|)
block|{
if|if
condition|(
operator|!
name|bound
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|meetsAllBounds
specifier|protected
specifier|static
name|boolean
name|meetsAllBounds
parameter_list|(
specifier|final
name|Vector
name|p
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|,
specifier|final
name|Membership
index|[]
name|moreBounds
parameter_list|)
block|{
return|return
name|meetsAllBounds
argument_list|(
name|p
operator|.
name|x
argument_list|,
name|p
operator|.
name|y
argument_list|,
name|p
operator|.
name|z
argument_list|,
name|bounds
argument_list|,
name|moreBounds
argument_list|)
return|;
block|}
DECL|method|meetsAllBounds
specifier|protected
specifier|static
name|boolean
name|meetsAllBounds
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|,
specifier|final
name|Membership
index|[]
name|moreBounds
parameter_list|)
block|{
return|return
name|meetsAllBounds
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|bounds
argument_list|)
operator|&&
name|meetsAllBounds
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|moreBounds
argument_list|)
return|;
block|}
comment|/**    * Find a sample point on the intersection between two planes and the unit sphere.    */
DECL|method|getSampleIntersectionPoint
specifier|public
name|GeoPoint
name|getSampleIntersectionPoint
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|Plane
name|q
parameter_list|)
block|{
specifier|final
name|GeoPoint
index|[]
name|intersections
init|=
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|q
argument_list|,
name|NO_BOUNDS
argument_list|,
name|NO_BOUNDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|intersections
operator|.
name|length
operator|==
literal|0
condition|)
return|return
literal|null
return|;
return|return
name|intersections
index|[
literal|0
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"[A="
operator|+
name|x
operator|+
literal|", B="
operator|+
name|y
operator|+
literal|"; C="
operator|+
name|z
operator|+
literal|"; D="
operator|+
name|D
operator|+
literal|"]"
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|super
operator|.
name|equals
argument_list|(
name|o
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Plane
operator|)
condition|)
return|return
literal|false
return|;
name|Plane
name|other
init|=
operator|(
name|Plane
operator|)
name|o
decl_stmt|;
return|return
name|other
operator|.
name|D
operator|==
name|D
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|super
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|long
name|temp
decl_stmt|;
name|temp
operator|=
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|D
argument_list|)
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
call|(
name|int
call|)
argument_list|(
name|temp
operator|^
operator|(
name|temp
operator|>>>
literal|32
operator|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_class
end_unit
