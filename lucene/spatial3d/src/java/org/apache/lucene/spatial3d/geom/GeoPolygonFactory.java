begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.spatial3d.geom
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_comment
comment|/**  * Class which constructs a GeoMembershipShape representing an arbitrary polygon.  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|GeoPolygonFactory
specifier|public
class|class
name|GeoPolygonFactory
block|{
DECL|method|GeoPolygonFactory
specifier|private
name|GeoPolygonFactory
parameter_list|()
block|{   }
comment|/** Create a GeoPolygon using the specified points and holes, using order to determine     * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space    * on the same side of the shape as being inside, and counter-clockwise to indicate the    * space on the opposite side as being inside.    * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go    *  clockwise from a given pole, then that pole should be within the polygon.  If points go    *  counter-clockwise, then that pole should be outside the polygon.    * @return a GeoPolygon corresponding to what was specified.    */
DECL|method|makeGeoPolygon
specifier|public
specifier|static
name|GeoPolygon
name|makeGeoPolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointList
parameter_list|)
block|{
return|return
name|makeGeoPolygon
argument_list|(
name|planetModel
argument_list|,
name|pointList
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Create a GeoPolygon using the specified points and holes, using order to determine     * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space    * on the same side of the shape as being inside, and counter-clockwise to indicate the    * space on the opposite side as being inside.    * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go    *  clockwise from a given pole, then that pole should be within the polygon.  If points go    *  counter-clockwise, then that pole should be outside the polygon.    * @param holes is a list of polygons representing "holes" in the outside polygon.  Null == none.    * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated    *  from this input.    */
DECL|method|makeGeoPolygon
specifier|public
specifier|static
name|GeoPolygon
name|makeGeoPolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointList
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPolygon
argument_list|>
name|holes
parameter_list|)
block|{
return|return
name|makeGeoPolygon
argument_list|(
name|planetModel
argument_list|,
name|pointList
argument_list|,
name|holes
argument_list|,
literal|0.0
argument_list|)
return|;
block|}
comment|/** Create a GeoPolygon using the specified points and holes, using order to determine     * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space    * on the same side of the shape as being inside, and counter-clockwise to indicate the    * space on the opposite side as being inside.    * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go    *  clockwise from a given pole, then that pole should be within the polygon.  If points go    *  counter-clockwise, then that pole should be outside the polygon.    * @param holes is a list of polygons representing "holes" in the outside polygon.  Null == none.    * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as    *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside    *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a    *  "safe" polygon.    * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated    *  from this input.    */
DECL|method|makeGeoPolygon
specifier|public
specifier|static
name|GeoPolygon
name|makeGeoPolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointList
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPolygon
argument_list|>
name|holes
parameter_list|,
specifier|final
name|double
name|leniencyValue
parameter_list|)
block|{
comment|// First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks
comment|//System.err.println(" filtering "+pointList.size()+" points...");
comment|//final long startTime = System.currentTimeMillis();
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|filteredPointList
init|=
name|filterEdges
argument_list|(
name|filterPoints
argument_list|(
name|pointList
argument_list|)
argument_list|,
name|leniencyValue
argument_list|)
decl_stmt|;
comment|//System.err.println("  ...done in "+(System.currentTimeMillis()-startTime)+"ms ("+((filteredPointList==null)?"degenerate":(filteredPointList.size()+" points"))+")");
if|if
condition|(
name|filteredPointList
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//System.err.println("points="+pointList);
comment|// Create a random number generator.  Effectively this furnishes us with a repeatable sequence
comment|// of points to use for poles.
specifier|final
name|Random
name|generator
init|=
operator|new
name|Random
argument_list|(
literal|1234
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|counter
init|=
literal|0
init|;
name|counter
operator|<
literal|1000000
condition|;
name|counter
operator|++
control|)
block|{
comment|//counter++;
comment|// Pick the next random pole
specifier|final
name|GeoPoint
name|pole
init|=
name|pickPole
argument_list|(
name|generator
argument_list|,
name|planetModel
argument_list|,
name|filteredPointList
argument_list|)
decl_stmt|;
comment|// Is it inside or outside?
specifier|final
name|Boolean
name|isPoleInside
init|=
name|isInsidePolygon
argument_list|(
name|pole
argument_list|,
name|filteredPointList
argument_list|)
decl_stmt|;
if|if
condition|(
name|isPoleInside
operator|!=
literal|null
condition|)
block|{
comment|// Legal pole
comment|//System.out.println("Took "+counter+" iterations to find pole");
comment|//System.out.println("Pole = "+pole+"; isInside="+isPoleInside+"; pointList = "+pointList);
return|return
name|generateGeoPolygon
argument_list|(
name|planetModel
argument_list|,
name|filteredPointList
argument_list|,
name|holes
argument_list|,
name|pole
argument_list|,
name|isPoleInside
argument_list|)
return|;
block|}
comment|// If pole choice was illegal, try another one
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot find a point that is inside the polygon "
operator|+
name|filteredPointList
argument_list|)
throw|;
block|}
comment|/** Use this class to specify a polygon with associated holes.    */
DECL|class|PolygonDescription
specifier|public
specifier|static
class|class
name|PolygonDescription
block|{
comment|/** The list of points */
DECL|field|points
specifier|public
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|GeoPoint
argument_list|>
name|points
decl_stmt|;
comment|/** The list of holes */
DECL|field|holes
specifier|public
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|PolygonDescription
argument_list|>
name|holes
decl_stmt|;
comment|/** Instantiate the polygon description.      * @param points is the list of points.      */
DECL|method|PolygonDescription
specifier|public
name|PolygonDescription
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|GeoPoint
argument_list|>
name|points
parameter_list|)
block|{
name|this
argument_list|(
name|points
argument_list|,
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Instantiate the polygon description.      * @param points is the list of points.      * @param holes is the list of holes.      */
DECL|method|PolygonDescription
specifier|public
name|PolygonDescription
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|GeoPoint
argument_list|>
name|points
parameter_list|,
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|PolygonDescription
argument_list|>
name|holes
parameter_list|)
block|{
name|this
operator|.
name|points
operator|=
name|points
expr_stmt|;
name|this
operator|.
name|holes
operator|=
name|holes
expr_stmt|;
block|}
block|}
comment|/** Create a large GeoPolygon.  This is one which has more than 100 sides and/or may have resolution problems    * with very closely spaced points, which often occurs when the polygon was constructed to approximate curves.  No tiling    * is done, and intersections and membership are optimized for having large numbers of sides.    *    * This method does very little checking for legality.  It expects the incoming shapes to not intersect    * each other.  The shapes can be disjoint or nested.  If the shapes listed are nested, then we are describing holes.    * There is no limit to the depth of holes.  However, if a shape is nested within another it must be explicitly    * described as being a child of the other shape.    *    * Membership in any given shape is described by the clockwise/counterclockwise direction of the points.  The    * clockwise direction indicates that a point inside is "in-set", while a counter-clockwise direction implies that    * a point inside is "out-of-set".    *     * @param planetModel is the planet model.    * @param shapesList is the list of polygons we should be making.    * @return the GeoPolygon, or null if it cannot be constructed.    */
DECL|method|makeLargeGeoPolygon
specifier|public
specifier|static
name|GeoPolygon
name|makeLargeGeoPolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|PolygonDescription
argument_list|>
name|shapesList
parameter_list|)
block|{
comment|// We're going to be building a single-level list of shapes in the end, with a single point that we know to be inside/outside, which is
comment|// not on an edge.
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|GeoPoint
argument_list|>
argument_list|>
name|pointsList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|testPointShape
init|=
literal|null
decl_stmt|;
for|for
control|(
specifier|final
name|PolygonDescription
name|shape
range|:
name|shapesList
control|)
block|{
comment|// Convert this shape and its holes to a general list of shapes.  We also need to identify exactly one
comment|// legal, non-degenerate shape with no children that we can use to find a test point.  We also optimize
comment|// to choose as small as possible a polygon for determining the in-set-ness of the test point.
name|testPointShape
operator|=
name|convertPolygon
argument_list|(
name|pointsList
argument_list|,
name|shape
argument_list|,
name|testPointShape
argument_list|)
expr_stmt|;
block|}
comment|// If there's no polygon we can use to determine a test point, we throw up.
if|if
condition|(
name|testPointShape
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"couldn't find a non-degenerate polygon for in-set determination"
argument_list|)
throw|;
block|}
comment|// Create a random number generator.  Effectively this furnishes us with a repeatable sequence
comment|// of points to use for poles.
specifier|final
name|Random
name|generator
init|=
operator|new
name|Random
argument_list|(
literal|1234
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|counter
init|=
literal|0
init|;
name|counter
operator|<
literal|1000000
condition|;
name|counter
operator|++
control|)
block|{
comment|// Pick the next random pole
specifier|final
name|GeoPoint
name|pole
init|=
name|pickPole
argument_list|(
name|generator
argument_list|,
name|planetModel
argument_list|,
name|testPointShape
argument_list|)
decl_stmt|;
comment|// Is it inside or outside?
specifier|final
name|Boolean
name|isPoleInside
init|=
name|isInsidePolygon
argument_list|(
name|pole
argument_list|,
name|testPointShape
argument_list|)
decl_stmt|;
if|if
condition|(
name|isPoleInside
operator|!=
literal|null
condition|)
block|{
comment|// Legal pole
return|return
operator|new
name|GeoComplexPolygon
argument_list|(
name|planetModel
argument_list|,
name|pointsList
argument_list|,
name|pole
argument_list|,
name|isPoleInside
argument_list|)
return|;
block|}
comment|// If pole choice was illegal, try another one
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot find a point that is inside the polygon "
operator|+
name|testPointShape
argument_list|)
throw|;
block|}
comment|/** Convert a polygon description to a list of shapes.  Also locate an optimal shape for evaluating a test point.    * @param pointsList is the structure to add new polygons to.    * @param shape is the current polygon description.    * @param testPointShape is the current best choice for a low-level polygon to evaluate.    * @return an updated best-choice for a test point polygon, and update the points list.    */
DECL|method|convertPolygon
specifier|private
specifier|static
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|convertPolygon
parameter_list|(
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|GeoPoint
argument_list|>
argument_list|>
name|pointsList
parameter_list|,
specifier|final
name|PolygonDescription
name|shape
parameter_list|,
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|testPointShape
parameter_list|)
block|{
comment|// First, remove duplicate points.  If degenerate, just ignore the shape.
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|filteredPoints
init|=
name|filterPoints
argument_list|(
name|shape
operator|.
name|points
argument_list|)
decl_stmt|;
if|if
condition|(
name|filteredPoints
operator|==
literal|null
condition|)
block|{
return|return
name|testPointShape
return|;
block|}
comment|// Non-degenerate.  Check if this is a candidate for in-set determination.
if|if
condition|(
name|shape
operator|.
name|holes
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// This shape is a candidate for a test point.
if|if
condition|(
name|testPointShape
operator|==
literal|null
operator|||
name|testPointShape
operator|.
name|size
argument_list|()
operator|>
name|filteredPoints
operator|.
name|size
argument_list|()
condition|)
block|{
name|testPointShape
operator|=
name|filteredPoints
expr_stmt|;
block|}
block|}
name|pointsList
operator|.
name|add
argument_list|(
name|filteredPoints
argument_list|)
expr_stmt|;
comment|// Now, do all holes too
for|for
control|(
specifier|final
name|PolygonDescription
name|hole
range|:
name|shape
operator|.
name|holes
control|)
block|{
name|testPointShape
operator|=
name|convertPolygon
argument_list|(
name|pointsList
argument_list|,
name|hole
argument_list|,
name|testPointShape
argument_list|)
expr_stmt|;
block|}
comment|// Done; return the updated test point shape.
return|return
name|testPointShape
return|;
block|}
comment|/**    * Create a GeoPolygon using the specified points and holes and a test point.    *    * @param filteredPointList is a filtered list of the GeoPoints to build an arbitrary polygon out of.    * @param holes is a list of polygons representing "holes" in the outside polygon.  Null == none.    * @param testPoint is a test point that is either known to be within the polygon area, or not.    * @param testPointInside is true if the test point is within the area, false otherwise.    * @return a GeoPolygon corresponding to what was specified, or null if what was specified    *  cannot be turned into a valid non-degenerate polygon.    */
DECL|method|generateGeoPolygon
specifier|static
name|GeoPolygon
name|generateGeoPolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|filteredPointList
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPolygon
argument_list|>
name|holes
parameter_list|,
specifier|final
name|GeoPoint
name|testPoint
parameter_list|,
specifier|final
name|boolean
name|testPointInside
parameter_list|)
block|{
comment|// We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon
comment|// side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can
comment|// find.
specifier|final
name|SidedPlane
name|initialPlane
init|=
operator|new
name|SidedPlane
argument_list|(
name|testPoint
argument_list|,
name|filteredPointList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|filteredPointList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|// We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.
comment|// So we need to be prepared to try both possibilities.
name|GeoCompositePolygon
name|rval
init|=
operator|new
name|GeoCompositePolygon
argument_list|()
decl_stmt|;
name|MutableBoolean
name|seenConcave
init|=
operator|new
name|MutableBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|buildPolygonShape
argument_list|(
name|rval
argument_list|,
name|seenConcave
argument_list|,
name|planetModel
argument_list|,
name|filteredPointList
argument_list|,
operator|new
name|BitSet
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|initialPlane
argument_list|,
name|holes
argument_list|,
name|testPoint
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// The testPoint was within the shape.  Was that intended?
if|if
condition|(
name|testPointInside
condition|)
block|{
comment|// Yes: build it for real
name|rval
operator|=
operator|new
name|GeoCompositePolygon
argument_list|()
expr_stmt|;
name|seenConcave
operator|=
operator|new
name|MutableBoolean
argument_list|()
expr_stmt|;
name|buildPolygonShape
argument_list|(
name|rval
argument_list|,
name|seenConcave
argument_list|,
name|planetModel
argument_list|,
name|filteredPointList
argument_list|,
operator|new
name|BitSet
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|initialPlane
argument_list|,
name|holes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
comment|// No: do the complement and return that.
name|rval
operator|=
operator|new
name|GeoCompositePolygon
argument_list|()
expr_stmt|;
name|seenConcave
operator|=
operator|new
name|MutableBoolean
argument_list|()
expr_stmt|;
name|buildPolygonShape
argument_list|(
name|rval
argument_list|,
name|seenConcave
argument_list|,
name|planetModel
argument_list|,
name|filteredPointList
argument_list|,
operator|new
name|BitSet
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|new
name|SidedPlane
argument_list|(
name|initialPlane
argument_list|)
argument_list|,
name|holes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
else|else
block|{
comment|// The testPoint was outside the shape.  Was that intended?
if|if
condition|(
operator|!
name|testPointInside
condition|)
block|{
comment|// Yes: return what we just built
return|return
name|rval
return|;
block|}
comment|// No: return the complement
name|rval
operator|=
operator|new
name|GeoCompositePolygon
argument_list|()
expr_stmt|;
name|seenConcave
operator|=
operator|new
name|MutableBoolean
argument_list|()
expr_stmt|;
name|buildPolygonShape
argument_list|(
name|rval
argument_list|,
name|seenConcave
argument_list|,
name|planetModel
argument_list|,
name|filteredPointList
argument_list|,
operator|new
name|BitSet
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|new
name|SidedPlane
argument_list|(
name|initialPlane
argument_list|)
argument_list|,
name|holes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
block|}
comment|/** Filter duplicate points.    * @param input with input list of points    * @return the filtered list, or null if we can't get a legit polygon from the input.    */
DECL|method|filterPoints
specifier|static
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|filterPoints
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|GeoPoint
argument_list|>
name|input
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|noIdenticalPoints
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|input
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Backtrack to find something different from the first point
name|int
name|startIndex
init|=
operator|-
literal|1
decl_stmt|;
specifier|final
name|GeoPoint
name|comparePoint
init|=
name|input
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|input
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|GeoPoint
name|thePoint
init|=
name|input
operator|.
name|get
argument_list|(
name|getLegalIndex
argument_list|(
operator|-
name|i
operator|-
literal|1
argument_list|,
name|input
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|thePoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|comparePoint
argument_list|)
condition|)
block|{
name|startIndex
operator|=
name|getLegalIndex
argument_list|(
operator|-
name|i
argument_list|,
name|input
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|startIndex
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Now we can start the process of walking around, removing duplicate points.
name|int
name|currentIndex
init|=
name|startIndex
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|GeoPoint
name|currentPoint
init|=
name|input
operator|.
name|get
argument_list|(
name|currentIndex
argument_list|)
decl_stmt|;
name|noIdenticalPoints
operator|.
name|add
argument_list|(
name|currentPoint
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|currentIndex
operator|=
name|getLegalIndex
argument_list|(
name|currentIndex
operator|+
literal|1
argument_list|,
name|input
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentIndex
operator|==
name|startIndex
condition|)
block|{
break|break;
block|}
specifier|final
name|GeoPoint
name|nextNonIdenticalPoint
init|=
name|input
operator|.
name|get
argument_list|(
name|currentIndex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nextNonIdenticalPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|currentPoint
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|currentIndex
operator|==
name|startIndex
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|noIdenticalPoints
operator|.
name|size
argument_list|()
operator|<
literal|3
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|noIdenticalPoints
return|;
block|}
comment|/** Filter coplanar points.    * @param noIdenticalPoints with input list of points    * @param leniencyValue is the allowed distance of a point from the plane for cleanup of overly detailed polygons    * @return the filtered list, or null if we can't get a legit polygon from the input.    */
DECL|method|filterEdges
specifier|static
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|filterEdges
parameter_list|(
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|noIdenticalPoints
parameter_list|,
specifier|final
name|double
name|leniencyValue
parameter_list|)
block|{
comment|// Now, do the depth-first search needed to find a path that has no coplanarities in it.
comment|// This is, unfortunately, not easy, because coplanarity is not transitive as you walk around the polygon.
comment|// If point C is not coplanar with edge A-B, there is no guarantee that A is not coplanar with B-C.
comment|// But we have to produce a polygon that is safe no matter which way it is looked at.
comment|// The approach I'm taking therefore is to do a depth-first search until we find a valid polygon.
comment|// This algorithmically awful in the worst case, but luckily we can presume that real-life data
comment|// does not require more than a couple of iterations.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|noIdenticalPoints
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SafePath
name|startPath
init|=
operator|new
name|SafePath
argument_list|(
literal|null
argument_list|,
name|noIdenticalPoints
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// Search, with this as the start path.
specifier|final
name|SafePath
name|resultPath
init|=
name|findSafePath
argument_list|(
name|startPath
argument_list|,
name|noIdenticalPoints
argument_list|,
name|getLegalIndex
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|noIdenticalPoints
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|i
argument_list|,
name|leniencyValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|resultPath
operator|!=
literal|null
operator|&&
name|resultPath
operator|.
name|previous
operator|!=
literal|null
condition|)
block|{
comment|// Read out result, maintaining ordering
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|rval
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|noIdenticalPoints
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|resultPath
operator|.
name|fillInList
argument_list|(
name|rval
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
block|}
comment|// No path found.  This means that everything was coplanar.
return|return
literal|null
return|;
block|}
comment|/** Recursive depth-first path search.  In order to find a valid path, we must consider all possible legal extensions of    * the current path.  We discard any path that produces illegalities (meaning anything that would allow any coplanarity    * to continue to exist no matter from which direction one looks at it), and take the first legal path we find.    * @param currentPath is the current path (not null).    * @param points is the raw list of points under consideration.    * @param pointIndex is the index of the point that represents the next possible point for consideration for path    *  extension.    * @param startPointIndex is index of the point that starts the current path, so that we can know when we are done.    * @param leniencyValue is the maximum allowed distance of a point being skipped from the revised polygon.  Pass zero if    *  no leniency desired.    * @return null if there was no safe path found, or the safe path if one was discovered.    */
DECL|method|findSafePath
specifier|private
specifier|static
name|SafePath
name|findSafePath
parameter_list|(
specifier|final
name|SafePath
name|currentPath
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|points
parameter_list|,
specifier|final
name|int
name|pointIndex
parameter_list|,
specifier|final
name|int
name|startPointIndex
parameter_list|,
specifier|final
name|double
name|leniencyValue
parameter_list|)
block|{
comment|//System.err.println("extending path...");
comment|// Loop across all possible path extensions, and consider each in turn
name|int
name|considerPointIndex
init|=
name|pointIndex
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// Check if the extension of currentPath to considerPointIndex is workable
specifier|final
name|GeoPoint
name|considerStartPoint
init|=
name|currentPath
operator|.
name|lastPoint
decl_stmt|;
specifier|final
name|GeoPoint
name|considerEndPoint
init|=
name|points
operator|.
name|get
argument_list|(
name|considerPointIndex
argument_list|)
decl_stmt|;
specifier|final
name|int
name|nextPointIndex
init|=
name|getLegalIndex
argument_list|(
name|considerPointIndex
operator|+
literal|1
argument_list|,
name|points
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|considerStartPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|considerEndPoint
argument_list|)
condition|)
block|{
comment|// Create a plane including these two
specifier|final
name|Plane
name|considerPlane
init|=
operator|new
name|Plane
argument_list|(
name|considerStartPoint
argument_list|,
name|considerEndPoint
argument_list|)
decl_stmt|;
name|boolean
name|isChoiceLegal
init|=
literal|true
decl_stmt|;
comment|//System.err.println(" considering "+considerStartPoint+" to "+considerEndPoint);
if|if
condition|(
name|isChoiceLegal
condition|)
block|{
comment|// Consider the previous plane/point
if|if
condition|(
name|currentPath
operator|.
name|lastPlane
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|currentPath
operator|.
name|lastPlane
operator|.
name|evaluateIsZero
argument_list|(
name|considerEndPoint
argument_list|)
condition|)
block|{
comment|//System.err.println("  coplanar with last plane");
comment|// no good
name|isChoiceLegal
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|considerPlane
operator|.
name|evaluateIsZero
argument_list|(
name|currentPath
operator|.
name|previous
operator|.
name|lastPoint
argument_list|)
condition|)
block|{
comment|//System.err.println("  last point coplanar with this plane");
name|isChoiceLegal
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// To guarantee that no planes we build are coplanar with edge points, we need to verify everything back from
comment|// considerEndPoint back to the start of the path.  We build the edge from considerEndPoint back to each
comment|// of the SafePath points already determined.  Then, we need to look at all triangles that include that edge and
comment|// the SafePath points in between.  If all of those triangles are legal, we can be assured that adding the current
comment|// proposed point is safe to do.
comment|// This is, of course, a lot of work -- specifically, it's O(n^2) for each point in the path, which leads to an O(n^3)
comment|// evaluation time overall!!
comment|// The only alternative is to understand the cases under which these triangles would be introduced, and tailor the
comment|// cleaning to catch those cases only.  Still need to figure that out.  The case that blows up is when *all* the points
comment|// for a triangle are coplanar, so theoretically we don't even need to generate the triangle at all(!)
comment|//
comment|// Build a plane that represents the third edge in this triangle, to guarantee that we can compose
comment|// the polygon from triangles
specifier|final
name|Plane
name|thirdPlane
init|=
operator|new
name|Plane
argument_list|(
name|currentPath
operator|.
name|previous
operator|.
name|lastPoint
argument_list|,
name|considerEndPoint
argument_list|)
decl_stmt|;
if|if
condition|(
name|thirdPlane
operator|.
name|evaluateIsZero
argument_list|(
name|considerStartPoint
argument_list|)
condition|)
block|{
name|isChoiceLegal
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|isChoiceLegal
operator|&&
name|considerPointIndex
operator|==
name|startPointIndex
condition|)
block|{
comment|// Verify that the first plane (already recorded) works together with the last plane
specifier|final
name|SafePath
name|firstPlaneEndpoint
init|=
name|currentPath
operator|.
name|findFirstEndpoint
argument_list|()
decl_stmt|;
if|if
condition|(
name|firstPlaneEndpoint
operator|==
literal|null
condition|)
block|{
comment|//System.err.println("  path not long enough");
name|isChoiceLegal
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|firstPlaneEndpoint
operator|.
name|lastPlane
operator|.
name|evaluateIsZero
argument_list|(
name|considerStartPoint
argument_list|)
condition|)
block|{
comment|//System.err.println("  last point is coplanar with start plane");
name|isChoiceLegal
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|considerPlane
operator|.
name|evaluateIsZero
argument_list|(
name|firstPlaneEndpoint
operator|.
name|lastPoint
argument_list|)
condition|)
block|{
comment|//System.err.println("  first point is coplanar with last plane");
name|isChoiceLegal
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// Build a plane that represents the third edge in this triangle, to guarantee that we can compose
comment|// the polygon from triangles
specifier|final
name|Plane
name|thirdPlane
init|=
operator|new
name|Plane
argument_list|(
name|considerStartPoint
argument_list|,
name|firstPlaneEndpoint
operator|.
name|lastPoint
argument_list|)
decl_stmt|;
if|if
condition|(
name|thirdPlane
operator|.
name|evaluateIsZero
argument_list|(
name|considerEndPoint
argument_list|)
condition|)
block|{
name|isChoiceLegal
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|isChoiceLegal
condition|)
block|{
comment|// All points between the start and end, if any, must be on the plane.
name|int
name|checkIndex
init|=
name|getLegalIndex
argument_list|(
name|currentPath
operator|.
name|lastPointIndex
operator|+
literal|1
argument_list|,
name|points
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|checkIndex
operator|!=
name|considerPointIndex
condition|)
block|{
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|considerPlane
operator|.
name|evaluate
argument_list|(
name|points
operator|.
name|get
argument_list|(
name|checkIndex
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|Vector
operator|.
name|MINIMUM_RESOLUTION
operator|+
name|leniencyValue
condition|)
block|{
comment|// This possibility is no good.  But does it say anything about other possibilities?  I think
comment|// it may mean we don't have to consider any further extensions.  I can't prove this, but
comment|// it makes this algorithm complete in not an insane period of time at least...
comment|//System.err.println("  interior point not coplanar with trial plane");
comment|//isChoiceLegal = false;
comment|//break;
return|return
literal|null
return|;
block|}
name|checkIndex
operator|=
name|getLegalIndex
argument_list|(
name|checkIndex
operator|+
literal|1
argument_list|,
name|points
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isChoiceLegal
condition|)
block|{
comment|// Extend the path and call ourselves recursively.
if|if
condition|(
name|considerPointIndex
operator|==
name|startPointIndex
condition|)
block|{
comment|// Current path has been validated; return it
return|return
name|currentPath
return|;
block|}
comment|//System.err.println(" adding to path: "+considerEndPoint+"; "+considerPlane);
specifier|final
name|SafePath
name|newPath
init|=
operator|new
name|SafePath
argument_list|(
name|currentPath
argument_list|,
name|considerEndPoint
argument_list|,
name|considerPointIndex
argument_list|,
name|considerPlane
argument_list|)
decl_stmt|;
specifier|final
name|SafePath
name|result
init|=
name|findSafePath
argument_list|(
name|newPath
argument_list|,
name|points
argument_list|,
name|nextPointIndex
argument_list|,
name|startPointIndex
argument_list|,
name|leniencyValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
block|}
if|if
condition|(
name|considerPointIndex
operator|==
name|startPointIndex
condition|)
block|{
break|break;
block|}
name|considerPointIndex
operator|=
name|nextPointIndex
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/** Pick a random pole that has a good chance of being inside the polygon described by the points.    * @param generator is the random number generator to use.    * @param planetModel is the planet model to use.    * @param points is the list of points available.    * @return the randomly-determined pole selection.    */
DECL|method|pickPole
specifier|private
specifier|static
name|GeoPoint
name|pickPole
parameter_list|(
specifier|final
name|Random
name|generator
parameter_list|,
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|points
parameter_list|)
block|{
specifier|final
name|int
name|pointIndex
init|=
name|generator
operator|.
name|nextInt
argument_list|(
name|points
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
name|closePoint
init|=
name|points
operator|.
name|get
argument_list|(
name|pointIndex
argument_list|)
decl_stmt|;
comment|// We pick a random angle and random arc distance, then generate a point based on closePoint
specifier|final
name|double
name|angle
init|=
name|generator
operator|.
name|nextDouble
argument_list|()
operator|*
name|Math
operator|.
name|PI
operator|*
literal|2.0
operator|-
name|Math
operator|.
name|PI
decl_stmt|;
specifier|final
name|double
name|maxArcDistance
init|=
name|points
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|arcDistance
argument_list|(
name|points
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|double
name|arcDistance
init|=
name|maxArcDistance
operator|-
name|generator
operator|.
name|nextDouble
argument_list|()
operator|*
name|maxArcDistance
decl_stmt|;
comment|// We come up with a unit circle (x,y,z) coordinate given the random angle and arc distance.  The point is centered around the positive x axis.
specifier|final
name|double
name|x
init|=
name|Math
operator|.
name|cos
argument_list|(
name|arcDistance
argument_list|)
decl_stmt|;
specifier|final
name|double
name|sinArcDistance
init|=
name|Math
operator|.
name|sin
argument_list|(
name|arcDistance
argument_list|)
decl_stmt|;
specifier|final
name|double
name|y
init|=
name|Math
operator|.
name|cos
argument_list|(
name|angle
argument_list|)
operator|*
name|sinArcDistance
decl_stmt|;
specifier|final
name|double
name|z
init|=
name|Math
operator|.
name|sin
argument_list|(
name|angle
argument_list|)
operator|*
name|sinArcDistance
decl_stmt|;
comment|// Now, use closePoint for a rotation pole
specifier|final
name|double
name|sinLatitude
init|=
name|Math
operator|.
name|sin
argument_list|(
name|closePoint
operator|.
name|getLatitude
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|double
name|cosLatitude
init|=
name|Math
operator|.
name|cos
argument_list|(
name|closePoint
operator|.
name|getLatitude
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|double
name|sinLongitude
init|=
name|Math
operator|.
name|sin
argument_list|(
name|closePoint
operator|.
name|getLongitude
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|double
name|cosLongitude
init|=
name|Math
operator|.
name|cos
argument_list|(
name|closePoint
operator|.
name|getLongitude
argument_list|()
argument_list|)
decl_stmt|;
comment|// This transformation should take the point (1,0,0) and transform it to the closepoint's actual (x,y,z) coordinates.
comment|// Coordinate rotation formula:
comment|// x1 = x0 cos T - y0 sin T
comment|// y1 = x0 sin T + y0 cos T
comment|// We're in essence undoing the following transformation (from GeoPolygonFactory):
comment|// x1 = x0 cos az + y0 sin az
comment|// y1 = - x0 sin az + y0 cos az
comment|// z1 = z0
comment|// x2 = x1 cos al + z1 sin al
comment|// y2 = y1
comment|// z2 = - x1 sin al + z1 cos al
comment|// So, we reverse the order of the transformations, AND we transform backwards.
comment|// Transforming backwards means using these identities: sin(-angle) = -sin(angle), cos(-angle) = cos(angle)
comment|// So:
comment|// x1 = x0 cos al - z0 sin al
comment|// y1 = y0
comment|// z1 = x0 sin al + z0 cos al
comment|// x2 = x1 cos az - y1 sin az
comment|// y2 = x1 sin az + y1 cos az
comment|// z2 = z1
specifier|final
name|double
name|x1
init|=
name|x
operator|*
name|cosLatitude
operator|-
name|z
operator|*
name|sinLatitude
decl_stmt|;
specifier|final
name|double
name|y1
init|=
name|y
decl_stmt|;
specifier|final
name|double
name|z1
init|=
name|x
operator|*
name|sinLatitude
operator|+
name|z
operator|*
name|cosLatitude
decl_stmt|;
specifier|final
name|double
name|x2
init|=
name|x1
operator|*
name|cosLongitude
operator|-
name|y1
operator|*
name|sinLongitude
decl_stmt|;
specifier|final
name|double
name|y2
init|=
name|x1
operator|*
name|sinLongitude
operator|+
name|y1
operator|*
name|cosLongitude
decl_stmt|;
specifier|final
name|double
name|z2
init|=
name|z1
decl_stmt|;
comment|// Finally, scale to put the point on the surface
return|return
name|planetModel
operator|.
name|createSurfacePoint
argument_list|(
name|x2
argument_list|,
name|y2
argument_list|,
name|z2
argument_list|)
return|;
block|}
comment|/** For a specified point and a list of poly points, determine based on point order whether the    * point should be considered in or out of the polygon.    * @param point is the point to check.    * @param polyPoints is the list of points comprising the polygon.    * @return null if the point is illegal, otherwise false if the point is inside and true if the point is outside    * of the polygon.    */
DECL|method|isInsidePolygon
specifier|private
specifier|static
name|Boolean
name|isInsidePolygon
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|polyPoints
parameter_list|)
block|{
comment|// First, compute sine and cosine of pole point latitude and longitude
specifier|final
name|double
name|latitude
init|=
name|point
operator|.
name|getLatitude
argument_list|()
decl_stmt|;
specifier|final
name|double
name|longitude
init|=
name|point
operator|.
name|getLongitude
argument_list|()
decl_stmt|;
specifier|final
name|double
name|sinLatitude
init|=
name|Math
operator|.
name|sin
argument_list|(
name|latitude
argument_list|)
decl_stmt|;
specifier|final
name|double
name|cosLatitude
init|=
name|Math
operator|.
name|cos
argument_list|(
name|latitude
argument_list|)
decl_stmt|;
specifier|final
name|double
name|sinLongitude
init|=
name|Math
operator|.
name|sin
argument_list|(
name|longitude
argument_list|)
decl_stmt|;
specifier|final
name|double
name|cosLongitude
init|=
name|Math
operator|.
name|cos
argument_list|(
name|longitude
argument_list|)
decl_stmt|;
comment|// Now, compute the incremental arc distance around the points of the polygon
name|double
name|arcDistance
init|=
literal|0.0
decl_stmt|;
name|Double
name|prevAngle
init|=
literal|null
decl_stmt|;
comment|//System.out.println("Computing angles:");
for|for
control|(
specifier|final
name|GeoPoint
name|polyPoint
range|:
name|polyPoints
control|)
block|{
specifier|final
name|Double
name|angle
init|=
name|computeAngle
argument_list|(
name|polyPoint
argument_list|,
name|sinLatitude
argument_list|,
name|cosLatitude
argument_list|,
name|sinLongitude
argument_list|,
name|cosLongitude
argument_list|)
decl_stmt|;
if|if
condition|(
name|angle
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//System.out.println("Computed angle: "+angle);
if|if
condition|(
name|prevAngle
operator|!=
literal|null
condition|)
block|{
comment|// Figure out delta between prevAngle and current angle, and add it to arcDistance
name|double
name|angleDelta
init|=
name|angle
operator|-
name|prevAngle
decl_stmt|;
if|if
condition|(
name|angleDelta
operator|<
operator|-
name|Math
operator|.
name|PI
condition|)
block|{
name|angleDelta
operator|+=
name|Math
operator|.
name|PI
operator|*
literal|2.0
expr_stmt|;
block|}
if|if
condition|(
name|angleDelta
operator|>
name|Math
operator|.
name|PI
condition|)
block|{
name|angleDelta
operator|-=
name|Math
operator|.
name|PI
operator|*
literal|2.0
expr_stmt|;
block|}
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|angleDelta
operator|-
name|Math
operator|.
name|PI
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//System.out.println(" angle delta = "+angleDelta);
name|arcDistance
operator|+=
name|angleDelta
expr_stmt|;
comment|//System.out.println(" For point "+polyPoint+" angle is "+angle+"; delta is "+angleDelta+"; arcDistance is "+arcDistance);
block|}
name|prevAngle
operator|=
name|angle
expr_stmt|;
block|}
if|if
condition|(
name|prevAngle
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Double
name|lastAngle
init|=
name|computeAngle
argument_list|(
name|polyPoints
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|sinLatitude
argument_list|,
name|cosLatitude
argument_list|,
name|sinLongitude
argument_list|,
name|cosLongitude
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastAngle
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//System.out.println("Computed last angle: "+lastAngle);
comment|// Figure out delta and add it
name|double
name|angleDelta
init|=
name|lastAngle
operator|-
name|prevAngle
decl_stmt|;
if|if
condition|(
name|angleDelta
operator|<
operator|-
name|Math
operator|.
name|PI
condition|)
block|{
name|angleDelta
operator|+=
name|Math
operator|.
name|PI
operator|*
literal|2.0
expr_stmt|;
block|}
if|if
condition|(
name|angleDelta
operator|>
name|Math
operator|.
name|PI
condition|)
block|{
name|angleDelta
operator|-=
name|Math
operator|.
name|PI
operator|*
literal|2.0
expr_stmt|;
block|}
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|angleDelta
operator|-
name|Math
operator|.
name|PI
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//System.out.println(" angle delta = "+angleDelta);
name|arcDistance
operator|+=
name|angleDelta
expr_stmt|;
comment|//System.out.println(" For point "+polyPoints.get(0)+" angle is "+lastAngle+"; delta is "+angleDelta+"; arcDistance is "+arcDistance);
block|}
comment|// Clockwise == inside == negative
comment|//System.out.println("Arcdistance = "+arcDistance);
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|arcDistance
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
condition|)
block|{
comment|// No idea what direction, so try another pole.
return|return
literal|null
return|;
block|}
return|return
name|arcDistance
operator|>
literal|0.0
return|;
block|}
comment|/** Compute the angle for a point given rotation information.     * @param point is the point to assess     * @param sinLatitude the sine of the latitude     * @param cosLatitude the cosine of the latitude     * @param sinLongitude the sine of the longitude     * @param cosLongitude the cosine of the longitude     * @return the angle of rotation, or null if not computable     */
DECL|method|computeAngle
specifier|private
specifier|static
name|Double
name|computeAngle
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|double
name|sinLatitude
parameter_list|,
specifier|final
name|double
name|cosLatitude
parameter_list|,
specifier|final
name|double
name|sinLongitude
parameter_list|,
specifier|final
name|double
name|cosLongitude
parameter_list|)
block|{
comment|// Coordinate rotation formula:
comment|// x1 = x0 cos T - y0 sin T
comment|// y1 = x0 sin T + y0 cos T
comment|// We need to rotate the point in question into the coordinate frame specified by
comment|// the lat and lon trig functions.
comment|// To do this we need to do two rotations on it.  First rotation is in x/y.  Second rotation is in x/z.
comment|// And we rotate in the negative direction.
comment|// So:
comment|// x1 = x0 cos az + y0 sin az
comment|// y1 = - x0 sin az + y0 cos az
comment|// z1 = z0
comment|// x2 = x1 cos al + z1 sin al
comment|// y2 = y1
comment|// z2 = - x1 sin al + z1 cos al
specifier|final
name|double
name|x1
init|=
name|point
operator|.
name|x
operator|*
name|cosLongitude
operator|+
name|point
operator|.
name|y
operator|*
name|sinLongitude
decl_stmt|;
specifier|final
name|double
name|y1
init|=
operator|-
name|point
operator|.
name|x
operator|*
name|sinLongitude
operator|+
name|point
operator|.
name|y
operator|*
name|cosLongitude
decl_stmt|;
specifier|final
name|double
name|z1
init|=
name|point
operator|.
name|z
decl_stmt|;
comment|// final double x2 = x1 * cosLatitude + z1 * sinLatitude;
specifier|final
name|double
name|y2
init|=
name|y1
decl_stmt|;
specifier|final
name|double
name|z2
init|=
operator|-
name|x1
operator|*
name|sinLatitude
operator|+
name|z1
operator|*
name|cosLatitude
decl_stmt|;
comment|// Now we should be looking down the X axis; the original point has rotated coordinates (N, 0, 0).
comment|// So we can just compute the angle using y2 and z2.  (If Math.sqrt(y2*y2 + z2 * z2) is 0.0, then the point is on the pole and we need another one).
if|if
condition|(
name|Math
operator|.
name|sqrt
argument_list|(
name|y2
operator|*
name|y2
operator|+
name|z2
operator|*
name|z2
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|Math
operator|.
name|atan2
argument_list|(
name|z2
argument_list|,
name|y2
argument_list|)
return|;
block|}
comment|/** Build a GeoPolygon out of one concave part and multiple convex parts given points, starting edge, and whether starting edge is internal or not.    * @param rval is the composite polygon to add to.    * @param seenConcave is true if a concave polygon has been seen in this generation yet.    * @param planetModel is the planet model.    * @param pointsList is a list of the GeoPoints to build an arbitrary polygon out of.    * @param internalEdges specifies which edges are internal.    * @param startPointIndex is the first of the points, constituting the starting edge.    * @param startingEdge is the plane describing the starting edge.    * @param holes is the list of holes in the polygon, or null if none.    * @param testPoint is an (optional) test point, which will be used to determine if we are generating    *  a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside    *  of the generated polygon.  In this case, if the generated polygon is found to contain the point, the    *  method exits early with a null return value.    *  This only makes sense in the context of evaluating both possible choices and using logic to determine    *  which result to use.  If the test point is supposed to be within the shape, then it must be outside of the    *  complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the    *  original shape.  Either way, we can figure out the right thing to use.    * @return false if what was specified    *  was inconsistent with what we generated.  Specifically, if we specify an exterior point that is    *  found in the interior of the shape we create here we return false, which is a signal that we chose    *  our initial plane sidedness backwards.    */
DECL|method|buildPolygonShape
specifier|static
name|boolean
name|buildPolygonShape
parameter_list|(
specifier|final
name|GeoCompositePolygon
name|rval
parameter_list|,
specifier|final
name|MutableBoolean
name|seenConcave
parameter_list|,
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointsList
parameter_list|,
specifier|final
name|BitSet
name|internalEdges
parameter_list|,
specifier|final
name|int
name|startPointIndex
parameter_list|,
specifier|final
name|int
name|endPointIndex
parameter_list|,
specifier|final
name|SidedPlane
name|startingEdge
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPolygon
argument_list|>
name|holes
parameter_list|,
specifier|final
name|GeoPoint
name|testPoint
parameter_list|)
block|{
comment|// It could be the case that we need a concave polygon.  So we need to try and look for that case
comment|// as part of the general code for constructing complex polygons.
comment|// Note that there can be only one concave polygon.  This code will enforce that condition and will return
comment|// false if it is violated.
comment|// The code here must keep track of two lists of sided planes.  The first list contains the planes consistent with
comment|// a concave polygon.  This list will grow and shrink.  The second list is built starting at the current edge that
comment|// was last consistent with the concave polygon, and contains all edges consistent with a convex polygon.
comment|// When that sequence of edges is done, then an internal edge is created and the identified points are converted to a
comment|// convex polygon.  That internal edge is used to extend the list of edges in the concave polygon edge list.
comment|// The edge buffer.
specifier|final
name|EdgeBuffer
name|edgeBuffer
init|=
operator|new
name|EdgeBuffer
argument_list|(
name|pointsList
argument_list|,
name|internalEdges
argument_list|,
name|startPointIndex
argument_list|,
name|endPointIndex
argument_list|,
name|startingEdge
argument_list|)
decl_stmt|;
comment|/*     // Verify that the polygon does not self-intersect     // Now, look for non-adjacent edges that cross.     System.err.println("Looking for intersections...");     System.err.println("Starting edge is: "+startingEdge);     final Iterator<Edge> edgeIterator = edgeBuffer.iterator();     while (edgeIterator.hasNext()) {       final Edge edge = edgeIterator.next();       final Set<Edge> excludedEdges = new HashSet<>();       excludedEdges.add(edge);       Edge oneBoundary = edgeBuffer.getPrevious(edge);       while (oneBoundary.plane.isNumericallyIdentical(edge.plane)) {         excludedEdges.add(oneBoundary);         oneBoundary = edgeBuffer.getPrevious(oneBoundary);       }       excludedEdges.add(oneBoundary);       Edge otherBoundary = edgeBuffer.getNext(edge);       while (otherBoundary.plane.isNumericallyIdentical(edge.plane)) {         excludedEdges.add(otherBoundary);         otherBoundary = edgeBuffer.getNext(otherBoundary);       }       excludedEdges.add(otherBoundary);        // Now go through all other edges and rule out any intersections       final Iterator<Edge> compareIterator = edgeBuffer.iterator();       while (compareIterator.hasNext()) {         final Edge compareEdge = compareIterator.next();         if (!excludedEdges.contains(compareEdge)) {           // Found an edge we can compare with!           //System.err.println("Found a compare edge...");           boolean nonOverlapping = true;           // We need the other boundaries though.           Edge oneCompareBoundary = edgeBuffer.getPrevious(compareEdge);           while (oneCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {             if (excludedEdges.contains(oneCompareBoundary)) {               //System.err.println(" excluded because oneCompareBoundary found to be in set");               nonOverlapping = false;               break;             }             oneCompareBoundary = edgeBuffer.getPrevious(oneCompareBoundary);           }           Edge otherCompareBoundary = edgeBuffer.getNext(compareEdge);           while (otherCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {             if (excludedEdges.contains(otherCompareBoundary)) {               //System.err.println(" excluded because otherCompareBoundary found to be in set");               nonOverlapping = false;               break;             }             otherCompareBoundary = edgeBuffer.getNext(otherCompareBoundary);           }           if (nonOverlapping) {             //System.err.println("Preparing to call findIntersections...");             // Finally do an intersection test             if (edge.plane.findIntersections(planetModel, compareEdge.plane, oneBoundary.plane, otherBoundary.plane, oneCompareBoundary.plane, otherCompareBoundary.plane).length> 0) {               throw new IllegalArgumentException("polygon has intersecting edges");             }           }         }       }     }     */
comment|// Starting state:
comment|// The stopping point
name|Edge
name|stoppingPoint
init|=
name|edgeBuffer
operator|.
name|pickOne
argument_list|()
decl_stmt|;
comment|// The current edge
name|Edge
name|currentEdge
init|=
name|stoppingPoint
decl_stmt|;
comment|// Progressively look for convex sections.  If we find one, we emit it and replace it.
comment|// Keep going until we have been around once and nothing needed to change, and then
comment|// do the concave polygon, if necessary.
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|currentEdge
operator|==
literal|null
condition|)
block|{
comment|// We're done!
break|break;
block|}
comment|// Find convexity around the current edge, if any
specifier|final
name|Boolean
name|foundIt
init|=
name|findConvexPolygon
argument_list|(
name|planetModel
argument_list|,
name|currentEdge
argument_list|,
name|rval
argument_list|,
name|edgeBuffer
argument_list|,
name|holes
argument_list|,
name|testPoint
argument_list|)
decl_stmt|;
if|if
condition|(
name|foundIt
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|foundIt
condition|)
block|{
comment|// New start point
name|stoppingPoint
operator|=
name|edgeBuffer
operator|.
name|pickOne
argument_list|()
expr_stmt|;
name|currentEdge
operator|=
name|stoppingPoint
expr_stmt|;
comment|// back around
continue|continue;
block|}
comment|// Otherwise, go on to the next
name|currentEdge
operator|=
name|edgeBuffer
operator|.
name|getNext
argument_list|(
name|currentEdge
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentEdge
operator|==
name|stoppingPoint
condition|)
block|{
break|break;
block|}
block|}
comment|// Look for any reason that the concave polygon cannot be created.
comment|// This test is really the converse of the one for a convex polygon.
comment|// Points on the edge of a convex polygon MUST be inside all the other
comment|// edges.  For a concave polygon, this check is still the same, except we have
comment|// to look at the reverse sided planes, not the forward ones.
comment|// If we find a point that is outside of the complementary edges, it means that
comment|// the point is in fact able to form a convex polygon with the edge it is
comment|// offending.
comment|// If what is left has any plane/point pair that is on the wrong side, we have to split using one of the plane endpoints and the
comment|// point in question.  This is best structured as a recursion, if detected.
specifier|final
name|Iterator
argument_list|<
name|Edge
argument_list|>
name|checkIterator
init|=
name|edgeBuffer
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|checkIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|Edge
name|checkEdge
init|=
name|checkIterator
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|SidedPlane
name|flippedPlane
init|=
operator|new
name|SidedPlane
argument_list|(
name|checkEdge
operator|.
name|plane
argument_list|)
decl_stmt|;
comment|// Now walk around again looking for points that fail
specifier|final
name|Iterator
argument_list|<
name|Edge
argument_list|>
name|confirmIterator
init|=
name|edgeBuffer
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|confirmIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|Edge
name|confirmEdge
init|=
name|confirmIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|confirmEdge
operator|==
name|checkEdge
condition|)
block|{
continue|continue;
block|}
comment|// Look for a point that is on the wrong side of the check edge.  This means that we can't build the polygon.
specifier|final
name|GeoPoint
name|thePoint
decl_stmt|;
if|if
condition|(
name|checkEdge
operator|.
name|startPoint
operator|!=
name|confirmEdge
operator|.
name|startPoint
operator|&&
name|checkEdge
operator|.
name|endPoint
operator|!=
name|confirmEdge
operator|.
name|startPoint
operator|&&
operator|!
name|flippedPlane
operator|.
name|isWithin
argument_list|(
name|confirmEdge
operator|.
name|startPoint
argument_list|)
condition|)
block|{
name|thePoint
operator|=
name|confirmEdge
operator|.
name|startPoint
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|checkEdge
operator|.
name|startPoint
operator|!=
name|confirmEdge
operator|.
name|endPoint
operator|&&
name|checkEdge
operator|.
name|endPoint
operator|!=
name|confirmEdge
operator|.
name|endPoint
operator|&&
operator|!
name|flippedPlane
operator|.
name|isWithin
argument_list|(
name|confirmEdge
operator|.
name|endPoint
argument_list|)
condition|)
block|{
name|thePoint
operator|=
name|confirmEdge
operator|.
name|endPoint
expr_stmt|;
block|}
else|else
block|{
name|thePoint
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|thePoint
operator|!=
literal|null
condition|)
block|{
comment|// thePoint is on the wrong side of the complementary plane.  That means we cannot build a concave polygon, because the complement would not
comment|// be a legal convex polygon.
comment|// But we can take advantage of the fact that the distance between the edge and thePoint is less than 180 degrees, and so we can split the
comment|// would-be concave polygon into three segments.  The first segment includes the edge and thePoint, and uses the sense of the edge to determine the sense
comment|// of the polygon.
comment|// This should be the only problematic part of the polygon.
comment|// We know that thePoint is on the "wrong" side of the edge -- that is, it's on the side that the
comment|// edge is pointing at.
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|thirdPartPoints
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|BitSet
name|thirdPartInternal
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|thirdPartPoints
operator|.
name|add
argument_list|(
name|checkEdge
operator|.
name|startPoint
argument_list|)
expr_stmt|;
name|thirdPartInternal
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|checkEdge
operator|.
name|isInternal
argument_list|)
expr_stmt|;
name|thirdPartPoints
operator|.
name|add
argument_list|(
name|checkEdge
operator|.
name|endPoint
argument_list|)
expr_stmt|;
name|thirdPartInternal
operator|.
name|set
argument_list|(
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|thirdPartPoints
operator|.
name|add
argument_list|(
name|thePoint
argument_list|)
expr_stmt|;
assert|assert
name|checkEdge
operator|.
name|plane
operator|.
name|isWithin
argument_list|(
name|thePoint
argument_list|)
operator|:
literal|"Point was on wrong side of complementary plane, so must be on the right side of the non-complementary plane!"
assert|;
specifier|final
name|GeoPolygon
name|convexPart
init|=
operator|new
name|GeoConvexPolygon
argument_list|(
name|planetModel
argument_list|,
name|thirdPartPoints
argument_list|,
name|holes
argument_list|,
name|thirdPartInternal
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|//System.out.println("convex part = "+convexPart);
name|rval
operator|.
name|addShape
argument_list|(
name|convexPart
argument_list|)
expr_stmt|;
comment|// The part preceding the bad edge, back to thePoint, needs to be recursively
comment|// processed.  So, assemble what we need, which is basically a list of edges.
name|Edge
name|loopEdge
init|=
name|edgeBuffer
operator|.
name|getPrevious
argument_list|(
name|checkEdge
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|firstPartPoints
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|BitSet
name|firstPartInternal
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|firstPartPoints
operator|.
name|add
argument_list|(
name|loopEdge
operator|.
name|endPoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|loopEdge
operator|.
name|endPoint
operator|==
name|thePoint
condition|)
block|{
break|break;
block|}
name|firstPartInternal
operator|.
name|set
argument_list|(
name|i
operator|++
argument_list|,
name|loopEdge
operator|.
name|isInternal
argument_list|)
expr_stmt|;
name|loopEdge
operator|=
name|edgeBuffer
operator|.
name|getPrevious
argument_list|(
name|loopEdge
argument_list|)
expr_stmt|;
block|}
name|firstPartInternal
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//System.out.println("Doing first part...");
if|if
condition|(
name|buildPolygonShape
argument_list|(
name|rval
argument_list|,
name|seenConcave
argument_list|,
name|planetModel
argument_list|,
name|firstPartPoints
argument_list|,
name|firstPartInternal
argument_list|,
name|firstPartPoints
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|new
name|SidedPlane
argument_list|(
name|checkEdge
operator|.
name|endPoint
argument_list|,
literal|false
argument_list|,
name|checkEdge
operator|.
name|startPoint
argument_list|,
name|thePoint
argument_list|)
argument_list|,
name|holes
argument_list|,
name|testPoint
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//System.out.println("...done first part.");
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|secondPartPoints
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|BitSet
name|secondPartInternal
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|loopEdge
operator|=
name|edgeBuffer
operator|.
name|getNext
argument_list|(
name|checkEdge
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|secondPartPoints
operator|.
name|add
argument_list|(
name|loopEdge
operator|.
name|startPoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|loopEdge
operator|.
name|startPoint
operator|==
name|thePoint
condition|)
block|{
break|break;
block|}
name|secondPartInternal
operator|.
name|set
argument_list|(
name|i
operator|++
argument_list|,
name|loopEdge
operator|.
name|isInternal
argument_list|)
expr_stmt|;
name|loopEdge
operator|=
name|edgeBuffer
operator|.
name|getNext
argument_list|(
name|loopEdge
argument_list|)
expr_stmt|;
block|}
name|secondPartInternal
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//System.out.println("Doing second part...");
if|if
condition|(
name|buildPolygonShape
argument_list|(
name|rval
argument_list|,
name|seenConcave
argument_list|,
name|planetModel
argument_list|,
name|secondPartPoints
argument_list|,
name|secondPartInternal
argument_list|,
name|secondPartPoints
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|new
name|SidedPlane
argument_list|(
name|checkEdge
operator|.
name|startPoint
argument_list|,
literal|false
argument_list|,
name|checkEdge
operator|.
name|endPoint
argument_list|,
name|thePoint
argument_list|)
argument_list|,
name|holes
argument_list|,
name|testPoint
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//System.out.println("... done second part");
return|return
literal|true
return|;
block|}
block|}
block|}
comment|// No violations found: we know it's a legal concave polygon.
comment|// If there's anything left in the edge buffer, convert to concave polygon.
comment|//System.out.println("adding concave part");
if|if
condition|(
name|makeConcavePolygon
argument_list|(
name|planetModel
argument_list|,
name|rval
argument_list|,
name|seenConcave
argument_list|,
name|edgeBuffer
argument_list|,
name|holes
argument_list|,
name|testPoint
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Look for a concave polygon in the remainder of the edgebuffer.    * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.    * @param planetModel is the planet model.    * @param rval is the composite polygon we're building.    * @param seenConcave is true if we've already seen a concave polygon.    * @param edgeBuffer is the edge buffer.    * @param holes is the optional list of holes.    * @param testPoint is the optional test point.    * @return true unless the testPoint caused failure.    */
DECL|method|makeConcavePolygon
specifier|private
specifier|static
name|boolean
name|makeConcavePolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|GeoCompositePolygon
name|rval
parameter_list|,
specifier|final
name|MutableBoolean
name|seenConcave
parameter_list|,
specifier|final
name|EdgeBuffer
name|edgeBuffer
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPolygon
argument_list|>
name|holes
parameter_list|,
specifier|final
name|GeoPoint
name|testPoint
parameter_list|)
block|{
if|if
condition|(
name|edgeBuffer
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|seenConcave
operator|.
name|value
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal polygon; polygon edges intersect each other"
argument_list|)
throw|;
block|}
name|seenConcave
operator|.
name|value
operator|=
literal|true
expr_stmt|;
comment|// If there are less than three edges, something got messed up somehow.  Don't know how this
comment|// can happen but check.
if|if
condition|(
name|edgeBuffer
operator|.
name|size
argument_list|()
operator|<
literal|3
condition|)
block|{
comment|// Linear...
comment|// Here we can emit GeoWorld, but probably this means we had a broken poly to start with.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal polygon; polygon edges intersect each other"
argument_list|)
throw|;
block|}
comment|// Create the list of points
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|points
init|=
operator|new
name|ArrayList
argument_list|<
name|GeoPoint
argument_list|>
argument_list|(
name|edgeBuffer
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|BitSet
name|internalEdges
init|=
operator|new
name|BitSet
argument_list|(
name|edgeBuffer
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|//System.out.println("Concave polygon points:");
name|Edge
name|edge
init|=
name|edgeBuffer
operator|.
name|pickOne
argument_list|()
decl_stmt|;
name|boolean
name|isInternal
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|edgeBuffer
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|//System.out.println(" "+edge.plane+": "+edge.startPoint+"->"+edge.endPoint+"; previous? "+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?"in":"out")+" next? "+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?"in":"out"));
name|points
operator|.
name|add
argument_list|(
name|edge
operator|.
name|startPoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|edgeBuffer
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|internalEdges
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|edge
operator|.
name|isInternal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isInternal
operator|=
name|edge
operator|.
name|isInternal
expr_stmt|;
block|}
name|edge
operator|=
name|edgeBuffer
operator|.
name|getNext
argument_list|(
name|edge
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|testPoint
operator|!=
literal|null
operator|&&
name|holes
operator|!=
literal|null
operator|&&
name|holes
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// No holes, for test
specifier|final
name|GeoPolygon
name|testPolygon
init|=
operator|new
name|GeoConcavePolygon
argument_list|(
name|planetModel
argument_list|,
name|points
argument_list|,
literal|null
argument_list|,
name|internalEdges
argument_list|,
name|isInternal
argument_list|)
decl_stmt|;
if|if
condition|(
name|testPolygon
operator|.
name|isWithin
argument_list|(
name|testPoint
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|final
name|GeoPolygon
name|realPolygon
init|=
operator|new
name|GeoConcavePolygon
argument_list|(
name|planetModel
argument_list|,
name|points
argument_list|,
name|holes
argument_list|,
name|internalEdges
argument_list|,
name|isInternal
argument_list|)
decl_stmt|;
if|if
condition|(
name|testPoint
operator|!=
literal|null
operator|&&
operator|(
name|holes
operator|==
literal|null
operator|||
name|holes
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|realPolygon
operator|.
name|isWithin
argument_list|(
name|testPoint
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|rval
operator|.
name|addShape
argument_list|(
name|realPolygon
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.    * @param planetModel is the planet model.    * @param currentEdge is the current edge to use starting the search.    * @param rval is the composite polygon to build.    * @param edgeBuffer is the edge buffer.    * @param holes is the optional list of holes.    * @param testPoint is the optional test point.    * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.    */
DECL|method|findConvexPolygon
specifier|private
specifier|static
name|Boolean
name|findConvexPolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|Edge
name|currentEdge
parameter_list|,
specifier|final
name|GeoCompositePolygon
name|rval
parameter_list|,
specifier|final
name|EdgeBuffer
name|edgeBuffer
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPolygon
argument_list|>
name|holes
parameter_list|,
specifier|final
name|GeoPoint
name|testPoint
parameter_list|)
block|{
comment|//System.out.println("Looking at edge "+currentEdge+" with startpoint "+currentEdge.startPoint+" endpoint "+currentEdge.endPoint);
comment|// Initialize the structure.
comment|// We don't keep track of order here; we just care about membership.
comment|// The only exception is the head and tail pointers.
specifier|final
name|Set
argument_list|<
name|Edge
argument_list|>
name|includedEdges
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|includedEdges
operator|.
name|add
argument_list|(
name|currentEdge
argument_list|)
expr_stmt|;
name|Edge
name|firstEdge
init|=
name|currentEdge
decl_stmt|;
name|Edge
name|lastEdge
init|=
name|currentEdge
decl_stmt|;
comment|// First, walk towards the end until we need to stop
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|firstEdge
operator|.
name|startPoint
operator|==
name|lastEdge
operator|.
name|endPoint
condition|)
block|{
break|break;
block|}
specifier|final
name|Edge
name|newLastEdge
init|=
name|edgeBuffer
operator|.
name|getNext
argument_list|(
name|lastEdge
argument_list|)
decl_stmt|;
if|if
condition|(
name|isWithin
argument_list|(
name|newLastEdge
operator|.
name|endPoint
argument_list|,
name|includedEdges
argument_list|)
condition|)
block|{
comment|//System.out.println(" maybe can extend to next edge");
comment|// Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon
comment|// here will overlap with other remaining points?
specifier|final
name|SidedPlane
name|returnBoundary
decl_stmt|;
if|if
condition|(
name|firstEdge
operator|.
name|startPoint
operator|!=
name|newLastEdge
operator|.
name|endPoint
condition|)
block|{
name|returnBoundary
operator|=
operator|new
name|SidedPlane
argument_list|(
name|firstEdge
operator|.
name|endPoint
argument_list|,
name|firstEdge
operator|.
name|startPoint
argument_list|,
name|newLastEdge
operator|.
name|endPoint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|returnBoundary
operator|=
literal|null
expr_stmt|;
block|}
comment|// The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,
comment|// plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.
name|boolean
name|foundPointInside
init|=
literal|false
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|Edge
argument_list|>
name|edgeIterator
init|=
name|edgeBuffer
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|edgeIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|Edge
name|edge
init|=
name|edgeIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|includedEdges
operator|.
name|contains
argument_list|(
name|edge
argument_list|)
operator|&&
name|edge
operator|!=
name|newLastEdge
condition|)
block|{
comment|// This edge has a point to check
if|if
condition|(
name|edge
operator|.
name|startPoint
operator|!=
name|newLastEdge
operator|.
name|endPoint
condition|)
block|{
comment|// look at edge.startPoint
if|if
condition|(
name|isWithin
argument_list|(
name|edge
operator|.
name|startPoint
argument_list|,
name|includedEdges
argument_list|,
name|newLastEdge
argument_list|,
name|returnBoundary
argument_list|)
condition|)
block|{
comment|//System.out.println("  nope; point within found: "+edge.startPoint);
name|foundPointInside
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|edge
operator|.
name|endPoint
operator|!=
name|firstEdge
operator|.
name|startPoint
condition|)
block|{
comment|// look at edge.endPoint
if|if
condition|(
name|isWithin
argument_list|(
name|edge
operator|.
name|endPoint
argument_list|,
name|includedEdges
argument_list|,
name|newLastEdge
argument_list|,
name|returnBoundary
argument_list|)
condition|)
block|{
comment|//System.out.println("  nope; point within found: "+edge.endPoint);
name|foundPointInside
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|foundPointInside
condition|)
block|{
comment|//System.out.println("  extending!");
comment|// Extend the polygon by the new last edge
name|includedEdges
operator|.
name|add
argument_list|(
name|newLastEdge
argument_list|)
expr_stmt|;
name|lastEdge
operator|=
name|newLastEdge
expr_stmt|;
comment|// continue extending in this direction
continue|continue;
block|}
block|}
comment|// We can't extend any more in this direction, so break from the loop.
break|break;
block|}
comment|// Now, walk towards the beginning until we need to stop
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|firstEdge
operator|.
name|startPoint
operator|==
name|lastEdge
operator|.
name|endPoint
condition|)
block|{
break|break;
block|}
specifier|final
name|Edge
name|newFirstEdge
init|=
name|edgeBuffer
operator|.
name|getPrevious
argument_list|(
name|firstEdge
argument_list|)
decl_stmt|;
if|if
condition|(
name|isWithin
argument_list|(
name|newFirstEdge
operator|.
name|startPoint
argument_list|,
name|includedEdges
argument_list|)
condition|)
block|{
comment|//System.out.println(" maybe can extend to previous edge");
comment|// Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon
comment|// here will overlap with other remaining points?
specifier|final
name|SidedPlane
name|returnBoundary
decl_stmt|;
if|if
condition|(
name|newFirstEdge
operator|.
name|startPoint
operator|!=
name|lastEdge
operator|.
name|endPoint
condition|)
block|{
name|returnBoundary
operator|=
operator|new
name|SidedPlane
argument_list|(
name|lastEdge
operator|.
name|startPoint
argument_list|,
name|lastEdge
operator|.
name|endPoint
argument_list|,
name|newFirstEdge
operator|.
name|startPoint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|returnBoundary
operator|=
literal|null
expr_stmt|;
block|}
comment|// The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,
comment|// plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.
name|boolean
name|foundPointInside
init|=
literal|false
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|Edge
argument_list|>
name|edgeIterator
init|=
name|edgeBuffer
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|edgeIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|Edge
name|edge
init|=
name|edgeIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|includedEdges
operator|.
name|contains
argument_list|(
name|edge
argument_list|)
operator|&&
name|edge
operator|!=
name|newFirstEdge
condition|)
block|{
comment|// This edge has a point to check
if|if
condition|(
name|edge
operator|.
name|startPoint
operator|!=
name|lastEdge
operator|.
name|endPoint
condition|)
block|{
comment|// look at edge.startPoint
if|if
condition|(
name|isWithin
argument_list|(
name|edge
operator|.
name|startPoint
argument_list|,
name|includedEdges
argument_list|,
name|newFirstEdge
argument_list|,
name|returnBoundary
argument_list|)
condition|)
block|{
comment|//System.out.println("  nope; point within found: "+edge.startPoint);
name|foundPointInside
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|edge
operator|.
name|endPoint
operator|!=
name|newFirstEdge
operator|.
name|startPoint
condition|)
block|{
comment|// look at edge.endPoint
if|if
condition|(
name|isWithin
argument_list|(
name|edge
operator|.
name|endPoint
argument_list|,
name|includedEdges
argument_list|,
name|newFirstEdge
argument_list|,
name|returnBoundary
argument_list|)
condition|)
block|{
comment|//System.out.println("  nope; point within found: "+edge.endPoint);
name|foundPointInside
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|foundPointInside
condition|)
block|{
comment|//System.out.println("  extending!");
comment|// Extend the polygon by the new last edge
name|includedEdges
operator|.
name|add
argument_list|(
name|newFirstEdge
argument_list|)
expr_stmt|;
name|firstEdge
operator|=
name|newFirstEdge
expr_stmt|;
comment|// continue extending in this direction
continue|continue;
block|}
block|}
comment|// We can't extend any more in this direction, so break from the loop.
break|break;
block|}
comment|// Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.
if|if
condition|(
name|includedEdges
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
comment|//System.out.println("Done edge "+currentEdge+": no poly found");
return|return
literal|false
return|;
block|}
comment|// It's enough to build a convex polygon
comment|//System.out.println("Edge "+currentEdge+": Found complex poly");
comment|// Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between
comment|// the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,
comment|// it's a degenerate case and we want to just clean out the edge buffer entirely.
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|points
init|=
operator|new
name|ArrayList
argument_list|<
name|GeoPoint
argument_list|>
argument_list|(
name|includedEdges
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|BitSet
name|internalEdges
init|=
operator|new
name|BitSet
argument_list|(
name|includedEdges
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|returnIsInternal
decl_stmt|;
if|if
condition|(
name|firstEdge
operator|.
name|startPoint
operator|==
name|lastEdge
operator|.
name|endPoint
condition|)
block|{
comment|// Degenerate case!!  There is no return edge -- or rather, we already have it.
if|if
condition|(
name|includedEdges
operator|.
name|size
argument_list|()
operator|<
literal|3
condition|)
block|{
comment|// This means we found a degenerate cycle of edges.  If we emit a polygon at this point it
comment|// has no contents, so we generate no polygon.
return|return
literal|false
return|;
block|}
comment|// Now look for completely planar points.  This too is a degeneracy condition that we should
comment|// return "false" for.
name|Edge
name|edge
init|=
name|firstEdge
decl_stmt|;
name|points
operator|.
name|add
argument_list|(
name|edge
operator|.
name|startPoint
argument_list|)
expr_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|edge
operator|==
name|lastEdge
condition|)
block|{
break|break;
block|}
name|points
operator|.
name|add
argument_list|(
name|edge
operator|.
name|endPoint
argument_list|)
expr_stmt|;
name|internalEdges
operator|.
name|set
argument_list|(
name|k
operator|++
argument_list|,
name|edge
operator|.
name|isInternal
argument_list|)
expr_stmt|;
name|edge
operator|=
name|edgeBuffer
operator|.
name|getNext
argument_list|(
name|edge
argument_list|)
expr_stmt|;
block|}
name|returnIsInternal
operator|=
name|lastEdge
operator|.
name|isInternal
expr_stmt|;
comment|// Look for coplanarity; abort if so
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|points
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|GeoPoint
name|start
init|=
name|points
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
name|end
init|=
name|points
operator|.
name|get
argument_list|(
name|getLegalIndex
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|points
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// We have to find the next point that is not on the plane between start and end.
comment|// If there is no such point, it's an error.
specifier|final
name|Plane
name|planeToFind
init|=
operator|new
name|Plane
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|int
name|endPointIndex
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|points
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|int
name|index
init|=
name|getLegalIndex
argument_list|(
name|j
operator|+
name|i
operator|+
literal|2
argument_list|,
name|points
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|planeToFind
operator|.
name|evaluateIsZero
argument_list|(
name|points
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
block|{
name|endPointIndex
operator|=
name|index
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|endPointIndex
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|edgeBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Build the return edge (internal, of course)
specifier|final
name|SidedPlane
name|returnSidedPlane
init|=
operator|new
name|SidedPlane
argument_list|(
name|firstEdge
operator|.
name|endPoint
argument_list|,
literal|false
argument_list|,
name|firstEdge
operator|.
name|startPoint
argument_list|,
name|lastEdge
operator|.
name|endPoint
argument_list|)
decl_stmt|;
specifier|final
name|Edge
name|returnEdge
init|=
operator|new
name|Edge
argument_list|(
name|firstEdge
operator|.
name|startPoint
argument_list|,
name|lastEdge
operator|.
name|endPoint
argument_list|,
name|returnSidedPlane
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// Build point list and edge list
specifier|final
name|List
argument_list|<
name|Edge
argument_list|>
name|edges
init|=
operator|new
name|ArrayList
argument_list|<
name|Edge
argument_list|>
argument_list|(
name|includedEdges
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|returnIsInternal
operator|=
literal|true
expr_stmt|;
comment|// Now look for completely planar points.  This too is a degeneracy condition that we should
comment|// return "false" for.
name|Edge
name|edge
init|=
name|firstEdge
decl_stmt|;
name|points
operator|.
name|add
argument_list|(
name|edge
operator|.
name|startPoint
argument_list|)
expr_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|points
operator|.
name|add
argument_list|(
name|edge
operator|.
name|endPoint
argument_list|)
expr_stmt|;
name|internalEdges
operator|.
name|set
argument_list|(
name|k
operator|++
argument_list|,
name|edge
operator|.
name|isInternal
argument_list|)
expr_stmt|;
name|edges
operator|.
name|add
argument_list|(
name|edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge
operator|==
name|lastEdge
condition|)
block|{
break|break;
block|}
name|edge
operator|=
name|edgeBuffer
operator|.
name|getNext
argument_list|(
name|edge
argument_list|)
expr_stmt|;
block|}
comment|// Look for coplanarity; abort if so
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|points
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|GeoPoint
name|start
init|=
name|points
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
name|end
init|=
name|points
operator|.
name|get
argument_list|(
name|getLegalIndex
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|points
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// We have to find the next point that is not on the plane between start and end.
comment|// If there is no such point, it's an error.
specifier|final
name|Plane
name|planeToFind
init|=
operator|new
name|Plane
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|int
name|endPointIndex
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|points
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|int
name|index
init|=
name|getLegalIndex
argument_list|(
name|j
operator|+
name|i
operator|+
literal|2
argument_list|,
name|points
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|planeToFind
operator|.
name|evaluateIsZero
argument_list|(
name|points
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
block|{
name|endPointIndex
operator|=
name|index
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|endPointIndex
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// Modify the edge buffer
name|edgeBuffer
operator|.
name|replace
argument_list|(
name|edges
argument_list|,
name|returnEdge
argument_list|)
expr_stmt|;
block|}
comment|// Now, construct the polygon
if|if
condition|(
name|testPoint
operator|!=
literal|null
operator|&&
name|holes
operator|!=
literal|null
operator|&&
name|holes
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// No holes, for test
specifier|final
name|GeoPolygon
name|testPolygon
init|=
operator|new
name|GeoConvexPolygon
argument_list|(
name|planetModel
argument_list|,
name|points
argument_list|,
literal|null
argument_list|,
name|internalEdges
argument_list|,
name|returnIsInternal
argument_list|)
decl_stmt|;
if|if
condition|(
name|testPolygon
operator|.
name|isWithin
argument_list|(
name|testPoint
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|final
name|GeoPolygon
name|realPolygon
init|=
operator|new
name|GeoConvexPolygon
argument_list|(
name|planetModel
argument_list|,
name|points
argument_list|,
name|holes
argument_list|,
name|internalEdges
argument_list|,
name|returnIsInternal
argument_list|)
decl_stmt|;
if|if
condition|(
name|testPoint
operator|!=
literal|null
operator|&&
operator|(
name|holes
operator|==
literal|null
operator|||
name|holes
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|realPolygon
operator|.
name|isWithin
argument_list|(
name|testPoint
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
name|rval
operator|.
name|addShape
argument_list|(
name|realPolygon
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/** Check if a point is within a set of edges.     * @param point is the point     * @param edgeSet is the set of edges     * @param extension is the new edge     * @param returnBoundary is the return edge     * @return true if within     */
DECL|method|isWithin
specifier|private
specifier|static
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Edge
argument_list|>
name|edgeSet
parameter_list|,
specifier|final
name|Edge
name|extension
parameter_list|,
specifier|final
name|SidedPlane
name|returnBoundary
parameter_list|)
block|{
if|if
condition|(
operator|!
name|extension
operator|.
name|plane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|returnBoundary
operator|!=
literal|null
operator|&&
operator|!
name|returnBoundary
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|isWithin
argument_list|(
name|point
argument_list|,
name|edgeSet
argument_list|)
return|;
block|}
comment|/** Check if a point is within a set of edges.     * @param point is the point     * @param edgeSet is the set of edges     * @return true if within     */
DECL|method|isWithin
specifier|private
specifier|static
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Edge
argument_list|>
name|edgeSet
parameter_list|)
block|{
for|for
control|(
specifier|final
name|Edge
name|edge
range|:
name|edgeSet
control|)
block|{
if|if
condition|(
operator|!
name|edge
operator|.
name|plane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/** Convert raw point index into valid array position.    *@param index is the array index.    *@param size is the array size.    *@return an updated index.    */
DECL|method|getLegalIndex
specifier|private
specifier|static
name|int
name|getLegalIndex
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|size
parameter_list|)
block|{
while|while
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|index
operator|+=
name|size
expr_stmt|;
block|}
while|while
condition|(
name|index
operator|>=
name|size
condition|)
block|{
name|index
operator|-=
name|size
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
comment|/** Class representing a single (unused) edge.    */
DECL|class|Edge
specifier|private
specifier|static
class|class
name|Edge
block|{
comment|/** Plane */
DECL|field|plane
specifier|public
specifier|final
name|SidedPlane
name|plane
decl_stmt|;
comment|/** Start point */
DECL|field|startPoint
specifier|public
specifier|final
name|GeoPoint
name|startPoint
decl_stmt|;
comment|/** End point */
DECL|field|endPoint
specifier|public
specifier|final
name|GeoPoint
name|endPoint
decl_stmt|;
comment|/** Internal edge flag */
DECL|field|isInternal
specifier|public
specifier|final
name|boolean
name|isInternal
decl_stmt|;
comment|/** Constructor.       * @param startPoint the edge start point       * @param endPoint the edge end point       * @param plane the edge plane       * @param isInternal true if internal edge       */
DECL|method|Edge
specifier|public
name|Edge
parameter_list|(
specifier|final
name|GeoPoint
name|startPoint
parameter_list|,
specifier|final
name|GeoPoint
name|endPoint
parameter_list|,
specifier|final
name|SidedPlane
name|plane
parameter_list|,
specifier|final
name|boolean
name|isInternal
parameter_list|)
block|{
name|this
operator|.
name|startPoint
operator|=
name|startPoint
expr_stmt|;
name|this
operator|.
name|endPoint
operator|=
name|endPoint
expr_stmt|;
name|this
operator|.
name|plane
operator|=
name|plane
expr_stmt|;
name|this
operator|.
name|isInternal
operator|=
name|isInternal
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|System
operator|.
name|identityHashCode
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
specifier|final
name|Object
name|o
parameter_list|)
block|{
return|return
name|o
operator|==
name|this
return|;
block|}
block|}
comment|/** Class representing an iterator over an EdgeBuffer.    */
DECL|class|EdgeBufferIterator
specifier|private
specifier|static
class|class
name|EdgeBufferIterator
implements|implements
name|Iterator
argument_list|<
name|Edge
argument_list|>
block|{
comment|/** Edge buffer */
DECL|field|edgeBuffer
specifier|protected
specifier|final
name|EdgeBuffer
name|edgeBuffer
decl_stmt|;
comment|/** First edge */
DECL|field|firstEdge
specifier|protected
specifier|final
name|Edge
name|firstEdge
decl_stmt|;
comment|/** Current edge */
DECL|field|currentEdge
specifier|protected
name|Edge
name|currentEdge
decl_stmt|;
comment|/** Constructor.       * @param edgeBuffer the edge buffer       */
DECL|method|EdgeBufferIterator
specifier|public
name|EdgeBufferIterator
parameter_list|(
specifier|final
name|EdgeBuffer
name|edgeBuffer
parameter_list|)
block|{
name|this
operator|.
name|edgeBuffer
operator|=
name|edgeBuffer
expr_stmt|;
name|this
operator|.
name|currentEdge
operator|=
name|edgeBuffer
operator|.
name|pickOne
argument_list|()
expr_stmt|;
name|this
operator|.
name|firstEdge
operator|=
name|currentEdge
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|currentEdge
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|Edge
name|next
parameter_list|()
block|{
specifier|final
name|Edge
name|rval
init|=
name|currentEdge
decl_stmt|;
if|if
condition|(
name|currentEdge
operator|!=
literal|null
condition|)
block|{
name|currentEdge
operator|=
name|edgeBuffer
operator|.
name|getNext
argument_list|(
name|currentEdge
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentEdge
operator|==
name|firstEdge
condition|)
block|{
name|currentEdge
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|return
name|rval
return|;
block|}
annotation|@
name|Override
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported operation"
argument_list|)
throw|;
block|}
block|}
comment|/** Class representing a pool of unused edges, all linked together by vertices.    */
DECL|class|EdgeBuffer
specifier|private
specifier|static
class|class
name|EdgeBuffer
block|{
comment|/** Starting edge */
DECL|field|oneEdge
specifier|protected
name|Edge
name|oneEdge
decl_stmt|;
comment|/** Full set of edges */
DECL|field|edges
specifier|protected
specifier|final
name|Set
argument_list|<
name|Edge
argument_list|>
name|edges
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Map to previous edge */
DECL|field|previousEdges
specifier|protected
specifier|final
name|Map
argument_list|<
name|Edge
argument_list|,
name|Edge
argument_list|>
name|previousEdges
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Map to next edge */
DECL|field|nextEdges
specifier|protected
specifier|final
name|Map
argument_list|<
name|Edge
argument_list|,
name|Edge
argument_list|>
name|nextEdges
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Constructor.       * @param pointList is the list of points.       * @param internalEdges is the list of edges that are internal (includes return edge)       * @param startPlaneStartIndex is the index of the startPlane's starting point       * @param startPlaneEndIndex is the index of the startPlane's ending point       * @param startPlane is the starting plane       */
DECL|method|EdgeBuffer
specifier|public
name|EdgeBuffer
parameter_list|(
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointList
parameter_list|,
specifier|final
name|BitSet
name|internalEdges
parameter_list|,
specifier|final
name|int
name|startPlaneStartIndex
parameter_list|,
specifier|final
name|int
name|startPlaneEndIndex
parameter_list|,
specifier|final
name|SidedPlane
name|startPlane
parameter_list|)
block|{
comment|/*       System.out.println("Start plane index: "+startPlaneStartIndex+" End plane index: "+startPlaneEndIndex+" Initial points:");       for (final GeoPoint p : pointList) {         System.out.println(" "+p);       }       */
specifier|final
name|Edge
name|startEdge
init|=
operator|new
name|Edge
argument_list|(
name|pointList
operator|.
name|get
argument_list|(
name|startPlaneStartIndex
argument_list|)
argument_list|,
name|pointList
operator|.
name|get
argument_list|(
name|startPlaneEndIndex
argument_list|)
argument_list|,
name|startPlane
argument_list|,
name|internalEdges
operator|.
name|get
argument_list|(
name|startPlaneStartIndex
argument_list|)
argument_list|)
decl_stmt|;
comment|// Fill in the EdgeBuffer by walking around creating more stuff
name|Edge
name|currentEdge
init|=
name|startEdge
decl_stmt|;
name|int
name|startIndex
init|=
name|startPlaneStartIndex
decl_stmt|;
name|int
name|endIndex
init|=
name|startPlaneEndIndex
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|/*         System.out.println("For plane "+currentEdge.plane+", the following points are in/out:");         for (final GeoPoint p: pointList) {           System.out.println(" "+p+" is: "+(currentEdge.plane.isWithin(p)?"in":"out"));         }         */
comment|// Check termination condition
if|if
condition|(
name|currentEdge
operator|.
name|endPoint
operator|==
name|startEdge
operator|.
name|startPoint
condition|)
block|{
comment|// We finish here.  Link the current edge to the start edge, and exit
name|previousEdges
operator|.
name|put
argument_list|(
name|startEdge
argument_list|,
name|currentEdge
argument_list|)
expr_stmt|;
name|nextEdges
operator|.
name|put
argument_list|(
name|currentEdge
argument_list|,
name|startEdge
argument_list|)
expr_stmt|;
name|edges
operator|.
name|add
argument_list|(
name|startEdge
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Compute the next edge
name|startIndex
operator|=
name|endIndex
expr_stmt|;
name|endIndex
operator|++
expr_stmt|;
if|if
condition|(
name|endIndex
operator|>=
name|pointList
operator|.
name|size
argument_list|()
condition|)
block|{
name|endIndex
operator|-=
name|pointList
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|// Get the next point
specifier|final
name|GeoPoint
name|newPoint
init|=
name|pointList
operator|.
name|get
argument_list|(
name|endIndex
argument_list|)
decl_stmt|;
comment|// Build the new edge
comment|// We need to know the sidedness of the new plane.  The point we're going to be presenting to it has
comment|// a certain relationship with the sided plane we already have for the current edge.  If the current edge
comment|// is colinear with the new edge, then we want to maintain the same relationship.  If the new edge
comment|// is not colinear, then we can use the new point's relationship with the current edge as our guide.
specifier|final
name|boolean
name|isNewPointWithin
init|=
name|currentEdge
operator|.
name|plane
operator|.
name|isWithin
argument_list|(
name|newPoint
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
name|pointToPresent
init|=
name|currentEdge
operator|.
name|startPoint
decl_stmt|;
specifier|final
name|SidedPlane
name|newPlane
init|=
operator|new
name|SidedPlane
argument_list|(
name|pointToPresent
argument_list|,
name|isNewPointWithin
argument_list|,
name|pointList
operator|.
name|get
argument_list|(
name|startIndex
argument_list|)
argument_list|,
name|newPoint
argument_list|)
decl_stmt|;
specifier|final
name|Edge
name|newEdge
init|=
operator|new
name|Edge
argument_list|(
name|pointList
operator|.
name|get
argument_list|(
name|startIndex
argument_list|)
argument_list|,
name|pointList
operator|.
name|get
argument_list|(
name|endIndex
argument_list|)
argument_list|,
name|newPlane
argument_list|,
name|internalEdges
operator|.
name|get
argument_list|(
name|startIndex
argument_list|)
argument_list|)
decl_stmt|;
comment|// Link it in
name|previousEdges
operator|.
name|put
argument_list|(
name|newEdge
argument_list|,
name|currentEdge
argument_list|)
expr_stmt|;
name|nextEdges
operator|.
name|put
argument_list|(
name|currentEdge
argument_list|,
name|newEdge
argument_list|)
expr_stmt|;
name|edges
operator|.
name|add
argument_list|(
name|newEdge
argument_list|)
expr_stmt|;
name|currentEdge
operator|=
name|newEdge
expr_stmt|;
block|}
name|oneEdge
operator|=
name|startEdge
expr_stmt|;
comment|// Verify the structure.
comment|//verify();
block|}
comment|/*     protected void verify() {       if (edges.size() != previousEdges.size() || edges.size() != nextEdges.size()) {         throw new IllegalStateException("broken structure");       }       // Confirm each edge       for (final Edge e : edges) {         final Edge previousEdge = getPrevious(e);         final Edge nextEdge = getNext(e);         if (e.endPoint != nextEdge.startPoint) {           throw new IllegalStateException("broken structure");         }         if (e.startPoint != previousEdge.endPoint) {           throw new IllegalStateException("broken structure");         }         if (getNext(previousEdge) != e) {           throw new IllegalStateException("broken structure");         }         if (getPrevious(nextEdge) != e) {           throw new IllegalStateException("broken structure");         }       }       if (oneEdge != null&& !edges.contains(oneEdge)) {         throw new IllegalStateException("broken structure");       }       if (oneEdge == null&& edges.size()> 0) {         throw new IllegalStateException("broken structure");       }     }     */
comment|/** Get the previous edge.       * @param currentEdge is the current edge.       * @return the previous edge, if found.       */
DECL|method|getPrevious
specifier|public
name|Edge
name|getPrevious
parameter_list|(
specifier|final
name|Edge
name|currentEdge
parameter_list|)
block|{
return|return
name|previousEdges
operator|.
name|get
argument_list|(
name|currentEdge
argument_list|)
return|;
block|}
comment|/** Get the next edge.       * @param currentEdge is the current edge.       * @return the next edge, if found.       */
DECL|method|getNext
specifier|public
name|Edge
name|getNext
parameter_list|(
specifier|final
name|Edge
name|currentEdge
parameter_list|)
block|{
return|return
name|nextEdges
operator|.
name|get
argument_list|(
name|currentEdge
argument_list|)
return|;
block|}
comment|/** Replace a list of edges with a new edge.       * @param removeList is the list of edges to remove.       * @param newEdge is the edge to add.       */
DECL|method|replace
specifier|public
name|void
name|replace
parameter_list|(
specifier|final
name|List
argument_list|<
name|Edge
argument_list|>
name|removeList
parameter_list|,
specifier|final
name|Edge
name|newEdge
parameter_list|)
block|{
comment|/*       System.out.println("Replacing: ");       for (final Edge e : removeList) {         System.out.println(" "+e.startPoint+"-->"+e.endPoint);       }       System.out.println("...with: "+newEdge.startPoint+"-->"+newEdge.endPoint);       */
specifier|final
name|Edge
name|previous
init|=
name|previousEdges
operator|.
name|get
argument_list|(
name|removeList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Edge
name|next
init|=
name|nextEdges
operator|.
name|get
argument_list|(
name|removeList
operator|.
name|get
argument_list|(
name|removeList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|edges
operator|.
name|add
argument_list|(
name|newEdge
argument_list|)
expr_stmt|;
name|previousEdges
operator|.
name|put
argument_list|(
name|newEdge
argument_list|,
name|previous
argument_list|)
expr_stmt|;
name|nextEdges
operator|.
name|put
argument_list|(
name|previous
argument_list|,
name|newEdge
argument_list|)
expr_stmt|;
name|previousEdges
operator|.
name|put
argument_list|(
name|next
argument_list|,
name|newEdge
argument_list|)
expr_stmt|;
name|nextEdges
operator|.
name|put
argument_list|(
name|newEdge
argument_list|,
name|next
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|Edge
name|edge
range|:
name|removeList
control|)
block|{
if|if
condition|(
name|edge
operator|==
name|oneEdge
condition|)
block|{
name|oneEdge
operator|=
name|newEdge
expr_stmt|;
block|}
name|edges
operator|.
name|remove
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|previousEdges
operator|.
name|remove
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|nextEdges
operator|.
name|remove
argument_list|(
name|edge
argument_list|)
expr_stmt|;
block|}
comment|//verify();
block|}
comment|/** Clear all edges.       */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|edges
operator|.
name|clear
argument_list|()
expr_stmt|;
name|previousEdges
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nextEdges
operator|.
name|clear
argument_list|()
expr_stmt|;
name|oneEdge
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Get the size of the edge buffer.       * @return the size.       */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|edges
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** Get an iterator to iterate over edges.       * @return the iterator.       */
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|Edge
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|EdgeBufferIterator
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/** Return a first edge.       * @return the edge.       */
DECL|method|pickOne
specifier|public
name|Edge
name|pickOne
parameter_list|()
block|{
return|return
name|oneEdge
return|;
block|}
block|}
comment|/** An instance of this class represents a known-good    * path of nodes that contains no coplanar points , no matter    * how assessed.  It's used in the depth-first search that    * must be executed to find a valid complete polygon without    * coplanarities.    */
DECL|class|SafePath
specifier|private
specifier|static
class|class
name|SafePath
block|{
DECL|field|lastPoint
specifier|public
specifier|final
name|GeoPoint
name|lastPoint
decl_stmt|;
DECL|field|lastPointIndex
specifier|public
specifier|final
name|int
name|lastPointIndex
decl_stmt|;
DECL|field|lastPlane
specifier|public
specifier|final
name|Plane
name|lastPlane
decl_stmt|;
DECL|field|previous
specifier|public
specifier|final
name|SafePath
name|previous
decl_stmt|;
comment|/** Create a new safe end point.      */
DECL|method|SafePath
specifier|public
name|SafePath
parameter_list|(
specifier|final
name|SafePath
name|previous
parameter_list|,
specifier|final
name|GeoPoint
name|lastPoint
parameter_list|,
specifier|final
name|int
name|lastPointIndex
parameter_list|,
specifier|final
name|Plane
name|lastPlane
parameter_list|)
block|{
name|this
operator|.
name|lastPoint
operator|=
name|lastPoint
expr_stmt|;
name|this
operator|.
name|lastPointIndex
operator|=
name|lastPointIndex
expr_stmt|;
name|this
operator|.
name|lastPlane
operator|=
name|lastPlane
expr_stmt|;
name|this
operator|.
name|previous
operator|=
name|previous
expr_stmt|;
block|}
comment|/** Find the first endpoint */
DECL|method|findFirstEndpoint
specifier|public
name|SafePath
name|findFirstEndpoint
parameter_list|()
block|{
if|if
condition|(
name|previous
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|previous
operator|.
name|previous
operator|==
literal|null
condition|)
block|{
return|return
name|this
return|;
block|}
return|return
name|previous
operator|.
name|findFirstEndpoint
argument_list|()
return|;
block|}
comment|/** Fill in a list, in order, of safe points.      */
DECL|method|fillInList
specifier|public
name|void
name|fillInList
parameter_list|(
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointList
parameter_list|)
block|{
if|if
condition|(
name|previous
operator|!=
literal|null
condition|)
block|{
name|previous
operator|.
name|fillInList
argument_list|(
name|pointList
argument_list|)
expr_stmt|;
block|}
name|pointList
operator|.
name|add
argument_list|(
name|lastPoint
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|MutableBoolean
specifier|static
class|class
name|MutableBoolean
block|{
DECL|field|value
specifier|public
name|boolean
name|value
init|=
literal|false
decl_stmt|;
block|}
block|}
end_class
end_unit
