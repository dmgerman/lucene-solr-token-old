begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.spatial3d.geom
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_comment
comment|/**  * Class which constructs a GeoMembershipShape representing an arbitrary polygon.  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|GeoPolygonFactory
specifier|public
class|class
name|GeoPolygonFactory
block|{
DECL|method|GeoPolygonFactory
specifier|private
name|GeoPolygonFactory
parameter_list|()
block|{   }
comment|/**    * Create a GeoMembershipShape of the right kind given the specified bounds.    *    * @param pointList        is a list of the GeoPoints to build an arbitrary polygon out of.    * @param convexPointIndex is the index of a single convex point whose conformation with    *                         its neighbors determines inside/outside for the entire polygon.    * @return a GeoPolygon corresponding to what was specified.    */
DECL|method|makeGeoPolygon
specifier|public
specifier|static
name|GeoPolygon
name|makeGeoPolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointList
parameter_list|,
specifier|final
name|int
name|convexPointIndex
parameter_list|)
block|{
return|return
name|makeGeoPolygon
argument_list|(
name|planetModel
argument_list|,
name|pointList
argument_list|,
name|convexPointIndex
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Create a GeoMembershipShape of the right kind given the specified bounds.    *    * @param pointList        is a list of the GeoPoints to build an arbitrary polygon out of.    * @param convexPointIndex is the index of a single convex point whose conformation with    *                         its neighbors determines inside/outside for the entire polygon.    * @param holes is a list of polygons representing "holes" in the outside polygon.  Null == none.    * @return a GeoPolygon corresponding to what was specified.    */
DECL|method|makeGeoPolygon
specifier|public
specifier|static
name|GeoPolygon
name|makeGeoPolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointList
parameter_list|,
specifier|final
name|int
name|convexPointIndex
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPolygon
argument_list|>
name|holes
parameter_list|)
block|{
comment|// The basic operation uses a set of points, two points determining one particular edge, and a sided plane
comment|// describing membership.
specifier|final
name|GeoCompositePolygon
name|rval
init|=
operator|new
name|GeoCompositePolygon
argument_list|()
decl_stmt|;
if|if
condition|(
name|buildPolygonShape
argument_list|(
name|rval
argument_list|,
name|planetModel
argument_list|,
name|pointList
argument_list|,
operator|new
name|BitSet
argument_list|()
argument_list|,
name|convexPointIndex
argument_list|,
name|getLegalIndex
argument_list|(
name|convexPointIndex
operator|+
literal|1
argument_list|,
name|pointList
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
operator|new
name|SidedPlane
argument_list|(
name|pointList
operator|.
name|get
argument_list|(
name|getLegalIndex
argument_list|(
name|convexPointIndex
operator|-
literal|1
argument_list|,
name|pointList
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|pointList
operator|.
name|get
argument_list|(
name|convexPointIndex
argument_list|)
argument_list|,
name|pointList
operator|.
name|get
argument_list|(
name|getLegalIndex
argument_list|(
name|convexPointIndex
operator|+
literal|1
argument_list|,
name|pointList
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|holes
argument_list|,
literal|null
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|rval
return|;
block|}
comment|/** Create a GeoPolygon using the specified points and holes, using order to determine     * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space    * on the same side of the shape as being inside, and counter-clockwise to indicate the    * space on the opposite side as being inside.    * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go    *  clockwise from a given pole, then that pole should be within the polygon.  If points go    *  counter-clockwise, then that pole should be outside the polygon.    * @return a GeoPolygon corresponding to what was specified.    */
DECL|method|makeGeoPolygon
specifier|public
specifier|static
name|GeoPolygon
name|makeGeoPolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointList
parameter_list|)
block|{
return|return
name|makeGeoPolygon
argument_list|(
name|planetModel
argument_list|,
name|pointList
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Create a GeoPolygon using the specified points and holes, using order to determine     * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space    * on the same side of the shape as being inside, and counter-clockwise to indicate the    * space on the opposite side as being inside.    * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go    *  clockwise from a given pole, then that pole should be within the polygon.  If points go    *  counter-clockwise, then that pole should be outside the polygon.    * @param holes is a list of polygons representing "holes" in the outside polygon.  Null == none.    * @return a GeoPolygon corresponding to what was specified.    */
DECL|method|makeGeoPolygon
specifier|public
specifier|static
name|GeoPolygon
name|makeGeoPolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointList
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPolygon
argument_list|>
name|holes
parameter_list|)
block|{
comment|// Create a random number generator.  Effectively this furnishes us with a repeatable sequence
comment|// of points to use for poles.
specifier|final
name|Random
name|generator
init|=
operator|new
name|Random
argument_list|(
literal|1234
argument_list|)
decl_stmt|;
comment|//int counter = 0;
while|while
condition|(
literal|true
condition|)
block|{
comment|//counter++;
comment|// Pick the next random pole
specifier|final
name|GeoPoint
name|pole
init|=
name|pickPole
argument_list|(
name|generator
argument_list|,
name|planetModel
argument_list|,
name|pointList
argument_list|)
decl_stmt|;
comment|// Is it inside or outside?
specifier|final
name|Boolean
name|isPoleInside
init|=
name|isInsidePolygon
argument_list|(
name|pole
argument_list|,
name|pointList
argument_list|)
decl_stmt|;
if|if
condition|(
name|isPoleInside
operator|!=
literal|null
condition|)
block|{
comment|// Legal pole
comment|//System.out.println("Took "+counter+" iterations to find pole");
comment|//System.out.println("Pole = "+pole+"; isInside="+isPoleInside+"; pointList = "+pointList);
return|return
name|makeGeoPolygon
argument_list|(
name|planetModel
argument_list|,
name|pointList
argument_list|,
name|holes
argument_list|,
name|pole
argument_list|,
name|isPoleInside
argument_list|)
return|;
block|}
comment|// If pole choice was illegal, try another one
block|}
block|}
comment|/**    * Create a GeoPolygon using the specified points and holes and a test point.    *    * @param pointList        is a list of the GeoPoints to build an arbitrary polygon out of.    * @param holes is a list of polygons representing "holes" in the outside polygon.  Null == none.    * @param testPoint is a test point that is either known to be within the polygon area, or not.    * @param testPointInside is true if the test point is within the area, false otherwise.    * @return a GeoPolygon corresponding to what was specified.    */
DECL|method|makeGeoPolygon
specifier|public
specifier|static
name|GeoPolygon
name|makeGeoPolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointList
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPolygon
argument_list|>
name|holes
parameter_list|,
specifier|final
name|GeoPoint
name|testPoint
parameter_list|,
specifier|final
name|boolean
name|testPointInside
parameter_list|)
block|{
comment|// We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon
comment|// side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can
comment|// find.
specifier|final
name|SidedPlane
name|initialPlane
init|=
operator|new
name|SidedPlane
argument_list|(
name|testPoint
argument_list|,
name|pointList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|pointList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|// We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.
comment|// So we need to be prepared to try both possibilities.
name|GeoCompositePolygon
name|rval
init|=
operator|new
name|GeoCompositePolygon
argument_list|()
decl_stmt|;
if|if
condition|(
name|buildPolygonShape
argument_list|(
name|rval
argument_list|,
name|planetModel
argument_list|,
name|pointList
argument_list|,
operator|new
name|BitSet
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|initialPlane
argument_list|,
name|holes
argument_list|,
name|testPoint
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// The testPoint was within the shape.  Was that intended?
if|if
condition|(
name|testPointInside
condition|)
block|{
comment|// Yes: build it for real
name|rval
operator|=
operator|new
name|GeoCompositePolygon
argument_list|()
expr_stmt|;
name|buildPolygonShape
argument_list|(
name|rval
argument_list|,
name|planetModel
argument_list|,
name|pointList
argument_list|,
operator|new
name|BitSet
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|initialPlane
argument_list|,
name|holes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
comment|// No: do the complement and return that.
name|rval
operator|=
operator|new
name|GeoCompositePolygon
argument_list|()
expr_stmt|;
name|buildPolygonShape
argument_list|(
name|rval
argument_list|,
name|planetModel
argument_list|,
name|pointList
argument_list|,
operator|new
name|BitSet
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|new
name|SidedPlane
argument_list|(
name|initialPlane
argument_list|)
argument_list|,
name|holes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
else|else
block|{
comment|// The testPoint was outside the shape.  Was that intended?
if|if
condition|(
operator|!
name|testPointInside
condition|)
block|{
comment|// Yes: return what we just built
return|return
name|rval
return|;
block|}
comment|// No: return the complement
name|rval
operator|=
operator|new
name|GeoCompositePolygon
argument_list|()
expr_stmt|;
name|buildPolygonShape
argument_list|(
name|rval
argument_list|,
name|planetModel
argument_list|,
name|pointList
argument_list|,
operator|new
name|BitSet
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|new
name|SidedPlane
argument_list|(
name|initialPlane
argument_list|)
argument_list|,
name|holes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
block|}
comment|/** The maximum distance from the close point to the trial pole: 2 degrees */
DECL|field|MAX_POLE_DISTANCE
specifier|private
specifier|final
specifier|static
name|double
name|MAX_POLE_DISTANCE
init|=
name|Math
operator|.
name|PI
operator|*
literal|2.0
operator|/
literal|180.0
decl_stmt|;
comment|/** Pick a random pole that has a good chance of being inside the polygon described by the points.    * @param generator is the random number generator to use.    * @param planetModel is the planet model to use.    * @param points is the list of points available.    * @return the randomly-determined pole selection.    */
DECL|method|pickPole
specifier|private
specifier|static
name|GeoPoint
name|pickPole
parameter_list|(
specifier|final
name|Random
name|generator
parameter_list|,
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|points
parameter_list|)
block|{
specifier|final
name|int
name|pointIndex
init|=
name|generator
operator|.
name|nextInt
argument_list|(
name|points
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
name|closePoint
init|=
name|points
operator|.
name|get
argument_list|(
name|pointIndex
argument_list|)
decl_stmt|;
comment|// We pick a random angle and random arc distance, then generate a point based on closePoint
specifier|final
name|double
name|angle
init|=
name|generator
operator|.
name|nextDouble
argument_list|()
operator|*
name|Math
operator|.
name|PI
operator|*
literal|2.0
operator|-
name|Math
operator|.
name|PI
decl_stmt|;
specifier|final
name|double
name|arcDistance
init|=
name|MAX_POLE_DISTANCE
operator|-
name|generator
operator|.
name|nextDouble
argument_list|()
operator|*
name|MAX_POLE_DISTANCE
decl_stmt|;
comment|// We come up with a unit circle (x,y,z) coordinate given the random angle and arc distance.  The point is centered around the positive x axis.
specifier|final
name|double
name|x
init|=
name|Math
operator|.
name|cos
argument_list|(
name|arcDistance
argument_list|)
decl_stmt|;
specifier|final
name|double
name|sinArcDistance
init|=
name|Math
operator|.
name|sin
argument_list|(
name|arcDistance
argument_list|)
decl_stmt|;
specifier|final
name|double
name|y
init|=
name|Math
operator|.
name|cos
argument_list|(
name|angle
argument_list|)
operator|*
name|sinArcDistance
decl_stmt|;
specifier|final
name|double
name|z
init|=
name|Math
operator|.
name|sin
argument_list|(
name|angle
argument_list|)
operator|*
name|sinArcDistance
decl_stmt|;
comment|// Now, use closePoint for a rotation pole
specifier|final
name|double
name|sinLatitude
init|=
name|Math
operator|.
name|sin
argument_list|(
name|closePoint
operator|.
name|getLatitude
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|double
name|cosLatitude
init|=
name|Math
operator|.
name|cos
argument_list|(
name|closePoint
operator|.
name|getLatitude
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|double
name|sinLongitude
init|=
name|Math
operator|.
name|sin
argument_list|(
name|closePoint
operator|.
name|getLongitude
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|double
name|cosLongitude
init|=
name|Math
operator|.
name|cos
argument_list|(
name|closePoint
operator|.
name|getLongitude
argument_list|()
argument_list|)
decl_stmt|;
comment|// This transformation should take the point (1,0,0) and transform it to the closepoint's actual (x,y,z) coordinates.
comment|// Coordinate rotation formula:
comment|// x1 = x0 cos T - y0 sin T
comment|// y1 = x0 sin T + y0 cos T
comment|// We're in essence undoing the following transformation (from GeoPolygonFactory):
comment|// x1 = x0 cos az + y0 sin az
comment|// y1 = - x0 sin az + y0 cos az
comment|// z1 = z0
comment|// x2 = x1 cos al + z1 sin al
comment|// y2 = y1
comment|// z2 = - x1 sin al + z1 cos al
comment|// So, we reverse the order of the transformations, AND we transform backwards.
comment|// Transforming backwards means using these identities: sin(-angle) = -sin(angle), cos(-angle) = cos(angle)
comment|// So:
comment|// x1 = x0 cos al - z0 sin al
comment|// y1 = y0
comment|// z1 = x0 sin al + z0 cos al
comment|// x2 = x1 cos az - y1 sin az
comment|// y2 = x1 sin az + y1 cos az
comment|// z2 = z1
specifier|final
name|double
name|x1
init|=
name|x
operator|*
name|cosLatitude
operator|-
name|z
operator|*
name|sinLatitude
decl_stmt|;
specifier|final
name|double
name|y1
init|=
name|y
decl_stmt|;
specifier|final
name|double
name|z1
init|=
name|x
operator|*
name|sinLatitude
operator|+
name|z
operator|*
name|cosLatitude
decl_stmt|;
specifier|final
name|double
name|x2
init|=
name|x1
operator|*
name|cosLongitude
operator|-
name|y1
operator|*
name|sinLongitude
decl_stmt|;
specifier|final
name|double
name|y2
init|=
name|x1
operator|*
name|sinLongitude
operator|+
name|y1
operator|*
name|cosLongitude
decl_stmt|;
specifier|final
name|double
name|z2
init|=
name|z1
decl_stmt|;
comment|// Finally, scale to put the point on the surface
return|return
name|planetModel
operator|.
name|createSurfacePoint
argument_list|(
name|x2
argument_list|,
name|y2
argument_list|,
name|z2
argument_list|)
return|;
block|}
comment|/** For a specified point and a list of poly points, determine based on point order whether the    * point should be considered in or out of the polygon.    * @param point is the point to check.    * @param polyPoints is the list of points comprising the polygon.    * @return null if the point is illegal, otherwise false if the point is inside and true if the point is outside    * of the polygon.    */
DECL|method|isInsidePolygon
specifier|private
specifier|static
name|Boolean
name|isInsidePolygon
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|polyPoints
parameter_list|)
block|{
comment|// First, compute sine and cosine of pole point latitude and longitude
specifier|final
name|double
name|latitude
init|=
name|point
operator|.
name|getLatitude
argument_list|()
decl_stmt|;
specifier|final
name|double
name|longitude
init|=
name|point
operator|.
name|getLongitude
argument_list|()
decl_stmt|;
specifier|final
name|double
name|sinLatitude
init|=
name|Math
operator|.
name|sin
argument_list|(
name|latitude
argument_list|)
decl_stmt|;
specifier|final
name|double
name|cosLatitude
init|=
name|Math
operator|.
name|cos
argument_list|(
name|latitude
argument_list|)
decl_stmt|;
specifier|final
name|double
name|sinLongitude
init|=
name|Math
operator|.
name|sin
argument_list|(
name|longitude
argument_list|)
decl_stmt|;
specifier|final
name|double
name|cosLongitude
init|=
name|Math
operator|.
name|cos
argument_list|(
name|longitude
argument_list|)
decl_stmt|;
comment|// Now, compute the incremental arc distance around the points of the polygon
name|double
name|arcDistance
init|=
literal|0.0
decl_stmt|;
name|Double
name|prevAngle
init|=
literal|null
decl_stmt|;
comment|//System.out.println("Computing angles:");
for|for
control|(
specifier|final
name|GeoPoint
name|polyPoint
range|:
name|polyPoints
control|)
block|{
specifier|final
name|Double
name|angle
init|=
name|computeAngle
argument_list|(
name|polyPoint
argument_list|,
name|sinLatitude
argument_list|,
name|cosLatitude
argument_list|,
name|sinLongitude
argument_list|,
name|cosLongitude
argument_list|)
decl_stmt|;
if|if
condition|(
name|angle
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//System.out.println("Computed angle: "+angle);
if|if
condition|(
name|prevAngle
operator|!=
literal|null
condition|)
block|{
comment|// Figure out delta between prevAngle and current angle, and add it to arcDistance
name|double
name|angleDelta
init|=
name|angle
operator|-
name|prevAngle
decl_stmt|;
if|if
condition|(
name|angleDelta
operator|<
operator|-
name|Math
operator|.
name|PI
condition|)
block|{
name|angleDelta
operator|+=
name|Math
operator|.
name|PI
operator|*
literal|2.0
expr_stmt|;
block|}
if|if
condition|(
name|angleDelta
operator|>
name|Math
operator|.
name|PI
condition|)
block|{
name|angleDelta
operator|-=
name|Math
operator|.
name|PI
operator|*
literal|2.0
expr_stmt|;
block|}
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|angleDelta
operator|-
name|Math
operator|.
name|PI
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//System.out.println(" angle delta = "+angleDelta);
name|arcDistance
operator|+=
name|angleDelta
expr_stmt|;
comment|//System.out.println(" For point "+polyPoint+" angle is "+angle+"; delta is "+angleDelta+"; arcDistance is "+arcDistance);
block|}
name|prevAngle
operator|=
name|angle
expr_stmt|;
block|}
if|if
condition|(
name|prevAngle
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Double
name|lastAngle
init|=
name|computeAngle
argument_list|(
name|polyPoints
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|sinLatitude
argument_list|,
name|cosLatitude
argument_list|,
name|sinLongitude
argument_list|,
name|cosLongitude
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastAngle
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//System.out.println("Computed last angle: "+lastAngle);
comment|// Figure out delta and add it
name|double
name|angleDelta
init|=
name|lastAngle
operator|-
name|prevAngle
decl_stmt|;
if|if
condition|(
name|angleDelta
operator|<
operator|-
name|Math
operator|.
name|PI
condition|)
block|{
name|angleDelta
operator|+=
name|Math
operator|.
name|PI
operator|*
literal|2.0
expr_stmt|;
block|}
if|if
condition|(
name|angleDelta
operator|>
name|Math
operator|.
name|PI
condition|)
block|{
name|angleDelta
operator|-=
name|Math
operator|.
name|PI
operator|*
literal|2.0
expr_stmt|;
block|}
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|angleDelta
operator|-
name|Math
operator|.
name|PI
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//System.out.println(" angle delta = "+angleDelta);
name|arcDistance
operator|+=
name|angleDelta
expr_stmt|;
comment|//System.out.println(" For point "+polyPoints.get(0)+" angle is "+lastAngle+"; delta is "+angleDelta+"; arcDistance is "+arcDistance);
block|}
comment|// Clockwise == inside == negative
comment|//System.out.println("Arcdistance = "+arcDistance);
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|arcDistance
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
condition|)
block|{
comment|// No idea what direction, so try another pole.
return|return
literal|null
return|;
block|}
return|return
name|arcDistance
operator|>
literal|0.0
return|;
block|}
comment|/** Compute the angle for a point given rotation information.     * @param point is the point to assess     * @param sinLatitude the sine of the latitude     * @param cosLatitude the cosine of the latitude     * @param sinLongitude the sine of the longitude     * @param cosLongitude the cosine of the longitude     * @return the angle of rotation, or null if not computable     */
DECL|method|computeAngle
specifier|private
specifier|static
name|Double
name|computeAngle
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|double
name|sinLatitude
parameter_list|,
specifier|final
name|double
name|cosLatitude
parameter_list|,
specifier|final
name|double
name|sinLongitude
parameter_list|,
specifier|final
name|double
name|cosLongitude
parameter_list|)
block|{
comment|// Coordinate rotation formula:
comment|// x1 = x0 cos T - y0 sin T
comment|// y1 = x0 sin T + y0 cos T
comment|// We need to rotate the point in question into the coordinate frame specified by
comment|// the lat and lon trig functions.
comment|// To do this we need to do two rotations on it.  First rotation is in x/y.  Second rotation is in x/z.
comment|// And we rotate in the negative direction.
comment|// So:
comment|// x1 = x0 cos az + y0 sin az
comment|// y1 = - x0 sin az + y0 cos az
comment|// z1 = z0
comment|// x2 = x1 cos al + z1 sin al
comment|// y2 = y1
comment|// z2 = - x1 sin al + z1 cos al
specifier|final
name|double
name|x1
init|=
name|point
operator|.
name|x
operator|*
name|cosLongitude
operator|+
name|point
operator|.
name|y
operator|*
name|sinLongitude
decl_stmt|;
specifier|final
name|double
name|y1
init|=
operator|-
name|point
operator|.
name|x
operator|*
name|sinLongitude
operator|+
name|point
operator|.
name|y
operator|*
name|cosLongitude
decl_stmt|;
specifier|final
name|double
name|z1
init|=
name|point
operator|.
name|z
decl_stmt|;
comment|// final double x2 = x1 * cosLatitude + z1 * sinLatitude;
specifier|final
name|double
name|y2
init|=
name|y1
decl_stmt|;
specifier|final
name|double
name|z2
init|=
operator|-
name|x1
operator|*
name|sinLatitude
operator|+
name|z1
operator|*
name|cosLatitude
decl_stmt|;
comment|// Now we should be looking down the X axis; the original point has rotated coordinates (N, 0, 0).
comment|// So we can just compute the angle using y2 and z2.  (If Math.sqrt(y2*y2 + z2 * z2) is 0.0, then the point is on the pole and we need another one).
if|if
condition|(
name|Math
operator|.
name|sqrt
argument_list|(
name|y2
operator|*
name|y2
operator|+
name|z2
operator|*
name|z2
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|Math
operator|.
name|atan2
argument_list|(
name|z2
argument_list|,
name|y2
argument_list|)
return|;
block|}
comment|/** Build a GeoPolygon out of one concave part and multiple convex parts given points, starting edge, and whether starting edge is internal or not.    * @param rval is the composite polygon to add to.    * @param planetModel is the planet model.    * @param pointsList is a list of the GeoPoints to build an arbitrary polygon out of.    * @param internalEdges specifies which edges are internal.    * @param startPointIndex is the first of the points, constituting the starting edge.    * @param startingEdge is the plane describing the starting edge.    * @param holes is the list of holes in the polygon, or null if none.    * @param testPoint is an (optional) test point, which will be used to determine if we are generating    *  a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside    *  of the generated polygon.  In this case, if the generated polygon is found to contain the point, the    *  method exits early with a null return value.    *  This only makes sense in the context of evaluating both possible choices and using logic to determine    *  which result to use.  If the test point is supposed to be within the shape, then it must be outside of the    *  complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the    *  original shape.  Either way, we can figure out the right thing to use.    * @return false if what was specified    *  was inconsistent with what we generated.  Specifically, if we specify an exterior point that is    *  found in the interior of the shape we create here we return false, which is a signal that we chose    *  our initial plane sidedness backwards.    */
DECL|method|buildPolygonShape
specifier|public
specifier|static
name|boolean
name|buildPolygonShape
parameter_list|(
specifier|final
name|GeoCompositePolygon
name|rval
parameter_list|,
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointsList
parameter_list|,
specifier|final
name|BitSet
name|internalEdges
parameter_list|,
specifier|final
name|int
name|startPointIndex
parameter_list|,
specifier|final
name|int
name|endPointIndex
parameter_list|,
specifier|final
name|SidedPlane
name|startingEdge
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPolygon
argument_list|>
name|holes
parameter_list|,
specifier|final
name|GeoPoint
name|testPoint
parameter_list|)
block|{
comment|// It could be the case that we need a concave polygon.  So we need to try and look for that case
comment|// as part of the general code for constructing complex polygons.
comment|// Note that there can be only one concave polygon.
comment|// The code here must keep track of two lists of sided planes.  The first list contains the planes consistent with
comment|// a concave polygon.  This list will grow and shrink.  The second list is built starting at the current edge that
comment|// was last consistent with the concave polygon, and contains all edges consistent with a convex polygon.
comment|// When that sequence of edges is done, then an internal edge is created and the identified points are converted to a
comment|// convex polygon.  That internal edge is used to extend the list of edges in the concave polygon edge list.
comment|// The edge buffer.
specifier|final
name|EdgeBuffer
name|edgeBuffer
init|=
operator|new
name|EdgeBuffer
argument_list|(
name|pointsList
argument_list|,
name|internalEdges
argument_list|,
name|startPointIndex
argument_list|,
name|endPointIndex
argument_list|,
name|startingEdge
argument_list|)
decl_stmt|;
comment|// Starting state:
comment|// The stopping point
name|Edge
name|stoppingPoint
init|=
name|edgeBuffer
operator|.
name|pickOne
argument_list|()
decl_stmt|;
comment|// The current edge
name|Edge
name|currentEdge
init|=
name|stoppingPoint
decl_stmt|;
comment|// Progressively look for convex sections.  If we find one, we emit it and replace it.
comment|// Keep going until we have been around once and nothing needed to change, and then
comment|// do the concave polygon, if necessary.
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|currentEdge
operator|==
literal|null
condition|)
block|{
comment|// We're done!
break|break;
block|}
comment|// Find convexity around the current edge, if any
specifier|final
name|Boolean
name|foundIt
init|=
name|findConvexPolygon
argument_list|(
name|planetModel
argument_list|,
name|currentEdge
argument_list|,
name|rval
argument_list|,
name|edgeBuffer
argument_list|,
name|holes
argument_list|,
name|testPoint
argument_list|)
decl_stmt|;
if|if
condition|(
name|foundIt
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|foundIt
condition|)
block|{
comment|// New start point
name|stoppingPoint
operator|=
name|edgeBuffer
operator|.
name|pickOne
argument_list|()
expr_stmt|;
name|currentEdge
operator|=
name|stoppingPoint
expr_stmt|;
comment|// back around
continue|continue;
block|}
comment|// Otherwise, go on to the next
name|currentEdge
operator|=
name|edgeBuffer
operator|.
name|getNext
argument_list|(
name|currentEdge
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentEdge
operator|==
name|stoppingPoint
condition|)
block|{
break|break;
block|}
block|}
comment|// Look for any reason that the concave polygon cannot be created.
comment|// This test is really the converse of the one for a convex polygon.
comment|// Points on the edge of a convex polygon MUST be inside all the other
comment|// edges.  For a concave polygon, this check is still the same, except we have
comment|// to look at the reverse sided planes, not the forward ones.
comment|// If we find a point that is outside of the complementary edges, it means that
comment|// the point is in fact able to form a convex polygon with the edge it is
comment|// offending.
comment|// If what is left has any plane/point pair that is on the wrong side, we have to split using one of the plane endpoints and the
comment|// point in question.  This is best structured as a recursion, if detected.
specifier|final
name|Iterator
argument_list|<
name|Edge
argument_list|>
name|checkIterator
init|=
name|edgeBuffer
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|checkIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|Edge
name|checkEdge
init|=
name|checkIterator
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|SidedPlane
name|flippedPlane
init|=
operator|new
name|SidedPlane
argument_list|(
name|checkEdge
operator|.
name|plane
argument_list|)
decl_stmt|;
comment|// Now walk around again looking for points that fail
specifier|final
name|Iterator
argument_list|<
name|Edge
argument_list|>
name|confirmIterator
init|=
name|edgeBuffer
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|confirmIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|Edge
name|confirmEdge
init|=
name|confirmIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|confirmEdge
operator|==
name|checkEdge
condition|)
block|{
continue|continue;
block|}
comment|// Look for a point that is on the wrong side of the check edge.  This means that we can't build the polygon.
specifier|final
name|GeoPoint
name|thePoint
decl_stmt|;
if|if
condition|(
name|checkEdge
operator|.
name|startPoint
operator|!=
name|confirmEdge
operator|.
name|startPoint
operator|&&
name|checkEdge
operator|.
name|endPoint
operator|!=
name|confirmEdge
operator|.
name|startPoint
operator|&&
operator|!
name|flippedPlane
operator|.
name|isWithin
argument_list|(
name|confirmEdge
operator|.
name|startPoint
argument_list|)
condition|)
block|{
name|thePoint
operator|=
name|confirmEdge
operator|.
name|startPoint
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|checkEdge
operator|.
name|startPoint
operator|!=
name|confirmEdge
operator|.
name|endPoint
operator|&&
name|checkEdge
operator|.
name|endPoint
operator|!=
name|confirmEdge
operator|.
name|endPoint
operator|&&
operator|!
name|flippedPlane
operator|.
name|isWithin
argument_list|(
name|confirmEdge
operator|.
name|endPoint
argument_list|)
condition|)
block|{
name|thePoint
operator|=
name|confirmEdge
operator|.
name|endPoint
expr_stmt|;
block|}
else|else
block|{
name|thePoint
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|thePoint
operator|!=
literal|null
condition|)
block|{
comment|// thePoint is on the wrong side of the complementary plane.  That means we cannot build a concave polygon, because the complement would not
comment|// be a legal convex polygon.
comment|// But we can take advantage of the fact that the distance between the edge and thePoint is less than 180 degrees, and so we can split the
comment|// would-be concave polygon into three segments.  The first segment includes the edge and thePoint, and uses the sense of the edge to determine the sense
comment|// of the polygon.
comment|// This should be the only problematic part of the polygon.
comment|// We know that thePoint is on the "wrong" side of the edge -- that is, it's on the side that the
comment|// edge is pointing at.
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|thirdPartPoints
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|BitSet
name|thirdPartInternal
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|thirdPartPoints
operator|.
name|add
argument_list|(
name|checkEdge
operator|.
name|startPoint
argument_list|)
expr_stmt|;
name|thirdPartInternal
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|checkEdge
operator|.
name|isInternal
argument_list|)
expr_stmt|;
name|thirdPartPoints
operator|.
name|add
argument_list|(
name|checkEdge
operator|.
name|endPoint
argument_list|)
expr_stmt|;
name|thirdPartInternal
operator|.
name|set
argument_list|(
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|thirdPartPoints
operator|.
name|add
argument_list|(
name|thePoint
argument_list|)
expr_stmt|;
name|thirdPartInternal
operator|.
name|set
argument_list|(
literal|2
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//System.out.println("Doing convex part...");
if|if
condition|(
name|buildPolygonShape
argument_list|(
name|rval
argument_list|,
name|planetModel
argument_list|,
name|thirdPartPoints
argument_list|,
name|thirdPartInternal
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|checkEdge
operator|.
name|plane
argument_list|,
name|holes
argument_list|,
name|testPoint
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//System.out.println("...done convex part.");
comment|// ??? check if we get the sense right
comment|// The part preceding the bad edge, back to thePoint, needs to be recursively
comment|// processed.  So, assemble what we need, which is basically a list of edges.
name|Edge
name|loopEdge
init|=
name|edgeBuffer
operator|.
name|getPrevious
argument_list|(
name|checkEdge
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|firstPartPoints
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|BitSet
name|firstPartInternal
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|firstPartPoints
operator|.
name|add
argument_list|(
name|loopEdge
operator|.
name|endPoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|loopEdge
operator|.
name|endPoint
operator|==
name|thePoint
condition|)
block|{
break|break;
block|}
name|firstPartInternal
operator|.
name|set
argument_list|(
name|i
operator|++
argument_list|,
name|loopEdge
operator|.
name|isInternal
argument_list|)
expr_stmt|;
name|loopEdge
operator|=
name|edgeBuffer
operator|.
name|getPrevious
argument_list|(
name|loopEdge
argument_list|)
expr_stmt|;
block|}
name|firstPartInternal
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//System.out.println("Doing first part...");
if|if
condition|(
name|buildPolygonShape
argument_list|(
name|rval
argument_list|,
name|planetModel
argument_list|,
name|firstPartPoints
argument_list|,
name|firstPartInternal
argument_list|,
name|firstPartPoints
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|new
name|SidedPlane
argument_list|(
name|checkEdge
operator|.
name|endPoint
argument_list|,
literal|false
argument_list|,
name|checkEdge
operator|.
name|startPoint
argument_list|,
name|thePoint
argument_list|)
argument_list|,
name|holes
argument_list|,
name|testPoint
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//System.out.println("...done first part.");
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|secondPartPoints
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|BitSet
name|secondPartInternal
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|loopEdge
operator|=
name|edgeBuffer
operator|.
name|getNext
argument_list|(
name|checkEdge
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|secondPartPoints
operator|.
name|add
argument_list|(
name|loopEdge
operator|.
name|startPoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|loopEdge
operator|.
name|startPoint
operator|==
name|thePoint
condition|)
block|{
break|break;
block|}
name|secondPartInternal
operator|.
name|set
argument_list|(
name|i
operator|++
argument_list|,
name|loopEdge
operator|.
name|isInternal
argument_list|)
expr_stmt|;
name|loopEdge
operator|=
name|edgeBuffer
operator|.
name|getNext
argument_list|(
name|loopEdge
argument_list|)
expr_stmt|;
block|}
name|secondPartInternal
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//System.out.println("Doing second part...");
if|if
condition|(
name|buildPolygonShape
argument_list|(
name|rval
argument_list|,
name|planetModel
argument_list|,
name|secondPartPoints
argument_list|,
name|secondPartInternal
argument_list|,
name|secondPartPoints
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|new
name|SidedPlane
argument_list|(
name|checkEdge
operator|.
name|startPoint
argument_list|,
literal|false
argument_list|,
name|checkEdge
operator|.
name|endPoint
argument_list|,
name|thePoint
argument_list|)
argument_list|,
name|holes
argument_list|,
name|testPoint
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//System.out.println("... done second part");
return|return
literal|true
return|;
block|}
block|}
block|}
comment|// No violations found: we know it's a legal concave polygon.
comment|// If there's anything left in the edge buffer, convert to concave polygon.
if|if
condition|(
name|makeConcavePolygon
argument_list|(
name|planetModel
argument_list|,
name|rval
argument_list|,
name|edgeBuffer
argument_list|,
name|holes
argument_list|,
name|testPoint
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Look for a concave polygon in the remainder of the edgebuffer.    * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.    * @param planetModel is the planet model.    * @param rval is the composite polygon we're building.    * @param edgeBuffer is the edge buffer.    * @param holes is the optional list of holes.    * @param testPoint is the optional test point.    * @return true unless the testPoint caused failure.    */
DECL|method|makeConcavePolygon
specifier|private
specifier|static
name|boolean
name|makeConcavePolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|GeoCompositePolygon
name|rval
parameter_list|,
specifier|final
name|EdgeBuffer
name|edgeBuffer
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPolygon
argument_list|>
name|holes
parameter_list|,
specifier|final
name|GeoPoint
name|testPoint
parameter_list|)
block|{
if|if
condition|(
name|edgeBuffer
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// If there are less than three edges, something got messed up somehow.  Don't know how this
comment|// can happen but check.
if|if
condition|(
name|edgeBuffer
operator|.
name|size
argument_list|()
operator|<
literal|3
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Ending edge buffer had only "
operator|+
name|edgeBuffer
operator|.
name|size
argument_list|()
operator|+
literal|" edges"
argument_list|)
throw|;
block|}
comment|// Create the list of points
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|points
init|=
operator|new
name|ArrayList
argument_list|<
name|GeoPoint
argument_list|>
argument_list|(
name|edgeBuffer
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|BitSet
name|internalEdges
init|=
operator|new
name|BitSet
argument_list|(
name|edgeBuffer
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|//System.out.println("Concave polygon points:");
name|Edge
name|edge
init|=
name|edgeBuffer
operator|.
name|pickOne
argument_list|()
decl_stmt|;
name|boolean
name|isInternal
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|edgeBuffer
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|//System.out.println(" "+edge.plane+": "+edge.startPoint+"->"+edge.endPoint+"; previous? "+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?"in":"out")+" next? "+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?"in":"out"));
name|points
operator|.
name|add
argument_list|(
name|edge
operator|.
name|startPoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|edgeBuffer
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|internalEdges
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|edge
operator|.
name|isInternal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isInternal
operator|=
name|edge
operator|.
name|isInternal
expr_stmt|;
block|}
name|edge
operator|=
name|edgeBuffer
operator|.
name|getNext
argument_list|(
name|edge
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|testPoint
operator|!=
literal|null
operator|&&
name|holes
operator|!=
literal|null
operator|&&
name|holes
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// No holes, for test
specifier|final
name|GeoPolygon
name|testPolygon
init|=
operator|new
name|GeoConcavePolygon
argument_list|(
name|planetModel
argument_list|,
name|points
argument_list|,
literal|null
argument_list|,
name|internalEdges
argument_list|,
name|isInternal
argument_list|)
decl_stmt|;
if|if
condition|(
name|testPolygon
operator|.
name|isWithin
argument_list|(
name|testPoint
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|final
name|GeoPolygon
name|realPolygon
init|=
operator|new
name|GeoConcavePolygon
argument_list|(
name|planetModel
argument_list|,
name|points
argument_list|,
name|holes
argument_list|,
name|internalEdges
argument_list|,
name|isInternal
argument_list|)
decl_stmt|;
if|if
condition|(
name|testPoint
operator|!=
literal|null
operator|&&
operator|(
name|holes
operator|==
literal|null
operator|||
name|holes
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|realPolygon
operator|.
name|isWithin
argument_list|(
name|testPoint
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|rval
operator|.
name|addShape
argument_list|(
name|realPolygon
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.    * @param planetModel is the planet model.    * @param currentEdge is the current edge to use starting the search.    * @param rval is the composite polygon to build.    * @param edgeBuffer is the edge buffer.    * @param holes is the optional list of holes.    * @param testPoint is the optional test point.    * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.    */
DECL|method|findConvexPolygon
specifier|private
specifier|static
name|Boolean
name|findConvexPolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|Edge
name|currentEdge
parameter_list|,
specifier|final
name|GeoCompositePolygon
name|rval
parameter_list|,
specifier|final
name|EdgeBuffer
name|edgeBuffer
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPolygon
argument_list|>
name|holes
parameter_list|,
specifier|final
name|GeoPoint
name|testPoint
parameter_list|)
block|{
comment|//System.out.println("Looking at edge "+currentEdge+" with startpoint "+currentEdge.startPoint+" endpoint "+currentEdge.endPoint);
comment|// Initialize the structure.
comment|// We don't keep track of order here; we just care about membership.
comment|// The only exception is the head and tail pointers.
specifier|final
name|Set
argument_list|<
name|Edge
argument_list|>
name|includedEdges
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|includedEdges
operator|.
name|add
argument_list|(
name|currentEdge
argument_list|)
expr_stmt|;
name|Edge
name|firstEdge
init|=
name|currentEdge
decl_stmt|;
name|Edge
name|lastEdge
init|=
name|currentEdge
decl_stmt|;
comment|// First, walk towards the end until we need to stop
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|firstEdge
operator|.
name|startPoint
operator|==
name|lastEdge
operator|.
name|endPoint
condition|)
block|{
break|break;
block|}
specifier|final
name|Edge
name|newLastEdge
init|=
name|edgeBuffer
operator|.
name|getNext
argument_list|(
name|lastEdge
argument_list|)
decl_stmt|;
if|if
condition|(
name|isWithin
argument_list|(
name|newLastEdge
operator|.
name|endPoint
argument_list|,
name|includedEdges
argument_list|)
condition|)
block|{
comment|//System.out.println(" maybe can extend to next edge");
comment|// Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon
comment|// here will overlap with other remaining points?
specifier|final
name|SidedPlane
name|returnBoundary
decl_stmt|;
if|if
condition|(
name|firstEdge
operator|.
name|startPoint
operator|!=
name|newLastEdge
operator|.
name|endPoint
condition|)
block|{
name|returnBoundary
operator|=
operator|new
name|SidedPlane
argument_list|(
name|firstEdge
operator|.
name|endPoint
argument_list|,
name|firstEdge
operator|.
name|startPoint
argument_list|,
name|newLastEdge
operator|.
name|endPoint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|returnBoundary
operator|=
literal|null
expr_stmt|;
block|}
comment|// The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,
comment|// plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.
name|boolean
name|foundPointInside
init|=
literal|false
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|Edge
argument_list|>
name|edgeIterator
init|=
name|edgeBuffer
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|edgeIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|Edge
name|edge
init|=
name|edgeIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|includedEdges
operator|.
name|contains
argument_list|(
name|edge
argument_list|)
operator|&&
name|edge
operator|!=
name|newLastEdge
condition|)
block|{
comment|// This edge has a point to check
if|if
condition|(
name|edge
operator|.
name|startPoint
operator|!=
name|newLastEdge
operator|.
name|endPoint
condition|)
block|{
comment|// look at edge.startPoint
if|if
condition|(
name|isWithin
argument_list|(
name|edge
operator|.
name|startPoint
argument_list|,
name|includedEdges
argument_list|,
name|newLastEdge
argument_list|,
name|returnBoundary
argument_list|)
condition|)
block|{
comment|//System.out.println("  nope; point within found: "+edge.startPoint);
name|foundPointInside
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|edge
operator|.
name|endPoint
operator|!=
name|firstEdge
operator|.
name|startPoint
condition|)
block|{
comment|// look at edge.endPoint
if|if
condition|(
name|isWithin
argument_list|(
name|edge
operator|.
name|endPoint
argument_list|,
name|includedEdges
argument_list|,
name|newLastEdge
argument_list|,
name|returnBoundary
argument_list|)
condition|)
block|{
comment|//System.out.println("  nope; point within found: "+edge.endPoint);
name|foundPointInside
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|foundPointInside
condition|)
block|{
comment|//System.out.println("  extending!");
comment|// Extend the polygon by the new last edge
name|includedEdges
operator|.
name|add
argument_list|(
name|newLastEdge
argument_list|)
expr_stmt|;
name|lastEdge
operator|=
name|newLastEdge
expr_stmt|;
comment|// continue extending in this direction
continue|continue;
block|}
block|}
comment|// We can't extend any more in this direction, so break from the loop.
break|break;
block|}
comment|// Now, walk towards the beginning until we need to stop
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|firstEdge
operator|.
name|startPoint
operator|==
name|lastEdge
operator|.
name|endPoint
condition|)
block|{
break|break;
block|}
specifier|final
name|Edge
name|newFirstEdge
init|=
name|edgeBuffer
operator|.
name|getPrevious
argument_list|(
name|firstEdge
argument_list|)
decl_stmt|;
if|if
condition|(
name|isWithin
argument_list|(
name|newFirstEdge
operator|.
name|startPoint
argument_list|,
name|includedEdges
argument_list|)
condition|)
block|{
comment|//System.out.println(" maybe can extend to previous edge");
comment|// Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon
comment|// here will overlap with other remaining points?
specifier|final
name|SidedPlane
name|returnBoundary
decl_stmt|;
if|if
condition|(
name|newFirstEdge
operator|.
name|startPoint
operator|!=
name|lastEdge
operator|.
name|endPoint
condition|)
block|{
name|returnBoundary
operator|=
operator|new
name|SidedPlane
argument_list|(
name|lastEdge
operator|.
name|startPoint
argument_list|,
name|lastEdge
operator|.
name|endPoint
argument_list|,
name|newFirstEdge
operator|.
name|startPoint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|returnBoundary
operator|=
literal|null
expr_stmt|;
block|}
comment|// The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,
comment|// plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.
name|boolean
name|foundPointInside
init|=
literal|false
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|Edge
argument_list|>
name|edgeIterator
init|=
name|edgeBuffer
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|edgeIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|Edge
name|edge
init|=
name|edgeIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|includedEdges
operator|.
name|contains
argument_list|(
name|edge
argument_list|)
operator|&&
name|edge
operator|!=
name|newFirstEdge
condition|)
block|{
comment|// This edge has a point to check
if|if
condition|(
name|edge
operator|.
name|startPoint
operator|!=
name|lastEdge
operator|.
name|endPoint
condition|)
block|{
comment|// look at edge.startPoint
if|if
condition|(
name|isWithin
argument_list|(
name|edge
operator|.
name|startPoint
argument_list|,
name|includedEdges
argument_list|,
name|newFirstEdge
argument_list|,
name|returnBoundary
argument_list|)
condition|)
block|{
comment|//System.out.println("  nope; point within found: "+edge.startPoint);
name|foundPointInside
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|edge
operator|.
name|endPoint
operator|!=
name|newFirstEdge
operator|.
name|startPoint
condition|)
block|{
comment|// look at edge.endPoint
if|if
condition|(
name|isWithin
argument_list|(
name|edge
operator|.
name|endPoint
argument_list|,
name|includedEdges
argument_list|,
name|newFirstEdge
argument_list|,
name|returnBoundary
argument_list|)
condition|)
block|{
comment|//System.out.println("  nope; point within found: "+edge.endPoint);
name|foundPointInside
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|foundPointInside
condition|)
block|{
comment|//System.out.println("  extending!");
comment|// Extend the polygon by the new last edge
name|includedEdges
operator|.
name|add
argument_list|(
name|newFirstEdge
argument_list|)
expr_stmt|;
name|firstEdge
operator|=
name|newFirstEdge
expr_stmt|;
comment|// continue extending in this direction
continue|continue;
block|}
block|}
comment|// We can't extend any more in this direction, so break from the loop.
break|break;
block|}
comment|// Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.
if|if
condition|(
name|includedEdges
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
comment|//System.out.println("Done edge "+currentEdge+": no poly found");
return|return
literal|false
return|;
block|}
comment|// It's enough to build a convex polygon
comment|//System.out.println("Edge "+currentEdge+": Found complex poly");
comment|// Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between
comment|// the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,
comment|// it's a degenerate case and we want to just clean out the edge buffer entirely.
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|points
init|=
operator|new
name|ArrayList
argument_list|<
name|GeoPoint
argument_list|>
argument_list|(
name|includedEdges
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|BitSet
name|internalEdges
init|=
operator|new
name|BitSet
argument_list|(
name|includedEdges
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|returnIsInternal
decl_stmt|;
if|if
condition|(
name|firstEdge
operator|.
name|startPoint
operator|==
name|lastEdge
operator|.
name|endPoint
condition|)
block|{
comment|// Degenerate case!!  There is no return edge -- or rather, we already have it.
if|if
condition|(
name|includedEdges
operator|.
name|size
argument_list|()
operator|<
literal|3
condition|)
block|{
comment|// This means we found a degenerate cycle of edges.  If we emit a polygon at this point it
comment|// has no contents, so we've clearly done something wrong, but not sure what.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"polygon was illegal (degenerate illegal two-edge cyclical polygon encountered in processing)"
argument_list|)
throw|;
block|}
name|Edge
name|edge
init|=
name|firstEdge
decl_stmt|;
name|points
operator|.
name|add
argument_list|(
name|edge
operator|.
name|startPoint
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|edge
operator|==
name|lastEdge
condition|)
block|{
break|break;
block|}
name|points
operator|.
name|add
argument_list|(
name|edge
operator|.
name|endPoint
argument_list|)
expr_stmt|;
name|internalEdges
operator|.
name|set
argument_list|(
name|i
operator|++
argument_list|,
name|edge
operator|.
name|isInternal
argument_list|)
expr_stmt|;
name|edge
operator|=
name|edgeBuffer
operator|.
name|getNext
argument_list|(
name|edge
argument_list|)
expr_stmt|;
block|}
name|returnIsInternal
operator|=
name|lastEdge
operator|.
name|isInternal
expr_stmt|;
name|edgeBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Build the return edge (internal, of course)
specifier|final
name|SidedPlane
name|returnSidedPlane
init|=
operator|new
name|SidedPlane
argument_list|(
name|firstEdge
operator|.
name|endPoint
argument_list|,
literal|false
argument_list|,
name|firstEdge
operator|.
name|startPoint
argument_list|,
name|lastEdge
operator|.
name|endPoint
argument_list|)
decl_stmt|;
specifier|final
name|Edge
name|returnEdge
init|=
operator|new
name|Edge
argument_list|(
name|firstEdge
operator|.
name|startPoint
argument_list|,
name|lastEdge
operator|.
name|endPoint
argument_list|,
name|returnSidedPlane
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// Build point list and edge list
specifier|final
name|List
argument_list|<
name|Edge
argument_list|>
name|edges
init|=
operator|new
name|ArrayList
argument_list|<
name|Edge
argument_list|>
argument_list|(
name|includedEdges
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|returnIsInternal
operator|=
literal|true
expr_stmt|;
name|Edge
name|edge
init|=
name|firstEdge
decl_stmt|;
name|points
operator|.
name|add
argument_list|(
name|edge
operator|.
name|startPoint
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|points
operator|.
name|add
argument_list|(
name|edge
operator|.
name|endPoint
argument_list|)
expr_stmt|;
name|internalEdges
operator|.
name|set
argument_list|(
name|i
operator|++
argument_list|,
name|edge
operator|.
name|isInternal
argument_list|)
expr_stmt|;
name|edges
operator|.
name|add
argument_list|(
name|edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge
operator|==
name|lastEdge
condition|)
block|{
break|break;
block|}
name|edge
operator|=
name|edgeBuffer
operator|.
name|getNext
argument_list|(
name|edge
argument_list|)
expr_stmt|;
block|}
comment|// Modify the edge buffer
name|edgeBuffer
operator|.
name|replace
argument_list|(
name|edges
argument_list|,
name|returnEdge
argument_list|)
expr_stmt|;
block|}
comment|// Now, construct the polygon
if|if
condition|(
name|testPoint
operator|!=
literal|null
operator|&&
name|holes
operator|!=
literal|null
operator|&&
name|holes
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// No holes, for test
specifier|final
name|GeoPolygon
name|testPolygon
init|=
operator|new
name|GeoConvexPolygon
argument_list|(
name|planetModel
argument_list|,
name|points
argument_list|,
literal|null
argument_list|,
name|internalEdges
argument_list|,
name|returnIsInternal
argument_list|)
decl_stmt|;
if|if
condition|(
name|testPolygon
operator|.
name|isWithin
argument_list|(
name|testPoint
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|final
name|GeoPolygon
name|realPolygon
init|=
operator|new
name|GeoConvexPolygon
argument_list|(
name|planetModel
argument_list|,
name|points
argument_list|,
name|holes
argument_list|,
name|internalEdges
argument_list|,
name|returnIsInternal
argument_list|)
decl_stmt|;
if|if
condition|(
name|testPoint
operator|!=
literal|null
operator|&&
operator|(
name|holes
operator|==
literal|null
operator|||
name|holes
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|realPolygon
operator|.
name|isWithin
argument_list|(
name|testPoint
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
name|rval
operator|.
name|addShape
argument_list|(
name|realPolygon
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/** Check if a point is within a set of edges.     * @param point is the point     * @param edgeSet is the set of edges     * @param extension is the new edge     * @param returnBoundary is the return edge     * @return true if within     */
DECL|method|isWithin
specifier|private
specifier|static
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Edge
argument_list|>
name|edgeSet
parameter_list|,
specifier|final
name|Edge
name|extension
parameter_list|,
specifier|final
name|SidedPlane
name|returnBoundary
parameter_list|)
block|{
if|if
condition|(
operator|!
name|extension
operator|.
name|plane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|returnBoundary
operator|!=
literal|null
operator|&&
operator|!
name|returnBoundary
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|isWithin
argument_list|(
name|point
argument_list|,
name|edgeSet
argument_list|)
return|;
block|}
comment|/** Check if a point is within a set of edges.     * @param point is the point     * @param edgeSet is the set of edges     * @return true if within     */
DECL|method|isWithin
specifier|private
specifier|static
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Edge
argument_list|>
name|edgeSet
parameter_list|)
block|{
for|for
control|(
specifier|final
name|Edge
name|edge
range|:
name|edgeSet
control|)
block|{
if|if
condition|(
operator|!
name|edge
operator|.
name|plane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/** Convert raw point index into valid array position.    *@param index is the array index.    *@param size is the array size.    *@return an updated index.    */
DECL|method|getLegalIndex
specifier|private
specifier|static
name|int
name|getLegalIndex
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|size
parameter_list|)
block|{
while|while
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|index
operator|+=
name|size
expr_stmt|;
block|}
while|while
condition|(
name|index
operator|>=
name|size
condition|)
block|{
name|index
operator|-=
name|size
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
comment|/** Class representing a single (unused) edge.    */
DECL|class|Edge
specifier|private
specifier|static
class|class
name|Edge
block|{
comment|/** Plane */
DECL|field|plane
specifier|public
specifier|final
name|SidedPlane
name|plane
decl_stmt|;
comment|/** Start point */
DECL|field|startPoint
specifier|public
specifier|final
name|GeoPoint
name|startPoint
decl_stmt|;
comment|/** End point */
DECL|field|endPoint
specifier|public
specifier|final
name|GeoPoint
name|endPoint
decl_stmt|;
comment|/** Internal edge flag */
DECL|field|isInternal
specifier|public
specifier|final
name|boolean
name|isInternal
decl_stmt|;
comment|/** Constructor.       * @param startPoint the edge start point       * @param endPoint the edge end point       * @param plane the edge plane       * @param isInternal true if internal edge       */
DECL|method|Edge
specifier|public
name|Edge
parameter_list|(
specifier|final
name|GeoPoint
name|startPoint
parameter_list|,
specifier|final
name|GeoPoint
name|endPoint
parameter_list|,
specifier|final
name|SidedPlane
name|plane
parameter_list|,
specifier|final
name|boolean
name|isInternal
parameter_list|)
block|{
name|this
operator|.
name|startPoint
operator|=
name|startPoint
expr_stmt|;
name|this
operator|.
name|endPoint
operator|=
name|endPoint
expr_stmt|;
name|this
operator|.
name|plane
operator|=
name|plane
expr_stmt|;
name|this
operator|.
name|isInternal
operator|=
name|isInternal
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|System
operator|.
name|identityHashCode
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
specifier|final
name|Object
name|o
parameter_list|)
block|{
return|return
name|o
operator|==
name|this
return|;
block|}
block|}
comment|/** Class representing an iterator over an EdgeBuffer.    */
DECL|class|EdgeBufferIterator
specifier|private
specifier|static
class|class
name|EdgeBufferIterator
implements|implements
name|Iterator
argument_list|<
name|Edge
argument_list|>
block|{
comment|/** Edge buffer */
DECL|field|edgeBuffer
specifier|protected
specifier|final
name|EdgeBuffer
name|edgeBuffer
decl_stmt|;
comment|/** First edge */
DECL|field|firstEdge
specifier|protected
specifier|final
name|Edge
name|firstEdge
decl_stmt|;
comment|/** Current edge */
DECL|field|currentEdge
specifier|protected
name|Edge
name|currentEdge
decl_stmt|;
comment|/** Constructor.       * @param edgeBuffer the edge buffer       */
DECL|method|EdgeBufferIterator
specifier|public
name|EdgeBufferIterator
parameter_list|(
specifier|final
name|EdgeBuffer
name|edgeBuffer
parameter_list|)
block|{
name|this
operator|.
name|edgeBuffer
operator|=
name|edgeBuffer
expr_stmt|;
name|this
operator|.
name|currentEdge
operator|=
name|edgeBuffer
operator|.
name|pickOne
argument_list|()
expr_stmt|;
name|this
operator|.
name|firstEdge
operator|=
name|currentEdge
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|currentEdge
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|Edge
name|next
parameter_list|()
block|{
specifier|final
name|Edge
name|rval
init|=
name|currentEdge
decl_stmt|;
if|if
condition|(
name|currentEdge
operator|!=
literal|null
condition|)
block|{
name|currentEdge
operator|=
name|edgeBuffer
operator|.
name|getNext
argument_list|(
name|currentEdge
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentEdge
operator|==
name|firstEdge
condition|)
block|{
name|currentEdge
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|return
name|rval
return|;
block|}
annotation|@
name|Override
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported operation"
argument_list|)
throw|;
block|}
block|}
comment|/** Class representing a pool of unused edges, all linked together by vertices.    */
DECL|class|EdgeBuffer
specifier|private
specifier|static
class|class
name|EdgeBuffer
block|{
comment|/** Starting edge */
DECL|field|oneEdge
specifier|protected
name|Edge
name|oneEdge
decl_stmt|;
comment|/** Full set of edges */
DECL|field|edges
specifier|protected
specifier|final
name|Set
argument_list|<
name|Edge
argument_list|>
name|edges
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Map to previous edge */
DECL|field|previousEdges
specifier|protected
specifier|final
name|Map
argument_list|<
name|Edge
argument_list|,
name|Edge
argument_list|>
name|previousEdges
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Map to next edge */
DECL|field|nextEdges
specifier|protected
specifier|final
name|Map
argument_list|<
name|Edge
argument_list|,
name|Edge
argument_list|>
name|nextEdges
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Constructor.       * @param pointList is the list of points.       * @param internalEdges is the list of edges that are internal (includes return edge)       * @param startPlaneStartIndex is the index of the startPlane's starting point       * @param startPlaneEndIndex is the index of the startPlane's ending point       * @param startPlane is the starting plane       */
DECL|method|EdgeBuffer
specifier|public
name|EdgeBuffer
parameter_list|(
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointList
parameter_list|,
specifier|final
name|BitSet
name|internalEdges
parameter_list|,
specifier|final
name|int
name|startPlaneStartIndex
parameter_list|,
specifier|final
name|int
name|startPlaneEndIndex
parameter_list|,
specifier|final
name|SidedPlane
name|startPlane
parameter_list|)
block|{
comment|/*       System.out.println("Initial points:");       for (final GeoPoint p : pointList) {         System.out.println(" "+p);       }       */
specifier|final
name|Edge
name|startEdge
init|=
operator|new
name|Edge
argument_list|(
name|pointList
operator|.
name|get
argument_list|(
name|startPlaneStartIndex
argument_list|)
argument_list|,
name|pointList
operator|.
name|get
argument_list|(
name|startPlaneEndIndex
argument_list|)
argument_list|,
name|startPlane
argument_list|,
name|internalEdges
operator|.
name|get
argument_list|(
name|startPlaneStartIndex
argument_list|)
argument_list|)
decl_stmt|;
comment|// Fill in the EdgeBuffer by walking around creating more stuff
name|Edge
name|currentEdge
init|=
name|startEdge
decl_stmt|;
name|int
name|startIndex
init|=
name|startPlaneStartIndex
decl_stmt|;
name|int
name|endIndex
init|=
name|startPlaneEndIndex
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// Compute the next edge
name|startIndex
operator|=
name|endIndex
expr_stmt|;
name|endIndex
operator|++
expr_stmt|;
if|if
condition|(
name|endIndex
operator|>=
name|pointList
operator|.
name|size
argument_list|()
condition|)
block|{
name|endIndex
operator|-=
name|pointList
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|// Get the next point
specifier|final
name|GeoPoint
name|newPoint
init|=
name|pointList
operator|.
name|get
argument_list|(
name|endIndex
argument_list|)
decl_stmt|;
comment|// Build the new edge
comment|// We have to be sure that the point we use as a check does not lie on the plane.
comment|// In order to meet that goal, we need to go hunting for a point that meets the criteria.  If we don't
comment|// find one, we've got a linear "polygon" that we cannot use.
comment|// We need to know the sidedness of the new plane.  The point we're going to be presenting to it has
comment|// a certain relationship with the sided plane we already have for the current edge.  If the current edge
comment|// is colinear with the new edge, then we want to maintain the same relationship.  If the new edge
comment|// is not colinear, then we can use the new point's relationship with the current edge as our guide.
specifier|final
name|boolean
name|isNewPointWithin
decl_stmt|;
specifier|final
name|GeoPoint
name|pointToPresent
decl_stmt|;
if|if
condition|(
name|currentEdge
operator|.
name|plane
operator|.
name|evaluateIsZero
argument_list|(
name|newPoint
argument_list|)
condition|)
block|{
comment|// The new point is colinear with the current edge.  We'll have to look for the first point that isn't.
name|int
name|checkPointIndex
init|=
operator|-
literal|1
decl_stmt|;
specifier|final
name|Plane
name|checkPlane
init|=
operator|new
name|Plane
argument_list|(
name|pointList
operator|.
name|get
argument_list|(
name|startIndex
argument_list|)
argument_list|,
name|newPoint
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|index
init|=
name|getLegalIndex
argument_list|(
name|startIndex
operator|-
literal|1
operator|-
name|i
argument_list|,
name|pointList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|checkPlane
operator|.
name|evaluateIsZero
argument_list|(
name|pointList
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
block|{
name|checkPointIndex
operator|=
name|index
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|checkPointIndex
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"polygon is illegal (linear)"
argument_list|)
throw|;
block|}
name|pointToPresent
operator|=
name|pointList
operator|.
name|get
argument_list|(
name|checkPointIndex
argument_list|)
expr_stmt|;
name|isNewPointWithin
operator|=
name|currentEdge
operator|.
name|plane
operator|.
name|isWithin
argument_list|(
name|pointToPresent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isNewPointWithin
operator|=
name|currentEdge
operator|.
name|plane
operator|.
name|isWithin
argument_list|(
name|newPoint
argument_list|)
expr_stmt|;
name|pointToPresent
operator|=
name|currentEdge
operator|.
name|startPoint
expr_stmt|;
block|}
specifier|final
name|SidedPlane
name|newPlane
init|=
operator|new
name|SidedPlane
argument_list|(
name|pointToPresent
argument_list|,
name|isNewPointWithin
argument_list|,
name|pointList
operator|.
name|get
argument_list|(
name|startIndex
argument_list|)
argument_list|,
name|newPoint
argument_list|)
decl_stmt|;
comment|/*         System.out.println("For next plane, the following points are in/out:");         for (final GeoPoint p: pointList) {           System.out.println(" "+p+" is: "+(newPlane.isWithin(p)?"in":"out"));         }         */
specifier|final
name|Edge
name|newEdge
init|=
operator|new
name|Edge
argument_list|(
name|pointList
operator|.
name|get
argument_list|(
name|startIndex
argument_list|)
argument_list|,
name|pointList
operator|.
name|get
argument_list|(
name|endIndex
argument_list|)
argument_list|,
name|newPlane
argument_list|,
name|internalEdges
operator|.
name|get
argument_list|(
name|startIndex
argument_list|)
argument_list|)
decl_stmt|;
comment|// Link it in
name|previousEdges
operator|.
name|put
argument_list|(
name|newEdge
argument_list|,
name|currentEdge
argument_list|)
expr_stmt|;
name|nextEdges
operator|.
name|put
argument_list|(
name|currentEdge
argument_list|,
name|newEdge
argument_list|)
expr_stmt|;
name|edges
operator|.
name|add
argument_list|(
name|newEdge
argument_list|)
expr_stmt|;
name|currentEdge
operator|=
name|newEdge
expr_stmt|;
if|if
condition|(
name|currentEdge
operator|.
name|endPoint
operator|==
name|startEdge
operator|.
name|startPoint
condition|)
block|{
comment|// We finish here.  Link the current edge to the start edge, and exit
name|previousEdges
operator|.
name|put
argument_list|(
name|startEdge
argument_list|,
name|currentEdge
argument_list|)
expr_stmt|;
name|nextEdges
operator|.
name|put
argument_list|(
name|currentEdge
argument_list|,
name|startEdge
argument_list|)
expr_stmt|;
name|edges
operator|.
name|add
argument_list|(
name|startEdge
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|oneEdge
operator|=
name|startEdge
expr_stmt|;
comment|// Verify the structure.
comment|//verify();
block|}
comment|/*     protected void verify() {       if (edges.size() != previousEdges.size() || edges.size() != nextEdges.size()) {         throw new IllegalStateException("broken structure");       }       // Confirm each edge       for (final Edge e : edges) {         final Edge previousEdge = getPrevious(e);         final Edge nextEdge = getNext(e);         if (e.endPoint != nextEdge.startPoint) {           throw new IllegalStateException("broken structure");         }         if (e.startPoint != previousEdge.endPoint) {           throw new IllegalStateException("broken structure");         }         if (getNext(previousEdge) != e) {           throw new IllegalStateException("broken structure");         }         if (getPrevious(nextEdge) != e) {           throw new IllegalStateException("broken structure");         }       }       if (oneEdge != null&& !edges.contains(oneEdge)) {         throw new IllegalStateException("broken structure");       }       if (oneEdge == null&& edges.size()> 0) {         throw new IllegalStateException("broken structure");       }     }     */
comment|/** Get the previous edge.       * @param currentEdge is the current edge.       * @return the previous edge, if found.       */
DECL|method|getPrevious
specifier|public
name|Edge
name|getPrevious
parameter_list|(
specifier|final
name|Edge
name|currentEdge
parameter_list|)
block|{
return|return
name|previousEdges
operator|.
name|get
argument_list|(
name|currentEdge
argument_list|)
return|;
block|}
comment|/** Get the next edge.       * @param currentEdge is the current edge.       * @return the next edge, if found.       */
DECL|method|getNext
specifier|public
name|Edge
name|getNext
parameter_list|(
specifier|final
name|Edge
name|currentEdge
parameter_list|)
block|{
return|return
name|nextEdges
operator|.
name|get
argument_list|(
name|currentEdge
argument_list|)
return|;
block|}
comment|/** Replace a list of edges with a new edge.       * @param removeList is the list of edges to remove.       * @param newEdge is the edge to add.       */
DECL|method|replace
specifier|public
name|void
name|replace
parameter_list|(
specifier|final
name|List
argument_list|<
name|Edge
argument_list|>
name|removeList
parameter_list|,
specifier|final
name|Edge
name|newEdge
parameter_list|)
block|{
comment|/*       System.out.println("Replacing: ");       for (final Edge e : removeList) {         System.out.println(" "+e.startPoint+"-->"+e.endPoint);       }       System.out.println("...with: "+newEdge.startPoint+"-->"+newEdge.endPoint);       */
specifier|final
name|Edge
name|previous
init|=
name|previousEdges
operator|.
name|get
argument_list|(
name|removeList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Edge
name|next
init|=
name|nextEdges
operator|.
name|get
argument_list|(
name|removeList
operator|.
name|get
argument_list|(
name|removeList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|edges
operator|.
name|add
argument_list|(
name|newEdge
argument_list|)
expr_stmt|;
name|previousEdges
operator|.
name|put
argument_list|(
name|newEdge
argument_list|,
name|previous
argument_list|)
expr_stmt|;
name|nextEdges
operator|.
name|put
argument_list|(
name|previous
argument_list|,
name|newEdge
argument_list|)
expr_stmt|;
name|previousEdges
operator|.
name|put
argument_list|(
name|next
argument_list|,
name|newEdge
argument_list|)
expr_stmt|;
name|nextEdges
operator|.
name|put
argument_list|(
name|newEdge
argument_list|,
name|next
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|Edge
name|edge
range|:
name|removeList
control|)
block|{
if|if
condition|(
name|edge
operator|==
name|oneEdge
condition|)
block|{
name|oneEdge
operator|=
name|newEdge
expr_stmt|;
block|}
name|edges
operator|.
name|remove
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|previousEdges
operator|.
name|remove
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|nextEdges
operator|.
name|remove
argument_list|(
name|edge
argument_list|)
expr_stmt|;
block|}
comment|//verify();
block|}
comment|/** Clear all edges.       */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|edges
operator|.
name|clear
argument_list|()
expr_stmt|;
name|previousEdges
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nextEdges
operator|.
name|clear
argument_list|()
expr_stmt|;
name|oneEdge
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Get the size of the edge buffer.       * @return the size.       */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|edges
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** Get an iterator to iterate over edges.       * @return the iterator.       */
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|Edge
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|EdgeBufferIterator
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/** Return a first edge.       * @return the edge.       */
DECL|method|pickOne
specifier|public
name|Edge
name|pickOne
parameter_list|()
block|{
return|return
name|oneEdge
return|;
block|}
block|}
block|}
end_class
end_unit
