begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.spatial3d.geom
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_comment
comment|/**  * GeoConcavePolygon objects are generic building blocks of more complex structures.  * The only restrictions on these objects are: (1) they must be concave; (2) they must have  * a maximum extent larger than PI.  Violating either one of these limits will  * cause the logic to fail.  *  * @lucene.internal  */
end_comment
begin_class
DECL|class|GeoConcavePolygon
class|class
name|GeoConcavePolygon
extends|extends
name|GeoBasePolygon
block|{
comment|/** The list of polygon points */
DECL|field|points
specifier|protected
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|points
decl_stmt|;
comment|/** A bitset describing, for each edge, whether it is internal or not */
DECL|field|isInternalEdges
specifier|protected
specifier|final
name|BitSet
name|isInternalEdges
decl_stmt|;
comment|/** The list of holes.  If a point is in the hole, it is *not* in the polygon */
DECL|field|holes
specifier|protected
specifier|final
name|List
argument_list|<
name|GeoPolygon
argument_list|>
name|holes
decl_stmt|;
comment|/** A list of edges */
DECL|field|edges
specifier|protected
name|SidedPlane
index|[]
name|edges
init|=
literal|null
decl_stmt|;
comment|/** A list of inverted edges */
DECL|field|invertedEdges
specifier|protected
name|SidedPlane
index|[]
name|invertedEdges
init|=
literal|null
decl_stmt|;
comment|/** The set of notable points for each edge */
DECL|field|notableEdgePoints
specifier|protected
name|GeoPoint
index|[]
index|[]
name|notableEdgePoints
init|=
literal|null
decl_stmt|;
comment|/** A point which is on the boundary of the polygon */
DECL|field|edgePoints
specifier|protected
name|GeoPoint
index|[]
name|edgePoints
init|=
literal|null
decl_stmt|;
comment|/** Set to true when the polygon is complete */
DECL|field|isDone
specifier|protected
name|boolean
name|isDone
init|=
literal|false
decl_stmt|;
comment|/** A bounds object for each sided plane */
DECL|field|eitherBounds
specifier|protected
name|Map
argument_list|<
name|SidedPlane
argument_list|,
name|Membership
argument_list|>
name|eitherBounds
init|=
literal|null
decl_stmt|;
comment|/** Edge plane for one side of intersection */
DECL|field|edgePlanes
specifier|protected
name|Map
argument_list|<
name|SidedPlane
argument_list|,
name|Plane
argument_list|>
name|edgePlanes
init|=
literal|null
decl_stmt|;
comment|/** Intersection bounds */
DECL|field|intersectionBounds
specifier|protected
name|Map
argument_list|<
name|SidedPlane
argument_list|,
name|Membership
argument_list|>
name|intersectionBounds
init|=
literal|null
decl_stmt|;
comment|/**    * Create a concave polygon from a list of points.  The first point must be on the    * external edge.    *@param planetModel is the planet model.    *@param pointList is the list of points to create the polygon from.    */
DECL|method|GeoConcavePolygon
specifier|public
name|GeoConcavePolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointList
parameter_list|)
block|{
name|this
argument_list|(
name|planetModel
argument_list|,
name|pointList
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a concave polygon from a list of points.  The first point must be on the    * external edge.    *@param planetModel is the planet model.    *@param pointList is the list of points to create the polygon from.    *@param holes is the list of GeoPolygon objects that describe holes in the concave polygon.  Null == no holes.    */
DECL|method|GeoConcavePolygon
specifier|public
name|GeoConcavePolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointList
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPolygon
argument_list|>
name|holes
parameter_list|)
block|{
name|super
argument_list|(
name|planetModel
argument_list|)
expr_stmt|;
name|this
operator|.
name|points
operator|=
name|pointList
expr_stmt|;
name|this
operator|.
name|holes
operator|=
name|holes
expr_stmt|;
name|this
operator|.
name|isInternalEdges
operator|=
operator|new
name|BitSet
argument_list|()
expr_stmt|;
name|done
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a concave polygon from a list of points, keeping track of which boundaries    * are internal.  This is used when creating a polygon as a building block for another shape.    *@param planetModel is the planet model.    *@param pointList is the set of points to create the polygon from.    *@param internalEdgeFlags is a bitset describing whether each edge is internal or not.    *@param returnEdgeInternal is true when the final return edge is an internal one.    */
DECL|method|GeoConcavePolygon
specifier|public
name|GeoConcavePolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointList
parameter_list|,
specifier|final
name|BitSet
name|internalEdgeFlags
parameter_list|,
specifier|final
name|boolean
name|returnEdgeInternal
parameter_list|)
block|{
name|this
argument_list|(
name|planetModel
argument_list|,
name|pointList
argument_list|,
literal|null
argument_list|,
name|internalEdgeFlags
argument_list|,
name|returnEdgeInternal
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a concave polygon from a list of points, keeping track of which boundaries    * are internal.  This is used when creating a polygon as a building block for another shape.    *@param planetModel is the planet model.    *@param pointList is the set of points to create the polygon from.    *@param holes is the list of GeoPolygon objects that describe holes in the concave polygon.  Null == no holes.    *@param internalEdgeFlags is a bitset describing whether each edge is internal or not.    *@param returnEdgeInternal is true when the final return edge is an internal one.    */
DECL|method|GeoConcavePolygon
specifier|public
name|GeoConcavePolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|pointList
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPolygon
argument_list|>
name|holes
parameter_list|,
specifier|final
name|BitSet
name|internalEdgeFlags
parameter_list|,
specifier|final
name|boolean
name|returnEdgeInternal
parameter_list|)
block|{
name|super
argument_list|(
name|planetModel
argument_list|)
expr_stmt|;
name|this
operator|.
name|points
operator|=
name|pointList
expr_stmt|;
name|this
operator|.
name|holes
operator|=
name|holes
expr_stmt|;
name|this
operator|.
name|isInternalEdges
operator|=
name|internalEdgeFlags
expr_stmt|;
name|done
argument_list|(
name|returnEdgeInternal
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a concave polygon, with a starting latitude and longitude.    * Accepts only values in the following ranges: lat: {@code -PI/2 -> PI/2}, lon: {@code -PI -> PI}    *@param planetModel is the planet model.    *@param startLatitude is the latitude of the first point.    *@param startLongitude is the longitude of the first point.    */
DECL|method|GeoConcavePolygon
specifier|public
name|GeoConcavePolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|double
name|startLatitude
parameter_list|,
specifier|final
name|double
name|startLongitude
parameter_list|)
block|{
name|this
argument_list|(
name|planetModel
argument_list|,
name|startLatitude
argument_list|,
name|startLongitude
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a concave polygon, with a starting latitude and longitude.    * Accepts only values in the following ranges: lat: {@code -PI/2 -> PI/2}, lon: {@code -PI -> PI}    *@param planetModel is the planet model.    *@param startLatitude is the latitude of the first point.    *@param startLongitude is the longitude of the first point.    *@param holes is the list of GeoPolygon objects that describe holes in the concave polygon.  Null == no holes.    */
DECL|method|GeoConcavePolygon
specifier|public
name|GeoConcavePolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|double
name|startLatitude
parameter_list|,
specifier|final
name|double
name|startLongitude
parameter_list|,
specifier|final
name|List
argument_list|<
name|GeoPolygon
argument_list|>
name|holes
parameter_list|)
block|{
name|super
argument_list|(
name|planetModel
argument_list|)
expr_stmt|;
name|points
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|holes
operator|=
name|holes
expr_stmt|;
name|isInternalEdges
operator|=
operator|new
name|BitSet
argument_list|()
expr_stmt|;
name|points
operator|.
name|add
argument_list|(
operator|new
name|GeoPoint
argument_list|(
name|planetModel
argument_list|,
name|startLatitude
argument_list|,
name|startLongitude
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a point to the polygon.    * Accepts only values in the following ranges: lat: {@code -PI/2 -> PI/2}, lon: {@code -PI -> PI}    *    * @param latitude       is the latitude of the next point.    * @param longitude      is the longitude of the next point.    * @param isInternalEdge is true if the edge just added with this point should be considered "internal", and not    *                       intersected as part of the intersects() operation.    */
DECL|method|addPoint
specifier|public
name|void
name|addPoint
parameter_list|(
specifier|final
name|double
name|latitude
parameter_list|,
specifier|final
name|double
name|longitude
parameter_list|,
specifier|final
name|boolean
name|isInternalEdge
parameter_list|)
block|{
if|if
condition|(
name|isDone
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Can't call addPoint() if done() already called"
argument_list|)
throw|;
if|if
condition|(
name|isInternalEdge
condition|)
name|isInternalEdges
operator|.
name|set
argument_list|(
name|points
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|points
operator|.
name|add
argument_list|(
operator|new
name|GeoPoint
argument_list|(
name|planetModel
argument_list|,
name|latitude
argument_list|,
name|longitude
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Finish the polygon, by connecting the last added point with the starting point.    *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.    */
DECL|method|done
specifier|public
name|void
name|done
parameter_list|(
specifier|final
name|boolean
name|isInternalReturnEdge
parameter_list|)
block|{
if|if
condition|(
name|isDone
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Can't call done() more than once"
argument_list|)
throw|;
comment|// If fewer than 3 points, can't do it.
if|if
condition|(
name|points
operator|.
name|size
argument_list|()
operator|<
literal|3
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Polygon needs at least three points."
argument_list|)
throw|;
if|if
condition|(
name|isInternalReturnEdge
condition|)
name|isInternalEdges
operator|.
name|set
argument_list|(
name|points
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|isDone
operator|=
literal|true
expr_stmt|;
comment|// Time to construct the planes.  If the polygon is truly concave then any adjacent point
comment|// to a segment can provide an exterior measurement.  Note: We build the true planes
comment|// here and use the logic to return what *isn't* inside all of them.
name|edges
operator|=
operator|new
name|SidedPlane
index|[
name|points
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|invertedEdges
operator|=
operator|new
name|SidedPlane
index|[
name|points
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|notableEdgePoints
operator|=
operator|new
name|GeoPoint
index|[
name|points
operator|.
name|size
argument_list|()
index|]
index|[]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|points
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|GeoPoint
name|start
init|=
name|points
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
name|end
init|=
name|points
operator|.
name|get
argument_list|(
name|legalIndex
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|// We have to find the next point that is not on the plane between start and end.
comment|// If there is no such point, it's an error.
specifier|final
name|Plane
name|planeToFind
init|=
operator|new
name|Plane
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|int
name|endPointIndex
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|points
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|int
name|index
init|=
name|legalIndex
argument_list|(
name|j
operator|+
name|i
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|planeToFind
operator|.
name|evaluateIsZero
argument_list|(
name|points
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
block|{
name|endPointIndex
operator|=
name|index
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|endPointIndex
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Polygon points are all coplanar"
argument_list|)
throw|;
block|}
specifier|final
name|GeoPoint
name|check
init|=
name|points
operator|.
name|get
argument_list|(
name|endPointIndex
argument_list|)
decl_stmt|;
comment|//System.out.println("Created edge "+sp+" using start="+start+" end="+end+" check="+check);
name|edges
index|[
name|i
index|]
operator|=
operator|new
name|SidedPlane
argument_list|(
name|check
argument_list|,
literal|false
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|invertedEdges
index|[
name|i
index|]
operator|=
operator|new
name|SidedPlane
argument_list|(
name|edges
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|notableEdgePoints
index|[
name|i
index|]
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|start
block|,
name|end
block|}
expr_stmt|;
block|}
comment|// For each edge, create a bounds object.
name|eitherBounds
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|edges
operator|.
name|length
argument_list|)
expr_stmt|;
name|intersectionBounds
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|edges
operator|.
name|length
argument_list|)
expr_stmt|;
name|edgePlanes
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|edges
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|edgeIndex
init|=
literal|0
init|;
name|edgeIndex
operator|<
name|edges
operator|.
name|length
condition|;
name|edgeIndex
operator|++
control|)
block|{
specifier|final
name|SidedPlane
name|edge
init|=
name|edges
index|[
name|edgeIndex
index|]
decl_stmt|;
specifier|final
name|SidedPlane
name|invertedEdge
init|=
name|invertedEdges
index|[
name|edgeIndex
index|]
decl_stmt|;
name|int
name|bound1Index
init|=
name|legalIndex
argument_list|(
name|edgeIndex
operator|+
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
name|invertedEdges
index|[
name|legalIndex
argument_list|(
name|bound1Index
argument_list|)
index|]
operator|.
name|isNumericallyIdentical
argument_list|(
name|invertedEdge
argument_list|)
condition|)
block|{
name|bound1Index
operator|++
expr_stmt|;
block|}
name|int
name|bound2Index
init|=
name|legalIndex
argument_list|(
name|edgeIndex
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
name|otherIndex
init|=
name|bound2Index
decl_stmt|;
specifier|final
name|SidedPlane
name|otherEdge
decl_stmt|;
specifier|final
name|SidedPlane
name|otherInvertedEdge
decl_stmt|;
if|if
condition|(
name|invertedEdges
index|[
name|legalIndex
argument_list|(
name|otherIndex
argument_list|)
index|]
operator|.
name|isNumericallyIdentical
argument_list|(
name|invertedEdge
argument_list|)
condition|)
block|{
name|otherInvertedEdge
operator|=
literal|null
expr_stmt|;
name|otherEdge
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|otherInvertedEdge
operator|=
name|invertedEdges
index|[
name|legalIndex
argument_list|(
name|otherIndex
argument_list|)
index|]
expr_stmt|;
name|otherEdge
operator|=
name|edges
index|[
name|legalIndex
argument_list|(
name|otherIndex
argument_list|)
index|]
expr_stmt|;
block|}
while|while
condition|(
name|invertedEdges
index|[
name|legalIndex
argument_list|(
name|bound2Index
argument_list|)
index|]
operator|.
name|isNumericallyIdentical
argument_list|(
name|invertedEdge
argument_list|)
condition|)
block|{
name|bound2Index
operator|--
expr_stmt|;
block|}
name|eitherBounds
operator|.
name|put
argument_list|(
name|edge
argument_list|,
operator|new
name|EitherBound
argument_list|(
name|invertedEdges
index|[
name|legalIndex
argument_list|(
name|bound1Index
argument_list|)
index|]
argument_list|,
name|invertedEdges
index|[
name|legalIndex
argument_list|(
name|bound2Index
argument_list|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|// For intersections, we look at the point at the intersection between the previous edge and this one.  We need to locate the
comment|// Intersection bounds needs to look even further forwards/backwards
if|if
condition|(
name|otherInvertedEdge
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
name|invertedEdges
index|[
name|legalIndex
argument_list|(
name|otherIndex
argument_list|)
index|]
operator|.
name|isNumericallyIdentical
argument_list|(
name|otherInvertedEdge
argument_list|)
condition|)
block|{
name|otherIndex
operator|--
expr_stmt|;
block|}
name|intersectionBounds
operator|.
name|put
argument_list|(
name|edge
argument_list|,
operator|new
name|EitherBound
argument_list|(
name|invertedEdges
index|[
name|legalIndex
argument_list|(
name|otherIndex
argument_list|)
index|]
argument_list|,
name|invertedEdges
index|[
name|legalIndex
argument_list|(
name|bound2Index
argument_list|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|edgePlanes
operator|.
name|put
argument_list|(
name|edge
argument_list|,
name|otherEdge
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Pick an edge point arbitrarily from the outer polygon.  Glom this together with all edge points from
comment|// inner polygons.
name|int
name|edgePointCount
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|holes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
specifier|final
name|GeoPolygon
name|hole
range|:
name|holes
control|)
block|{
name|edgePointCount
operator|+=
name|hole
operator|.
name|getEdgePoints
argument_list|()
operator|.
name|length
expr_stmt|;
block|}
block|}
name|edgePoints
operator|=
operator|new
name|GeoPoint
index|[
name|edgePointCount
index|]
expr_stmt|;
name|edgePointCount
operator|=
literal|0
expr_stmt|;
name|edgePoints
index|[
name|edgePointCount
operator|++
index|]
operator|=
name|points
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|holes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
specifier|final
name|GeoPolygon
name|hole
range|:
name|holes
control|)
block|{
specifier|final
name|GeoPoint
index|[]
name|holeEdgePoints
init|=
name|hole
operator|.
name|getEdgePoints
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|GeoPoint
name|p
range|:
name|holeEdgePoints
control|)
block|{
name|edgePoints
index|[
name|edgePointCount
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|isWithinHoles
argument_list|(
name|points
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Polygon edge intersects a polygon hole; not allowed"
argument_list|)
throw|;
block|}
block|}
comment|/** Check if a point is within the provided holes.    *@param point point to check.    *@return true if the point is within any of the holes.    */
DECL|method|isWithinHoles
specifier|protected
name|boolean
name|isWithinHoles
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
if|if
condition|(
name|holes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
specifier|final
name|GeoPolygon
name|hole
range|:
name|holes
control|)
block|{
if|if
condition|(
operator|!
name|hole
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Compute a legal point index from a possibly illegal one, that may have wrapped.    *@param index is the index.    *@return the normalized index.    */
DECL|method|legalIndex
specifier|protected
name|int
name|legalIndex
parameter_list|(
name|int
name|index
parameter_list|)
block|{
while|while
condition|(
name|index
operator|>=
name|points
operator|.
name|size
argument_list|()
condition|)
name|index
operator|-=
name|points
operator|.
name|size
argument_list|()
expr_stmt|;
while|while
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|index
operator|+=
name|points
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
annotation|@
name|Override
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
if|if
condition|(
operator|!
name|localIsWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|holes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
specifier|final
name|GeoPolygon
name|polygon
range|:
name|holes
control|)
block|{
if|if
condition|(
operator|!
name|polygon
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|localIsWithin
specifier|protected
name|boolean
name|localIsWithin
parameter_list|(
specifier|final
name|Vector
name|v
parameter_list|)
block|{
return|return
name|localIsWithin
argument_list|(
name|v
operator|.
name|x
argument_list|,
name|v
operator|.
name|y
argument_list|,
name|v
operator|.
name|z
argument_list|)
return|;
block|}
DECL|method|localIsWithin
specifier|protected
name|boolean
name|localIsWithin
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
comment|// If present within *any* plane, then it is a member, except where there are holes.
name|boolean
name|isMember
init|=
literal|false
decl_stmt|;
for|for
control|(
specifier|final
name|SidedPlane
name|edge
range|:
name|edges
control|)
block|{
if|if
condition|(
name|edge
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
block|{
name|isMember
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
return|return
name|isMember
return|;
block|}
annotation|@
name|Override
DECL|method|getEdgePoints
specifier|public
name|GeoPoint
index|[]
name|getEdgePoints
parameter_list|()
block|{
return|return
name|edgePoints
return|;
block|}
annotation|@
name|Override
DECL|method|intersects
specifier|public
name|boolean
name|intersects
parameter_list|(
specifier|final
name|Plane
name|p
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|notablePoints
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
comment|// The bounding planes are inverted and complementary.  For intersection computation, we
comment|// cannot use them as bounds.  They are independent hemispheres.
for|for
control|(
name|int
name|edgeIndex
init|=
literal|0
init|;
name|edgeIndex
operator|<
name|edges
operator|.
name|length
condition|;
name|edgeIndex
operator|++
control|)
block|{
specifier|final
name|SidedPlane
name|edge
init|=
name|edges
index|[
name|edgeIndex
index|]
decl_stmt|;
specifier|final
name|SidedPlane
name|invertedEdge
init|=
name|invertedEdges
index|[
name|edgeIndex
index|]
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|points
init|=
name|this
operator|.
name|notableEdgePoints
index|[
name|edgeIndex
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isInternalEdges
operator|.
name|get
argument_list|(
name|edgeIndex
argument_list|)
condition|)
block|{
comment|//System.err.println("Checking concave edge "+edge+" for intersection against plane "+p);
if|if
condition|(
name|invertedEdge
operator|.
name|intersects
argument_list|(
name|planetModel
argument_list|,
name|p
argument_list|,
name|notablePoints
argument_list|,
name|points
argument_list|,
name|bounds
argument_list|,
name|eitherBounds
operator|.
name|get
argument_list|(
name|edge
argument_list|)
argument_list|)
condition|)
block|{
comment|//System.err.println(" intersects!");
return|return
literal|true
return|;
block|}
block|}
block|}
if|if
condition|(
name|holes
operator|!=
literal|null
condition|)
block|{
comment|// Each hole needs to be looked at for intersection too, since a shape can be entirely within the hole
for|for
control|(
specifier|final
name|GeoPolygon
name|hole
range|:
name|holes
control|)
block|{
if|if
condition|(
name|hole
operator|.
name|intersects
argument_list|(
name|p
argument_list|,
name|notablePoints
argument_list|,
name|bounds
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
comment|//System.err.println(" no intersection");
return|return
literal|false
return|;
block|}
comment|/** A membership implementation representing polygon edges that must apply.    */
DECL|class|EitherBound
specifier|protected
class|class
name|EitherBound
implements|implements
name|Membership
block|{
DECL|field|sideBound1
specifier|protected
specifier|final
name|SidedPlane
name|sideBound1
decl_stmt|;
DECL|field|sideBound2
specifier|protected
specifier|final
name|SidedPlane
name|sideBound2
decl_stmt|;
comment|/** Constructor.       * @param sideBound1 is the first side bound.       * @param sideBound2 is the second side bound.       */
DECL|method|EitherBound
specifier|public
name|EitherBound
parameter_list|(
specifier|final
name|SidedPlane
name|sideBound1
parameter_list|,
specifier|final
name|SidedPlane
name|sideBound2
parameter_list|)
block|{
name|this
operator|.
name|sideBound1
operator|=
name|sideBound1
expr_stmt|;
name|this
operator|.
name|sideBound2
operator|=
name|sideBound2
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|Vector
name|v
parameter_list|)
block|{
return|return
name|sideBound1
operator|.
name|isWithin
argument_list|(
name|v
argument_list|)
operator|&&
name|sideBound2
operator|.
name|isWithin
argument_list|(
name|v
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|sideBound1
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
operator|&&
name|sideBound2
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getBounds
specifier|public
name|void
name|getBounds
parameter_list|(
name|Bounds
name|bounds
parameter_list|)
block|{
comment|// Because of holes, we don't want to use superclass method
if|if
condition|(
name|localIsWithin
argument_list|(
name|planetModel
operator|.
name|NORTH_POLE
argument_list|)
condition|)
block|{
name|bounds
operator|.
name|noTopLatitudeBound
argument_list|()
operator|.
name|noLongitudeBound
argument_list|()
operator|.
name|addPoint
argument_list|(
name|planetModel
operator|.
name|NORTH_POLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|localIsWithin
argument_list|(
name|planetModel
operator|.
name|SOUTH_POLE
argument_list|)
condition|)
block|{
name|bounds
operator|.
name|noBottomLatitudeBound
argument_list|()
operator|.
name|noLongitudeBound
argument_list|()
operator|.
name|addPoint
argument_list|(
name|planetModel
operator|.
name|SOUTH_POLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|localIsWithin
argument_list|(
name|planetModel
operator|.
name|MIN_X_POLE
argument_list|)
condition|)
block|{
name|bounds
operator|.
name|addPoint
argument_list|(
name|planetModel
operator|.
name|MIN_X_POLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|localIsWithin
argument_list|(
name|planetModel
operator|.
name|MAX_X_POLE
argument_list|)
condition|)
block|{
name|bounds
operator|.
name|addPoint
argument_list|(
name|planetModel
operator|.
name|MAX_X_POLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|localIsWithin
argument_list|(
name|planetModel
operator|.
name|MIN_Y_POLE
argument_list|)
condition|)
block|{
name|bounds
operator|.
name|addPoint
argument_list|(
name|planetModel
operator|.
name|MIN_Y_POLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|localIsWithin
argument_list|(
name|planetModel
operator|.
name|MAX_Y_POLE
argument_list|)
condition|)
block|{
name|bounds
operator|.
name|addPoint
argument_list|(
name|planetModel
operator|.
name|MAX_Y_POLE
argument_list|)
expr_stmt|;
block|}
name|bounds
operator|.
name|isWide
argument_list|()
expr_stmt|;
comment|// Add all the points
for|for
control|(
specifier|final
name|GeoPoint
name|point
range|:
name|points
control|)
block|{
name|bounds
operator|.
name|addPoint
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
comment|// Add planes with membership.
for|for
control|(
specifier|final
name|SidedPlane
name|edge
range|:
name|edges
control|)
block|{
name|bounds
operator|.
name|addPlane
argument_list|(
name|planetModel
argument_list|,
name|edge
argument_list|,
name|eitherBounds
operator|.
name|get
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Membership
name|m
init|=
name|intersectionBounds
operator|.
name|get
argument_list|(
name|edge
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|!=
literal|null
condition|)
block|{
name|bounds
operator|.
name|addIntersection
argument_list|(
name|planetModel
argument_list|,
name|edgePlanes
operator|.
name|get
argument_list|(
name|edge
argument_list|)
argument_list|,
name|edge
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|outsideDistance
specifier|protected
name|double
name|outsideDistance
parameter_list|(
specifier|final
name|DistanceStyle
name|distanceStyle
parameter_list|,
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
name|double
name|minimumDistance
init|=
name|Double
operator|.
name|POSITIVE_INFINITY
decl_stmt|;
for|for
control|(
specifier|final
name|GeoPoint
name|edgePoint
range|:
name|points
control|)
block|{
specifier|final
name|double
name|newDist
init|=
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|edgePoint
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDist
operator|<
name|minimumDistance
condition|)
block|{
name|minimumDistance
operator|=
name|newDist
expr_stmt|;
block|}
block|}
for|for
control|(
specifier|final
name|SidedPlane
name|edgePlane
range|:
name|edges
control|)
block|{
specifier|final
name|double
name|newDist
init|=
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|planetModel
argument_list|,
name|edgePlane
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|eitherBounds
operator|.
name|get
argument_list|(
name|edgePlane
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDist
operator|<
name|minimumDistance
condition|)
block|{
name|minimumDistance
operator|=
name|newDist
expr_stmt|;
block|}
block|}
if|if
condition|(
name|holes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
specifier|final
name|GeoPolygon
name|hole
range|:
name|holes
control|)
block|{
name|double
name|holeDistance
init|=
name|hole
operator|.
name|computeOutsideDistance
argument_list|(
name|distanceStyle
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|holeDistance
operator|!=
literal|0.0
operator|&&
name|holeDistance
operator|<
name|minimumDistance
condition|)
block|{
name|minimumDistance
operator|=
name|holeDistance
expr_stmt|;
block|}
block|}
block|}
return|return
name|minimumDistance
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|GeoConcavePolygon
operator|)
condition|)
return|return
literal|false
return|;
name|GeoConcavePolygon
name|other
init|=
operator|(
name|GeoConcavePolygon
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|!
name|super
operator|.
name|equals
argument_list|(
name|other
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|other
operator|.
name|isInternalEdges
operator|.
name|equals
argument_list|(
name|isInternalEdges
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|other
operator|.
name|holes
operator|!=
literal|null
operator|||
name|holes
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|holes
operator|==
literal|null
operator|||
name|holes
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|other
operator|.
name|holes
operator|.
name|equals
argument_list|(
name|holes
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
operator|(
name|other
operator|.
name|points
operator|.
name|equals
argument_list|(
name|points
argument_list|)
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|super
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|points
operator|.
name|hashCode
argument_list|()
expr_stmt|;
if|if
condition|(
name|holes
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|holes
operator|.
name|hashCode
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"GeoConcavePolygon: {planetmodel="
operator|+
name|planetModel
operator|+
literal|", points="
operator|+
name|points
operator|+
literal|", internalEdges="
operator|+
name|isInternalEdges
operator|+
operator|(
operator|(
name|holes
operator|==
literal|null
operator|)
condition|?
literal|""
else|:
literal|", holes="
operator|+
name|holes
operator|)
operator|+
literal|"}"
return|;
block|}
block|}
end_class
end_unit
