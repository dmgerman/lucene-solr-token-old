begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.spatial3d.geom
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_comment
comment|/**  * GeoComplexPolygon objects are structures designed to handle very large numbers of edges.  * They perform very well in this case compared to the alternatives, which all have O(N) evaluation  * and O(N^2) setup times.  Complex polygons have O(N) setup times and best case O(log(N))  * evaluation times.  *  * The tradeoff is that these objects perform object creation when evaluating intersects() and  * isWithin().  *  * @lucene.internal  */
end_comment
begin_class
DECL|class|GeoComplexPolygon
class|class
name|GeoComplexPolygon
extends|extends
name|GeoBasePolygon
block|{
DECL|field|xTree
specifier|private
specifier|final
name|Tree
name|xTree
decl_stmt|;
DECL|field|yTree
specifier|private
specifier|final
name|Tree
name|yTree
decl_stmt|;
DECL|field|zTree
specifier|private
specifier|final
name|Tree
name|zTree
decl_stmt|;
DECL|field|testPointInSet
specifier|private
specifier|final
name|boolean
name|testPointInSet
decl_stmt|;
DECL|field|testPoint
specifier|private
specifier|final
name|GeoPoint
name|testPoint
decl_stmt|;
DECL|field|testPointFixedYPlane
specifier|private
specifier|final
name|Plane
name|testPointFixedYPlane
decl_stmt|;
DECL|field|testPointFixedYAbovePlane
specifier|private
specifier|final
name|Plane
name|testPointFixedYAbovePlane
decl_stmt|;
DECL|field|testPointFixedYBelowPlane
specifier|private
specifier|final
name|Plane
name|testPointFixedYBelowPlane
decl_stmt|;
DECL|field|testPointFixedXPlane
specifier|private
specifier|final
name|Plane
name|testPointFixedXPlane
decl_stmt|;
DECL|field|testPointFixedXAbovePlane
specifier|private
specifier|final
name|Plane
name|testPointFixedXAbovePlane
decl_stmt|;
DECL|field|testPointFixedXBelowPlane
specifier|private
specifier|final
name|Plane
name|testPointFixedXBelowPlane
decl_stmt|;
DECL|field|testPointFixedZPlane
specifier|private
specifier|final
name|Plane
name|testPointFixedZPlane
decl_stmt|;
DECL|field|testPointFixedZAbovePlane
specifier|private
specifier|final
name|Plane
name|testPointFixedZAbovePlane
decl_stmt|;
DECL|field|testPointFixedZBelowPlane
specifier|private
specifier|final
name|Plane
name|testPointFixedZBelowPlane
decl_stmt|;
DECL|field|edgePoints
specifier|private
specifier|final
name|GeoPoint
index|[]
name|edgePoints
decl_stmt|;
DECL|field|shapeStartEdges
specifier|private
specifier|final
name|Edge
index|[]
name|shapeStartEdges
decl_stmt|;
comment|/**    * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of    * set.    *@param planetModel is the planet model.    *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied    *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that    *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed    *  that no edges intersect, but the structure can contain both outer rings as well as holes.    *@param testPoint is the point whose in/out of setness is known.    *@param testPointInSet is true if the test point is considered "within" the polygon.    */
DECL|method|GeoComplexPolygon
specifier|public
name|GeoComplexPolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|GeoPoint
argument_list|>
argument_list|>
name|pointsList
parameter_list|,
specifier|final
name|GeoPoint
name|testPoint
parameter_list|,
specifier|final
name|boolean
name|testPointInSet
parameter_list|)
block|{
name|super
argument_list|(
name|planetModel
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointInSet
operator|=
name|testPointInSet
expr_stmt|;
name|this
operator|.
name|testPoint
operator|=
name|testPoint
expr_stmt|;
name|this
operator|.
name|testPointFixedYPlane
operator|=
operator|new
name|Plane
argument_list|(
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
operator|-
name|testPoint
operator|.
name|y
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointFixedXPlane
operator|=
operator|new
name|Plane
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
operator|-
name|testPoint
operator|.
name|x
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointFixedZPlane
operator|=
operator|new
name|Plane
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
operator|-
name|testPoint
operator|.
name|z
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointFixedYAbovePlane
operator|=
operator|new
name|Plane
argument_list|(
name|testPointFixedYPlane
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointFixedYBelowPlane
operator|=
operator|new
name|Plane
argument_list|(
name|testPointFixedYPlane
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointFixedXAbovePlane
operator|=
operator|new
name|Plane
argument_list|(
name|testPointFixedXPlane
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointFixedXBelowPlane
operator|=
operator|new
name|Plane
argument_list|(
name|testPointFixedXPlane
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointFixedZAbovePlane
operator|=
operator|new
name|Plane
argument_list|(
name|testPointFixedZPlane
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointFixedZBelowPlane
operator|=
operator|new
name|Plane
argument_list|(
name|testPointFixedZPlane
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|edgePoints
operator|=
operator|new
name|GeoPoint
index|[
name|pointsList
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|this
operator|.
name|shapeStartEdges
operator|=
operator|new
name|Edge
index|[
name|pointsList
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
specifier|final
name|ArrayList
argument_list|<
name|Edge
argument_list|>
name|allEdges
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|edgePointIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|shapePoints
range|:
name|pointsList
control|)
block|{
name|allEdges
operator|.
name|ensureCapacity
argument_list|(
name|allEdges
operator|.
name|size
argument_list|()
operator|+
name|shapePoints
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|GeoPoint
name|lastGeoPoint
init|=
name|shapePoints
operator|.
name|get
argument_list|(
name|shapePoints
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|edgePoints
index|[
name|edgePointIndex
index|]
operator|=
name|lastGeoPoint
expr_stmt|;
name|Edge
name|lastEdge
init|=
literal|null
decl_stmt|;
name|Edge
name|firstEdge
init|=
literal|null
decl_stmt|;
for|for
control|(
specifier|final
name|GeoPoint
name|thisGeoPoint
range|:
name|shapePoints
control|)
block|{
specifier|final
name|Edge
name|edge
init|=
operator|new
name|Edge
argument_list|(
name|planetModel
argument_list|,
name|lastGeoPoint
argument_list|,
name|thisGeoPoint
argument_list|)
decl_stmt|;
name|allEdges
operator|.
name|add
argument_list|(
name|edge
argument_list|)
expr_stmt|;
comment|// Now, link
if|if
condition|(
name|firstEdge
operator|==
literal|null
condition|)
block|{
name|firstEdge
operator|=
name|edge
expr_stmt|;
block|}
if|if
condition|(
name|lastEdge
operator|!=
literal|null
condition|)
block|{
name|lastEdge
operator|.
name|next
operator|=
name|edge
expr_stmt|;
name|edge
operator|.
name|previous
operator|=
name|lastEdge
expr_stmt|;
block|}
name|lastEdge
operator|=
name|edge
expr_stmt|;
name|lastGeoPoint
operator|=
name|thisGeoPoint
expr_stmt|;
block|}
name|firstEdge
operator|.
name|previous
operator|=
name|lastEdge
expr_stmt|;
name|lastEdge
operator|.
name|next
operator|=
name|firstEdge
expr_stmt|;
name|shapeStartEdges
index|[
name|edgePointIndex
index|]
operator|=
name|firstEdge
expr_stmt|;
name|edgePointIndex
operator|++
expr_stmt|;
block|}
name|xTree
operator|=
operator|new
name|XTree
argument_list|(
name|allEdges
argument_list|)
expr_stmt|;
name|yTree
operator|=
operator|new
name|YTree
argument_list|(
name|allEdges
argument_list|)
expr_stmt|;
name|zTree
operator|=
operator|new
name|ZTree
argument_list|(
name|allEdges
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|isWithin
argument_list|(
operator|new
name|Vector
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|Vector
name|thePoint
parameter_list|)
block|{
comment|// If we're right on top of the point, we know the answer.
if|if
condition|(
name|testPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|thePoint
argument_list|)
condition|)
block|{
return|return
name|testPointInSet
return|;
block|}
comment|// If we're right on top of any of the test planes, we navigate solely on that plane.
if|if
condition|(
name|testPointFixedYPlane
operator|.
name|evaluateIsZero
argument_list|(
name|thePoint
argument_list|)
condition|)
block|{
comment|// Use the XZ plane exclusively.
specifier|final
name|LinearCrossingEdgeIterator
name|crossingEdgeIterator
init|=
operator|new
name|LinearCrossingEdgeIterator
argument_list|(
name|testPointFixedYPlane
argument_list|,
name|testPointFixedYAbovePlane
argument_list|,
name|testPointFixedYBelowPlane
argument_list|,
name|testPoint
argument_list|,
name|thePoint
argument_list|)
decl_stmt|;
comment|// Traverse our way from the test point to the check point.  Use the y tree because that's fixed.
if|if
condition|(
operator|!
name|yTree
operator|.
name|traverse
argument_list|(
name|crossingEdgeIterator
argument_list|,
name|testPoint
operator|.
name|y
argument_list|)
condition|)
block|{
comment|// Endpoint is on edge
return|return
literal|true
return|;
block|}
return|return
operator|(
operator|(
name|crossingEdgeIterator
operator|.
name|crossingCount
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|?
name|testPointInSet
else|:
operator|!
name|testPointInSet
return|;
block|}
elseif|else
if|if
condition|(
name|testPointFixedXPlane
operator|.
name|evaluateIsZero
argument_list|(
name|thePoint
argument_list|)
condition|)
block|{
comment|// Use the YZ plane exclusively.
specifier|final
name|LinearCrossingEdgeIterator
name|crossingEdgeIterator
init|=
operator|new
name|LinearCrossingEdgeIterator
argument_list|(
name|testPointFixedXPlane
argument_list|,
name|testPointFixedXAbovePlane
argument_list|,
name|testPointFixedXBelowPlane
argument_list|,
name|testPoint
argument_list|,
name|thePoint
argument_list|)
decl_stmt|;
comment|// Traverse our way from the test point to the check point.  Use the x tree because that's fixed.
if|if
condition|(
operator|!
name|xTree
operator|.
name|traverse
argument_list|(
name|crossingEdgeIterator
argument_list|,
name|testPoint
operator|.
name|x
argument_list|)
condition|)
block|{
comment|// Endpoint is on edge
return|return
literal|true
return|;
block|}
return|return
operator|(
operator|(
name|crossingEdgeIterator
operator|.
name|crossingCount
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|?
name|testPointInSet
else|:
operator|!
name|testPointInSet
return|;
block|}
elseif|else
if|if
condition|(
name|testPointFixedZPlane
operator|.
name|evaluateIsZero
argument_list|(
name|thePoint
argument_list|)
condition|)
block|{
comment|// Use the XY plane exclusively.
specifier|final
name|LinearCrossingEdgeIterator
name|crossingEdgeIterator
init|=
operator|new
name|LinearCrossingEdgeIterator
argument_list|(
name|testPointFixedZPlane
argument_list|,
name|testPointFixedZAbovePlane
argument_list|,
name|testPointFixedZBelowPlane
argument_list|,
name|testPoint
argument_list|,
name|thePoint
argument_list|)
decl_stmt|;
comment|// Traverse our way from the test point to the check point.  Use the z tree because that's fixed.
if|if
condition|(
operator|!
name|zTree
operator|.
name|traverse
argument_list|(
name|crossingEdgeIterator
argument_list|,
name|testPoint
operator|.
name|z
argument_list|)
condition|)
block|{
comment|// Endpoint is on edge
return|return
literal|true
return|;
block|}
return|return
operator|(
operator|(
name|crossingEdgeIterator
operator|.
name|crossingCount
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|?
name|testPointInSet
else|:
operator|!
name|testPointInSet
return|;
block|}
else|else
block|{
comment|// We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.
specifier|final
name|Plane
name|travelPlaneFixedX
init|=
operator|new
name|Plane
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
operator|-
name|thePoint
operator|.
name|x
argument_list|)
decl_stmt|;
specifier|final
name|Plane
name|travelPlaneFixedY
init|=
operator|new
name|Plane
argument_list|(
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
operator|-
name|thePoint
operator|.
name|y
argument_list|)
decl_stmt|;
specifier|final
name|Plane
name|travelPlaneFixedZ
init|=
operator|new
name|Plane
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
operator|-
name|thePoint
operator|.
name|z
argument_list|)
decl_stmt|;
comment|// Find the intersection points for each one of these and the complementary test point planes.
specifier|final
name|GeoPoint
index|[]
name|XIntersectionsY
init|=
name|travelPlaneFixedX
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointFixedYPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|XIntersectionsZ
init|=
name|travelPlaneFixedX
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointFixedZPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|YIntersectionsX
init|=
name|travelPlaneFixedY
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointFixedXPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|YIntersectionsZ
init|=
name|travelPlaneFixedY
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointFixedZPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|ZIntersectionsX
init|=
name|travelPlaneFixedZ
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointFixedXPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|ZIntersectionsY
init|=
name|travelPlaneFixedZ
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointFixedYPlane
argument_list|)
decl_stmt|;
comment|// There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.
name|double
name|bestDistance
init|=
name|Double
operator|.
name|MAX_VALUE
decl_stmt|;
name|double
name|firstLegValue
init|=
literal|0.0
decl_stmt|;
name|double
name|secondLegValue
init|=
literal|0.0
decl_stmt|;
name|Plane
name|firstLegPlane
init|=
literal|null
decl_stmt|;
name|Plane
name|firstLegAbovePlane
init|=
literal|null
decl_stmt|;
name|Plane
name|firstLegBelowPlane
init|=
literal|null
decl_stmt|;
name|Plane
name|secondLegPlane
init|=
literal|null
decl_stmt|;
name|Tree
name|firstLegTree
init|=
literal|null
decl_stmt|;
name|Tree
name|secondLegTree
init|=
literal|null
decl_stmt|;
name|GeoPoint
name|intersectionPoint
init|=
literal|null
decl_stmt|;
for|for
control|(
specifier|final
name|GeoPoint
name|p
range|:
name|XIntersectionsY
control|)
block|{
comment|// Travel would be in YZ plane (fixed x) then in XZ (fixed y)
specifier|final
name|double
name|newDistance
init|=
name|Math
operator|.
name|abs
argument_list|(
name|testPoint
operator|.
name|x
operator|-
name|p
operator|.
name|x
argument_list|)
operator|+
name|Math
operator|.
name|abs
argument_list|(
name|thePoint
operator|.
name|y
operator|-
name|p
operator|.
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDistance
operator|<
name|bestDistance
condition|)
block|{
name|bestDistance
operator|=
name|newDistance
expr_stmt|;
name|firstLegValue
operator|=
name|testPoint
operator|.
name|y
expr_stmt|;
name|secondLegValue
operator|=
name|thePoint
operator|.
name|x
expr_stmt|;
name|firstLegPlane
operator|=
name|testPointFixedYPlane
expr_stmt|;
name|firstLegAbovePlane
operator|=
name|testPointFixedYAbovePlane
expr_stmt|;
name|firstLegBelowPlane
operator|=
name|testPointFixedYBelowPlane
expr_stmt|;
name|secondLegPlane
operator|=
name|travelPlaneFixedX
expr_stmt|;
name|firstLegTree
operator|=
name|yTree
expr_stmt|;
name|secondLegTree
operator|=
name|xTree
expr_stmt|;
name|intersectionPoint
operator|=
name|p
expr_stmt|;
block|}
block|}
for|for
control|(
specifier|final
name|GeoPoint
name|p
range|:
name|XIntersectionsZ
control|)
block|{
comment|// Travel would be in YZ plane (fixed x) then in XY (fixed z)
specifier|final
name|double
name|newDistance
init|=
name|Math
operator|.
name|abs
argument_list|(
name|testPoint
operator|.
name|x
operator|-
name|p
operator|.
name|x
argument_list|)
operator|+
name|Math
operator|.
name|abs
argument_list|(
name|thePoint
operator|.
name|z
operator|-
name|p
operator|.
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDistance
operator|<
name|bestDistance
condition|)
block|{
name|bestDistance
operator|=
name|newDistance
expr_stmt|;
name|firstLegValue
operator|=
name|testPoint
operator|.
name|z
expr_stmt|;
name|secondLegValue
operator|=
name|thePoint
operator|.
name|x
expr_stmt|;
name|firstLegPlane
operator|=
name|testPointFixedZPlane
expr_stmt|;
name|firstLegAbovePlane
operator|=
name|testPointFixedZAbovePlane
expr_stmt|;
name|firstLegBelowPlane
operator|=
name|testPointFixedZBelowPlane
expr_stmt|;
name|secondLegPlane
operator|=
name|travelPlaneFixedX
expr_stmt|;
name|firstLegTree
operator|=
name|zTree
expr_stmt|;
name|secondLegTree
operator|=
name|xTree
expr_stmt|;
name|intersectionPoint
operator|=
name|p
expr_stmt|;
block|}
block|}
for|for
control|(
specifier|final
name|GeoPoint
name|p
range|:
name|YIntersectionsX
control|)
block|{
comment|// Travel would be in XZ plane (fixed y) then in YZ (fixed x)
specifier|final
name|double
name|newDistance
init|=
name|Math
operator|.
name|abs
argument_list|(
name|testPoint
operator|.
name|y
operator|-
name|p
operator|.
name|y
argument_list|)
operator|+
name|Math
operator|.
name|abs
argument_list|(
name|thePoint
operator|.
name|x
operator|-
name|p
operator|.
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDistance
operator|<
name|bestDistance
condition|)
block|{
name|bestDistance
operator|=
name|newDistance
expr_stmt|;
name|firstLegValue
operator|=
name|testPoint
operator|.
name|x
expr_stmt|;
name|secondLegValue
operator|=
name|thePoint
operator|.
name|y
expr_stmt|;
name|firstLegPlane
operator|=
name|testPointFixedXPlane
expr_stmt|;
name|firstLegAbovePlane
operator|=
name|testPointFixedXAbovePlane
expr_stmt|;
name|firstLegBelowPlane
operator|=
name|testPointFixedXBelowPlane
expr_stmt|;
name|secondLegPlane
operator|=
name|travelPlaneFixedY
expr_stmt|;
name|firstLegTree
operator|=
name|xTree
expr_stmt|;
name|secondLegTree
operator|=
name|yTree
expr_stmt|;
name|intersectionPoint
operator|=
name|p
expr_stmt|;
block|}
block|}
for|for
control|(
specifier|final
name|GeoPoint
name|p
range|:
name|YIntersectionsZ
control|)
block|{
comment|// Travel would be in XZ plane (fixed y) then in XY (fixed z)
specifier|final
name|double
name|newDistance
init|=
name|Math
operator|.
name|abs
argument_list|(
name|testPoint
operator|.
name|y
operator|-
name|p
operator|.
name|y
argument_list|)
operator|+
name|Math
operator|.
name|abs
argument_list|(
name|thePoint
operator|.
name|z
operator|-
name|p
operator|.
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDistance
operator|<
name|bestDistance
condition|)
block|{
name|bestDistance
operator|=
name|newDistance
expr_stmt|;
name|firstLegValue
operator|=
name|testPoint
operator|.
name|z
expr_stmt|;
name|secondLegValue
operator|=
name|thePoint
operator|.
name|y
expr_stmt|;
name|firstLegPlane
operator|=
name|testPointFixedZPlane
expr_stmt|;
name|firstLegAbovePlane
operator|=
name|testPointFixedZAbovePlane
expr_stmt|;
name|firstLegBelowPlane
operator|=
name|testPointFixedZBelowPlane
expr_stmt|;
name|secondLegPlane
operator|=
name|travelPlaneFixedY
expr_stmt|;
name|firstLegTree
operator|=
name|zTree
expr_stmt|;
name|secondLegTree
operator|=
name|yTree
expr_stmt|;
name|intersectionPoint
operator|=
name|p
expr_stmt|;
block|}
block|}
for|for
control|(
specifier|final
name|GeoPoint
name|p
range|:
name|ZIntersectionsX
control|)
block|{
comment|// Travel would be in XY plane (fixed z) then in YZ (fixed x)
specifier|final
name|double
name|newDistance
init|=
name|Math
operator|.
name|abs
argument_list|(
name|testPoint
operator|.
name|z
operator|-
name|p
operator|.
name|z
argument_list|)
operator|+
name|Math
operator|.
name|abs
argument_list|(
name|thePoint
operator|.
name|x
operator|-
name|p
operator|.
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDistance
operator|<
name|bestDistance
condition|)
block|{
name|bestDistance
operator|=
name|newDistance
expr_stmt|;
name|firstLegValue
operator|=
name|testPoint
operator|.
name|x
expr_stmt|;
name|secondLegValue
operator|=
name|thePoint
operator|.
name|z
expr_stmt|;
name|firstLegPlane
operator|=
name|testPointFixedXPlane
expr_stmt|;
name|firstLegAbovePlane
operator|=
name|testPointFixedXAbovePlane
expr_stmt|;
name|firstLegBelowPlane
operator|=
name|testPointFixedXBelowPlane
expr_stmt|;
name|secondLegPlane
operator|=
name|travelPlaneFixedZ
expr_stmt|;
name|firstLegTree
operator|=
name|xTree
expr_stmt|;
name|secondLegTree
operator|=
name|zTree
expr_stmt|;
name|intersectionPoint
operator|=
name|p
expr_stmt|;
block|}
block|}
for|for
control|(
specifier|final
name|GeoPoint
name|p
range|:
name|ZIntersectionsY
control|)
block|{
comment|// Travel would be in XY plane (fixed z) then in XZ (fixed y)
specifier|final
name|double
name|newDistance
init|=
name|Math
operator|.
name|abs
argument_list|(
name|testPoint
operator|.
name|z
operator|-
name|p
operator|.
name|z
argument_list|)
operator|+
name|Math
operator|.
name|abs
argument_list|(
name|thePoint
operator|.
name|y
operator|-
name|p
operator|.
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDistance
operator|<
name|bestDistance
condition|)
block|{
name|bestDistance
operator|=
name|newDistance
expr_stmt|;
name|firstLegValue
operator|=
name|testPoint
operator|.
name|y
expr_stmt|;
name|secondLegValue
operator|=
name|thePoint
operator|.
name|z
expr_stmt|;
name|firstLegPlane
operator|=
name|testPointFixedYPlane
expr_stmt|;
name|firstLegAbovePlane
operator|=
name|testPointFixedYAbovePlane
expr_stmt|;
name|firstLegBelowPlane
operator|=
name|testPointFixedYBelowPlane
expr_stmt|;
name|secondLegPlane
operator|=
name|travelPlaneFixedZ
expr_stmt|;
name|firstLegTree
operator|=
name|yTree
expr_stmt|;
name|secondLegTree
operator|=
name|zTree
expr_stmt|;
name|intersectionPoint
operator|=
name|p
expr_stmt|;
block|}
block|}
assert|assert
name|bestDistance
operator|>
literal|0.0
operator|:
literal|"Best distance should not be zero unless on single plane"
assert|;
assert|assert
name|bestDistance
operator|<
name|Double
operator|.
name|MAX_VALUE
operator|:
literal|"Couldn't find an intersection point of any kind"
assert|;
specifier|final
name|DualCrossingEdgeIterator
name|edgeIterator
init|=
operator|new
name|DualCrossingEdgeIterator
argument_list|(
name|firstLegPlane
argument_list|,
name|firstLegAbovePlane
argument_list|,
name|firstLegBelowPlane
argument_list|,
name|secondLegPlane
argument_list|,
name|testPoint
argument_list|,
name|thePoint
argument_list|,
name|intersectionPoint
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|firstLegTree
operator|.
name|traverse
argument_list|(
name|edgeIterator
argument_list|,
name|firstLegValue
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|edgeIterator
operator|.
name|setSecondLeg
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|secondLegTree
operator|.
name|traverse
argument_list|(
name|edgeIterator
argument_list|,
name|secondLegValue
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
operator|(
operator|(
name|edgeIterator
operator|.
name|crossingCount
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|?
name|testPointInSet
else|:
operator|!
name|testPointInSet
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getEdgePoints
specifier|public
name|GeoPoint
index|[]
name|getEdgePoints
parameter_list|()
block|{
return|return
name|edgePoints
return|;
block|}
annotation|@
name|Override
DECL|method|intersects
specifier|public
name|boolean
name|intersects
parameter_list|(
specifier|final
name|Plane
name|p
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|notablePoints
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
comment|// Create the intersector
specifier|final
name|EdgeIterator
name|intersector
init|=
operator|new
name|IntersectorEdgeIterator
argument_list|(
name|p
argument_list|,
name|notablePoints
argument_list|,
name|bounds
argument_list|)
decl_stmt|;
comment|// First, compute the bounds for the the plane
specifier|final
name|XYZBounds
name|xyzBounds
init|=
operator|new
name|XYZBounds
argument_list|()
decl_stmt|;
name|p
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|xyzBounds
argument_list|,
name|bounds
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|GeoPoint
name|point
range|:
name|notablePoints
control|)
block|{
name|xyzBounds
operator|.
name|addPoint
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
comment|// Figure out which tree likely works best
specifier|final
name|double
name|xDelta
init|=
name|xyzBounds
operator|.
name|getMaximumX
argument_list|()
operator|-
name|xyzBounds
operator|.
name|getMinimumX
argument_list|()
decl_stmt|;
specifier|final
name|double
name|yDelta
init|=
name|xyzBounds
operator|.
name|getMaximumY
argument_list|()
operator|-
name|xyzBounds
operator|.
name|getMinimumY
argument_list|()
decl_stmt|;
specifier|final
name|double
name|zDelta
init|=
name|xyzBounds
operator|.
name|getMaximumZ
argument_list|()
operator|-
name|xyzBounds
operator|.
name|getMinimumZ
argument_list|()
decl_stmt|;
comment|// Select the smallest range
if|if
condition|(
name|xDelta
operator|<=
name|yDelta
operator|&&
name|xDelta
operator|<=
name|zDelta
condition|)
block|{
comment|// Drill down in x
return|return
operator|!
name|xTree
operator|.
name|traverse
argument_list|(
name|intersector
argument_list|,
name|xyzBounds
operator|.
name|getMinimumX
argument_list|()
argument_list|,
name|xyzBounds
operator|.
name|getMaximumX
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|yDelta
operator|<=
name|xDelta
operator|&&
name|yDelta
operator|<=
name|zDelta
condition|)
block|{
comment|// Drill down in y
return|return
operator|!
name|yTree
operator|.
name|traverse
argument_list|(
name|intersector
argument_list|,
name|xyzBounds
operator|.
name|getMinimumY
argument_list|()
argument_list|,
name|xyzBounds
operator|.
name|getMaximumY
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|zDelta
operator|<=
name|xDelta
operator|&&
name|zDelta
operator|<=
name|yDelta
condition|)
block|{
comment|// Drill down in z
return|return
operator|!
name|zTree
operator|.
name|traverse
argument_list|(
name|intersector
argument_list|,
name|xyzBounds
operator|.
name|getMinimumZ
argument_list|()
argument_list|,
name|xyzBounds
operator|.
name|getMaximumZ
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|getBounds
specifier|public
name|void
name|getBounds
parameter_list|(
name|Bounds
name|bounds
parameter_list|)
block|{
name|super
operator|.
name|getBounds
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|Edge
name|startEdge
range|:
name|shapeStartEdges
control|)
block|{
name|Edge
name|currentEdge
init|=
name|startEdge
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|bounds
operator|.
name|addPoint
argument_list|(
name|currentEdge
operator|.
name|startPoint
argument_list|)
expr_stmt|;
name|bounds
operator|.
name|addPlane
argument_list|(
name|this
operator|.
name|planetModel
argument_list|,
name|currentEdge
operator|.
name|plane
argument_list|,
name|currentEdge
operator|.
name|startPlane
argument_list|,
name|currentEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
name|currentEdge
operator|=
name|currentEdge
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|currentEdge
operator|==
name|startEdge
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|outsideDistance
specifier|protected
name|double
name|outsideDistance
parameter_list|(
specifier|final
name|DistanceStyle
name|distanceStyle
parameter_list|,
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
name|double
name|minimumDistance
init|=
name|Double
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
specifier|final
name|Edge
name|shapeStartEdge
range|:
name|shapeStartEdges
control|)
block|{
name|Edge
name|shapeEdge
init|=
name|shapeStartEdge
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|double
name|newDist
init|=
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|shapeEdge
operator|.
name|startPoint
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDist
operator|<
name|minimumDistance
condition|)
block|{
name|minimumDistance
operator|=
name|newDist
expr_stmt|;
block|}
specifier|final
name|double
name|newPlaneDist
init|=
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|planetModel
argument_list|,
name|shapeEdge
operator|.
name|plane
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|shapeEdge
operator|.
name|startPlane
argument_list|,
name|shapeEdge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
if|if
condition|(
name|newPlaneDist
operator|<
name|minimumDistance
condition|)
block|{
name|minimumDistance
operator|=
name|newPlaneDist
expr_stmt|;
block|}
name|shapeEdge
operator|=
name|shapeEdge
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|shapeEdge
operator|==
name|shapeStartEdge
condition|)
block|{
break|break;
block|}
block|}
block|}
return|return
name|minimumDistance
return|;
block|}
comment|/**    * An instance of this class describes a single edge, and includes what is necessary to reliably determine intersection    * in the context of the even/odd algorithm used.    */
DECL|class|Edge
specifier|private
specifier|static
class|class
name|Edge
block|{
DECL|field|startPoint
specifier|public
specifier|final
name|GeoPoint
name|startPoint
decl_stmt|;
DECL|field|endPoint
specifier|public
specifier|final
name|GeoPoint
name|endPoint
decl_stmt|;
DECL|field|notablePoints
specifier|public
specifier|final
name|GeoPoint
index|[]
name|notablePoints
decl_stmt|;
DECL|field|startPlane
specifier|public
specifier|final
name|SidedPlane
name|startPlane
decl_stmt|;
DECL|field|endPlane
specifier|public
specifier|final
name|SidedPlane
name|endPlane
decl_stmt|;
DECL|field|plane
specifier|public
specifier|final
name|Plane
name|plane
decl_stmt|;
DECL|field|planeBounds
specifier|public
specifier|final
name|XYZBounds
name|planeBounds
decl_stmt|;
DECL|field|previous
specifier|public
name|Edge
name|previous
init|=
literal|null
decl_stmt|;
DECL|field|next
specifier|public
name|Edge
name|next
init|=
literal|null
decl_stmt|;
DECL|method|Edge
specifier|public
name|Edge
parameter_list|(
specifier|final
name|PlanetModel
name|pm
parameter_list|,
specifier|final
name|GeoPoint
name|startPoint
parameter_list|,
specifier|final
name|GeoPoint
name|endPoint
parameter_list|)
block|{
name|this
operator|.
name|startPoint
operator|=
name|startPoint
expr_stmt|;
name|this
operator|.
name|endPoint
operator|=
name|endPoint
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|startPoint
block|,
name|endPoint
block|}
expr_stmt|;
name|this
operator|.
name|plane
operator|=
operator|new
name|Plane
argument_list|(
name|startPoint
argument_list|,
name|endPoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|startPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|endPoint
argument_list|,
name|plane
argument_list|,
name|startPoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|endPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|startPoint
argument_list|,
name|plane
argument_list|,
name|endPoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|planeBounds
operator|=
operator|new
name|XYZBounds
argument_list|()
expr_stmt|;
name|this
operator|.
name|planeBounds
operator|.
name|addPoint
argument_list|(
name|startPoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|planeBounds
operator|.
name|addPoint
argument_list|(
name|endPoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|plane
operator|.
name|recordBounds
argument_list|(
name|pm
argument_list|,
name|this
operator|.
name|planeBounds
argument_list|,
name|this
operator|.
name|startPlane
argument_list|,
name|this
operator|.
name|endPlane
argument_list|)
expr_stmt|;
comment|//System.err.println("Recording edge "+this+" from "+startPoint+" to "+endPoint+"; bounds = "+planeBounds);
block|}
block|}
comment|/**    * Iterator execution interface, for tree traversal.  Pass an object implementing this interface    * into the traversal method of a tree, and each edge that matches will cause this object to be    * called.    */
DECL|interface|EdgeIterator
specifier|private
specifier|static
interface|interface
name|EdgeIterator
block|{
comment|/**      * @param edge is the edge that matched.      * @return true if the iteration should continue, false otherwise.      */
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
function_decl|;
block|}
comment|/**    * An instance of this class represents a node in a tree.  The tree is designed to be given    * a value and from that to iterate over a list of edges.    * In order to do this efficiently, each new edge is dropped into the tree using its minimum and    * maximum value.  If the new edge's value does not overlap the range, then it gets added    * either to the lesser side or the greater side, accordingly.  If it does overlap, then the    * "overlapping" chain is instead traversed.    *    * This class is generic and can be used for any definition of "value".    *    */
DECL|class|Node
specifier|private
specifier|static
class|class
name|Node
block|{
DECL|field|edge
specifier|public
specifier|final
name|Edge
name|edge
decl_stmt|;
DECL|field|low
specifier|public
specifier|final
name|double
name|low
decl_stmt|;
DECL|field|high
specifier|public
specifier|final
name|double
name|high
decl_stmt|;
DECL|field|left
specifier|public
name|Node
name|left
init|=
literal|null
decl_stmt|;
DECL|field|right
specifier|public
name|Node
name|right
init|=
literal|null
decl_stmt|;
DECL|field|max
specifier|public
name|double
name|max
decl_stmt|;
DECL|method|Node
specifier|public
name|Node
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|,
specifier|final
name|double
name|minimumValue
parameter_list|,
specifier|final
name|double
name|maximumValue
parameter_list|)
block|{
name|this
operator|.
name|edge
operator|=
name|edge
expr_stmt|;
name|this
operator|.
name|low
operator|=
name|minimumValue
expr_stmt|;
name|this
operator|.
name|high
operator|=
name|maximumValue
expr_stmt|;
name|this
operator|.
name|max
operator|=
name|maximumValue
expr_stmt|;
block|}
DECL|method|traverse
specifier|public
name|boolean
name|traverse
parameter_list|(
specifier|final
name|EdgeIterator
name|edgeIterator
parameter_list|,
specifier|final
name|double
name|minValue
parameter_list|,
specifier|final
name|double
name|maxValue
parameter_list|)
block|{
if|if
condition|(
name|minValue
operator|<=
name|max
condition|)
block|{
comment|// Does this node overlap?
if|if
condition|(
name|minValue
operator|<=
name|high
operator|&&
name|maxValue
operator|>=
name|low
condition|)
block|{
if|if
condition|(
name|edgeIterator
operator|.
name|matches
argument_list|(
name|edge
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|left
operator|!=
literal|null
operator|&&
name|left
operator|.
name|traverse
argument_list|(
name|edgeIterator
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|right
operator|!=
literal|null
operator|&&
name|minValue
operator|>=
name|low
operator|&&
name|right
operator|.
name|traverse
argument_list|(
name|edgeIterator
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/** An interface describing a tree.    */
DECL|class|Tree
specifier|private
specifier|static
specifier|abstract
class|class
name|Tree
block|{
DECL|field|rootNode
specifier|private
specifier|final
name|Node
name|rootNode
decl_stmt|;
DECL|field|EMPTY_ARRAY
specifier|protected
specifier|static
specifier|final
name|Edge
index|[]
name|EMPTY_ARRAY
init|=
operator|new
name|Edge
index|[
literal|0
index|]
decl_stmt|;
comment|/** Constructor.      * @param allEdges is the list of all edges for the tree.      */
DECL|method|Tree
specifier|public
name|Tree
parameter_list|(
specifier|final
name|List
argument_list|<
name|Edge
argument_list|>
name|allEdges
parameter_list|)
block|{
comment|// Dump edges into an array and then sort it
specifier|final
name|Node
index|[]
name|edges
init|=
operator|new
name|Node
index|[
name|allEdges
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|Edge
name|edge
range|:
name|allEdges
control|)
block|{
name|edges
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|Node
argument_list|(
name|edge
argument_list|,
name|getMinimum
argument_list|(
name|edge
argument_list|)
argument_list|,
name|getMaximum
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|edges
argument_list|,
parameter_list|(
name|left
parameter_list|,
name|right
parameter_list|)
lambda|->
block|{
name|int
name|ret
init|=
name|Double
operator|.
name|compare
argument_list|(
name|left
operator|.
name|low
argument_list|,
name|right
operator|.
name|low
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|Double
operator|.
name|compare
argument_list|(
name|left
operator|.
name|max
argument_list|,
name|right
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
argument_list|)
expr_stmt|;
name|rootNode
operator|=
name|createTree
argument_list|(
name|edges
argument_list|,
literal|0
argument_list|,
name|edges
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|createTree
specifier|private
specifier|static
name|Node
name|createTree
parameter_list|(
specifier|final
name|Node
index|[]
name|edges
parameter_list|,
specifier|final
name|int
name|low
parameter_list|,
specifier|final
name|int
name|high
parameter_list|)
block|{
if|if
condition|(
name|low
operator|>
name|high
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// add midpoint
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
specifier|final
name|Node
name|newNode
init|=
name|edges
index|[
name|mid
index|]
decl_stmt|;
comment|// add children
name|newNode
operator|.
name|left
operator|=
name|createTree
argument_list|(
name|edges
argument_list|,
name|low
argument_list|,
name|mid
operator|-
literal|1
argument_list|)
expr_stmt|;
name|newNode
operator|.
name|right
operator|=
name|createTree
argument_list|(
name|edges
argument_list|,
name|mid
operator|+
literal|1
argument_list|,
name|high
argument_list|)
expr_stmt|;
comment|// pull up max values to this node
if|if
condition|(
name|newNode
operator|.
name|left
operator|!=
literal|null
condition|)
block|{
name|newNode
operator|.
name|max
operator|=
name|Math
operator|.
name|max
argument_list|(
name|newNode
operator|.
name|max
argument_list|,
name|newNode
operator|.
name|left
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newNode
operator|.
name|right
operator|!=
literal|null
condition|)
block|{
name|newNode
operator|.
name|max
operator|=
name|Math
operator|.
name|max
argument_list|(
name|newNode
operator|.
name|max
argument_list|,
name|newNode
operator|.
name|right
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
return|return
name|newNode
return|;
block|}
comment|/** Get the minimum value from the edge.      * @param edge is the edge.      * @return the minimum value.      */
DECL|method|getMinimum
specifier|protected
specifier|abstract
name|double
name|getMinimum
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
function_decl|;
comment|/** Get the maximum value from the edge.      * @param edge is the edge.      * @return the maximum value.      */
DECL|method|getMaximum
specifier|protected
specifier|abstract
name|double
name|getMaximum
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
function_decl|;
comment|/** Traverse the tree, finding all edges that intersect the provided value.      * @param edgeIterator provides the method to call for any encountered matching edge.      * @param value is the value to match.      * @return false if the traversal was aborted before completion.      */
DECL|method|traverse
specifier|public
name|boolean
name|traverse
parameter_list|(
specifier|final
name|EdgeIterator
name|edgeIterator
parameter_list|,
specifier|final
name|double
name|value
parameter_list|)
block|{
return|return
name|traverse
argument_list|(
name|edgeIterator
argument_list|,
name|value
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** Traverse the tree, finding all edges that intersect the provided value range.      * @param edgeIterator provides the method to call for any encountered matching edge.      *   Edges will not be invoked more than once.      * @param minValue is the minimum value.      * @param maxValue is the maximum value.      * @return false if the traversal was aborted before completion.      */
DECL|method|traverse
specifier|public
name|boolean
name|traverse
parameter_list|(
specifier|final
name|EdgeIterator
name|edgeIterator
parameter_list|,
specifier|final
name|double
name|minValue
parameter_list|,
specifier|final
name|double
name|maxValue
parameter_list|)
block|{
if|if
condition|(
name|rootNode
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|rootNode
operator|.
name|traverse
argument_list|(
name|edgeIterator
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|)
return|;
block|}
block|}
comment|/** This is the z-tree.    */
DECL|class|ZTree
specifier|private
specifier|static
class|class
name|ZTree
extends|extends
name|Tree
block|{
DECL|field|rootNode
specifier|public
name|Node
name|rootNode
init|=
literal|null
decl_stmt|;
DECL|method|ZTree
specifier|public
name|ZTree
parameter_list|(
specifier|final
name|List
argument_list|<
name|Edge
argument_list|>
name|allEdges
parameter_list|)
block|{
name|super
argument_list|(
name|allEdges
argument_list|)
expr_stmt|;
block|}
comment|/*     @Override     public boolean traverse(final EdgeIterator edgeIterator, final double value) {       System.err.println("Traversing in Z, value= "+value+"...");       return super.traverse(edgeIterator, value);     }     */
annotation|@
name|Override
DECL|method|getMinimum
specifier|protected
name|double
name|getMinimum
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
return|return
name|edge
operator|.
name|planeBounds
operator|.
name|getMinimumZ
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getMaximum
specifier|protected
name|double
name|getMaximum
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
return|return
name|edge
operator|.
name|planeBounds
operator|.
name|getMaximumZ
argument_list|()
return|;
block|}
block|}
comment|/** This is the y-tree.    */
DECL|class|YTree
specifier|private
specifier|static
class|class
name|YTree
extends|extends
name|Tree
block|{
DECL|method|YTree
specifier|public
name|YTree
parameter_list|(
specifier|final
name|List
argument_list|<
name|Edge
argument_list|>
name|allEdges
parameter_list|)
block|{
name|super
argument_list|(
name|allEdges
argument_list|)
expr_stmt|;
block|}
comment|/*     @Override     public boolean traverse(final EdgeIterator edgeIterator, final double value) {       System.err.println("Traversing in Y, value= "+value+"...");       return super.traverse(edgeIterator, value);     }     */
annotation|@
name|Override
DECL|method|getMinimum
specifier|protected
name|double
name|getMinimum
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
return|return
name|edge
operator|.
name|planeBounds
operator|.
name|getMinimumY
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getMaximum
specifier|protected
name|double
name|getMaximum
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
return|return
name|edge
operator|.
name|planeBounds
operator|.
name|getMaximumY
argument_list|()
return|;
block|}
block|}
comment|/** This is the x-tree.    */
DECL|class|XTree
specifier|private
specifier|static
class|class
name|XTree
extends|extends
name|Tree
block|{
DECL|method|XTree
specifier|public
name|XTree
parameter_list|(
specifier|final
name|List
argument_list|<
name|Edge
argument_list|>
name|allEdges
parameter_list|)
block|{
name|super
argument_list|(
name|allEdges
argument_list|)
expr_stmt|;
block|}
comment|/*     @Override     public boolean traverse(final EdgeIterator edgeIterator, final double value) {       System.err.println("Traversing in X, value= "+value+"...");       return super.traverse(edgeIterator, value);     }     */
annotation|@
name|Override
DECL|method|getMinimum
specifier|protected
name|double
name|getMinimum
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
return|return
name|edge
operator|.
name|planeBounds
operator|.
name|getMinimumX
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getMaximum
specifier|protected
name|double
name|getMaximum
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
return|return
name|edge
operator|.
name|planeBounds
operator|.
name|getMaximumX
argument_list|()
return|;
block|}
block|}
comment|/** Assess whether edge intersects the provided plane plus bounds.    */
DECL|class|IntersectorEdgeIterator
specifier|private
class|class
name|IntersectorEdgeIterator
implements|implements
name|EdgeIterator
block|{
DECL|field|plane
specifier|private
specifier|final
name|Plane
name|plane
decl_stmt|;
DECL|field|notablePoints
specifier|private
specifier|final
name|GeoPoint
index|[]
name|notablePoints
decl_stmt|;
DECL|field|bounds
specifier|private
specifier|final
name|Membership
index|[]
name|bounds
decl_stmt|;
DECL|method|IntersectorEdgeIterator
specifier|public
name|IntersectorEdgeIterator
parameter_list|(
specifier|final
name|Plane
name|plane
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|notablePoints
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
name|this
operator|.
name|plane
operator|=
name|plane
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
name|notablePoints
expr_stmt|;
name|this
operator|.
name|bounds
operator|=
name|bounds
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
return|return
operator|!
name|plane
operator|.
name|intersects
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|notablePoints
argument_list|,
name|edge
operator|.
name|notablePoints
argument_list|,
name|bounds
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
return|;
block|}
block|}
comment|/** Count the number of verifiable edge crossings.    */
DECL|class|LinearCrossingEdgeIterator
specifier|private
class|class
name|LinearCrossingEdgeIterator
implements|implements
name|EdgeIterator
block|{
DECL|field|plane
specifier|private
specifier|final
name|Plane
name|plane
decl_stmt|;
DECL|field|abovePlane
specifier|private
specifier|final
name|Plane
name|abovePlane
decl_stmt|;
DECL|field|belowPlane
specifier|private
specifier|final
name|Plane
name|belowPlane
decl_stmt|;
DECL|field|bound1
specifier|private
specifier|final
name|Membership
name|bound1
decl_stmt|;
DECL|field|bound2
specifier|private
specifier|final
name|Membership
name|bound2
decl_stmt|;
DECL|field|thePoint
specifier|private
specifier|final
name|Vector
name|thePoint
decl_stmt|;
DECL|field|crossingCount
specifier|public
name|int
name|crossingCount
init|=
literal|0
decl_stmt|;
DECL|method|LinearCrossingEdgeIterator
specifier|public
name|LinearCrossingEdgeIterator
parameter_list|(
specifier|final
name|Plane
name|plane
parameter_list|,
specifier|final
name|Plane
name|abovePlane
parameter_list|,
specifier|final
name|Plane
name|belowPlane
parameter_list|,
specifier|final
name|Vector
name|testPoint
parameter_list|,
specifier|final
name|Vector
name|thePoint
parameter_list|)
block|{
name|this
operator|.
name|plane
operator|=
name|plane
expr_stmt|;
name|this
operator|.
name|abovePlane
operator|=
name|abovePlane
expr_stmt|;
name|this
operator|.
name|belowPlane
operator|=
name|belowPlane
expr_stmt|;
name|this
operator|.
name|bound1
operator|=
operator|new
name|SidedPlane
argument_list|(
name|thePoint
argument_list|,
name|plane
argument_list|,
name|testPoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|bound2
operator|=
operator|new
name|SidedPlane
argument_list|(
name|testPoint
argument_list|,
name|plane
argument_list|,
name|thePoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|thePoint
operator|=
name|thePoint
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
comment|// Early exit if the point is on the edge.
if|if
condition|(
name|thePoint
operator|!=
literal|null
operator|&&
name|edge
operator|.
name|plane
operator|.
name|evaluateIsZero
argument_list|(
name|thePoint
argument_list|)
operator|&&
name|edge
operator|.
name|startPlane
operator|.
name|isWithin
argument_list|(
name|thePoint
argument_list|)
operator|&&
name|edge
operator|.
name|endPlane
operator|.
name|isWithin
argument_list|(
name|thePoint
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|GeoPoint
index|[]
name|crossingPoints
init|=
name|plane
operator|.
name|findCrossings
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|bound1
argument_list|,
name|bound2
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
if|if
condition|(
name|crossingPoints
operator|!=
literal|null
condition|)
block|{
comment|// We need to handle the endpoint case, which is quite tricky.
for|for
control|(
specifier|final
name|GeoPoint
name|crossingPoint
range|:
name|crossingPoints
control|)
block|{
name|countCrossingPoint
argument_list|(
name|crossingPoint
argument_list|,
name|edge
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|countCrossingPoint
specifier|private
name|void
name|countCrossingPoint
parameter_list|(
specifier|final
name|GeoPoint
name|crossingPoint
parameter_list|,
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
if|if
condition|(
name|crossingPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|edge
operator|.
name|startPoint
argument_list|)
condition|)
block|{
comment|// We have to figure out if this crossing should be counted.
comment|// Does the crossing for this edge go up, or down?  Or can't we tell?
specifier|final
name|GeoPoint
index|[]
name|aboveIntersections
init|=
name|abovePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|belowIntersections
init|=
name|belowPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
assert|assert
operator|!
operator|(
name|aboveIntersections
operator|.
name|length
operator|>
literal|0
operator|&&
name|belowIntersections
operator|.
name|length
operator|>
literal|0
operator|)
operator|:
literal|"edge that ends in a crossing can't both up and down"
assert|;
if|if
condition|(
name|aboveIntersections
operator|.
name|length
operator|==
literal|0
operator|&&
name|belowIntersections
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return;
block|}
specifier|final
name|boolean
name|edgeCrossesAbove
init|=
name|aboveIntersections
operator|.
name|length
operator|>
literal|0
decl_stmt|;
comment|// This depends on the previous edge that first departs from identicalness.
name|Edge
name|assessEdge
init|=
name|edge
decl_stmt|;
name|GeoPoint
index|[]
name|assessAboveIntersections
decl_stmt|;
name|GeoPoint
index|[]
name|assessBelowIntersections
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|assessEdge
operator|=
name|assessEdge
operator|.
name|previous
expr_stmt|;
name|assessAboveIntersections
operator|=
name|abovePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
name|assessBelowIntersections
operator|=
name|belowPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
assert|assert
operator|!
operator|(
name|assessAboveIntersections
operator|.
name|length
operator|>
literal|0
operator|&&
name|assessBelowIntersections
operator|.
name|length
operator|>
literal|0
operator|)
operator|:
literal|"assess edge that ends in a crossing can't both up and down"
assert|;
if|if
condition|(
name|assessAboveIntersections
operator|.
name|length
operator|==
literal|0
operator|&&
name|assessBelowIntersections
operator|.
name|length
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
break|break;
block|}
comment|// Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite
comment|// directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that
comment|// each edge we look at can also be looked at again if it, too, seems to cross the plane.
comment|// To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make
comment|// a decision whether to count or not based on that.
comment|// Compute the crossing points of this other edge.
specifier|final
name|GeoPoint
index|[]
name|otherCrossingPoints
init|=
name|plane
operator|.
name|findCrossings
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|bound1
argument_list|,
name|bound2
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
comment|// Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the
comment|// transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).
for|for
control|(
specifier|final
name|GeoPoint
name|otherCrossingPoint
range|:
name|otherCrossingPoints
control|)
block|{
if|if
condition|(
name|otherCrossingPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|assessEdge
operator|.
name|endPoint
argument_list|)
condition|)
block|{
comment|// Found it!
comment|// Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.
comment|// Since we're the latter point, we exit here in that case.
return|return;
block|}
block|}
comment|// Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the
comment|// point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges
comment|// and make an assessment that way, since a single edge can intersect the plane at more than one point.
specifier|final
name|boolean
name|assessEdgeAbove
init|=
name|assessAboveIntersections
operator|.
name|length
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|assessEdgeAbove
operator|!=
name|edgeCrossesAbove
condition|)
block|{
name|crossingCount
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|crossingPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|edge
operator|.
name|endPoint
argument_list|)
condition|)
block|{
comment|// Figure out if the crossing should be counted.
comment|// Does the crossing for this edge go up, or down?  Or can't we tell?
specifier|final
name|GeoPoint
index|[]
name|aboveIntersections
init|=
name|abovePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|belowIntersections
init|=
name|belowPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
assert|assert
operator|!
operator|(
name|aboveIntersections
operator|.
name|length
operator|>
literal|0
operator|&&
name|belowIntersections
operator|.
name|length
operator|>
literal|0
operator|)
operator|:
literal|"edge that ends in a crossing can't both up and down"
assert|;
if|if
condition|(
name|aboveIntersections
operator|.
name|length
operator|==
literal|0
operator|&&
name|belowIntersections
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return;
block|}
specifier|final
name|boolean
name|edgeCrossesAbove
init|=
name|aboveIntersections
operator|.
name|length
operator|>
literal|0
decl_stmt|;
comment|// This depends on the previous edge that first departs from identicalness.
name|Edge
name|assessEdge
init|=
name|edge
decl_stmt|;
name|GeoPoint
index|[]
name|assessAboveIntersections
decl_stmt|;
name|GeoPoint
index|[]
name|assessBelowIntersections
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|assessEdge
operator|=
name|assessEdge
operator|.
name|next
expr_stmt|;
name|assessAboveIntersections
operator|=
name|abovePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
name|assessBelowIntersections
operator|=
name|belowPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
assert|assert
operator|!
operator|(
name|assessAboveIntersections
operator|.
name|length
operator|>
literal|0
operator|&&
name|assessBelowIntersections
operator|.
name|length
operator|>
literal|0
operator|)
operator|:
literal|"assess edge that ends in a crossing can't both up and down"
assert|;
if|if
condition|(
name|assessAboveIntersections
operator|.
name|length
operator|==
literal|0
operator|&&
name|assessBelowIntersections
operator|.
name|length
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
break|break;
block|}
comment|// Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite
comment|// directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that
comment|// each edge we look at can also be looked at again if it, too, seems to cross the plane.
comment|// By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary
comment|// to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.
comment|// We need to determine the direction of both edges at the
comment|// point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges
comment|// and make an assessment that way, since a single edge can intersect the plane at more than one point.
specifier|final
name|boolean
name|assessEdgeAbove
init|=
name|assessAboveIntersections
operator|.
name|length
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|assessEdgeAbove
operator|!=
name|edgeCrossesAbove
condition|)
block|{
name|crossingCount
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|crossingCount
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/** Count the number of verifiable edge crossings for a dual-leg journey.    */
DECL|class|DualCrossingEdgeIterator
specifier|private
class|class
name|DualCrossingEdgeIterator
implements|implements
name|EdgeIterator
block|{
DECL|field|isSecondLeg
specifier|private
name|boolean
name|isSecondLeg
init|=
literal|false
decl_stmt|;
DECL|field|testPointPlane
specifier|private
specifier|final
name|Plane
name|testPointPlane
decl_stmt|;
DECL|field|testPointAbovePlane
specifier|private
specifier|final
name|Plane
name|testPointAbovePlane
decl_stmt|;
DECL|field|testPointBelowPlane
specifier|private
specifier|final
name|Plane
name|testPointBelowPlane
decl_stmt|;
DECL|field|travelPlane
specifier|private
specifier|final
name|Plane
name|travelPlane
decl_stmt|;
DECL|field|thePoint
specifier|private
specifier|final
name|Vector
name|thePoint
decl_stmt|;
DECL|field|intersectionPoint
specifier|private
specifier|final
name|GeoPoint
name|intersectionPoint
decl_stmt|;
DECL|field|testPointCutoffPlane
specifier|private
specifier|final
name|SidedPlane
name|testPointCutoffPlane
decl_stmt|;
DECL|field|checkPointCutoffPlane
specifier|private
specifier|final
name|SidedPlane
name|checkPointCutoffPlane
decl_stmt|;
DECL|field|testPointOtherCutoffPlane
specifier|private
specifier|final
name|SidedPlane
name|testPointOtherCutoffPlane
decl_stmt|;
DECL|field|checkPointOtherCutoffPlane
specifier|private
specifier|final
name|SidedPlane
name|checkPointOtherCutoffPlane
decl_stmt|;
comment|// These are computed on an as-needed basis
DECL|field|computedInsideOutside
specifier|private
name|boolean
name|computedInsideOutside
init|=
literal|false
decl_stmt|;
DECL|field|testPointInsidePlane
specifier|private
name|Plane
name|testPointInsidePlane
decl_stmt|;
DECL|field|testPointOutsidePlane
specifier|private
name|Plane
name|testPointOutsidePlane
decl_stmt|;
DECL|field|travelInsidePlane
specifier|private
name|Plane
name|travelInsidePlane
decl_stmt|;
DECL|field|travelOutsidePlane
specifier|private
name|Plane
name|travelOutsidePlane
decl_stmt|;
DECL|field|insideTestPointCutoffPlane
specifier|private
name|SidedPlane
name|insideTestPointCutoffPlane
decl_stmt|;
DECL|field|insideTravelCutoffPlane
specifier|private
name|SidedPlane
name|insideTravelCutoffPlane
decl_stmt|;
comment|// The counter
DECL|field|crossingCount
specifier|public
name|int
name|crossingCount
init|=
literal|0
decl_stmt|;
DECL|method|DualCrossingEdgeIterator
specifier|public
name|DualCrossingEdgeIterator
parameter_list|(
specifier|final
name|Plane
name|testPointPlane
parameter_list|,
specifier|final
name|Plane
name|testPointAbovePlane
parameter_list|,
specifier|final
name|Plane
name|testPointBelowPlane
parameter_list|,
specifier|final
name|Plane
name|travelPlane
parameter_list|,
specifier|final
name|Vector
name|testPoint
parameter_list|,
specifier|final
name|Vector
name|thePoint
parameter_list|,
specifier|final
name|GeoPoint
name|intersectionPoint
parameter_list|)
block|{
name|this
operator|.
name|testPointPlane
operator|=
name|testPointPlane
expr_stmt|;
name|this
operator|.
name|testPointAbovePlane
operator|=
name|testPointAbovePlane
expr_stmt|;
name|this
operator|.
name|testPointBelowPlane
operator|=
name|testPointBelowPlane
expr_stmt|;
name|this
operator|.
name|travelPlane
operator|=
name|travelPlane
expr_stmt|;
name|this
operator|.
name|thePoint
operator|=
name|thePoint
expr_stmt|;
name|this
operator|.
name|intersectionPoint
operator|=
name|intersectionPoint
expr_stmt|;
comment|//System.err.println("Intersection point = "+intersectionPoint);
assert|assert
name|travelPlane
operator|.
name|evaluateIsZero
argument_list|(
name|intersectionPoint
argument_list|)
operator|:
literal|"intersection point must be on travel plane"
assert|;
assert|assert
name|testPointPlane
operator|.
name|evaluateIsZero
argument_list|(
name|intersectionPoint
argument_list|)
operator|:
literal|"intersection point must be on test point plane"
assert|;
assert|assert
operator|!
name|testPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|intersectionPoint
argument_list|)
operator|:
literal|"test point is the same as intersection point"
assert|;
assert|assert
operator|!
name|thePoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|intersectionPoint
argument_list|)
operator|:
literal|"check point is same is intersection point"
assert|;
name|this
operator|.
name|testPointCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|intersectionPoint
argument_list|,
name|testPointPlane
argument_list|,
name|testPoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|checkPointCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|intersectionPoint
argument_list|,
name|travelPlane
argument_list|,
name|thePoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointOtherCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|testPoint
argument_list|,
name|testPointPlane
argument_list|,
name|intersectionPoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|checkPointOtherCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|thePoint
argument_list|,
name|travelPlane
argument_list|,
name|intersectionPoint
argument_list|)
expr_stmt|;
comment|// Sanity check
assert|assert
name|testPointCutoffPlane
operator|.
name|isWithin
argument_list|(
name|intersectionPoint
argument_list|)
operator|:
literal|"intersection must be within testPointCutoffPlane"
assert|;
assert|assert
name|testPointOtherCutoffPlane
operator|.
name|isWithin
argument_list|(
name|intersectionPoint
argument_list|)
operator|:
literal|"intersection must be within testPointOtherCutoffPlane"
assert|;
assert|assert
name|checkPointCutoffPlane
operator|.
name|isWithin
argument_list|(
name|intersectionPoint
argument_list|)
operator|:
literal|"intersection must be within checkPointCutoffPlane"
assert|;
assert|assert
name|checkPointOtherCutoffPlane
operator|.
name|isWithin
argument_list|(
name|intersectionPoint
argument_list|)
operator|:
literal|"intersection must be within checkPointOtherCutoffPlane"
assert|;
block|}
DECL|method|computeInsideOutside
specifier|protected
name|void
name|computeInsideOutside
parameter_list|()
block|{
if|if
condition|(
operator|!
name|computedInsideOutside
condition|)
block|{
comment|// Convert travel plane to a sided plane
specifier|final
name|Membership
name|intersectionBound1
init|=
operator|new
name|SidedPlane
argument_list|(
name|testPoint
argument_list|,
name|travelPlane
argument_list|,
name|travelPlane
operator|.
name|D
argument_list|)
decl_stmt|;
comment|// Convert testPoint plane to a sided plane
specifier|final
name|Membership
name|intersectionBound2
init|=
operator|new
name|SidedPlane
argument_list|(
name|thePoint
argument_list|,
name|testPointPlane
argument_list|,
name|testPointPlane
operator|.
name|D
argument_list|)
decl_stmt|;
assert|assert
name|intersectionBound1
operator|.
name|isWithin
argument_list|(
name|intersectionPoint
argument_list|)
operator|:
literal|"intersection must be within intersectionBound1"
assert|;
assert|assert
name|intersectionBound2
operator|.
name|isWithin
argument_list|(
name|intersectionPoint
argument_list|)
operator|:
literal|"intersection must be within intersectionBound2"
assert|;
comment|// Figure out which of the above/below planes are inside vs. outside.  To do this,
comment|// we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside
comment|// borders.
specifier|final
name|Plane
name|travelAbovePlane
init|=
operator|new
name|Plane
argument_list|(
name|travelPlane
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|Plane
name|travelBelowPlane
init|=
operator|new
name|Plane
argument_list|(
name|travelPlane
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|aboveAbove
init|=
name|travelAbovePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointAbovePlane
argument_list|,
name|intersectionBound1
argument_list|,
name|intersectionBound2
argument_list|)
decl_stmt|;
assert|assert
name|aboveAbove
operator|!=
literal|null
operator|:
literal|"Above + above should not be coplanar"
assert|;
specifier|final
name|GeoPoint
index|[]
name|aboveBelow
init|=
name|travelAbovePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointBelowPlane
argument_list|,
name|intersectionBound1
argument_list|,
name|intersectionBound2
argument_list|)
decl_stmt|;
assert|assert
name|aboveBelow
operator|!=
literal|null
operator|:
literal|"Above + below should not be coplanar"
assert|;
specifier|final
name|GeoPoint
index|[]
name|belowBelow
init|=
name|travelBelowPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointBelowPlane
argument_list|,
name|intersectionBound1
argument_list|,
name|intersectionBound2
argument_list|)
decl_stmt|;
assert|assert
name|belowBelow
operator|!=
literal|null
operator|:
literal|"Below + below should not be coplanar"
assert|;
specifier|final
name|GeoPoint
index|[]
name|belowAbove
init|=
name|travelBelowPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointAbovePlane
argument_list|,
name|intersectionBound1
argument_list|,
name|intersectionBound2
argument_list|)
decl_stmt|;
assert|assert
name|belowAbove
operator|!=
literal|null
operator|:
literal|"Below + above should not be coplanar"
assert|;
assert|assert
operator|(
operator|(
name|aboveAbove
operator|.
name|length
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|aboveBelow
operator|.
name|length
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|belowBelow
operator|.
name|length
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|belowAbove
operator|.
name|length
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|==
literal|1
operator|:
literal|"Can be exactly one inside point, instead was: aa="
operator|+
name|aboveAbove
operator|.
name|length
operator|+
literal|" ab="
operator|+
name|aboveBelow
operator|.
name|length
operator|+
literal|" bb="
operator|+
name|belowBelow
operator|.
name|length
operator|+
literal|" ba="
operator|+
name|belowAbove
operator|.
name|length
assert|;
if|if
condition|(
name|aboveAbove
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|travelInsidePlane
operator|=
name|travelAbovePlane
expr_stmt|;
name|testPointInsidePlane
operator|=
name|testPointAbovePlane
expr_stmt|;
name|travelOutsidePlane
operator|=
name|travelBelowPlane
expr_stmt|;
name|testPointOutsidePlane
operator|=
name|testPointBelowPlane
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aboveBelow
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|travelInsidePlane
operator|=
name|travelAbovePlane
expr_stmt|;
name|testPointInsidePlane
operator|=
name|testPointBelowPlane
expr_stmt|;
name|travelOutsidePlane
operator|=
name|travelBelowPlane
expr_stmt|;
name|testPointOutsidePlane
operator|=
name|testPointAbovePlane
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|belowBelow
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|travelInsidePlane
operator|=
name|travelBelowPlane
expr_stmt|;
name|testPointInsidePlane
operator|=
name|testPointBelowPlane
expr_stmt|;
name|travelOutsidePlane
operator|=
name|travelAbovePlane
expr_stmt|;
name|testPointOutsidePlane
operator|=
name|testPointAbovePlane
expr_stmt|;
block|}
else|else
block|{
name|travelInsidePlane
operator|=
name|travelBelowPlane
expr_stmt|;
name|testPointInsidePlane
operator|=
name|testPointAbovePlane
expr_stmt|;
name|travelOutsidePlane
operator|=
name|travelAbovePlane
expr_stmt|;
name|testPointOutsidePlane
operator|=
name|testPointBelowPlane
expr_stmt|;
block|}
name|insideTravelCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|thePoint
argument_list|,
name|testPointInsidePlane
argument_list|,
name|testPointInsidePlane
operator|.
name|D
argument_list|)
expr_stmt|;
name|insideTestPointCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|testPoint
argument_list|,
name|travelInsidePlane
argument_list|,
name|travelInsidePlane
operator|.
name|D
argument_list|)
expr_stmt|;
name|computedInsideOutside
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|method|setSecondLeg
specifier|public
name|void
name|setSecondLeg
parameter_list|()
block|{
name|isSecondLeg
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
comment|//System.err.println("Processing edge "+edge+", startpoint="+edge.startPoint+" endpoint="+edge.endPoint);
comment|// Early exit if the point is on the edge.
if|if
condition|(
name|thePoint
operator|!=
literal|null
operator|&&
name|edge
operator|.
name|plane
operator|.
name|evaluateIsZero
argument_list|(
name|thePoint
argument_list|)
operator|&&
name|edge
operator|.
name|startPlane
operator|.
name|isWithin
argument_list|(
name|thePoint
argument_list|)
operator|&&
name|edge
operator|.
name|endPlane
operator|.
name|isWithin
argument_list|(
name|thePoint
argument_list|)
condition|)
block|{
comment|//System.err.println(" Check point is on edge: isWithin = true");
return|return
literal|false
return|;
block|}
comment|// If the intersection point lies on this edge, we should still be able to consider crossing points only.
comment|// Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing
comment|// for at least one of the two planes in order to be a legitimate crossing of the combined path.
specifier|final
name|GeoPoint
index|[]
name|crossingPoints
decl_stmt|;
if|if
condition|(
name|isSecondLeg
condition|)
block|{
comment|//System.err.println(" check point plane = "+travelPlane);
name|crossingPoints
operator|=
name|travelPlane
operator|.
name|findCrossings
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|checkPointCutoffPlane
argument_list|,
name|checkPointOtherCutoffPlane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//System.err.println(" test point plane = "+testPointPlane);
name|crossingPoints
operator|=
name|testPointPlane
operator|.
name|findCrossings
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|testPointCutoffPlane
argument_list|,
name|testPointOtherCutoffPlane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|crossingPoints
operator|!=
literal|null
condition|)
block|{
comment|// We need to handle the endpoint case, which is quite tricky.
for|for
control|(
specifier|final
name|GeoPoint
name|crossingPoint
range|:
name|crossingPoints
control|)
block|{
name|countCrossingPoint
argument_list|(
name|crossingPoint
argument_list|,
name|edge
argument_list|)
expr_stmt|;
block|}
comment|//System.err.println(" All crossing points processed");
block|}
else|else
block|{
comment|//System.err.println(" No crossing points!");
block|}
return|return
literal|true
return|;
block|}
DECL|method|countCrossingPoint
specifier|private
name|void
name|countCrossingPoint
parameter_list|(
specifier|final
name|GeoPoint
name|crossingPoint
parameter_list|,
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
comment|//System.err.println(" Crossing point "+crossingPoint);
comment|// We consider crossing points only in this method.
comment|// Unlike the linear case, there are additional cases when:
comment|// (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;
comment|// (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.
comment|// The other logical difference is that crossings of all kinds have to be considered so that:
comment|// (a) both inside edges are considered together at all times;
comment|// (b) both outside edges are considered together at all times;
comment|// (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.
comment|// Intersection point crossings are either simple, or a crossing on an endpoint.
comment|// In either case, we have to be sure to count each edge only once, since it might appear in both the
comment|// first leg and the second.  If the first leg can process it, it should, and the second should skip it.
if|if
condition|(
name|crossingPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|intersectionPoint
argument_list|)
condition|)
block|{
comment|//System.err.println(" Crosses intersection point.");
if|if
condition|(
name|isSecondLeg
condition|)
block|{
comment|// See whether this edge would have been processed in the first leg; if so, we skip it.
specifier|final
name|GeoPoint
index|[]
name|firstLegCrossings
init|=
name|testPointPlane
operator|.
name|findCrossings
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|testPointCutoffPlane
argument_list|,
name|testPointOtherCutoffPlane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|GeoPoint
name|firstLegCrossing
range|:
name|firstLegCrossings
control|)
block|{
if|if
condition|(
name|firstLegCrossing
operator|.
name|isNumericallyIdentical
argument_list|(
name|intersectionPoint
argument_list|)
condition|)
block|{
comment|// We already processed it, so we're done here.
comment|//System.err.println("  Already processed on previous leg: exit");
return|return;
block|}
block|}
block|}
block|}
comment|// Plane crossing, either first leg or second leg
specifier|final
name|Plane
name|plane
decl_stmt|;
specifier|final
name|SidedPlane
name|bound1
decl_stmt|;
specifier|final
name|SidedPlane
name|bound2
decl_stmt|;
if|if
condition|(
name|isSecondLeg
condition|)
block|{
name|plane
operator|=
name|travelPlane
expr_stmt|;
name|bound1
operator|=
name|checkPointCutoffPlane
expr_stmt|;
name|bound2
operator|=
name|checkPointOtherCutoffPlane
expr_stmt|;
block|}
else|else
block|{
name|plane
operator|=
name|testPointPlane
expr_stmt|;
name|bound1
operator|=
name|testPointCutoffPlane
expr_stmt|;
name|bound2
operator|=
name|testPointOtherCutoffPlane
expr_stmt|;
block|}
if|if
condition|(
name|crossingPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|edge
operator|.
name|startPoint
argument_list|)
condition|)
block|{
comment|//System.err.println(" Crossing point = edge.startPoint");
comment|// We have to figure out if this crossing should be counted.
name|computeInsideOutside
argument_list|()
expr_stmt|;
comment|// Does the crossing for this edge go up, or down?  Or can't we tell?
specifier|final
name|GeoPoint
index|[]
name|insideTestPointPlaneIntersections
init|=
name|testPointInsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|,
name|insideTestPointCutoffPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|insideTravelPlaneIntersections
init|=
name|travelInsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|,
name|insideTravelCutoffPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|outsideTestPointPlaneIntersections
init|=
name|testPointOutsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|outsideTravelPlaneIntersections
init|=
name|travelOutsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
assert|assert
operator|!
operator|(
name|insideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|insideTravelPlaneIntersections
operator|.
name|length
operator|>
literal|0
operator|&&
name|outsideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|outsideTravelPlaneIntersections
operator|.
name|length
operator|>
literal|0
operator|)
operator|:
literal|"edge that ends in a crossing can't both up and down"
assert|;
if|if
condition|(
name|insideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|insideTravelPlaneIntersections
operator|.
name|length
operator|==
literal|0
operator|&&
name|outsideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|outsideTravelPlaneIntersections
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|//System.err.println(" No inside or outside crossings found");
return|return;
block|}
specifier|final
name|boolean
name|edgeCrossesInside
init|=
name|insideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|insideTravelPlaneIntersections
operator|.
name|length
operator|>
literal|0
decl_stmt|;
comment|// This depends on the previous edge that first departs from identicalness.
name|Edge
name|assessEdge
init|=
name|edge
decl_stmt|;
name|GeoPoint
index|[]
name|assessInsideTestPointIntersections
decl_stmt|;
name|GeoPoint
index|[]
name|assessInsideTravelIntersections
decl_stmt|;
name|GeoPoint
index|[]
name|assessOutsideTestPointIntersections
decl_stmt|;
name|GeoPoint
index|[]
name|assessOutsideTravelIntersections
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|assessEdge
operator|=
name|assessEdge
operator|.
name|previous
expr_stmt|;
name|assessInsideTestPointIntersections
operator|=
name|testPointInsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|,
name|insideTestPointCutoffPlane
argument_list|)
expr_stmt|;
name|assessInsideTravelIntersections
operator|=
name|travelInsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|,
name|insideTravelCutoffPlane
argument_list|)
expr_stmt|;
name|assessOutsideTestPointIntersections
operator|=
name|testPointOutsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
name|assessOutsideTravelIntersections
operator|=
name|travelOutsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
comment|// An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.
comment|//assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length> 0&& assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length> 0) : "assess edge that ends in a crossing can't both up and down";
if|if
condition|(
name|assessInsideTestPointIntersections
operator|.
name|length
operator|+
name|assessInsideTravelIntersections
operator|.
name|length
operator|==
literal|0
operator|&&
name|assessOutsideTestPointIntersections
operator|.
name|length
operator|+
name|assessOutsideTravelIntersections
operator|.
name|length
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
break|break;
block|}
comment|// Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite
comment|// directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that
comment|// each edge we look at can also be looked at again if it, too, seems to cross the plane.
comment|// To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make
comment|// a decision whether to count or not based on that.
comment|// Compute the crossing points of this other edge.
specifier|final
name|GeoPoint
index|[]
name|otherCrossingPoints
init|=
name|plane
operator|.
name|findCrossings
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|bound1
argument_list|,
name|bound2
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
comment|// Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the
comment|// transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).
for|for
control|(
specifier|final
name|GeoPoint
name|otherCrossingPoint
range|:
name|otherCrossingPoints
control|)
block|{
if|if
condition|(
name|otherCrossingPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|assessEdge
operator|.
name|endPoint
argument_list|)
condition|)
block|{
comment|// Found it!
comment|// Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.
comment|// Since we're the latter point, we exit here in that case.
comment|//System.err.println(" Earlier point fired, so this one shouldn't");
return|return;
block|}
block|}
comment|// Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the
comment|// point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges
comment|// and make an assessment that way, since a single edge can intersect the plane at more than one point.
specifier|final
name|boolean
name|assessEdgeInside
init|=
name|assessInsideTestPointIntersections
operator|.
name|length
operator|+
name|assessInsideTravelIntersections
operator|.
name|length
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|assessEdgeInside
operator|!=
name|edgeCrossesInside
condition|)
block|{
comment|//System.err.println(" Incrementing crossing count");
name|crossingCount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|//System.err.println(" Entered and exited on same side");
block|}
block|}
elseif|else
if|if
condition|(
name|crossingPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|edge
operator|.
name|endPoint
argument_list|)
condition|)
block|{
comment|//System.err.println(" Crossing point = edge.endPoint");
comment|// Figure out if the crossing should be counted.
name|computeInsideOutside
argument_list|()
expr_stmt|;
comment|// Does the crossing for this edge go up, or down?  Or can't we tell?
specifier|final
name|GeoPoint
index|[]
name|insideTestPointPlaneIntersections
init|=
name|testPointInsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|,
name|insideTestPointCutoffPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|insideTravelPlaneIntersections
init|=
name|travelInsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|,
name|insideTravelCutoffPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|outsideTestPointPlaneIntersections
init|=
name|testPointOutsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|outsideTravelPlaneIntersections
init|=
name|travelOutsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
comment|// An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.
comment|//assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length> 0&& outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length> 0) : "edge that ends in a crossing can't go both up and down: insideTestPointPlaneIntersections: "+insideTestPointPlaneIntersections.length+" insideTravelPlaneIntersections: "+insideTravelPlaneIntersections.length+" outsideTestPointPlaneIntersections: "+outsideTestPointPlaneIntersections.length+" outsideTravelPlaneIntersections: "+outsideTravelPlaneIntersections.length;
if|if
condition|(
name|insideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|insideTravelPlaneIntersections
operator|.
name|length
operator|==
literal|0
operator|&&
name|outsideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|outsideTravelPlaneIntersections
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|//System.err.println(" No inside or outside crossings found");
return|return;
block|}
specifier|final
name|boolean
name|edgeCrossesInside
init|=
name|insideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|insideTravelPlaneIntersections
operator|.
name|length
operator|>
literal|0
decl_stmt|;
comment|// This depends on the previous edge that first departs from identicalness.
name|Edge
name|assessEdge
init|=
name|edge
decl_stmt|;
name|GeoPoint
index|[]
name|assessInsideTestPointIntersections
decl_stmt|;
name|GeoPoint
index|[]
name|assessInsideTravelIntersections
decl_stmt|;
name|GeoPoint
index|[]
name|assessOutsideTestPointIntersections
decl_stmt|;
name|GeoPoint
index|[]
name|assessOutsideTravelIntersections
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|assessEdge
operator|=
name|assessEdge
operator|.
name|next
expr_stmt|;
name|assessInsideTestPointIntersections
operator|=
name|testPointInsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|,
name|insideTestPointCutoffPlane
argument_list|)
expr_stmt|;
name|assessInsideTravelIntersections
operator|=
name|travelInsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|,
name|insideTravelCutoffPlane
argument_list|)
expr_stmt|;
name|assessOutsideTestPointIntersections
operator|=
name|testPointOutsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
name|assessOutsideTravelIntersections
operator|=
name|travelOutsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
assert|assert
operator|!
operator|(
name|assessInsideTestPointIntersections
operator|.
name|length
operator|+
name|assessInsideTravelIntersections
operator|.
name|length
operator|>
literal|0
operator|&&
name|assessOutsideTestPointIntersections
operator|.
name|length
operator|+
name|assessOutsideTravelIntersections
operator|.
name|length
operator|>
literal|0
operator|)
operator|:
literal|"assess edge that ends in a crossing can't both up and down"
assert|;
if|if
condition|(
name|assessInsideTestPointIntersections
operator|.
name|length
operator|+
name|assessInsideTravelIntersections
operator|.
name|length
operator|==
literal|0
operator|&&
name|assessOutsideTestPointIntersections
operator|.
name|length
operator|+
name|assessOutsideTravelIntersections
operator|.
name|length
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
break|break;
block|}
comment|// Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite
comment|// directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that
comment|// each edge we look at can also be looked at again if it, too, seems to cross the plane.
comment|// By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary
comment|// to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.
comment|// We need to determine the direction of both edges at the
comment|// point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges
comment|// and make an assessment that way, since a single edge can intersect the plane at more than one point.
specifier|final
name|boolean
name|assessEdgeInside
init|=
name|assessInsideTestPointIntersections
operator|.
name|length
operator|+
name|assessInsideTravelIntersections
operator|.
name|length
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|assessEdgeInside
operator|!=
name|edgeCrossesInside
condition|)
block|{
comment|//System.err.println(" Incrementing crossing count");
name|crossingCount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|//System.err.println(" Entered and exited on same side");
block|}
block|}
else|else
block|{
comment|//System.err.println(" Not a special case: incrementing crossing count");
comment|// Not a special case, so we can safely count a crossing.
name|crossingCount
operator|++
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
comment|// Way too expensive to do this the hard way, so each complex polygon will be considered unique.
return|return
name|this
operator|==
name|o
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// Each complex polygon is considered unique.
return|return
name|System
operator|.
name|identityHashCode
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|edgeDescription
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Edge
name|shapeStartEdge
range|:
name|shapeStartEdges
control|)
block|{
name|fillInEdgeDescription
argument_list|(
name|edgeDescription
argument_list|,
name|shapeStartEdge
argument_list|)
expr_stmt|;
block|}
return|return
literal|"GeoComplexPolygon: {planetmodel="
operator|+
name|planetModel
operator|+
literal|", number of shapes="
operator|+
name|shapeStartEdges
operator|.
name|length
operator|+
literal|", address="
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|hashCode
argument_list|()
argument_list|)
operator|+
literal|", testPoint="
operator|+
name|testPoint
operator|+
literal|", testPointInSet="
operator|+
name|testPointInSet
operator|+
literal|", shapes={"
operator|+
name|edgeDescription
operator|+
literal|"}}"
return|;
block|}
DECL|method|fillInEdgeDescription
specifier|private
specifier|static
name|void
name|fillInEdgeDescription
parameter_list|(
specifier|final
name|StringBuilder
name|description
parameter_list|,
specifier|final
name|Edge
name|startEdge
parameter_list|)
block|{
name|description
operator|.
name|append
argument_list|(
literal|" {"
argument_list|)
expr_stmt|;
name|Edge
name|currentEdge
init|=
name|startEdge
decl_stmt|;
name|int
name|edgeCounter
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|edgeCounter
operator|>
literal|0
condition|)
block|{
name|description
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|edgeCounter
operator|>=
literal|20
condition|)
block|{
name|description
operator|.
name|append
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
break|break;
block|}
name|description
operator|.
name|append
argument_list|(
name|currentEdge
operator|.
name|startPoint
argument_list|)
expr_stmt|;
name|currentEdge
operator|=
name|currentEdge
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|currentEdge
operator|==
name|startEdge
condition|)
block|{
break|break;
block|}
name|edgeCounter
operator|++
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
