begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.spatial3d.geom
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial3d
operator|.
name|geom
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_comment
comment|/**  * GeoComplexPolygon objects are structures designed to handle very large numbers of edges.  * They perform very well in this case compared to the alternatives, which all have O(N) evaluation  * and O(N^2) setup times.  Complex polygons have O(N) setup times and best case O(log(N))  * evaluation times.  *  * The tradeoff is that these objects perform object creation when evaluating intersects() and  * isWithin().  *  * @lucene.internal  */
end_comment
begin_class
DECL|class|GeoComplexPolygon
class|class
name|GeoComplexPolygon
extends|extends
name|GeoBasePolygon
block|{
DECL|field|xTree
specifier|private
specifier|final
name|Tree
name|xTree
init|=
operator|new
name|XTree
argument_list|()
decl_stmt|;
DECL|field|yTree
specifier|private
specifier|final
name|Tree
name|yTree
init|=
operator|new
name|YTree
argument_list|()
decl_stmt|;
DECL|field|zTree
specifier|private
specifier|final
name|Tree
name|zTree
init|=
operator|new
name|ZTree
argument_list|()
decl_stmt|;
DECL|field|testPointInSet
specifier|private
specifier|final
name|boolean
name|testPointInSet
decl_stmt|;
DECL|field|testPoint
specifier|private
specifier|final
name|GeoPoint
name|testPoint
decl_stmt|;
DECL|field|testPointXZPlane
specifier|private
specifier|final
name|Plane
name|testPointXZPlane
decl_stmt|;
DECL|field|testPointXZAbovePlane
specifier|private
specifier|final
name|Plane
name|testPointXZAbovePlane
decl_stmt|;
DECL|field|testPointXZBelowPlane
specifier|private
specifier|final
name|Plane
name|testPointXZBelowPlane
decl_stmt|;
DECL|field|testPointYZPlane
specifier|private
specifier|final
name|Plane
name|testPointYZPlane
decl_stmt|;
DECL|field|testPointYZAbovePlane
specifier|private
specifier|final
name|Plane
name|testPointYZAbovePlane
decl_stmt|;
DECL|field|testPointYZBelowPlane
specifier|private
specifier|final
name|Plane
name|testPointYZBelowPlane
decl_stmt|;
DECL|field|testPointXYPlane
specifier|private
specifier|final
name|Plane
name|testPointXYPlane
decl_stmt|;
DECL|field|testPointXYAbovePlane
specifier|private
specifier|final
name|Plane
name|testPointXYAbovePlane
decl_stmt|;
DECL|field|testPointXYBelowPlane
specifier|private
specifier|final
name|Plane
name|testPointXYBelowPlane
decl_stmt|;
DECL|field|edgePoints
specifier|private
specifier|final
name|GeoPoint
index|[]
name|edgePoints
decl_stmt|;
DECL|field|shapeStartEdges
specifier|private
specifier|final
name|Edge
index|[]
name|shapeStartEdges
decl_stmt|;
comment|/**    * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of    * set.    *@param planetModel is the planet model.    *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied    *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that    *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed    *  that no edges intersect, but the structure can contain both outer rings as well as holes.    *@param testPoint is the point whose in/out of setness is known.    *@param testPointInSet is true if the test point is considered "within" the polygon.    */
DECL|method|GeoComplexPolygon
specifier|public
name|GeoComplexPolygon
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|GeoPoint
argument_list|>
argument_list|>
name|pointsList
parameter_list|,
specifier|final
name|GeoPoint
name|testPoint
parameter_list|,
specifier|final
name|boolean
name|testPointInSet
parameter_list|)
block|{
name|super
argument_list|(
name|planetModel
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointInSet
operator|=
name|testPointInSet
expr_stmt|;
name|this
operator|.
name|testPoint
operator|=
name|testPoint
expr_stmt|;
name|this
operator|.
name|testPointXZPlane
operator|=
operator|new
name|Plane
argument_list|(
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
operator|-
name|testPoint
operator|.
name|y
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointYZPlane
operator|=
operator|new
name|Plane
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
operator|-
name|testPoint
operator|.
name|x
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointXYPlane
operator|=
operator|new
name|Plane
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
operator|-
name|testPoint
operator|.
name|z
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointXZAbovePlane
operator|=
operator|new
name|Plane
argument_list|(
name|testPointXZPlane
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointXZBelowPlane
operator|=
operator|new
name|Plane
argument_list|(
name|testPointXZPlane
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointYZAbovePlane
operator|=
operator|new
name|Plane
argument_list|(
name|testPointYZPlane
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointYZBelowPlane
operator|=
operator|new
name|Plane
argument_list|(
name|testPointYZPlane
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointXYAbovePlane
operator|=
operator|new
name|Plane
argument_list|(
name|testPointXYPlane
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|testPointXYBelowPlane
operator|=
operator|new
name|Plane
argument_list|(
name|testPointXYPlane
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|edgePoints
operator|=
operator|new
name|GeoPoint
index|[
name|pointsList
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|this
operator|.
name|shapeStartEdges
operator|=
operator|new
name|Edge
index|[
name|pointsList
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|int
name|edgePointIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|shapePoints
range|:
name|pointsList
control|)
block|{
name|GeoPoint
name|lastGeoPoint
init|=
name|shapePoints
operator|.
name|get
argument_list|(
name|shapePoints
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|edgePoints
index|[
name|edgePointIndex
index|]
operator|=
name|lastGeoPoint
expr_stmt|;
name|Edge
name|lastEdge
init|=
literal|null
decl_stmt|;
name|Edge
name|firstEdge
init|=
literal|null
decl_stmt|;
for|for
control|(
specifier|final
name|GeoPoint
name|thisGeoPoint
range|:
name|shapePoints
control|)
block|{
specifier|final
name|Edge
name|edge
init|=
operator|new
name|Edge
argument_list|(
name|planetModel
argument_list|,
name|lastGeoPoint
argument_list|,
name|thisGeoPoint
argument_list|)
decl_stmt|;
name|xTree
operator|.
name|add
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|yTree
operator|.
name|add
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|zTree
operator|.
name|add
argument_list|(
name|edge
argument_list|)
expr_stmt|;
comment|// Now, link
if|if
condition|(
name|firstEdge
operator|==
literal|null
condition|)
block|{
name|firstEdge
operator|=
name|edge
expr_stmt|;
block|}
if|if
condition|(
name|lastEdge
operator|!=
literal|null
condition|)
block|{
name|lastEdge
operator|.
name|next
operator|=
name|edge
expr_stmt|;
name|edge
operator|.
name|previous
operator|=
name|lastEdge
expr_stmt|;
block|}
name|lastEdge
operator|=
name|edge
expr_stmt|;
name|lastGeoPoint
operator|=
name|thisGeoPoint
expr_stmt|;
block|}
name|firstEdge
operator|.
name|previous
operator|=
name|lastEdge
expr_stmt|;
name|lastEdge
operator|.
name|next
operator|=
name|firstEdge
expr_stmt|;
name|shapeStartEdges
index|[
name|edgePointIndex
index|]
operator|=
name|firstEdge
expr_stmt|;
name|edgePointIndex
operator|++
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|isWithin
argument_list|(
operator|new
name|Vector
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|Vector
name|thePoint
parameter_list|)
block|{
comment|// If we're right on top of the point, we know the answer.
if|if
condition|(
name|testPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|thePoint
argument_list|)
condition|)
block|{
return|return
name|testPointInSet
return|;
block|}
comment|// If we're right on top of any of the test planes, we navigate solely on that plane.
if|if
condition|(
name|testPointXZPlane
operator|.
name|evaluateIsZero
argument_list|(
name|thePoint
argument_list|)
condition|)
block|{
comment|// Use the XZ plane exclusively.
specifier|final
name|LinearCrossingEdgeIterator
name|crossingEdgeIterator
init|=
operator|new
name|LinearCrossingEdgeIterator
argument_list|(
name|testPointXZPlane
argument_list|,
name|testPointXZAbovePlane
argument_list|,
name|testPointXZBelowPlane
argument_list|,
name|testPoint
argument_list|,
name|thePoint
argument_list|)
decl_stmt|;
comment|// Traverse our way from the test point to the check point.  Use the y tree because that's fixed.
if|if
condition|(
operator|!
name|yTree
operator|.
name|traverse
argument_list|(
name|crossingEdgeIterator
argument_list|,
name|testPoint
operator|.
name|y
argument_list|,
name|testPoint
operator|.
name|y
argument_list|)
condition|)
block|{
comment|// Endpoint is on edge
return|return
literal|true
return|;
block|}
return|return
operator|(
operator|(
name|crossingEdgeIterator
operator|.
name|crossingCount
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|?
name|testPointInSet
else|:
operator|!
name|testPointInSet
return|;
block|}
elseif|else
if|if
condition|(
name|testPointYZPlane
operator|.
name|evaluateIsZero
argument_list|(
name|thePoint
argument_list|)
condition|)
block|{
comment|// Use the YZ plane exclusively.
specifier|final
name|LinearCrossingEdgeIterator
name|crossingEdgeIterator
init|=
operator|new
name|LinearCrossingEdgeIterator
argument_list|(
name|testPointYZPlane
argument_list|,
name|testPointYZAbovePlane
argument_list|,
name|testPointYZBelowPlane
argument_list|,
name|testPoint
argument_list|,
name|thePoint
argument_list|)
decl_stmt|;
comment|// Traverse our way from the test point to the check point.  Use the x tree because that's fixed.
if|if
condition|(
operator|!
name|xTree
operator|.
name|traverse
argument_list|(
name|crossingEdgeIterator
argument_list|,
name|testPoint
operator|.
name|x
argument_list|,
name|testPoint
operator|.
name|x
argument_list|)
condition|)
block|{
comment|// Endpoint is on edge
return|return
literal|true
return|;
block|}
return|return
operator|(
operator|(
name|crossingEdgeIterator
operator|.
name|crossingCount
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|?
name|testPointInSet
else|:
operator|!
name|testPointInSet
return|;
block|}
elseif|else
if|if
condition|(
name|testPointXYPlane
operator|.
name|evaluateIsZero
argument_list|(
name|thePoint
argument_list|)
condition|)
block|{
comment|// Use the XY plane exclusively.
specifier|final
name|LinearCrossingEdgeIterator
name|crossingEdgeIterator
init|=
operator|new
name|LinearCrossingEdgeIterator
argument_list|(
name|testPointXYPlane
argument_list|,
name|testPointXYAbovePlane
argument_list|,
name|testPointXYBelowPlane
argument_list|,
name|testPoint
argument_list|,
name|thePoint
argument_list|)
decl_stmt|;
comment|// Traverse our way from the test point to the check point.  Use the z tree because that's fixed.
if|if
condition|(
operator|!
name|zTree
operator|.
name|traverse
argument_list|(
name|crossingEdgeIterator
argument_list|,
name|testPoint
operator|.
name|z
argument_list|,
name|testPoint
operator|.
name|z
argument_list|)
condition|)
block|{
comment|// Endpoint is on edge
return|return
literal|true
return|;
block|}
return|return
operator|(
operator|(
name|crossingEdgeIterator
operator|.
name|crossingCount
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|?
name|testPointInSet
else|:
operator|!
name|testPointInSet
return|;
block|}
else|else
block|{
comment|// We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.
specifier|final
name|Plane
name|travelPlaneFixedX
init|=
operator|new
name|Plane
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
operator|-
name|thePoint
operator|.
name|x
argument_list|)
decl_stmt|;
specifier|final
name|Plane
name|travelPlaneFixedY
init|=
operator|new
name|Plane
argument_list|(
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
operator|-
name|thePoint
operator|.
name|y
argument_list|)
decl_stmt|;
specifier|final
name|Plane
name|travelPlaneFixedZ
init|=
operator|new
name|Plane
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
operator|-
name|thePoint
operator|.
name|z
argument_list|)
decl_stmt|;
comment|// Find the intersection points for each one of these and the complementary test point planes.
specifier|final
name|GeoPoint
index|[]
name|XZIntersectionsYZ
init|=
name|travelPlaneFixedX
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointYZPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|XZIntersectionsXY
init|=
name|travelPlaneFixedX
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointXYPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|YZIntersectionsXZ
init|=
name|travelPlaneFixedY
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointXZPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|YZIntersectionsXY
init|=
name|travelPlaneFixedY
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointXYPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|XYIntersectionsYZ
init|=
name|travelPlaneFixedZ
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointYZPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|XYIntersectionsXZ
init|=
name|travelPlaneFixedZ
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointXZPlane
argument_list|)
decl_stmt|;
comment|// There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.
name|double
name|bestDistance
init|=
name|Double
operator|.
name|MAX_VALUE
decl_stmt|;
name|double
name|firstLegValue
init|=
literal|0.0
decl_stmt|;
name|double
name|secondLegValue
init|=
literal|0.0
decl_stmt|;
name|Plane
name|firstLegPlane
init|=
literal|null
decl_stmt|;
name|Plane
name|firstLegAbovePlane
init|=
literal|null
decl_stmt|;
name|Plane
name|firstLegBelowPlane
init|=
literal|null
decl_stmt|;
name|Plane
name|secondLegPlane
init|=
literal|null
decl_stmt|;
name|Tree
name|firstLegTree
init|=
literal|null
decl_stmt|;
name|Tree
name|secondLegTree
init|=
literal|null
decl_stmt|;
name|GeoPoint
name|intersectionPoint
init|=
literal|null
decl_stmt|;
for|for
control|(
specifier|final
name|GeoPoint
name|p
range|:
name|XZIntersectionsYZ
control|)
block|{
comment|// Travel would be in XZ plane (fixed y) then in YZ (fixed x)
specifier|final
name|double
name|newDistance
init|=
name|Math
operator|.
name|abs
argument_list|(
name|thePoint
operator|.
name|x
operator|-
name|p
operator|.
name|x
argument_list|)
operator|+
name|Math
operator|.
name|abs
argument_list|(
name|testPoint
operator|.
name|y
operator|-
name|p
operator|.
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDistance
operator|<
name|bestDistance
condition|)
block|{
name|bestDistance
operator|=
name|newDistance
expr_stmt|;
name|firstLegValue
operator|=
name|testPoint
operator|.
name|y
expr_stmt|;
name|secondLegValue
operator|=
name|thePoint
operator|.
name|x
expr_stmt|;
name|firstLegPlane
operator|=
name|testPointYZPlane
expr_stmt|;
name|firstLegAbovePlane
operator|=
name|testPointYZAbovePlane
expr_stmt|;
name|firstLegBelowPlane
operator|=
name|testPointYZBelowPlane
expr_stmt|;
name|secondLegPlane
operator|=
name|travelPlaneFixedX
expr_stmt|;
name|firstLegTree
operator|=
name|xTree
expr_stmt|;
name|secondLegTree
operator|=
name|yTree
expr_stmt|;
name|intersectionPoint
operator|=
name|p
expr_stmt|;
block|}
block|}
for|for
control|(
specifier|final
name|GeoPoint
name|p
range|:
name|XZIntersectionsXY
control|)
block|{
comment|// Travel would be in XZ plane (fixed y) then in XY (fixed z)
specifier|final
name|double
name|newDistance
init|=
name|Math
operator|.
name|abs
argument_list|(
name|thePoint
operator|.
name|z
operator|-
name|p
operator|.
name|z
argument_list|)
operator|+
name|Math
operator|.
name|abs
argument_list|(
name|testPoint
operator|.
name|y
operator|-
name|p
operator|.
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDistance
operator|<
name|bestDistance
condition|)
block|{
name|bestDistance
operator|=
name|newDistance
expr_stmt|;
name|firstLegValue
operator|=
name|testPoint
operator|.
name|y
expr_stmt|;
name|secondLegValue
operator|=
name|thePoint
operator|.
name|z
expr_stmt|;
name|firstLegPlane
operator|=
name|testPointXYPlane
expr_stmt|;
name|firstLegAbovePlane
operator|=
name|testPointXYAbovePlane
expr_stmt|;
name|firstLegBelowPlane
operator|=
name|testPointXYBelowPlane
expr_stmt|;
name|secondLegPlane
operator|=
name|travelPlaneFixedX
expr_stmt|;
name|firstLegTree
operator|=
name|yTree
expr_stmt|;
name|secondLegTree
operator|=
name|zTree
expr_stmt|;
name|intersectionPoint
operator|=
name|p
expr_stmt|;
block|}
block|}
for|for
control|(
specifier|final
name|GeoPoint
name|p
range|:
name|YZIntersectionsXZ
control|)
block|{
comment|// Travel would be in YZ plane (fixed x) then in XZ (fixed y)
specifier|final
name|double
name|newDistance
init|=
name|Math
operator|.
name|abs
argument_list|(
name|thePoint
operator|.
name|y
operator|-
name|p
operator|.
name|y
argument_list|)
operator|+
name|Math
operator|.
name|abs
argument_list|(
name|testPoint
operator|.
name|x
operator|-
name|p
operator|.
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDistance
operator|<
name|bestDistance
condition|)
block|{
name|bestDistance
operator|=
name|newDistance
expr_stmt|;
name|firstLegValue
operator|=
name|testPoint
operator|.
name|x
expr_stmt|;
name|secondLegValue
operator|=
name|thePoint
operator|.
name|y
expr_stmt|;
name|firstLegPlane
operator|=
name|testPointXZPlane
expr_stmt|;
name|firstLegAbovePlane
operator|=
name|testPointXZAbovePlane
expr_stmt|;
name|firstLegBelowPlane
operator|=
name|testPointXZBelowPlane
expr_stmt|;
name|secondLegPlane
operator|=
name|travelPlaneFixedY
expr_stmt|;
name|firstLegTree
operator|=
name|xTree
expr_stmt|;
name|secondLegTree
operator|=
name|yTree
expr_stmt|;
name|intersectionPoint
operator|=
name|p
expr_stmt|;
block|}
block|}
for|for
control|(
specifier|final
name|GeoPoint
name|p
range|:
name|YZIntersectionsXY
control|)
block|{
comment|// Travel would be in YZ plane (fixed x) then in XY (fixed z)
specifier|final
name|double
name|newDistance
init|=
name|Math
operator|.
name|abs
argument_list|(
name|thePoint
operator|.
name|z
operator|-
name|p
operator|.
name|z
argument_list|)
operator|+
name|Math
operator|.
name|abs
argument_list|(
name|testPoint
operator|.
name|x
operator|-
name|p
operator|.
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDistance
operator|<
name|bestDistance
condition|)
block|{
name|bestDistance
operator|=
name|newDistance
expr_stmt|;
name|firstLegValue
operator|=
name|testPoint
operator|.
name|x
expr_stmt|;
name|secondLegValue
operator|=
name|thePoint
operator|.
name|z
expr_stmt|;
name|firstLegPlane
operator|=
name|testPointXYPlane
expr_stmt|;
name|firstLegAbovePlane
operator|=
name|testPointXYAbovePlane
expr_stmt|;
name|firstLegBelowPlane
operator|=
name|testPointXYBelowPlane
expr_stmt|;
name|secondLegPlane
operator|=
name|travelPlaneFixedX
expr_stmt|;
name|firstLegTree
operator|=
name|xTree
expr_stmt|;
name|secondLegTree
operator|=
name|zTree
expr_stmt|;
name|intersectionPoint
operator|=
name|p
expr_stmt|;
block|}
block|}
for|for
control|(
specifier|final
name|GeoPoint
name|p
range|:
name|XYIntersectionsYZ
control|)
block|{
comment|// Travel would be in XY plane (fixed z) then in YZ (fixed x)
specifier|final
name|double
name|newDistance
init|=
name|Math
operator|.
name|abs
argument_list|(
name|thePoint
operator|.
name|x
operator|-
name|p
operator|.
name|x
argument_list|)
operator|+
name|Math
operator|.
name|abs
argument_list|(
name|testPoint
operator|.
name|z
operator|-
name|p
operator|.
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDistance
operator|<
name|bestDistance
condition|)
block|{
name|bestDistance
operator|=
name|newDistance
expr_stmt|;
name|firstLegValue
operator|=
name|testPoint
operator|.
name|z
expr_stmt|;
name|secondLegValue
operator|=
name|thePoint
operator|.
name|x
expr_stmt|;
name|firstLegPlane
operator|=
name|testPointYZPlane
expr_stmt|;
name|firstLegAbovePlane
operator|=
name|testPointYZAbovePlane
expr_stmt|;
name|firstLegBelowPlane
operator|=
name|testPointYZBelowPlane
expr_stmt|;
name|secondLegPlane
operator|=
name|travelPlaneFixedZ
expr_stmt|;
name|firstLegTree
operator|=
name|zTree
expr_stmt|;
name|secondLegTree
operator|=
name|xTree
expr_stmt|;
name|intersectionPoint
operator|=
name|p
expr_stmt|;
block|}
block|}
for|for
control|(
specifier|final
name|GeoPoint
name|p
range|:
name|XYIntersectionsXZ
control|)
block|{
comment|// Travel would be in XY plane (fixed z) then in XZ (fixed y)
specifier|final
name|double
name|newDistance
init|=
name|Math
operator|.
name|abs
argument_list|(
name|thePoint
operator|.
name|y
operator|-
name|p
operator|.
name|y
argument_list|)
operator|+
name|Math
operator|.
name|abs
argument_list|(
name|testPoint
operator|.
name|z
operator|-
name|p
operator|.
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDistance
operator|<
name|bestDistance
condition|)
block|{
name|bestDistance
operator|=
name|newDistance
expr_stmt|;
name|firstLegValue
operator|=
name|testPoint
operator|.
name|z
expr_stmt|;
name|secondLegValue
operator|=
name|thePoint
operator|.
name|y
expr_stmt|;
name|firstLegPlane
operator|=
name|testPointXZPlane
expr_stmt|;
name|firstLegAbovePlane
operator|=
name|testPointXZAbovePlane
expr_stmt|;
name|firstLegBelowPlane
operator|=
name|testPointXZBelowPlane
expr_stmt|;
name|secondLegPlane
operator|=
name|travelPlaneFixedZ
expr_stmt|;
name|firstLegTree
operator|=
name|zTree
expr_stmt|;
name|secondLegTree
operator|=
name|yTree
expr_stmt|;
name|intersectionPoint
operator|=
name|p
expr_stmt|;
block|}
block|}
assert|assert
name|bestDistance
operator|<
name|Double
operator|.
name|MAX_VALUE
operator|:
literal|"Couldn't find an intersection point of any kind"
assert|;
specifier|final
name|DualCrossingEdgeIterator
name|edgeIterator
init|=
operator|new
name|DualCrossingEdgeIterator
argument_list|(
name|firstLegPlane
argument_list|,
name|firstLegAbovePlane
argument_list|,
name|firstLegBelowPlane
argument_list|,
name|secondLegPlane
argument_list|,
name|testPoint
argument_list|,
name|thePoint
argument_list|,
name|intersectionPoint
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|firstLegTree
operator|.
name|traverse
argument_list|(
name|edgeIterator
argument_list|,
name|firstLegValue
argument_list|,
name|firstLegValue
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|edgeIterator
operator|.
name|setSecondLeg
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|secondLegTree
operator|.
name|traverse
argument_list|(
name|edgeIterator
argument_list|,
name|secondLegValue
argument_list|,
name|secondLegValue
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
operator|(
operator|(
name|edgeIterator
operator|.
name|crossingCount
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|?
name|testPointInSet
else|:
operator|!
name|testPointInSet
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getEdgePoints
specifier|public
name|GeoPoint
index|[]
name|getEdgePoints
parameter_list|()
block|{
return|return
name|edgePoints
return|;
block|}
annotation|@
name|Override
DECL|method|intersects
specifier|public
name|boolean
name|intersects
parameter_list|(
specifier|final
name|Plane
name|p
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|notablePoints
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
comment|// Create the intersector
specifier|final
name|EdgeIterator
name|intersector
init|=
operator|new
name|IntersectorEdgeIterator
argument_list|(
name|p
argument_list|,
name|notablePoints
argument_list|,
name|bounds
argument_list|)
decl_stmt|;
comment|// First, compute the bounds for the the plane
specifier|final
name|XYZBounds
name|xyzBounds
init|=
operator|new
name|XYZBounds
argument_list|()
decl_stmt|;
name|p
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|xyzBounds
argument_list|,
name|bounds
argument_list|)
expr_stmt|;
comment|// Figure out which tree likely works best
specifier|final
name|double
name|xDelta
init|=
name|xyzBounds
operator|.
name|getMaximumX
argument_list|()
operator|-
name|xyzBounds
operator|.
name|getMinimumX
argument_list|()
decl_stmt|;
specifier|final
name|double
name|yDelta
init|=
name|xyzBounds
operator|.
name|getMaximumY
argument_list|()
operator|-
name|xyzBounds
operator|.
name|getMinimumY
argument_list|()
decl_stmt|;
specifier|final
name|double
name|zDelta
init|=
name|xyzBounds
operator|.
name|getMaximumZ
argument_list|()
operator|-
name|xyzBounds
operator|.
name|getMinimumZ
argument_list|()
decl_stmt|;
comment|// Select the smallest range
if|if
condition|(
name|xDelta
operator|<=
name|yDelta
operator|&&
name|xDelta
operator|<=
name|zDelta
condition|)
block|{
comment|// Drill down in x
return|return
operator|!
name|xTree
operator|.
name|traverse
argument_list|(
name|intersector
argument_list|,
name|xyzBounds
operator|.
name|getMinimumX
argument_list|()
argument_list|,
name|xyzBounds
operator|.
name|getMaximumX
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|yDelta
operator|<=
name|xDelta
operator|&&
name|yDelta
operator|<=
name|zDelta
condition|)
block|{
comment|// Drill down in y
return|return
operator|!
name|yTree
operator|.
name|traverse
argument_list|(
name|intersector
argument_list|,
name|xyzBounds
operator|.
name|getMinimumY
argument_list|()
argument_list|,
name|xyzBounds
operator|.
name|getMaximumY
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|zDelta
operator|<=
name|xDelta
operator|&&
name|zDelta
operator|<=
name|yDelta
condition|)
block|{
comment|// Drill down in z
return|return
operator|!
name|zTree
operator|.
name|traverse
argument_list|(
name|intersector
argument_list|,
name|xyzBounds
operator|.
name|getMinimumZ
argument_list|()
argument_list|,
name|xyzBounds
operator|.
name|getMaximumZ
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|getBounds
specifier|public
name|void
name|getBounds
parameter_list|(
name|Bounds
name|bounds
parameter_list|)
block|{
name|super
operator|.
name|getBounds
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|Edge
name|startEdge
range|:
name|shapeStartEdges
control|)
block|{
name|Edge
name|currentEdge
init|=
name|startEdge
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|bounds
operator|.
name|addPlane
argument_list|(
name|this
operator|.
name|planetModel
argument_list|,
name|currentEdge
operator|.
name|plane
argument_list|,
name|currentEdge
operator|.
name|startPlane
argument_list|,
name|currentEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
name|currentEdge
operator|=
name|currentEdge
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|currentEdge
operator|==
name|startEdge
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|outsideDistance
specifier|protected
name|double
name|outsideDistance
parameter_list|(
specifier|final
name|DistanceStyle
name|distanceStyle
parameter_list|,
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
name|double
name|minimumDistance
init|=
name|Double
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
specifier|final
name|Edge
name|shapeStartEdge
range|:
name|shapeStartEdges
control|)
block|{
name|Edge
name|shapeEdge
init|=
name|shapeStartEdge
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|double
name|newDist
init|=
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|shapeEdge
operator|.
name|startPoint
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDist
operator|<
name|minimumDistance
condition|)
block|{
name|minimumDistance
operator|=
name|newDist
expr_stmt|;
block|}
specifier|final
name|double
name|newPlaneDist
init|=
name|distanceStyle
operator|.
name|computeDistance
argument_list|(
name|planetModel
argument_list|,
name|shapeEdge
operator|.
name|plane
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|shapeEdge
operator|.
name|startPlane
argument_list|,
name|shapeEdge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
if|if
condition|(
name|newPlaneDist
operator|<
name|minimumDistance
condition|)
block|{
name|minimumDistance
operator|=
name|newPlaneDist
expr_stmt|;
block|}
name|shapeEdge
operator|=
name|shapeEdge
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|shapeEdge
operator|==
name|shapeStartEdge
condition|)
block|{
break|break;
block|}
block|}
block|}
return|return
name|minimumDistance
return|;
block|}
comment|/**    * An instance of this class describes a single edge, and includes what is necessary to reliably determine intersection    * in the context of the even/odd algorithm used.    */
DECL|class|Edge
specifier|private
specifier|static
class|class
name|Edge
block|{
DECL|field|startPoint
specifier|public
specifier|final
name|GeoPoint
name|startPoint
decl_stmt|;
DECL|field|endPoint
specifier|public
specifier|final
name|GeoPoint
name|endPoint
decl_stmt|;
DECL|field|notablePoints
specifier|public
specifier|final
name|GeoPoint
index|[]
name|notablePoints
decl_stmt|;
DECL|field|startPlane
specifier|public
specifier|final
name|SidedPlane
name|startPlane
decl_stmt|;
DECL|field|endPlane
specifier|public
specifier|final
name|SidedPlane
name|endPlane
decl_stmt|;
DECL|field|plane
specifier|public
specifier|final
name|Plane
name|plane
decl_stmt|;
DECL|field|planeBounds
specifier|public
specifier|final
name|XYZBounds
name|planeBounds
decl_stmt|;
DECL|field|previous
specifier|public
name|Edge
name|previous
init|=
literal|null
decl_stmt|;
DECL|field|next
specifier|public
name|Edge
name|next
init|=
literal|null
decl_stmt|;
DECL|method|Edge
specifier|public
name|Edge
parameter_list|(
specifier|final
name|PlanetModel
name|pm
parameter_list|,
specifier|final
name|GeoPoint
name|startPoint
parameter_list|,
specifier|final
name|GeoPoint
name|endPoint
parameter_list|)
block|{
name|this
operator|.
name|startPoint
operator|=
name|startPoint
expr_stmt|;
name|this
operator|.
name|endPoint
operator|=
name|endPoint
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|startPoint
block|,
name|endPoint
block|}
expr_stmt|;
name|this
operator|.
name|plane
operator|=
operator|new
name|Plane
argument_list|(
name|startPoint
argument_list|,
name|endPoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|startPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|endPoint
argument_list|,
name|plane
argument_list|,
name|startPoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|endPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|startPoint
argument_list|,
name|plane
argument_list|,
name|endPoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|planeBounds
operator|=
operator|new
name|XYZBounds
argument_list|()
expr_stmt|;
name|this
operator|.
name|planeBounds
operator|.
name|addPoint
argument_list|(
name|startPoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|planeBounds
operator|.
name|addPoint
argument_list|(
name|endPoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|plane
operator|.
name|recordBounds
argument_list|(
name|pm
argument_list|,
name|this
operator|.
name|planeBounds
argument_list|,
name|this
operator|.
name|startPlane
argument_list|,
name|this
operator|.
name|endPlane
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Iterator execution interface, for tree traversal.  Pass an object implementing this interface    * into the traversal method of a tree, and each edge that matches will cause this object to be    * called.    */
DECL|interface|EdgeIterator
specifier|private
specifier|static
interface|interface
name|EdgeIterator
block|{
comment|/**      * @param edge is the edge that matched.      * @return true if the iteration should continue, false otherwise.      */
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
function_decl|;
block|}
comment|/**    * Comparison interface for tree traversal.  An object implementing this interface    * gets to decide the relationship between the Edge object and the criteria being considered.    */
DECL|interface|TraverseComparator
specifier|private
specifier|static
interface|interface
name|TraverseComparator
block|{
comment|/**      * Compare an edge.      * @param edge is the edge to compare.      * @param minValue is the minimum value to compare (bottom of the range)      * @param maxValue is the maximum value to compare (top of the range)      * @return -1 if "less" than this one, 0 if overlaps, or 1 if "greater".      */
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|,
specifier|final
name|double
name|minValue
parameter_list|,
specifier|final
name|double
name|maxValue
parameter_list|)
function_decl|;
block|}
comment|/**    * Comparison interface for tree addition.  An object implementing this interface    * gets to decide the relationship between the Edge object and the criteria being considered.    */
DECL|interface|AddComparator
specifier|private
specifier|static
interface|interface
name|AddComparator
block|{
comment|/**      * Compare an edge.      * @param edge is the edge to compare.      * @param addEdge is the edge being added.      * @return -1 if "less" than this one, 0 if overlaps, or 1 if "greater".      */
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|,
specifier|final
name|Edge
name|addEdge
parameter_list|)
function_decl|;
block|}
comment|/**    * An instance of this class represents a node in a tree.  The tree is designed to be given    * a value and from that to iterate over a list of edges.    * In order to do this efficiently, each new edge is dropped into the tree using its minimum and    * maximum value.  If the new edge's value does not overlap the range, then it gets added    * either to the lesser side or the greater side, accordingly.  If it does overlap, then the    * "overlapping" chain is instead traversed.    *    * This class is generic and can be used for any definition of "value".    *    */
DECL|class|Node
specifier|private
specifier|static
class|class
name|Node
block|{
DECL|field|edge
specifier|public
specifier|final
name|Edge
name|edge
decl_stmt|;
DECL|field|lesser
specifier|public
name|Node
name|lesser
init|=
literal|null
decl_stmt|;
DECL|field|greater
specifier|public
name|Node
name|greater
init|=
literal|null
decl_stmt|;
DECL|field|overlaps
specifier|public
name|Node
name|overlaps
init|=
literal|null
decl_stmt|;
DECL|method|Node
specifier|public
name|Node
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
name|this
operator|.
name|edge
operator|=
name|edge
expr_stmt|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
specifier|final
name|Edge
name|newEdge
parameter_list|,
specifier|final
name|AddComparator
name|edgeComparator
parameter_list|)
block|{
name|Node
name|currentNode
init|=
name|this
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|result
init|=
name|edgeComparator
operator|.
name|compare
argument_list|(
name|currentNode
operator|.
name|edge
argument_list|,
name|newEdge
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|currentNode
operator|.
name|lesser
operator|==
literal|null
condition|)
block|{
name|currentNode
operator|.
name|lesser
operator|=
operator|new
name|Node
argument_list|(
name|newEdge
argument_list|)
expr_stmt|;
return|return;
block|}
name|currentNode
operator|=
name|currentNode
operator|.
name|lesser
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|currentNode
operator|.
name|greater
operator|==
literal|null
condition|)
block|{
name|currentNode
operator|.
name|greater
operator|=
operator|new
name|Node
argument_list|(
name|newEdge
argument_list|)
expr_stmt|;
return|return;
block|}
name|currentNode
operator|=
name|currentNode
operator|.
name|greater
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currentNode
operator|.
name|overlaps
operator|==
literal|null
condition|)
block|{
name|currentNode
operator|.
name|overlaps
operator|=
operator|new
name|Node
argument_list|(
name|newEdge
argument_list|)
expr_stmt|;
return|return;
block|}
name|currentNode
operator|=
name|currentNode
operator|.
name|overlaps
expr_stmt|;
block|}
block|}
block|}
DECL|method|traverse
specifier|public
name|boolean
name|traverse
parameter_list|(
specifier|final
name|EdgeIterator
name|edgeIterator
parameter_list|,
specifier|final
name|TraverseComparator
name|edgeComparator
parameter_list|,
specifier|final
name|double
name|minValue
parameter_list|,
specifier|final
name|double
name|maxValue
parameter_list|)
block|{
name|Node
name|currentNode
init|=
name|this
decl_stmt|;
while|while
condition|(
name|currentNode
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|result
init|=
name|edgeComparator
operator|.
name|compare
argument_list|(
name|currentNode
operator|.
name|edge
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|currentNode
operator|=
name|currentNode
operator|.
name|lesser
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|>
literal|0
condition|)
block|{
name|currentNode
operator|=
name|currentNode
operator|.
name|greater
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|edgeIterator
operator|.
name|matches
argument_list|(
name|currentNode
operator|.
name|edge
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|currentNode
operator|=
name|currentNode
operator|.
name|overlaps
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/** An interface describing a tree.    */
DECL|interface|Tree
specifier|private
specifier|static
interface|interface
name|Tree
block|{
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
function_decl|;
DECL|method|traverse
specifier|public
name|boolean
name|traverse
parameter_list|(
specifier|final
name|EdgeIterator
name|edgeIterator
parameter_list|,
specifier|final
name|double
name|minValue
parameter_list|,
specifier|final
name|double
name|maxValue
parameter_list|)
function_decl|;
block|}
comment|/** This is the z-tree.    */
DECL|class|ZTree
specifier|private
specifier|static
class|class
name|ZTree
implements|implements
name|Tree
implements|,
name|TraverseComparator
implements|,
name|AddComparator
block|{
DECL|field|rootNode
specifier|public
name|Node
name|rootNode
init|=
literal|null
decl_stmt|;
DECL|method|ZTree
specifier|public
name|ZTree
parameter_list|()
block|{     }
annotation|@
name|Override
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
if|if
condition|(
name|rootNode
operator|==
literal|null
condition|)
block|{
name|rootNode
operator|=
operator|new
name|Node
argument_list|(
name|edge
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rootNode
operator|.
name|add
argument_list|(
name|edge
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|traverse
specifier|public
name|boolean
name|traverse
parameter_list|(
specifier|final
name|EdgeIterator
name|edgeIterator
parameter_list|,
specifier|final
name|double
name|minValue
parameter_list|,
specifier|final
name|double
name|maxValue
parameter_list|)
block|{
if|if
condition|(
name|rootNode
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|rootNode
operator|.
name|traverse
argument_list|(
name|edgeIterator
argument_list|,
name|this
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|,
specifier|final
name|Edge
name|addEdge
parameter_list|)
block|{
if|if
condition|(
name|edge
operator|.
name|planeBounds
operator|.
name|getMaximumZ
argument_list|()
operator|<
name|addEdge
operator|.
name|planeBounds
operator|.
name|getMinimumZ
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|edge
operator|.
name|planeBounds
operator|.
name|getMinimumZ
argument_list|()
operator|>
name|addEdge
operator|.
name|planeBounds
operator|.
name|getMaximumZ
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|,
specifier|final
name|double
name|minValue
parameter_list|,
specifier|final
name|double
name|maxValue
parameter_list|)
block|{
if|if
condition|(
name|edge
operator|.
name|planeBounds
operator|.
name|getMinimumZ
argument_list|()
operator|>
name|maxValue
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|edge
operator|.
name|planeBounds
operator|.
name|getMaximumZ
argument_list|()
operator|<
name|minValue
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
comment|/** This is the y-tree.    */
DECL|class|YTree
specifier|private
specifier|static
class|class
name|YTree
implements|implements
name|Tree
implements|,
name|TraverseComparator
implements|,
name|AddComparator
block|{
DECL|field|rootNode
specifier|public
name|Node
name|rootNode
init|=
literal|null
decl_stmt|;
DECL|method|YTree
specifier|public
name|YTree
parameter_list|()
block|{     }
annotation|@
name|Override
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
if|if
condition|(
name|rootNode
operator|==
literal|null
condition|)
block|{
name|rootNode
operator|=
operator|new
name|Node
argument_list|(
name|edge
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rootNode
operator|.
name|add
argument_list|(
name|edge
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|traverse
specifier|public
name|boolean
name|traverse
parameter_list|(
specifier|final
name|EdgeIterator
name|edgeIterator
parameter_list|,
specifier|final
name|double
name|minValue
parameter_list|,
specifier|final
name|double
name|maxValue
parameter_list|)
block|{
if|if
condition|(
name|rootNode
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|rootNode
operator|.
name|traverse
argument_list|(
name|edgeIterator
argument_list|,
name|this
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|,
specifier|final
name|Edge
name|addEdge
parameter_list|)
block|{
if|if
condition|(
name|edge
operator|.
name|planeBounds
operator|.
name|getMaximumY
argument_list|()
operator|<
name|addEdge
operator|.
name|planeBounds
operator|.
name|getMinimumY
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|edge
operator|.
name|planeBounds
operator|.
name|getMinimumY
argument_list|()
operator|>
name|addEdge
operator|.
name|planeBounds
operator|.
name|getMaximumY
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|,
specifier|final
name|double
name|minValue
parameter_list|,
specifier|final
name|double
name|maxValue
parameter_list|)
block|{
if|if
condition|(
name|edge
operator|.
name|planeBounds
operator|.
name|getMinimumY
argument_list|()
operator|>
name|maxValue
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|edge
operator|.
name|planeBounds
operator|.
name|getMaximumY
argument_list|()
operator|<
name|minValue
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
comment|/** This is the x-tree.    */
DECL|class|XTree
specifier|private
specifier|static
class|class
name|XTree
implements|implements
name|Tree
implements|,
name|TraverseComparator
implements|,
name|AddComparator
block|{
DECL|field|rootNode
specifier|public
name|Node
name|rootNode
init|=
literal|null
decl_stmt|;
DECL|method|XTree
specifier|public
name|XTree
parameter_list|()
block|{     }
annotation|@
name|Override
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
if|if
condition|(
name|rootNode
operator|==
literal|null
condition|)
block|{
name|rootNode
operator|=
operator|new
name|Node
argument_list|(
name|edge
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rootNode
operator|.
name|add
argument_list|(
name|edge
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|traverse
specifier|public
name|boolean
name|traverse
parameter_list|(
specifier|final
name|EdgeIterator
name|edgeIterator
parameter_list|,
specifier|final
name|double
name|minValue
parameter_list|,
specifier|final
name|double
name|maxValue
parameter_list|)
block|{
if|if
condition|(
name|rootNode
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|rootNode
operator|.
name|traverse
argument_list|(
name|edgeIterator
argument_list|,
name|this
argument_list|,
name|minValue
argument_list|,
name|maxValue
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|,
specifier|final
name|Edge
name|addEdge
parameter_list|)
block|{
if|if
condition|(
name|edge
operator|.
name|planeBounds
operator|.
name|getMaximumX
argument_list|()
operator|<
name|addEdge
operator|.
name|planeBounds
operator|.
name|getMinimumX
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|edge
operator|.
name|planeBounds
operator|.
name|getMinimumX
argument_list|()
operator|>
name|addEdge
operator|.
name|planeBounds
operator|.
name|getMaximumX
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|,
specifier|final
name|double
name|minValue
parameter_list|,
specifier|final
name|double
name|maxValue
parameter_list|)
block|{
if|if
condition|(
name|edge
operator|.
name|planeBounds
operator|.
name|getMinimumX
argument_list|()
operator|>
name|maxValue
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|edge
operator|.
name|planeBounds
operator|.
name|getMaximumX
argument_list|()
operator|<
name|minValue
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
comment|/** Assess whether edge intersects the provided plane plus bounds.    */
DECL|class|IntersectorEdgeIterator
specifier|private
class|class
name|IntersectorEdgeIterator
implements|implements
name|EdgeIterator
block|{
DECL|field|plane
specifier|private
specifier|final
name|Plane
name|plane
decl_stmt|;
DECL|field|notablePoints
specifier|private
specifier|final
name|GeoPoint
index|[]
name|notablePoints
decl_stmt|;
DECL|field|bounds
specifier|private
specifier|final
name|Membership
index|[]
name|bounds
decl_stmt|;
DECL|method|IntersectorEdgeIterator
specifier|public
name|IntersectorEdgeIterator
parameter_list|(
specifier|final
name|Plane
name|plane
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|notablePoints
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
name|this
operator|.
name|plane
operator|=
name|plane
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
name|notablePoints
expr_stmt|;
name|this
operator|.
name|bounds
operator|=
name|bounds
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
return|return
operator|!
name|plane
operator|.
name|intersects
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|notablePoints
argument_list|,
name|edge
operator|.
name|notablePoints
argument_list|,
name|bounds
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
return|;
block|}
block|}
comment|/** Count the number of verifiable edge crossings.    */
DECL|class|LinearCrossingEdgeIterator
specifier|private
class|class
name|LinearCrossingEdgeIterator
implements|implements
name|EdgeIterator
block|{
DECL|field|plane
specifier|private
specifier|final
name|Plane
name|plane
decl_stmt|;
DECL|field|abovePlane
specifier|private
specifier|final
name|Plane
name|abovePlane
decl_stmt|;
DECL|field|belowPlane
specifier|private
specifier|final
name|Plane
name|belowPlane
decl_stmt|;
DECL|field|bound1
specifier|private
specifier|final
name|Membership
name|bound1
decl_stmt|;
DECL|field|bound2
specifier|private
specifier|final
name|Membership
name|bound2
decl_stmt|;
DECL|field|thePoint
specifier|private
specifier|final
name|Vector
name|thePoint
decl_stmt|;
DECL|field|crossingCount
specifier|public
name|int
name|crossingCount
init|=
literal|0
decl_stmt|;
DECL|method|LinearCrossingEdgeIterator
specifier|public
name|LinearCrossingEdgeIterator
parameter_list|(
specifier|final
name|Plane
name|plane
parameter_list|,
specifier|final
name|Plane
name|abovePlane
parameter_list|,
specifier|final
name|Plane
name|belowPlane
parameter_list|,
specifier|final
name|Vector
name|testPoint
parameter_list|,
specifier|final
name|Vector
name|thePoint
parameter_list|)
block|{
name|this
operator|.
name|plane
operator|=
name|plane
expr_stmt|;
name|this
operator|.
name|abovePlane
operator|=
name|abovePlane
expr_stmt|;
name|this
operator|.
name|belowPlane
operator|=
name|belowPlane
expr_stmt|;
name|this
operator|.
name|bound1
operator|=
operator|new
name|SidedPlane
argument_list|(
name|thePoint
argument_list|,
name|plane
argument_list|,
name|testPoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|bound2
operator|=
operator|new
name|SidedPlane
argument_list|(
name|testPoint
argument_list|,
name|plane
argument_list|,
name|thePoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|thePoint
operator|=
name|thePoint
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
comment|// Early exit if the point is on the edge.
if|if
condition|(
name|thePoint
operator|!=
literal|null
operator|&&
name|edge
operator|.
name|plane
operator|.
name|evaluateIsZero
argument_list|(
name|thePoint
argument_list|)
operator|&&
name|edge
operator|.
name|startPlane
operator|.
name|isWithin
argument_list|(
name|thePoint
argument_list|)
operator|&&
name|edge
operator|.
name|endPlane
operator|.
name|isWithin
argument_list|(
name|thePoint
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|GeoPoint
index|[]
name|crossingPoints
init|=
name|plane
operator|.
name|findCrossings
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|bound1
argument_list|,
name|bound2
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
if|if
condition|(
name|crossingPoints
operator|!=
literal|null
condition|)
block|{
comment|// We need to handle the endpoint case, which is quite tricky.
for|for
control|(
specifier|final
name|GeoPoint
name|crossingPoint
range|:
name|crossingPoints
control|)
block|{
name|countCrossingPoint
argument_list|(
name|crossingPoint
argument_list|,
name|edge
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|countCrossingPoint
specifier|private
name|void
name|countCrossingPoint
parameter_list|(
specifier|final
name|GeoPoint
name|crossingPoint
parameter_list|,
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
if|if
condition|(
name|crossingPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|edge
operator|.
name|startPoint
argument_list|)
condition|)
block|{
comment|// We have to figure out if this crossing should be counted.
comment|// Does the crossing for this edge go up, or down?  Or can't we tell?
specifier|final
name|GeoPoint
index|[]
name|aboveIntersections
init|=
name|abovePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|belowIntersections
init|=
name|belowPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
assert|assert
operator|!
operator|(
name|aboveIntersections
operator|.
name|length
operator|>
literal|0
operator|&&
name|belowIntersections
operator|.
name|length
operator|>
literal|0
operator|)
operator|:
literal|"edge that ends in a crossing can't both up and down"
assert|;
if|if
condition|(
name|aboveIntersections
operator|.
name|length
operator|==
literal|0
operator|&&
name|belowIntersections
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return;
block|}
specifier|final
name|boolean
name|edgeCrossesAbove
init|=
name|aboveIntersections
operator|.
name|length
operator|>
literal|0
decl_stmt|;
comment|// This depends on the previous edge that first departs from identicalness.
name|Edge
name|assessEdge
init|=
name|edge
decl_stmt|;
name|GeoPoint
index|[]
name|assessAboveIntersections
decl_stmt|;
name|GeoPoint
index|[]
name|assessBelowIntersections
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|assessEdge
operator|=
name|assessEdge
operator|.
name|previous
expr_stmt|;
name|assessAboveIntersections
operator|=
name|abovePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
name|assessBelowIntersections
operator|=
name|belowPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
assert|assert
operator|!
operator|(
name|assessAboveIntersections
operator|.
name|length
operator|>
literal|0
operator|&&
name|assessBelowIntersections
operator|.
name|length
operator|>
literal|0
operator|)
operator|:
literal|"assess edge that ends in a crossing can't both up and down"
assert|;
if|if
condition|(
name|assessAboveIntersections
operator|.
name|length
operator|==
literal|0
operator|&&
name|assessBelowIntersections
operator|.
name|length
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
break|break;
block|}
comment|// Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite
comment|// directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that
comment|// each edge we look at can also be looked at again if it, too, seems to cross the plane.
comment|// To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make
comment|// a decision whether to count or not based on that.
comment|// Compute the crossing points of this other edge.
specifier|final
name|GeoPoint
index|[]
name|otherCrossingPoints
init|=
name|plane
operator|.
name|findCrossings
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|bound1
argument_list|,
name|bound2
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
comment|// Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the
comment|// transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).
for|for
control|(
specifier|final
name|GeoPoint
name|otherCrossingPoint
range|:
name|otherCrossingPoints
control|)
block|{
if|if
condition|(
name|otherCrossingPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|assessEdge
operator|.
name|endPoint
argument_list|)
condition|)
block|{
comment|// Found it!
comment|// Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.
comment|// Since we're the latter point, we exit here in that case.
return|return;
block|}
block|}
comment|// Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the
comment|// point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges
comment|// and make an assessment that way, since a single edge can intersect the plane at more than one point.
specifier|final
name|boolean
name|assessEdgeAbove
init|=
name|assessAboveIntersections
operator|.
name|length
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|assessEdgeAbove
operator|!=
name|edgeCrossesAbove
condition|)
block|{
name|crossingCount
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|crossingPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|edge
operator|.
name|endPoint
argument_list|)
condition|)
block|{
comment|// Figure out if the crossing should be counted.
comment|// Does the crossing for this edge go up, or down?  Or can't we tell?
specifier|final
name|GeoPoint
index|[]
name|aboveIntersections
init|=
name|abovePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|belowIntersections
init|=
name|belowPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
assert|assert
operator|!
operator|(
name|aboveIntersections
operator|.
name|length
operator|>
literal|0
operator|&&
name|belowIntersections
operator|.
name|length
operator|>
literal|0
operator|)
operator|:
literal|"edge that ends in a crossing can't both up and down"
assert|;
if|if
condition|(
name|aboveIntersections
operator|.
name|length
operator|==
literal|0
operator|&&
name|belowIntersections
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return;
block|}
specifier|final
name|boolean
name|edgeCrossesAbove
init|=
name|aboveIntersections
operator|.
name|length
operator|>
literal|0
decl_stmt|;
comment|// This depends on the previous edge that first departs from identicalness.
name|Edge
name|assessEdge
init|=
name|edge
decl_stmt|;
name|GeoPoint
index|[]
name|assessAboveIntersections
decl_stmt|;
name|GeoPoint
index|[]
name|assessBelowIntersections
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|assessEdge
operator|=
name|assessEdge
operator|.
name|next
expr_stmt|;
name|assessAboveIntersections
operator|=
name|abovePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
name|assessBelowIntersections
operator|=
name|belowPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
assert|assert
operator|!
operator|(
name|assessAboveIntersections
operator|.
name|length
operator|>
literal|0
operator|&&
name|assessBelowIntersections
operator|.
name|length
operator|>
literal|0
operator|)
operator|:
literal|"assess edge that ends in a crossing can't both up and down"
assert|;
if|if
condition|(
name|assessAboveIntersections
operator|.
name|length
operator|==
literal|0
operator|&&
name|assessBelowIntersections
operator|.
name|length
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
break|break;
block|}
comment|// Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite
comment|// directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that
comment|// each edge we look at can also be looked at again if it, too, seems to cross the plane.
comment|// By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary
comment|// to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.
comment|// We need to determine the direction of both edges at the
comment|// point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges
comment|// and make an assessment that way, since a single edge can intersect the plane at more than one point.
specifier|final
name|boolean
name|assessEdgeAbove
init|=
name|assessAboveIntersections
operator|.
name|length
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|assessEdgeAbove
operator|!=
name|edgeCrossesAbove
condition|)
block|{
name|crossingCount
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|crossingCount
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/** Count the number of verifiable edge crossings for a dual-leg journey.    */
DECL|class|DualCrossingEdgeIterator
specifier|private
class|class
name|DualCrossingEdgeIterator
implements|implements
name|EdgeIterator
block|{
DECL|field|isSecondLeg
specifier|private
name|boolean
name|isSecondLeg
init|=
literal|false
decl_stmt|;
DECL|field|testPointPlane
specifier|private
specifier|final
name|Plane
name|testPointPlane
decl_stmt|;
DECL|field|testPointInsidePlane
specifier|private
specifier|final
name|Plane
name|testPointInsidePlane
decl_stmt|;
DECL|field|testPointOutsidePlane
specifier|private
specifier|final
name|Plane
name|testPointOutsidePlane
decl_stmt|;
DECL|field|travelPlane
specifier|private
specifier|final
name|Plane
name|travelPlane
decl_stmt|;
DECL|field|travelInsidePlane
specifier|private
specifier|final
name|Plane
name|travelInsidePlane
decl_stmt|;
DECL|field|travelOutsidePlane
specifier|private
specifier|final
name|Plane
name|travelOutsidePlane
decl_stmt|;
DECL|field|thePoint
specifier|private
specifier|final
name|Vector
name|thePoint
decl_stmt|;
DECL|field|intersectionPoint
specifier|private
specifier|final
name|GeoPoint
name|intersectionPoint
decl_stmt|;
DECL|field|testPointCutoffPlane
specifier|private
specifier|final
name|SidedPlane
name|testPointCutoffPlane
decl_stmt|;
DECL|field|checkPointCutoffPlane
specifier|private
specifier|final
name|SidedPlane
name|checkPointCutoffPlane
decl_stmt|;
DECL|field|testPointOtherCutoffPlane
specifier|private
specifier|final
name|SidedPlane
name|testPointOtherCutoffPlane
decl_stmt|;
DECL|field|checkPointOtherCutoffPlane
specifier|private
specifier|final
name|SidedPlane
name|checkPointOtherCutoffPlane
decl_stmt|;
DECL|field|insideTestPointCutoffPlane
specifier|private
specifier|final
name|SidedPlane
name|insideTestPointCutoffPlane
decl_stmt|;
DECL|field|insideTravelCutoffPlane
specifier|private
specifier|final
name|SidedPlane
name|insideTravelCutoffPlane
decl_stmt|;
DECL|field|crossingCount
specifier|public
name|int
name|crossingCount
init|=
literal|0
decl_stmt|;
DECL|method|DualCrossingEdgeIterator
specifier|public
name|DualCrossingEdgeIterator
parameter_list|(
specifier|final
name|Plane
name|testPointPlane
parameter_list|,
specifier|final
name|Plane
name|testPointAbovePlane
parameter_list|,
specifier|final
name|Plane
name|testPointBelowPlane
parameter_list|,
specifier|final
name|Plane
name|travelPlane
parameter_list|,
specifier|final
name|Vector
name|testPoint
parameter_list|,
specifier|final
name|Vector
name|thePoint
parameter_list|,
specifier|final
name|GeoPoint
name|intersectionPoint
parameter_list|)
block|{
name|this
operator|.
name|testPointPlane
operator|=
name|testPointPlane
expr_stmt|;
name|this
operator|.
name|travelPlane
operator|=
name|travelPlane
expr_stmt|;
name|this
operator|.
name|thePoint
operator|=
name|thePoint
expr_stmt|;
name|this
operator|.
name|intersectionPoint
operator|=
name|intersectionPoint
expr_stmt|;
name|this
operator|.
name|testPointCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|thePoint
argument_list|,
name|testPointPlane
argument_list|,
name|testPoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|checkPointCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|testPoint
argument_list|,
name|travelPlane
argument_list|,
name|thePoint
argument_list|)
expr_stmt|;
comment|// Convert travel plane to a sided plane
name|this
operator|.
name|testPointOtherCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|testPoint
argument_list|,
name|travelPlane
argument_list|,
name|travelPlane
operator|.
name|D
argument_list|)
expr_stmt|;
comment|// Convert testPoint plane to a sided plane
name|this
operator|.
name|checkPointOtherCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|thePoint
argument_list|,
name|testPointPlane
argument_list|,
name|testPointPlane
operator|.
name|D
argument_list|)
expr_stmt|;
comment|// Figure out which of the above/below planes are inside vs. outside.  To do this,
comment|// we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside
comment|// borders.
specifier|final
name|Plane
name|travelAbovePlane
init|=
operator|new
name|Plane
argument_list|(
name|travelPlane
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|Plane
name|travelBelowPlane
init|=
operator|new
name|Plane
argument_list|(
name|travelPlane
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|aboveAbove
init|=
name|travelAbovePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointAbovePlane
argument_list|,
name|testPointCutoffPlane
argument_list|,
name|testPointOtherCutoffPlane
argument_list|,
name|checkPointCutoffPlane
argument_list|,
name|checkPointOtherCutoffPlane
argument_list|)
decl_stmt|;
assert|assert
name|aboveAbove
operator|!=
literal|null
operator|:
literal|"Above + above should not be coplanar"
assert|;
specifier|final
name|GeoPoint
index|[]
name|aboveBelow
init|=
name|travelAbovePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointBelowPlane
argument_list|,
name|testPointCutoffPlane
argument_list|,
name|testPointOtherCutoffPlane
argument_list|,
name|checkPointCutoffPlane
argument_list|,
name|checkPointOtherCutoffPlane
argument_list|)
decl_stmt|;
assert|assert
name|aboveBelow
operator|!=
literal|null
operator|:
literal|"Above + below should not be coplanar"
assert|;
specifier|final
name|GeoPoint
index|[]
name|belowBelow
init|=
name|travelBelowPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointBelowPlane
argument_list|,
name|testPointCutoffPlane
argument_list|,
name|testPointOtherCutoffPlane
argument_list|,
name|checkPointCutoffPlane
argument_list|,
name|checkPointOtherCutoffPlane
argument_list|)
decl_stmt|;
assert|assert
name|belowBelow
operator|!=
literal|null
operator|:
literal|"Below + below should not be coplanar"
assert|;
specifier|final
name|GeoPoint
index|[]
name|belowAbove
init|=
name|travelBelowPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|testPointAbovePlane
argument_list|,
name|testPointCutoffPlane
argument_list|,
name|testPointOtherCutoffPlane
argument_list|,
name|checkPointCutoffPlane
argument_list|,
name|checkPointOtherCutoffPlane
argument_list|)
decl_stmt|;
assert|assert
name|belowAbove
operator|!=
literal|null
operator|:
literal|"Below + above should not be coplanar"
assert|;
assert|assert
operator|(
operator|(
name|aboveAbove
operator|.
name|length
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|aboveBelow
operator|.
name|length
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|belowBelow
operator|.
name|length
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|belowAbove
operator|.
name|length
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|==
literal|1
operator|:
literal|"Can be exactly one inside point, instead was: aa="
operator|+
name|aboveAbove
operator|.
name|length
operator|+
literal|" ab="
operator|+
name|aboveBelow
operator|.
name|length
operator|+
literal|" bb="
operator|+
name|belowBelow
operator|.
name|length
operator|+
literal|" ba="
operator|+
name|belowAbove
operator|.
name|length
assert|;
specifier|final
name|GeoPoint
name|insideIntersection
decl_stmt|;
if|if
condition|(
name|aboveAbove
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|travelInsidePlane
operator|=
name|travelAbovePlane
expr_stmt|;
name|testPointInsidePlane
operator|=
name|testPointAbovePlane
expr_stmt|;
name|travelOutsidePlane
operator|=
name|travelBelowPlane
expr_stmt|;
name|testPointOutsidePlane
operator|=
name|testPointBelowPlane
expr_stmt|;
name|insideIntersection
operator|=
name|aboveAbove
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aboveBelow
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|travelInsidePlane
operator|=
name|travelAbovePlane
expr_stmt|;
name|testPointInsidePlane
operator|=
name|testPointBelowPlane
expr_stmt|;
name|travelOutsidePlane
operator|=
name|travelBelowPlane
expr_stmt|;
name|testPointOutsidePlane
operator|=
name|testPointAbovePlane
expr_stmt|;
name|insideIntersection
operator|=
name|aboveBelow
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|belowBelow
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|travelInsidePlane
operator|=
name|travelBelowPlane
expr_stmt|;
name|testPointInsidePlane
operator|=
name|testPointBelowPlane
expr_stmt|;
name|travelOutsidePlane
operator|=
name|travelAbovePlane
expr_stmt|;
name|testPointOutsidePlane
operator|=
name|testPointAbovePlane
expr_stmt|;
name|insideIntersection
operator|=
name|belowBelow
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|travelInsidePlane
operator|=
name|travelBelowPlane
expr_stmt|;
name|testPointInsidePlane
operator|=
name|testPointAbovePlane
expr_stmt|;
name|travelOutsidePlane
operator|=
name|travelAbovePlane
expr_stmt|;
name|testPointOutsidePlane
operator|=
name|testPointBelowPlane
expr_stmt|;
name|insideIntersection
operator|=
name|belowAbove
index|[
literal|0
index|]
expr_stmt|;
block|}
name|insideTravelCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|thePoint
argument_list|,
name|testPointInsidePlane
argument_list|,
name|testPointInsidePlane
operator|.
name|D
argument_list|)
expr_stmt|;
name|insideTestPointCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|testPoint
argument_list|,
name|travelInsidePlane
argument_list|,
name|travelInsidePlane
operator|.
name|D
argument_list|)
expr_stmt|;
block|}
DECL|method|setSecondLeg
specifier|public
name|void
name|setSecondLeg
parameter_list|()
block|{
name|isSecondLeg
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|matches
specifier|public
name|boolean
name|matches
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
comment|// Early exit if the point is on the edge.
if|if
condition|(
name|thePoint
operator|!=
literal|null
operator|&&
name|edge
operator|.
name|plane
operator|.
name|evaluateIsZero
argument_list|(
name|thePoint
argument_list|)
operator|&&
name|edge
operator|.
name|startPlane
operator|.
name|isWithin
argument_list|(
name|thePoint
argument_list|)
operator|&&
name|edge
operator|.
name|endPlane
operator|.
name|isWithin
argument_list|(
name|thePoint
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// If the intersection point lies on this edge, we should still be able to consider crossing points only.
comment|// Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing
comment|// for at least one of the two planes in order to be a legitimate crossing of the combined path.
specifier|final
name|GeoPoint
index|[]
name|crossingPoints
decl_stmt|;
if|if
condition|(
name|isSecondLeg
condition|)
block|{
name|crossingPoints
operator|=
name|travelPlane
operator|.
name|findCrossings
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|checkPointCutoffPlane
argument_list|,
name|checkPointOtherCutoffPlane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|crossingPoints
operator|=
name|testPointPlane
operator|.
name|findCrossings
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|testPointCutoffPlane
argument_list|,
name|testPointOtherCutoffPlane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|crossingPoints
operator|!=
literal|null
condition|)
block|{
comment|// We need to handle the endpoint case, which is quite tricky.
for|for
control|(
specifier|final
name|GeoPoint
name|crossingPoint
range|:
name|crossingPoints
control|)
block|{
name|countCrossingPoint
argument_list|(
name|crossingPoint
argument_list|,
name|edge
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|countCrossingPoint
specifier|private
name|void
name|countCrossingPoint
parameter_list|(
specifier|final
name|GeoPoint
name|crossingPoint
parameter_list|,
specifier|final
name|Edge
name|edge
parameter_list|)
block|{
comment|// We consider crossing points only in this method.
comment|// Unlike the linear case, there are additional cases when:
comment|// (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;
comment|// (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.
comment|// The other logical difference is that crossings of all kinds have to be considered so that:
comment|// (a) both inside edges are considered together at all times;
comment|// (b) both outside edges are considered together at all times;
comment|// (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.
comment|// Intersection point crossings are either simple, or a crossing on an endpoint.
comment|// In either case, we have to be sure to count each edge only once, since it might appear in both the
comment|// first leg and the second.  If the first leg can process it, it should, and the second should skip it.
if|if
condition|(
name|crossingPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|intersectionPoint
argument_list|)
condition|)
block|{
if|if
condition|(
name|isSecondLeg
condition|)
block|{
comment|// See whether this edge would have been processed in the first leg; if so, we skip it.
specifier|final
name|GeoPoint
index|[]
name|firstLegCrossings
init|=
name|testPointPlane
operator|.
name|findCrossings
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|testPointCutoffPlane
argument_list|,
name|testPointOtherCutoffPlane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|GeoPoint
name|firstLegCrossing
range|:
name|firstLegCrossings
control|)
block|{
if|if
condition|(
name|firstLegCrossing
operator|.
name|isNumericallyIdentical
argument_list|(
name|intersectionPoint
argument_list|)
condition|)
block|{
comment|// We already processed it, so we're done here.
return|return;
block|}
block|}
block|}
block|}
comment|// Plane crossing, either first leg or second leg
specifier|final
name|Plane
name|plane
decl_stmt|;
specifier|final
name|Plane
name|insidePlane
decl_stmt|;
specifier|final
name|Plane
name|outsidePlane
decl_stmt|;
specifier|final
name|SidedPlane
name|bound1
decl_stmt|;
specifier|final
name|SidedPlane
name|bound2
decl_stmt|;
if|if
condition|(
name|isSecondLeg
condition|)
block|{
name|plane
operator|=
name|travelPlane
expr_stmt|;
name|insidePlane
operator|=
name|travelInsidePlane
expr_stmt|;
name|outsidePlane
operator|=
name|travelOutsidePlane
expr_stmt|;
name|bound1
operator|=
name|checkPointCutoffPlane
expr_stmt|;
name|bound2
operator|=
name|checkPointOtherCutoffPlane
expr_stmt|;
block|}
else|else
block|{
name|plane
operator|=
name|testPointPlane
expr_stmt|;
name|insidePlane
operator|=
name|testPointInsidePlane
expr_stmt|;
name|outsidePlane
operator|=
name|testPointOutsidePlane
expr_stmt|;
name|bound1
operator|=
name|testPointCutoffPlane
expr_stmt|;
name|bound2
operator|=
name|testPointOtherCutoffPlane
expr_stmt|;
block|}
if|if
condition|(
name|crossingPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|edge
operator|.
name|startPoint
argument_list|)
condition|)
block|{
comment|// We have to figure out if this crossing should be counted.
comment|// Does the crossing for this edge go up, or down?  Or can't we tell?
specifier|final
name|GeoPoint
index|[]
name|insideTestPointPlaneIntersections
init|=
name|testPointInsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|,
name|insideTestPointCutoffPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|insideTravelPlaneIntersections
init|=
name|travelInsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|,
name|insideTravelCutoffPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|outsideTestPointPlaneIntersections
init|=
name|testPointOutsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|outsideTravelPlaneIntersections
init|=
name|travelOutsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
assert|assert
operator|!
operator|(
name|insideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|insideTravelPlaneIntersections
operator|.
name|length
operator|>
literal|0
operator|&&
name|outsideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|outsideTravelPlaneIntersections
operator|.
name|length
operator|>
literal|0
operator|)
operator|:
literal|"edge that ends in a crossing can't both up and down"
assert|;
if|if
condition|(
name|insideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|insideTravelPlaneIntersections
operator|.
name|length
operator|==
literal|0
operator|&&
name|outsideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|outsideTravelPlaneIntersections
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return;
block|}
specifier|final
name|boolean
name|edgeCrossesInside
init|=
name|insideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|insideTravelPlaneIntersections
operator|.
name|length
operator|>
literal|0
decl_stmt|;
comment|// This depends on the previous edge that first departs from identicalness.
name|Edge
name|assessEdge
init|=
name|edge
decl_stmt|;
name|GeoPoint
index|[]
name|assessInsideTestPointIntersections
decl_stmt|;
name|GeoPoint
index|[]
name|assessInsideTravelIntersections
decl_stmt|;
name|GeoPoint
index|[]
name|assessOutsideTestPointIntersections
decl_stmt|;
name|GeoPoint
index|[]
name|assessOutsideTravelIntersections
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|assessEdge
operator|=
name|assessEdge
operator|.
name|previous
expr_stmt|;
name|assessInsideTestPointIntersections
operator|=
name|testPointInsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|,
name|insideTestPointCutoffPlane
argument_list|)
expr_stmt|;
name|assessInsideTravelIntersections
operator|=
name|travelInsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|,
name|insideTravelCutoffPlane
argument_list|)
expr_stmt|;
name|assessOutsideTestPointIntersections
operator|=
name|testPointOutsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
name|assessOutsideTravelIntersections
operator|=
name|travelOutsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
assert|assert
operator|!
operator|(
name|assessInsideTestPointIntersections
operator|.
name|length
operator|+
name|assessInsideTravelIntersections
operator|.
name|length
operator|>
literal|0
operator|&&
name|assessOutsideTestPointIntersections
operator|.
name|length
operator|+
name|assessOutsideTravelIntersections
operator|.
name|length
operator|>
literal|0
operator|)
operator|:
literal|"assess edge that ends in a crossing can't both up and down"
assert|;
if|if
condition|(
name|assessInsideTestPointIntersections
operator|.
name|length
operator|+
name|assessInsideTravelIntersections
operator|.
name|length
operator|==
literal|0
operator|&&
name|assessOutsideTestPointIntersections
operator|.
name|length
operator|+
name|assessOutsideTravelIntersections
operator|.
name|length
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
break|break;
block|}
comment|// Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite
comment|// directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that
comment|// each edge we look at can also be looked at again if it, too, seems to cross the plane.
comment|// To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make
comment|// a decision whether to count or not based on that.
comment|// Compute the crossing points of this other edge.
specifier|final
name|GeoPoint
index|[]
name|otherCrossingPoints
init|=
name|plane
operator|.
name|findCrossings
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|bound1
argument_list|,
name|bound2
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
comment|// Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the
comment|// transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).
for|for
control|(
specifier|final
name|GeoPoint
name|otherCrossingPoint
range|:
name|otherCrossingPoints
control|)
block|{
if|if
condition|(
name|otherCrossingPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|assessEdge
operator|.
name|endPoint
argument_list|)
condition|)
block|{
comment|// Found it!
comment|// Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.
comment|// Since we're the latter point, we exit here in that case.
return|return;
block|}
block|}
comment|// Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the
comment|// point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges
comment|// and make an assessment that way, since a single edge can intersect the plane at more than one point.
specifier|final
name|boolean
name|assessEdgeInside
init|=
name|assessInsideTestPointIntersections
operator|.
name|length
operator|+
name|assessInsideTravelIntersections
operator|.
name|length
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|assessEdgeInside
operator|!=
name|edgeCrossesInside
condition|)
block|{
name|crossingCount
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|crossingPoint
operator|.
name|isNumericallyIdentical
argument_list|(
name|edge
operator|.
name|endPoint
argument_list|)
condition|)
block|{
comment|// Figure out if the crossing should be counted.
comment|// Does the crossing for this edge go up, or down?  Or can't we tell?
specifier|final
name|GeoPoint
index|[]
name|insideTestPointPlaneIntersections
init|=
name|testPointInsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|,
name|insideTestPointCutoffPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|insideTravelPlaneIntersections
init|=
name|travelInsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|,
name|insideTravelCutoffPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|outsideTestPointPlaneIntersections
init|=
name|testPointOutsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
specifier|final
name|GeoPoint
index|[]
name|outsideTravelPlaneIntersections
init|=
name|travelOutsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|edge
operator|.
name|plane
argument_list|,
name|edge
operator|.
name|startPlane
argument_list|,
name|edge
operator|.
name|endPlane
argument_list|)
decl_stmt|;
assert|assert
operator|!
operator|(
name|insideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|insideTravelPlaneIntersections
operator|.
name|length
operator|>
literal|0
operator|&&
name|outsideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|outsideTravelPlaneIntersections
operator|.
name|length
operator|>
literal|0
operator|)
operator|:
literal|"edge that ends in a crossing can't both up and down"
assert|;
if|if
condition|(
name|insideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|insideTravelPlaneIntersections
operator|.
name|length
operator|==
literal|0
operator|&&
name|outsideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|outsideTravelPlaneIntersections
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return;
block|}
specifier|final
name|boolean
name|edgeCrossesInside
init|=
name|insideTestPointPlaneIntersections
operator|.
name|length
operator|+
name|insideTravelPlaneIntersections
operator|.
name|length
operator|>
literal|0
decl_stmt|;
comment|// This depends on the previous edge that first departs from identicalness.
name|Edge
name|assessEdge
init|=
name|edge
decl_stmt|;
name|GeoPoint
index|[]
name|assessInsideTestPointIntersections
decl_stmt|;
name|GeoPoint
index|[]
name|assessInsideTravelIntersections
decl_stmt|;
name|GeoPoint
index|[]
name|assessOutsideTestPointIntersections
decl_stmt|;
name|GeoPoint
index|[]
name|assessOutsideTravelIntersections
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|assessEdge
operator|=
name|assessEdge
operator|.
name|next
expr_stmt|;
name|assessInsideTestPointIntersections
operator|=
name|testPointInsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|,
name|insideTestPointCutoffPlane
argument_list|)
expr_stmt|;
name|assessInsideTravelIntersections
operator|=
name|travelInsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|,
name|insideTravelCutoffPlane
argument_list|)
expr_stmt|;
name|assessOutsideTestPointIntersections
operator|=
name|testPointOutsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
name|assessOutsideTravelIntersections
operator|=
name|travelOutsidePlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|assessEdge
operator|.
name|plane
argument_list|,
name|assessEdge
operator|.
name|startPlane
argument_list|,
name|assessEdge
operator|.
name|endPlane
argument_list|)
expr_stmt|;
assert|assert
operator|!
operator|(
name|assessInsideTestPointIntersections
operator|.
name|length
operator|+
name|assessInsideTravelIntersections
operator|.
name|length
operator|>
literal|0
operator|&&
name|assessOutsideTestPointIntersections
operator|.
name|length
operator|+
name|assessOutsideTravelIntersections
operator|.
name|length
operator|>
literal|0
operator|)
operator|:
literal|"assess edge that ends in a crossing can't both up and down"
assert|;
if|if
condition|(
name|assessInsideTestPointIntersections
operator|.
name|length
operator|+
name|assessInsideTravelIntersections
operator|.
name|length
operator|==
literal|0
operator|&&
name|assessOutsideTestPointIntersections
operator|.
name|length
operator|+
name|assessOutsideTravelIntersections
operator|.
name|length
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
break|break;
block|}
comment|// Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite
comment|// directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that
comment|// each edge we look at can also be looked at again if it, too, seems to cross the plane.
comment|// By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary
comment|// to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.
comment|// We need to determine the direction of both edges at the
comment|// point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges
comment|// and make an assessment that way, since a single edge can intersect the plane at more than one point.
specifier|final
name|boolean
name|assessEdgeInside
init|=
name|assessInsideTestPointIntersections
operator|.
name|length
operator|+
name|assessInsideTravelIntersections
operator|.
name|length
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|assessEdgeInside
operator|!=
name|edgeCrossesInside
condition|)
block|{
name|crossingCount
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Not a special case, so we can safely count a crossing.
name|crossingCount
operator|++
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
comment|// Way too expensive to do this the hard way, so each complex polygon will be considered unique.
return|return
name|this
operator|==
name|o
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// Each complex polygon is considered unique.
return|return
name|System
operator|.
name|identityHashCode
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"GeoComplexPolygon: {planetmodel="
operator|+
name|planetModel
operator|+
literal|", number of shapes="
operator|+
name|shapeStartEdges
operator|.
name|length
operator|+
literal|", address="
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|hashCode
argument_list|()
argument_list|)
operator|+
literal|"}"
return|;
block|}
block|}
end_class
end_unit
