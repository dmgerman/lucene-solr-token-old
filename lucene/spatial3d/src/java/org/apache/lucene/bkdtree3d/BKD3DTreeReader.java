begin_unit
begin_package
DECL|package|org.apache.lucene.bkdtree3d
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|bkdtree3d
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Accountable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|DocIdSetBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_comment
comment|/** Handles intersection of a shape with a BKD tree previously written with {@link BKD3DTreeWriter}.  *  * @lucene.experimental */
end_comment
begin_class
DECL|class|BKD3DTreeReader
specifier|final
class|class
name|BKD3DTreeReader
implements|implements
name|Accountable
block|{
DECL|field|splitValues
specifier|final
specifier|private
name|int
index|[]
name|splitValues
decl_stmt|;
DECL|field|leafNodeOffset
specifier|final
specifier|private
name|int
name|leafNodeOffset
decl_stmt|;
DECL|field|leafBlockFPs
specifier|final
specifier|private
name|long
index|[]
name|leafBlockFPs
decl_stmt|;
DECL|field|maxDoc
specifier|final
name|int
name|maxDoc
decl_stmt|;
DECL|field|in
specifier|final
name|IndexInput
name|in
decl_stmt|;
DECL|enum|Relation
DECL|enum constant|CELL_INSIDE_SHAPE
DECL|enum constant|SHAPE_CROSSES_CELL
DECL|enum constant|SHAPE_OUTSIDE_CELL
DECL|enum constant|SHAPE_INSIDE_CELL
enum|enum
name|Relation
block|{
name|CELL_INSIDE_SHAPE
block|,
name|SHAPE_CROSSES_CELL
block|,
name|SHAPE_OUTSIDE_CELL
block|,
name|SHAPE_INSIDE_CELL
block|}
empty_stmt|;
DECL|interface|ValueFilter
interface|interface
name|ValueFilter
block|{
DECL|method|accept
name|boolean
name|accept
parameter_list|(
name|int
name|docID
parameter_list|)
function_decl|;
DECL|method|compare
name|Relation
name|compare
parameter_list|(
name|int
name|cellXMin
parameter_list|,
name|int
name|cellXMax
parameter_list|,
name|int
name|cellYMin
parameter_list|,
name|int
name|cellYMax
parameter_list|,
name|int
name|cellZMin
parameter_list|,
name|int
name|cellZMax
parameter_list|)
function_decl|;
block|}
DECL|method|BKD3DTreeReader
specifier|public
name|BKD3DTreeReader
parameter_list|(
name|IndexInput
name|in
parameter_list|,
name|int
name|maxDoc
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Read index:
name|int
name|numLeaves
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|leafNodeOffset
operator|=
name|numLeaves
expr_stmt|;
comment|// Tree is fully balanced binary tree, so number of nodes = numLeaves-1, except our nodeIDs are 1-based (splitValues[0] is unused):
name|splitValues
operator|=
operator|new
name|int
index|[
name|numLeaves
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numLeaves
condition|;
name|i
operator|++
control|)
block|{
name|splitValues
index|[
name|i
index|]
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
name|leafBlockFPs
operator|=
operator|new
name|long
index|[
name|numLeaves
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numLeaves
condition|;
name|i
operator|++
control|)
block|{
name|leafBlockFPs
index|[
name|i
index|]
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|maxDoc
operator|=
name|maxDoc
expr_stmt|;
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
block|}
DECL|class|QueryState
specifier|private
specifier|static
specifier|final
class|class
name|QueryState
block|{
DECL|field|in
specifier|final
name|IndexInput
name|in
decl_stmt|;
DECL|field|scratch
name|byte
index|[]
name|scratch
init|=
operator|new
name|byte
index|[
literal|16
index|]
decl_stmt|;
DECL|field|scratchReader
specifier|final
name|ByteArrayDataInput
name|scratchReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|(
name|scratch
argument_list|)
decl_stmt|;
DECL|field|docs
specifier|final
name|DocIdSetBuilder
name|docs
decl_stmt|;
DECL|field|xMin
specifier|final
name|int
name|xMin
decl_stmt|;
DECL|field|xMax
specifier|final
name|int
name|xMax
decl_stmt|;
DECL|field|yMin
specifier|final
name|int
name|yMin
decl_stmt|;
DECL|field|yMax
specifier|final
name|int
name|yMax
decl_stmt|;
DECL|field|zMin
specifier|final
name|int
name|zMin
decl_stmt|;
DECL|field|zMax
specifier|final
name|int
name|zMax
decl_stmt|;
DECL|field|valueFilter
specifier|final
name|ValueFilter
name|valueFilter
decl_stmt|;
DECL|method|QueryState
specifier|public
name|QueryState
parameter_list|(
name|IndexInput
name|in
parameter_list|,
name|int
name|maxDoc
parameter_list|,
name|int
name|xMin
parameter_list|,
name|int
name|xMax
parameter_list|,
name|int
name|yMin
parameter_list|,
name|int
name|yMax
parameter_list|,
name|int
name|zMin
parameter_list|,
name|int
name|zMax
parameter_list|,
name|ValueFilter
name|valueFilter
parameter_list|)
block|{
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|docs
operator|=
operator|new
name|DocIdSetBuilder
argument_list|(
name|maxDoc
argument_list|)
expr_stmt|;
name|this
operator|.
name|xMin
operator|=
name|xMin
expr_stmt|;
name|this
operator|.
name|xMax
operator|=
name|xMax
expr_stmt|;
name|this
operator|.
name|yMin
operator|=
name|yMin
expr_stmt|;
name|this
operator|.
name|yMax
operator|=
name|yMax
expr_stmt|;
name|this
operator|.
name|zMin
operator|=
name|zMin
expr_stmt|;
name|this
operator|.
name|zMax
operator|=
name|zMax
expr_stmt|;
name|this
operator|.
name|valueFilter
operator|=
name|valueFilter
expr_stmt|;
block|}
block|}
DECL|method|intersect
specifier|public
name|DocIdSet
name|intersect
parameter_list|(
name|ValueFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|intersect
argument_list|(
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|filter
argument_list|)
return|;
block|}
comment|/** Optimized intersect which takes the 3D bbox for the query and uses that to avoid filter.compare calls   *   when cells are clearly outside the bbox. */
DECL|method|intersect
specifier|public
name|DocIdSet
name|intersect
parameter_list|(
name|int
name|xMin
parameter_list|,
name|int
name|xMax
parameter_list|,
name|int
name|yMin
parameter_list|,
name|int
name|yMax
parameter_list|,
name|int
name|zMin
parameter_list|,
name|int
name|zMax
parameter_list|,
name|ValueFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|QueryState
name|state
init|=
operator|new
name|QueryState
argument_list|(
name|in
operator|.
name|clone
argument_list|()
argument_list|,
name|maxDoc
argument_list|,
name|xMin
argument_list|,
name|xMax
argument_list|,
name|yMin
argument_list|,
name|yMax
argument_list|,
name|zMin
argument_list|,
name|zMax
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|int
name|hitCount
init|=
name|intersect
argument_list|(
name|state
argument_list|,
literal|1
argument_list|,
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
comment|// NOTE: hitCount is an over-estimate in the multi-valued case:
return|return
name|state
operator|.
name|docs
operator|.
name|build
argument_list|(
name|hitCount
argument_list|)
return|;
block|}
comment|/** Fast path: this is called when the query rect fully encompasses all cells under this node. */
DECL|method|addAll
specifier|private
name|int
name|addAll
parameter_list|(
name|QueryState
name|state
parameter_list|,
name|int
name|nodeID
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("  addAll nodeID=" + nodeID + " leafNodeOffset=" + leafNodeOffset);
if|if
condition|(
name|nodeID
operator|>=
name|leafNodeOffset
condition|)
block|{
comment|/*       System.out.println("A: " + BKDTreeWriter.decodeLat(cellLatMinEnc)                          + " " + BKDTreeWriter.decodeLat(cellLatMaxEnc)                          + " " + BKDTreeWriter.decodeLon(cellLonMinEnc)                          + " " + BKDTreeWriter.decodeLon(cellLonMaxEnc));       */
comment|// Leaf node
name|long
name|fp
init|=
name|leafBlockFPs
index|[
name|nodeID
operator|-
name|leafNodeOffset
index|]
decl_stmt|;
comment|//System.out.println("    leaf fp=" + fp);
name|state
operator|.
name|in
operator|.
name|seek
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|//System.out.println("    seek to leafFP=" + fp);
comment|// How many points are stored in this leaf cell:
name|int
name|count
init|=
name|state
operator|.
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
comment|//System.out.println("    count=" + count);
name|state
operator|.
name|docs
operator|.
name|grow
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|docID
init|=
name|state
operator|.
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|state
operator|.
name|docs
operator|.
name|add
argument_list|(
name|docID
argument_list|)
expr_stmt|;
comment|// Up above in the recursion we asked valueFilter to relate our cell, and it returned Relation.CELL_INSIDE_SHAPE
comment|// so all docs inside this cell better be accepted by the filter:
comment|// NOTE: this is too anal, because we lost precision in the pack/unpack (8 bytes to 4 bytes), a point that's a bit above/below the
comment|// earth's surface due to that quantization may incorrectly evaluate as not inside the shape:
comment|// assert state.valueFilter.accept(docID);
block|}
return|return
name|count
return|;
block|}
else|else
block|{
name|int
name|count
init|=
name|addAll
argument_list|(
name|state
argument_list|,
literal|2
operator|*
name|nodeID
argument_list|)
decl_stmt|;
name|count
operator|+=
name|addAll
argument_list|(
name|state
argument_list|,
literal|2
operator|*
name|nodeID
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
block|}
DECL|method|intersect
specifier|private
name|int
name|intersect
parameter_list|(
name|QueryState
name|state
parameter_list|,
name|int
name|nodeID
parameter_list|,
name|int
name|cellXMin
parameter_list|,
name|int
name|cellXMax
parameter_list|,
name|int
name|cellYMin
parameter_list|,
name|int
name|cellYMax
parameter_list|,
name|int
name|cellZMin
parameter_list|,
name|int
name|cellZMax
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("BKD3D.intersect nodeID=" + nodeID + " cellX=" + cellXMin + " TO " + cellXMax + ", cellY=" + cellYMin + " TO " + cellYMax + ", cellZ=" + cellZMin + " TO " + cellZMax);
if|if
condition|(
name|cellXMin
operator|>=
name|state
operator|.
name|xMin
operator|||
name|cellXMax
operator|<=
name|state
operator|.
name|xMax
operator|||
name|cellYMin
operator|>=
name|state
operator|.
name|yMin
operator|||
name|cellYMax
operator|<=
name|state
operator|.
name|yMax
operator|||
name|cellZMin
operator|>=
name|state
operator|.
name|zMin
operator|||
name|cellZMax
operator|<=
name|state
operator|.
name|zMax
condition|)
block|{
comment|// Only call the filter when the current cell does not fully contain the bbox:
name|Relation
name|r
init|=
name|state
operator|.
name|valueFilter
operator|.
name|compare
argument_list|(
name|cellXMin
argument_list|,
name|cellXMax
argument_list|,
name|cellYMin
argument_list|,
name|cellYMax
argument_list|,
name|cellZMin
argument_list|,
name|cellZMax
argument_list|)
decl_stmt|;
comment|//System.out.println("  relation: " + r);
if|if
condition|(
name|r
operator|==
name|Relation
operator|.
name|SHAPE_OUTSIDE_CELL
condition|)
block|{
comment|// This cell is fully outside of the query shape: stop recursing
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
name|Relation
operator|.
name|CELL_INSIDE_SHAPE
condition|)
block|{
comment|// This cell is fully inside of the query shape: recursively add all points in this cell without filtering
comment|/*         System.out.println(Thread.currentThread() + ": switch to addAll at cell" +                            " x=" + Geo3DDocValuesFormat.decodeValue(cellXMin) + " to " + Geo3DDocValuesFormat.decodeValue(cellXMax) +                            " y=" + Geo3DDocValuesFormat.decodeValue(cellYMin) + " to " + Geo3DDocValuesFormat.decodeValue(cellYMax) +                            " z=" + Geo3DDocValuesFormat.decodeValue(cellZMin) + " to " + Geo3DDocValuesFormat.decodeValue(cellZMax));         */
return|return
name|addAll
argument_list|(
name|state
argument_list|,
name|nodeID
argument_list|)
return|;
block|}
else|else
block|{
comment|// The cell crosses the shape boundary, so we fall through and do full filtering
block|}
block|}
else|else
block|{
comment|// The whole point of the incoming bbox (state.xMin/xMax/etc.) is that it is
comment|// supposed to fully enclose the shape, so this cell we are visiting, which
comment|// fully contains the query's bbox, better in turn fully contain the shape!
assert|assert
name|state
operator|.
name|valueFilter
operator|.
name|compare
argument_list|(
name|cellXMin
argument_list|,
name|cellXMax
argument_list|,
name|cellYMin
argument_list|,
name|cellYMax
argument_list|,
name|cellZMin
argument_list|,
name|cellZMax
argument_list|)
operator|==
name|Relation
operator|.
name|SHAPE_INSIDE_CELL
operator|:
literal|"got "
operator|+
name|state
operator|.
name|valueFilter
operator|.
name|compare
argument_list|(
name|cellXMin
argument_list|,
name|cellXMax
argument_list|,
name|cellYMin
argument_list|,
name|cellYMax
argument_list|,
name|cellZMin
argument_list|,
name|cellZMax
argument_list|)
assert|;
block|}
comment|//System.out.println("\nintersect node=" + nodeID + " vs " + leafNodeOffset);
if|if
condition|(
name|nodeID
operator|>=
name|leafNodeOffset
condition|)
block|{
comment|//System.out.println("  leaf");
comment|// Leaf node; scan and filter all points in this block:
comment|//System.out.println("    intersect leaf nodeID=" + nodeID + " vs leafNodeOffset=" + leafNodeOffset + " fp=" + leafBlockFPs[nodeID-leafNodeOffset]);
name|int
name|hitCount
init|=
literal|0
decl_stmt|;
name|long
name|fp
init|=
name|leafBlockFPs
index|[
name|nodeID
operator|-
name|leafNodeOffset
index|]
decl_stmt|;
comment|/*       System.out.println("I: " + BKDTreeWriter.decodeLat(cellLatMinEnc)                          + " " + BKDTreeWriter.decodeLat(cellLatMaxEnc)                          + " " + BKDTreeWriter.decodeLon(cellLonMinEnc)                          + " " + BKDTreeWriter.decodeLon(cellLonMaxEnc));       */
name|state
operator|.
name|in
operator|.
name|seek
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|// How many points are stored in this leaf cell:
name|int
name|count
init|=
name|state
operator|.
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|state
operator|.
name|docs
operator|.
name|grow
argument_list|(
name|count
argument_list|)
expr_stmt|;
comment|//System.out.println("  count=" + count);
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|docID
init|=
name|state
operator|.
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
comment|//System.out.println("  check docID=" + docID);
if|if
condition|(
name|state
operator|.
name|valueFilter
operator|.
name|accept
argument_list|(
name|docID
argument_list|)
condition|)
block|{
name|state
operator|.
name|docs
operator|.
name|add
argument_list|(
name|docID
argument_list|)
expr_stmt|;
name|hitCount
operator|++
expr_stmt|;
block|}
block|}
return|return
name|hitCount
return|;
block|}
else|else
block|{
comment|//System.out.println("  non-leaf");
name|int
name|splitDim
init|=
name|BKD3DTreeWriter
operator|.
name|getSplitDim
argument_list|(
name|cellXMin
argument_list|,
name|cellXMax
argument_list|,
name|cellYMin
argument_list|,
name|cellYMax
argument_list|,
name|cellZMin
argument_list|,
name|cellZMax
argument_list|)
decl_stmt|;
name|int
name|splitValue
init|=
name|splitValues
index|[
name|nodeID
index|]
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|splitDim
operator|==
literal|0
condition|)
block|{
comment|//System.out.println("  split on lat=" + splitValue);
comment|// Inner node split on x:
comment|// Left node:
if|if
condition|(
name|state
operator|.
name|xMin
operator|<=
name|splitValue
condition|)
block|{
comment|//System.out.println("  recurse left");
name|count
operator|+=
name|intersect
argument_list|(
name|state
argument_list|,
literal|2
operator|*
name|nodeID
argument_list|,
name|cellXMin
argument_list|,
name|splitValue
argument_list|,
name|cellYMin
argument_list|,
name|cellYMax
argument_list|,
name|cellZMin
argument_list|,
name|cellZMax
argument_list|)
expr_stmt|;
block|}
comment|// Right node:
if|if
condition|(
name|state
operator|.
name|xMax
operator|>=
name|splitValue
condition|)
block|{
comment|//System.out.println("  recurse right");
name|count
operator|+=
name|intersect
argument_list|(
name|state
argument_list|,
literal|2
operator|*
name|nodeID
operator|+
literal|1
argument_list|,
name|splitValue
argument_list|,
name|cellXMax
argument_list|,
name|cellYMin
argument_list|,
name|cellYMax
argument_list|,
name|cellZMin
argument_list|,
name|cellZMax
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|splitDim
operator|==
literal|1
condition|)
block|{
comment|// Inner node split on y:
comment|// System.out.println("  split on lon=" + splitValue);
comment|// Left node:
if|if
condition|(
name|state
operator|.
name|yMin
operator|<=
name|splitValue
condition|)
block|{
comment|// System.out.println("  recurse left");
name|count
operator|+=
name|intersect
argument_list|(
name|state
argument_list|,
literal|2
operator|*
name|nodeID
argument_list|,
name|cellXMin
argument_list|,
name|cellXMax
argument_list|,
name|cellYMin
argument_list|,
name|splitValue
argument_list|,
name|cellZMin
argument_list|,
name|cellZMax
argument_list|)
expr_stmt|;
block|}
comment|// Right node:
if|if
condition|(
name|state
operator|.
name|yMax
operator|>=
name|splitValue
condition|)
block|{
comment|// System.out.println("  recurse right");
name|count
operator|+=
name|intersect
argument_list|(
name|state
argument_list|,
literal|2
operator|*
name|nodeID
operator|+
literal|1
argument_list|,
name|cellXMin
argument_list|,
name|cellXMax
argument_list|,
name|splitValue
argument_list|,
name|cellYMax
argument_list|,
name|cellZMin
argument_list|,
name|cellZMax
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Inner node split on z:
comment|// System.out.println("  split on lon=" + splitValue);
comment|// Left node:
if|if
condition|(
name|state
operator|.
name|zMin
operator|<=
name|splitValue
condition|)
block|{
comment|// System.out.println("  recurse left");
name|count
operator|+=
name|intersect
argument_list|(
name|state
argument_list|,
literal|2
operator|*
name|nodeID
argument_list|,
name|cellXMin
argument_list|,
name|cellXMax
argument_list|,
name|cellYMin
argument_list|,
name|cellYMax
argument_list|,
name|cellZMin
argument_list|,
name|splitValue
argument_list|)
expr_stmt|;
block|}
comment|// Right node:
if|if
condition|(
name|state
operator|.
name|zMax
operator|>=
name|splitValue
condition|)
block|{
comment|// System.out.println("  recurse right");
name|count
operator|+=
name|intersect
argument_list|(
name|state
argument_list|,
literal|2
operator|*
name|nodeID
operator|+
literal|1
argument_list|,
name|cellXMin
argument_list|,
name|cellXMax
argument_list|,
name|cellYMin
argument_list|,
name|cellYMax
argument_list|,
name|splitValue
argument_list|,
name|cellZMax
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
return|return
name|splitValues
operator|.
name|length
operator|*
name|RamUsageEstimator
operator|.
name|NUM_BYTES_INT
operator|+
name|leafBlockFPs
operator|.
name|length
operator|*
name|RamUsageEstimator
operator|.
name|NUM_BYTES_LONG
return|;
block|}
block|}
end_class
end_unit
