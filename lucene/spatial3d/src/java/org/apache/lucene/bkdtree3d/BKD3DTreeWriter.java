begin_unit
begin_package
DECL|package|org.apache.lucene.bkdtree3d
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|bkdtree3d
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|DirectoryStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|InPlaceMergeSorter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LongBitSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|OfflineSorter
operator|.
name|ByteSequencesWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|OfflineSorter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_comment
comment|// TODO
end_comment
begin_comment
comment|//   - we could also index "auto-prefix terms" here, and use better compression, and maybe only use for the "fully contained" case so we'd
end_comment
begin_comment
comment|//     only index docIDs
end_comment
begin_comment
comment|//   - the index could be efficiently encoded as an FST, so we don't have wasteful
end_comment
begin_comment
comment|//     (monotonic) long[] leafBlockFPs; or we could use MonotonicLongValues ... but then
end_comment
begin_comment
comment|//     the index is already plenty small: 60M OSM points --> 1.1 MB with 128 points
end_comment
begin_comment
comment|//     per leaf, and you can reduce that by putting more points per leaf
end_comment
begin_comment
comment|//   - we can quantize the split values to 2 bytes (short): http://people.csail.mit.edu/tmertens/papers/qkdtree.pdf
end_comment
begin_comment
comment|//   - we could use threads while building; the higher nodes are very parallelizable
end_comment
begin_comment
comment|//   - generalize to N dimenions? i think there are reasonable use cases here, e.g.
end_comment
begin_comment
comment|//     2 dimensional points to store houses, plus e.g. 3rd dimension for "household income"
end_comment
begin_comment
comment|/** Recursively builds a BKD tree to assign all incoming points to smaller  *  and smaller rectangles until the number of points in a given  *  rectangle is&lt= the<code>maxPointsInLeafNode</code>.  The tree is  *  fully balanced, which means the leaf nodes will have between 50% and 100% of  *  the requested<code>maxPointsInLeafNode</code>, except for the adversarial case  *  of indexing exactly the same point many times.  *  *<p>  *  See<a href="https://www.cs.duke.edu/~pankaj/publications/papers/bkd-sstd.pdf">this paper</a> for details.  *  *<p>This consumes heap during writing: it allocates a<code>LongBitSet(numPoints)</code>,   *  and for any nodes with fewer than<code>maxPointsSortInHeap</code>, it holds  *  the points in memory as simple java arrays.  *  *<p>  *<b>NOTE</b>: This can write at most Integer.MAX_VALUE *<code>maxPointsInLeafNode</code> total points.  *  * @lucene.experimental */
end_comment
begin_class
DECL|class|BKD3DTreeWriter
class|class
name|BKD3DTreeWriter
block|{
comment|// x (int), y (int), z (int) + ord (long) + docID (int)
DECL|field|BYTES_PER_DOC
specifier|static
specifier|final
name|int
name|BYTES_PER_DOC
init|=
name|RamUsageEstimator
operator|.
name|NUM_BYTES_LONG
operator|+
literal|4
operator|*
name|RamUsageEstimator
operator|.
name|NUM_BYTES_INT
decl_stmt|;
comment|//static final boolean DEBUG = false;
DECL|field|DEFAULT_MAX_POINTS_IN_LEAF_NODE
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_POINTS_IN_LEAF_NODE
init|=
literal|1024
decl_stmt|;
comment|/** This works out to max of ~10 MB peak heap tied up during writing: */
DECL|field|DEFAULT_MAX_POINTS_SORT_IN_HEAP
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_POINTS_SORT_IN_HEAP
init|=
literal|128
operator|*
literal|1024
decl_stmt|;
empty_stmt|;
DECL|field|scratchBytes
specifier|private
specifier|final
name|byte
index|[]
name|scratchBytes
init|=
operator|new
name|byte
index|[
name|BYTES_PER_DOC
index|]
decl_stmt|;
DECL|field|scratchBytesOutput
specifier|private
specifier|final
name|ByteArrayDataOutput
name|scratchBytesOutput
init|=
operator|new
name|ByteArrayDataOutput
argument_list|(
name|scratchBytes
argument_list|)
decl_stmt|;
DECL|field|writer
specifier|private
name|OfflineSorter
operator|.
name|ByteSequencesWriter
name|writer
decl_stmt|;
DECL|field|heapWriter
specifier|private
name|GrowingHeapWriter
name|heapWriter
decl_stmt|;
DECL|field|tempInput
specifier|private
name|Path
name|tempInput
decl_stmt|;
DECL|field|maxPointsInLeafNode
specifier|private
specifier|final
name|int
name|maxPointsInLeafNode
decl_stmt|;
DECL|field|maxPointsSortInHeap
specifier|private
specifier|final
name|int
name|maxPointsSortInHeap
decl_stmt|;
DECL|field|pointCount
specifier|private
name|long
name|pointCount
decl_stmt|;
DECL|field|scratchDocIDs
specifier|private
specifier|final
name|int
index|[]
name|scratchDocIDs
decl_stmt|;
DECL|method|BKD3DTreeWriter
specifier|public
name|BKD3DTreeWriter
parameter_list|()
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|DEFAULT_MAX_POINTS_IN_LEAF_NODE
argument_list|,
name|DEFAULT_MAX_POINTS_SORT_IN_HEAP
argument_list|)
expr_stmt|;
block|}
comment|// TODO: instead of maxPointsSortInHeap, change to maxMBHeap ... the mapping is non-obvious:
DECL|method|BKD3DTreeWriter
specifier|public
name|BKD3DTreeWriter
parameter_list|(
name|int
name|maxPointsInLeafNode
parameter_list|,
name|int
name|maxPointsSortInHeap
parameter_list|)
throws|throws
name|IOException
block|{
name|verifyParams
argument_list|(
name|maxPointsInLeafNode
argument_list|,
name|maxPointsSortInHeap
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxPointsInLeafNode
operator|=
name|maxPointsInLeafNode
expr_stmt|;
name|this
operator|.
name|maxPointsSortInHeap
operator|=
name|maxPointsSortInHeap
expr_stmt|;
name|scratchDocIDs
operator|=
operator|new
name|int
index|[
name|maxPointsInLeafNode
index|]
expr_stmt|;
comment|// We write first maxPointsSortInHeap in heap, then cutover to offline for additional points:
name|heapWriter
operator|=
operator|new
name|GrowingHeapWriter
argument_list|(
name|maxPointsSortInHeap
argument_list|)
expr_stmt|;
block|}
DECL|method|verifyParams
specifier|public
specifier|static
name|void
name|verifyParams
parameter_list|(
name|int
name|maxPointsInLeafNode
parameter_list|,
name|int
name|maxPointsSortInHeap
parameter_list|)
block|{
if|if
condition|(
name|maxPointsInLeafNode
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxPointsInLeafNode must be> 0; got "
operator|+
name|maxPointsInLeafNode
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxPointsInLeafNode
operator|>
name|ArrayUtil
operator|.
name|MAX_ARRAY_LENGTH
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxPointsInLeafNode must be<= ArrayUtil.MAX_ARRAY_LENGTH (= "
operator|+
name|ArrayUtil
operator|.
name|MAX_ARRAY_LENGTH
operator|+
literal|"); got "
operator|+
name|maxPointsInLeafNode
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxPointsSortInHeap
operator|<
name|maxPointsInLeafNode
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxPointsSortInHeap must be>= maxPointsInLeafNode; got "
operator|+
name|maxPointsSortInHeap
operator|+
literal|" vs maxPointsInLeafNode="
operator|+
name|maxPointsInLeafNode
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxPointsSortInHeap
operator|>
name|ArrayUtil
operator|.
name|MAX_ARRAY_LENGTH
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxPointsSortInHeap must be<= ArrayUtil.MAX_ARRAY_LENGTH (= "
operator|+
name|ArrayUtil
operator|.
name|MAX_ARRAY_LENGTH
operator|+
literal|"); got "
operator|+
name|maxPointsSortInHeap
argument_list|)
throw|;
block|}
block|}
comment|/** If the current segment has too many points then we switchover to temp files / offline sort. */
DECL|method|switchToOffline
specifier|private
name|void
name|switchToOffline
parameter_list|()
throws|throws
name|IOException
block|{
comment|// For each .add we just append to this input file, then in .finish we sort this input and resursively build the tree:
name|tempInput
operator|=
name|Files
operator|.
name|createTempFile
argument_list|(
name|OfflineSorter
operator|.
name|getDefaultTempDir
argument_list|()
argument_list|,
literal|"in"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|writer
operator|=
operator|new
name|OfflineSorter
operator|.
name|ByteSequencesWriter
argument_list|(
name|tempInput
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
name|i
operator|++
control|)
block|{
name|scratchBytesOutput
operator|.
name|reset
argument_list|(
name|scratchBytes
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeInt
argument_list|(
name|heapWriter
operator|.
name|xs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeInt
argument_list|(
name|heapWriter
operator|.
name|ys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeInt
argument_list|(
name|heapWriter
operator|.
name|zs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeVInt
argument_list|(
name|heapWriter
operator|.
name|docIDs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeVLong
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// TODO: can/should OfflineSorter optimize the fixed-width case?
name|writer
operator|.
name|write
argument_list|(
name|scratchBytes
argument_list|,
literal|0
argument_list|,
name|scratchBytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|heapWriter
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|z
parameter_list|,
name|int
name|docID
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pointCount
operator|>=
name|maxPointsSortInHeap
condition|)
block|{
if|if
condition|(
name|writer
operator|==
literal|null
condition|)
block|{
name|switchToOffline
argument_list|()
expr_stmt|;
block|}
name|scratchBytesOutput
operator|.
name|reset
argument_list|(
name|scratchBytes
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeInt
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeInt
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeInt
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeVInt
argument_list|(
name|docID
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeVLong
argument_list|(
name|pointCount
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|scratchBytes
argument_list|,
literal|0
argument_list|,
name|scratchBytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Not too many points added yet, continue using heap:
name|heapWriter
operator|.
name|append
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|pointCount
argument_list|,
name|docID
argument_list|)
expr_stmt|;
block|}
name|pointCount
operator|++
expr_stmt|;
block|}
comment|/** Changes incoming {@link ByteSequencesWriter} file to to fixed-width-per-entry file, because we need to be able to slice    *  as we recurse in {@link #build}. */
DECL|method|convertToFixedWidth
specifier|private
name|Writer
name|convertToFixedWidth
parameter_list|(
name|Path
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|BytesRefBuilder
name|scratch
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|scratch
operator|.
name|grow
argument_list|(
name|BYTES_PER_DOC
argument_list|)
expr_stmt|;
name|BytesRef
name|bytes
init|=
name|scratch
operator|.
name|get
argument_list|()
decl_stmt|;
name|ByteArrayDataInput
name|dataReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
name|OfflineSorter
operator|.
name|ByteSequencesReader
name|reader
init|=
literal|null
decl_stmt|;
name|Writer
name|sortedWriter
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|reader
operator|=
operator|new
name|OfflineSorter
operator|.
name|ByteSequencesReader
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|sortedWriter
operator|=
name|getWriter
argument_list|(
name|pointCount
argument_list|)
expr_stmt|;
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|result
init|=
name|reader
operator|.
name|read
argument_list|(
name|scratch
argument_list|)
decl_stmt|;
assert|assert
name|result
assert|;
name|dataReader
operator|.
name|reset
argument_list|(
name|bytes
operator|.
name|bytes
argument_list|,
name|bytes
operator|.
name|offset
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|x
init|=
name|dataReader
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|int
name|y
init|=
name|dataReader
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|int
name|z
init|=
name|dataReader
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|int
name|docID
init|=
name|dataReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|long
name|ord
init|=
name|dataReader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
assert|assert
name|docID
operator|>=
literal|0
operator|:
literal|"docID="
operator|+
name|docID
assert|;
name|sortedWriter
operator|.
name|append
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|ord
argument_list|,
name|docID
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|sortedWriter
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|sortedWriter
argument_list|,
name|reader
argument_list|)
expr_stmt|;
try|try
block|{
name|sortedWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress to keep throwing original exc
block|}
block|}
block|}
return|return
name|sortedWriter
return|;
block|}
comment|/** dim: 0=x, 1=y, 2=z */
DECL|method|sort
specifier|private
name|Writer
name|sort
parameter_list|(
name|int
name|dim
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|heapWriter
operator|!=
literal|null
condition|)
block|{
assert|assert
name|pointCount
operator|<
name|Integer
operator|.
name|MAX_VALUE
assert|;
comment|// All buffered points are still in heap
operator|new
name|InPlaceMergeSorter
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|docID
init|=
name|heapWriter
operator|.
name|docIDs
index|[
name|i
index|]
decl_stmt|;
name|heapWriter
operator|.
name|docIDs
index|[
name|i
index|]
operator|=
name|heapWriter
operator|.
name|docIDs
index|[
name|j
index|]
expr_stmt|;
name|heapWriter
operator|.
name|docIDs
index|[
name|j
index|]
operator|=
name|docID
expr_stmt|;
name|long
name|ord
init|=
name|heapWriter
operator|.
name|ords
index|[
name|i
index|]
decl_stmt|;
name|heapWriter
operator|.
name|ords
index|[
name|i
index|]
operator|=
name|heapWriter
operator|.
name|ords
index|[
name|j
index|]
expr_stmt|;
name|heapWriter
operator|.
name|ords
index|[
name|j
index|]
operator|=
name|ord
expr_stmt|;
name|int
name|x
init|=
name|heapWriter
operator|.
name|xs
index|[
name|i
index|]
decl_stmt|;
name|heapWriter
operator|.
name|xs
index|[
name|i
index|]
operator|=
name|heapWriter
operator|.
name|xs
index|[
name|j
index|]
expr_stmt|;
name|heapWriter
operator|.
name|xs
index|[
name|j
index|]
operator|=
name|x
expr_stmt|;
name|int
name|y
init|=
name|heapWriter
operator|.
name|ys
index|[
name|i
index|]
decl_stmt|;
name|heapWriter
operator|.
name|ys
index|[
name|i
index|]
operator|=
name|heapWriter
operator|.
name|ys
index|[
name|j
index|]
expr_stmt|;
name|heapWriter
operator|.
name|ys
index|[
name|j
index|]
operator|=
name|y
expr_stmt|;
name|int
name|z
init|=
name|heapWriter
operator|.
name|zs
index|[
name|i
index|]
decl_stmt|;
name|heapWriter
operator|.
name|zs
index|[
name|i
index|]
operator|=
name|heapWriter
operator|.
name|zs
index|[
name|j
index|]
expr_stmt|;
name|heapWriter
operator|.
name|zs
index|[
name|j
index|]
operator|=
name|z
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|cmp
decl_stmt|;
if|if
condition|(
name|dim
operator|==
literal|0
condition|)
block|{
name|cmp
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|heapWriter
operator|.
name|xs
index|[
name|i
index|]
argument_list|,
name|heapWriter
operator|.
name|xs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dim
operator|==
literal|1
condition|)
block|{
name|cmp
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|heapWriter
operator|.
name|ys
index|[
name|i
index|]
argument_list|,
name|heapWriter
operator|.
name|ys
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmp
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|heapWriter
operator|.
name|zs
index|[
name|i
index|]
argument_list|,
name|heapWriter
operator|.
name|zs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
comment|// Tie-break
name|cmp
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|heapWriter
operator|.
name|docIDs
index|[
name|i
index|]
argument_list|,
name|heapWriter
operator|.
name|docIDs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
return|return
name|Long
operator|.
name|compare
argument_list|(
name|heapWriter
operator|.
name|ords
index|[
name|i
index|]
argument_list|,
name|heapWriter
operator|.
name|ords
index|[
name|j
index|]
argument_list|)
return|;
block|}
block|}
operator|.
name|sort
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|pointCount
argument_list|)
expr_stmt|;
name|HeapWriter
name|sorted
init|=
operator|new
name|HeapWriter
argument_list|(
operator|(
name|int
operator|)
name|pointCount
argument_list|)
decl_stmt|;
comment|//System.out.println("sorted dim=" + dim);
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
name|i
operator|++
control|)
block|{
comment|/*         System.out.println("  docID=" + heapWriter.docIDs[i] +                             " x=" + heapWriter.xs[i] +                            " y=" + heapWriter.ys[i] +                            " z=" + heapWriter.zs[i]);         */
name|sorted
operator|.
name|append
argument_list|(
name|heapWriter
operator|.
name|xs
index|[
name|i
index|]
argument_list|,
name|heapWriter
operator|.
name|ys
index|[
name|i
index|]
argument_list|,
name|heapWriter
operator|.
name|zs
index|[
name|i
index|]
argument_list|,
name|heapWriter
operator|.
name|ords
index|[
name|i
index|]
argument_list|,
name|heapWriter
operator|.
name|docIDs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sorted
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|sorted
return|;
block|}
else|else
block|{
comment|// Offline sort:
assert|assert
name|tempInput
operator|!=
literal|null
assert|;
specifier|final
name|ByteArrayDataInput
name|reader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|cmp
init|=
operator|new
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
argument_list|()
block|{
specifier|private
specifier|final
name|ByteArrayDataInput
name|readerB
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|BytesRef
name|a
parameter_list|,
name|BytesRef
name|b
parameter_list|)
block|{
name|reader
operator|.
name|reset
argument_list|(
name|a
operator|.
name|bytes
argument_list|,
name|a
operator|.
name|offset
argument_list|,
name|a
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|int
name|xa
init|=
name|reader
operator|.
name|readInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|ya
init|=
name|reader
operator|.
name|readInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|za
init|=
name|reader
operator|.
name|readInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|docIDA
init|=
name|reader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
specifier|final
name|long
name|ordA
init|=
name|reader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
name|reader
operator|.
name|reset
argument_list|(
name|b
operator|.
name|bytes
argument_list|,
name|b
operator|.
name|offset
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|int
name|xb
init|=
name|reader
operator|.
name|readInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|yb
init|=
name|reader
operator|.
name|readInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|zb
init|=
name|reader
operator|.
name|readInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|docIDB
init|=
name|reader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
specifier|final
name|long
name|ordB
init|=
name|reader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
name|int
name|cmp
decl_stmt|;
if|if
condition|(
name|dim
operator|==
literal|0
condition|)
block|{
name|cmp
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|xa
argument_list|,
name|xb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dim
operator|==
literal|1
condition|)
block|{
name|cmp
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|ya
argument_list|,
name|yb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmp
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|za
argument_list|,
name|zb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
comment|// Tie-break
name|cmp
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|docIDA
argument_list|,
name|docIDB
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
return|return
name|Long
operator|.
name|compare
argument_list|(
name|ordA
argument_list|,
name|ordB
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|Path
name|sorted
init|=
name|Files
operator|.
name|createTempFile
argument_list|(
name|OfflineSorter
operator|.
name|getDefaultTempDir
argument_list|()
argument_list|,
literal|"sorted"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|OfflineSorter
name|sorter
init|=
operator|new
name|OfflineSorter
argument_list|(
name|cmp
argument_list|)
decl_stmt|;
name|sorter
operator|.
name|sort
argument_list|(
name|tempInput
argument_list|,
name|sorted
argument_list|)
expr_stmt|;
name|Writer
name|writer
init|=
name|convertToFixedWidth
argument_list|(
name|sorted
argument_list|)
decl_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|writer
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|rm
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|deleteFilesIgnoringExceptions
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Writes the BKD tree to the provided {@link IndexOutput} and returns the file offset where index was written. */
DECL|method|finish
specifier|public
name|long
name|finish
parameter_list|(
name|IndexOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("\nBKDTreeWriter.finish pointCount=" + pointCount + " out=" + out + " heapWriter=" + heapWriter + " maxPointsInLeafNode=" + maxPointsInLeafNode);
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|LongBitSet
name|bitSet
init|=
operator|new
name|LongBitSet
argument_list|(
name|pointCount
argument_list|)
decl_stmt|;
name|long
name|countPerLeaf
init|=
name|pointCount
decl_stmt|;
name|long
name|innerNodeCount
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|countPerLeaf
operator|>
name|maxPointsInLeafNode
condition|)
block|{
name|countPerLeaf
operator|=
operator|(
name|countPerLeaf
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|innerNodeCount
operator|*=
literal|2
expr_stmt|;
block|}
comment|//System.out.println("innerNodeCount=" + innerNodeCount + " countPerLeaf=" + countPerLeaf);
if|if
condition|(
literal|1
operator|+
literal|2
operator|*
name|innerNodeCount
operator|>=
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"too many nodes; increase maxPointsInLeafNode (currently "
operator|+
name|maxPointsInLeafNode
operator|+
literal|") and reindex"
argument_list|)
throw|;
block|}
name|innerNodeCount
operator|--
expr_stmt|;
name|int
name|numLeaves
init|=
call|(
name|int
call|)
argument_list|(
name|innerNodeCount
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|//System.out.println("  numLeaves=" + numLeaves);
comment|// Indexed by nodeID, but first (root) nodeID is 1
name|int
index|[]
name|splitValues
init|=
operator|new
name|int
index|[
name|numLeaves
index|]
decl_stmt|;
comment|// +1 because leaf count is power of 2 (e.g. 8), and innerNodeCount is power of 2 minus 1 (e.g. 7)
name|long
index|[]
name|leafBlockFPs
init|=
operator|new
name|long
index|[
name|numLeaves
index|]
decl_stmt|;
comment|// Make sure the math above "worked":
assert|assert
name|pointCount
operator|/
name|splitValues
operator|.
name|length
operator|<=
name|maxPointsInLeafNode
operator|:
literal|"pointCount="
operator|+
name|pointCount
operator|+
literal|" splitValues.length="
operator|+
name|splitValues
operator|.
name|length
operator|+
literal|" maxPointsInLeafNode="
operator|+
name|maxPointsInLeafNode
assert|;
comment|//System.out.println("  avg pointsPerLeaf=" + (pointCount/splitValues.length));
comment|// Sort all docs once by x, once by y, once by z:
name|Writer
name|xSortedWriter
init|=
literal|null
decl_stmt|;
name|Writer
name|ySortedWriter
init|=
literal|null
decl_stmt|;
name|Writer
name|zSortedWriter
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|xSortedWriter
operator|=
name|sort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ySortedWriter
operator|=
name|sort
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|zSortedWriter
operator|=
name|sort
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|heapWriter
operator|=
literal|null
expr_stmt|;
name|build
argument_list|(
literal|1
argument_list|,
name|numLeaves
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|xSortedWriter
argument_list|,
literal|0
argument_list|,
name|pointCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|ySortedWriter
argument_list|,
literal|0
argument_list|,
name|pointCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|zSortedWriter
argument_list|,
literal|0
argument_list|,
name|pointCount
argument_list|)
argument_list|,
name|bitSet
argument_list|,
name|out
argument_list|,
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|splitValues
argument_list|,
name|leafBlockFPs
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|xSortedWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|ySortedWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|zSortedWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|IOUtils
operator|.
name|rm
argument_list|(
name|tempInput
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|xSortedWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress to keep throwing original exc
block|}
try|try
block|{
name|ySortedWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress to keep throwing original exc
block|}
try|try
block|{
name|zSortedWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress to keep throwing original exc
block|}
name|IOUtils
operator|.
name|deleteFilesIgnoringExceptions
argument_list|(
name|tempInput
argument_list|)
expr_stmt|;
block|}
block|}
comment|//System.out.println("Total nodes: " + innerNodeCount);
comment|// Write index:
name|long
name|indexFP
init|=
name|out
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
comment|//System.out.println("indexFP=" + indexFP);
name|out
operator|.
name|writeVInt
argument_list|(
name|numLeaves
argument_list|)
expr_stmt|;
comment|// NOTE: splitValues[0] is unused, because nodeID is 1-based:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|splitValues
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|splitValues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leafBlockFPs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|writeVLong
argument_list|(
name|leafBlockFPs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|indexFP
return|;
block|}
comment|/** Sliced reference to points in an OfflineSorter.ByteSequencesWriter file. */
DECL|class|PathSlice
specifier|private
specifier|static
specifier|final
class|class
name|PathSlice
block|{
DECL|field|writer
specifier|final
name|Writer
name|writer
decl_stmt|;
DECL|field|start
specifier|final
name|long
name|start
decl_stmt|;
DECL|field|count
specifier|final
name|long
name|count
decl_stmt|;
DECL|method|PathSlice
specifier|public
name|PathSlice
parameter_list|(
name|Writer
name|writer
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|count
parameter_list|)
block|{
name|this
operator|.
name|writer
operator|=
name|writer
expr_stmt|;
name|this
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"PathSlice(start="
operator|+
name|start
operator|+
literal|" count="
operator|+
name|count
operator|+
literal|" writer="
operator|+
name|writer
operator|+
literal|")"
return|;
block|}
block|}
comment|/** Marks bits for the ords (points) that belong in the left sub tree. */
DECL|method|markLeftTree
specifier|private
name|int
name|markLeftTree
parameter_list|(
name|int
name|splitDim
parameter_list|,
name|PathSlice
name|source
parameter_list|,
name|LongBitSet
name|bitSet
parameter_list|,
name|int
name|minX
parameter_list|,
name|int
name|maxX
parameter_list|,
name|int
name|minY
parameter_list|,
name|int
name|maxY
parameter_list|,
name|int
name|minZ
parameter_list|,
name|int
name|maxZ
parameter_list|)
throws|throws
name|IOException
block|{
comment|// This is the size of our left tree
name|long
name|leftCount
init|=
name|source
operator|.
name|count
operator|/
literal|2
decl_stmt|;
comment|// Read the split value:
comment|//if (DEBUG) System.out.println("  leftCount=" + leftCount + " vs " + source.count);
name|Reader
name|reader
init|=
name|source
operator|.
name|writer
operator|.
name|getReader
argument_list|(
name|source
operator|.
name|start
operator|+
name|leftCount
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|int
name|splitValue
decl_stmt|;
try|try
block|{
name|boolean
name|result
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
assert|assert
name|result
assert|;
name|int
name|x
init|=
name|reader
operator|.
name|x
argument_list|()
decl_stmt|;
assert|assert
name|x
operator|>=
name|minX
operator|&&
name|x
operator|<=
name|maxX
operator|:
literal|"x="
operator|+
name|x
operator|+
literal|" minX="
operator|+
name|minX
operator|+
literal|" maxX="
operator|+
name|maxX
assert|;
name|int
name|y
init|=
name|reader
operator|.
name|y
argument_list|()
decl_stmt|;
assert|assert
name|y
operator|>=
name|minY
operator|&&
name|y
operator|<=
name|maxY
operator|:
literal|"y="
operator|+
name|y
operator|+
literal|" minY="
operator|+
name|minY
operator|+
literal|" maxY="
operator|+
name|maxY
assert|;
name|int
name|z
init|=
name|reader
operator|.
name|z
argument_list|()
decl_stmt|;
assert|assert
name|z
operator|>=
name|minZ
operator|&&
name|z
operator|<=
name|maxZ
operator|:
literal|"z="
operator|+
name|z
operator|+
literal|" minZ="
operator|+
name|minZ
operator|+
literal|" maxZ="
operator|+
name|maxZ
assert|;
if|if
condition|(
name|splitDim
operator|==
literal|0
condition|)
block|{
name|splitValue
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|splitDim
operator|==
literal|1
condition|)
block|{
name|splitValue
operator|=
name|y
expr_stmt|;
block|}
else|else
block|{
name|splitValue
operator|=
name|z
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Mark ords that fall into the left half, and also handle the == boundary case:
assert|assert
name|bitSet
operator|.
name|cardinality
argument_list|()
operator|==
literal|0
operator|:
literal|"cardinality="
operator|+
name|bitSet
operator|.
name|cardinality
argument_list|()
assert|;
name|success
operator|=
literal|false
expr_stmt|;
name|reader
operator|=
name|source
operator|.
name|writer
operator|.
name|getReader
argument_list|(
name|source
operator|.
name|start
argument_list|)
expr_stmt|;
try|try
block|{
name|int
name|lastValue
init|=
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftCount
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|result
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
assert|assert
name|result
assert|;
name|int
name|x
init|=
name|reader
operator|.
name|x
argument_list|()
decl_stmt|;
name|int
name|y
init|=
name|reader
operator|.
name|y
argument_list|()
decl_stmt|;
name|int
name|z
init|=
name|reader
operator|.
name|z
argument_list|()
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
name|splitDim
operator|==
literal|0
condition|)
block|{
name|value
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|splitDim
operator|==
literal|1
condition|)
block|{
name|value
operator|=
name|y
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|z
expr_stmt|;
block|}
comment|// Our input source is supposed to be sorted on the incoming dimension:
assert|assert
name|value
operator|>=
name|lastValue
assert|;
name|lastValue
operator|=
name|value
expr_stmt|;
assert|assert
name|value
operator|<=
name|splitValue
operator|:
literal|"i="
operator|+
name|i
operator|+
literal|" value="
operator|+
name|value
operator|+
literal|" vs splitValue="
operator|+
name|splitValue
assert|;
name|long
name|ord
init|=
name|reader
operator|.
name|ord
argument_list|()
decl_stmt|;
name|int
name|docID
init|=
name|reader
operator|.
name|docID
argument_list|()
decl_stmt|;
assert|assert
name|docID
operator|>=
literal|0
operator|:
literal|"docID="
operator|+
name|docID
operator|+
literal|" reader="
operator|+
name|reader
assert|;
comment|// We should never see dup ords:
assert|assert
name|bitSet
operator|.
name|get
argument_list|(
name|ord
argument_list|)
operator|==
literal|false
assert|;
name|bitSet
operator|.
name|set
argument_list|(
name|ord
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|leftCount
operator|==
name|bitSet
operator|.
name|cardinality
argument_list|()
operator|:
literal|"leftCount="
operator|+
name|leftCount
operator|+
literal|" cardinality="
operator|+
name|bitSet
operator|.
name|cardinality
argument_list|()
assert|;
return|return
name|splitValue
return|;
block|}
comment|// Split on the dim with the largest range:
DECL|method|getSplitDim
specifier|static
name|int
name|getSplitDim
parameter_list|(
name|int
name|minX
parameter_list|,
name|int
name|maxX
parameter_list|,
name|int
name|minY
parameter_list|,
name|int
name|maxY
parameter_list|,
name|int
name|minZ
parameter_list|,
name|int
name|maxZ
parameter_list|)
block|{
name|long
name|xRange
init|=
operator|(
name|long
operator|)
name|maxX
operator|-
operator|(
name|long
operator|)
name|minX
decl_stmt|;
name|long
name|yRange
init|=
operator|(
name|long
operator|)
name|maxY
operator|-
operator|(
name|long
operator|)
name|minY
decl_stmt|;
name|long
name|zRange
init|=
operator|(
name|long
operator|)
name|maxZ
operator|-
operator|(
name|long
operator|)
name|minZ
decl_stmt|;
if|if
condition|(
name|xRange
operator|>
name|yRange
condition|)
block|{
if|if
condition|(
name|xRange
operator|>
name|zRange
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
literal|2
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|yRange
operator|>
name|zRange
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|2
return|;
block|}
block|}
comment|/** The incoming PathSlice for the dim we will split is already partitioned/sorted. */
DECL|method|build
specifier|private
name|void
name|build
parameter_list|(
name|int
name|nodeID
parameter_list|,
name|int
name|leafNodeOffset
parameter_list|,
name|PathSlice
name|lastXSorted
parameter_list|,
name|PathSlice
name|lastYSorted
parameter_list|,
name|PathSlice
name|lastZSorted
parameter_list|,
name|LongBitSet
name|bitSet
parameter_list|,
name|IndexOutput
name|out
parameter_list|,
name|int
name|minX
parameter_list|,
name|int
name|maxX
parameter_list|,
name|int
name|minY
parameter_list|,
name|int
name|maxY
parameter_list|,
name|int
name|minZ
parameter_list|,
name|int
name|maxZ
parameter_list|,
name|int
index|[]
name|splitValues
parameter_list|,
name|long
index|[]
name|leafBlockFPs
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|count
init|=
name|lastXSorted
operator|.
name|count
decl_stmt|;
assert|assert
name|count
operator|>
literal|0
assert|;
assert|assert
name|count
operator|<=
name|ArrayUtil
operator|.
name|MAX_ARRAY_LENGTH
assert|;
assert|assert
name|count
operator|==
name|lastYSorted
operator|.
name|count
assert|;
assert|assert
name|count
operator|==
name|lastZSorted
operator|.
name|count
assert|;
comment|//if (DEBUG) System.out.println("\nBUILD: nodeID=" + nodeID + " leafNodeOffset=" + leafNodeOffset + "\n  lastXSorted=" + lastXSorted + "\n  lastYSorted=" + lastYSorted + "\n  lastZSorted=" + lastZSorted + "\n  count=" + lastXSorted.count + " x=" + minX + " TO " + maxX + " y=" + minY + " TO " + maxY + " z=" + minZ + " TO " + maxZ);
if|if
condition|(
name|nodeID
operator|>=
name|leafNodeOffset
condition|)
block|{
comment|// Leaf node: write block
comment|//if (DEBUG) System.out.println("  leaf");
assert|assert
name|maxX
operator|>=
name|minX
assert|;
assert|assert
name|maxY
operator|>=
name|minY
assert|;
assert|assert
name|maxZ
operator|>=
name|minZ
assert|;
comment|//System.out.println("\nleaf:\n  lat range: " + ((long) maxLatEnc-minLatEnc));
comment|//System.out.println("  lon range: " + ((long) maxLonEnc-minLonEnc));
comment|// Sort by docID in the leaf so we get sequentiality at search time (may not matter?):
name|Reader
name|reader
init|=
name|lastXSorted
operator|.
name|writer
operator|.
name|getReader
argument_list|(
name|lastXSorted
operator|.
name|start
argument_list|)
decl_stmt|;
assert|assert
name|count
operator|<=
name|scratchDocIDs
operator|.
name|length
operator|:
literal|"count="
operator|+
name|count
operator|+
literal|" scratchDocIDs.length="
operator|+
name|scratchDocIDs
operator|.
name|length
assert|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|// NOTE: we discard ord at this point; we only needed it temporarily
comment|// during building to uniquely identify each point to properly handle
comment|// the multi-valued case (one docID having multiple values):
comment|// We also discard lat/lon, since at search time, we reside on the
comment|// wrapped doc values for this:
name|boolean
name|result
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
assert|assert
name|result
assert|;
name|scratchDocIDs
index|[
name|i
index|]
operator|=
name|reader
operator|.
name|docID
argument_list|()
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|scratchDocIDs
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|)
expr_stmt|;
comment|// Dedup docIDs: for the multi-valued case where more than one value for the doc
comment|// wound up in this leaf cell, we only need to store the docID once:
name|int
name|lastDocID
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|uniqueCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|docID
init|=
name|scratchDocIDs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|docID
operator|!=
name|lastDocID
condition|)
block|{
name|uniqueCount
operator|++
expr_stmt|;
name|lastDocID
operator|=
name|docID
expr_stmt|;
block|}
block|}
assert|assert
name|uniqueCount
operator|<=
name|count
assert|;
name|long
name|startFP
init|=
name|out
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|uniqueCount
argument_list|)
expr_stmt|;
comment|// Save the block file pointer:
name|leafBlockFPs
index|[
name|nodeID
operator|-
name|leafNodeOffset
index|]
operator|=
name|startFP
expr_stmt|;
comment|//System.out.println("    leafFP=" + startFP);
name|lastDocID
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|// Absolute int encode; with "vInt of deltas" encoding, the .kdd size dropped from
comment|// 697 MB -> 539 MB, but query time for 225 queries went from 1.65 sec -> 2.64 sec.
comment|// I think if we also indexed prefix terms here we could do less costly compression
comment|// on those lists:
name|int
name|docID
init|=
name|scratchDocIDs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|docID
operator|!=
name|lastDocID
condition|)
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|docID
argument_list|)
expr_stmt|;
comment|//System.out.println("  write docID=" + docID);
name|lastDocID
operator|=
name|docID
expr_stmt|;
block|}
block|}
comment|//long endFP = out.getFilePointer();
comment|//System.out.println("  bytes/doc: " + ((endFP - startFP) / count));
block|}
else|else
block|{
name|int
name|splitDim
init|=
name|getSplitDim
argument_list|(
name|minX
argument_list|,
name|maxX
argument_list|,
name|minY
argument_list|,
name|maxY
argument_list|,
name|minZ
argument_list|,
name|maxZ
argument_list|)
decl_stmt|;
comment|//System.out.println("  splitDim=" + splitDim);
name|PathSlice
name|source
decl_stmt|;
if|if
condition|(
name|splitDim
operator|==
literal|0
condition|)
block|{
name|source
operator|=
name|lastXSorted
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|splitDim
operator|==
literal|1
condition|)
block|{
name|source
operator|=
name|lastYSorted
expr_stmt|;
block|}
else|else
block|{
name|source
operator|=
name|lastZSorted
expr_stmt|;
block|}
comment|// We let ties go to either side, so we should never get down to count == 0, even
comment|// in adversarial case (all values are the same):
assert|assert
name|count
operator|>
literal|0
assert|;
comment|// Inner node: partition/recurse
comment|//if (DEBUG) System.out.println("  non-leaf");
assert|assert
name|nodeID
operator|<
name|splitValues
operator|.
name|length
operator|:
literal|"nodeID="
operator|+
name|nodeID
operator|+
literal|" splitValues.length="
operator|+
name|splitValues
operator|.
name|length
assert|;
name|int
name|splitValue
init|=
name|markLeftTree
argument_list|(
name|splitDim
argument_list|,
name|source
argument_list|,
name|bitSet
argument_list|,
name|minX
argument_list|,
name|maxX
argument_list|,
name|minY
argument_list|,
name|maxY
argument_list|,
name|minZ
argument_list|,
name|maxZ
argument_list|)
decl_stmt|;
name|long
name|leftCount
init|=
name|count
operator|/
literal|2
decl_stmt|;
comment|// TODO: we could save split value in here so we don't have to re-open file later:
comment|// Partition the other (not split) dims into sorted left and right sets, so we can recurse.
comment|// This is somewhat hairy: we partition the next X, Y set according to how we had just
comment|// partitioned the Z set, etc.
name|Writer
index|[]
name|leftWriters
init|=
operator|new
name|Writer
index|[
literal|3
index|]
decl_stmt|;
name|Writer
index|[]
name|rightWriters
init|=
operator|new
name|Writer
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|int
name|dim
init|=
literal|0
init|;
name|dim
operator|<
literal|3
condition|;
name|dim
operator|++
control|)
block|{
if|if
condition|(
name|dim
operator|==
name|splitDim
condition|)
block|{
continue|continue;
block|}
name|Writer
name|leftWriter
init|=
literal|null
decl_stmt|;
name|Writer
name|rightWriter
init|=
literal|null
decl_stmt|;
name|Reader
name|reader
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|int
name|nextLeftCount
init|=
literal|0
decl_stmt|;
name|PathSlice
name|nextSource
decl_stmt|;
if|if
condition|(
name|dim
operator|==
literal|0
condition|)
block|{
name|nextSource
operator|=
name|lastXSorted
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dim
operator|==
literal|1
condition|)
block|{
name|nextSource
operator|=
name|lastYSorted
expr_stmt|;
block|}
else|else
block|{
name|nextSource
operator|=
name|lastZSorted
expr_stmt|;
block|}
try|try
block|{
name|leftWriter
operator|=
name|getWriter
argument_list|(
name|leftCount
argument_list|)
expr_stmt|;
name|rightWriter
operator|=
name|getWriter
argument_list|(
name|nextSource
operator|.
name|count
operator|-
name|leftCount
argument_list|)
expr_stmt|;
assert|assert
name|nextSource
operator|.
name|count
operator|==
name|count
assert|;
name|reader
operator|=
name|nextSource
operator|.
name|writer
operator|.
name|getReader
argument_list|(
name|nextSource
operator|.
name|start
argument_list|)
expr_stmt|;
comment|// TODO: we could compute the split value here for each sub-tree and save an O(N) pass on recursion, but makes code hairier and only
comment|// changes the constant factor of building, not the big-oh:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|result
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
assert|assert
name|result
assert|;
name|int
name|x
init|=
name|reader
operator|.
name|x
argument_list|()
decl_stmt|;
name|int
name|y
init|=
name|reader
operator|.
name|y
argument_list|()
decl_stmt|;
name|int
name|z
init|=
name|reader
operator|.
name|z
argument_list|()
decl_stmt|;
name|long
name|ord
init|=
name|reader
operator|.
name|ord
argument_list|()
decl_stmt|;
name|int
name|docID
init|=
name|reader
operator|.
name|docID
argument_list|()
decl_stmt|;
assert|assert
name|docID
operator|>=
literal|0
operator|:
literal|"docID="
operator|+
name|docID
operator|+
literal|" reader="
operator|+
name|reader
assert|;
comment|//System.out.println("  i=" + i + " x=" + x + " ord=" + ord + " docID=" + docID);
if|if
condition|(
name|bitSet
operator|.
name|get
argument_list|(
name|ord
argument_list|)
condition|)
block|{
if|if
condition|(
name|splitDim
operator|==
literal|0
condition|)
block|{
assert|assert
name|x
operator|<=
name|splitValue
operator|:
literal|"x="
operator|+
name|x
operator|+
literal|" splitValue="
operator|+
name|splitValue
assert|;
block|}
elseif|else
if|if
condition|(
name|splitDim
operator|==
literal|1
condition|)
block|{
assert|assert
name|y
operator|<=
name|splitValue
operator|:
literal|"y="
operator|+
name|y
operator|+
literal|" splitValue="
operator|+
name|splitValue
assert|;
block|}
else|else
block|{
assert|assert
name|z
operator|<=
name|splitValue
operator|:
literal|"z="
operator|+
name|z
operator|+
literal|" splitValue="
operator|+
name|splitValue
assert|;
block|}
name|leftWriter
operator|.
name|append
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|ord
argument_list|,
name|docID
argument_list|)
expr_stmt|;
name|nextLeftCount
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|splitDim
operator|==
literal|0
condition|)
block|{
assert|assert
name|x
operator|>=
name|splitValue
operator|:
literal|"x="
operator|+
name|x
operator|+
literal|" splitValue="
operator|+
name|splitValue
assert|;
block|}
elseif|else
if|if
condition|(
name|splitDim
operator|==
literal|1
condition|)
block|{
assert|assert
name|y
operator|>=
name|splitValue
operator|:
literal|"y="
operator|+
name|y
operator|+
literal|" splitValue="
operator|+
name|splitValue
assert|;
block|}
else|else
block|{
assert|assert
name|z
operator|>=
name|splitValue
operator|:
literal|"z="
operator|+
name|z
operator|+
literal|" splitValue="
operator|+
name|splitValue
assert|;
block|}
name|rightWriter
operator|.
name|append
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|ord
argument_list|,
name|docID
argument_list|)
expr_stmt|;
block|}
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|reader
argument_list|,
name|leftWriter
argument_list|,
name|rightWriter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|reader
argument_list|,
name|leftWriter
argument_list|,
name|rightWriter
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|leftCount
operator|==
name|nextLeftCount
operator|:
literal|"leftCount="
operator|+
name|leftCount
operator|+
literal|" nextLeftCount="
operator|+
name|nextLeftCount
assert|;
name|leftWriters
index|[
name|dim
index|]
operator|=
name|leftWriter
expr_stmt|;
name|rightWriters
index|[
name|dim
index|]
operator|=
name|rightWriter
expr_stmt|;
block|}
name|bitSet
operator|.
name|clear
argument_list|(
literal|0
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
name|long
name|rightCount
init|=
name|count
operator|-
name|leftCount
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|splitDim
operator|==
literal|0
condition|)
block|{
name|build
argument_list|(
literal|2
operator|*
name|nodeID
argument_list|,
name|leafNodeOffset
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|source
operator|.
name|writer
argument_list|,
name|source
operator|.
name|start
argument_list|,
name|leftCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|leftWriters
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|leftCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|leftWriters
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|leftCount
argument_list|)
argument_list|,
name|bitSet
argument_list|,
name|out
argument_list|,
name|minX
argument_list|,
name|splitValue
argument_list|,
name|minY
argument_list|,
name|maxY
argument_list|,
name|minZ
argument_list|,
name|maxZ
argument_list|,
name|splitValues
argument_list|,
name|leafBlockFPs
argument_list|)
expr_stmt|;
name|leftWriters
index|[
literal|1
index|]
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|leftWriters
index|[
literal|2
index|]
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|build
argument_list|(
literal|2
operator|*
name|nodeID
operator|+
literal|1
argument_list|,
name|leafNodeOffset
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|source
operator|.
name|writer
argument_list|,
name|source
operator|.
name|start
operator|+
name|leftCount
argument_list|,
name|rightCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|rightWriters
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|rightCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|rightWriters
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|rightCount
argument_list|)
argument_list|,
name|bitSet
argument_list|,
name|out
argument_list|,
name|splitValue
argument_list|,
name|maxX
argument_list|,
name|minY
argument_list|,
name|maxY
argument_list|,
name|minZ
argument_list|,
name|maxZ
argument_list|,
name|splitValues
argument_list|,
name|leafBlockFPs
argument_list|)
expr_stmt|;
name|rightWriters
index|[
literal|1
index|]
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|rightWriters
index|[
literal|2
index|]
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|splitDim
operator|==
literal|1
condition|)
block|{
name|build
argument_list|(
literal|2
operator|*
name|nodeID
argument_list|,
name|leafNodeOffset
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|leftWriters
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|leftCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|source
operator|.
name|writer
argument_list|,
name|source
operator|.
name|start
argument_list|,
name|leftCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|leftWriters
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|leftCount
argument_list|)
argument_list|,
name|bitSet
argument_list|,
name|out
argument_list|,
name|minX
argument_list|,
name|maxX
argument_list|,
name|minY
argument_list|,
name|splitValue
argument_list|,
name|minZ
argument_list|,
name|maxZ
argument_list|,
name|splitValues
argument_list|,
name|leafBlockFPs
argument_list|)
expr_stmt|;
name|leftWriters
index|[
literal|0
index|]
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|leftWriters
index|[
literal|2
index|]
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|build
argument_list|(
literal|2
operator|*
name|nodeID
operator|+
literal|1
argument_list|,
name|leafNodeOffset
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|rightWriters
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|rightCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|source
operator|.
name|writer
argument_list|,
name|source
operator|.
name|start
operator|+
name|leftCount
argument_list|,
name|rightCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|rightWriters
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|rightCount
argument_list|)
argument_list|,
name|bitSet
argument_list|,
name|out
argument_list|,
name|minX
argument_list|,
name|maxX
argument_list|,
name|splitValue
argument_list|,
name|maxY
argument_list|,
name|minZ
argument_list|,
name|maxZ
argument_list|,
name|splitValues
argument_list|,
name|leafBlockFPs
argument_list|)
expr_stmt|;
name|rightWriters
index|[
literal|0
index|]
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|rightWriters
index|[
literal|2
index|]
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|build
argument_list|(
literal|2
operator|*
name|nodeID
argument_list|,
name|leafNodeOffset
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|leftWriters
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|leftCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|leftWriters
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|leftCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|source
operator|.
name|writer
argument_list|,
name|source
operator|.
name|start
argument_list|,
name|leftCount
argument_list|)
argument_list|,
name|bitSet
argument_list|,
name|out
argument_list|,
name|minX
argument_list|,
name|maxX
argument_list|,
name|minY
argument_list|,
name|maxY
argument_list|,
name|minZ
argument_list|,
name|splitValue
argument_list|,
name|splitValues
argument_list|,
name|leafBlockFPs
argument_list|)
expr_stmt|;
name|leftWriters
index|[
literal|0
index|]
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|leftWriters
index|[
literal|1
index|]
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|build
argument_list|(
literal|2
operator|*
name|nodeID
operator|+
literal|1
argument_list|,
name|leafNodeOffset
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|rightWriters
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|rightCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|rightWriters
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|rightCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|source
operator|.
name|writer
argument_list|,
name|source
operator|.
name|start
operator|+
name|leftCount
argument_list|,
name|rightCount
argument_list|)
argument_list|,
name|bitSet
argument_list|,
name|out
argument_list|,
name|minX
argument_list|,
name|maxX
argument_list|,
name|minY
argument_list|,
name|maxY
argument_list|,
name|splitValue
argument_list|,
name|maxZ
argument_list|,
name|splitValues
argument_list|,
name|leafBlockFPs
argument_list|)
expr_stmt|;
name|rightWriters
index|[
literal|0
index|]
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|rightWriters
index|[
literal|1
index|]
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
for|for
control|(
name|Writer
name|writer
range|:
name|leftWriters
control|)
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|writer
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress to keep throwing original exc
block|}
block|}
block|}
for|for
control|(
name|Writer
name|writer
range|:
name|rightWriters
control|)
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|writer
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress to keep throwing original exc
block|}
block|}
block|}
block|}
block|}
name|splitValues
index|[
name|nodeID
index|]
operator|=
name|splitValue
expr_stmt|;
block|}
block|}
DECL|method|getWriter
name|Writer
name|getWriter
parameter_list|(
name|long
name|count
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|count
operator|<
name|maxPointsSortInHeap
condition|)
block|{
return|return
operator|new
name|HeapWriter
argument_list|(
operator|(
name|int
operator|)
name|count
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|OfflineWriter
argument_list|(
name|count
argument_list|)
return|;
block|}
block|}
block|}
end_class
end_unit
