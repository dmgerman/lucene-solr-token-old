begin_unit
begin_package
DECL|package|org.apache.lucene.document
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
package|;
end_package
begin_comment
comment|/**  * Copyright 2004 The Apache Software Foundation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|NumericField
operator|.
name|DataType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldReaderException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexableField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StoredFieldVisitor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_comment
comment|/** Create this, passing a legacy {@link FieldSelector} to it, then  *  pass this class to {@link IndexReader#document(int,  *  StoredFieldVisitor)}, then call {@link #getDocument} to  *  retrieve the loaded document.   *<p><b>NOTE</b>:  If you use Lazy fields, you should not  *  access the returned document after the reader has been  *  closed!  */
end_comment
begin_class
DECL|class|FieldSelectorVisitor
specifier|public
class|class
name|FieldSelectorVisitor
extends|extends
name|StoredFieldVisitor
block|{
DECL|field|selector
specifier|private
specifier|final
name|FieldSelector
name|selector
decl_stmt|;
DECL|field|doc
specifier|private
specifier|final
name|Document
name|doc
decl_stmt|;
DECL|method|FieldSelectorVisitor
specifier|public
name|FieldSelectorVisitor
parameter_list|(
name|FieldSelector
name|selector
parameter_list|)
block|{
name|this
operator|.
name|selector
operator|=
name|selector
expr_stmt|;
name|doc
operator|=
operator|new
name|Document
argument_list|()
expr_stmt|;
block|}
DECL|method|getDocument
specifier|public
name|Document
name|getDocument
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
annotation|@
name|Override
DECL|method|binaryField
specifier|public
name|boolean
name|binaryField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|IndexInput
name|in
parameter_list|,
name|int
name|numBytes
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FieldSelectorResult
name|accept
init|=
name|selector
operator|.
name|accept
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|accept
condition|)
block|{
case|case
name|LOAD
case|:
case|case
name|LOAD_AND_BREAK
case|:
specifier|final
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|numBytes
index|]
decl_stmt|;
name|in
operator|.
name|readBytes
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|BinaryField
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|accept
operator|!=
name|FieldSelectorResult
operator|.
name|LOAD
return|;
case|case
name|LAZY_LOAD
case|:
case|case
name|LATENT
case|:
name|addFieldLazy
argument_list|(
name|in
argument_list|,
name|fieldInfo
argument_list|,
literal|true
argument_list|,
name|accept
operator|==
name|FieldSelectorResult
operator|.
name|LAZY_LOAD
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
case|case
name|SIZE
case|:
case|case
name|SIZE_AND_BREAK
case|:
name|in
operator|.
name|seek
argument_list|(
name|in
operator|.
name|getFilePointer
argument_list|()
operator|+
name|numBytes
argument_list|)
expr_stmt|;
name|addFieldSize
argument_list|(
name|fieldInfo
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
return|return
name|accept
operator|!=
name|FieldSelectorResult
operator|.
name|SIZE
return|;
default|default:
comment|// skip
name|in
operator|.
name|seek
argument_list|(
name|in
operator|.
name|getFilePointer
argument_list|()
operator|+
name|numBytes
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|stringField
specifier|public
name|boolean
name|stringField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|IndexInput
name|in
parameter_list|,
name|int
name|numUTF8Bytes
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FieldSelectorResult
name|accept
init|=
name|selector
operator|.
name|accept
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|accept
condition|)
block|{
case|case
name|LOAD
case|:
case|case
name|LOAD_AND_BREAK
case|:
specifier|final
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|numUTF8Bytes
index|]
decl_stmt|;
name|in
operator|.
name|readBytes
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
name|FieldType
name|ft
init|=
operator|new
name|FieldType
argument_list|(
name|TextField
operator|.
name|TYPE_STORED
argument_list|)
decl_stmt|;
name|ft
operator|.
name|setStoreTermVectors
argument_list|(
name|fieldInfo
operator|.
name|storeTermVector
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setStoreTermVectorOffsets
argument_list|(
name|fieldInfo
operator|.
name|storeOffsetWithTermVector
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setStoreTermVectorPositions
argument_list|(
name|fieldInfo
operator|.
name|storePositionWithTermVector
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|ft
argument_list|,
operator|new
name|String
argument_list|(
name|b
argument_list|,
literal|"UTF-8"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|accept
operator|!=
name|FieldSelectorResult
operator|.
name|LOAD
return|;
case|case
name|LAZY_LOAD
case|:
case|case
name|LATENT
case|:
name|addFieldLazy
argument_list|(
name|in
argument_list|,
name|fieldInfo
argument_list|,
literal|false
argument_list|,
name|accept
operator|==
name|FieldSelectorResult
operator|.
name|LAZY_LOAD
argument_list|,
name|numUTF8Bytes
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
case|case
name|SIZE
case|:
case|case
name|SIZE_AND_BREAK
case|:
name|in
operator|.
name|seek
argument_list|(
name|in
operator|.
name|getFilePointer
argument_list|()
operator|+
name|numUTF8Bytes
argument_list|)
expr_stmt|;
name|addFieldSize
argument_list|(
name|fieldInfo
argument_list|,
literal|2
operator|*
name|numUTF8Bytes
argument_list|)
expr_stmt|;
return|return
name|accept
operator|!=
name|FieldSelectorResult
operator|.
name|SIZE
return|;
default|default:
comment|// skip
name|in
operator|.
name|seek
argument_list|(
name|in
operator|.
name|getFilePointer
argument_list|()
operator|+
name|numUTF8Bytes
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|intField
specifier|public
name|boolean
name|intField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|FieldType
name|ft
init|=
operator|new
name|FieldType
argument_list|(
name|NumericField
operator|.
name|TYPE_STORED
argument_list|)
decl_stmt|;
name|ft
operator|.
name|setIndexed
argument_list|(
name|fieldInfo
operator|.
name|isIndexed
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setOmitNorms
argument_list|(
name|fieldInfo
operator|.
name|omitNorms
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setIndexOptions
argument_list|(
name|fieldInfo
operator|.
name|indexOptions
argument_list|)
expr_stmt|;
return|return
name|addNumericField
argument_list|(
name|fieldInfo
argument_list|,
operator|new
name|NumericField
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|ft
argument_list|)
operator|.
name|setIntValue
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|longField
specifier|public
name|boolean
name|longField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|FieldType
name|ft
init|=
operator|new
name|FieldType
argument_list|(
name|NumericField
operator|.
name|TYPE_STORED
argument_list|)
decl_stmt|;
name|ft
operator|.
name|setIndexed
argument_list|(
name|fieldInfo
operator|.
name|isIndexed
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setOmitNorms
argument_list|(
name|fieldInfo
operator|.
name|omitNorms
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setIndexOptions
argument_list|(
name|fieldInfo
operator|.
name|indexOptions
argument_list|)
expr_stmt|;
return|return
name|addNumericField
argument_list|(
name|fieldInfo
argument_list|,
operator|new
name|NumericField
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|ft
argument_list|)
operator|.
name|setLongValue
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|floatField
specifier|public
name|boolean
name|floatField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|float
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|FieldType
name|ft
init|=
operator|new
name|FieldType
argument_list|(
name|NumericField
operator|.
name|TYPE_STORED
argument_list|)
decl_stmt|;
name|ft
operator|.
name|setIndexed
argument_list|(
name|fieldInfo
operator|.
name|isIndexed
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setOmitNorms
argument_list|(
name|fieldInfo
operator|.
name|omitNorms
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setIndexOptions
argument_list|(
name|fieldInfo
operator|.
name|indexOptions
argument_list|)
expr_stmt|;
return|return
name|addNumericField
argument_list|(
name|fieldInfo
argument_list|,
operator|new
name|NumericField
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|ft
argument_list|)
operator|.
name|setFloatValue
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doubleField
specifier|public
name|boolean
name|doubleField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|double
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|FieldType
name|ft
init|=
operator|new
name|FieldType
argument_list|(
name|NumericField
operator|.
name|TYPE_STORED
argument_list|)
decl_stmt|;
name|ft
operator|.
name|setIndexed
argument_list|(
name|fieldInfo
operator|.
name|isIndexed
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setOmitNorms
argument_list|(
name|fieldInfo
operator|.
name|omitNorms
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setIndexOptions
argument_list|(
name|fieldInfo
operator|.
name|indexOptions
argument_list|)
expr_stmt|;
return|return
name|addNumericField
argument_list|(
name|fieldInfo
argument_list|,
operator|new
name|NumericField
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
name|ft
argument_list|)
operator|.
name|setDoubleValue
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
DECL|method|addNumericField
specifier|private
name|boolean
name|addNumericField
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|NumericField
name|f
parameter_list|)
block|{
name|doc
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
specifier|final
name|FieldSelectorResult
name|accept
init|=
name|selector
operator|.
name|accept
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|accept
condition|)
block|{
case|case
name|LOAD
case|:
return|return
literal|false
return|;
case|case
name|LOAD_AND_BREAK
case|:
return|return
literal|true
return|;
case|case
name|LAZY_LOAD
case|:
case|case
name|LATENT
case|:
return|return
literal|false
return|;
case|case
name|SIZE
case|:
return|return
literal|false
return|;
case|case
name|SIZE_AND_BREAK
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|method|addFieldLazy
specifier|private
name|void
name|addFieldLazy
parameter_list|(
name|IndexInput
name|in
parameter_list|,
name|FieldInfo
name|fi
parameter_list|,
name|boolean
name|binary
parameter_list|,
name|boolean
name|cacheResult
parameter_list|,
name|int
name|numBytes
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|IndexableField
name|f
decl_stmt|;
specifier|final
name|long
name|pointer
init|=
name|in
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
comment|// Need to move the pointer ahead by toRead positions
name|in
operator|.
name|seek
argument_list|(
name|pointer
operator|+
name|numBytes
argument_list|)
expr_stmt|;
name|FieldType
name|ft
init|=
operator|new
name|FieldType
argument_list|()
decl_stmt|;
name|ft
operator|.
name|setStored
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setOmitNorms
argument_list|(
name|fi
operator|.
name|omitNorms
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setIndexOptions
argument_list|(
name|fi
operator|.
name|indexOptions
argument_list|)
expr_stmt|;
if|if
condition|(
name|binary
condition|)
block|{
name|f
operator|=
operator|new
name|LazyField
argument_list|(
name|in
argument_list|,
name|fi
operator|.
name|name
argument_list|,
name|ft
argument_list|,
name|numBytes
argument_list|,
name|pointer
argument_list|,
name|binary
argument_list|,
name|cacheResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ft
operator|.
name|setStoreTermVectors
argument_list|(
name|fi
operator|.
name|storeTermVector
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setStoreTermVectorOffsets
argument_list|(
name|fi
operator|.
name|storeOffsetWithTermVector
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setStoreTermVectorPositions
argument_list|(
name|fi
operator|.
name|storePositionWithTermVector
argument_list|)
expr_stmt|;
name|f
operator|=
operator|new
name|LazyField
argument_list|(
name|in
argument_list|,
name|fi
operator|.
name|name
argument_list|,
name|ft
argument_list|,
name|numBytes
argument_list|,
name|pointer
argument_list|,
name|binary
argument_list|,
name|cacheResult
argument_list|)
expr_stmt|;
block|}
name|doc
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|// Add the size of field as a byte[] containing the 4 bytes of the integer byte size (high order byte first; char = 2 bytes)
comment|// Read just the size -- caller must skip the field content to continue reading fields
comment|// Return the size in bytes or chars, depending on field type
DECL|method|addFieldSize
specifier|private
name|void
name|addFieldSize
parameter_list|(
name|FieldInfo
name|fi
parameter_list|,
name|int
name|numBytes
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|sizebytes
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|sizebytes
index|[
literal|0
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|numBytes
operator|>>>
literal|24
argument_list|)
expr_stmt|;
name|sizebytes
index|[
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|numBytes
operator|>>>
literal|16
argument_list|)
expr_stmt|;
name|sizebytes
index|[
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|numBytes
operator|>>>
literal|8
argument_list|)
expr_stmt|;
name|sizebytes
index|[
literal|3
index|]
operator|=
operator|(
name|byte
operator|)
name|numBytes
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
operator|new
name|BinaryField
argument_list|(
name|fi
operator|.
name|name
argument_list|,
name|sizebytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * A Lazy field implementation that defers loading of fields until asked for, instead of when the Document is    * loaded.    */
DECL|class|LazyField
specifier|private
specifier|static
class|class
name|LazyField
extends|extends
name|Field
block|{
DECL|field|toRead
specifier|private
name|int
name|toRead
decl_stmt|;
DECL|field|pointer
specifier|private
name|long
name|pointer
decl_stmt|;
DECL|field|cacheResult
specifier|private
specifier|final
name|boolean
name|cacheResult
decl_stmt|;
DECL|field|in
specifier|private
specifier|final
name|IndexInput
name|in
decl_stmt|;
DECL|field|isBinary
specifier|private
name|boolean
name|isBinary
decl_stmt|;
DECL|method|LazyField
specifier|public
name|LazyField
parameter_list|(
name|IndexInput
name|in
parameter_list|,
name|String
name|name
parameter_list|,
name|FieldType
name|ft
parameter_list|,
name|int
name|toRead
parameter_list|,
name|long
name|pointer
parameter_list|,
name|boolean
name|isBinary
parameter_list|,
name|boolean
name|cacheResult
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|toRead
operator|=
name|toRead
expr_stmt|;
name|this
operator|.
name|pointer
operator|=
name|pointer
expr_stmt|;
name|this
operator|.
name|isBinary
operator|=
name|isBinary
expr_stmt|;
name|this
operator|.
name|cacheResult
operator|=
name|cacheResult
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|numericValue
specifier|public
name|Number
name|numericValue
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|numericDataType
specifier|public
name|DataType
name|numericDataType
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|field|localFieldsStream
specifier|private
name|IndexInput
name|localFieldsStream
decl_stmt|;
DECL|method|getFieldStream
specifier|private
name|IndexInput
name|getFieldStream
parameter_list|()
block|{
if|if
condition|(
name|localFieldsStream
operator|==
literal|null
condition|)
block|{
name|localFieldsStream
operator|=
operator|(
name|IndexInput
operator|)
name|in
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
return|return
name|localFieldsStream
return|;
block|}
comment|/** The value of the field as a Reader, or null.  If null, the String value,      * binary value, or TokenStream value is used.  Exactly one of stringValue(),       * readerValue(), getBinaryValue(), and tokenStreamValue() must be set. */
annotation|@
name|Override
DECL|method|readerValue
specifier|public
name|Reader
name|readerValue
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/** The value of the field as a TokenStream, or null.  If null, the Reader value,      * String value, or binary value is used. Exactly one of stringValue(),       * readerValue(), getBinaryValue(), and tokenStreamValue() must be set. */
annotation|@
name|Override
DECL|method|tokenStreamValue
specifier|public
name|TokenStream
name|tokenStreamValue
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/** The value of the field as a String, or null.  If null, the Reader value,      * binary value, or TokenStream value is used.  Exactly one of stringValue(),       * readerValue(), getBinaryValue(), and tokenStreamValue() must be set. */
annotation|@
name|Override
DECL|method|stringValue
specifier|synchronized
specifier|public
name|String
name|stringValue
parameter_list|()
block|{
if|if
condition|(
name|isBinary
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
if|if
condition|(
name|fieldsData
operator|==
literal|null
condition|)
block|{
name|String
name|result
init|=
literal|null
decl_stmt|;
name|IndexInput
name|localFieldsStream
init|=
name|getFieldStream
argument_list|()
decl_stmt|;
try|try
block|{
name|localFieldsStream
operator|.
name|seek
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|toRead
index|]
decl_stmt|;
name|localFieldsStream
operator|.
name|readBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|toRead
argument_list|)
expr_stmt|;
name|result
operator|=
operator|new
name|String
argument_list|(
name|bytes
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|FieldReaderException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|cacheResult
operator|==
literal|true
condition|)
block|{
name|fieldsData
operator|=
name|result
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
else|else
block|{
return|return
operator|(
name|String
operator|)
name|fieldsData
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|binaryValue
specifier|synchronized
specifier|public
name|BytesRef
name|binaryValue
parameter_list|()
block|{
if|if
condition|(
name|isBinary
condition|)
block|{
if|if
condition|(
name|fieldsData
operator|==
literal|null
condition|)
block|{
comment|// Allocate new buffer if result is null or too small
specifier|final
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|toRead
index|]
decl_stmt|;
name|IndexInput
name|localFieldsStream
init|=
name|getFieldStream
argument_list|()
decl_stmt|;
comment|// Throw this IOException since IndexReader.document does so anyway, so probably not that big of a change for people
comment|// since they are already handling this exception when getting the document
try|try
block|{
name|localFieldsStream
operator|.
name|seek
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|localFieldsStream
operator|.
name|readBytes
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|toRead
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|FieldReaderException
argument_list|(
name|e
argument_list|)
throw|;
block|}
specifier|final
name|BytesRef
name|result
init|=
operator|new
name|BytesRef
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|result
operator|.
name|length
operator|=
name|toRead
expr_stmt|;
if|if
condition|(
name|cacheResult
operator|==
literal|true
condition|)
block|{
name|fieldsData
operator|=
name|result
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
else|else
block|{
return|return
operator|(
name|BytesRef
operator|)
name|fieldsData
return|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
block|}
end_class
end_unit
