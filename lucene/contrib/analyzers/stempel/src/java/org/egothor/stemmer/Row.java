begin_unit
begin_comment
comment|/*                     Egothor Software License version 1.00                     Copyright (C) 1997-2004 Leo Galambos.                  Copyright (C) 2002-2004 "Egothor developers"                       on behalf of the Egothor Project.                              All rights reserved.     This  software  is  copyrighted  by  the "Egothor developers". If this    license applies to a single file or document, the "Egothor developers"    are the people or entities mentioned as copyright holders in that file    or  document.  If  this  license  applies  to the Egothor project as a    whole,  the  copyright holders are the people or entities mentioned in    the  file CREDITS. This file can be found in the same location as this    license in the distribution.     Redistribution  and  use  in  source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:     1. Redistributions  of  source  code  must retain the above copyright        notice, the list of contributors, this list of conditions, and the        following disclaimer.     2. Redistributions  in binary form must reproduce the above copyright        notice, the list of contributors, this list of conditions, and the        disclaimer  that  follows  these  conditions  in the documentation        and/or other materials provided with the distribution.     3. The name "Egothor" must not be used to endorse or promote products        derived  from  this software without prior written permission. For        written permission, please contact Leo.G@seznam.cz     4. Products  derived  from this software may not be called "Egothor",        nor  may  "Egothor"  appear  in  their name, without prior written        permission from Leo.G@seznam.cz.     In addition, we request that you include in the end-user documentation    provided  with  the  redistribution  and/or  in the software itself an    acknowledgement equivalent to the following:    "This product includes software developed by the Egothor Project.     http://egothor.sf.net/"     THIS  SOFTWARE  IS  PROVIDED  ``AS  IS''  AND ANY EXPRESSED OR IMPLIED    WARRANTIES,  INCLUDING,  BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF    MERCHANTABILITY  AND  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.    IN  NO  EVENT  SHALL THE EGOTHOR PROJECT OR ITS CONTRIBUTORS BE LIABLE    FOR   ANY   DIRECT,   INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR    CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE  GOODS  OR  SERVICES;  LOSS  OF  USE,  DATA, OR PROFITS; OR    BUSINESS  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,    WHETHER  IN  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE    OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN    IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     This  software  consists  of  voluntary  contributions  made  by  many    individuals  on  behalf  of  the  Egothor  Project  and was originally    created by Leo Galambos (Leo.G@seznam.cz).  */
end_comment
begin_package
DECL|package|org.egothor.stemmer
package|package
name|org
operator|.
name|egothor
operator|.
name|stemmer
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import
begin_comment
comment|/**  * The Row class represents a row in a matrix representation of a trie.  */
end_comment
begin_class
DECL|class|Row
specifier|public
class|class
name|Row
block|{
DECL|field|cells
name|TreeMap
argument_list|<
name|Character
argument_list|,
name|Cell
argument_list|>
name|cells
init|=
operator|new
name|TreeMap
argument_list|<
name|Character
argument_list|,
name|Cell
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|uniformCnt
name|int
name|uniformCnt
init|=
literal|0
decl_stmt|;
DECL|field|uniformSkip
name|int
name|uniformSkip
init|=
literal|0
decl_stmt|;
comment|/**    * Construct a Row object from input carried in via the given input stream.    *     * @param is the input stream    * @exception IOException if an I/O error occurs    */
DECL|method|Row
specifier|public
name|Row
parameter_list|(
name|DataInput
name|is
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
name|is
operator|.
name|readInt
argument_list|()
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|char
name|ch
init|=
name|is
operator|.
name|readChar
argument_list|()
decl_stmt|;
name|Cell
name|c
init|=
operator|new
name|Cell
argument_list|()
decl_stmt|;
name|c
operator|.
name|cmd
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|c
operator|.
name|cnt
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|c
operator|.
name|ref
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|c
operator|.
name|skip
operator|=
name|is
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|cells
operator|.
name|put
argument_list|(
name|ch
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * The default constructor for the Row object.    */
DECL|method|Row
specifier|public
name|Row
parameter_list|()
block|{}
comment|/**    * Construct a Row using the cells of the given Row.    *     * @param old the Row to copy    */
DECL|method|Row
specifier|public
name|Row
parameter_list|(
name|Row
name|old
parameter_list|)
block|{
name|cells
operator|=
name|old
operator|.
name|cells
expr_stmt|;
block|}
comment|/**    * Set the command in the Cell of the given Character to the given integer.    *     * @param way the Character defining the Cell    * @param cmd the new command    */
DECL|method|setCmd
specifier|public
name|void
name|setCmd
parameter_list|(
name|Character
name|way
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|Cell
name|c
init|=
name|at
argument_list|(
name|way
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
name|c
operator|=
operator|new
name|Cell
argument_list|()
expr_stmt|;
name|c
operator|.
name|cmd
operator|=
name|cmd
expr_stmt|;
name|cells
operator|.
name|put
argument_list|(
name|way
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|.
name|cmd
operator|=
name|cmd
expr_stmt|;
block|}
name|c
operator|.
name|cnt
operator|=
operator|(
name|cmd
operator|>=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
comment|/**    * Set the reference to the next row in the Cell of the given Character to the    * given integer.    *     * @param way the Character defining the Cell    * @param ref The new ref value    */
DECL|method|setRef
specifier|public
name|void
name|setRef
parameter_list|(
name|Character
name|way
parameter_list|,
name|int
name|ref
parameter_list|)
block|{
name|Cell
name|c
init|=
name|at
argument_list|(
name|way
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
name|c
operator|=
operator|new
name|Cell
argument_list|()
expr_stmt|;
name|c
operator|.
name|ref
operator|=
name|ref
expr_stmt|;
name|cells
operator|.
name|put
argument_list|(
name|way
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|.
name|ref
operator|=
name|ref
expr_stmt|;
block|}
block|}
comment|/**    * Return the number of cells in use.    *     * @return the number of cells in use    */
DECL|method|getCells
specifier|public
name|int
name|getCells
parameter_list|()
block|{
name|Iterator
argument_list|<
name|Character
argument_list|>
name|i
init|=
name|cells
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Character
name|c
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Cell
name|e
init|=
name|at
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|cmd
operator|>=
literal|0
operator|||
name|e
operator|.
name|ref
operator|>=
literal|0
condition|)
block|{
name|size
operator|++
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
comment|/**    * Return the number of references (how many transitions) to other rows.    *     * @return the number of references    */
DECL|method|getCellsPnt
specifier|public
name|int
name|getCellsPnt
parameter_list|()
block|{
name|Iterator
argument_list|<
name|Character
argument_list|>
name|i
init|=
name|cells
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Character
name|c
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Cell
name|e
init|=
name|at
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|ref
operator|>=
literal|0
condition|)
block|{
name|size
operator|++
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
comment|/**    * Return the number of patch commands saved in this Row.    *     * @return the number of patch commands    */
DECL|method|getCellsVal
specifier|public
name|int
name|getCellsVal
parameter_list|()
block|{
name|Iterator
argument_list|<
name|Character
argument_list|>
name|i
init|=
name|cells
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Character
name|c
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Cell
name|e
init|=
name|at
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|cmd
operator|>=
literal|0
condition|)
block|{
name|size
operator|++
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
comment|/**    * Return the command in the Cell associated with the given Character.    *     * @param way the Character associated with the Cell holding the desired    *          command    * @return the command    */
DECL|method|getCmd
specifier|public
name|int
name|getCmd
parameter_list|(
name|Character
name|way
parameter_list|)
block|{
name|Cell
name|c
init|=
name|at
argument_list|(
name|way
argument_list|)
decl_stmt|;
return|return
operator|(
name|c
operator|==
literal|null
operator|)
condition|?
operator|-
literal|1
else|:
name|c
operator|.
name|cmd
return|;
block|}
comment|/**    * Return the number of patch commands were in the Cell associated with the    * given Character before the Trie containing this Row was reduced.    *     * @param way the Character associated with the desired Cell    * @return the number of patch commands before reduction    */
DECL|method|getCnt
specifier|public
name|int
name|getCnt
parameter_list|(
name|Character
name|way
parameter_list|)
block|{
name|Cell
name|c
init|=
name|at
argument_list|(
name|way
argument_list|)
decl_stmt|;
return|return
operator|(
name|c
operator|==
literal|null
operator|)
condition|?
operator|-
literal|1
else|:
name|c
operator|.
name|cnt
return|;
block|}
comment|/**    * Return the reference to the next Row in the Cell associated with the given    * Character.    *     * @param way the Character associated with the desired Cell    * @return the reference, or -1 if the Cell is<tt>null,/tt>    */
DECL|method|getRef
specifier|public
name|int
name|getRef
parameter_list|(
name|Character
name|way
parameter_list|)
block|{
name|Cell
name|c
init|=
name|at
argument_list|(
name|way
argument_list|)
decl_stmt|;
return|return
operator|(
name|c
operator|==
literal|null
operator|)
condition|?
operator|-
literal|1
else|:
name|c
operator|.
name|ref
return|;
block|}
comment|/**    * Write the contents of this Row to the given output stream.    *     * @param os the output stream    * @exception IOException if an I/O error occurs    */
DECL|method|store
specifier|public
name|void
name|store
parameter_list|(
name|DataOutput
name|os
parameter_list|)
throws|throws
name|IOException
block|{
name|os
operator|.
name|writeInt
argument_list|(
name|cells
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Character
argument_list|>
name|i
init|=
name|cells
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Character
name|c
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Cell
name|e
init|=
name|at
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|cmd
operator|<
literal|0
operator|&&
name|e
operator|.
name|ref
operator|<
literal|0
condition|)
block|{
continue|continue;
block|}
name|os
operator|.
name|writeChar
argument_list|(
name|c
operator|.
name|charValue
argument_list|()
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|e
operator|.
name|cmd
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|e
operator|.
name|cnt
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|e
operator|.
name|ref
argument_list|)
expr_stmt|;
name|os
operator|.
name|writeInt
argument_list|(
name|e
operator|.
name|skip
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return the number of identical Cells (containing patch commands) in this    * Row.    *     * @param eqSkip when set to<tt>false</tt> the removed patch commands are    *          considered    * @return the number of identical Cells, or -1 if there are (at least) two    *         different cells    */
DECL|method|uniformCmd
specifier|public
name|int
name|uniformCmd
parameter_list|(
name|boolean
name|eqSkip
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Cell
argument_list|>
name|i
init|=
name|cells
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|uniformCnt
operator|=
literal|1
expr_stmt|;
name|uniformSkip
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Cell
name|c
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|ref
operator|>=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|c
operator|.
name|cmd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
name|c
operator|.
name|cmd
expr_stmt|;
name|uniformSkip
operator|=
name|c
operator|.
name|skip
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|c
operator|.
name|cmd
condition|)
block|{
if|if
condition|(
name|eqSkip
condition|)
block|{
if|if
condition|(
name|uniformSkip
operator|==
name|c
operator|.
name|skip
condition|)
block|{
name|uniformCnt
operator|++
expr_stmt|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|uniformCnt
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Write the contents of this Row to stdout.    */
DECL|method|print
specifier|public
name|void
name|print
parameter_list|()
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Character
argument_list|>
name|i
init|=
name|cells
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Character
name|ch
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Cell
name|c
init|=
name|at
argument_list|(
name|ch
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"["
operator|+
name|ch
operator|+
literal|":"
operator|+
name|c
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
DECL|method|at
name|Cell
name|at
parameter_list|(
name|Character
name|index
parameter_list|)
block|{
return|return
name|cells
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
block|}
end_class
end_unit
