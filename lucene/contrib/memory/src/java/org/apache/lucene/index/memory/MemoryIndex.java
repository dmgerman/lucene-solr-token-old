begin_unit
begin_package
DECL|package|org.apache.lucene.index.memory
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|memory
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|CharTermAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|OffsetAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|PositionIncrementAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|TermToBytesRefAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|AtomicReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|AtomicReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Norm
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInvertState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Fields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|OrdTermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StoredFieldVisitor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|memory
operator|.
name|MemoryIndexNormDocValues
operator|.
name|SingleValueSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Collector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Scorer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RAMDirectory
import|;
end_import
begin_comment
comment|// for javadocs
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Constants
import|;
end_import
begin_comment
comment|// for javadocs
end_comment
begin_comment
comment|/**  * High-performance single-document main memory Apache Lucene fulltext search index.   *   *<h4>Overview</h4>  *   * This class is a replacement/substitute for a large subset of  * {@link RAMDirectory} functionality. It is designed to  * enable maximum efficiency for on-the-fly matchmaking combining structured and   * fuzzy fulltext search in realtime streaming applications such as Nux XQuery based XML   * message queues, publish-subscribe systems for Blogs/newsfeeds, text chat, data acquisition and   * distribution systems, application level routers, firewalls, classifiers, etc.   * Rather than targeting fulltext search of infrequent queries over huge persistent   * data archives (historic search), this class targets fulltext search of huge   * numbers of queries over comparatively small transient realtime data (prospective   * search).   * For example as in   *<pre>  * float score = search(String text, Query query)  *</pre>  *<p>  * Each instance can hold at most one Lucene "document", with a document containing  * zero or more "fields", each field having a name and a fulltext value. The  * fulltext value is tokenized (split and transformed) into zero or more index terms   * (aka words) on<code>addField()</code>, according to the policy implemented by an  * Analyzer. For example, Lucene analyzers can split on whitespace, normalize to lower case  * for case insensitivity, ignore common terms with little discriminatory value such as "he", "in", "and" (stop  * words), reduce the terms to their natural linguistic root form such as "fishing"  * being reduced to "fish" (stemming), resolve synonyms/inflexions/thesauri   * (upon indexing and/or querying), etc. For details, see  *<a target="_blank" href="http://today.java.net/pub/a/today/2003/07/30/LuceneIntro.html">Lucene Analyzer Intro</a>.  *<p>  * Arbitrary Lucene queries can be run against this class - see<a target="_blank"   * href="../../../../../../../queryparsersyntax.html">Lucene Query Syntax</a>  * as well as<a target="_blank"   * href="http://today.java.net/pub/a/today/2003/11/07/QueryParserRules.html">Query Parser Rules</a>.  * Note that a Lucene query selects on the field names and associated (indexed)   * tokenized terms, not on the original fulltext(s) - the latter are not stored   * but rather thrown away immediately after tokenization.  *<p>  * For some interesting background information on search technology, see Bob Wyman's  *<a target="_blank"   * href="http://bobwyman.pubsub.com/main/2005/05/mary_hodder_poi.html">Prospective Search</a>,   * Jim Gray's  *<a target="_blank" href="http://www.acmqueue.org/modules.php?name=Content&pa=showpage&pid=293&page=4">  * A Call to Arms - Custom subscriptions</a>, and Tim Bray's  *<a target="_blank"   * href="http://www.tbray.org/ongoing/When/200x/2003/07/30/OnSearchTOC">On Search, the Series</a>.  *   *   *<h4>Example Usage</h4>   *   *<pre>  * Analyzer analyzer = PatternAnalyzer.DEFAULT_ANALYZER;  * //Analyzer analyzer = new SimpleAnalyzer();  * MemoryIndex index = new MemoryIndex();  * index.addField("content", "Readings about Salmons and other select Alaska fishing Manuals", analyzer);  * index.addField("author", "Tales of James", analyzer);  * QueryParser parser = new QueryParser("content", analyzer);  * float score = index.search(parser.parse("+author:james +salmon~ +fish* manual~"));  * if (score&gt; 0.0f) {  *     System.out.println("it's a match");  * } else {  *     System.out.println("no match found");  * }  * System.out.println("indexData=" + index.toString());  *</pre>  *   *   *<h4>Example XQuery Usage</h4>   *   *<pre>  * (: An XQuery that finds all books authored by James that have something to do with "salmon fishing manuals", sorted by relevance :)  * declare namespace lucene = "java:nux.xom.pool.FullTextUtil";  * declare variable $query := "+salmon~ +fish* manual~"; (: any arbitrary Lucene query can go here :)  *   * for $book in /books/book[author="James" and lucene:match(abstract, $query)> 0.0]  * let $score := lucene:match($book/abstract, $query)  * order by $score descending  * return $book  *</pre>  *   *   *<h4>No thread safety guarantees</h4>  *   * An instance can be queried multiple times with the same or different queries,  * but an instance is not thread-safe. If desired use idioms such as:  *<pre>  * MemoryIndex index = ...  * synchronized (index) {  *    // read and/or write index (i.e. add fields and/or query)  * }   *</pre>  *   *   *<h4>Performance Notes</h4>  *   * Internally there's a new data structure geared towards efficient indexing   * and searching, plus the necessary support code to seamlessly plug into the Lucene   * framework.  *<p>  * This class performs very well for very small texts (e.g. 10 chars)   * as well as for large texts (e.g. 10 MB) and everything in between.   * Typically, it is about 10-100 times faster than<code>RAMDirectory</code>.  * Note that<code>RAMDirectory</code> has particularly   * large efficiency overheads for small to medium sized texts, both in time and space.  * Indexing a field with N tokens takes O(N) in the best case, and O(N logN) in the worst   * case. Memory consumption is probably larger than for<code>RAMDirectory</code>.  *<p>  * Example throughput of many simple term queries over a single MemoryIndex:   * ~500000 queries/sec on a MacBook Pro, jdk 1.5.0_06, server VM.   * As always, your mileage may vary.  *<p>  * If you're curious about  * the whereabouts of bottlenecks, run java 1.5 with the non-perturbing '-server  * -agentlib:hprof=cpu=samples,depth=10' flags, then study the trace log and  * correlate its hotspot trailer with its call stack headers (see<a  * target="_blank"  * href="http://java.sun.com/developer/technicalArticles/Programming/HPROF.html">  * hprof tracing</a>).  *  */
end_comment
begin_class
DECL|class|MemoryIndex
specifier|public
class|class
name|MemoryIndex
block|{
comment|/** info for each field: Map<String fieldName, Info field> */
DECL|field|fields
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|Info
argument_list|>
name|fields
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Info
argument_list|>
argument_list|()
decl_stmt|;
comment|/** fields sorted ascending by fieldName; lazily computed on demand */
DECL|field|sortedFields
specifier|private
specifier|transient
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Info
argument_list|>
index|[]
name|sortedFields
decl_stmt|;
comment|/** pos: positions[3*i], startOffset: positions[3*i +1], endOffset: positions[3*i +2] */
DECL|field|stride
specifier|private
specifier|final
name|int
name|stride
decl_stmt|;
comment|/** Could be made configurable; See {@link Document#setBoost(float)} */
DECL|field|docBoost
specifier|private
specifier|static
specifier|final
name|float
name|docBoost
init|=
literal|1.0f
decl_stmt|;
DECL|field|DEBUG
specifier|private
specifier|static
specifier|final
name|boolean
name|DEBUG
init|=
literal|false
decl_stmt|;
DECL|field|fieldInfos
specifier|private
specifier|final
name|FieldInfos
name|fieldInfos
decl_stmt|;
comment|/**    * Sorts term entries into ascending order; also works for    * Arrays.binarySearch() and Arrays.sort()    */
DECL|field|termComparator
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Object
argument_list|>
name|termComparator
init|=
operator|new
name|Comparator
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|int
name|compare
parameter_list|(
name|Object
name|o1
parameter_list|,
name|Object
name|o2
parameter_list|)
block|{
if|if
condition|(
name|o1
operator|instanceof
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
condition|) o1 = ((Map.Entry<?
condition|,
operator|?
operator|>
condition|)
name|o1
block|)
function|.getKey
parameter_list|()
function|;
if|if
condition|(
name|o2
operator|instanceof
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
condition|) o2 = ((Map.Entry<?
condition|,
operator|?
operator|>
condition|)
name|o2
block|)
operator|.
name|getKey
argument_list|()
expr_stmt|;
if|if
condition|(
name|o1
operator|==
name|o2
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|Comparable
operator|)
name|o1
operator|)
operator|.
name|compareTo
argument_list|(
operator|(
name|Comparable
operator|)
name|o2
argument_list|)
return|;
block|}
end_class
begin_comment
unit|};
comment|/**    * Constructs an empty instance.    */
end_comment
begin_constructor
DECL|method|MemoryIndex
specifier|public
name|MemoryIndex
parameter_list|()
block|{
name|this
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/**    * Constructs an empty instance that can optionally store the start and end    * character offset of each token term in the text. This can be useful for    * highlighting of hit locations with the Lucene highlighter package.    * Private until the highlighter package matures, so that this can actually    * be meaningfully integrated.    *     * @param storeOffsets    *            whether or not to store the start and end character offset of    *            each token term in the text    */
end_comment
begin_constructor
DECL|method|MemoryIndex
specifier|private
name|MemoryIndex
parameter_list|(
name|boolean
name|storeOffsets
parameter_list|)
block|{
name|this
operator|.
name|stride
operator|=
name|storeOffsets
condition|?
literal|3
else|:
literal|1
expr_stmt|;
name|fieldInfos
operator|=
operator|new
name|FieldInfos
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/**    * Convenience method; Tokenizes the given field text and adds the resulting    * terms to the index; Equivalent to adding an indexed non-keyword Lucene    * {@link org.apache.lucene.document.Field} that is tokenized, not stored,    * termVectorStored with positions (or termVectorStored with positions and offsets),    *     * @param fieldName    *            a name to be associated with the text    * @param text    *            the text to tokenize and index.    * @param analyzer    *            the analyzer to use for tokenization    */
end_comment
begin_function
DECL|method|addField
specifier|public
name|void
name|addField
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|String
name|text
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
block|{
if|if
condition|(
name|fieldName
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"fieldName must not be null"
argument_list|)
throw|;
if|if
condition|(
name|text
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"text must not be null"
argument_list|)
throw|;
if|if
condition|(
name|analyzer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"analyzer must not be null"
argument_list|)
throw|;
name|TokenStream
name|stream
decl_stmt|;
try|try
block|{
name|stream
operator|=
name|analyzer
operator|.
name|tokenStream
argument_list|(
name|fieldName
argument_list|,
operator|new
name|StringReader
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
name|addField
argument_list|(
name|fieldName
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**    * Convenience method; Creates and returns a token stream that generates a    * token for each keyword in the given collection, "as is", without any    * transforming text analysis. The resulting token stream can be fed into    * {@link #addField(String, TokenStream)}, perhaps wrapped into another    * {@link org.apache.lucene.analysis.TokenFilter}, as desired.    *     * @param keywords    *            the keywords to generate tokens for    * @return the corresponding token stream    */
end_comment
begin_function
DECL|method|keywordTokenStream
specifier|public
parameter_list|<
name|T
parameter_list|>
name|TokenStream
name|keywordTokenStream
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|keywords
parameter_list|)
block|{
comment|// TODO: deprecate& move this method into AnalyzerUtil?
if|if
condition|(
name|keywords
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"keywords must not be null"
argument_list|)
throw|;
return|return
operator|new
name|TokenStream
argument_list|()
block|{
specifier|private
name|Iterator
argument_list|<
name|T
argument_list|>
name|iter
init|=
name|keywords
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|private
name|int
name|start
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|CharTermAttribute
name|termAtt
init|=
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|OffsetAttribute
name|offsetAtt
init|=
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|incrementToken
parameter_list|()
block|{
if|if
condition|(
operator|!
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
return|return
literal|false
return|;
name|T
name|obj
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"keyword must not be null"
argument_list|)
throw|;
name|String
name|term
init|=
name|obj
operator|.
name|toString
argument_list|()
decl_stmt|;
name|clearAttributes
argument_list|()
expr_stmt|;
name|termAtt
operator|.
name|setEmpty
argument_list|()
operator|.
name|append
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|offsetAtt
operator|.
name|setOffset
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|termAtt
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|start
operator|+=
name|term
operator|.
name|length
argument_list|()
operator|+
literal|1
expr_stmt|;
comment|// separate words by 1 (blank) character
return|return
literal|true
return|;
block|}
block|}
return|;
block|}
end_function
begin_comment
comment|/**    * Equivalent to<code>addField(fieldName, stream, 1.0f)</code>.    *     * @param fieldName    *            a name to be associated with the text    * @param stream    *            the token stream to retrieve tokens from    */
end_comment
begin_function
DECL|method|addField
specifier|public
name|void
name|addField
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|TokenStream
name|stream
parameter_list|)
block|{
name|addField
argument_list|(
name|fieldName
argument_list|,
name|stream
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**    * Iterates over the given token stream and adds the resulting terms to the index;    * Equivalent to adding a tokenized, indexed, termVectorStored, unstored,    * Lucene {@link org.apache.lucene.document.Field}.    * Finally closes the token stream. Note that untokenized keywords can be added with this method via     * {@link #keywordTokenStream(Collection)}, the Lucene contrib<code>KeywordTokenizer</code> or similar utilities.    *     * @param fieldName    *            a name to be associated with the text    * @param stream    *            the token stream to retrieve tokens from.    * @param boost    *            the boost factor for hits for this field    * @see org.apache.lucene.document.Field#setBoost(float)    */
end_comment
begin_function
DECL|method|addField
specifier|public
name|void
name|addField
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|TokenStream
name|stream
parameter_list|,
name|float
name|boost
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|fieldName
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"fieldName must not be null"
argument_list|)
throw|;
if|if
condition|(
name|stream
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"token stream must not be null"
argument_list|)
throw|;
if|if
condition|(
name|boost
operator|<=
literal|0.0f
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"boost factor must be greater than 0.0"
argument_list|)
throw|;
if|if
condition|(
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field must not be added more than once"
argument_list|)
throw|;
name|HashMap
argument_list|<
name|BytesRef
argument_list|,
name|ArrayIntList
argument_list|>
name|terms
init|=
operator|new
name|HashMap
argument_list|<
name|BytesRef
argument_list|,
name|ArrayIntList
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numTokens
init|=
literal|0
decl_stmt|;
name|int
name|numOverlapTokens
init|=
literal|0
decl_stmt|;
name|int
name|pos
init|=
operator|-
literal|1
decl_stmt|;
name|fieldInfos
operator|.
name|addOrUpdate
argument_list|(
name|fieldName
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|TermToBytesRefAttribute
name|termAtt
init|=
name|stream
operator|.
name|getAttribute
argument_list|(
name|TermToBytesRefAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|PositionIncrementAttribute
name|posIncrAttribute
init|=
name|stream
operator|.
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|OffsetAttribute
name|offsetAtt
init|=
name|stream
operator|.
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|BytesRef
name|ref
init|=
name|termAtt
operator|.
name|getBytesRef
argument_list|()
decl_stmt|;
name|stream
operator|.
name|reset
argument_list|()
expr_stmt|;
while|while
condition|(
name|stream
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
name|termAtt
operator|.
name|fillBytesRef
argument_list|()
expr_stmt|;
if|if
condition|(
name|ref
operator|.
name|length
operator|==
literal|0
condition|)
continue|continue;
comment|// nothing to do
comment|//        if (DEBUG) System.err.println("token='" + term + "'");
name|numTokens
operator|++
expr_stmt|;
specifier|final
name|int
name|posIncr
init|=
name|posIncrAttribute
operator|.
name|getPositionIncrement
argument_list|()
decl_stmt|;
if|if
condition|(
name|posIncr
operator|==
literal|0
condition|)
name|numOverlapTokens
operator|++
expr_stmt|;
name|pos
operator|+=
name|posIncr
expr_stmt|;
name|ArrayIntList
name|positions
init|=
name|terms
operator|.
name|get
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|positions
operator|==
literal|null
condition|)
block|{
comment|// term not seen before
name|positions
operator|=
operator|new
name|ArrayIntList
argument_list|(
name|stride
argument_list|)
expr_stmt|;
name|terms
operator|.
name|put
argument_list|(
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|ref
argument_list|)
argument_list|,
name|positions
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stride
operator|==
literal|1
condition|)
block|{
name|positions
operator|.
name|add
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|positions
operator|.
name|add
argument_list|(
name|pos
argument_list|,
name|offsetAtt
operator|.
name|startOffset
argument_list|()
argument_list|,
name|offsetAtt
operator|.
name|endOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|stream
operator|.
name|end
argument_list|()
expr_stmt|;
comment|// ensure infos.numTokens> 0 invariant; needed for correct operation of terms()
if|if
condition|(
name|numTokens
operator|>
literal|0
condition|)
block|{
name|boost
operator|=
name|boost
operator|*
name|docBoost
expr_stmt|;
comment|// see DocumentWriter.addDocument(...)
name|fields
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
operator|new
name|Info
argument_list|(
name|terms
argument_list|,
name|numTokens
argument_list|,
name|numOverlapTokens
argument_list|,
name|boost
argument_list|)
argument_list|)
expr_stmt|;
name|sortedFields
operator|=
literal|null
expr_stmt|;
comment|// invalidate sorted view, if any
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// can never happen
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
try|try
block|{
if|if
condition|(
name|stream
operator|!=
literal|null
condition|)
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e2
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e2
argument_list|)
throw|;
block|}
block|}
block|}
end_function
begin_comment
comment|/**    * Creates and returns a searcher that can be used to execute arbitrary    * Lucene queries and to collect the resulting query results as hits.    *     * @return a searcher    */
end_comment
begin_function
DECL|method|createSearcher
specifier|public
name|IndexSearcher
name|createSearcher
parameter_list|()
block|{
name|MemoryIndexReader
name|reader
init|=
operator|new
name|MemoryIndexReader
argument_list|()
decl_stmt|;
name|IndexSearcher
name|searcher
init|=
operator|new
name|IndexSearcher
argument_list|(
name|reader
argument_list|)
decl_stmt|;
comment|// ensures no auto-close !!
name|reader
operator|.
name|setSearcher
argument_list|(
name|searcher
argument_list|)
expr_stmt|;
comment|// to later get hold of searcher.getSimilarity()
return|return
name|searcher
return|;
block|}
end_function
begin_comment
comment|/**    * Convenience method that efficiently returns the relevance score by    * matching this index against the given Lucene query expression.    *     * @param query    *            an arbitrary Lucene query to run against this index    * @return the relevance score of the matchmaking; A number in the range    *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number    *         the better the match.    *    */
end_comment
begin_function
DECL|method|search
specifier|public
name|float
name|search
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
if|if
condition|(
name|query
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"query must not be null"
argument_list|)
throw|;
name|IndexSearcher
name|searcher
init|=
name|createSearcher
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|float
index|[]
name|scores
init|=
operator|new
name|float
index|[
literal|1
index|]
decl_stmt|;
comment|// inits to 0.0f (no match)
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
operator|new
name|Collector
argument_list|()
block|{
specifier|private
name|Scorer
name|scorer
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|scores
index|[
literal|0
index|]
operator|=
name|scorer
operator|.
name|score
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setNextReader
parameter_list|(
name|AtomicReaderContext
name|context
parameter_list|)
block|{ }
block|}
argument_list|)
expr_stmt|;
name|float
name|score
init|=
name|scores
index|[
literal|0
index|]
decl_stmt|;
return|return
name|score
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// can never happen (RAMDirectory)
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// searcher.close();
comment|/*        * Note that it is harmless and important for good performance to        * NOT close the index reader!!! This avoids all sorts of        * unnecessary baggage and locking in the Lucene IndexReader        * superclass, all of which is completely unnecessary for this main        * memory index data structure without thread-safety claims.        *         * Wishing IndexReader would be an interface...        *         * Actually with the new tight createSearcher() API auto-closing is now        * made impossible, hence searcher.close() would be harmless and also         * would not degrade performance...        */
block|}
block|}
end_function
begin_comment
comment|/**    * Returns a reasonable approximation of the main memory [bytes] consumed by    * this instance. Useful for smart memory sensititive caches/pools. Assumes    * fieldNames are interned, whereas tokenized terms are memory-overlaid.    *     * @return the main memory consumption    */
end_comment
begin_function
DECL|method|getMemorySize
specifier|public
name|int
name|getMemorySize
parameter_list|()
block|{
comment|// for example usage in a smart cache see nux.xom.pool.Pool
name|int
name|PTR
init|=
name|VM
operator|.
name|PTR
decl_stmt|;
name|int
name|INT
init|=
name|VM
operator|.
name|INT
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
name|size
operator|+=
name|VM
operator|.
name|sizeOfObject
argument_list|(
literal|2
operator|*
name|PTR
operator|+
name|INT
argument_list|)
expr_stmt|;
comment|// memory index
if|if
condition|(
name|sortedFields
operator|!=
literal|null
condition|)
name|size
operator|+=
name|VM
operator|.
name|sizeOfObjectArray
argument_list|(
name|sortedFields
operator|.
name|length
argument_list|)
expr_stmt|;
name|size
operator|+=
name|VM
operator|.
name|sizeOfHashMap
argument_list|(
name|fields
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Info
argument_list|>
name|entry
range|:
name|fields
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// for each Field Info
name|Info
name|info
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|size
operator|+=
name|VM
operator|.
name|sizeOfObject
argument_list|(
literal|2
operator|*
name|INT
operator|+
literal|3
operator|*
name|PTR
argument_list|)
expr_stmt|;
comment|// Info instance vars
if|if
condition|(
name|info
operator|.
name|sortedTerms
operator|!=
literal|null
condition|)
name|size
operator|+=
name|VM
operator|.
name|sizeOfObjectArray
argument_list|(
name|info
operator|.
name|sortedTerms
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|info
operator|.
name|terms
operator|.
name|size
argument_list|()
decl_stmt|;
name|size
operator|+=
name|VM
operator|.
name|sizeOfHashMap
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|BytesRef
argument_list|,
name|ArrayIntList
argument_list|>
argument_list|>
name|iter2
init|=
name|info
operator|.
name|terms
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
comment|// for each term
name|Map
operator|.
name|Entry
argument_list|<
name|BytesRef
argument_list|,
name|ArrayIntList
argument_list|>
name|e
init|=
name|iter2
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// FIXME: this calculation is probably not correct since we use bytes now.
name|size
operator|+=
name|VM
operator|.
name|sizeOfObject
argument_list|(
name|PTR
operator|+
literal|3
operator|*
name|INT
argument_list|)
expr_stmt|;
comment|// assumes substring() memory overlay
comment|//        size += STR + 2 * ((String) e.getKey()).length();
name|ArrayIntList
name|positions
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|size
operator|+=
name|VM
operator|.
name|sizeOfArrayIntList
argument_list|(
name|positions
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
end_function
begin_function
DECL|method|numPositions
specifier|private
name|int
name|numPositions
parameter_list|(
name|ArrayIntList
name|positions
parameter_list|)
block|{
return|return
name|positions
operator|.
name|size
argument_list|()
operator|/
name|stride
return|;
block|}
end_function
begin_comment
comment|/** sorts into ascending order (on demand), reusing memory along the way */
end_comment
begin_function
DECL|method|sortFields
specifier|private
name|void
name|sortFields
parameter_list|()
block|{
if|if
condition|(
name|sortedFields
operator|==
literal|null
condition|)
name|sortedFields
operator|=
name|sort
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/** returns a view of the given map's entries, sorted ascending by key */
end_comment
begin_function
DECL|method|sort
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|sort
parameter_list|(
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|int
name|size
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|entries
init|=
operator|new
name|Map
operator|.
name|Entry
index|[
name|size
index|]
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iter
init|=
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|entries
index|[
name|i
index|]
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
literal|1
condition|)
name|ArrayUtil
operator|.
name|quickSort
argument_list|(
name|entries
argument_list|,
name|termComparator
argument_list|)
expr_stmt|;
return|return
name|entries
return|;
block|}
end_function
begin_comment
comment|/**    * Returns a String representation of the index data for debugging purposes.    *     * @return the string representation    */
end_comment
begin_function
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|(
literal|256
argument_list|)
decl_stmt|;
name|sortFields
argument_list|()
expr_stmt|;
name|int
name|sumBytes
init|=
literal|0
decl_stmt|;
name|int
name|sumPositions
init|=
literal|0
decl_stmt|;
name|int
name|sumTerms
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedFields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Info
argument_list|>
name|entry
init|=
name|sortedFields
index|[
name|i
index|]
decl_stmt|;
name|String
name|fieldName
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Info
name|info
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|info
operator|.
name|sortTerms
argument_list|()
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|fieldName
operator|+
literal|":\n"
argument_list|)
expr_stmt|;
name|int
name|numBytes
init|=
literal|0
decl_stmt|;
name|int
name|numPositions
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|info
operator|.
name|sortedTerms
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|BytesRef
argument_list|,
name|ArrayIntList
argument_list|>
name|e
init|=
name|info
operator|.
name|sortedTerms
index|[
name|j
index|]
decl_stmt|;
name|BytesRef
name|term
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ArrayIntList
name|positions
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|"\t'"
operator|+
name|term
operator|+
literal|"':"
operator|+
name|numPositions
argument_list|(
name|positions
argument_list|)
operator|+
literal|":"
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|positions
operator|.
name|toString
argument_list|(
name|stride
argument_list|)
argument_list|)
expr_stmt|;
comment|// ignore offsets
name|result
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|numPositions
operator|+=
name|numPositions
argument_list|(
name|positions
argument_list|)
expr_stmt|;
name|numBytes
operator|+=
name|term
operator|.
name|length
expr_stmt|;
block|}
name|result
operator|.
name|append
argument_list|(
literal|"\tterms="
operator|+
name|info
operator|.
name|sortedTerms
operator|.
name|length
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|", positions="
operator|+
name|numPositions
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|", Kbytes="
operator|+
operator|(
name|numBytes
operator|/
literal|1000.0f
operator|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sumPositions
operator|+=
name|numPositions
expr_stmt|;
name|sumBytes
operator|+=
name|numBytes
expr_stmt|;
name|sumTerms
operator|+=
name|info
operator|.
name|sortedTerms
operator|.
name|length
expr_stmt|;
block|}
name|result
operator|.
name|append
argument_list|(
literal|"\nfields="
operator|+
name|sortedFields
operator|.
name|length
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|", terms="
operator|+
name|sumTerms
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|", positions="
operator|+
name|sumPositions
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|", Kbytes="
operator|+
operator|(
name|sumBytes
operator|/
literal|1000.0f
operator|)
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|// Nested classes:
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|/**    * Index data structure for a field; Contains the tokenized term texts and    * their positions.    */
end_comment
begin_class
DECL|class|Info
specifier|private
specifier|static
specifier|final
class|class
name|Info
block|{
comment|/**      * Term strings and their positions for this field: Map<String      * termText, ArrayIntList positions>      */
DECL|field|terms
specifier|private
specifier|final
name|HashMap
argument_list|<
name|BytesRef
argument_list|,
name|ArrayIntList
argument_list|>
name|terms
decl_stmt|;
comment|/** Terms sorted ascending by term text; computed on demand */
DECL|field|sortedTerms
specifier|private
specifier|transient
name|Map
operator|.
name|Entry
argument_list|<
name|BytesRef
argument_list|,
name|ArrayIntList
argument_list|>
index|[]
name|sortedTerms
decl_stmt|;
comment|/** Number of added tokens for this field */
DECL|field|numTokens
specifier|private
specifier|final
name|int
name|numTokens
decl_stmt|;
comment|/** Number of overlapping tokens for this field */
DECL|field|numOverlapTokens
specifier|private
specifier|final
name|int
name|numOverlapTokens
decl_stmt|;
comment|/** Boost factor for hits for this field */
DECL|field|boost
specifier|private
specifier|final
name|float
name|boost
decl_stmt|;
comment|/** Term for this field's fieldName, lazily computed on demand */
DECL|field|template
specifier|public
specifier|transient
name|Term
name|template
decl_stmt|;
DECL|field|sumTotalTermFreq
specifier|private
specifier|final
name|long
name|sumTotalTermFreq
decl_stmt|;
DECL|method|Info
specifier|public
name|Info
parameter_list|(
name|HashMap
argument_list|<
name|BytesRef
argument_list|,
name|ArrayIntList
argument_list|>
name|terms
parameter_list|,
name|int
name|numTokens
parameter_list|,
name|int
name|numOverlapTokens
parameter_list|,
name|float
name|boost
parameter_list|)
block|{
name|this
operator|.
name|terms
operator|=
name|terms
expr_stmt|;
name|this
operator|.
name|numTokens
operator|=
name|numTokens
expr_stmt|;
name|this
operator|.
name|numOverlapTokens
operator|=
name|numOverlapTokens
expr_stmt|;
name|this
operator|.
name|boost
operator|=
name|boost
expr_stmt|;
name|long
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|BytesRef
argument_list|,
name|ArrayIntList
argument_list|>
name|ent
range|:
name|terms
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|sum
operator|+=
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|sumTotalTermFreq
operator|=
name|sum
expr_stmt|;
block|}
DECL|method|getSumTotalTermFreq
specifier|public
name|long
name|getSumTotalTermFreq
parameter_list|()
block|{
return|return
name|sumTotalTermFreq
return|;
block|}
comment|/**      * Sorts hashed terms into ascending order, reusing memory along the      * way. Note that sorting is lazily delayed until required (often it's      * not required at all). If a sorted view is required then hashing +      * sort + binary search is still faster and smaller than TreeMap usage      * (which would be an alternative and somewhat more elegant approach,      * apart from more sophisticated Tries / prefix trees).      */
DECL|method|sortTerms
specifier|public
name|void
name|sortTerms
parameter_list|()
block|{
if|if
condition|(
name|sortedTerms
operator|==
literal|null
condition|)
name|sortedTerms
operator|=
name|sort
argument_list|(
name|terms
argument_list|)
expr_stmt|;
block|}
comment|/** note that the frequency can be calculated as numPosition(getPositions(x)) */
DECL|method|getPositions
specifier|public
name|ArrayIntList
name|getPositions
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
return|return
name|terms
operator|.
name|get
argument_list|(
name|term
argument_list|)
return|;
block|}
comment|/** note that the frequency can be calculated as numPosition(getPositions(x)) */
DECL|method|getPositions
specifier|public
name|ArrayIntList
name|getPositions
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
return|return
name|sortedTerms
index|[
name|pos
index|]
operator|.
name|getValue
argument_list|()
return|;
block|}
DECL|method|getBoost
specifier|public
name|float
name|getBoost
parameter_list|()
block|{
return|return
name|boost
return|;
block|}
block|}
end_class
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|// Nested classes:
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|/**    * Efficient resizable auto-expanding list holding<code>int</code> elements;    * implemented with arrays.    */
end_comment
begin_class
DECL|class|ArrayIntList
specifier|private
specifier|static
specifier|final
class|class
name|ArrayIntList
block|{
DECL|field|elements
specifier|private
name|int
index|[]
name|elements
decl_stmt|;
DECL|field|size
specifier|private
name|int
name|size
init|=
literal|0
decl_stmt|;
DECL|method|ArrayIntList
specifier|public
name|ArrayIntList
parameter_list|()
block|{
name|this
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
DECL|method|ArrayIntList
specifier|public
name|ArrayIntList
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
name|elements
operator|=
operator|new
name|int
index|[
name|initialCapacity
index|]
expr_stmt|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|int
name|elem
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
name|elements
operator|.
name|length
condition|)
name|ensureCapacity
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|elements
index|[
name|size
operator|++
index|]
operator|=
name|elem
expr_stmt|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
if|if
condition|(
name|size
operator|+
literal|3
operator|>
name|elements
operator|.
name|length
condition|)
name|ensureCapacity
argument_list|(
name|size
operator|+
literal|3
argument_list|)
expr_stmt|;
name|elements
index|[
name|size
index|]
operator|=
name|pos
expr_stmt|;
name|elements
index|[
name|size
operator|+
literal|1
index|]
operator|=
name|start
expr_stmt|;
name|elements
index|[
name|size
operator|+
literal|2
index|]
operator|=
name|end
expr_stmt|;
name|size
operator|+=
literal|3
expr_stmt|;
block|}
DECL|method|get
specifier|public
name|int
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|>=
name|size
condition|)
name|throwIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|elements
index|[
name|index
index|]
return|;
block|}
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
DECL|method|toArray
specifier|public
name|int
index|[]
name|toArray
parameter_list|(
name|int
name|stride
parameter_list|)
block|{
name|int
index|[]
name|arr
init|=
operator|new
name|int
index|[
name|size
argument_list|()
operator|/
name|stride
index|]
decl_stmt|;
if|if
condition|(
name|stride
operator|==
literal|1
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|elements
argument_list|,
literal|0
argument_list|,
name|arr
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|// fast path
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
name|stride
control|)
name|arr
index|[
name|i
index|]
operator|=
name|elements
index|[
name|j
index|]
expr_stmt|;
block|}
return|return
name|arr
return|;
block|}
DECL|method|ensureCapacity
specifier|private
name|void
name|ensureCapacity
parameter_list|(
name|int
name|minCapacity
parameter_list|)
block|{
name|int
name|newCapacity
init|=
name|Math
operator|.
name|max
argument_list|(
name|minCapacity
argument_list|,
operator|(
name|elements
operator|.
name|length
operator|*
literal|3
operator|)
operator|/
literal|2
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
index|[]
name|newElements
init|=
operator|new
name|int
index|[
name|newCapacity
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|elements
argument_list|,
literal|0
argument_list|,
name|newElements
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|elements
operator|=
name|newElements
expr_stmt|;
block|}
DECL|method|throwIndex
specifier|private
name|void
name|throwIndex
parameter_list|(
name|int
name|index
parameter_list|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"index: "
operator|+
name|index
operator|+
literal|", size: "
operator|+
name|size
argument_list|)
throw|;
block|}
comment|/** returns the first few positions (without offsets); debug only */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|(
name|int
name|stride
parameter_list|)
block|{
name|int
name|s
init|=
name|size
argument_list|()
operator|/
name|stride
decl_stmt|;
name|int
name|len
init|=
name|Math
operator|.
name|min
argument_list|(
literal|10
argument_list|,
name|s
argument_list|)
decl_stmt|;
comment|// avoid printing huge lists
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|4
operator|*
name|len
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|get
argument_list|(
name|i
operator|*
name|stride
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len
operator|-
literal|1
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
name|s
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|", ..."
argument_list|)
expr_stmt|;
comment|// and some more...
name|buf
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|// Nested classes:
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|/**    * Search support for Lucene framework integration; implements all methods    * required by the Lucene IndexReader contracts.    */
end_comment
begin_class
DECL|class|MemoryIndexReader
specifier|private
specifier|final
class|class
name|MemoryIndexReader
extends|extends
name|AtomicReader
block|{
DECL|field|searcher
specifier|private
name|IndexSearcher
name|searcher
decl_stmt|;
comment|// needed to find searcher.getSimilarity()
DECL|method|MemoryIndexReader
specifier|private
name|MemoryIndexReader
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
comment|// avoid as much superclass baggage as possible
block|}
DECL|method|getInfo
specifier|private
name|Info
name|getInfo
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
name|fields
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
DECL|method|getInfo
specifier|private
name|Info
name|getInfo
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
return|return
name|sortedFields
index|[
name|pos
index|]
operator|.
name|getValue
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getLiveDocs
specifier|public
name|Bits
name|getLiveDocs
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getFieldInfos
specifier|public
name|FieldInfos
name|getFieldInfos
parameter_list|()
block|{
return|return
name|fieldInfos
return|;
block|}
DECL|class|MemoryFields
specifier|private
class|class
name|MemoryFields
extends|extends
name|Fields
block|{
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|FieldsEnum
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|FieldsEnum
argument_list|()
block|{
name|int
name|upto
init|=
operator|-
literal|1
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|next
parameter_list|()
block|{
name|upto
operator|++
expr_stmt|;
if|if
condition|(
name|upto
operator|>=
name|sortedFields
operator|.
name|length
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|sortedFields
index|[
name|upto
index|]
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Terms
name|terms
parameter_list|()
block|{
return|return
name|MemoryFields
operator|.
name|this
operator|.
name|terms
argument_list|(
name|sortedFields
index|[
name|upto
index|]
operator|.
name|getKey
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|terms
specifier|public
name|Terms
name|terms
parameter_list|(
specifier|final
name|String
name|field
parameter_list|)
block|{
name|int
name|i
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|sortedFields
argument_list|,
name|field
argument_list|,
name|termComparator
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
specifier|final
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|info
operator|.
name|sortTerms
argument_list|()
expr_stmt|;
return|return
operator|new
name|Terms
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TermsEnum
name|iterator
parameter_list|(
name|TermsEnum
name|reuse
parameter_list|)
block|{
return|return
operator|new
name|MemoryTermsEnum
argument_list|(
name|info
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getUniqueTermCount
parameter_list|()
block|{
return|return
name|info
operator|.
name|sortedTerms
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getSumTotalTermFreq
parameter_list|()
block|{
return|return
name|info
operator|.
name|getSumTotalTermFreq
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getSumDocFreq
parameter_list|()
throws|throws
name|IOException
block|{
comment|// each term has df=1
return|return
name|info
operator|.
name|sortedTerms
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getDocCount
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|info
operator|.
name|sortedTerms
operator|.
name|length
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
return|;
block|}
block|}
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getUniqueFieldCount
specifier|public
name|int
name|getUniqueFieldCount
parameter_list|()
block|{
return|return
name|sortedFields
operator|.
name|length
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|fields
specifier|public
name|Fields
name|fields
parameter_list|()
block|{
name|sortFields
argument_list|()
expr_stmt|;
return|return
operator|new
name|MemoryFields
argument_list|()
return|;
block|}
DECL|class|MemoryTermsEnum
specifier|private
class|class
name|MemoryTermsEnum
extends|extends
name|TermsEnum
block|{
DECL|field|info
specifier|private
specifier|final
name|Info
name|info
decl_stmt|;
DECL|field|br
specifier|private
specifier|final
name|BytesRef
name|br
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
DECL|field|termUpto
name|int
name|termUpto
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|MemoryTermsEnum
specifier|public
name|MemoryTermsEnum
parameter_list|(
name|Info
name|info
parameter_list|)
block|{
name|this
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|info
operator|.
name|sortTerms
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|boolean
name|seekExact
parameter_list|(
name|BytesRef
name|text
parameter_list|,
name|boolean
name|useCache
parameter_list|)
block|{
name|termUpto
operator|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|info
operator|.
name|sortedTerms
argument_list|,
name|text
argument_list|,
name|termComparator
argument_list|)
expr_stmt|;
if|if
condition|(
name|termUpto
operator|>=
literal|0
condition|)
block|{
name|br
operator|.
name|copyBytes
argument_list|(
name|info
operator|.
name|sortedTerms
index|[
name|termUpto
index|]
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
name|BytesRef
name|text
parameter_list|,
name|boolean
name|useCache
parameter_list|)
block|{
name|termUpto
operator|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|info
operator|.
name|sortedTerms
argument_list|,
name|text
argument_list|,
name|termComparator
argument_list|)
expr_stmt|;
if|if
condition|(
name|termUpto
operator|<
literal|0
condition|)
block|{
comment|// not found; choose successor
name|termUpto
operator|=
operator|-
name|termUpto
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|termUpto
operator|>=
name|info
operator|.
name|sortedTerms
operator|.
name|length
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
else|else
block|{
name|br
operator|.
name|copyBytes
argument_list|(
name|info
operator|.
name|sortedTerms
index|[
name|termUpto
index|]
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
block|}
else|else
block|{
name|br
operator|.
name|copyBytes
argument_list|(
name|info
operator|.
name|sortedTerms
index|[
name|termUpto
index|]
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|ord
parameter_list|)
block|{
assert|assert
name|ord
operator|<
name|info
operator|.
name|sortedTerms
operator|.
name|length
assert|;
name|termUpto
operator|=
operator|(
name|int
operator|)
name|ord
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
block|{
name|termUpto
operator|++
expr_stmt|;
if|if
condition|(
name|termUpto
operator|>=
name|info
operator|.
name|sortedTerms
operator|.
name|length
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|br
operator|.
name|copyBytes
argument_list|(
name|info
operator|.
name|sortedTerms
index|[
name|termUpto
index|]
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|br
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
block|{
return|return
name|br
return|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
block|{
return|return
name|termUpto
return|;
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
block|{
return|return
name|info
operator|.
name|sortedTerms
index|[
name|termUpto
index|]
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|boolean
name|needsFreqs
parameter_list|)
block|{
if|if
condition|(
name|reuse
operator|==
literal|null
operator|||
operator|!
operator|(
name|reuse
operator|instanceof
name|MemoryDocsEnum
operator|)
condition|)
block|{
name|reuse
operator|=
operator|new
name|MemoryDocsEnum
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|MemoryDocsEnum
operator|)
name|reuse
operator|)
operator|.
name|reset
argument_list|(
name|liveDocs
argument_list|,
name|info
operator|.
name|sortedTerms
index|[
name|termUpto
index|]
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|,
name|boolean
name|needsOffsets
parameter_list|)
block|{
if|if
condition|(
name|needsOffsets
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|reuse
operator|==
literal|null
operator|||
operator|!
operator|(
name|reuse
operator|instanceof
name|MemoryDocsAndPositionsEnum
operator|)
condition|)
block|{
name|reuse
operator|=
operator|new
name|MemoryDocsAndPositionsEnum
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|MemoryDocsAndPositionsEnum
operator|)
name|reuse
operator|)
operator|.
name|reset
argument_list|(
name|liveDocs
argument_list|,
name|info
operator|.
name|sortedTerms
index|[
name|termUpto
index|]
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|BytesRef
name|term
parameter_list|,
name|TermState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|state
operator|!=
literal|null
assert|;
name|this
operator|.
name|seekExact
argument_list|(
operator|(
operator|(
name|OrdTermState
operator|)
name|state
operator|)
operator|.
name|ord
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|termState
specifier|public
name|TermState
name|termState
parameter_list|()
throws|throws
name|IOException
block|{
name|OrdTermState
name|ts
init|=
operator|new
name|OrdTermState
argument_list|()
decl_stmt|;
name|ts
operator|.
name|ord
operator|=
name|termUpto
expr_stmt|;
return|return
name|ts
return|;
block|}
block|}
DECL|class|MemoryDocsEnum
specifier|private
class|class
name|MemoryDocsEnum
extends|extends
name|DocsEnum
block|{
DECL|field|positions
specifier|private
name|ArrayIntList
name|positions
decl_stmt|;
DECL|field|hasNext
specifier|private
name|boolean
name|hasNext
decl_stmt|;
DECL|field|liveDocs
specifier|private
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|doc
specifier|private
name|int
name|doc
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|reset
specifier|public
name|DocsEnum
name|reset
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|ArrayIntList
name|positions
parameter_list|)
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
name|this
operator|.
name|positions
operator|=
name|positions
expr_stmt|;
name|hasNext
operator|=
literal|true
expr_stmt|;
name|doc
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
block|{
if|if
condition|(
name|hasNext
operator|&&
operator|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
block|{
name|hasNext
operator|=
literal|false
expr_stmt|;
return|return
name|doc
operator|=
literal|0
return|;
block|}
else|else
block|{
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
block|{
return|return
name|nextDoc
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
block|{
return|return
name|positions
operator|.
name|size
argument_list|()
return|;
block|}
block|}
DECL|class|MemoryDocsAndPositionsEnum
specifier|private
class|class
name|MemoryDocsAndPositionsEnum
extends|extends
name|DocsAndPositionsEnum
block|{
DECL|field|positions
specifier|private
name|ArrayIntList
name|positions
decl_stmt|;
DECL|field|posUpto
specifier|private
name|int
name|posUpto
decl_stmt|;
DECL|field|hasNext
specifier|private
name|boolean
name|hasNext
decl_stmt|;
DECL|field|liveDocs
specifier|private
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|doc
specifier|private
name|int
name|doc
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|reset
specifier|public
name|DocsAndPositionsEnum
name|reset
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|ArrayIntList
name|positions
parameter_list|)
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
name|this
operator|.
name|positions
operator|=
name|positions
expr_stmt|;
name|posUpto
operator|=
literal|0
expr_stmt|;
name|hasNext
operator|=
literal|true
expr_stmt|;
name|doc
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
block|{
if|if
condition|(
name|hasNext
operator|&&
operator|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
block|{
name|hasNext
operator|=
literal|false
expr_stmt|;
return|return
name|doc
operator|=
literal|0
return|;
block|}
else|else
block|{
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
block|{
return|return
name|nextDoc
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
block|{
return|return
name|positions
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|nextPosition
specifier|public
name|int
name|nextPosition
parameter_list|()
block|{
return|return
name|positions
operator|.
name|get
argument_list|(
name|posUpto
operator|++
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|startOffset
specifier|public
name|int
name|startOffset
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|endOffset
specifier|public
name|int
name|endOffset
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|hasPayload
specifier|public
name|boolean
name|hasPayload
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|getPayload
specifier|public
name|BytesRef
name|getPayload
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getTermVectors
specifier|public
name|Fields
name|getTermVectors
parameter_list|(
name|int
name|docID
parameter_list|)
block|{
if|if
condition|(
name|docID
operator|==
literal|0
condition|)
block|{
return|return
name|fields
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
DECL|method|getSimilarity
specifier|private
name|Similarity
name|getSimilarity
parameter_list|()
block|{
if|if
condition|(
name|searcher
operator|!=
literal|null
condition|)
return|return
name|searcher
operator|.
name|getSimilarity
argument_list|()
return|;
return|return
name|IndexSearcher
operator|.
name|getDefaultSimilarity
argument_list|()
return|;
block|}
DECL|method|setSearcher
specifier|private
name|void
name|setSearcher
parameter_list|(
name|IndexSearcher
name|searcher
parameter_list|)
block|{
name|this
operator|.
name|searcher
operator|=
name|searcher
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|numDocs
specifier|public
name|int
name|numDocs
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.numDocs"
argument_list|)
expr_stmt|;
return|return
name|fields
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|maxDoc
specifier|public
name|int
name|maxDoc
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.maxDoc"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|document
specifier|public
name|void
name|document
parameter_list|(
name|int
name|docID
parameter_list|,
name|StoredFieldVisitor
name|visitor
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.document"
argument_list|)
expr_stmt|;
comment|// no-op: there are no stored fields
block|}
annotation|@
name|Override
DECL|method|hasDeletions
specifier|public
name|boolean
name|hasDeletions
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.hasDeletions"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|doClose
specifier|protected
name|void
name|doClose
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.doClose"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|docValues
specifier|public
name|DocValues
name|docValues
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|null
return|;
block|}
comment|/** performance hack: cache norms to avoid repeated expensive calculations */
DECL|field|cachedNormValues
specifier|private
name|DocValues
name|cachedNormValues
decl_stmt|;
DECL|field|cachedFieldName
specifier|private
name|String
name|cachedFieldName
decl_stmt|;
DECL|field|cachedSimilarity
specifier|private
name|Similarity
name|cachedSimilarity
decl_stmt|;
annotation|@
name|Override
DECL|method|normValues
specifier|public
name|DocValues
name|normValues
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
name|DocValues
name|norms
init|=
name|cachedNormValues
decl_stmt|;
name|Similarity
name|sim
init|=
name|getSimilarity
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|field
operator|.
name|equals
argument_list|(
name|cachedFieldName
argument_list|)
operator|||
name|sim
operator|!=
name|cachedSimilarity
condition|)
block|{
comment|// not cached?
name|Info
name|info
init|=
name|getInfo
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|int
name|numTokens
init|=
name|info
operator|!=
literal|null
condition|?
name|info
operator|.
name|numTokens
else|:
literal|0
decl_stmt|;
name|int
name|numOverlapTokens
init|=
name|info
operator|!=
literal|null
condition|?
name|info
operator|.
name|numOverlapTokens
else|:
literal|0
decl_stmt|;
name|float
name|boost
init|=
name|info
operator|!=
literal|null
condition|?
name|info
operator|.
name|getBoost
argument_list|()
else|:
literal|1.0f
decl_stmt|;
name|FieldInvertState
name|invertState
init|=
operator|new
name|FieldInvertState
argument_list|(
name|field
argument_list|,
literal|0
argument_list|,
name|numTokens
argument_list|,
name|numOverlapTokens
argument_list|,
literal|0
argument_list|,
name|boost
argument_list|)
decl_stmt|;
name|Norm
name|norm
init|=
operator|new
name|Norm
argument_list|()
decl_stmt|;
name|sim
operator|.
name|computeNorm
argument_list|(
name|invertState
argument_list|,
name|norm
argument_list|)
expr_stmt|;
name|SingleValueSource
name|singleByteSource
init|=
operator|new
name|SingleValueSource
argument_list|(
name|norm
argument_list|)
decl_stmt|;
name|norms
operator|=
operator|new
name|MemoryIndexNormDocValues
argument_list|(
name|singleByteSource
argument_list|)
expr_stmt|;
comment|// cache it for future reuse
name|cachedNormValues
operator|=
name|norms
expr_stmt|;
name|cachedFieldName
operator|=
name|field
expr_stmt|;
name|cachedSimilarity
operator|=
name|sim
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"MemoryIndexReader.norms: "
operator|+
name|field
operator|+
literal|":"
operator|+
name|norm
operator|+
literal|":"
operator|+
name|numTokens
argument_list|)
expr_stmt|;
block|}
return|return
name|norms
return|;
block|}
block|}
end_class
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|// Nested classes:
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_class
DECL|class|VM
specifier|private
specifier|static
specifier|final
class|class
name|VM
block|{
DECL|field|PTR
specifier|public
specifier|static
specifier|final
name|int
name|PTR
init|=
name|Constants
operator|.
name|JRE_IS_64BIT
condition|?
literal|8
else|:
literal|4
decl_stmt|;
comment|// bytes occupied by primitive data types
DECL|field|BOOLEAN
specifier|public
specifier|static
specifier|final
name|int
name|BOOLEAN
init|=
literal|1
decl_stmt|;
DECL|field|BYTE
specifier|public
specifier|static
specifier|final
name|int
name|BYTE
init|=
literal|1
decl_stmt|;
DECL|field|CHAR
specifier|public
specifier|static
specifier|final
name|int
name|CHAR
init|=
literal|2
decl_stmt|;
DECL|field|SHORT
specifier|public
specifier|static
specifier|final
name|int
name|SHORT
init|=
literal|2
decl_stmt|;
DECL|field|INT
specifier|public
specifier|static
specifier|final
name|int
name|INT
init|=
literal|4
decl_stmt|;
DECL|field|LONG
specifier|public
specifier|static
specifier|final
name|int
name|LONG
init|=
literal|8
decl_stmt|;
DECL|field|FLOAT
specifier|public
specifier|static
specifier|final
name|int
name|FLOAT
init|=
literal|4
decl_stmt|;
DECL|field|DOUBLE
specifier|public
specifier|static
specifier|final
name|int
name|DOUBLE
init|=
literal|8
decl_stmt|;
DECL|field|LOG_PTR
specifier|private
specifier|static
specifier|final
name|int
name|LOG_PTR
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|round
argument_list|(
name|log2
argument_list|(
name|PTR
argument_list|)
argument_list|)
decl_stmt|;
comment|/**      * Object header of any heap allocated Java object.       * ptr to class, info for monitor, gc, hash, etc.      */
DECL|field|OBJECT_HEADER
specifier|private
specifier|static
specifier|final
name|int
name|OBJECT_HEADER
init|=
literal|2
operator|*
name|PTR
decl_stmt|;
DECL|method|VM
specifier|private
name|VM
parameter_list|()
block|{}
comment|// not instantiable
comment|//  assumes n> 0
comment|//  64 bit VM:
comment|//    0     --> 0*PTR
comment|//    1..8  --> 1*PTR
comment|//    9..16 --> 2*PTR
DECL|method|sizeOf
specifier|private
specifier|static
name|int
name|sizeOf
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|n
operator|-
literal|1
operator|)
operator|>>
name|LOG_PTR
operator|)
operator|+
literal|1
operator|)
operator|<<
name|LOG_PTR
return|;
block|}
DECL|method|sizeOfObject
specifier|public
specifier|static
name|int
name|sizeOfObject
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
name|sizeOf
argument_list|(
name|OBJECT_HEADER
operator|+
name|n
argument_list|)
return|;
block|}
DECL|method|sizeOfObjectArray
specifier|public
specifier|static
name|int
name|sizeOfObjectArray
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|sizeOfObject
argument_list|(
name|INT
operator|+
name|PTR
operator|*
name|len
argument_list|)
return|;
block|}
DECL|method|sizeOfCharArray
specifier|public
specifier|static
name|int
name|sizeOfCharArray
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|sizeOfObject
argument_list|(
name|INT
operator|+
name|CHAR
operator|*
name|len
argument_list|)
return|;
block|}
DECL|method|sizeOfIntArray
specifier|public
specifier|static
name|int
name|sizeOfIntArray
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|sizeOfObject
argument_list|(
name|INT
operator|+
name|INT
operator|*
name|len
argument_list|)
return|;
block|}
DECL|method|sizeOfString
specifier|public
specifier|static
name|int
name|sizeOfString
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|sizeOfObject
argument_list|(
literal|3
operator|*
name|INT
operator|+
name|PTR
argument_list|)
operator|+
name|sizeOfCharArray
argument_list|(
name|len
argument_list|)
return|;
block|}
DECL|method|sizeOfHashMap
specifier|public
specifier|static
name|int
name|sizeOfHashMap
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|sizeOfObject
argument_list|(
literal|4
operator|*
name|PTR
operator|+
literal|4
operator|*
name|INT
argument_list|)
operator|+
name|sizeOfObjectArray
argument_list|(
name|len
argument_list|)
operator|+
name|len
operator|*
name|sizeOfObject
argument_list|(
literal|3
operator|*
name|PTR
operator|+
name|INT
argument_list|)
return|;
comment|// entries
block|}
comment|// note: does not include referenced objects
DECL|method|sizeOfArrayList
specifier|public
specifier|static
name|int
name|sizeOfArrayList
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|sizeOfObject
argument_list|(
name|PTR
operator|+
literal|2
operator|*
name|INT
argument_list|)
operator|+
name|sizeOfObjectArray
argument_list|(
name|len
argument_list|)
return|;
block|}
DECL|method|sizeOfArrayIntList
specifier|public
specifier|static
name|int
name|sizeOfArrayIntList
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|sizeOfObject
argument_list|(
name|PTR
operator|+
name|INT
argument_list|)
operator|+
name|sizeOfIntArray
argument_list|(
name|len
argument_list|)
return|;
block|}
comment|/** logarithm to the base 2. Example: log2(4) == 2, log2(8) == 3 */
DECL|method|log2
specifier|private
specifier|static
name|double
name|log2
parameter_list|(
name|double
name|value
parameter_list|)
block|{
return|return
name|Math
operator|.
name|log
argument_list|(
name|value
argument_list|)
operator|/
name|Math
operator|.
name|log
argument_list|(
literal|2
argument_list|)
return|;
block|}
block|}
end_class
unit|}
end_unit
