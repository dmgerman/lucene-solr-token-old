begin_unit
begin_package
DECL|package|org.apache.lucene.replicator.nrt
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|replicator
operator|.
name|nrt
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFileNames
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|SearcherFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|BufferedChecksumIndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayIndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Lock
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_comment
comment|/** Replica node, that pulls index changes from the primary node by copying newly flushed or merged index files */
end_comment
begin_class
DECL|class|ReplicaNode
specifier|abstract
class|class
name|ReplicaNode
extends|extends
name|Node
block|{
DECL|field|deleter
name|ReplicaFileDeleter
name|deleter
decl_stmt|;
comment|/** IncRef'd files in the current commit point: */
DECL|field|lastCommitFiles
specifier|private
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|lastCommitFiles
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** IncRef'd files in the current NRT point: */
DECL|field|lastNRTFiles
specifier|protected
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|lastNRTFiles
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Currently running merge pre-copy jobs */
DECL|field|mergeCopyJobs
specifier|protected
specifier|final
name|Set
argument_list|<
name|CopyJob
argument_list|>
name|mergeCopyJobs
init|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Non-null when we are currently copying files from a new NRT point: */
DECL|field|curNRTCopy
specifier|protected
name|CopyJob
name|curNRTCopy
decl_stmt|;
comment|/** We hold this to ensure an external IndexWriter cannot also open on our directory: */
DECL|field|writeFileLock
specifier|private
specifier|final
name|Lock
name|writeFileLock
decl_stmt|;
comment|/** Merged segment files that we pre-copied, but have not yet made visible in a new NRT point. */
DECL|field|pendingMergeFiles
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|pendingMergeFiles
init|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Primary gen last time we successfully replicated: */
DECL|field|lastPrimaryGen
specifier|protected
name|long
name|lastPrimaryGen
decl_stmt|;
DECL|method|ReplicaNode
specifier|public
name|ReplicaNode
parameter_list|(
name|int
name|id
parameter_list|,
name|Directory
name|dir
parameter_list|,
name|SearcherFactory
name|searcherFactory
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|id
argument_list|,
name|dir
argument_list|,
name|searcherFactory
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|instanceof
name|FSDirectory
operator|&&
operator|(
operator|(
name|FSDirectory
operator|)
name|dir
operator|)
operator|.
name|checkPendingDeletions
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Directory "
operator|+
name|dir
operator|+
literal|" still has pending deleted files; cannot initialize IndexWriter"
argument_list|)
throw|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|message
argument_list|(
literal|"top: init replica dir="
operator|+
name|dir
argument_list|)
expr_stmt|;
comment|// Obtain a write lock on this index since we "act like" an IndexWriter, to prevent any other IndexWriter or ReplicaNode from using it:
name|writeFileLock
operator|=
name|dir
operator|.
name|obtainLock
argument_list|(
name|IndexWriter
operator|.
name|WRITE_LOCK_NAME
argument_list|)
expr_stmt|;
name|state
operator|=
literal|"init"
expr_stmt|;
name|deleter
operator|=
operator|new
name|ReplicaFileDeleter
argument_list|(
name|this
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|message
argument_list|(
literal|"exc on init:"
argument_list|)
expr_stmt|;
name|t
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */
DECL|method|start
specifier|protected
specifier|synchronized
name|void
name|start
parameter_list|(
name|long
name|curPrimaryGen
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|state
operator|.
name|equals
argument_list|(
literal|"init"
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"already started"
argument_list|)
throw|;
block|}
name|message
argument_list|(
literal|"top: now start"
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Figure out what state our local index is in now:
name|String
name|segmentsFileName
init|=
name|SegmentInfos
operator|.
name|getLastCommitSegmentsFileName
argument_list|(
name|dir
argument_list|)
decl_stmt|;
comment|// Also look for any pending_segments_N, in case we crashed mid-commit.  We must "inflate" our infos gen to at least this, since
comment|// otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still
comment|// wants to delete this file:
name|long
name|maxPendingGen
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|String
name|fileName
range|:
name|dir
operator|.
name|listAll
argument_list|()
control|)
block|{
if|if
condition|(
name|fileName
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|PENDING_SEGMENTS
argument_list|)
condition|)
block|{
name|long
name|gen
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|fileName
operator|.
name|substring
argument_list|(
name|IndexFileNames
operator|.
name|PENDING_SEGMENTS
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
decl_stmt|;
if|if
condition|(
name|gen
operator|>
name|maxPendingGen
condition|)
block|{
name|maxPendingGen
operator|=
name|gen
expr_stmt|;
block|}
block|}
block|}
name|SegmentInfos
name|infos
decl_stmt|;
if|if
condition|(
name|segmentsFileName
operator|==
literal|null
condition|)
block|{
comment|// No index here yet:
name|infos
operator|=
operator|new
name|SegmentInfos
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"top: init: no segments in index"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"top: init: read existing segments commit "
operator|+
name|segmentsFileName
argument_list|)
expr_stmt|;
name|infos
operator|=
name|SegmentInfos
operator|.
name|readCommit
argument_list|(
name|dir
argument_list|,
name|segmentsFileName
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: init: segments: "
operator|+
name|infos
operator|.
name|toString
argument_list|()
operator|+
literal|" version="
operator|+
name|infos
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|indexFiles
init|=
name|infos
operator|.
name|files
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|lastCommitFiles
operator|.
name|add
argument_list|(
name|segmentsFileName
argument_list|)
expr_stmt|;
name|lastCommitFiles
operator|.
name|addAll
argument_list|(
name|indexFiles
argument_list|)
expr_stmt|;
comment|// Always protect the last commit:
name|deleter
operator|.
name|incRef
argument_list|(
name|lastCommitFiles
argument_list|)
expr_stmt|;
name|lastNRTFiles
operator|.
name|addAll
argument_list|(
name|indexFiles
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|incRef
argument_list|(
name|lastNRTFiles
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: commitFiles="
operator|+
name|lastCommitFiles
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: nrtFiles="
operator|+
name|lastNRTFiles
argument_list|)
expr_stmt|;
block|}
name|message
argument_list|(
literal|"top: delete unknown files on init: all files="
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|dir
operator|.
name|listAll
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|deleteUnknownFiles
argument_list|(
name|segmentsFileName
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: done delete unknown files on init: all files="
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|dir
operator|.
name|listAll
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|s
init|=
name|infos
operator|.
name|getUserData
argument_list|()
operator|.
name|get
argument_list|(
name|PRIMARY_GEN_KEY
argument_list|)
decl_stmt|;
name|long
name|myPrimaryGen
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
assert|assert
name|infos
operator|.
name|size
argument_list|()
operator|==
literal|0
assert|;
name|myPrimaryGen
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|myPrimaryGen
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|message
argument_list|(
literal|"top: myPrimaryGen="
operator|+
name|myPrimaryGen
argument_list|)
expr_stmt|;
name|boolean
name|doCommit
decl_stmt|;
if|if
condition|(
name|infos
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|myPrimaryGen
operator|!=
operator|-
literal|1
operator|&&
name|myPrimaryGen
operator|!=
name|curPrimaryGen
condition|)
block|{
assert|assert
name|myPrimaryGen
operator|<
name|curPrimaryGen
assert|;
comment|// Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current
comment|// files we have will need to be overwritten with different ones (if index rolled back and "forked"), and we can't overwrite open
comment|// files on Windows:
specifier|final
name|long
name|initSyncStartNS
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|message
argument_list|(
literal|"top: init: primary changed while we were down myPrimaryGen="
operator|+
name|myPrimaryGen
operator|+
literal|" vs curPrimaryGen="
operator|+
name|curPrimaryGen
operator|+
literal|"; sync now before mgr init"
argument_list|)
expr_stmt|;
comment|// Try until we succeed in copying over the latest NRT point:
name|CopyJob
name|job
init|=
literal|null
decl_stmt|;
comment|// We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make
comment|// sure the index is never even in an "apparently" corrupt state (where an old segments_N references invalid files) we forcefully
comment|// remove the commit now, and refuse to start the replica if this delete fails:
name|message
argument_list|(
literal|"top: now delete starting commit point "
operator|+
name|segmentsFileName
argument_list|)
expr_stmt|;
comment|// If this throws exc (e.g. due to virus checker), we cannot start this replica:
assert|assert
name|deleter
operator|.
name|getRefCount
argument_list|(
name|segmentsFileName
argument_list|)
operator|==
literal|1
assert|;
name|deleter
operator|.
name|decRef
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|segmentsFileName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleter
operator|.
name|isPending
argument_list|(
name|segmentsFileName
argument_list|)
condition|)
block|{
comment|// If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else we can cause corruption:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"replica cannot start: existing segments file="
operator|+
name|segmentsFileName
operator|+
literal|" must be removed in order to start, but the file delete failed"
argument_list|)
throw|;
block|}
comment|// So we don't later try to decRef it (illegally) again:
name|boolean
name|didRemove
init|=
name|lastCommitFiles
operator|.
name|remove
argument_list|(
name|segmentsFileName
argument_list|)
decl_stmt|;
assert|assert
name|didRemove
assert|;
while|while
condition|(
literal|true
condition|)
block|{
name|job
operator|=
name|newCopyJob
argument_list|(
literal|"sync on startup replica="
operator|+
name|name
argument_list|()
operator|+
literal|" myVersion="
operator|+
name|infos
operator|.
name|getVersion
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|job
operator|.
name|start
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"top: init: sync sis.version="
operator|+
name|job
operator|.
name|getCopyState
argument_list|()
operator|.
name|version
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|fileNamesToCopy
init|=
name|job
operator|.
name|getFileNamesToCopy
argument_list|()
decl_stmt|;
comment|// Force this copy job to finish while we wait, now.  Note that this can be very time consuming!
comment|// NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens
try|try
block|{
name|job
operator|.
name|runBlocking
argument_list|()
expr_stmt|;
name|job
operator|.
name|finish
argument_list|()
expr_stmt|;
comment|// Success!
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|job
operator|.
name|cancel
argument_list|(
literal|"startup failed"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioe
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"checksum mismatch after file copy"
argument_list|)
condition|)
block|{
comment|// OK-ish
name|message
argument_list|(
literal|"top: failed to copy: "
operator|+
name|ioe
operator|+
literal|"; retrying"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|ioe
throw|;
block|}
block|}
block|}
name|lastPrimaryGen
operator|=
name|job
operator|.
name|getCopyState
argument_list|()
operator|.
name|primaryGen
expr_stmt|;
name|byte
index|[]
name|infosBytes
init|=
name|job
operator|.
name|getCopyState
argument_list|()
operator|.
name|infosBytes
decl_stmt|;
name|SegmentInfos
name|syncInfos
init|=
name|SegmentInfos
operator|.
name|readCommit
argument_list|(
name|dir
argument_list|,
operator|new
name|BufferedChecksumIndexInput
argument_list|(
operator|new
name|ByteArrayIndexInput
argument_list|(
literal|"SegmentInfos"
argument_list|,
name|job
operator|.
name|getCopyState
argument_list|()
operator|.
name|infosBytes
argument_list|)
argument_list|)
argument_list|,
name|job
operator|.
name|getCopyState
argument_list|()
operator|.
name|gen
argument_list|)
decl_stmt|;
comment|// Must always commit to a larger generation than what's currently in the index:
name|syncInfos
operator|.
name|updateGeneration
argument_list|(
name|infos
argument_list|)
expr_stmt|;
name|infos
operator|=
name|syncInfos
expr_stmt|;
assert|assert
name|infos
operator|.
name|getVersion
argument_list|()
operator|==
name|job
operator|.
name|getCopyState
argument_list|()
operator|.
name|version
assert|;
name|message
argument_list|(
literal|"  version="
operator|+
name|infos
operator|.
name|getVersion
argument_list|()
operator|+
literal|" segments="
operator|+
name|infos
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: init: incRef nrtFiles="
operator|+
name|job
operator|.
name|getFileNames
argument_list|()
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|incRef
argument_list|(
name|job
operator|.
name|getFileNames
argument_list|()
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: init: decRef lastNRTFiles="
operator|+
name|lastNRTFiles
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|decRef
argument_list|(
name|lastNRTFiles
argument_list|)
expr_stmt|;
name|lastNRTFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
name|lastNRTFiles
operator|.
name|addAll
argument_list|(
name|job
operator|.
name|getFileNames
argument_list|()
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: init: set lastNRTFiles="
operator|+
name|lastNRTFiles
argument_list|)
expr_stmt|;
name|lastFileMetaData
operator|=
name|job
operator|.
name|getCopyState
argument_list|()
operator|.
name|files
expr_stmt|;
name|message
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d"
argument_list|,
name|id
argument_list|,
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|initSyncStartNS
operator|)
operator|/
literal|1000000000.0
argument_list|,
name|bytesToString
argument_list|(
name|job
operator|.
name|getTotalBytesCopied
argument_list|()
argument_list|)
argument_list|,
name|job
operator|.
name|getCopyState
argument_list|()
operator|.
name|version
argument_list|)
argument_list|)
expr_stmt|;
name|doCommit
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|doCommit
operator|=
literal|false
expr_stmt|;
name|lastPrimaryGen
operator|=
name|curPrimaryGen
expr_stmt|;
name|message
argument_list|(
literal|"top: same primary as before"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|infos
operator|.
name|getGeneration
argument_list|()
operator|<
name|maxPendingGen
condition|)
block|{
name|message
argument_list|(
literal|"top: move infos generation from "
operator|+
name|infos
operator|.
name|getGeneration
argument_list|()
operator|+
literal|" to "
operator|+
name|maxPendingGen
argument_list|)
expr_stmt|;
name|infos
operator|.
name|setNextWriteGeneration
argument_list|(
name|maxPendingGen
argument_list|)
expr_stmt|;
block|}
comment|// Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:
name|sendNewReplica
argument_list|()
expr_stmt|;
comment|// Finally, we are open for business, since our index now "agrees" with the primary:
name|mgr
operator|=
operator|new
name|SegmentInfosSearcherManager
argument_list|(
name|dir
argument_list|,
name|this
argument_list|,
name|infos
argument_list|,
name|searcherFactory
argument_list|)
expr_stmt|;
name|IndexSearcher
name|searcher
init|=
name|mgr
operator|.
name|acquire
argument_list|()
decl_stmt|;
try|try
block|{
comment|// TODO: this is test specific:
name|int
name|hitCount
init|=
name|searcher
operator|.
name|count
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"marker"
argument_list|,
literal|"marker"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|message
argument_list|(
literal|"top: marker count="
operator|+
name|hitCount
operator|+
literal|" version="
operator|+
operator|(
operator|(
name|DirectoryReader
operator|)
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|)
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|mgr
operator|.
name|release
argument_list|(
name|searcher
argument_list|)
expr_stmt|;
block|}
comment|// Must commit after init mgr:
if|if
condition|(
name|doCommit
condition|)
block|{
comment|// Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to
comment|// overwrite any files it referenced:
name|commit
argument_list|()
expr_stmt|;
block|}
name|message
argument_list|(
literal|"top: done start"
argument_list|)
expr_stmt|;
name|state
operator|=
literal|"idle"
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|.
name|getMessage
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"replica cannot start"
argument_list|)
operator|==
literal|false
condition|)
block|{
name|message
argument_list|(
literal|"exc on start:"
argument_list|)
expr_stmt|;
name|t
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|IOUtils
operator|.
name|reThrow
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|commitLock
specifier|final
name|Object
name|commitLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|commit
specifier|public
name|void
name|commit
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|commitLock
init|)
block|{
name|SegmentInfos
name|infos
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|indexFiles
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|infos
operator|=
operator|(
operator|(
name|SegmentInfosSearcherManager
operator|)
name|mgr
operator|)
operator|.
name|getCurrentInfos
argument_list|()
expr_stmt|;
name|indexFiles
operator|=
name|infos
operator|.
name|files
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|incRef
argument_list|(
name|indexFiles
argument_list|)
expr_stmt|;
block|}
name|message
argument_list|(
literal|"top: commit primaryGen="
operator|+
name|lastPrimaryGen
operator|+
literal|" infos="
operator|+
name|infos
operator|.
name|toString
argument_list|()
operator|+
literal|" files="
operator|+
name|indexFiles
argument_list|)
expr_stmt|;
comment|// fsync all index files we are now referencing
name|dir
operator|.
name|sync
argument_list|(
name|indexFiles
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commitData
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|commitData
operator|.
name|put
argument_list|(
name|PRIMARY_GEN_KEY
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|lastPrimaryGen
argument_list|)
argument_list|)
expr_stmt|;
name|commitData
operator|.
name|put
argument_list|(
name|VERSION_KEY
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|getCurrentSearchingVersion
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|infos
operator|.
name|setUserData
argument_list|(
name|commitData
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// write and fsync a new segments_N
name|infos
operator|.
name|commit
argument_list|(
name|dir
argument_list|)
expr_stmt|;
comment|// Notify current infos (which may have changed while we were doing dir.sync above) what generation we are up to; this way future
comment|// commits are guaranteed to go to the next (unwritten) generations:
if|if
condition|(
name|mgr
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|SegmentInfosSearcherManager
operator|)
name|mgr
operator|)
operator|.
name|getCurrentInfos
argument_list|()
operator|.
name|updateGeneration
argument_list|(
name|infos
argument_list|)
expr_stmt|;
block|}
name|String
name|segmentsFileName
init|=
name|infos
operator|.
name|getSegmentsFileName
argument_list|()
decl_stmt|;
name|message
argument_list|(
literal|"top: commit wrote segments file "
operator|+
name|segmentsFileName
operator|+
literal|" version="
operator|+
name|infos
operator|.
name|getVersion
argument_list|()
operator|+
literal|" sis="
operator|+
name|infos
operator|.
name|toString
argument_list|()
operator|+
literal|" commitData="
operator|+
name|commitData
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|incRef
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|segmentsFileName
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: commit decRef lastCommitFiles="
operator|+
name|lastCommitFiles
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|decRef
argument_list|(
name|lastCommitFiles
argument_list|)
expr_stmt|;
name|lastCommitFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
name|lastCommitFiles
operator|.
name|addAll
argument_list|(
name|indexFiles
argument_list|)
expr_stmt|;
name|lastCommitFiles
operator|.
name|add
argument_list|(
name|segmentsFileName
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: commit version="
operator|+
name|infos
operator|.
name|getVersion
argument_list|()
operator|+
literal|" files now "
operator|+
name|lastCommitFiles
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|finishNRTCopy
name|void
name|finishNRTCopy
parameter_list|(
name|CopyJob
name|job
parameter_list|,
name|long
name|startNS
parameter_list|)
throws|throws
name|IOException
block|{
name|CopyState
name|copyState
init|=
name|job
operator|.
name|getCopyState
argument_list|()
decl_stmt|;
name|message
argument_list|(
literal|"top: finishNRTCopy: version="
operator|+
name|copyState
operator|.
name|version
operator|+
operator|(
name|job
operator|.
name|getFailed
argument_list|()
condition|?
literal|" FAILED"
else|:
literal|""
operator|)
operator|+
literal|" job="
operator|+
name|job
argument_list|)
expr_stmt|;
comment|// NOTE: if primary crashed while we were still copying then the job will hit an exc trying to read bytes for the files from the primary node,
comment|// and the job will be marked as failed here:
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
literal|"syncing"
operator|.
name|equals
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|state
operator|=
literal|"idle"
expr_stmt|;
block|}
if|if
condition|(
name|curNRTCopy
operator|==
name|job
condition|)
block|{
name|message
argument_list|(
literal|"top: now clear curNRTCopy; job="
operator|+
name|job
argument_list|)
expr_stmt|;
name|curNRTCopy
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|job
operator|.
name|getFailed
argument_list|()
assert|;
name|message
argument_list|(
literal|"top: skip clear curNRTCopy: we were cancelled; job="
operator|+
name|job
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|job
operator|.
name|getFailed
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// Does final file renames:
name|job
operator|.
name|finish
argument_list|()
expr_stmt|;
comment|// Turn byte[] back to SegmentInfos:
name|byte
index|[]
name|infosBytes
init|=
name|copyState
operator|.
name|infosBytes
decl_stmt|;
name|SegmentInfos
name|infos
init|=
name|SegmentInfos
operator|.
name|readCommit
argument_list|(
name|dir
argument_list|,
operator|new
name|BufferedChecksumIndexInput
argument_list|(
operator|new
name|ByteArrayIndexInput
argument_list|(
literal|"SegmentInfos"
argument_list|,
name|copyState
operator|.
name|infosBytes
argument_list|)
argument_list|)
argument_list|,
name|copyState
operator|.
name|gen
argument_list|)
decl_stmt|;
assert|assert
name|infos
operator|.
name|getVersion
argument_list|()
operator|==
name|copyState
operator|.
name|version
assert|;
name|message
argument_list|(
literal|"  version="
operator|+
name|infos
operator|.
name|getVersion
argument_list|()
operator|+
literal|" segments="
operator|+
name|infos
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Cutover to new searcher:
if|if
condition|(
name|mgr
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|SegmentInfosSearcherManager
operator|)
name|mgr
operator|)
operator|.
name|setCurrentInfos
argument_list|(
name|infos
argument_list|)
expr_stmt|;
block|}
comment|// Must first incRef new NRT files, then decRef old ones, to make sure we don't remove an NRT file that's in common to both:
name|Collection
argument_list|<
name|String
argument_list|>
name|newFiles
init|=
name|copyState
operator|.
name|files
operator|.
name|keySet
argument_list|()
decl_stmt|;
name|message
argument_list|(
literal|"top: incRef newNRTFiles="
operator|+
name|newFiles
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|incRef
argument_list|(
name|newFiles
argument_list|)
expr_stmt|;
comment|// If any of our new files were previously copied merges, we clear them now, so we don't try to later delete a non-existent file:
name|pendingMergeFiles
operator|.
name|removeAll
argument_list|(
name|newFiles
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: after remove from pending merges pendingMergeFiles="
operator|+
name|pendingMergeFiles
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: decRef lastNRTFiles="
operator|+
name|lastNRTFiles
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|decRef
argument_list|(
name|lastNRTFiles
argument_list|)
expr_stmt|;
name|lastNRTFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
name|lastNRTFiles
operator|.
name|addAll
argument_list|(
name|newFiles
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: set lastNRTFiles="
operator|+
name|lastNRTFiles
argument_list|)
expr_stmt|;
comment|// At this point we can remove any completed merge segment files that we still do not reference.  This can happen when a merge
comment|// finishes, copies its files out to us, but is then merged away (or dropped due to 100% deletions) before we ever cutover to it
comment|// in an NRT point:
if|if
condition|(
name|copyState
operator|.
name|completedMergeFiles
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
name|message
argument_list|(
literal|"now remove-if-not-ref'd completed merge files: "
operator|+
name|copyState
operator|.
name|completedMergeFiles
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|fileName
range|:
name|copyState
operator|.
name|completedMergeFiles
control|)
block|{
if|if
condition|(
name|pendingMergeFiles
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
name|pendingMergeFiles
operator|.
name|remove
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|deleteIfNoRef
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|lastFileMetaData
operator|=
name|copyState
operator|.
name|files
expr_stmt|;
comment|// It's a good time to delete pending files, since we just refreshed and some previously open files are now closed:
name|deleter
operator|.
name|deletePending
argument_list|()
expr_stmt|;
block|}
name|int
name|markerCount
decl_stmt|;
name|IndexSearcher
name|s
init|=
name|mgr
operator|.
name|acquire
argument_list|()
decl_stmt|;
try|try
block|{
name|markerCount
operator|=
name|s
operator|.
name|count
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"marker"
argument_list|,
literal|"marker"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|mgr
operator|.
name|release
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|message
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"top: done sync: took %.3fs for %s, opened NRT reader version=%d markerCount=%d"
argument_list|,
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startNS
operator|)
operator|/
literal|1000000000.0
argument_list|,
name|bytesToString
argument_list|(
name|job
operator|.
name|getTotalBytesCopied
argument_list|()
argument_list|)
argument_list|,
name|copyState
operator|.
name|version
argument_list|,
name|markerCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Start a background copying job, to copy the specified files from the current primary node.  If files is null then the latest copy    *  state should be copied.  If prevJob is not null, then the new copy job is replacing it and should 1) cancel the previous one, and    *  2) optionally salvage e.g. partially copied and, shared with the new copy job, files. */
DECL|method|newCopyJob
specifier|protected
specifier|abstract
name|CopyJob
name|newCopyJob
parameter_list|(
name|String
name|reason
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|FileMetaData
argument_list|>
name|files
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|FileMetaData
argument_list|>
name|prevFiles
parameter_list|,
name|boolean
name|highPriority
parameter_list|,
name|CopyJob
operator|.
name|OnceDone
name|onceDone
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Runs this job async'd */
DECL|method|launch
specifier|protected
specifier|abstract
name|void
name|launch
parameter_list|(
name|CopyJob
name|job
parameter_list|)
function_decl|;
comment|/** Tell primary we (replica) just started, so primary can tell us to warm any already warming merges.  This lets us keep low nrt refresh    *  time for the first nrt sync after we started. */
DECL|method|sendNewReplica
specifier|protected
specifier|abstract
name|void
name|sendNewReplica
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Call this to notify this replica node that a new NRT infos is available on the primary.    *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */
DECL|method|newNRTPoint
specifier|public
specifier|synchronized
name|CopyJob
name|newNRTPoint
parameter_list|(
name|long
name|version
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isClosed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AlreadyClosedException
argument_list|(
literal|"this replica is closed: state="
operator|+
name|state
argument_list|)
throw|;
block|}
comment|// Caller should not "publish" us until we have finished .start():
assert|assert
name|mgr
operator|!=
literal|null
assert|;
if|if
condition|(
literal|"idle"
operator|.
name|equals
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|state
operator|=
literal|"syncing"
expr_stmt|;
block|}
name|long
name|curVersion
init|=
name|getCurrentSearchingVersion
argument_list|()
decl_stmt|;
name|message
argument_list|(
literal|"top: start sync sis.version="
operator|+
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|curVersion
condition|)
block|{
comment|// Caller releases the CopyState:
name|message
argument_list|(
literal|"top: new NRT point has same version as current; skipping"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|version
operator|<
name|curVersion
condition|)
block|{
comment|// This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version
name|message
argument_list|(
literal|"top: new NRT point (version="
operator|+
name|version
operator|+
literal|") is older than current (version="
operator|+
name|version
operator|+
literal|"); skipping"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|long
name|startNS
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|message
argument_list|(
literal|"top: newNRTPoint"
argument_list|)
expr_stmt|;
name|CopyJob
name|job
init|=
literal|null
decl_stmt|;
try|try
block|{
name|job
operator|=
name|newCopyJob
argument_list|(
literal|"NRT point sync version="
operator|+
name|version
argument_list|,
literal|null
argument_list|,
name|lastFileMetaData
argument_list|,
literal|true
argument_list|,
operator|new
name|CopyJob
operator|.
name|OnceDone
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|(
name|CopyJob
name|job
parameter_list|)
block|{
try|try
block|{
name|finishNRTCopy
argument_list|(
name|job
argument_list|,
name|startNS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NodeCommunicationException
name|nce
parameter_list|)
block|{
comment|// E.g. primary could crash/close when we are asking it for the copy state:
name|message
argument_list|(
literal|"top: ignoring communication exception creating CopyJob: "
operator|+
name|nce
argument_list|)
expr_stmt|;
comment|//nce.printStackTrace(System.out);
if|if
condition|(
name|state
operator|.
name|equals
argument_list|(
literal|"syncing"
argument_list|)
condition|)
block|{
name|state
operator|=
literal|"idle"
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
name|Collection
argument_list|<
name|String
argument_list|>
name|newNRTFiles
init|=
name|job
operator|.
name|getFileNames
argument_list|()
decl_stmt|;
name|long
name|newPrimaryGen
init|=
name|job
operator|.
name|getCopyState
argument_list|()
operator|.
name|primaryGen
decl_stmt|;
name|maybeNewPrimary
argument_list|(
name|newPrimaryGen
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: newNRTPoint: job files="
operator|+
name|newNRTFiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|curNRTCopy
operator|!=
literal|null
condition|)
block|{
name|job
operator|.
name|transferAndCancel
argument_list|(
name|curNRTCopy
argument_list|)
expr_stmt|;
assert|assert
name|curNRTCopy
operator|.
name|getFailed
argument_list|()
assert|;
block|}
name|curNRTCopy
operator|=
name|job
expr_stmt|;
for|for
control|(
name|String
name|fileName
range|:
name|curNRTCopy
operator|.
name|getFileNamesToCopy
argument_list|()
control|)
block|{
assert|assert
name|lastCommitFiles
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
operator|==
literal|false
operator|:
literal|"fileName="
operator|+
name|fileName
operator|+
literal|" is in lastCommitFiles and is being copied?"
assert|;
synchronized|synchronized
init|(
name|mergeCopyJobs
init|)
block|{
for|for
control|(
name|CopyJob
name|mergeJob
range|:
name|mergeCopyJobs
control|)
block|{
if|if
condition|(
name|mergeJob
operator|.
name|getFileNames
argument_list|()
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
comment|// TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently
name|message
argument_list|(
literal|"top: now cancel merge copy job="
operator|+
name|mergeJob
operator|+
literal|": file "
operator|+
name|fileName
operator|+
literal|" is now being copied via NRT point"
argument_list|)
expr_stmt|;
name|mergeJob
operator|.
name|cancel
argument_list|(
literal|"newNRTPoint is copying over the same file"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
try|try
block|{
name|job
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NodeCommunicationException
name|nce
parameter_list|)
block|{
comment|// E.g. primary could crash/close when we are asking it for the copy state:
name|message
argument_list|(
literal|"top: ignoring exception starting CopyJob: "
operator|+
name|nce
argument_list|)
expr_stmt|;
name|nce
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|equals
argument_list|(
literal|"syncing"
argument_list|)
condition|)
block|{
name|state
operator|=
literal|"idle"
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|// Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:
name|launch
argument_list|(
name|curNRTCopy
argument_list|)
expr_stmt|;
return|return
name|curNRTCopy
return|;
block|}
DECL|method|isCopying
specifier|public
specifier|synchronized
name|boolean
name|isCopying
parameter_list|()
block|{
return|return
name|curNRTCopy
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|isClosed
specifier|public
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
literal|"closed"
operator|.
name|equals
argument_list|(
name|state
argument_list|)
operator|||
literal|"closing"
operator|.
name|equals
argument_list|(
name|state
argument_list|)
operator|||
literal|"crashing"
operator|.
name|equals
argument_list|(
name|state
argument_list|)
operator|||
literal|"crashed"
operator|.
name|equals
argument_list|(
name|state
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|message
argument_list|(
literal|"top: now close"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|state
operator|=
literal|"closing"
expr_stmt|;
if|if
condition|(
name|curNRTCopy
operator|!=
literal|null
condition|)
block|{
name|curNRTCopy
operator|.
name|cancel
argument_list|(
literal|"closing"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
name|message
argument_list|(
literal|"top: close mgr"
argument_list|)
expr_stmt|;
name|mgr
operator|.
name|close
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"top: decRef lastNRTFiles="
operator|+
name|lastNRTFiles
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|decRef
argument_list|(
name|lastNRTFiles
argument_list|)
expr_stmt|;
name|lastNRTFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// NOTE: do not decRef these!
name|lastCommitFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"top: delete if no ref pendingMergeFiles="
operator|+
name|pendingMergeFiles
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|fileName
range|:
name|pendingMergeFiles
control|)
block|{
name|deleter
operator|.
name|deleteIfNoRef
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
name|pendingMergeFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"top: close dir"
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|close
argument_list|(
name|writeFileLock
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
name|message
argument_list|(
literal|"top: done close"
argument_list|)
expr_stmt|;
name|state
operator|=
literal|"closed"
expr_stmt|;
block|}
comment|/** Called when the primary changed */
DECL|method|maybeNewPrimary
specifier|protected
specifier|synchronized
name|void
name|maybeNewPrimary
parameter_list|(
name|long
name|newPrimaryGen
parameter_list|)
block|{
if|if
condition|(
name|newPrimaryGen
operator|!=
name|lastPrimaryGen
condition|)
block|{
name|message
argument_list|(
literal|"top: now change lastPrimaryGen from "
operator|+
name|lastPrimaryGen
operator|+
literal|" to "
operator|+
name|newPrimaryGen
operator|+
literal|" pendingMergeFiles="
operator|+
name|pendingMergeFiles
argument_list|)
expr_stmt|;
assert|assert
name|newPrimaryGen
operator|>
name|lastPrimaryGen
operator|:
literal|"newPrimaryGen="
operator|+
name|newPrimaryGen
operator|+
literal|" vs lastPrimaryGen="
operator|+
name|lastPrimaryGen
assert|;
name|lastPrimaryGen
operator|=
name|newPrimaryGen
expr_stmt|;
name|pendingMergeFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"top: keep current lastPrimaryGen="
operator|+
name|lastPrimaryGen
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|launchPreCopyMerge
specifier|protected
specifier|synchronized
name|CopyJob
name|launchPreCopyMerge
parameter_list|(
name|AtomicBoolean
name|finished
parameter_list|,
name|long
name|newPrimaryGen
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|FileMetaData
argument_list|>
name|files
parameter_list|)
throws|throws
name|IOException
block|{
name|CopyJob
name|job
decl_stmt|;
name|maybeNewPrimary
argument_list|(
name|newPrimaryGen
argument_list|)
expr_stmt|;
specifier|final
name|long
name|primaryGenStart
init|=
name|lastPrimaryGen
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|fileNames
init|=
name|files
operator|.
name|keySet
argument_list|()
decl_stmt|;
name|message
argument_list|(
literal|"now pre-copy warm merge files="
operator|+
name|fileNames
operator|+
literal|" primaryGen="
operator|+
name|newPrimaryGen
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|fileName
range|:
name|fileNames
control|)
block|{
assert|assert
name|pendingMergeFiles
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
operator|==
literal|false
operator|:
literal|"file \""
operator|+
name|fileName
operator|+
literal|"\" is already being warmed!"
assert|;
assert|assert
name|lastNRTFiles
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
operator|==
literal|false
operator|:
literal|"file \""
operator|+
name|fileName
operator|+
literal|"\" is already NRT visible!"
assert|;
block|}
name|job
operator|=
name|newCopyJob
argument_list|(
literal|"warm merge on "
operator|+
name|name
argument_list|()
operator|+
literal|" filesNames="
operator|+
name|fileNames
argument_list|,
name|files
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
operator|new
name|CopyJob
operator|.
name|OnceDone
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|(
name|CopyJob
name|job
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Signals that this replica has finished
name|mergeCopyJobs
operator|.
name|remove
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"done warming merge "
operator|+
name|fileNames
operator|+
literal|" failed?="
operator|+
name|job
operator|.
name|getFailed
argument_list|()
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|job
operator|.
name|getFailed
argument_list|()
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|lastPrimaryGen
operator|!=
name|primaryGenStart
condition|)
block|{
name|message
argument_list|(
literal|"merge pre copy finished but primary has changed; cancelling job files="
operator|+
name|fileNames
argument_list|)
expr_stmt|;
name|job
operator|.
name|cancel
argument_list|(
literal|"primary changed during merge copy"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|abort
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|fileName
range|:
name|fileNames
control|)
block|{
if|if
condition|(
name|lastNRTFiles
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
name|message
argument_list|(
literal|"abort merge finish: file "
operator|+
name|fileName
operator|+
literal|" is referenced by last NRT point"
argument_list|)
expr_stmt|;
name|abort
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|lastCommitFiles
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
name|message
argument_list|(
literal|"abort merge finish: file "
operator|+
name|fileName
operator|+
literal|" is referenced by last commit point"
argument_list|)
expr_stmt|;
name|abort
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|abort
condition|)
block|{
comment|// Even though in newNRTPoint we have similar logic, which cancels any merge copy jobs if an NRT point
comment|// shows up referencing the files we are warming (because primary got impatient and gave up on us), we also
comment|// need it here in case replica is way far behind and fails to even receive the merge pre-copy request
comment|// until after the newNRTPoint referenced those files:
name|job
operator|.
name|cancel
argument_list|(
literal|"merged segment was separately copied via NRT point"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|job
operator|.
name|finish
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"merge pre copy finished files="
operator|+
name|fileNames
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|fileName
range|:
name|fileNames
control|)
block|{
assert|assert
name|pendingMergeFiles
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
operator|==
literal|false
operator|:
literal|"file \""
operator|+
name|fileName
operator|+
literal|"\" is already in pendingMergeFiles"
assert|;
name|message
argument_list|(
literal|"add file "
operator|+
name|fileName
operator|+
literal|" to pendingMergeFiles"
argument_list|)
expr_stmt|;
name|pendingMergeFiles
operator|.
name|add
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|message
argument_list|(
literal|"merge copy finished with failure"
argument_list|)
expr_stmt|;
block|}
block|}
name|finished
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|job
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// When warming a merge we better not already have any of these files copied!
assert|assert
name|job
operator|.
name|getFileNamesToCopy
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|files
operator|.
name|size
argument_list|()
assert|;
name|mergeCopyJobs
operator|.
name|add
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|launch
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
DECL|method|createTempOutput
specifier|public
name|IndexOutput
name|createTempOutput
parameter_list|(
name|String
name|prefix
parameter_list|,
name|String
name|suffix
parameter_list|,
name|IOContext
name|ioContext
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dir
operator|.
name|createTempOutput
argument_list|(
name|prefix
argument_list|,
name|suffix
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
return|;
block|}
comment|/** Compares incoming per-file identity (id, checksum, header, footer) versus what we have locally and returns the subset of the incoming    *  files that need copying */
DECL|method|getFilesToCopy
specifier|public
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|FileMetaData
argument_list|>
argument_list|>
name|getFilesToCopy
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|FileMetaData
argument_list|>
name|files
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|doCopyCommitFiles
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|FileMetaData
argument_list|>
argument_list|>
name|toCopy
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|FileMetaData
argument_list|>
name|ent
range|:
name|files
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|fileName
init|=
name|ent
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|FileMetaData
name|fileMetaData
init|=
name|ent
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|fileIsIdentical
argument_list|(
name|fileName
argument_list|,
name|fileMetaData
argument_list|)
operator|==
literal|false
condition|)
block|{
name|toCopy
operator|.
name|add
argument_list|(
name|ent
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|toCopy
return|;
block|}
comment|/** Carefully determine if the file on the primary, identified by its {@code String fileName} along with the {@link FileMetaData}    * "summarizing" its contents, is precisely the same file that we have locally.  If the file does not exist locally, or if its its header    * (inclues the segment id), length, footer (including checksum) differ, then this returns false, else true. */
DECL|method|fileIsIdentical
specifier|private
name|boolean
name|fileIsIdentical
parameter_list|(
name|String
name|fileName
parameter_list|,
name|FileMetaData
name|srcMetaData
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|deleter
operator|.
name|isPending
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
comment|// This was a file we had wanted to delete yet a virus checker prevented us, and now we need to overwrite it.
comment|// Such files are in an unknown state, and even if their header and footer and length all
comment|// match, since they may not have been fsync'd by the previous node instance on this directory,
comment|// they could in theory have corruption internally.  So we always force ourselves to copy them here:
if|if
condition|(
name|Node
operator|.
name|VERBOSE_FILES
condition|)
block|{
name|message
argument_list|(
literal|"file "
operator|+
name|fileName
operator|+
literal|": will copy [we had wanted to delete this file on init, but failed]"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
name|FileMetaData
name|destMetaData
init|=
name|readLocalFileMetaData
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|destMetaData
operator|==
literal|null
condition|)
block|{
comment|// Something went wrong in reading the file (it's corrupt, truncated, does not exist, etc.):
return|return
literal|false
return|;
block|}
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|destMetaData
operator|.
name|header
argument_list|,
name|srcMetaData
operator|.
name|header
argument_list|)
operator|==
literal|false
operator|||
name|Arrays
operator|.
name|equals
argument_list|(
name|destMetaData
operator|.
name|footer
argument_list|,
name|srcMetaData
operator|.
name|footer
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// Segment name was reused!  This is rare but possible and otherwise devastating:
if|if
condition|(
name|Node
operator|.
name|VERBOSE_FILES
condition|)
block|{
name|message
argument_list|(
literal|"file "
operator|+
name|fileName
operator|+
literal|": will copy [header/footer is different]"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
DECL|field|copying
specifier|private
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|copying
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Used only to catch bugs, ensuring a given file name is only ever being copied bye one job:
DECL|method|startCopyFile
specifier|public
name|void
name|startCopyFile
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|copying
operator|.
name|putIfAbsent
argument_list|(
name|name
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"file "
operator|+
name|name
operator|+
literal|" is being copied in two places!"
argument_list|)
throw|;
block|}
block|}
DECL|method|finishCopyFile
specifier|public
name|void
name|finishCopyFile
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|copying
operator|.
name|remove
argument_list|(
name|name
argument_list|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"file "
operator|+
name|name
operator|+
literal|" was not actually being copied?"
argument_list|)
throw|;
block|}
block|}
block|}
end_class
end_unit
