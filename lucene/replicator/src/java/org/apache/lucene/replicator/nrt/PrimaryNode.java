begin_unit
begin_package
DECL|package|org.apache.lucene.replicator.nrt
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|replicator
operator|.
name|nrt
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFileNames
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriterConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LogMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentCommitInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StandardDirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TieredMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|SearcherFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|SearcherManager
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RAMFile
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RAMOutputStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PrintStreamInfoStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ThreadInterruptedException
import|;
end_import
begin_comment
comment|/*  * This just asks IndexWriter to open new NRT reader, in order to publish a new NRT point.  This could be improved, if we separated out 1)  * nrt flush (and incRef the SIS) from 2) opening a new reader, but this is tricky with IW's concurrency, and it would also be hard-ish to share  * IW's reader pool with our searcher manager.  So we do the simpler solution now, but that adds some unecessary latency to NRT refresh on  * replicas since step 2) could otherwise be done concurrently with replicas copying files over.  */
end_comment
begin_comment
comment|/** Node that holds an IndexWriter, indexing documents into its local index. */
end_comment
begin_class
DECL|class|PrimaryNode
specifier|public
specifier|abstract
class|class
name|PrimaryNode
extends|extends
name|Node
block|{
comment|// Current NRT segment infos, incRef'd with IndexWriter.deleter:
DECL|field|curInfos
specifier|private
name|SegmentInfos
name|curInfos
decl_stmt|;
DECL|field|writer
specifier|final
name|IndexWriter
name|writer
decl_stmt|;
comment|// IncRef'd state of the last published NRT point; when a replica comes asking, we give it this as the current NRT point:
DECL|field|copyState
specifier|private
name|CopyState
name|copyState
decl_stmt|;
DECL|field|primaryGen
specifier|protected
specifier|final
name|long
name|primaryGen
decl_stmt|;
comment|/** Contains merged segments that have been copied to all running replicas (as of when that merge started warming). */
DECL|field|finishedMergedFiles
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|finishedMergedFiles
init|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|copyingCount
specifier|private
specifier|final
name|AtomicInteger
name|copyingCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|method|PrimaryNode
specifier|public
name|PrimaryNode
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|int
name|id
parameter_list|,
name|long
name|primaryGen
parameter_list|,
name|long
name|forcePrimaryVersion
parameter_list|,
name|SearcherFactory
name|searcherFactory
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|id
argument_list|,
name|writer
operator|.
name|getDirectory
argument_list|()
argument_list|,
name|searcherFactory
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: now init primary"
argument_list|)
expr_stmt|;
name|this
operator|.
name|writer
operator|=
name|writer
expr_stmt|;
name|this
operator|.
name|primaryGen
operator|=
name|primaryGen
expr_stmt|;
try|try
block|{
comment|// So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,
comment|// it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a
comment|// large merge completes:
name|writer
operator|.
name|getConfig
argument_list|()
operator|.
name|setMergedSegmentWarmer
argument_list|(
operator|new
name|PreCopyMergedSegmentWarmer
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"IWC:\n"
operator|+
name|writer
operator|.
name|getConfig
argument_list|()
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"dir:\n"
operator|+
name|writer
operator|.
name|getDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"commitData: "
operator|+
name|writer
operator|.
name|getCommitData
argument_list|()
argument_list|)
expr_stmt|;
comment|// Record our primaryGen in the userData, and set initial version to 0:
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commitData
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|writer
operator|.
name|getCommitData
argument_list|()
argument_list|)
decl_stmt|;
name|commitData
operator|.
name|put
argument_list|(
name|PRIMARY_GEN_KEY
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|primaryGen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|commitData
operator|.
name|get
argument_list|(
name|VERSION_KEY
argument_list|)
operator|==
literal|null
condition|)
block|{
name|commitData
operator|.
name|put
argument_list|(
name|VERSION_KEY
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"add initial commitData version=0"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"keep current commitData version="
operator|+
name|commitData
operator|.
name|get
argument_list|(
name|VERSION_KEY
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|setCommitData
argument_list|(
name|commitData
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are
comment|// starting up on an "older" index, else versions can be illegally reused but show different results:
if|if
condition|(
name|forcePrimaryVersion
operator|!=
operator|-
literal|1
condition|)
block|{
name|message
argument_list|(
literal|"now forcePrimaryVersion to version="
operator|+
name|forcePrimaryVersion
argument_list|)
expr_stmt|;
name|writer
operator|.
name|advanceSegmentInfosVersion
argument_list|(
name|forcePrimaryVersion
argument_list|)
expr_stmt|;
block|}
name|mgr
operator|=
operator|new
name|SearcherManager
argument_list|(
name|writer
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|searcherFactory
argument_list|)
expr_stmt|;
name|setCurrentInfos
argument_list|(
name|Collections
operator|.
expr|<
name|String
operator|>
name|emptySet
argument_list|()
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"init: infos version="
operator|+
name|curInfos
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|IndexSearcher
name|s
init|=
name|mgr
operator|.
name|acquire
argument_list|()
decl_stmt|;
try|try
block|{
name|message
argument_list|(
literal|"init: marker hit count: "
operator|+
name|s
operator|.
name|search
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"marker"
argument_list|,
literal|"marker"
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|.
name|totalHits
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|mgr
operator|.
name|release
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|message
argument_list|(
literal|"init: exception"
argument_list|)
expr_stmt|;
name|t
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|t
argument_list|)
throw|;
block|}
block|}
comment|// TODO: in the future, we should separate "flush" (returns an incRef'd SegmentInfos) from "refresh" (open new NRT reader from
comment|// IndexWriter) so that the latter can be done concurrently while copying files out to replicas, minimizing the refresh time from the
comment|// replicas.  But fixing this is tricky because e.g. IndexWriter may complete a big merge just after returning the incRef'd SegmentInfos
comment|// and before we can open a new reader causing us to close the just-merged readers only to then open them again from the (now stale)
comment|// SegmentInfos.  To fix this "properly" I think IW.inc/decRefDeleter must also incread the ReaderPool entry
comment|/** Flush all index operations to disk and opens a new near-real-time reader.    *  new NRT point, to make the changes visible to searching.  Returns true if there were changes. */
DECL|method|flushAndRefresh
specifier|public
name|boolean
name|flushAndRefresh
parameter_list|()
throws|throws
name|IOException
block|{
name|message
argument_list|(
literal|"top: now flushAndRefresh"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|completedMergeFiles
decl_stmt|;
synchronized|synchronized
init|(
name|finishedMergedFiles
init|)
block|{
name|completedMergeFiles
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|finishedMergedFiles
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mgr
operator|.
name|maybeRefreshBlocking
argument_list|()
expr_stmt|;
name|boolean
name|result
init|=
name|setCurrentInfos
argument_list|(
name|completedMergeFiles
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|message
argument_list|(
literal|"top: opened NRT reader version="
operator|+
name|curInfos
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|finishedMergedFiles
operator|.
name|removeAll
argument_list|(
name|completedMergeFiles
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"flushAndRefresh:  version="
operator|+
name|curInfos
operator|.
name|getVersion
argument_list|()
operator|+
literal|" completedMergeFiles="
operator|+
name|completedMergeFiles
operator|+
literal|" finishedMergedFiles="
operator|+
name|finishedMergedFiles
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"top: no changes in flushAndRefresh; still version="
operator|+
name|curInfos
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|getCopyStateVersion
specifier|public
name|long
name|getCopyStateVersion
parameter_list|()
block|{
return|return
name|copyState
operator|.
name|version
return|;
block|}
DECL|method|getLastCommitVersion
specifier|public
specifier|synchronized
name|long
name|getLastCommitVersion
parameter_list|()
block|{
name|String
name|s
init|=
name|curInfos
operator|.
name|getUserData
argument_list|()
operator|.
name|get
argument_list|(
name|VERSION_KEY
argument_list|)
decl_stmt|;
comment|// In ctor we always install an initial version:
assert|assert
name|s
operator|!=
literal|null
assert|;
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|s
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|commit
specifier|public
name|void
name|commit
parameter_list|()
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commitData
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|commitData
operator|.
name|put
argument_list|(
name|PRIMARY_GEN_KEY
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|primaryGen
argument_list|)
argument_list|)
expr_stmt|;
comment|// TODO (opto): it's a bit wasteful that we put "last refresh" version here, not the actual version we are committing, because it means
comment|// on xlog replay we are replaying more ops than necessary.
name|commitData
operator|.
name|put
argument_list|(
name|VERSION_KEY
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|copyState
operator|.
name|version
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: commit commitData="
operator|+
name|commitData
argument_list|)
expr_stmt|;
comment|// nocommit this is now an NRT-visible change!  make test where nothing is indexing and confirm we don't do silly commit + refresh loop forever!
name|writer
operator|.
name|setCommitData
argument_list|(
name|commitData
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|writer
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
comment|/** IncRef the current CopyState and return it */
DECL|method|getCopyState
specifier|public
specifier|synchronized
name|CopyState
name|getCopyState
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|//message("top: getCopyState replicaID=" + replicaID + " replicaNodeID=" + replicaNodeID + " version=" + curInfos.getVersion() + " infos=" + curInfos.toString());
assert|assert
name|curInfos
operator|==
name|copyState
operator|.
name|infos
assert|;
name|writer
operator|.
name|incRefDeleter
argument_list|(
name|copyState
operator|.
name|infos
argument_list|)
expr_stmt|;
name|int
name|count
init|=
name|copyingCount
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
assert|assert
name|count
operator|>
literal|0
assert|;
return|return
name|copyState
return|;
block|}
comment|/** Called once replica is done (or failed) copying an NRT point */
DECL|method|releaseCopyState
specifier|public
name|void
name|releaseCopyState
parameter_list|(
name|CopyState
name|copyState
parameter_list|)
throws|throws
name|IOException
block|{
comment|//message("top: releaseCopyState version=" + copyState.version);
assert|assert
name|copyState
operator|.
name|infos
operator|!=
literal|null
assert|;
name|writer
operator|.
name|decRefDeleter
argument_list|(
name|copyState
operator|.
name|infos
argument_list|)
expr_stmt|;
name|int
name|count
init|=
name|copyingCount
operator|.
name|decrementAndGet
argument_list|()
decl_stmt|;
assert|assert
name|count
operator|>=
literal|0
assert|;
block|}
annotation|@
name|Override
DECL|method|isClosed
specifier|public
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|isClosed
argument_list|(
literal|false
argument_list|)
return|;
block|}
DECL|method|isClosed
name|boolean
name|isClosed
parameter_list|(
name|boolean
name|allowClosing
parameter_list|)
block|{
return|return
literal|"closed"
operator|.
name|equals
argument_list|(
name|state
argument_list|)
operator|||
operator|(
name|allowClosing
operator|==
literal|false
operator|&&
literal|"closing"
operator|.
name|equals
argument_list|(
name|state
argument_list|)
operator|)
return|;
block|}
DECL|method|ensureOpen
specifier|private
name|void
name|ensureOpen
parameter_list|(
name|boolean
name|allowClosing
parameter_list|)
block|{
if|if
condition|(
name|isClosed
argument_list|(
name|allowClosing
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AlreadyClosedException
argument_list|(
name|state
argument_list|)
throw|;
block|}
block|}
comment|/** Steals incoming infos refCount; returns true if there were changes. */
DECL|method|setCurrentInfos
specifier|private
specifier|synchronized
name|boolean
name|setCurrentInfos
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|completedMergeFiles
parameter_list|)
throws|throws
name|IOException
block|{
name|IndexSearcher
name|searcher
init|=
literal|null
decl_stmt|;
name|SegmentInfos
name|infos
decl_stmt|;
try|try
block|{
name|searcher
operator|=
name|mgr
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|infos
operator|=
operator|(
operator|(
name|StandardDirectoryReader
operator|)
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|)
operator|.
name|getSegmentInfos
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|searcher
operator|!=
literal|null
condition|)
block|{
name|mgr
operator|.
name|release
argument_list|(
name|searcher
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|curInfos
operator|!=
literal|null
operator|&&
name|infos
operator|.
name|getVersion
argument_list|()
operator|==
name|curInfos
operator|.
name|getVersion
argument_list|()
condition|)
block|{
comment|// no change
name|message
argument_list|(
literal|"top: skip switch to infos: version="
operator|+
name|infos
operator|.
name|getVersion
argument_list|()
operator|+
literal|" is unchanged: "
operator|+
name|infos
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|SegmentInfos
name|oldInfos
init|=
name|curInfos
decl_stmt|;
name|writer
operator|.
name|incRefDeleter
argument_list|(
name|infos
argument_list|)
expr_stmt|;
name|curInfos
operator|=
name|infos
expr_stmt|;
if|if
condition|(
name|oldInfos
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|decRefDeleter
argument_list|(
name|oldInfos
argument_list|)
expr_stmt|;
block|}
name|message
argument_list|(
literal|"top: switch to infos="
operator|+
name|infos
operator|.
name|toString
argument_list|()
operator|+
literal|" version="
operator|+
name|infos
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
comment|// Serialize the SegmentInfos:
name|RAMOutputStream
name|out
init|=
operator|new
name|RAMOutputStream
argument_list|(
operator|new
name|RAMFile
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|infos
operator|.
name|write
argument_list|(
name|dir
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|byte
index|[]
name|infosBytes
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|out
operator|.
name|getFilePointer
argument_list|()
index|]
decl_stmt|;
name|out
operator|.
name|writeTo
argument_list|(
name|infosBytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|FileMetaData
argument_list|>
name|filesMetaData
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|FileMetaData
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|infos
control|)
block|{
for|for
control|(
name|String
name|fileName
range|:
name|info
operator|.
name|files
argument_list|()
control|)
block|{
name|FileMetaData
name|metaData
init|=
name|readLocalFileMetaData
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
comment|// NOTE: we hold a refCount on this infos, so this file better exist:
assert|assert
name|metaData
operator|!=
literal|null
assert|;
assert|assert
name|filesMetaData
operator|.
name|containsKey
argument_list|(
name|fileName
argument_list|)
operator|==
literal|false
assert|;
name|filesMetaData
operator|.
name|put
argument_list|(
name|fileName
argument_list|,
name|metaData
argument_list|)
expr_stmt|;
block|}
block|}
name|lastFileMetaData
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|filesMetaData
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: set copyState primaryGen="
operator|+
name|primaryGen
operator|+
literal|" version="
operator|+
name|infos
operator|.
name|getVersion
argument_list|()
operator|+
literal|" files="
operator|+
name|filesMetaData
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|copyState
operator|=
operator|new
name|CopyState
argument_list|(
name|lastFileMetaData
argument_list|,
name|infos
operator|.
name|getVersion
argument_list|()
argument_list|,
name|infos
operator|.
name|getGeneration
argument_list|()
argument_list|,
name|infosBytes
argument_list|,
name|completedMergeFiles
argument_list|,
name|primaryGen
argument_list|,
name|curInfos
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|waitForAllRemotesToClose
specifier|private
specifier|synchronized
name|void
name|waitForAllRemotesToClose
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Wait for replicas to finish or crash:
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|count
init|=
name|copyingCount
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|message
argument_list|(
literal|"pendingCopies: "
operator|+
name|count
argument_list|)
expr_stmt|;
try|try
block|{
name|wait
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|ThreadInterruptedException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|state
operator|=
literal|"closing"
expr_stmt|;
name|message
argument_list|(
literal|"top: close primary"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|waitForAllRemotesToClose
argument_list|()
expr_stmt|;
if|if
condition|(
name|curInfos
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|decRefDeleter
argument_list|(
name|curInfos
argument_list|)
expr_stmt|;
name|curInfos
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|mgr
operator|.
name|close
argument_list|()
expr_stmt|;
name|writer
operator|.
name|rollback
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
name|state
operator|=
literal|"closed"
expr_stmt|;
block|}
comment|/** Called when a merge has finished, but before IW switches to the merged segment */
DECL|method|preCopyMergedSegmentFiles
specifier|protected
specifier|abstract
name|void
name|preCopyMergedSegmentFiles
parameter_list|(
name|SegmentCommitInfo
name|info
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|FileMetaData
argument_list|>
name|files
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
end_class
end_unit
