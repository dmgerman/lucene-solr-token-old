begin_unit
begin_package
DECL|package|org.apache.lucene.replicator.nrt
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|replicator
operator|.
name|nrt
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_comment
comment|/** Copies one file from an incoming DataInput to a dest filename in a local Directory */
end_comment
begin_class
DECL|class|CopyOneFile
class|class
name|CopyOneFile
implements|implements
name|Closeable
block|{
DECL|field|in
specifier|private
specifier|final
name|DataInput
name|in
decl_stmt|;
DECL|field|out
specifier|private
specifier|final
name|IndexOutput
name|out
decl_stmt|;
DECL|field|dest
specifier|private
specifier|final
name|ReplicaNode
name|dest
decl_stmt|;
DECL|field|name
specifier|public
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|tmpName
specifier|public
specifier|final
name|String
name|tmpName
decl_stmt|;
DECL|field|metaData
specifier|public
specifier|final
name|FileMetaData
name|metaData
decl_stmt|;
DECL|field|bytesToCopy
specifier|public
specifier|final
name|long
name|bytesToCopy
decl_stmt|;
DECL|field|copyStartNS
specifier|private
specifier|final
name|long
name|copyStartNS
decl_stmt|;
DECL|field|buffer
specifier|private
specifier|final
name|byte
index|[]
name|buffer
decl_stmt|;
DECL|field|bytesCopied
specifier|private
name|long
name|bytesCopied
decl_stmt|;
DECL|method|CopyOneFile
specifier|public
name|CopyOneFile
parameter_list|(
name|DataInput
name|in
parameter_list|,
name|ReplicaNode
name|dest
parameter_list|,
name|String
name|name
parameter_list|,
name|FileMetaData
name|metaData
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|dest
operator|=
name|dest
expr_stmt|;
name|this
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
comment|// TODO: pass correct IOCtx, e.g. seg total size
name|out
operator|=
name|dest
operator|.
name|createTempOutput
argument_list|(
name|name
argument_list|,
literal|"copy"
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
name|tmpName
operator|=
name|out
operator|.
name|getName
argument_list|()
expr_stmt|;
comment|// last 8 bytes are checksum:
name|bytesToCopy
operator|=
name|metaData
operator|.
name|length
operator|-
literal|8
expr_stmt|;
if|if
condition|(
name|Node
operator|.
name|VERBOSE_FILES
condition|)
block|{
name|dest
operator|.
name|message
argument_list|(
literal|"file "
operator|+
name|name
operator|+
literal|": start copying to tmp file "
operator|+
name|tmpName
operator|+
literal|" length="
operator|+
operator|(
literal|8
operator|+
name|bytesToCopy
operator|)
argument_list|)
expr_stmt|;
block|}
name|copyStartNS
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|this
operator|.
name|metaData
operator|=
name|metaData
expr_stmt|;
name|dest
operator|.
name|startCopyFile
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/** Transfers this file copy to another input, continuing where the first one left off */
DECL|method|CopyOneFile
specifier|public
name|CopyOneFile
parameter_list|(
name|CopyOneFile
name|other
parameter_list|,
name|DataInput
name|in
parameter_list|)
block|{
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|dest
operator|=
name|other
operator|.
name|dest
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|other
operator|.
name|name
expr_stmt|;
name|this
operator|.
name|out
operator|=
name|other
operator|.
name|out
expr_stmt|;
name|this
operator|.
name|tmpName
operator|=
name|other
operator|.
name|tmpName
expr_stmt|;
name|this
operator|.
name|metaData
operator|=
name|other
operator|.
name|metaData
expr_stmt|;
name|this
operator|.
name|bytesCopied
operator|=
name|other
operator|.
name|bytesCopied
expr_stmt|;
name|this
operator|.
name|bytesToCopy
operator|=
name|other
operator|.
name|bytesToCopy
expr_stmt|;
name|this
operator|.
name|copyStartNS
operator|=
name|other
operator|.
name|copyStartNS
expr_stmt|;
name|this
operator|.
name|buffer
operator|=
name|other
operator|.
name|buffer
expr_stmt|;
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|dest
operator|.
name|finishCopyFile
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/** Copy another chunk of bytes, returning true once the copy is done */
DECL|method|visit
specifier|public
name|boolean
name|visit
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Copy up to 640 KB per visit:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|long
name|bytesLeft
init|=
name|bytesToCopy
operator|-
name|bytesCopied
decl_stmt|;
if|if
condition|(
name|bytesLeft
operator|==
literal|0
condition|)
block|{
name|long
name|checksum
init|=
name|out
operator|.
name|getChecksum
argument_list|()
decl_stmt|;
if|if
condition|(
name|checksum
operator|!=
name|metaData
operator|.
name|checksum
condition|)
block|{
comment|// Bits flipped during copy!
name|dest
operator|.
name|message
argument_list|(
literal|"file "
operator|+
name|tmpName
operator|+
literal|": checksum mismatch after copy (bits flipped during network copy?) after-copy checksum="
operator|+
name|checksum
operator|+
literal|" vs expected="
operator|+
name|metaData
operator|.
name|checksum
operator|+
literal|"; cancel job"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"file "
operator|+
name|name
operator|+
literal|": checksum mismatch after file copy"
argument_list|)
throw|;
block|}
comment|// Paranoia: make sure the primary node is not smoking crack, by somehow sending us an already corrupted file whose checksum (in its
comment|// footer) disagrees with reality:
name|long
name|actualChecksumIn
init|=
name|in
operator|.
name|readLong
argument_list|()
decl_stmt|;
if|if
condition|(
name|actualChecksumIn
operator|!=
name|checksum
condition|)
block|{
name|dest
operator|.
name|message
argument_list|(
literal|"file "
operator|+
name|tmpName
operator|+
literal|": checksum claimed by primary disagrees with the file's footer: claimed checksum="
operator|+
name|checksum
operator|+
literal|" vs actual="
operator|+
name|actualChecksumIn
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"file "
operator|+
name|name
operator|+
literal|": checksum mismatch after file copy"
argument_list|)
throw|;
block|}
name|out
operator|.
name|writeLong
argument_list|(
name|checksum
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|Node
operator|.
name|VERBOSE_FILES
condition|)
block|{
name|dest
operator|.
name|message
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"file %s: done copying [%s, %.3fms]"
argument_list|,
name|name
argument_list|,
name|Node
operator|.
name|bytesToString
argument_list|(
name|metaData
operator|.
name|length
argument_list|)
argument_list|,
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|copyStartNS
operator|)
operator|/
literal|1000000.0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
name|int
name|toCopy
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|bytesLeft
argument_list|,
name|buffer
operator|.
name|length
argument_list|)
decl_stmt|;
name|in
operator|.
name|readBytes
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|toCopy
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|toCopy
argument_list|)
expr_stmt|;
comment|// TODO: rsync will fsync a range of the file; maybe we should do that here for large files in case we crash/killed
name|bytesCopied
operator|+=
name|toCopy
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|getBytesCopied
specifier|public
name|long
name|getBytesCopied
parameter_list|()
block|{
return|return
name|bytesCopied
return|;
block|}
block|}
end_class
end_unit
