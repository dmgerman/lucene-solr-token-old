begin_unit
begin_package
DECL|package|org.apache.lucene.replicator.nrt
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|replicator
operator|.
name|nrt
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|StandardOpenOption
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MockDirectoryWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LineFileDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
operator|.
name|SuppressCodecs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
operator|.
name|SuppressSysoutChecks
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ThreadInterruptedException
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|SeedUtils
import|;
end_import
begin_comment
comment|// nocommit why so many "hit SocketException during commit with R0"?
end_comment
begin_comment
comment|// nocommit why all these NodeCommunicationExcs?
end_comment
begin_comment
comment|/*   TODO     - fangs       - sometimes have one replica be really slow at copying / have random pauses (fake GC) / etc.       - graceful primary close     - why do we do the "rename temp to actual" all at the end...?  what really does that buy us?     - replica should also track maxSegmentName its seen, and tap into inflateGens if it's later promoted to primary?     - test should not print scary exceptions and then succeed!     - since all nodes are local, we could have a different test only impl that just does local file copies instead of via tcp...     - are the pre-copied-completed-merged files not being cleared in primary?       - hmm the logic isn't right today?  a replica may skip pulling a given copy state, that recorded the finished merged segments?     - beast& fix bugs     - graceful cluster restart     - better translog integration     - get "graceful primary shutdown" working     - there is still some global state we rely on for "correctness", e.g. lastPrimaryVersion     - clean up how version is persisted in commit data     - why am i not using hashes here?  how does ES use them?     - get all other "single shard" functions working too: this cluster should "act like" a single shard       - SLM       - controlled nrt reopen thread / returning long gen on write       - live field values       - add indexes     - make cluster level APIs to search, index, that deal w/ primary failover, etc.     - must prune xlog       - refuse to start primary unless we have quorum     - later       - if we named index files using segment's ID we wouldn't have file name conflicts after primary crash / rollback?       - back pressure on indexing if replicas can't keep up?       - get xlog working on top?  needs to be checkpointed, so we can correlate IW ops to NRT reader version and prune xlog based on commit         quorum         - maybe fix IW to return "gen" or "seq id" or "segment name" or something?       - replica can copy files from other replicas too / use multicast / rsync / something       - each replica could also pre-open a SegmentReader after pre-copy when warming a merge       - we can pre-copy newly flushed files too, for cases where reopen rate is low vs IW's flushing because RAM buffer is full       - opto: pre-copy files as they are written; if they will become CFS, we can build CFS on the replica?       - what about multiple commit points?       - fix primary to init directly from an open replica, instead of having to commit/close the replica first */
end_comment
begin_comment
comment|// Tricky cases:
end_comment
begin_comment
comment|//   - we are pre-copying a merge, then replica starts up part way through, so it misses that pre-copy and must do it on next nrt point
end_comment
begin_comment
comment|//   - a down replica starts up, but it's "from the future" vs the current primary, and must copy over file names with different contents
end_comment
begin_comment
comment|//     but referenced by its latest commit point, so it must fully remove that commit ... which is a hazardous window
end_comment
begin_comment
comment|//   - replica comes up just as the primary is crashing / moving
end_comment
begin_comment
comment|//   - electing a new primary when a replica is just finishing its nrt sync: we need to wait for it so we are sure to get the "most up to
end_comment
begin_comment
comment|//     date" replica
end_comment
begin_comment
comment|//   - replica comes up after merged segment finished so it doesn't copy over the merged segment "promptly" (i.e. only sees it on NRT refresh)
end_comment
begin_comment
comment|/**  * Test case showing how to implement NRT replication.  This test spawns a sub-process per-node, running TestNRTReplicationChild.  *  * One node is primary, and segments are periodically flushed there, then concurrently the N replica nodes copy the new files over and open new readers, while  * primary also opens a new reader.  *  * Nodes randomly crash and are restarted.  If the primary crashes, a replica is promoted.  *  * Merges are currently first finished on the primary and then pre-copied out to replicas with a merged segment warmer so they don't block  * ongoing NRT reopens.  Probably replicas could do their own merging instead, but this is more complex and may not be better overall  * (merging takes a lot of IO resources).  *  * Slow network is simulated with a RateLimiter.  */
end_comment
begin_comment
comment|// MockRandom's .sd file has no index header/footer:
end_comment
begin_class
annotation|@
name|SuppressCodecs
argument_list|(
block|{
literal|"MockRandom"
block|,
literal|"Memory"
block|,
literal|"Direct"
block|,
literal|"SimpleText"
block|}
argument_list|)
annotation|@
name|SuppressSysoutChecks
argument_list|(
name|bugUrl
operator|=
literal|"Stuff gets printed, important stuff for debugging a failure"
argument_list|)
DECL|class|TestStressNRTReplication
specifier|public
class|class
name|TestStressNRTReplication
extends|extends
name|LuceneTestCase
block|{
comment|// Test evilness controls:
comment|/** Randomly crash the current primary (losing data!) and promote the "next best" replica. */
DECL|field|DO_CRASH_PRIMARY
specifier|static
specifier|final
name|boolean
name|DO_CRASH_PRIMARY
init|=
literal|true
decl_stmt|;
comment|/** Randomly crash (JVM core dumps) a replica; it will later randomly be restarted and sync itself. */
DECL|field|DO_CRASH_REPLICA
specifier|static
specifier|final
name|boolean
name|DO_CRASH_REPLICA
init|=
literal|true
decl_stmt|;
comment|/** Randomly gracefully close a replica; it will later be restarted and sync itself. */
DECL|field|DO_CLOSE_REPLICA
specifier|static
specifier|final
name|boolean
name|DO_CLOSE_REPLICA
init|=
literal|true
decl_stmt|;
comment|/** Randomly gracefully close the primary; it will later be restarted and sync itself. */
DECL|field|DO_CLOSE_PRIMARY
specifier|static
specifier|final
name|boolean
name|DO_CLOSE_PRIMARY
init|=
literal|true
decl_stmt|;
comment|/** If false, all child + parent output is interleaved into single stdout/err */
DECL|field|SEPARATE_CHILD_OUTPUT
specifier|static
specifier|final
name|boolean
name|SEPARATE_CHILD_OUTPUT
init|=
literal|false
decl_stmt|;
comment|/** Randomly crash whole cluster and then restart it */
DECL|field|DO_FULL_CLUSTER_CRASH
specifier|static
specifier|final
name|boolean
name|DO_FULL_CLUSTER_CRASH
init|=
literal|true
decl_stmt|;
comment|/** True if we randomly flip a bit while copying files out */
DECL|field|DO_BIT_FLIPS_DURING_COPY
specifier|static
specifier|final
name|boolean
name|DO_BIT_FLIPS_DURING_COPY
init|=
literal|true
decl_stmt|;
comment|/** Set to a non-null value to force exactly that many nodes; else, it's random. */
DECL|field|NUM_NODES
specifier|static
specifier|final
name|Integer
name|NUM_NODES
init|=
literal|null
decl_stmt|;
DECL|field|failed
specifier|final
name|AtomicBoolean
name|failed
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
DECL|field|stop
specifier|final
name|AtomicBoolean
name|stop
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
comment|/** cwd where we start each child (server) node */
DECL|field|childTempDir
specifier|private
name|Path
name|childTempDir
decl_stmt|;
DECL|field|primaryGen
name|long
name|primaryGen
decl_stmt|;
DECL|field|lastPrimaryVersion
specifier|volatile
name|long
name|lastPrimaryVersion
decl_stmt|;
DECL|field|primary
specifier|volatile
name|NodeProcess
name|primary
decl_stmt|;
DECL|field|nodes
specifier|volatile
name|NodeProcess
index|[]
name|nodes
decl_stmt|;
DECL|field|nodeTimeStamps
specifier|volatile
name|long
index|[]
name|nodeTimeStamps
decl_stmt|;
DECL|field|starting
specifier|volatile
name|boolean
index|[]
name|starting
decl_stmt|;
DECL|field|indexPaths
name|Path
index|[]
name|indexPaths
decl_stmt|;
DECL|field|transLogPath
name|Path
name|transLogPath
decl_stmt|;
DECL|field|transLog
name|SimpleTransLog
name|transLog
decl_stmt|;
DECL|field|markerUpto
specifier|final
name|AtomicInteger
name|markerUpto
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|markerID
specifier|final
name|AtomicInteger
name|markerID
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|/** Maps searcher version to how many hits the query body:the matched. */
DECL|field|hitCounts
specifier|final
name|Map
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
name|hitCounts
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Maps searcher version to how many marker documents matched.  This should only ever grow (we never delete marker documents). */
DECL|field|versionToMarker
specifier|final
name|Map
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
name|versionToMarker
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Maps searcher version to xlog location when refresh of this version started. */
DECL|field|versionToTransLogLocation
specifier|final
name|Map
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|versionToTransLogLocation
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|nodeStartCounter
specifier|final
name|AtomicLong
name|nodeStartCounter
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|crashingNodes
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|crashingNodes
init|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
DECL|method|test
specifier|public
name|void
name|test
parameter_list|()
throws|throws
name|Exception
block|{
name|Node
operator|.
name|globalStartNS
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"change thread name from "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
literal|"main"
argument_list|)
expr_stmt|;
name|childTempDir
operator|=
name|createTempDir
argument_list|(
literal|"child"
argument_list|)
expr_stmt|;
comment|// We are parent process:
comment|// Silly bootstrapping:
name|versionToTransLogLocation
operator|.
name|put
argument_list|(
literal|0L
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|versionToMarker
operator|.
name|put
argument_list|(
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|int
name|numNodes
decl_stmt|;
if|if
condition|(
name|NUM_NODES
operator|==
literal|null
condition|)
block|{
name|numNodes
operator|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|numNodes
operator|=
name|NUM_NODES
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: using "
operator|+
name|numNodes
operator|+
literal|" nodes"
argument_list|)
expr_stmt|;
name|transLogPath
operator|=
name|createTempDir
argument_list|(
literal|"NRTReplication"
argument_list|)
operator|.
name|resolve
argument_list|(
literal|"translog"
argument_list|)
expr_stmt|;
name|transLog
operator|=
operator|new
name|SimpleTransLog
argument_list|(
name|transLogPath
argument_list|)
expr_stmt|;
comment|//state.rateLimiters = new RateLimiter[numNodes];
name|indexPaths
operator|=
operator|new
name|Path
index|[
name|numNodes
index|]
expr_stmt|;
name|nodes
operator|=
operator|new
name|NodeProcess
index|[
name|numNodes
index|]
expr_stmt|;
name|nodeTimeStamps
operator|=
operator|new
name|long
index|[
name|numNodes
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|nodeTimeStamps
argument_list|,
name|Node
operator|.
name|globalStartNS
argument_list|)
expr_stmt|;
name|starting
operator|=
operator|new
name|boolean
index|[
name|numNodes
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numNodes
condition|;
name|i
operator|++
control|)
block|{
name|indexPaths
index|[
name|i
index|]
operator|=
name|createTempDir
argument_list|(
literal|"index"
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|Thread
index|[]
name|indexers
init|=
operator|new
name|Thread
index|[
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: launch "
operator|+
name|indexers
operator|.
name|length
operator|+
literal|" indexer threads"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|indexers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|indexers
index|[
name|i
index|]
operator|=
operator|new
name|IndexThread
argument_list|()
expr_stmt|;
name|indexers
index|[
name|i
index|]
operator|.
name|setName
argument_list|(
literal|"indexer"
operator|+
name|i
argument_list|)
expr_stmt|;
name|indexers
index|[
name|i
index|]
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|indexers
index|[
name|i
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|Thread
index|[]
name|searchers
init|=
operator|new
name|Thread
index|[
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: launch "
operator|+
name|searchers
operator|.
name|length
operator|+
literal|" searcher threads"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|searchers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|searchers
index|[
name|i
index|]
operator|=
operator|new
name|SearchThread
argument_list|()
expr_stmt|;
name|searchers
index|[
name|i
index|]
operator|.
name|setName
argument_list|(
literal|"searcher"
operator|+
name|i
argument_list|)
expr_stmt|;
name|searchers
index|[
name|i
index|]
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|searchers
index|[
name|i
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|Thread
name|restarter
init|=
operator|new
name|RestartThread
argument_list|()
decl_stmt|;
name|restarter
operator|.
name|setName
argument_list|(
literal|"restarter"
argument_list|)
expr_stmt|;
name|restarter
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|restarter
operator|.
name|start
argument_list|()
expr_stmt|;
name|int
name|runTimeSec
decl_stmt|;
if|if
condition|(
name|TEST_NIGHTLY
condition|)
block|{
name|runTimeSec
operator|=
name|RANDOM_MULTIPLIER
operator|*
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|120
argument_list|,
literal|240
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|runTimeSec
operator|=
name|RANDOM_MULTIPLIER
operator|*
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|45
argument_list|,
literal|120
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: will run for "
operator|+
name|runTimeSec
operator|+
literal|" sec"
argument_list|)
expr_stmt|;
name|long
name|endTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|runTimeSec
operator|*
literal|1000000000L
decl_stmt|;
name|sendReplicasToPrimary
argument_list|()
expr_stmt|;
while|while
condition|(
name|failed
operator|.
name|get
argument_list|()
operator|==
literal|false
operator|&&
name|System
operator|.
name|nanoTime
argument_list|()
operator|<
name|endTime
condition|)
block|{
comment|// Wait a bit:
name|Thread
operator|.
name|sleep
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|runTimeSec
operator|*
literal|4
argument_list|,
literal|200
argument_list|)
argument_list|,
name|runTimeSec
operator|*
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|primary
operator|!=
literal|null
operator|&&
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|NodeProcess
name|curPrimary
init|=
name|primary
decl_stmt|;
if|if
condition|(
name|curPrimary
operator|!=
literal|null
condition|)
block|{
comment|// Save these before we start flush:
name|long
name|nextTransLogLoc
init|=
name|transLog
operator|.
name|getNextLocation
argument_list|()
decl_stmt|;
name|int
name|markerUptoSav
init|=
name|markerUpto
operator|.
name|get
argument_list|()
decl_stmt|;
name|message
argument_list|(
literal|"top: now flush primary; at least marker count="
operator|+
name|markerUptoSav
argument_list|)
expr_stmt|;
name|long
name|result
decl_stmt|;
try|try
block|{
name|result
operator|=
name|primary
operator|.
name|flush
argument_list|(
name|markerUptoSav
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|message
argument_list|(
literal|"top: flush failed; skipping: "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|>
literal|0
condition|)
block|{
comment|// There were changes
name|message
argument_list|(
literal|"top: flush finished with changed; new primary version="
operator|+
name|result
argument_list|)
expr_stmt|;
name|lastPrimaryVersion
operator|=
name|result
expr_stmt|;
name|addTransLogLoc
argument_list|(
name|lastPrimaryVersion
argument_list|,
name|nextTransLogLoc
argument_list|)
expr_stmt|;
name|addVersionMarker
argument_list|(
name|lastPrimaryVersion
argument_list|,
name|markerUptoSav
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|liveCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|NodeProcess
name|node
init|=
name|nodes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|liveCount
operator|++
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|isPrimary
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'P'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|message
argument_list|(
literal|"PG="
operator|+
operator|(
name|primary
operator|==
literal|null
condition|?
literal|"X"
else|:
name|primaryGen
operator|)
operator|+
literal|" "
operator|+
name|liveCount
operator|+
literal|" (of "
operator|+
name|nodes
operator|.
name|length
operator|+
literal|") nodes running: "
operator|+
name|sb
argument_list|)
expr_stmt|;
comment|// Commit a random node, primary or replica
block|{
name|NodeProcess
name|node
init|=
name|nodes
index|[
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|nodes
operator|.
name|length
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|nodeIsClosing
operator|.
name|get
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// TODO: if this node is primary, it means we committed an unpublished version (not exposed as an NRT point)... not sure it matters.
comment|// maybe we somehow allow IW to commit a specific sis (the one we just flushed)?
name|message
argument_list|(
literal|"top: now commit node="
operator|+
name|node
argument_list|)
expr_stmt|;
try|try
block|{
name|node
operator|.
name|commitAsync
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|message
argument_list|(
literal|"top: hit exception during commit with R"
operator|+
name|node
operator|.
name|id
operator|+
literal|"; skipping"
argument_list|)
expr_stmt|;
name|t
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|message
argument_list|(
literal|"TEST: top: test done, now close"
argument_list|)
expr_stmt|;
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|Thread
name|thread
range|:
name|indexers
control|)
block|{
name|thread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Thread
name|thread
range|:
name|searchers
control|)
block|{
name|thread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
name|restarter
operator|.
name|join
argument_list|()
expr_stmt|;
comment|// Close replicas before primary so we cancel any in-progres replications:
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: top: now close replicas"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Closeable
argument_list|>
name|toClose
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|NodeProcess
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|node
operator|!=
name|primary
operator|&&
name|node
operator|!=
literal|null
condition|)
block|{
name|toClose
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
name|IOUtils
operator|.
name|close
argument_list|(
name|toClose
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|close
argument_list|(
name|primary
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|close
argument_list|(
name|transLog
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
operator|.
name|get
argument_list|()
operator|==
literal|false
condition|)
block|{
name|message
argument_list|(
literal|"TEST: top: now checkIndex"
argument_list|)
expr_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|indexPaths
control|)
block|{
name|message
argument_list|(
literal|"TEST: check "
operator|+
name|path
argument_list|)
expr_stmt|;
name|MockDirectoryWrapper
name|dir
init|=
name|newMockFSDirectory
argument_list|(
name|path
argument_list|)
decl_stmt|;
comment|// Just too slow otherwise
name|dir
operator|.
name|setCrossCheckTermVectorsOnClose
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|message
argument_list|(
literal|"TEST: failed; skip checkIndex"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|anyNodesStarting
specifier|private
name|boolean
name|anyNodesStarting
parameter_list|()
block|{
for|for
control|(
name|int
name|id
init|=
literal|0
init|;
name|id
operator|<
name|nodes
operator|.
name|length
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
name|starting
index|[
name|id
index|]
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Picks a replica and promotes it as new primary. */
DECL|method|promoteReplica
specifier|private
name|void
name|promoteReplica
parameter_list|()
throws|throws
name|IOException
block|{
name|message
argument_list|(
literal|"top: primary crashed; now pick replica to promote"
argument_list|)
expr_stmt|;
name|long
name|maxSearchingVersion
init|=
operator|-
literal|1
decl_stmt|;
name|NodeProcess
name|replicaToPromote
init|=
literal|null
decl_stmt|;
comment|// We must promote the most current replica, because otherwise file name reuse can cause a replication to fail when it needs to copy
comment|// over a file currently held open for searching.  This also minimizes recovery work since the most current replica means less xlog
comment|// replay to catch up:
for|for
control|(
name|NodeProcess
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"ask "
operator|+
name|node
operator|+
literal|" for its current searching version"
argument_list|)
expr_stmt|;
name|long
name|searchingVersion
decl_stmt|;
try|try
block|{
name|searchingVersion
operator|=
name|node
operator|.
name|getSearchingVersion
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|message
argument_list|(
literal|"top: hit SocketException during getSearchingVersion with R"
operator|+
name|node
operator|.
name|id
operator|+
literal|"; skipping"
argument_list|)
expr_stmt|;
name|t
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|message
argument_list|(
name|node
operator|+
literal|" has searchingVersion="
operator|+
name|searchingVersion
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchingVersion
operator|>
name|maxSearchingVersion
condition|)
block|{
name|maxSearchingVersion
operator|=
name|searchingVersion
expr_stmt|;
name|replicaToPromote
operator|=
name|node
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|replicaToPromote
operator|==
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"top: no replicas running; skipping primary promotion"
argument_list|)
expr_stmt|;
return|return;
block|}
name|message
argument_list|(
literal|"top: promote "
operator|+
name|replicaToPromote
operator|+
literal|" version="
operator|+
name|maxSearchingVersion
operator|+
literal|"; now commit"
argument_list|)
expr_stmt|;
try|try
block|{
name|replicaToPromote
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Something wrong with this replica; skip it:
name|message
argument_list|(
literal|"top: hit exception during commit with R"
operator|+
name|replicaToPromote
operator|.
name|id
operator|+
literal|"; skipping"
argument_list|)
expr_stmt|;
name|t
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
return|return;
block|}
name|message
argument_list|(
literal|"top: now shutdown "
operator|+
name|replicaToPromote
argument_list|)
expr_stmt|;
if|if
condition|(
name|replicaToPromote
operator|.
name|shutdown
argument_list|()
operator|==
literal|false
condition|)
block|{
name|message
argument_list|(
literal|"top: shutdown failed for R"
operator|+
name|replicaToPromote
operator|.
name|id
operator|+
literal|"; skipping primary promotion"
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|id
init|=
name|replicaToPromote
operator|.
name|id
decl_stmt|;
name|message
argument_list|(
literal|"top: now startPrimary "
operator|+
name|replicaToPromote
argument_list|)
expr_stmt|;
name|startPrimary
argument_list|(
name|replicaToPromote
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
DECL|method|startPrimary
name|void
name|startPrimary
parameter_list|(
name|int
name|id
parameter_list|)
throws|throws
name|IOException
block|{
name|message
argument_list|(
name|id
operator|+
literal|": top: startPrimary lastPrimaryVersion="
operator|+
name|lastPrimaryVersion
argument_list|)
expr_stmt|;
assert|assert
name|nodes
index|[
name|id
index|]
operator|==
literal|null
assert|;
comment|// Force version of new primary to advance beyond where old primary was, so we never re-use versions.  It may have
comment|// already advanced beyond newVersion, e.g. if it flushed new segments while during xlog replay:
comment|// First start node as primary (it opens an IndexWriter) but do not publish it for searching until we replay xlog:
name|NodeProcess
name|newPrimary
init|=
name|startNode
argument_list|(
name|id
argument_list|,
name|indexPaths
index|[
name|id
index|]
argument_list|,
literal|true
argument_list|,
name|lastPrimaryVersion
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|newPrimary
operator|==
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"top: newPrimary failed to start; abort"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Get xlog location that this node was guaranteed to already have indexed through; this may replay some ops already indexed but it's OK
comment|// because the ops are idempotent: we updateDocument (by docid) on replay even for original addDocument:
name|Long
name|startTransLogLoc
decl_stmt|;
name|Integer
name|markerCount
decl_stmt|;
if|if
condition|(
name|newPrimary
operator|.
name|initCommitVersion
operator|==
literal|0
condition|)
block|{
name|startTransLogLoc
operator|=
literal|0L
expr_stmt|;
name|markerCount
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|startTransLogLoc
operator|=
name|versionToTransLogLocation
operator|.
name|get
argument_list|(
name|newPrimary
operator|.
name|initCommitVersion
argument_list|)
expr_stmt|;
name|markerCount
operator|=
name|versionToMarker
operator|.
name|get
argument_list|(
name|newPrimary
operator|.
name|initCommitVersion
argument_list|)
expr_stmt|;
block|}
assert|assert
name|startTransLogLoc
operator|!=
literal|null
operator|:
literal|"newPrimary.initCommitVersion="
operator|+
name|newPrimary
operator|.
name|initCommitVersion
operator|+
literal|" is missing from versionToTransLogLocation: keys="
operator|+
name|versionToTransLogLocation
operator|.
name|keySet
argument_list|()
assert|;
assert|assert
name|markerCount
operator|!=
literal|null
operator|:
literal|"newPrimary.initCommitVersion="
operator|+
name|newPrimary
operator|.
name|initCommitVersion
operator|+
literal|" is missing from versionToMarker: keys="
operator|+
name|versionToMarker
operator|.
name|keySet
argument_list|()
assert|;
comment|// When the primary starts, the userData in its latest commit point tells us which version it had indexed up to, so we know where to
comment|// replay from in the xlog.  However, we forcefuly advance the version, and then IW on init (or maybe getReader) also adds 1 to it.
comment|// Since we publish the primary in this state (before xlog replay is done), a replica can start up at this point and pull this version,
comment|// and possibly later be chosen as a primary, causing problems if the version is known recorded in the translog map.  So we record it
comment|// here:
name|addTransLogLoc
argument_list|(
name|newPrimary
operator|.
name|initInfosVersion
argument_list|,
name|startTransLogLoc
argument_list|)
expr_stmt|;
name|addVersionMarker
argument_list|(
name|newPrimary
operator|.
name|initInfosVersion
argument_list|,
name|markerCount
argument_list|)
expr_stmt|;
assert|assert
name|newPrimary
operator|.
name|initInfosVersion
operator|>=
name|lastPrimaryVersion
assert|;
name|message
argument_list|(
literal|"top: now change lastPrimaryVersion from "
operator|+
name|lastPrimaryVersion
operator|+
literal|" to "
operator|+
name|newPrimary
operator|.
name|initInfosVersion
operator|+
literal|"; startup marker count "
operator|+
name|markerCount
argument_list|)
expr_stmt|;
name|lastPrimaryVersion
operator|=
name|newPrimary
operator|.
name|initInfosVersion
expr_stmt|;
name|long
name|nextTransLogLoc
init|=
name|transLog
operator|.
name|getNextLocation
argument_list|()
decl_stmt|;
name|long
name|t0
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|message
argument_list|(
literal|"top: start translog replay "
operator|+
name|startTransLogLoc
operator|+
literal|" (version="
operator|+
name|newPrimary
operator|.
name|initCommitVersion
operator|+
literal|") to "
operator|+
name|nextTransLogLoc
operator|+
literal|" (translog end)"
argument_list|)
expr_stmt|;
try|try
block|{
name|transLog
operator|.
name|replay
argument_list|(
name|newPrimary
argument_list|,
name|startTransLogLoc
argument_list|,
name|nextTransLogLoc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|message
argument_list|(
literal|"top: replay xlog failed; shutdown new primary"
argument_list|)
expr_stmt|;
name|ioe
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
name|newPrimary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
return|return;
block|}
name|long
name|t1
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|message
argument_list|(
literal|"top: done translog replay; took "
operator|+
operator|(
operator|(
name|t1
operator|-
name|t0
operator|)
operator|/
literal|1000000.0
operator|)
operator|+
literal|" msec; now publish primary"
argument_list|)
expr_stmt|;
comment|// Publish new primary only after translog has succeeded in replaying; this is important, for this test anyway, so we keep a "linear"
comment|// history so enforcing marker counts is correct.  E.g., if we publish first and replay translog concurrently with incoming ops, then
comment|// a primary commit that happens while translog is still replaying will incorrectly record the translog loc into the commit user data
comment|// when in fact that commit did NOT reflect all prior ops.  So if we crash and start up again from that commit point, we are missing
comment|// ops.
name|nodes
index|[
name|id
index|]
operator|=
name|newPrimary
expr_stmt|;
name|primary
operator|=
name|newPrimary
expr_stmt|;
name|sendReplicasToPrimary
argument_list|()
expr_stmt|;
block|}
comment|/** Launches a child "server" (separate JVM), which is either primary or replica node */
DECL|method|startNode
name|NodeProcess
name|startNode
parameter_list|(
specifier|final
name|int
name|id
parameter_list|,
name|Path
name|indexPath
parameter_list|,
name|boolean
name|isPrimary
parameter_list|,
name|long
name|forcePrimaryVersion
parameter_list|)
throws|throws
name|IOException
block|{
name|nodeTimeStamps
index|[
name|id
index|]
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|cmd
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|NodeProcess
name|curPrimary
init|=
name|primary
decl_stmt|;
name|cmd
operator|.
name|add
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.home"
argument_list|)
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
operator|+
literal|"bin"
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
operator|+
literal|"java"
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|add
argument_list|(
literal|"-Xmx512m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|curPrimary
operator|!=
literal|null
condition|)
block|{
name|cmd
operator|.
name|add
argument_list|(
literal|"-Dtests.nrtreplication.primaryTCPPort="
operator|+
name|curPrimary
operator|.
name|tcpPort
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isPrimary
operator|==
literal|false
condition|)
block|{
comment|// We cannot start a replica when there is no primary:
return|return
literal|null
return|;
block|}
comment|// This is very costly (takes more time to check than it did to index); we do this ourselves in the end instead of each time a replica
comment|// is restarted:
comment|// cmd.add("-Dtests.nrtreplication.checkonclose=true");
name|cmd
operator|.
name|add
argument_list|(
literal|"-Dtests.nrtreplication.node=true"
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|add
argument_list|(
literal|"-Dtests.nrtreplication.nodeid="
operator|+
name|id
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|add
argument_list|(
literal|"-Dtests.nrtreplication.startNS="
operator|+
name|Node
operator|.
name|globalStartNS
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|add
argument_list|(
literal|"-Dtests.nrtreplication.indexpath="
operator|+
name|indexPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|isPrimary
condition|)
block|{
name|cmd
operator|.
name|add
argument_list|(
literal|"-Dtests.nrtreplication.isPrimary=true"
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|add
argument_list|(
literal|"-Dtests.nrtreplication.forcePrimaryVersion="
operator|+
name|forcePrimaryVersion
argument_list|)
expr_stmt|;
if|if
condition|(
name|DO_CRASH_PRIMARY
condition|)
block|{
name|cmd
operator|.
name|add
argument_list|(
literal|"-Dtests.nrtreplication.doRandomCrash=true"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DO_CLOSE_PRIMARY
condition|)
block|{
name|cmd
operator|.
name|add
argument_list|(
literal|"-Dtests.nrtreplication.doRandomClose=true"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|DO_CRASH_REPLICA
condition|)
block|{
name|cmd
operator|.
name|add
argument_list|(
literal|"-Dtests.nrtreplication.doRandomCrash=true"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DO_CLOSE_REPLICA
condition|)
block|{
name|cmd
operator|.
name|add
argument_list|(
literal|"-Dtests.nrtreplication.doRandomClose=true"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DO_BIT_FLIPS_DURING_COPY
condition|)
block|{
name|cmd
operator|.
name|add
argument_list|(
literal|"-Dtests.nrtreplication.doFlipBitsDuringCopy=true"
argument_list|)
expr_stmt|;
block|}
name|long
name|myPrimaryGen
init|=
name|primaryGen
decl_stmt|;
name|cmd
operator|.
name|add
argument_list|(
literal|"-Dtests.nrtreplication.primaryGen="
operator|+
name|myPrimaryGen
argument_list|)
expr_stmt|;
comment|// Mixin our own counter because this is called from a fresh thread which means the seed otherwise isn't changing each time we spawn a
comment|// new node:
name|long
name|seed
init|=
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
operator|*
name|nodeStartCounter
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
name|cmd
operator|.
name|add
argument_list|(
literal|"-Dtests.seed="
operator|+
name|SeedUtils
operator|.
name|formatSeed
argument_list|(
name|seed
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|add
argument_list|(
literal|"-ea"
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|add
argument_list|(
literal|"-cp"
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|add
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.class.path"
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|add
argument_list|(
literal|"org.junit.runner.JUnitCore"
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|add
argument_list|(
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|replace
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
literal|"SimpleServer"
argument_list|)
argument_list|)
expr_stmt|;
name|Writer
name|childLog
decl_stmt|;
if|if
condition|(
name|SEPARATE_CHILD_OUTPUT
condition|)
block|{
name|Path
name|childOut
init|=
name|childTempDir
operator|.
name|resolve
argument_list|(
name|id
operator|+
literal|".log"
argument_list|)
decl_stmt|;
name|message
argument_list|(
literal|"logging to "
operator|+
name|childOut
argument_list|)
expr_stmt|;
name|childLog
operator|=
name|Files
operator|.
name|newBufferedWriter
argument_list|(
name|childOut
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|,
name|StandardOpenOption
operator|.
name|APPEND
argument_list|,
name|StandardOpenOption
operator|.
name|CREATE
argument_list|)
expr_stmt|;
name|childLog
operator|.
name|write
argument_list|(
literal|"\n\nSTART NEW CHILD:\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|childLog
operator|=
literal|null
expr_stmt|;
block|}
comment|//message("child process command: " + cmd);
name|ProcessBuilder
name|pb
init|=
operator|new
name|ProcessBuilder
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
name|pb
operator|.
name|redirectErrorStream
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Important, so that the scary looking hs_err_<pid>.log appear under our test temp dir:
name|pb
operator|.
name|directory
argument_list|(
name|childTempDir
operator|.
name|toFile
argument_list|()
argument_list|)
expr_stmt|;
name|Process
name|p
init|=
name|pb
operator|.
name|start
argument_list|()
decl_stmt|;
name|BufferedReader
name|r
decl_stmt|;
try|try
block|{
name|r
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|p
operator|.
name|getInputStream
argument_list|()
argument_list|,
name|IOUtils
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|uee
argument_list|)
throw|;
block|}
name|int
name|tcpPort
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|initCommitVersion
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|initInfosVersion
init|=
operator|-
literal|1
decl_stmt|;
name|Pattern
name|logTimeStart
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^[0-9\\.]+s .*"
argument_list|)
decl_stmt|;
name|boolean
name|willCrash
init|=
literal|false
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|l
init|=
name|r
operator|.
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|==
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"top: node="
operator|+
name|id
operator|+
literal|" failed to start"
argument_list|)
expr_stmt|;
try|try
block|{
name|p
operator|.
name|waitFor
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
name|message
argument_list|(
literal|"exit value="
operator|+
name|p
operator|.
name|exitValue
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|exitValue
argument_list|()
operator|==
literal|0
condition|)
block|{
name|message
argument_list|(
literal|"zero exit status; assuming failed to remove segments_N; skipping"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Hackity hack, in case primary crashed/closed and we haven't noticed (reaped the process) yet:
if|if
condition|(
name|isPrimary
operator|==
literal|false
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|NodeProcess
name|primary2
init|=
name|primary
decl_stmt|;
if|if
condition|(
name|primaryGen
operator|!=
name|myPrimaryGen
operator|||
name|primary2
operator|==
literal|null
operator|||
name|primary2
operator|.
name|nodeIsClosing
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// OK: primary crashed while we were trying to start, so it's expected/allowed that we could not start the replica:
name|message
argument_list|(
literal|"primary crashed/closed while replica R"
operator|+
name|id
operator|+
literal|" tried to start; skipping"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|ThreadInterruptedException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|// Should fail the test:
name|message
argument_list|(
literal|"top: now fail test replica R"
operator|+
name|id
operator|+
literal|" failed to start"
argument_list|)
expr_stmt|;
name|failed
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"replica R"
operator|+
name|id
operator|+
literal|" failed to start"
argument_list|)
throw|;
block|}
if|if
condition|(
name|childLog
operator|!=
literal|null
condition|)
block|{
name|childLog
operator|.
name|write
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|childLog
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|childLog
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|logTimeStart
operator|.
name|matcher
argument_list|(
name|l
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
comment|// Already a well-formed log output:
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|.
name|startsWith
argument_list|(
literal|"PORT: "
argument_list|)
condition|)
block|{
name|tcpPort
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|l
operator|.
name|substring
argument_list|(
literal|6
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|.
name|startsWith
argument_list|(
literal|"COMMIT VERSION: "
argument_list|)
condition|)
block|{
name|initCommitVersion
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|l
operator|.
name|substring
argument_list|(
literal|16
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|.
name|startsWith
argument_list|(
literal|"INFOS VERSION: "
argument_list|)
condition|)
block|{
name|initInfosVersion
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|l
operator|.
name|substring
argument_list|(
literal|15
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|.
name|contains
argument_list|(
literal|"will crash after"
argument_list|)
condition|)
block|{
name|willCrash
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|.
name|startsWith
argument_list|(
literal|"NODE STARTED"
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
specifier|final
name|boolean
name|finalWillCrash
init|=
name|willCrash
decl_stmt|;
specifier|final
name|AtomicBoolean
name|nodeIsClosing
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
comment|// Baby sits the child process, pulling its stdout and printing to our stdout, calling nodeClosed once it exits:
name|Thread
name|pumper
init|=
name|ThreadPumper
operator|.
name|start
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|message
argument_list|(
literal|"now wait for process "
operator|+
name|p
argument_list|)
expr_stmt|;
try|try
block|{
name|p
operator|.
name|waitFor
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|t
argument_list|)
throw|;
block|}
name|message
argument_list|(
literal|"done wait for process "
operator|+
name|p
argument_list|)
expr_stmt|;
name|int
name|exitValue
init|=
name|p
operator|.
name|exitValue
argument_list|()
decl_stmt|;
name|message
argument_list|(
literal|"exit value="
operator|+
name|exitValue
operator|+
literal|" willCrash="
operator|+
name|finalWillCrash
argument_list|)
expr_stmt|;
if|if
condition|(
name|childLog
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|childLog
operator|.
name|write
argument_list|(
literal|"process done; exitValue="
operator|+
name|exitValue
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|childLog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|exitValue
operator|!=
literal|0
operator|&&
name|finalWillCrash
operator|==
literal|false
operator|&&
name|crashingNodes
operator|.
name|remove
argument_list|(
name|id
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// should fail test
name|failed
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|childLog
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"node "
operator|+
name|id
operator|+
literal|" process had unexpected non-zero exit status="
operator|+
name|exitValue
operator|+
literal|"; see "
operator|+
name|childLog
operator|+
literal|" for details"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"node "
operator|+
name|id
operator|+
literal|" process had unexpected non-zero exit status="
operator|+
name|exitValue
argument_list|)
throw|;
block|}
block|}
name|nodeClosed
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
name|r
argument_list|,
name|System
operator|.
name|out
argument_list|,
name|childLog
argument_list|,
name|nodeIsClosing
argument_list|)
decl_stmt|;
name|pumper
operator|.
name|setName
argument_list|(
literal|"pump"
operator|+
name|id
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: node="
operator|+
name|id
operator|+
literal|" started at tcpPort="
operator|+
name|tcpPort
operator|+
literal|" initCommitVersion="
operator|+
name|initCommitVersion
operator|+
literal|" initInfosVersion="
operator|+
name|initInfosVersion
argument_list|)
expr_stmt|;
return|return
operator|new
name|NodeProcess
argument_list|(
name|p
argument_list|,
name|id
argument_list|,
name|tcpPort
argument_list|,
name|pumper
argument_list|,
name|isPrimary
argument_list|,
name|initCommitVersion
argument_list|,
name|initInfosVersion
argument_list|,
name|nodeIsClosing
argument_list|)
return|;
block|}
DECL|method|nodeClosed
specifier|private
name|void
name|nodeClosed
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|NodeProcess
name|oldNode
init|=
name|nodes
index|[
name|id
index|]
decl_stmt|;
if|if
condition|(
name|primary
operator|!=
literal|null
operator|&&
name|oldNode
operator|==
name|primary
condition|)
block|{
name|message
argument_list|(
literal|"top: "
operator|+
name|primary
operator|+
literal|": primary process finished"
argument_list|)
expr_stmt|;
name|primary
operator|=
literal|null
expr_stmt|;
name|primaryGen
operator|++
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"top: "
operator|+
name|oldNode
operator|+
literal|": replica process finished"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldNode
operator|!=
literal|null
condition|)
block|{
name|oldNode
operator|.
name|isOpen
operator|=
literal|false
expr_stmt|;
block|}
name|nodes
index|[
name|id
index|]
operator|=
literal|null
expr_stmt|;
name|nodeTimeStamps
index|[
name|id
index|]
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|sendReplicasToPrimary
argument_list|()
expr_stmt|;
block|}
comment|/** Sends currently alive replicas to primary, which uses this to know who to notify when it does a refresh */
DECL|method|sendReplicasToPrimary
specifier|private
name|void
name|sendReplicasToPrimary
parameter_list|()
block|{
name|NodeProcess
name|curPrimary
init|=
name|primary
decl_stmt|;
if|if
condition|(
name|curPrimary
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|NodeProcess
argument_list|>
name|replicas
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|NodeProcess
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|isPrimary
operator|==
literal|false
condition|)
block|{
name|replicas
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
name|message
argument_list|(
literal|"top: send "
operator|+
name|replicas
operator|.
name|size
argument_list|()
operator|+
literal|" replicas to primary"
argument_list|)
expr_stmt|;
try|try
init|(
name|Connection
name|c
init|=
operator|new
name|Connection
argument_list|(
name|curPrimary
operator|.
name|tcpPort
argument_list|)
init|)
block|{
name|c
operator|.
name|out
operator|.
name|writeByte
argument_list|(
name|SimplePrimaryNode
operator|.
name|CMD_SET_REPLICAS
argument_list|)
expr_stmt|;
name|c
operator|.
name|out
operator|.
name|writeVInt
argument_list|(
name|replicas
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|NodeProcess
name|replica
range|:
name|replicas
control|)
block|{
name|c
operator|.
name|out
operator|.
name|writeVInt
argument_list|(
name|replica
operator|.
name|id
argument_list|)
expr_stmt|;
name|c
operator|.
name|out
operator|.
name|writeVInt
argument_list|(
name|replica
operator|.
name|tcpPort
argument_list|)
expr_stmt|;
block|}
name|c
operator|.
name|flush
argument_list|()
expr_stmt|;
name|c
operator|.
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|message
argument_list|(
literal|"top: ignore exc sending replicas to primary: "
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|addVersionMarker
name|void
name|addVersionMarker
parameter_list|(
name|long
name|version
parameter_list|,
name|int
name|count
parameter_list|)
block|{
comment|//System.out.println("ADD VERSION MARKER version=" + version + " count=" + count);
if|if
condition|(
name|versionToMarker
operator|.
name|containsKey
argument_list|(
name|version
argument_list|)
condition|)
block|{
name|int
name|curCount
init|=
name|versionToMarker
operator|.
name|get
argument_list|(
name|version
argument_list|)
decl_stmt|;
if|if
condition|(
name|curCount
operator|!=
name|count
condition|)
block|{
name|message
argument_list|(
literal|"top: wrong marker count version="
operator|+
name|version
operator|+
literal|" count="
operator|+
name|count
operator|+
literal|" curCount="
operator|+
name|curCount
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"version="
operator|+
name|version
operator|+
literal|" count="
operator|+
name|count
operator|+
literal|" curCount="
operator|+
name|curCount
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|message
argument_list|(
literal|"top: record marker count: version="
operator|+
name|version
operator|+
literal|" count="
operator|+
name|count
argument_list|)
expr_stmt|;
name|versionToMarker
operator|.
name|put
argument_list|(
name|version
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addTransLogLoc
name|void
name|addTransLogLoc
parameter_list|(
name|long
name|version
parameter_list|,
name|long
name|loc
parameter_list|)
block|{
name|message
argument_list|(
literal|"top: record transLogLoc: version="
operator|+
name|version
operator|+
literal|" loc="
operator|+
name|loc
argument_list|)
expr_stmt|;
name|versionToTransLogLocation
operator|.
name|put
argument_list|(
name|version
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|// Periodically wakes up and starts up any down nodes:
DECL|class|RestartThread
specifier|private
class|class
name|RestartThread
extends|extends
name|Thread
block|{
annotation|@
name|Override
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
name|List
argument_list|<
name|Thread
argument_list|>
name|startupThreads
init|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
while|while
condition|(
name|stop
operator|.
name|get
argument_list|()
operator|==
literal|false
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|50
argument_list|,
literal|500
argument_list|)
argument_list|)
expr_stmt|;
comment|//message("top: restarter cycle");
comment|// Randomly crash full cluster:
if|if
condition|(
name|DO_FULL_CLUSTER_CRASH
operator|&&
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|500
argument_list|)
operator|==
literal|17
condition|)
block|{
name|message
argument_list|(
literal|"top: full cluster crash"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|starting
index|[
name|i
index|]
condition|)
block|{
name|message
argument_list|(
literal|"N"
operator|+
name|i
operator|+
literal|": top: wait for startup so we can crash..."
argument_list|)
expr_stmt|;
while|while
condition|(
name|starting
index|[
name|i
index|]
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|message
argument_list|(
literal|"N"
operator|+
name|i
operator|+
literal|": top: done wait for startup"
argument_list|)
expr_stmt|;
block|}
name|NodeProcess
name|node
init|=
name|nodes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|crashingNodes
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: N"
operator|+
name|node
operator|.
name|id
operator|+
literal|": top: now crash node"
argument_list|)
expr_stmt|;
name|node
operator|.
name|crash
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"top: N"
operator|+
name|node
operator|.
name|id
operator|+
literal|": top: done crash node"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|downNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|long
name|nowNS
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|double
name|sec
init|=
operator|(
name|nowNS
operator|-
name|nodeTimeStamps
index|[
name|i
index|]
operator|)
operator|/
literal|1000000000.0
decl_stmt|;
name|String
name|prefix
decl_stmt|;
if|if
condition|(
name|nodes
index|[
name|i
index|]
operator|==
literal|null
condition|)
block|{
name|downNodes
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|starting
index|[
name|i
index|]
condition|)
block|{
name|prefix
operator|=
literal|"s"
expr_stmt|;
block|}
else|else
block|{
name|prefix
operator|=
literal|"x"
expr_stmt|;
block|}
block|}
else|else
block|{
name|prefix
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|primary
operator|!=
literal|null
operator|&&
name|nodes
index|[
name|i
index|]
operator|==
name|primary
condition|)
block|{
name|prefix
operator|+=
literal|"p"
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%s%d(%.1fs)"
argument_list|,
name|prefix
argument_list|,
name|i
argument_list|,
name|sec
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|message
argument_list|(
literal|"node status"
operator|+
name|b
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"downNodes="
operator|+
name|downNodes
argument_list|)
expr_stmt|;
comment|// If primary is down, promote a replica:
if|if
condition|(
name|primary
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|anyNodesStarting
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"top: skip promote replica: nodes are still starting"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|promoteReplica
argument_list|()
expr_stmt|;
block|}
comment|// Randomly start up a down a replica:
comment|// Stop or start a replica
if|if
condition|(
name|downNodes
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
name|int
name|idx
init|=
name|downNodes
operator|.
name|get
argument_list|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|downNodes
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|starting
index|[
name|idx
index|]
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|primary
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|downNodes
operator|.
name|size
argument_list|()
operator|==
name|nodes
operator|.
name|length
condition|)
block|{
comment|// Cold start: entire cluster is down, start this node up as the new primary
name|message
argument_list|(
literal|"N"
operator|+
name|idx
operator|+
literal|": top: cold start as primary"
argument_list|)
expr_stmt|;
name|startPrimary
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|<
operator|(
operator|(
name|double
operator|)
name|downNodes
operator|.
name|size
argument_list|()
operator|)
operator|/
name|nodes
operator|.
name|length
condition|)
block|{
comment|// Start up replica:
name|starting
index|[
name|idx
index|]
operator|=
literal|true
expr_stmt|;
name|message
argument_list|(
literal|"N"
operator|+
name|idx
operator|+
literal|": top: start up: launch thread"
argument_list|)
expr_stmt|;
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|message
argument_list|(
literal|"N"
operator|+
name|idx
operator|+
literal|": top: start up thread"
argument_list|)
expr_stmt|;
name|nodes
index|[
name|idx
index|]
operator|=
name|startNode
argument_list|(
name|idx
argument_list|,
name|indexPaths
index|[
name|idx
index|]
argument_list|,
literal|false
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sendReplicasToPrimary
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|failed
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|t
argument_list|)
throw|;
block|}
finally|finally
block|{
name|starting
index|[
name|idx
index|]
operator|=
literal|false
expr_stmt|;
name|startupThreads
operator|.
name|remove
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|t
operator|.
name|setName
argument_list|(
literal|"start R"
operator|+
name|idx
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
name|startupThreads
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|message
argument_list|(
literal|"node "
operator|+
name|idx
operator|+
literal|" still starting"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Restarter: now stop: join "
operator|+
name|startupThreads
operator|.
name|size
argument_list|()
operator|+
literal|" startup threads"
argument_list|)
expr_stmt|;
while|while
condition|(
name|startupThreads
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|failed
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|t
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Randomly picks a node and runs a search against it */
DECL|class|SearchThread
specifier|private
class|class
name|SearchThread
extends|extends
name|Thread
block|{
annotation|@
name|Override
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// Maps version to number of hits for silly 'the' TermQuery:
name|Query
name|theQuery
init|=
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"body"
argument_list|,
literal|"the"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Persists connections
name|Map
argument_list|<
name|Integer
argument_list|,
name|Connection
argument_list|>
name|connections
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|stop
operator|.
name|get
argument_list|()
operator|==
literal|false
condition|)
block|{
name|NodeProcess
name|node
init|=
name|nodes
index|[
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|nodes
operator|.
name|length
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
operator|||
name|node
operator|.
name|isOpen
operator|==
literal|false
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|node
operator|.
name|lock
operator|.
name|tryLock
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// Node is in the process of closing or crashing or something
continue|continue;
block|}
name|boolean
name|nodeIsPrimary
init|=
name|node
operator|==
name|primary
decl_stmt|;
try|try
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
literal|"Searcher node="
operator|+
name|node
argument_list|)
expr_stmt|;
comment|//System.out.println("S: cycle; conns=" + connections);
name|Connection
name|c
init|=
name|connections
operator|.
name|get
argument_list|(
name|node
operator|.
name|id
argument_list|)
decl_stmt|;
name|long
name|version
decl_stmt|;
try|try
block|{
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
comment|//System.out.println("S: new connection " + node.id + " " + Thread.currentThread().getName());
name|c
operator|=
operator|new
name|Connection
argument_list|(
name|node
operator|.
name|tcpPort
argument_list|)
expr_stmt|;
name|connections
operator|.
name|put
argument_list|(
name|node
operator|.
name|id
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//System.out.println("S: reuse connection " + node.id + " " + Thread.currentThread().getName());
block|}
name|c
operator|.
name|out
operator|.
name|writeByte
argument_list|(
name|SimplePrimaryNode
operator|.
name|CMD_SEARCH
argument_list|)
expr_stmt|;
name|c
operator|.
name|flush
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|.
name|sockIn
operator|.
name|available
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stop
operator|.
name|get
argument_list|()
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|node
operator|.
name|isOpen
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"node closed"
argument_list|)
throw|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|version
operator|=
name|c
operator|.
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|.
name|sockIn
operator|.
name|available
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stop
operator|.
name|get
argument_list|()
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|node
operator|.
name|isOpen
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"node closed"
argument_list|)
throw|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|hitCount
init|=
name|c
operator|.
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|Integer
name|oldHitCount
init|=
name|hitCounts
operator|.
name|get
argument_list|(
name|version
argument_list|)
decl_stmt|;
comment|// TODO: we never prune this map...
if|if
condition|(
name|oldHitCount
operator|==
literal|null
condition|)
block|{
name|hitCounts
operator|.
name|put
argument_list|(
name|version
argument_list|,
name|hitCount
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: searcher: record search hitCount version="
operator|+
name|version
operator|+
literal|" hitCount="
operator|+
name|hitCount
operator|+
literal|" node="
operator|+
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodeIsPrimary
operator|&&
name|version
operator|>
name|lastPrimaryVersion
condition|)
block|{
comment|// It's possible a search request sees a new primary version because it's in the process of flushing, but then the primary
comment|// crashes.  In this case we need to ensure new primary forces its version beyond this:
name|message
argument_list|(
literal|"top: searcher: set lastPrimaryVersion="
operator|+
name|lastPrimaryVersion
operator|+
literal|" vs "
operator|+
name|version
argument_list|)
expr_stmt|;
name|lastPrimaryVersion
operator|=
name|version
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Just ensure that all nodes show the same hit count for
comment|// the same version, i.e. they really are replicas of one another:
if|if
condition|(
name|oldHitCount
operator|.
name|intValue
argument_list|()
operator|!=
name|hitCount
condition|)
block|{
name|failed
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: searcher: wrong version hitCount: version="
operator|+
name|version
operator|+
literal|" oldHitCount="
operator|+
name|oldHitCount
operator|.
name|intValue
argument_list|()
operator|+
literal|" hitCount="
operator|+
name|hitCount
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"version="
operator|+
name|version
operator|+
literal|" oldHitCount="
operator|+
name|oldHitCount
operator|.
name|intValue
argument_list|()
operator|+
literal|" hitCount="
operator|+
name|hitCount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|//message("top: searcher: ignore exc talking to node " + node + ": " + ioe);
comment|//ioe.printStackTrace(System.out);
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|connections
operator|.
name|remove
argument_list|(
name|node
operator|.
name|id
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// This can be null if primary is flushing, has already refreshed its searcher, but is e.g. still notifying replicas and hasn't
comment|// yet returned the version to us, in which case this searcher thread can see the version before the main thread has added it to
comment|// versionToMarker:
name|Integer
name|expectedAtLeastHitCount
init|=
name|versionToMarker
operator|.
name|get
argument_list|(
name|version
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedAtLeastHitCount
operator|!=
literal|null
operator|&&
name|expectedAtLeastHitCount
operator|>
literal|0
operator|&&
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
operator|==
literal|7
condition|)
block|{
try|try
block|{
name|c
operator|.
name|out
operator|.
name|writeByte
argument_list|(
name|SimplePrimaryNode
operator|.
name|CMD_MARKER_SEARCH
argument_list|)
expr_stmt|;
name|c
operator|.
name|out
operator|.
name|writeVInt
argument_list|(
name|expectedAtLeastHitCount
argument_list|)
expr_stmt|;
name|c
operator|.
name|flush
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|.
name|sockIn
operator|.
name|available
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stop
operator|.
name|get
argument_list|()
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|node
operator|.
name|isOpen
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"node died"
argument_list|)
throw|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|version
operator|=
name|c
operator|.
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|.
name|sockIn
operator|.
name|available
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stop
operator|.
name|get
argument_list|()
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|node
operator|.
name|isOpen
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"node died"
argument_list|)
throw|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|hitCount
init|=
name|c
operator|.
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
comment|// Look for data loss: make sure all marker docs are visible:
if|if
condition|(
name|hitCount
operator|<
name|expectedAtLeastHitCount
condition|)
block|{
name|String
name|failMessage
init|=
literal|"node="
operator|+
name|node
operator|+
literal|": documents were lost version="
operator|+
name|version
operator|+
literal|" hitCount="
operator|+
name|hitCount
operator|+
literal|" vs expectedAtLeastHitCount="
operator|+
name|expectedAtLeastHitCount
decl_stmt|;
name|message
argument_list|(
name|failMessage
argument_list|)
expr_stmt|;
name|failed
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|failMessage
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|//message("top: searcher: ignore exc talking to node " + node + ": " + ioe);
comment|//throw new RuntimeException(ioe);
comment|//ioe.printStackTrace(System.out);
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|connections
operator|.
name|remove
argument_list|(
name|node
operator|.
name|id
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|failed
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|t
argument_list|)
throw|;
block|}
finally|finally
block|{
name|node
operator|.
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Searcher: now stop"
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|connections
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|IndexThread
specifier|private
class|class
name|IndexThread
extends|extends
name|Thread
block|{
annotation|@
name|Override
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|LineFileDocs
name|docs
init|=
operator|new
name|LineFileDocs
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|docCount
init|=
literal|0
decl_stmt|;
comment|// How often we do an update/delete vs add:
name|double
name|updatePct
init|=
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
decl_stmt|;
comment|// Varies how many docs/sec we index:
name|int
name|sleepChance
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|4
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|message
argument_list|(
literal|"top: indexer: updatePct="
operator|+
name|updatePct
operator|+
literal|" sleepChance="
operator|+
name|sleepChance
argument_list|)
expr_stmt|;
name|long
name|lastTransLogLoc
init|=
name|transLog
operator|.
name|getNextLocation
argument_list|()
decl_stmt|;
name|NodeProcess
name|curPrimary
init|=
literal|null
decl_stmt|;
name|Connection
name|c
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|stop
operator|.
name|get
argument_list|()
operator|==
literal|false
condition|)
block|{
try|try
block|{
while|while
condition|(
name|stop
operator|.
name|get
argument_list|()
operator|==
literal|false
operator|&&
name|curPrimary
operator|==
literal|null
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|curPrimary
operator|=
name|primary
expr_stmt|;
if|if
condition|(
name|curPrimary
operator|!=
literal|null
condition|)
block|{
name|c
operator|=
operator|new
name|Connection
argument_list|(
name|curPrimary
operator|.
name|tcpPort
argument_list|)
expr_stmt|;
name|c
operator|.
name|out
operator|.
name|writeByte
argument_list|(
name|SimplePrimaryNode
operator|.
name|CMD_INDEXING
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|stop
operator|.
name|get
argument_list|()
condition|)
block|{
break|break;
block|}
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
literal|"indexer p"
operator|+
name|curPrimary
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
operator|==
literal|7
condition|)
block|{
comment|// We use the marker docs to check for data loss in search thread:
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|int
name|id
init|=
name|markerID
operator|.
name|getAndIncrement
argument_list|()
decl_stmt|;
name|String
name|idString
init|=
literal|"m"
operator|+
name|id
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"docid"
argument_list|,
name|idString
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|newStringField
argument_list|(
literal|"marker"
argument_list|,
literal|"marker"
argument_list|,
name|Field
operator|.
name|Store
operator|.
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|curPrimary
operator|.
name|addOrUpdateDocument
argument_list|(
name|c
argument_list|,
name|doc
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|transLog
operator|.
name|addDocument
argument_list|(
name|idString
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|// Only increment after primary replies:
name|markerUpto
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
comment|//message("index marker=" + idString + "; translog is " + Node.bytesToString(Files.size(transLogPath)));
block|}
if|if
condition|(
name|docCount
operator|>
literal|0
operator|&&
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|<
name|updatePct
condition|)
block|{
name|int
name|randomID
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|docCount
argument_list|)
decl_stmt|;
name|String
name|randomIDString
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|randomID
argument_list|)
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// Replace previous doc
name|Document
name|doc
init|=
name|docs
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
operator|(
operator|(
name|Field
operator|)
name|doc
operator|.
name|getField
argument_list|(
literal|"docid"
argument_list|)
operator|)
operator|.
name|setStringValue
argument_list|(
name|randomIDString
argument_list|)
expr_stmt|;
name|curPrimary
operator|.
name|addOrUpdateDocument
argument_list|(
name|c
argument_list|,
name|doc
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|transLog
operator|.
name|updateDocument
argument_list|(
name|randomIDString
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Delete previous doc
name|curPrimary
operator|.
name|deleteDocument
argument_list|(
name|c
argument_list|,
name|randomIDString
argument_list|)
expr_stmt|;
name|transLog
operator|.
name|deleteDocuments
argument_list|(
name|randomIDString
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Add new doc:
name|Document
name|doc
init|=
name|docs
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
name|String
name|idString
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|docCount
operator|++
argument_list|)
decl_stmt|;
operator|(
operator|(
name|Field
operator|)
name|doc
operator|.
name|getField
argument_list|(
literal|"docid"
argument_list|)
operator|)
operator|.
name|setStringValue
argument_list|(
name|idString
argument_list|)
expr_stmt|;
name|curPrimary
operator|.
name|addOrUpdateDocument
argument_list|(
name|c
argument_list|,
name|doc
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|transLog
operator|.
name|addDocument
argument_list|(
name|idString
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|se
parameter_list|)
block|{
comment|// Assume primary crashed
name|message
argument_list|(
literal|"top: indexer lost connection to primary"
argument_list|)
expr_stmt|;
try|try
block|{
name|c
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{             }
name|curPrimary
operator|=
literal|null
expr_stmt|;
name|c
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|sleepChance
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|100
argument_list|)
operator|==
literal|17
condition|)
block|{
name|int
name|pauseMS
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|500
argument_list|,
literal|2000
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Indexer: now pause for "
operator|+
name|pauseMS
operator|+
literal|" msec..."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|pauseMS
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Indexer: done pause for a bit..."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|curPrimary
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|c
operator|.
name|out
operator|.
name|writeByte
argument_list|(
name|SimplePrimaryNode
operator|.
name|CMD_INDEXING_DONE
argument_list|)
expr_stmt|;
name|c
operator|.
name|flush
argument_list|()
expr_stmt|;
name|c
operator|.
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|se
parameter_list|)
block|{
comment|// Assume primary crashed
name|message
argument_list|(
literal|"top: indexer lost connection to primary"
argument_list|)
expr_stmt|;
try|try
block|{
name|c
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{             }
name|curPrimary
operator|=
literal|null
expr_stmt|;
name|c
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Indexer: now stop"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|failed
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|t
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|message
specifier|static
name|void
name|message
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|long
name|now
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%5.3fs       :     parent [%11s] %s"
argument_list|,
operator|(
name|now
operator|-
name|Node
operator|.
name|globalStartNS
operator|)
operator|/
literal|1000000000.
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|message
specifier|static
name|void
name|message
parameter_list|(
name|String
name|message
parameter_list|,
name|long
name|localStartNS
parameter_list|)
block|{
name|long
name|now
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%5.3fs %5.1fs:     parent [%11s] %s"
argument_list|,
operator|(
name|now
operator|-
name|Node
operator|.
name|globalStartNS
operator|)
operator|/
literal|1000000000.
argument_list|,
operator|(
name|now
operator|-
name|localStartNS
operator|)
operator|/
literal|1000000000.
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class
end_unit
