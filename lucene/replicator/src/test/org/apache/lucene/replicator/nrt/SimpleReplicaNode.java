begin_unit
begin_package
DECL|package|org.apache.lucene.replicator.nrt
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|replicator
operator|.
name|nrt
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ServerSocket
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|MatchAllDocsQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|ScoreDoc
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|SearcherFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TopDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MockDirectoryWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RateLimitedIndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RateLimiter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_class
DECL|class|SimpleReplicaNode
class|class
name|SimpleReplicaNode
extends|extends
name|ReplicaNode
block|{
DECL|field|tcpPort
specifier|final
name|int
name|tcpPort
decl_stmt|;
DECL|field|jobs
specifier|final
name|Jobs
name|jobs
decl_stmt|;
comment|// Rate limits incoming bytes/sec when fetching files:
DECL|field|fetchRateLimiter
specifier|final
name|RateLimiter
name|fetchRateLimiter
decl_stmt|;
DECL|field|bytesSinceLastRateLimiterCheck
specifier|final
name|AtomicLong
name|bytesSinceLastRateLimiterCheck
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|random
specifier|final
name|Random
name|random
decl_stmt|;
comment|/** Changes over time, as primary node crashes and moves around */
DECL|field|curPrimaryTCPPort
name|int
name|curPrimaryTCPPort
decl_stmt|;
DECL|method|SimpleReplicaNode
specifier|public
name|SimpleReplicaNode
parameter_list|(
name|Random
name|random
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|tcpPort
parameter_list|,
name|Path
name|indexPath
parameter_list|,
name|long
name|curPrimaryGen
parameter_list|,
name|int
name|primaryTCPPort
parameter_list|,
name|SearcherFactory
name|searcherFactory
parameter_list|,
name|boolean
name|doCheckIndexOnClose
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|id
argument_list|,
name|getDirectory
argument_list|(
name|random
argument_list|,
name|id
argument_list|,
name|indexPath
argument_list|,
name|doCheckIndexOnClose
argument_list|)
argument_list|,
name|searcherFactory
argument_list|)
expr_stmt|;
name|this
operator|.
name|tcpPort
operator|=
name|tcpPort
expr_stmt|;
name|this
operator|.
name|random
operator|=
operator|new
name|Random
argument_list|(
name|random
operator|.
name|nextLong
argument_list|()
argument_list|)
expr_stmt|;
comment|// Random IO throttling on file copies: 5 - 20 MB/sec:
name|double
name|mbPerSec
init|=
literal|5
operator|*
operator|(
literal|1.0
operator|+
literal|3
operator|*
name|random
operator|.
name|nextDouble
argument_list|()
operator|)
decl_stmt|;
name|message
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"top: will rate limit file fetch to %.2f MB/sec"
argument_list|,
name|mbPerSec
argument_list|)
argument_list|)
expr_stmt|;
name|fetchRateLimiter
operator|=
operator|new
name|RateLimiter
operator|.
name|SimpleRateLimiter
argument_list|(
name|mbPerSec
argument_list|)
expr_stmt|;
name|this
operator|.
name|curPrimaryTCPPort
operator|=
name|primaryTCPPort
expr_stmt|;
name|start
argument_list|(
name|curPrimaryGen
argument_list|)
expr_stmt|;
comment|// Handles fetching files from primary:
name|jobs
operator|=
operator|new
name|Jobs
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|jobs
operator|.
name|setName
argument_list|(
literal|"R"
operator|+
name|id
operator|+
literal|".copyJobs"
argument_list|)
expr_stmt|;
name|jobs
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|jobs
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|launch
specifier|protected
name|void
name|launch
parameter_list|(
name|CopyJob
name|job
parameter_list|)
block|{
name|jobs
operator|.
name|launch
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Can't be sync'd when calling jobs since it can lead to deadlock:
name|jobs
operator|.
name|close
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"top: jobs closed"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|mergeCopyJobs
init|)
block|{
for|for
control|(
name|CopyJob
name|job
range|:
name|mergeCopyJobs
control|)
block|{
name|message
argument_list|(
literal|"top: cancel merge copy job "
operator|+
name|job
argument_list|)
expr_stmt|;
name|job
operator|.
name|cancel
argument_list|(
literal|"jobs closing"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|newCopyJob
specifier|protected
name|CopyJob
name|newCopyJob
parameter_list|(
name|String
name|reason
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|FileMetaData
argument_list|>
name|files
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|FileMetaData
argument_list|>
name|prevFiles
parameter_list|,
name|boolean
name|highPriority
parameter_list|,
name|CopyJob
operator|.
name|OnceDone
name|onceDone
parameter_list|)
throws|throws
name|IOException
block|{
name|Connection
name|c
decl_stmt|;
name|CopyState
name|copyState
decl_stmt|;
comment|// Exceptions in here mean something went wrong talking over the socket, which are fine (e.g. primary node crashed):
try|try
block|{
name|c
operator|=
operator|new
name|Connection
argument_list|(
name|curPrimaryTCPPort
argument_list|)
expr_stmt|;
name|c
operator|.
name|out
operator|.
name|writeByte
argument_list|(
name|SimplePrimaryNode
operator|.
name|CMD_FETCH_FILES
argument_list|)
expr_stmt|;
name|c
operator|.
name|out
operator|.
name|writeVInt
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|files
operator|==
literal|null
condition|)
block|{
comment|// No incoming CopyState: ask primary for latest one now
name|c
operator|.
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|1
argument_list|)
expr_stmt|;
name|c
operator|.
name|flush
argument_list|()
expr_stmt|;
name|copyState
operator|=
name|SimpleServer
operator|.
name|readCopyState
argument_list|(
name|c
operator|.
name|in
argument_list|)
expr_stmt|;
name|files
operator|=
name|copyState
operator|.
name|files
expr_stmt|;
block|}
else|else
block|{
name|c
operator|.
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|copyState
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
operator|new
name|NodeCommunicationException
argument_list|(
literal|"exc while reading files to copy"
argument_list|,
name|t
argument_list|)
throw|;
block|}
return|return
operator|new
name|SimpleCopyJob
argument_list|(
name|reason
argument_list|,
name|c
argument_list|,
name|copyState
argument_list|,
name|this
argument_list|,
name|files
argument_list|,
name|highPriority
argument_list|,
name|onceDone
argument_list|)
return|;
block|}
DECL|method|getDirectory
specifier|static
name|Directory
name|getDirectory
parameter_list|(
name|Random
name|random
parameter_list|,
name|int
name|id
parameter_list|,
name|Path
name|path
parameter_list|,
name|boolean
name|doCheckIndexOnClose
parameter_list|)
throws|throws
name|IOException
block|{
name|MockDirectoryWrapper
name|dir
init|=
name|LuceneTestCase
operator|.
name|newMockFSDirectory
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|dir
operator|.
name|setAssertNoUnrefencedFilesOnClose
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dir
operator|.
name|setCheckIndexOnClose
argument_list|(
name|doCheckIndexOnClose
argument_list|)
expr_stmt|;
comment|// Corrupt any index files not referenced by current commit point; this is important (increases test evilness) because we may have done
comment|// a hard crash of the previous JVM writing to this directory and so MDW's corrupt-unknown-files-on-close never ran:
name|Node
operator|.
name|nodeMessage
argument_list|(
name|id
argument_list|,
literal|"top: corrupt unknown files"
argument_list|)
expr_stmt|;
name|dir
operator|.
name|corruptUnknownFiles
argument_list|()
expr_stmt|;
return|return
name|dir
return|;
block|}
DECL|field|CMD_NEW_NRT_POINT
specifier|static
specifier|final
name|byte
name|CMD_NEW_NRT_POINT
init|=
literal|0
decl_stmt|;
comment|// Sent by primary to replica to pre-copy merge files:
DECL|field|CMD_PRE_COPY_MERGE
specifier|static
specifier|final
name|byte
name|CMD_PRE_COPY_MERGE
init|=
literal|17
decl_stmt|;
comment|/** Handles incoming request to the naive TCP server wrapping this node */
DECL|method|handleOneConnection
name|void
name|handleOneConnection
parameter_list|(
name|ServerSocket
name|ss
parameter_list|,
name|AtomicBoolean
name|stop
parameter_list|,
name|InputStream
name|is
parameter_list|,
name|Socket
name|socket
parameter_list|,
name|DataInput
name|in
parameter_list|,
name|DataOutput
name|out
parameter_list|,
name|BufferedOutputStream
name|bos
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|//message("one connection: " + socket);
name|outer
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|byte
name|cmd
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|is
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|stop
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|cmd
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|eofe
parameter_list|)
block|{
break|break;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CMD_NEW_NRT_POINT
case|:
block|{
name|long
name|version
init|=
name|in
operator|.
name|readVLong
argument_list|()
decl_stmt|;
name|long
name|newPrimaryGen
init|=
name|in
operator|.
name|readVLong
argument_list|()
decl_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
literal|"recv-"
operator|+
name|version
argument_list|)
expr_stmt|;
name|curPrimaryTCPPort
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"newNRTPoint primaryTCPPort="
operator|+
name|curPrimaryTCPPort
operator|+
literal|" version="
operator|+
name|version
operator|+
literal|" newPrimaryGen="
operator|+
name|newPrimaryGen
argument_list|)
expr_stmt|;
name|newNRTPoint
argument_list|(
name|newPrimaryGen
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SimplePrimaryNode
operator|.
name|CMD_GET_SEARCHING_VERSION
case|:
comment|// This is called when primary has crashed and we need to elect a new primary from all the still running replicas:
comment|// Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now
comment|// in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:
if|if
condition|(
name|isCopying
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"top: getSearchingVersion: now wait for finish sync"
argument_list|)
expr_stmt|;
comment|// TODO: use immediate concurrency instead of polling:
while|while
condition|(
name|isCopying
argument_list|()
operator|&&
name|stop
operator|.
name|get
argument_list|()
operator|==
literal|false
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"top: curNRTCopy="
operator|+
name|curNRTCopy
argument_list|)
expr_stmt|;
block|}
name|message
argument_list|(
literal|"top: getSearchingVersion: done wait for finish sync"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stop
operator|.
name|get
argument_list|()
operator|==
literal|false
condition|)
block|{
name|out
operator|.
name|writeVLong
argument_list|(
name|getCurrentSearchingVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"top: getSearchingVersion: stop waiting for finish sync: stop is set"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SimplePrimaryNode
operator|.
name|CMD_SEARCH
case|:
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
literal|"search"
argument_list|)
expr_stmt|;
name|IndexSearcher
name|searcher
init|=
name|mgr
operator|.
name|acquire
argument_list|()
decl_stmt|;
try|try
block|{
name|long
name|version
init|=
operator|(
operator|(
name|DirectoryReader
operator|)
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|)
operator|.
name|getVersion
argument_list|()
decl_stmt|;
name|int
name|hitCount
init|=
name|searcher
operator|.
name|search
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"body"
argument_list|,
literal|"the"
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|.
name|totalHits
decl_stmt|;
comment|//node.message("version=" + version + " searcher=" + searcher);
name|out
operator|.
name|writeVLong
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|hitCount
argument_list|)
expr_stmt|;
name|bos
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|mgr
operator|.
name|release
argument_list|(
name|searcher
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue
name|outer
continue|;
case|case
name|SimplePrimaryNode
operator|.
name|CMD_SEARCH_ALL
case|:
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
literal|"search all"
argument_list|)
expr_stmt|;
name|IndexSearcher
name|searcher
init|=
name|mgr
operator|.
name|acquire
argument_list|()
decl_stmt|;
try|try
block|{
name|long
name|version
init|=
operator|(
operator|(
name|DirectoryReader
operator|)
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|)
operator|.
name|getVersion
argument_list|()
decl_stmt|;
name|int
name|hitCount
init|=
name|searcher
operator|.
name|search
argument_list|(
operator|new
name|MatchAllDocsQuery
argument_list|()
argument_list|,
literal|1
argument_list|)
operator|.
name|totalHits
decl_stmt|;
comment|//node.message("version=" + version + " searcher=" + searcher);
name|out
operator|.
name|writeVLong
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|hitCount
argument_list|)
expr_stmt|;
name|bos
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|mgr
operator|.
name|release
argument_list|(
name|searcher
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue
name|outer
continue|;
case|case
name|SimplePrimaryNode
operator|.
name|CMD_MARKER_SEARCH
case|:
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
literal|"msearch"
argument_list|)
expr_stmt|;
name|int
name|expectedAtLeastCount
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|IndexSearcher
name|searcher
init|=
name|mgr
operator|.
name|acquire
argument_list|()
decl_stmt|;
try|try
block|{
name|long
name|version
init|=
operator|(
operator|(
name|DirectoryReader
operator|)
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|)
operator|.
name|getVersion
argument_list|()
decl_stmt|;
name|int
name|hitCount
init|=
name|searcher
operator|.
name|count
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"marker"
argument_list|,
literal|"marker"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|hitCount
operator|<
name|expectedAtLeastCount
condition|)
block|{
name|message
argument_list|(
literal|"marker search: expectedAtLeastCount="
operator|+
name|expectedAtLeastCount
operator|+
literal|" but hitCount="
operator|+
name|hitCount
argument_list|)
expr_stmt|;
name|TopDocs
name|hits
init|=
name|searcher
operator|.
name|search
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"marker"
argument_list|,
literal|"marker"
argument_list|)
argument_list|)
argument_list|,
name|expectedAtLeastCount
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|seen
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ScoreDoc
name|hit
range|:
name|hits
operator|.
name|scoreDocs
control|)
block|{
name|Document
name|doc
init|=
name|searcher
operator|.
name|doc
argument_list|(
name|hit
operator|.
name|doc
argument_list|)
decl_stmt|;
name|seen
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|doc
operator|.
name|get
argument_list|(
literal|"docid"
argument_list|)
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|seen
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"saw markers:"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|marker
range|:
name|seen
control|)
block|{
name|message
argument_list|(
literal|"saw m"
operator|+
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
name|out
operator|.
name|writeVLong
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|hitCount
argument_list|)
expr_stmt|;
name|bos
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|mgr
operator|.
name|release
argument_list|(
name|searcher
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue
name|outer
continue|;
case|case
name|SimplePrimaryNode
operator|.
name|CMD_COMMIT
case|:
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
literal|"commit"
argument_list|)
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SimplePrimaryNode
operator|.
name|CMD_CLOSE
case|:
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
name|ss
operator|.
name|close
argument_list|()
expr_stmt|;
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|1
argument_list|)
expr_stmt|;
break|break
name|outer
break|;
case|case
name|CMD_PRE_COPY_MERGE
case|:
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
literal|"merge copy"
argument_list|)
expr_stmt|;
name|long
name|newPrimaryGen
init|=
name|in
operator|.
name|readVLong
argument_list|()
decl_stmt|;
name|curPrimaryTCPPort
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|FileMetaData
argument_list|>
name|files
init|=
name|SimpleServer
operator|.
name|readFilesMetaData
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|message
argument_list|(
literal|"done reading files to copy files="
operator|+
name|files
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|AtomicBoolean
name|finished
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|CopyJob
name|job
init|=
name|launchPreCopyMerge
argument_list|(
name|finished
argument_list|,
name|newPrimaryGen
argument_list|,
name|files
argument_list|)
decl_stmt|;
name|message
argument_list|(
literal|"done launching copy job files="
operator|+
name|files
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
comment|// Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary
comment|// won't notice for a very long time:
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|finished
operator|.
name|get
argument_list|()
operator|||
name|stop
operator|.
name|get
argument_list|()
condition|)
block|{
break|break;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|100
condition|)
block|{
comment|// Once per second or so, we send a keep alive
name|message
argument_list|(
literal|"send merge pre copy keep alive... files="
operator|+
name|files
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
comment|// To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|1
argument_list|)
expr_stmt|;
name|bos
operator|.
name|flush
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|message
argument_list|(
literal|"done merge copy files="
operator|+
name|files
operator|.
name|keySet
argument_list|()
operator|+
literal|" success="
operator|+
name|success
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unrecognized cmd="
operator|+
name|cmd
argument_list|)
throw|;
block|}
name|bos
operator|.
name|flush
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
annotation|@
name|Override
DECL|method|sendNewReplica
specifier|protected
name|void
name|sendNewReplica
parameter_list|()
throws|throws
name|IOException
block|{
name|message
argument_list|(
literal|"send new_replica to primary tcpPort="
operator|+
name|curPrimaryTCPPort
argument_list|)
expr_stmt|;
try|try
init|(
name|Connection
name|c
init|=
operator|new
name|Connection
argument_list|(
name|curPrimaryTCPPort
argument_list|)
init|)
block|{
name|c
operator|.
name|out
operator|.
name|writeByte
argument_list|(
name|SimplePrimaryNode
operator|.
name|CMD_NEW_REPLICA
argument_list|)
expr_stmt|;
name|c
operator|.
name|out
operator|.
name|writeVInt
argument_list|(
name|tcpPort
argument_list|)
expr_stmt|;
name|c
operator|.
name|flush
argument_list|()
expr_stmt|;
name|c
operator|.
name|s
operator|.
name|shutdownOutput
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|message
argument_list|(
literal|"ignoring exc "
operator|+
name|t
operator|+
literal|" sending new_replica to primary tcpPort="
operator|+
name|curPrimaryTCPPort
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|createTempOutput
specifier|public
name|IndexOutput
name|createTempOutput
parameter_list|(
name|String
name|prefix
parameter_list|,
name|String
name|suffix
parameter_list|,
name|IOContext
name|ioContext
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|RateLimitedIndexOutput
argument_list|(
name|fetchRateLimiter
argument_list|,
name|super
operator|.
name|createTempOutput
argument_list|(
name|prefix
argument_list|,
name|suffix
argument_list|,
name|ioContext
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class
end_unit
