begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.analysis.ja
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|ja
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|CharTermAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|KeywordAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|OffsetAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|PositionIncrementAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|PositionLengthAttribute
import|;
end_import
begin_comment
comment|/**  * A {@link TokenFilter} that normalizes Japanese numbers (kansÅ«ji) to regular Arabic  * decimal numbers in half-width characters.  *<p>  * Japanese numbers are often written using a combination of kanji and Arabic numbers with  * various kinds punctuation. For example, ï¼ï¼ï¼å means 3200. This filter does this kind  * of normalization and allows a search for 3200 to match ï¼ï¼ï¼å in text, but can also be  * used to make range facets based on the normalized numbers and so on.  *<p>  * Notice that this analyzer uses a token composition scheme and relies on punctuation  * tokens being found in the token stream. Please make sure your {@link JapaneseTokenizer}  * has {@code discardPunctuation} set to false. In case punctuation characters, such as ï¼  * (U+FF0E FULLWIDTH FULL STOP), is removed from the token stream, this filter would find  * input tokens tokens ï¼ and ï¼å and give outputs 3 and 2000 instead of 3200, which is  * likely not the intended result. If you want to remove punctuation characters from your  * index that are not part of normalized numbers, add a  * {@link org.apache.lucene.analysis.core.StopFilter} with the punctuation you wish to  * remove after {@link JapaneseNumberFilter} in your analyzer chain.  *<p>  * Below are some examples of normalizations this filter supports. The input is untokenized  * text and the result is the single term attribute emitted for the input.  *<ul>  *<li>ããä¸ becomes 7</li>  *<li>ä¸ããã becomes 1000</li>  *<li>ä¸å2ç¾ï¼åä¸ becomes 3223</li>  *<li>åå­ç¾ä¸äºåä¸ becomes 1000006005001</li>  *<li>ï¼ï¼ï¼å becomes 3200</li>  *<li>ï¼ï¼ï¼ä¸ï¼ï¼ï¼ï¼ï¼ï¼ becomes 12345.67</li>  *<li>4,647.100 becomes 4647.1</li>  *<li>15,7 becomes 157 (be aware of this weakness)</li>  *</ul>  *<p>  * Tokens preceded by a token with {@link PositionIncrementAttribute} of zero are left  * left untouched and emitted as-is.  *<p>  * This filter does not use any part-of-speech information for its normalization and  * the motivation for this is to also support n-grammed token streams in the future.  *<p>  * This filter may in some cases normalize tokens that are not numbers in their context.  * For example, is ç°ä¸­äº¬ä¸ is a name and means Tanaka KyÅichi, but äº¬ä¸ (KyÅichi) out of  * context can strictly speaking also represent the number 10000000000000001. This filter  * respects the {@link KeywordAttribute}, which can be used to prevent specific  * normalizations from happening.  *<p>  * Also notice that token attributes such as  * {@link org.apache.lucene.analysis.ja.tokenattributes.PartOfSpeechAttribute},  * {@link org.apache.lucene.analysis.ja.tokenattributes.ReadingAttribute},  * {@link org.apache.lucene.analysis.ja.tokenattributes.InflectionAttribute} and  * {@link org.apache.lucene.analysis.ja.tokenattributes.BaseFormAttribute} are left  * unchanged and will inherit the values of the last token used to compose the normalized  * number and can be wrong. Hence, for ï¼ï¼ä¸ (10000), we will have  * {@link org.apache.lucene.analysis.ja.tokenattributes.ReadingAttribute}  * set to ãã³. This is a known issue and is subject to a future improvement.  *<p>  * Japanese formal numbers (daiji), accounting numbers and decimal fractions are currently  * not supported.  */
end_comment
begin_class
DECL|class|JapaneseNumberFilter
specifier|public
class|class
name|JapaneseNumberFilter
extends|extends
name|TokenFilter
block|{
DECL|field|termAttr
specifier|private
specifier|final
name|CharTermAttribute
name|termAttr
init|=
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|offsetAttr
specifier|private
specifier|final
name|OffsetAttribute
name|offsetAttr
init|=
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|keywordAttr
specifier|private
specifier|final
name|KeywordAttribute
name|keywordAttr
init|=
name|addAttribute
argument_list|(
name|KeywordAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|posIncrAttr
specifier|private
specifier|final
name|PositionIncrementAttribute
name|posIncrAttr
init|=
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|posLengthAttr
specifier|private
specifier|final
name|PositionLengthAttribute
name|posLengthAttr
init|=
name|addAttribute
argument_list|(
name|PositionLengthAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|NO_NUMERAL
specifier|private
specifier|static
name|char
name|NO_NUMERAL
init|=
name|Character
operator|.
name|MAX_VALUE
decl_stmt|;
DECL|field|numerals
specifier|private
specifier|static
name|char
index|[]
name|numerals
decl_stmt|;
DECL|field|exponents
specifier|private
specifier|static
name|char
index|[]
name|exponents
decl_stmt|;
DECL|field|state
specifier|private
name|State
name|state
decl_stmt|;
DECL|field|numeral
specifier|private
name|StringBuilder
name|numeral
decl_stmt|;
DECL|field|fallThroughTokens
specifier|private
name|int
name|fallThroughTokens
decl_stmt|;
static|static
block|{
name|numerals
operator|=
operator|new
name|char
index|[
literal|0x10000
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numerals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|numerals
index|[
name|i
index|]
operator|=
name|NO_NUMERAL
expr_stmt|;
block|}
name|numerals
index|[
literal|'ã'
index|]
operator|=
literal|0
expr_stmt|;
comment|// ã U+3007 0
name|numerals
index|[
literal|'ä¸'
index|]
operator|=
literal|1
expr_stmt|;
comment|// ä¸ U+4E00 1
name|numerals
index|[
literal|'äº'
index|]
operator|=
literal|2
expr_stmt|;
comment|// äº U+4E8C 2
name|numerals
index|[
literal|'ä¸'
index|]
operator|=
literal|3
expr_stmt|;
comment|// ä¸ U+4E09 3
name|numerals
index|[
literal|'å'
index|]
operator|=
literal|4
expr_stmt|;
comment|// å U+56DB 4
name|numerals
index|[
literal|'äº'
index|]
operator|=
literal|5
expr_stmt|;
comment|// äº U+4E94 5
name|numerals
index|[
literal|'å­'
index|]
operator|=
literal|6
expr_stmt|;
comment|// å­ U+516D 6
name|numerals
index|[
literal|'ä¸'
index|]
operator|=
literal|7
expr_stmt|;
comment|// ä¸ U+4E03 7
name|numerals
index|[
literal|'å«'
index|]
operator|=
literal|8
expr_stmt|;
comment|// å« U+516B 8
name|numerals
index|[
literal|'ä¹'
index|]
operator|=
literal|9
expr_stmt|;
comment|// ä¹ U+4E5D 9
name|exponents
operator|=
operator|new
name|char
index|[
literal|0x10000
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exponents
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|exponents
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|exponents
index|[
literal|'å'
index|]
operator|=
literal|1
expr_stmt|;
comment|// å U+5341 10
name|exponents
index|[
literal|'ç¾'
index|]
operator|=
literal|2
expr_stmt|;
comment|// ç¾ U+767E 100
name|exponents
index|[
literal|'å'
index|]
operator|=
literal|3
expr_stmt|;
comment|// å U+5343 1,000
name|exponents
index|[
literal|'ä¸'
index|]
operator|=
literal|4
expr_stmt|;
comment|// ä¸ U+4E07 10,000
name|exponents
index|[
literal|'å'
index|]
operator|=
literal|8
expr_stmt|;
comment|// å U+5104 100,000,000
name|exponents
index|[
literal|'å'
index|]
operator|=
literal|12
expr_stmt|;
comment|// å U+5146 1,000,000,000,000
name|exponents
index|[
literal|'äº¬'
index|]
operator|=
literal|16
expr_stmt|;
comment|// äº¬ U+4EAC 10,000,000,000,000,000
name|exponents
index|[
literal|'å'
index|]
operator|=
literal|20
expr_stmt|;
comment|// å U+5793 100,000,000,000,000,000,000
block|}
DECL|method|JapaneseNumberFilter
specifier|public
name|JapaneseNumberFilter
parameter_list|(
name|TokenStream
name|input
parameter_list|)
block|{
name|super
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|incrementToken
specifier|public
specifier|final
name|boolean
name|incrementToken
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Emit previously captured token we read past earlier
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
name|restoreState
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|state
operator|=
literal|null
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|input
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|keywordAttr
operator|.
name|isKeyword
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|fallThroughTokens
operator|>
literal|0
condition|)
block|{
name|fallThroughTokens
operator|--
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|posIncrAttr
operator|.
name|getPositionIncrement
argument_list|()
operator|==
literal|0
condition|)
block|{
name|fallThroughTokens
operator|=
name|posLengthAttr
operator|.
name|getPositionLength
argument_list|()
operator|-
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
name|boolean
name|moreTokens
init|=
literal|true
decl_stmt|;
name|boolean
name|composedNumberToken
init|=
literal|false
decl_stmt|;
name|int
name|startOffset
init|=
literal|0
decl_stmt|;
name|int
name|endOffset
init|=
literal|0
decl_stmt|;
name|State
name|preCompositionState
init|=
name|captureState
argument_list|()
decl_stmt|;
name|String
name|term
init|=
name|termAttr
operator|.
name|toString
argument_list|()
decl_stmt|;
name|boolean
name|numeralTerm
init|=
name|isNumeral
argument_list|(
name|term
argument_list|)
decl_stmt|;
while|while
condition|(
name|moreTokens
operator|&&
name|numeralTerm
condition|)
block|{
if|if
condition|(
operator|!
name|composedNumberToken
condition|)
block|{
name|startOffset
operator|=
name|offsetAttr
operator|.
name|startOffset
argument_list|()
expr_stmt|;
name|composedNumberToken
operator|=
literal|true
expr_stmt|;
block|}
name|endOffset
operator|=
name|offsetAttr
operator|.
name|endOffset
argument_list|()
expr_stmt|;
name|moreTokens
operator|=
name|input
operator|.
name|incrementToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|posIncrAttr
operator|.
name|getPositionIncrement
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// This token is a stacked/synonym token, capture number of tokens "under" this token,
comment|// except the first token, which we will emit below after restoring state
name|fallThroughTokens
operator|=
name|posLengthAttr
operator|.
name|getPositionLength
argument_list|()
operator|-
literal|1
expr_stmt|;
name|state
operator|=
name|captureState
argument_list|()
expr_stmt|;
name|restoreState
argument_list|(
name|preCompositionState
argument_list|)
expr_stmt|;
return|return
name|moreTokens
return|;
block|}
name|numeral
operator|.
name|append
argument_list|(
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|moreTokens
condition|)
block|{
name|term
operator|=
name|termAttr
operator|.
name|toString
argument_list|()
expr_stmt|;
name|numeralTerm
operator|=
name|isNumeral
argument_list|(
name|term
argument_list|)
operator|||
name|isNumeralPunctuation
argument_list|(
name|term
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|composedNumberToken
condition|)
block|{
if|if
condition|(
name|moreTokens
condition|)
block|{
comment|// We have read past all numerals and there are still tokens left, so
comment|// capture the state of this token and emit it on our next incrementToken()
name|state
operator|=
name|captureState
argument_list|()
expr_stmt|;
block|}
name|String
name|normalizedNumber
init|=
name|normalizeNumber
argument_list|(
name|numeral
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|termAttr
operator|.
name|setEmpty
argument_list|()
expr_stmt|;
name|termAttr
operator|.
name|append
argument_list|(
name|normalizedNumber
argument_list|)
expr_stmt|;
name|offsetAttr
operator|.
name|setOffset
argument_list|(
name|startOffset
argument_list|,
name|endOffset
argument_list|)
expr_stmt|;
name|numeral
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|moreTokens
return|;
block|}
annotation|@
name|Override
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|reset
argument_list|()
expr_stmt|;
name|fallThroughTokens
operator|=
literal|0
expr_stmt|;
name|numeral
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
name|state
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * Normalizes a Japanese number    *    * @param number number or normalize    * @return normalized number, or number to normalize on error (no op)    */
DECL|method|normalizeNumber
specifier|public
name|String
name|normalizeNumber
parameter_list|(
name|String
name|number
parameter_list|)
block|{
try|try
block|{
name|BigDecimal
name|normalizedNumber
init|=
name|parseNumber
argument_list|(
operator|new
name|NumberBuffer
argument_list|(
name|number
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|normalizedNumber
operator|==
literal|null
condition|)
block|{
return|return
name|number
return|;
block|}
return|return
name|normalizedNumber
operator|.
name|stripTrailingZeros
argument_list|()
operator|.
name|toPlainString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
decl||
name|ArithmeticException
name|e
parameter_list|)
block|{
comment|// Return the source number in case of error, i.e. malformed input
return|return
name|number
return|;
block|}
block|}
comment|/**    * Parses a Japanese number    *    * @param buffer buffer to parse    * @return parsed number, or null on error or end of input    */
DECL|method|parseNumber
specifier|private
name|BigDecimal
name|parseNumber
parameter_list|(
name|NumberBuffer
name|buffer
parameter_list|)
block|{
name|BigDecimal
name|sum
init|=
name|BigDecimal
operator|.
name|ZERO
decl_stmt|;
name|BigDecimal
name|result
init|=
name|parseLargePair
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
while|while
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|sum
operator|=
name|sum
operator|.
name|add
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|parseLargePair
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
comment|/**    * Parses a pair of large numbers, i.e. large kanji factor is 10,000ï¼ä¸ï¼or larger    *    * @param buffer buffer to parse    * @return parsed pair, or null on error or end of input    */
DECL|method|parseLargePair
specifier|private
name|BigDecimal
name|parseLargePair
parameter_list|(
name|NumberBuffer
name|buffer
parameter_list|)
block|{
name|BigDecimal
name|first
init|=
name|parseMediumNumber
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|BigDecimal
name|second
init|=
name|parseLargeKanjiNumeral
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
operator|==
literal|null
operator|&&
name|second
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|second
operator|==
literal|null
condition|)
block|{
comment|// If there's no second factor, we return the first one
comment|// This can happen if we our number is smaller than 10,000 (ä¸)
return|return
name|first
return|;
block|}
if|if
condition|(
name|first
operator|==
literal|null
condition|)
block|{
comment|// If there's no first factor, just return the second one,
comment|// which is the same as multiplying by 1, i.e. with ä¸
return|return
name|second
return|;
block|}
return|return
name|first
operator|.
name|multiply
argument_list|(
name|second
argument_list|)
return|;
block|}
comment|/**    * Parses a "medium sized" number, typically less than 10,000ï¼ä¸ï¼, but might be larger    * due to a larger factor from {link parseBasicNumber}.    *    * @param buffer buffer to parse    * @return parsed number, or null on error or end of input    */
DECL|method|parseMediumNumber
specifier|private
name|BigDecimal
name|parseMediumNumber
parameter_list|(
name|NumberBuffer
name|buffer
parameter_list|)
block|{
name|BigDecimal
name|sum
init|=
name|BigDecimal
operator|.
name|ZERO
decl_stmt|;
name|BigDecimal
name|result
init|=
name|parseMediumPair
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
while|while
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|sum
operator|=
name|sum
operator|.
name|add
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|parseMediumPair
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
comment|/**    * Parses a pair of "medium sized" numbers, i.e. large kanji factor is at most 1,000ï¼åï¼    *    * @param buffer buffer to parse    * @return parsed pair, or null on error or end of input    */
DECL|method|parseMediumPair
specifier|private
name|BigDecimal
name|parseMediumPair
parameter_list|(
name|NumberBuffer
name|buffer
parameter_list|)
block|{
name|BigDecimal
name|first
init|=
name|parseBasicNumber
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|BigDecimal
name|second
init|=
name|parseMediumKanjiNumeral
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
operator|==
literal|null
operator|&&
name|second
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|second
operator|==
literal|null
condition|)
block|{
comment|// If there's no second factor, we return the first one
comment|// This can happen if we just have a plain number such as äº
return|return
name|first
return|;
block|}
if|if
condition|(
name|first
operator|==
literal|null
condition|)
block|{
comment|// If there's no first factor, just return the second one,
comment|// which is the same as multiplying by 1, i.e. with å
return|return
name|second
return|;
block|}
comment|// Return factors multiplied
return|return
name|first
operator|.
name|multiply
argument_list|(
name|second
argument_list|)
return|;
block|}
comment|/**    * Parse a basic number, which is a sequence of Arabic numbers or a sequence or 0-9 kanji numerals (ã to ä¹).    *    * @param buffer buffer to parse    * @return parsed number, or null on error or end of input    */
DECL|method|parseBasicNumber
specifier|private
name|BigDecimal
name|parseBasicNumber
parameter_list|(
name|NumberBuffer
name|buffer
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|i
init|=
name|buffer
operator|.
name|position
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|buffer
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|buffer
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|isArabicNumeral
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|// Arabic numerals; 0 to 9 or ï¼ to ï¼ (full-width)
name|builder
operator|.
name|append
argument_list|(
name|arabicNumeralValue
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isKanjiNumeral
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|// Kanji numerals; ã, ä¸, äº, ä¸, å, äº, å­, ä¸, å«, or ä¹
name|builder
operator|.
name|append
argument_list|(
name|kanjiNumeralValue
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDecimalPoint
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isThousandSeparator
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|// Just skip and move to the next character
block|}
else|else
block|{
comment|// We don't have an Arabic nor kanji numeral, nor separation or punctuation, so we'll stop.
break|break;
block|}
name|i
operator|++
expr_stmt|;
name|buffer
operator|.
name|advance
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|builder
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// We didn't build anything, so we don't have a number
return|return
literal|null
return|;
block|}
return|return
operator|new
name|BigDecimal
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Parse large kanji numerals (ten thousands or larger)    *    * @param buffer buffer to parse    * @return parsed number, or null on error or end of input    */
DECL|method|parseLargeKanjiNumeral
specifier|public
name|BigDecimal
name|parseLargeKanjiNumeral
parameter_list|(
name|NumberBuffer
name|buffer
parameter_list|)
block|{
name|int
name|i
init|=
name|buffer
operator|.
name|position
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|buffer
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|char
name|c
init|=
name|buffer
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|power
init|=
name|exponents
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
name|power
operator|>
literal|3
condition|)
block|{
name|buffer
operator|.
name|advance
argument_list|()
expr_stmt|;
return|return
name|BigDecimal
operator|.
name|TEN
operator|.
name|pow
argument_list|(
name|power
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Parse medium kanji numerals (tens, hundreds or thousands)    *    * @param buffer buffer to parse    * @return parsed number or null on error    */
DECL|method|parseMediumKanjiNumeral
specifier|public
name|BigDecimal
name|parseMediumKanjiNumeral
parameter_list|(
name|NumberBuffer
name|buffer
parameter_list|)
block|{
name|int
name|i
init|=
name|buffer
operator|.
name|position
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|buffer
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|char
name|c
init|=
name|buffer
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|power
init|=
name|exponents
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
literal|1
operator|<=
name|power
operator|&&
name|power
operator|<=
literal|3
condition|)
block|{
name|buffer
operator|.
name|advance
argument_list|()
expr_stmt|;
return|return
name|BigDecimal
operator|.
name|TEN
operator|.
name|pow
argument_list|(
name|power
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Numeral predicate    *    * @param input string to test    * @return true if and only if input is a numeral    */
DECL|method|isNumeral
specifier|public
name|boolean
name|isNumeral
parameter_list|(
name|String
name|input
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|input
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isNumeral
argument_list|(
name|input
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Numeral predicate    *    * @param c character to test    * @return true if and only if c is a numeral    */
DECL|method|isNumeral
specifier|public
name|boolean
name|isNumeral
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|isArabicNumeral
argument_list|(
name|c
argument_list|)
operator|||
name|isKanjiNumeral
argument_list|(
name|c
argument_list|)
operator|||
name|exponents
index|[
name|c
index|]
operator|>
literal|0
return|;
block|}
comment|/**    * Numeral punctuation predicate    *    * @param input string to test    * @return true if and only if c is a numeral punctuation string    */
DECL|method|isNumeralPunctuation
specifier|public
name|boolean
name|isNumeralPunctuation
parameter_list|(
name|String
name|input
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|input
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isNumeralPunctuation
argument_list|(
name|input
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Numeral punctuation predicate    *    * @param c character to test    * @return true if and only if c is a numeral punctuation character    */
DECL|method|isNumeralPunctuation
specifier|public
name|boolean
name|isNumeralPunctuation
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|isDecimalPoint
argument_list|(
name|c
argument_list|)
operator|||
name|isThousandSeparator
argument_list|(
name|c
argument_list|)
return|;
block|}
comment|/**    * Arabic numeral predicate. Both half-width and full-width characters are supported    *    * @param c character to test    * @return true if and only if c is an Arabic numeral    */
DECL|method|isArabicNumeral
specifier|public
name|boolean
name|isArabicNumeral
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|isHalfWidthArabicNumeral
argument_list|(
name|c
argument_list|)
operator|||
name|isFullWidthArabicNumeral
argument_list|(
name|c
argument_list|)
return|;
block|}
comment|/**    * Arabic half-width numeral predicate    *    * @param c character to test    * @return true if and only if c is a half-width Arabic numeral    */
DECL|method|isHalfWidthArabicNumeral
specifier|private
name|boolean
name|isHalfWidthArabicNumeral
parameter_list|(
name|char
name|c
parameter_list|)
block|{
comment|// 0 U+0030 - 9 U+0039
return|return
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
return|;
block|}
comment|/**    * Arabic full-width numeral predicate    *    * @param c character to test    * @return true if and only if c is a full-width Arabic numeral    */
DECL|method|isFullWidthArabicNumeral
specifier|private
name|boolean
name|isFullWidthArabicNumeral
parameter_list|(
name|char
name|c
parameter_list|)
block|{
comment|// ï¼ U+FF10 - ï¼ U+FF19
return|return
literal|'ï¼'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'ï¼'
return|;
block|}
comment|/**    * Returns the numeric value for the specified character Arabic numeral.    * Behavior is undefined if a non-Arabic numeral is provided    *    * @param c arabic numeral character    * @return numeral value    */
DECL|method|arabicNumeralValue
specifier|private
name|int
name|arabicNumeralValue
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|isHalfWidthArabicNumeral
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|offset
operator|=
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
literal|'ï¼'
expr_stmt|;
block|}
return|return
name|c
operator|-
name|offset
return|;
block|}
comment|/**    * Kanji numeral predicate that tests if the provided character is one of ã, ä¸, äº, ä¸, å, äº, å­, ä¸, å«, or ä¹.    * Larger number kanji gives a false value.    *    * @param c character to test    * @return true if and only is character is one of ã, ä¸, äº, ä¸, å, äº, å­, ä¸, å«, or ä¹ (0 to 9)    */
DECL|method|isKanjiNumeral
specifier|private
name|boolean
name|isKanjiNumeral
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|numerals
index|[
name|c
index|]
operator|!=
name|NO_NUMERAL
return|;
block|}
comment|/**    * Returns the value for the provided kanji numeral. Only numeric values for the characters where    * {link isKanjiNumeral} return true are supported - behavior is undefined for other characters.    *    * @param c kanji numeral character    * @return numeral value    * @see #isKanjiNumeral(char)    */
DECL|method|kanjiNumeralValue
specifier|private
name|int
name|kanjiNumeralValue
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|numerals
index|[
name|c
index|]
return|;
block|}
comment|/**    * Decimal point predicate    *    * @param c character to test    * @return true if and only if c is a decimal point    */
DECL|method|isDecimalPoint
specifier|private
name|boolean
name|isDecimalPoint
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|'.'
comment|// U+002E FULL STOP
operator|||
name|c
operator|==
literal|'ï¼'
return|;
comment|// U+FF0E FULLWIDTH FULL STOP
block|}
comment|/**    * Thousand separator predicate    *    * @param c character to test    * @return true if and only if c is a thousand separator predicate    */
DECL|method|isThousandSeparator
specifier|private
name|boolean
name|isThousandSeparator
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|','
comment|// U+002C COMMA
operator|||
name|c
operator|==
literal|'ï¼'
return|;
comment|// U+FF0C FULLWIDTH COMMA
block|}
comment|/**    * Buffer that holds a Japanese number string and a position index used as a parsed-to marker    */
DECL|class|NumberBuffer
specifier|public
specifier|static
class|class
name|NumberBuffer
block|{
DECL|field|position
specifier|private
name|int
name|position
decl_stmt|;
DECL|field|string
specifier|private
name|String
name|string
decl_stmt|;
DECL|method|NumberBuffer
specifier|public
name|NumberBuffer
parameter_list|(
name|String
name|string
parameter_list|)
block|{
name|this
operator|.
name|string
operator|=
name|string
expr_stmt|;
name|this
operator|.
name|position
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|charAt
specifier|public
name|char
name|charAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|string
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
return|;
block|}
DECL|method|length
specifier|public
name|int
name|length
parameter_list|()
block|{
return|return
name|string
operator|.
name|length
argument_list|()
return|;
block|}
DECL|method|advance
specifier|public
name|void
name|advance
parameter_list|()
block|{
name|position
operator|++
expr_stmt|;
block|}
DECL|method|position
specifier|public
name|int
name|position
parameter_list|()
block|{
return|return
name|position
return|;
block|}
block|}
block|}
end_class
end_unit
