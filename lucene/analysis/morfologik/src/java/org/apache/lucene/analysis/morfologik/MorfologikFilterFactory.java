begin_unit
begin_package
DECL|package|org.apache.lucene.analysis.morfologik
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|morfologik
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import
begin_import
import|import
name|morfologik
operator|.
name|stemming
operator|.
name|Dictionary
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|ResourceLoader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|ResourceLoaderAware
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|TokenFilterFactory
import|;
end_import
begin_comment
comment|/**  * Filter factory for {@link MorfologikFilter}. For backward compatibility polish  * dictionary is used as default. You can change dictionary resource   * by dictionary-resource parameter:  *<pre class="prettyprint">  *&lt;fieldType name="text_polish" class="solr.TextField" positionIncrementGap="100"&gt;  *&lt;analyzer&gt;  *&lt;tokenizer class="solr.WhitespaceTokenizerFactory"/&gt;  *&lt;filter class="solr.MorfologikFilterFactory" dictionary-resource="pl" /&gt;  *&lt;/analyzer&gt;  *&lt;/fieldType&gt;</pre>  *   *<p>Alternatively, you can pass in the filenames of FSA ({@code ".dict"} and features "{@code ".info"}" file  * (if the features file is not given, its name is derived from the FSA file):  *<pre class="prettyprint">  *&lt;fieldType name="text_polish" class="solr.TextField" positionIncrementGap="100"&gt;  *&lt;analyzer&gt;  *&lt;tokenizer class="solr.WhitespaceTokenizerFactory"/&gt;  *&lt;filter class="solr.MorfologikFilterFactory" dictionary-fsa-file="mylang.dict" dictionary-features-file="mylang.info" /&gt;  *&lt;/analyzer&gt;  *&lt;/fieldType&gt;</pre>  *   * @see<a href="http://morfologik.blogspot.com/">Morfologik web site</a>  */
end_comment
begin_class
DECL|class|MorfologikFilterFactory
specifier|public
class|class
name|MorfologikFilterFactory
extends|extends
name|TokenFilterFactory
implements|implements
name|ResourceLoaderAware
block|{
comment|/**    * The default dictionary resource (for Polish).     */
DECL|field|DEFAULT_DICTIONARY_RESOURCE
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_DICTIONARY_RESOURCE
init|=
literal|"pl"
decl_stmt|;
comment|/** Dictionary resource */
DECL|field|DICTIONARY_RESOURCE_ATTRIBUTE
specifier|public
specifier|static
specifier|final
name|String
name|DICTIONARY_RESOURCE_ATTRIBUTE
init|=
literal|"dictionary-resource"
decl_stmt|;
comment|/** Dictionary FSA file (should have {@code ".dict"} suffix), loaded from {@link ResourceLoader}. */
DECL|field|DICTIONARY_FSA_FILE_ATTRIBUTE
specifier|public
specifier|static
specifier|final
name|String
name|DICTIONARY_FSA_FILE_ATTRIBUTE
init|=
literal|"dictionary-fsa-file"
decl_stmt|;
comment|/** Dictionary features/properties file, loaded from {@link ResourceLoader}. If not given, this    * loads the file with same name like {@link #DICTIONARY_FSA_FILE_ATTRIBUTE}, but with    * {@code ".info"} suffix.    */
DECL|field|DICTIONARY_FEATURES_FILE_ATTRIBUTE
specifier|public
specifier|static
specifier|final
name|String
name|DICTIONARY_FEATURES_FILE_ATTRIBUTE
init|=
literal|"dictionary-features-file"
decl_stmt|;
DECL|field|dictionaryFsaFile
DECL|field|dictionaryFeaturesFile
DECL|field|dictionaryResource
specifier|private
specifier|final
name|String
name|dictionaryFsaFile
decl_stmt|,
name|dictionaryFeaturesFile
decl_stmt|,
name|dictionaryResource
decl_stmt|;
DECL|field|dictionary
specifier|private
name|Dictionary
name|dictionary
decl_stmt|;
comment|// initialized on inform()
comment|/** Creates a new MorfologikFilterFactory */
DECL|method|MorfologikFilterFactory
specifier|public
name|MorfologikFilterFactory
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|args
parameter_list|)
block|{
name|super
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|// first check FSA and features (at least FSA must be given, features name is guessed):
name|dictionaryFsaFile
operator|=
name|get
argument_list|(
name|args
argument_list|,
name|DICTIONARY_FSA_FILE_ATTRIBUTE
argument_list|)
expr_stmt|;
name|dictionaryFeaturesFile
operator|=
name|get
argument_list|(
name|args
argument_list|,
name|DICTIONARY_FEATURES_FILE_ATTRIBUTE
argument_list|,
operator|(
name|dictionaryFsaFile
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|Dictionary
operator|.
name|getExpectedFeaturesName
argument_list|(
name|dictionaryFsaFile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dictionaryFsaFile
operator|==
literal|null
operator|&&
name|dictionaryFeaturesFile
operator|==
literal|null
condition|)
block|{
comment|// if we have no FSA/features combination, we resolve the classpath resource:
name|dictionaryResource
operator|=
name|get
argument_list|(
name|args
argument_list|,
name|DICTIONARY_RESOURCE_ATTRIBUTE
argument_list|,
name|DEFAULT_DICTIONARY_RESOURCE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dictionaryFsaFile
operator|==
literal|null
operator|||
name|dictionaryFeaturesFile
operator|==
literal|null
condition|)
block|{
comment|// if we have incomplete FSA/features tuple in args
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|,
literal|"Missing '%s' or '%s' attribute."
argument_list|,
name|DICTIONARY_FSA_FILE_ATTRIBUTE
argument_list|,
name|DICTIONARY_FEATURES_FILE_ATTRIBUTE
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
name|dictionaryResource
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|get
argument_list|(
name|args
argument_list|,
name|DICTIONARY_RESOURCE_ATTRIBUTE
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// fail if both is given: FSA/features files + classpath resource
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|,
literal|"Cannot give '%s' and '%s'/'%s' at the same time."
argument_list|,
name|DICTIONARY_RESOURCE_ATTRIBUTE
argument_list|,
name|DICTIONARY_FSA_FILE_ATTRIBUTE
argument_list|,
name|DICTIONARY_FEATURES_FILE_ATTRIBUTE
argument_list|)
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|args
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown parameters: "
operator|+
name|args
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|inform
specifier|public
name|void
name|inform
parameter_list|(
name|ResourceLoader
name|loader
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|dictionaryFsaFile
operator|!=
literal|null
condition|)
block|{
assert|assert
name|dictionaryFeaturesFile
operator|!=
literal|null
assert|;
assert|assert
name|dictionaryResource
operator|==
literal|null
assert|;
try|try
init|(
specifier|final
name|InputStream
name|dictIn
init|=
name|loader
operator|.
name|openResource
argument_list|(
name|dictionaryFsaFile
argument_list|)
init|;           final InputStream metaIn = loader.openResource(dictionaryFeaturesFile)
block|)
block|{
name|this
operator|.
name|dictionary
operator|=
name|Dictionary
operator|.
name|readAndClose
argument_list|(
name|dictIn
argument_list|,
name|metaIn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|dictionaryResource
operator|!=
literal|null
assert|;
name|this
operator|.
name|dictionary
operator|=
name|MorfologikFilter
operator|.
name|loadDictionaryResource
argument_list|(
name|dictionaryResource
argument_list|)
expr_stmt|;
block|}
block|}
end_class
begin_function
annotation|@
name|Override
DECL|method|create
specifier|public
name|TokenStream
name|create
parameter_list|(
name|TokenStream
name|ts
parameter_list|)
block|{
return|return
operator|new
name|MorfologikFilter
argument_list|(
name|ts
argument_list|,
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|dictionary
argument_list|,
literal|"MorfologikFilterFactory was not fully initialized."
argument_list|)
argument_list|)
return|;
block|}
end_function
unit|}
end_unit
