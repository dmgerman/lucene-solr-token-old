begin_unit
begin_package
DECL|package|org.apache.lucene.analysis.hunspell
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|hunspell
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefHash
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CharsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|OfflineSorter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|OfflineSorter
operator|.
name|ByteSequencesReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|OfflineSorter
operator|.
name|ByteSequencesWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|CharacterRunAutomaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|RegExp
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Builder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|CharSequenceOutputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FST
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|IntSequenceOutputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Outputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Util
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|LineNumberReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharsetDecoder
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CodingErrorAction
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import
begin_comment
comment|/**  * In-memory structure for the dictionary (.dic) and affix (.aff)  * data of a hunspell dictionary.  */
end_comment
begin_class
DECL|class|Dictionary
specifier|public
class|class
name|Dictionary
block|{
DECL|field|NOFLAGS
specifier|static
specifier|final
name|char
index|[]
name|NOFLAGS
init|=
operator|new
name|char
index|[
literal|0
index|]
decl_stmt|;
DECL|field|ALIAS_KEY
specifier|private
specifier|static
specifier|final
name|String
name|ALIAS_KEY
init|=
literal|"AF"
decl_stmt|;
DECL|field|MORPH_ALIAS_KEY
specifier|private
specifier|static
specifier|final
name|String
name|MORPH_ALIAS_KEY
init|=
literal|"AM"
decl_stmt|;
DECL|field|PREFIX_KEY
specifier|private
specifier|static
specifier|final
name|String
name|PREFIX_KEY
init|=
literal|"PFX"
decl_stmt|;
DECL|field|SUFFIX_KEY
specifier|private
specifier|static
specifier|final
name|String
name|SUFFIX_KEY
init|=
literal|"SFX"
decl_stmt|;
DECL|field|FLAG_KEY
specifier|private
specifier|static
specifier|final
name|String
name|FLAG_KEY
init|=
literal|"FLAG"
decl_stmt|;
DECL|field|COMPLEXPREFIXES_KEY
specifier|private
specifier|static
specifier|final
name|String
name|COMPLEXPREFIXES_KEY
init|=
literal|"COMPLEXPREFIXES"
decl_stmt|;
DECL|field|CIRCUMFIX_KEY
specifier|private
specifier|static
specifier|final
name|String
name|CIRCUMFIX_KEY
init|=
literal|"CIRCUMFIX"
decl_stmt|;
DECL|field|IGNORE_KEY
specifier|private
specifier|static
specifier|final
name|String
name|IGNORE_KEY
init|=
literal|"IGNORE"
decl_stmt|;
DECL|field|ICONV_KEY
specifier|private
specifier|static
specifier|final
name|String
name|ICONV_KEY
init|=
literal|"ICONV"
decl_stmt|;
DECL|field|OCONV_KEY
specifier|private
specifier|static
specifier|final
name|String
name|OCONV_KEY
init|=
literal|"OCONV"
decl_stmt|;
DECL|field|FULLSTRIP_KEY
specifier|private
specifier|static
specifier|final
name|String
name|FULLSTRIP_KEY
init|=
literal|"FULLSTRIP"
decl_stmt|;
DECL|field|LANG_KEY
specifier|private
specifier|static
specifier|final
name|String
name|LANG_KEY
init|=
literal|"LANG"
decl_stmt|;
DECL|field|KEEPCASE_KEY
specifier|private
specifier|static
specifier|final
name|String
name|KEEPCASE_KEY
init|=
literal|"KEEPCASE"
decl_stmt|;
DECL|field|NEEDAFFIX_KEY
specifier|private
specifier|static
specifier|final
name|String
name|NEEDAFFIX_KEY
init|=
literal|"NEEDAFFIX"
decl_stmt|;
DECL|field|PSEUDOROOT_KEY
specifier|private
specifier|static
specifier|final
name|String
name|PSEUDOROOT_KEY
init|=
literal|"PSEUDOROOT"
decl_stmt|;
DECL|field|ONLYINCOMPOUND_KEY
specifier|private
specifier|static
specifier|final
name|String
name|ONLYINCOMPOUND_KEY
init|=
literal|"ONLYINCOMPOUND"
decl_stmt|;
DECL|field|NUM_FLAG_TYPE
specifier|private
specifier|static
specifier|final
name|String
name|NUM_FLAG_TYPE
init|=
literal|"num"
decl_stmt|;
DECL|field|UTF8_FLAG_TYPE
specifier|private
specifier|static
specifier|final
name|String
name|UTF8_FLAG_TYPE
init|=
literal|"UTF-8"
decl_stmt|;
DECL|field|LONG_FLAG_TYPE
specifier|private
specifier|static
specifier|final
name|String
name|LONG_FLAG_TYPE
init|=
literal|"long"
decl_stmt|;
comment|// TODO: really for suffixes we should reverse the automaton and run them backwards
DECL|field|PREFIX_CONDITION_REGEX_PATTERN
specifier|private
specifier|static
specifier|final
name|String
name|PREFIX_CONDITION_REGEX_PATTERN
init|=
literal|"%s.*"
decl_stmt|;
DECL|field|SUFFIX_CONDITION_REGEX_PATTERN
specifier|private
specifier|static
specifier|final
name|String
name|SUFFIX_CONDITION_REGEX_PATTERN
init|=
literal|".*%s"
decl_stmt|;
DECL|field|prefixes
name|FST
argument_list|<
name|IntsRef
argument_list|>
name|prefixes
decl_stmt|;
DECL|field|suffixes
name|FST
argument_list|<
name|IntsRef
argument_list|>
name|suffixes
decl_stmt|;
comment|// all condition checks used by prefixes and suffixes. these are typically re-used across
comment|// many affix stripping rules. so these are deduplicated, to save RAM.
DECL|field|patterns
name|ArrayList
argument_list|<
name|CharacterRunAutomaton
argument_list|>
name|patterns
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// the entries in the .dic file, mapping to their set of flags.
comment|// the fst output is the ordinal list for flagLookup
DECL|field|words
name|FST
argument_list|<
name|IntsRef
argument_list|>
name|words
decl_stmt|;
comment|// the list of unique flagsets (wordforms). theoretically huge, but practically
comment|// small (e.g. for polish this is 756), otherwise humans wouldn't be able to deal with it either.
DECL|field|flagLookup
name|BytesRefHash
name|flagLookup
init|=
operator|new
name|BytesRefHash
argument_list|()
decl_stmt|;
comment|// the list of unique strip affixes.
DECL|field|stripData
name|char
index|[]
name|stripData
decl_stmt|;
DECL|field|stripOffsets
name|int
index|[]
name|stripOffsets
decl_stmt|;
comment|// 8 bytes per affix
DECL|field|affixData
name|byte
index|[]
name|affixData
init|=
operator|new
name|byte
index|[
literal|64
index|]
decl_stmt|;
DECL|field|currentAffix
specifier|private
name|int
name|currentAffix
init|=
literal|0
decl_stmt|;
DECL|field|flagParsingStrategy
specifier|private
name|FlagParsingStrategy
name|flagParsingStrategy
init|=
operator|new
name|SimpleFlagParsingStrategy
argument_list|()
decl_stmt|;
comment|// Default flag parsing strategy
comment|// AF entries
DECL|field|aliases
specifier|private
name|String
index|[]
name|aliases
decl_stmt|;
DECL|field|aliasCount
specifier|private
name|int
name|aliasCount
init|=
literal|0
decl_stmt|;
comment|// AM entries
DECL|field|morphAliases
specifier|private
name|String
index|[]
name|morphAliases
decl_stmt|;
DECL|field|morphAliasCount
specifier|private
name|int
name|morphAliasCount
init|=
literal|0
decl_stmt|;
comment|// st: morphological entries (either directly, or aliased from AM)
DECL|field|stemExceptions
specifier|private
name|String
index|[]
name|stemExceptions
init|=
operator|new
name|String
index|[
literal|8
index|]
decl_stmt|;
DECL|field|stemExceptionCount
specifier|private
name|int
name|stemExceptionCount
init|=
literal|0
decl_stmt|;
comment|// we set this during sorting, so we know to add an extra FST output.
comment|// when set, some words have exceptional stems, and the last entry is a pointer to stemExceptions
DECL|field|hasStemExceptions
name|boolean
name|hasStemExceptions
decl_stmt|;
DECL|field|tempDir
specifier|private
specifier|final
name|Path
name|tempDir
init|=
name|OfflineSorter
operator|.
name|defaultTempDir
argument_list|()
decl_stmt|;
comment|// TODO: make this configurable?
DECL|field|ignoreCase
name|boolean
name|ignoreCase
decl_stmt|;
DECL|field|complexPrefixes
name|boolean
name|complexPrefixes
decl_stmt|;
DECL|field|twoStageAffix
name|boolean
name|twoStageAffix
decl_stmt|;
comment|// if no affixes have continuation classes, no need to do 2-level affix stripping
DECL|field|circumfix
name|int
name|circumfix
init|=
operator|-
literal|1
decl_stmt|;
comment|// circumfix flag, or -1 if one is not defined
DECL|field|keepcase
name|int
name|keepcase
init|=
operator|-
literal|1
decl_stmt|;
comment|// keepcase flag, or -1 if one is not defined
DECL|field|needaffix
name|int
name|needaffix
init|=
operator|-
literal|1
decl_stmt|;
comment|// needaffix flag, or -1 if one is not defined
DECL|field|onlyincompound
name|int
name|onlyincompound
init|=
operator|-
literal|1
decl_stmt|;
comment|// onlyincompound flag, or -1 if one is not defined
comment|// ignored characters (dictionary, affix, inputs)
DECL|field|ignore
specifier|private
name|char
index|[]
name|ignore
decl_stmt|;
comment|// FSTs used for ICONV/OCONV, output ord pointing to replacement text
DECL|field|iconv
name|FST
argument_list|<
name|CharsRef
argument_list|>
name|iconv
decl_stmt|;
DECL|field|oconv
name|FST
argument_list|<
name|CharsRef
argument_list|>
name|oconv
decl_stmt|;
DECL|field|needsInputCleaning
name|boolean
name|needsInputCleaning
decl_stmt|;
DECL|field|needsOutputCleaning
name|boolean
name|needsOutputCleaning
decl_stmt|;
comment|// true if we can strip suffixes "down to nothing"
DECL|field|fullStrip
name|boolean
name|fullStrip
decl_stmt|;
comment|// language declaration of the dictionary
DECL|field|language
name|String
name|language
decl_stmt|;
comment|// true if case algorithms should use alternate (Turkish/Azeri) mapping
DECL|field|alternateCasing
name|boolean
name|alternateCasing
decl_stmt|;
comment|/**    * Creates a new Dictionary containing the information read from the provided InputStreams to hunspell affix    * and dictionary files.    * You have to close the provided InputStreams yourself.    *    * @param affix InputStream for reading the hunspell affix file (won't be closed).    * @param dictionary InputStream for reading the hunspell dictionary file (won't be closed).    * @throws IOException Can be thrown while reading from the InputStreams    * @throws ParseException Can be thrown if the content of the files does not meet expected formats    */
DECL|method|Dictionary
specifier|public
name|Dictionary
parameter_list|(
name|InputStream
name|affix
parameter_list|,
name|InputStream
name|dictionary
parameter_list|)
throws|throws
name|IOException
throws|,
name|ParseException
block|{
name|this
argument_list|(
name|affix
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|dictionary
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a new Dictionary containing the information read from the provided InputStreams to hunspell affix    * and dictionary files.    * You have to close the provided InputStreams yourself.    *    * @param affix InputStream for reading the hunspell affix file (won't be closed).    * @param dictionaries InputStream for reading the hunspell dictionary files (won't be closed).    * @throws IOException Can be thrown while reading from the InputStreams    * @throws ParseException Can be thrown if the content of the files does not meet expected formats    */
DECL|method|Dictionary
specifier|public
name|Dictionary
parameter_list|(
name|InputStream
name|affix
parameter_list|,
name|List
argument_list|<
name|InputStream
argument_list|>
name|dictionaries
parameter_list|,
name|boolean
name|ignoreCase
parameter_list|)
throws|throws
name|IOException
throws|,
name|ParseException
block|{
name|this
operator|.
name|ignoreCase
operator|=
name|ignoreCase
expr_stmt|;
name|this
operator|.
name|needsInputCleaning
operator|=
name|ignoreCase
expr_stmt|;
name|this
operator|.
name|needsOutputCleaning
operator|=
literal|false
expr_stmt|;
comment|// set if we have an OCONV
name|flagLookup
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|()
argument_list|)
expr_stmt|;
comment|// no flags -> ord 0
name|Path
name|aff
init|=
name|Files
operator|.
name|createTempFile
argument_list|(
name|tempDir
argument_list|,
literal|"affix"
argument_list|,
literal|"aff"
argument_list|)
decl_stmt|;
name|OutputStream
name|out
init|=
operator|new
name|BufferedOutputStream
argument_list|(
name|Files
operator|.
name|newOutputStream
argument_list|(
name|aff
argument_list|)
argument_list|)
decl_stmt|;
name|InputStream
name|aff1
init|=
literal|null
decl_stmt|;
name|InputStream
name|aff2
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// copy contents of affix stream to temp file
specifier|final
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|1024
operator|*
literal|8
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|affix
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// pass 1: get encoding
name|aff1
operator|=
operator|new
name|BufferedInputStream
argument_list|(
name|Files
operator|.
name|newInputStream
argument_list|(
name|aff
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|encoding
init|=
name|getDictionaryEncoding
argument_list|(
name|aff1
argument_list|)
decl_stmt|;
comment|// pass 2: parse affixes
name|CharsetDecoder
name|decoder
init|=
name|getJavaEncoding
argument_list|(
name|encoding
argument_list|)
decl_stmt|;
name|aff2
operator|=
operator|new
name|BufferedInputStream
argument_list|(
name|Files
operator|.
name|newInputStream
argument_list|(
name|aff
argument_list|)
argument_list|)
expr_stmt|;
name|readAffixFile
argument_list|(
name|aff2
argument_list|,
name|decoder
argument_list|)
expr_stmt|;
comment|// read dictionary entries
name|IntSequenceOutputs
name|o
init|=
name|IntSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
name|Builder
argument_list|<
name|IntsRef
argument_list|>
name|b
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE4
argument_list|,
name|o
argument_list|)
decl_stmt|;
name|readDictionaryFiles
argument_list|(
name|dictionaries
argument_list|,
name|decoder
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|words
operator|=
name|b
operator|.
name|finish
argument_list|()
expr_stmt|;
name|aliases
operator|=
literal|null
expr_stmt|;
comment|// no longer needed
name|morphAliases
operator|=
literal|null
expr_stmt|;
comment|// no longer needed
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|out
argument_list|,
name|aff1
argument_list|,
name|aff2
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|Files
operator|.
name|delete
argument_list|(
name|aff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|deleteFilesIgnoringExceptions
argument_list|(
name|aff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Looks up Hunspell word forms from the dictionary    */
DECL|method|lookupWord
name|IntsRef
name|lookupWord
parameter_list|(
name|char
name|word
index|[]
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|lookup
argument_list|(
name|words
argument_list|,
name|word
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|// only for testing
DECL|method|lookupPrefix
name|IntsRef
name|lookupPrefix
parameter_list|(
name|char
name|word
index|[]
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|lookup
argument_list|(
name|prefixes
argument_list|,
name|word
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|// only for testing
DECL|method|lookupSuffix
name|IntsRef
name|lookupSuffix
parameter_list|(
name|char
name|word
index|[]
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|lookup
argument_list|(
name|suffixes
argument_list|,
name|word
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
DECL|method|lookup
name|IntsRef
name|lookup
parameter_list|(
name|FST
argument_list|<
name|IntsRef
argument_list|>
name|fst
parameter_list|,
name|char
name|word
index|[]
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|fst
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|FST
operator|.
name|BytesReader
name|bytesReader
init|=
name|fst
operator|.
name|getBytesReader
argument_list|()
decl_stmt|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|IntsRef
argument_list|>
name|arc
init|=
name|fst
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|IntsRef
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|// Accumulate output as we go
specifier|final
name|IntsRef
name|NO_OUTPUT
init|=
name|fst
operator|.
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
name|IntsRef
name|output
init|=
name|NO_OUTPUT
decl_stmt|;
name|int
name|l
init|=
name|offset
operator|+
name|length
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
name|offset
init|,
name|cp
init|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|cp
argument_list|)
control|)
block|{
name|cp
operator|=
name|Character
operator|.
name|codePointAt
argument_list|(
name|word
argument_list|,
name|i
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst
operator|.
name|findTargetArc
argument_list|(
name|cp
argument_list|,
name|arc
argument_list|,
name|arc
argument_list|,
name|bytesReader
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|fst
operator|.
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fst
operator|.
name|findTargetArc
argument_list|(
name|FST
operator|.
name|END_LABEL
argument_list|,
name|arc
argument_list|,
name|arc
argument_list|,
name|bytesReader
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
return|return
name|fst
operator|.
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|output
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|bogus
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|bogus
argument_list|)
throw|;
block|}
block|}
comment|/**    * Reads the affix file through the provided InputStream, building up the prefix and suffix maps    *    * @param affixStream InputStream to read the content of the affix file from    * @param decoder CharsetDecoder to decode the content of the file    * @throws IOException Can be thrown while reading from the InputStream    */
DECL|method|readAffixFile
specifier|private
name|void
name|readAffixFile
parameter_list|(
name|InputStream
name|affixStream
parameter_list|,
name|CharsetDecoder
name|decoder
parameter_list|)
throws|throws
name|IOException
throws|,
name|ParseException
block|{
name|TreeMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|prefixes
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|suffixes
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|seenPatterns
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// zero condition -> 0 ord
name|seenPatterns
operator|.
name|put
argument_list|(
literal|".*"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patterns
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// zero strip -> 0 ord
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|seenStrips
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|seenStrips
operator|.
name|put
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LineNumberReader
name|reader
init|=
operator|new
name|LineNumberReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|affixStream
argument_list|,
name|decoder
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|line
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// ignore any BOM marker on first line
if|if
condition|(
name|reader
operator|.
name|getLineNumber
argument_list|()
operator|==
literal|1
operator|&&
name|line
operator|.
name|startsWith
argument_list|(
literal|"\uFEFF"
argument_list|)
condition|)
block|{
name|line
operator|=
name|line
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|ALIAS_KEY
argument_list|)
condition|)
block|{
name|parseAlias
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|MORPH_ALIAS_KEY
argument_list|)
condition|)
block|{
name|parseMorphAlias
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|PREFIX_KEY
argument_list|)
condition|)
block|{
name|parseAffix
argument_list|(
name|prefixes
argument_list|,
name|line
argument_list|,
name|reader
argument_list|,
name|PREFIX_CONDITION_REGEX_PATTERN
argument_list|,
name|seenPatterns
argument_list|,
name|seenStrips
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|SUFFIX_KEY
argument_list|)
condition|)
block|{
name|parseAffix
argument_list|(
name|suffixes
argument_list|,
name|line
argument_list|,
name|reader
argument_list|,
name|SUFFIX_CONDITION_REGEX_PATTERN
argument_list|,
name|seenPatterns
argument_list|,
name|seenStrips
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|FLAG_KEY
argument_list|)
condition|)
block|{
comment|// Assume that the FLAG line comes before any prefix or suffixes
comment|// Store the strategy so it can be used when parsing the dic file
name|flagParsingStrategy
operator|=
name|getFlagParsingStrategy
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|equals
argument_list|(
name|COMPLEXPREFIXES_KEY
argument_list|)
condition|)
block|{
name|complexPrefixes
operator|=
literal|true
expr_stmt|;
comment|// 2-stage prefix+1-stage suffix instead of 2-stage suffix+1-stage prefix
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|CIRCUMFIX_KEY
argument_list|)
condition|)
block|{
name|String
name|parts
index|[]
init|=
name|line
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Illegal CIRCUMFIX declaration"
argument_list|,
name|reader
operator|.
name|getLineNumber
argument_list|()
argument_list|)
throw|;
block|}
name|circumfix
operator|=
name|flagParsingStrategy
operator|.
name|parseFlag
argument_list|(
name|parts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|KEEPCASE_KEY
argument_list|)
condition|)
block|{
name|String
name|parts
index|[]
init|=
name|line
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Illegal KEEPCASE declaration"
argument_list|,
name|reader
operator|.
name|getLineNumber
argument_list|()
argument_list|)
throw|;
block|}
name|keepcase
operator|=
name|flagParsingStrategy
operator|.
name|parseFlag
argument_list|(
name|parts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|NEEDAFFIX_KEY
argument_list|)
operator|||
name|line
operator|.
name|startsWith
argument_list|(
name|PSEUDOROOT_KEY
argument_list|)
condition|)
block|{
name|String
name|parts
index|[]
init|=
name|line
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Illegal NEEDAFFIX declaration"
argument_list|,
name|reader
operator|.
name|getLineNumber
argument_list|()
argument_list|)
throw|;
block|}
name|needaffix
operator|=
name|flagParsingStrategy
operator|.
name|parseFlag
argument_list|(
name|parts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|ONLYINCOMPOUND_KEY
argument_list|)
condition|)
block|{
name|String
name|parts
index|[]
init|=
name|line
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Illegal ONLYINCOMPOUND declaration"
argument_list|,
name|reader
operator|.
name|getLineNumber
argument_list|()
argument_list|)
throw|;
block|}
name|onlyincompound
operator|=
name|flagParsingStrategy
operator|.
name|parseFlag
argument_list|(
name|parts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|IGNORE_KEY
argument_list|)
condition|)
block|{
name|String
name|parts
index|[]
init|=
name|line
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Illegal IGNORE declaration"
argument_list|,
name|reader
operator|.
name|getLineNumber
argument_list|()
argument_list|)
throw|;
block|}
name|ignore
operator|=
name|parts
index|[
literal|1
index|]
operator|.
name|toCharArray
argument_list|()
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
name|needsInputCleaning
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|ICONV_KEY
argument_list|)
operator|||
name|line
operator|.
name|startsWith
argument_list|(
name|OCONV_KEY
argument_list|)
condition|)
block|{
name|String
name|parts
index|[]
init|=
name|line
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
name|String
name|type
init|=
name|parts
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Illegal "
operator|+
name|type
operator|+
literal|" declaration"
argument_list|,
name|reader
operator|.
name|getLineNumber
argument_list|()
argument_list|)
throw|;
block|}
name|int
name|num
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|parts
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|FST
argument_list|<
name|CharsRef
argument_list|>
name|res
init|=
name|parseConversions
argument_list|(
name|reader
argument_list|,
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"ICONV"
argument_list|)
condition|)
block|{
name|iconv
operator|=
name|res
expr_stmt|;
name|needsInputCleaning
operator||=
name|iconv
operator|!=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|oconv
operator|=
name|res
expr_stmt|;
name|needsOutputCleaning
operator||=
name|oconv
operator|!=
literal|null
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|FULLSTRIP_KEY
argument_list|)
condition|)
block|{
name|fullStrip
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|LANG_KEY
argument_list|)
condition|)
block|{
name|language
operator|=
name|line
operator|.
name|substring
argument_list|(
name|LANG_KEY
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
name|alternateCasing
operator|=
literal|"tr_TR"
operator|.
name|equals
argument_list|(
name|language
argument_list|)
operator|||
literal|"az_AZ"
operator|.
name|equals
argument_list|(
name|language
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|prefixes
operator|=
name|affixFST
argument_list|(
name|prefixes
argument_list|)
expr_stmt|;
name|this
operator|.
name|suffixes
operator|=
name|affixFST
argument_list|(
name|suffixes
argument_list|)
expr_stmt|;
name|int
name|totalChars
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|strip
range|:
name|seenStrips
operator|.
name|keySet
argument_list|()
control|)
block|{
name|totalChars
operator|+=
name|strip
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
name|stripData
operator|=
operator|new
name|char
index|[
name|totalChars
index|]
expr_stmt|;
name|stripOffsets
operator|=
operator|new
name|int
index|[
name|seenStrips
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
expr_stmt|;
name|int
name|currentOffset
init|=
literal|0
decl_stmt|;
name|int
name|currentIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|strip
range|:
name|seenStrips
operator|.
name|keySet
argument_list|()
control|)
block|{
name|stripOffsets
index|[
name|currentIndex
operator|++
index|]
operator|=
name|currentOffset
expr_stmt|;
name|strip
operator|.
name|getChars
argument_list|(
literal|0
argument_list|,
name|strip
operator|.
name|length
argument_list|()
argument_list|,
name|stripData
argument_list|,
name|currentOffset
argument_list|)
expr_stmt|;
name|currentOffset
operator|+=
name|strip
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
assert|assert
name|currentIndex
operator|==
name|seenStrips
operator|.
name|size
argument_list|()
assert|;
name|stripOffsets
index|[
name|currentIndex
index|]
operator|=
name|currentOffset
expr_stmt|;
block|}
DECL|method|affixFST
specifier|private
name|FST
argument_list|<
name|IntsRef
argument_list|>
name|affixFST
parameter_list|(
name|TreeMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|affixes
parameter_list|)
throws|throws
name|IOException
block|{
name|IntSequenceOutputs
name|outputs
init|=
name|IntSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
name|Builder
argument_list|<
name|IntsRef
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE4
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
name|IntsRefBuilder
name|scratch
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|entry
range|:
name|affixes
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Util
operator|.
name|toUTF32
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|entries
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|IntsRef
name|output
init|=
operator|new
name|IntsRef
argument_list|(
name|entries
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Integer
name|c
range|:
name|entries
control|)
block|{
name|output
operator|.
name|ints
index|[
name|output
operator|.
name|length
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|builder
operator|.
name|add
argument_list|(
name|scratch
operator|.
name|get
argument_list|()
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|finish
argument_list|()
return|;
block|}
DECL|method|escapeDash
specifier|static
name|String
name|escapeDash
parameter_list|(
name|String
name|re
parameter_list|)
block|{
comment|// we have to be careful, even though dash doesn't have a special meaning,
comment|// some dictionaries already escape it (e.g. pt_PT), so we don't want to nullify it
name|StringBuilder
name|escaped
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|re
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|re
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|escaped
operator|.
name|append
argument_list|(
literal|"\\-"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|escaped
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|i
operator|+
literal|1
operator|<
name|re
operator|.
name|length
argument_list|()
condition|)
block|{
name|escaped
operator|.
name|append
argument_list|(
name|re
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|escaped
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Parses a specific affix rule putting the result into the provided affix map    *     * @param affixes Map where the result of the parsing will be put    * @param header Header line of the affix rule    * @param reader BufferedReader to read the content of the rule from    * @param conditionPattern {@link String#format(String, Object...)} pattern to be used to generate the condition regex    *                         pattern    * @param seenPatterns map from condition -&gt; index of patterns, for deduplication.    * @throws IOException Can be thrown while reading the rule    */
DECL|method|parseAffix
specifier|private
name|void
name|parseAffix
parameter_list|(
name|TreeMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|affixes
parameter_list|,
name|String
name|header
parameter_list|,
name|LineNumberReader
name|reader
parameter_list|,
name|String
name|conditionPattern
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|seenPatterns
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|seenStrips
parameter_list|)
throws|throws
name|IOException
throws|,
name|ParseException
block|{
name|BytesRefBuilder
name|scratch
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|String
name|args
index|[]
init|=
name|header
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
name|boolean
name|crossProduct
init|=
name|args
index|[
literal|2
index|]
operator|.
name|equals
argument_list|(
literal|"Y"
argument_list|)
decl_stmt|;
name|boolean
name|isSuffix
init|=
name|conditionPattern
operator|==
name|SUFFIX_CONDITION_REGEX_PATTERN
decl_stmt|;
name|int
name|numLines
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|affixData
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|affixData
argument_list|,
operator|(
name|currentAffix
operator|<<
literal|3
operator|)
operator|+
operator|(
name|numLines
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|ByteArrayDataOutput
name|affixWriter
init|=
operator|new
name|ByteArrayDataOutput
argument_list|(
name|affixData
argument_list|,
name|currentAffix
operator|<<
literal|3
argument_list|,
name|numLines
operator|<<
literal|3
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numLines
condition|;
name|i
operator|++
control|)
block|{
assert|assert
name|affixWriter
operator|.
name|getPosition
argument_list|()
operator|==
name|currentAffix
operator|<<
literal|3
assert|;
name|String
name|line
init|=
name|reader
operator|.
name|readLine
argument_list|()
decl_stmt|;
name|String
name|ruleArgs
index|[]
init|=
name|line
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
comment|// from the manpage: PFX flag stripping prefix [condition [morphological_fields...]]
comment|// condition is optional
if|if
condition|(
name|ruleArgs
operator|.
name|length
operator|<
literal|4
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"The affix file contains a rule with less than four elements: "
operator|+
name|line
argument_list|,
name|reader
operator|.
name|getLineNumber
argument_list|()
argument_list|)
throw|;
block|}
name|char
name|flag
init|=
name|flagParsingStrategy
operator|.
name|parseFlag
argument_list|(
name|ruleArgs
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|String
name|strip
init|=
name|ruleArgs
index|[
literal|2
index|]
operator|.
name|equals
argument_list|(
literal|"0"
argument_list|)
condition|?
literal|""
else|:
name|ruleArgs
index|[
literal|2
index|]
decl_stmt|;
name|String
name|affixArg
init|=
name|ruleArgs
index|[
literal|3
index|]
decl_stmt|;
name|char
name|appendFlags
index|[]
init|=
literal|null
decl_stmt|;
comment|// first: parse continuation classes out of affix
name|int
name|flagSep
init|=
name|affixArg
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|flagSep
operator|!=
operator|-
literal|1
condition|)
block|{
name|String
name|flagPart
init|=
name|affixArg
operator|.
name|substring
argument_list|(
name|flagSep
operator|+
literal|1
argument_list|)
decl_stmt|;
name|affixArg
operator|=
name|affixArg
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|flagSep
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasCount
operator|>
literal|0
condition|)
block|{
name|flagPart
operator|=
name|getAliasValue
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|flagPart
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|appendFlags
operator|=
name|flagParsingStrategy
operator|.
name|parseFlags
argument_list|(
name|flagPart
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|appendFlags
argument_list|)
expr_stmt|;
name|twoStageAffix
operator|=
literal|true
expr_stmt|;
block|}
comment|// zero affix -> empty string
if|if
condition|(
literal|"0"
operator|.
name|equals
argument_list|(
name|affixArg
argument_list|)
condition|)
block|{
name|affixArg
operator|=
literal|""
expr_stmt|;
block|}
name|String
name|condition
init|=
name|ruleArgs
operator|.
name|length
operator|>
literal|4
condition|?
name|ruleArgs
index|[
literal|4
index|]
else|:
literal|"."
decl_stmt|;
comment|// at least the gascon affix file has this issue
if|if
condition|(
name|condition
operator|.
name|startsWith
argument_list|(
literal|"["
argument_list|)
operator|&&
name|condition
operator|.
name|indexOf
argument_list|(
literal|']'
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|condition
operator|=
name|condition
operator|+
literal|"]"
expr_stmt|;
block|}
comment|// "dash hasn't got special meaning" (we must escape it)
if|if
condition|(
name|condition
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|condition
operator|=
name|escapeDash
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
specifier|final
name|String
name|regex
decl_stmt|;
if|if
condition|(
literal|"."
operator|.
name|equals
argument_list|(
name|condition
argument_list|)
condition|)
block|{
name|regex
operator|=
literal|".*"
expr_stmt|;
comment|// Zero condition is indicated by dot
block|}
elseif|else
if|if
condition|(
name|condition
operator|.
name|equals
argument_list|(
name|strip
argument_list|)
condition|)
block|{
name|regex
operator|=
literal|".*"
expr_stmt|;
comment|// TODO: optimize this better:
comment|// if we remove 'strip' from condition, we don't have to append 'strip' to check it...!
comment|// but this is complicated...
block|}
else|else
block|{
name|regex
operator|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
name|conditionPattern
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
comment|// deduplicate patterns
name|Integer
name|patternIndex
init|=
name|seenPatterns
operator|.
name|get
argument_list|(
name|regex
argument_list|)
decl_stmt|;
if|if
condition|(
name|patternIndex
operator|==
literal|null
condition|)
block|{
name|patternIndex
operator|=
name|patterns
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|patternIndex
operator|>
name|Short
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Too many patterns, please report this to dev@lucene.apache.org"
argument_list|)
throw|;
block|}
name|seenPatterns
operator|.
name|put
argument_list|(
name|regex
argument_list|,
name|patternIndex
argument_list|)
expr_stmt|;
name|CharacterRunAutomaton
name|pattern
init|=
operator|new
name|CharacterRunAutomaton
argument_list|(
operator|new
name|RegExp
argument_list|(
name|regex
argument_list|,
name|RegExp
operator|.
name|NONE
argument_list|)
operator|.
name|toAutomaton
argument_list|()
argument_list|)
decl_stmt|;
name|patterns
operator|.
name|add
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
name|Integer
name|stripOrd
init|=
name|seenStrips
operator|.
name|get
argument_list|(
name|strip
argument_list|)
decl_stmt|;
if|if
condition|(
name|stripOrd
operator|==
literal|null
condition|)
block|{
name|stripOrd
operator|=
name|seenStrips
operator|.
name|size
argument_list|()
expr_stmt|;
name|seenStrips
operator|.
name|put
argument_list|(
name|strip
argument_list|,
name|stripOrd
argument_list|)
expr_stmt|;
if|if
condition|(
name|stripOrd
operator|>
name|Character
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Too many unique strips, please report this to dev@lucene.apache.org"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|appendFlags
operator|==
literal|null
condition|)
block|{
name|appendFlags
operator|=
name|NOFLAGS
expr_stmt|;
block|}
name|encodeFlags
argument_list|(
name|scratch
argument_list|,
name|appendFlags
argument_list|)
expr_stmt|;
name|int
name|appendFlagsOrd
init|=
name|flagLookup
operator|.
name|add
argument_list|(
name|scratch
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|appendFlagsOrd
operator|<
literal|0
condition|)
block|{
comment|// already exists in our hash
name|appendFlagsOrd
operator|=
operator|(
operator|-
name|appendFlagsOrd
operator|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|appendFlagsOrd
operator|>
name|Short
operator|.
name|MAX_VALUE
condition|)
block|{
comment|// this limit is probably flexible, but it's a good sanity check too
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Too many unique append flags, please report this to dev@lucene.apache.org"
argument_list|)
throw|;
block|}
name|affixWriter
operator|.
name|writeShort
argument_list|(
operator|(
name|short
operator|)
name|flag
argument_list|)
expr_stmt|;
name|affixWriter
operator|.
name|writeShort
argument_list|(
operator|(
name|short
operator|)
name|stripOrd
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// encode crossProduct into patternIndex
name|int
name|patternOrd
init|=
name|patternIndex
operator|.
name|intValue
argument_list|()
operator|<<
literal|1
operator||
operator|(
name|crossProduct
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|affixWriter
operator|.
name|writeShort
argument_list|(
operator|(
name|short
operator|)
name|patternOrd
argument_list|)
expr_stmt|;
name|affixWriter
operator|.
name|writeShort
argument_list|(
operator|(
name|short
operator|)
name|appendFlagsOrd
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsInputCleaning
condition|)
block|{
name|CharSequence
name|cleaned
init|=
name|cleanInput
argument_list|(
name|affixArg
argument_list|,
name|sb
argument_list|)
decl_stmt|;
name|affixArg
operator|=
name|cleaned
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isSuffix
condition|)
block|{
name|affixArg
operator|=
operator|new
name|StringBuilder
argument_list|(
name|affixArg
argument_list|)
operator|.
name|reverse
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|affixes
operator|.
name|get
argument_list|(
name|affixArg
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
name|list
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|affixes
operator|.
name|put
argument_list|(
name|affixArg
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|currentAffix
argument_list|)
expr_stmt|;
name|currentAffix
operator|++
expr_stmt|;
block|}
block|}
DECL|method|parseConversions
specifier|private
name|FST
argument_list|<
name|CharsRef
argument_list|>
name|parseConversions
parameter_list|(
name|LineNumberReader
name|reader
parameter_list|,
name|int
name|num
parameter_list|)
throws|throws
name|IOException
throws|,
name|ParseException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mappings
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|String
name|line
init|=
name|reader
operator|.
name|readLine
argument_list|()
decl_stmt|;
name|String
name|parts
index|[]
init|=
name|line
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
operator|!=
literal|3
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"invalid syntax: "
operator|+
name|line
argument_list|,
name|reader
operator|.
name|getLineNumber
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|mappings
operator|.
name|put
argument_list|(
name|parts
index|[
literal|1
index|]
argument_list|,
name|parts
index|[
literal|2
index|]
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"duplicate mapping specified for: "
operator|+
name|parts
index|[
literal|1
index|]
argument_list|)
throw|;
block|}
block|}
name|Outputs
argument_list|<
name|CharsRef
argument_list|>
name|outputs
init|=
name|CharSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
name|Builder
argument_list|<
name|CharsRef
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE2
argument_list|,
name|outputs
argument_list|)
decl_stmt|;
name|IntsRefBuilder
name|scratchInts
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|mappings
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Util
operator|.
name|toUTF16
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|scratchInts
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|scratchInts
operator|.
name|get
argument_list|()
argument_list|,
operator|new
name|CharsRef
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|finish
argument_list|()
return|;
block|}
comment|/** pattern accepts optional BOM + SET + any whitespace */
DECL|field|ENCODING_PATTERN
specifier|final
specifier|static
name|Pattern
name|ENCODING_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^(\u00EF\u00BB\u00BF)?SET\\s+"
argument_list|)
decl_stmt|;
comment|/**    * Parses the encoding specified in the affix file readable through the provided InputStream    *    * @param affix InputStream for reading the affix file    * @return Encoding specified in the affix file    * @throws IOException Can be thrown while reading from the InputStream    * @throws ParseException Thrown if the first non-empty non-comment line read from the file does not adhere to the format {@code SET<encoding>}    */
DECL|method|getDictionaryEncoding
specifier|static
name|String
name|getDictionaryEncoding
parameter_list|(
name|InputStream
name|affix
parameter_list|)
throws|throws
name|IOException
throws|,
name|ParseException
block|{
specifier|final
name|StringBuilder
name|encoding
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|encoding
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|affix
operator|.
name|read
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ch
operator|!=
literal|'\r'
condition|)
block|{
name|encoding
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|encoding
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|||
name|encoding
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'#'
operator|||
comment|// this test only at the end as ineffective but would allow lines only containing spaces:
name|encoding
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Unexpected end of affix file."
argument_list|,
literal|0
argument_list|)
throw|;
block|}
continue|continue;
block|}
name|Matcher
name|matcher
init|=
name|ENCODING_PATTERN
operator|.
name|matcher
argument_list|(
name|encoding
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|int
name|last
init|=
name|matcher
operator|.
name|end
argument_list|()
decl_stmt|;
return|return
name|encoding
operator|.
name|substring
argument_list|(
name|last
argument_list|)
operator|.
name|trim
argument_list|()
return|;
block|}
block|}
block|}
DECL|field|CHARSET_ALIASES
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|CHARSET_ALIASES
decl_stmt|;
static|static
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|m
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"microsoft-cp1251"
argument_list|,
literal|"windows-1251"
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"TIS620-2533"
argument_list|,
literal|"TIS-620"
argument_list|)
expr_stmt|;
name|CHARSET_ALIASES
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/**    * Retrieves the CharsetDecoder for the given encoding.  Note, This isn't perfect as I think ISCII-DEVANAGARI and    * MICROSOFT-CP1251 etc are allowed...    *    * @param encoding Encoding to retrieve the CharsetDecoder for    * @return CharSetDecoder for the given encoding    */
DECL|method|getJavaEncoding
specifier|private
name|CharsetDecoder
name|getJavaEncoding
parameter_list|(
name|String
name|encoding
parameter_list|)
block|{
if|if
condition|(
literal|"ISO8859-14"
operator|.
name|equals
argument_list|(
name|encoding
argument_list|)
condition|)
block|{
return|return
operator|new
name|ISO8859_14Decoder
argument_list|()
return|;
block|}
name|String
name|canon
init|=
name|CHARSET_ALIASES
operator|.
name|get
argument_list|(
name|encoding
argument_list|)
decl_stmt|;
if|if
condition|(
name|canon
operator|!=
literal|null
condition|)
block|{
name|encoding
operator|=
name|canon
expr_stmt|;
block|}
name|Charset
name|charset
init|=
name|Charset
operator|.
name|forName
argument_list|(
name|encoding
argument_list|)
decl_stmt|;
return|return
name|charset
operator|.
name|newDecoder
argument_list|()
operator|.
name|onMalformedInput
argument_list|(
name|CodingErrorAction
operator|.
name|REPLACE
argument_list|)
return|;
block|}
comment|/**    * Determines the appropriate {@link FlagParsingStrategy} based on the FLAG definition line taken from the affix file    *    * @param flagLine Line containing the flag information    * @return FlagParsingStrategy that handles parsing flags in the way specified in the FLAG definition    */
DECL|method|getFlagParsingStrategy
specifier|static
name|FlagParsingStrategy
name|getFlagParsingStrategy
parameter_list|(
name|String
name|flagLine
parameter_list|)
block|{
name|String
name|parts
index|[]
init|=
name|flagLine
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal FLAG specification: "
operator|+
name|flagLine
argument_list|)
throw|;
block|}
name|String
name|flagType
init|=
name|parts
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|NUM_FLAG_TYPE
operator|.
name|equals
argument_list|(
name|flagType
argument_list|)
condition|)
block|{
return|return
operator|new
name|NumFlagParsingStrategy
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|UTF8_FLAG_TYPE
operator|.
name|equals
argument_list|(
name|flagType
argument_list|)
condition|)
block|{
return|return
operator|new
name|SimpleFlagParsingStrategy
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|LONG_FLAG_TYPE
operator|.
name|equals
argument_list|(
name|flagType
argument_list|)
condition|)
block|{
return|return
operator|new
name|DoubleASCIIFlagParsingStrategy
argument_list|()
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown flag type: "
operator|+
name|flagType
argument_list|)
throw|;
block|}
DECL|field|FLAG_SEPARATOR
specifier|final
name|char
name|FLAG_SEPARATOR
init|=
literal|0x1f
decl_stmt|;
comment|// flag separator after escaping
DECL|field|MORPH_SEPARATOR
specifier|final
name|char
name|MORPH_SEPARATOR
init|=
literal|0x1e
decl_stmt|;
comment|// separator for boundary of entry (may be followed by morph data)
DECL|method|unescapeEntry
name|String
name|unescapeEntry
parameter_list|(
name|String
name|entry
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|end
init|=
name|morphBoundary
argument_list|(
name|entry
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
init|=
name|entry
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\\'
operator|&&
name|i
operator|+
literal|1
operator|<
name|entry
operator|.
name|length
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|entry
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'/'
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|FLAG_SEPARATOR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|MORPH_SEPARATOR
operator|||
name|ch
operator|==
name|FLAG_SEPARATOR
condition|)
block|{
comment|// BINARY EXECUTABLES EMBEDDED IN ZULU DICTIONARIES!!!!!!!
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
name|MORPH_SEPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|<
name|entry
operator|.
name|length
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|end
init|;
name|i
operator|<
name|entry
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|entry
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|FLAG_SEPARATOR
operator|||
name|c
operator|==
name|MORPH_SEPARATOR
condition|)
block|{
comment|// BINARY EXECUTABLES EMBEDDED IN ZULU DICTIONARIES!!!!!!!
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|morphBoundary
specifier|static
name|int
name|morphBoundary
parameter_list|(
name|String
name|line
parameter_list|)
block|{
name|int
name|end
init|=
name|indexOfSpaceOrTab
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|line
operator|.
name|length
argument_list|()
return|;
block|}
while|while
condition|(
name|end
operator|>=
literal|0
operator|&&
name|end
operator|<
name|line
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
name|line
operator|.
name|charAt
argument_list|(
name|end
argument_list|)
operator|==
literal|'\t'
operator|||
name|end
operator|+
literal|3
operator|<
name|line
operator|.
name|length
argument_list|()
operator|&&
name|Character
operator|.
name|isLetter
argument_list|(
name|line
operator|.
name|charAt
argument_list|(
name|end
operator|+
literal|1
argument_list|)
argument_list|)
operator|&&
name|Character
operator|.
name|isLetter
argument_list|(
name|line
operator|.
name|charAt
argument_list|(
name|end
operator|+
literal|2
argument_list|)
argument_list|)
operator|&&
name|line
operator|.
name|charAt
argument_list|(
name|end
operator|+
literal|3
argument_list|)
operator|==
literal|':'
condition|)
block|{
break|break;
block|}
name|end
operator|=
name|indexOfSpaceOrTab
argument_list|(
name|line
argument_list|,
name|end
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|line
operator|.
name|length
argument_list|()
return|;
block|}
return|return
name|end
return|;
block|}
DECL|method|indexOfSpaceOrTab
specifier|static
name|int
name|indexOfSpaceOrTab
parameter_list|(
name|String
name|text
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|pos1
init|=
name|text
operator|.
name|indexOf
argument_list|(
literal|'\t'
argument_list|,
name|start
argument_list|)
decl_stmt|;
name|int
name|pos2
init|=
name|text
operator|.
name|indexOf
argument_list|(
literal|' '
argument_list|,
name|start
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos1
operator|>=
literal|0
operator|&&
name|pos2
operator|>=
literal|0
condition|)
block|{
return|return
name|Math
operator|.
name|min
argument_list|(
name|pos1
argument_list|,
name|pos2
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
name|pos1
argument_list|,
name|pos2
argument_list|)
return|;
block|}
block|}
comment|/**    * Reads the dictionary file through the provided InputStreams, building up the words map    *    * @param dictionaries InputStreams to read the dictionary file through    * @param decoder CharsetDecoder used to decode the contents of the file    * @throws IOException Can be thrown while reading from the file    */
DECL|method|readDictionaryFiles
specifier|private
name|void
name|readDictionaryFiles
parameter_list|(
name|List
argument_list|<
name|InputStream
argument_list|>
name|dictionaries
parameter_list|,
name|CharsetDecoder
name|decoder
parameter_list|,
name|Builder
argument_list|<
name|IntsRef
argument_list|>
name|words
parameter_list|)
throws|throws
name|IOException
block|{
name|BytesRefBuilder
name|flagsScratch
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|IntsRefBuilder
name|scratchInts
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|Path
name|unsorted
init|=
name|Files
operator|.
name|createTempFile
argument_list|(
name|tempDir
argument_list|,
literal|"unsorted"
argument_list|,
literal|"dat"
argument_list|)
decl_stmt|;
try|try
init|(
name|ByteSequencesWriter
name|writer
init|=
operator|new
name|ByteSequencesWriter
argument_list|(
name|unsorted
argument_list|)
init|)
block|{
for|for
control|(
name|InputStream
name|dictionary
range|:
name|dictionaries
control|)
block|{
name|BufferedReader
name|lines
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|dictionary
argument_list|,
name|decoder
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|line
init|=
name|lines
operator|.
name|readLine
argument_list|()
decl_stmt|;
comment|// first line is number of entries (approximately, sometimes)
while|while
condition|(
operator|(
name|line
operator|=
name|lines
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// wild and unpredictable code comment rules
if|if
condition|(
name|line
operator|.
name|isEmpty
argument_list|()
operator|||
name|line
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'/'
operator|||
name|line
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'#'
operator|||
name|line
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'\t'
condition|)
block|{
continue|continue;
block|}
name|line
operator|=
name|unescapeEntry
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|// if we havent seen any stem exceptions, try to parse one
if|if
condition|(
name|hasStemExceptions
operator|==
literal|false
condition|)
block|{
name|int
name|morphStart
init|=
name|line
operator|.
name|indexOf
argument_list|(
name|MORPH_SEPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|morphStart
operator|>=
literal|0
operator|&&
name|morphStart
operator|<
name|line
operator|.
name|length
argument_list|()
condition|)
block|{
name|hasStemExceptions
operator|=
name|parseStemException
argument_list|(
name|line
operator|.
name|substring
argument_list|(
name|morphStart
operator|+
literal|1
argument_list|)
argument_list|)
operator|!=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needsInputCleaning
condition|)
block|{
name|int
name|flagSep
init|=
name|line
operator|.
name|indexOf
argument_list|(
name|FLAG_SEPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|flagSep
operator|==
operator|-
literal|1
condition|)
block|{
name|flagSep
operator|=
name|line
operator|.
name|indexOf
argument_list|(
name|MORPH_SEPARATOR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flagSep
operator|==
operator|-
literal|1
condition|)
block|{
name|CharSequence
name|cleansed
init|=
name|cleanInput
argument_list|(
name|line
argument_list|,
name|sb
argument_list|)
decl_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|cleansed
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|text
init|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|flagSep
argument_list|)
decl_stmt|;
name|CharSequence
name|cleansed
init|=
name|cleanInput
argument_list|(
name|text
argument_list|,
name|sb
argument_list|)
decl_stmt|;
if|if
condition|(
name|cleansed
operator|!=
name|sb
condition|)
block|{
name|sb
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|cleansed
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|line
operator|.
name|substring
argument_list|(
name|flagSep
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|writer
operator|.
name|write
argument_list|(
name|line
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|Path
name|sorted
init|=
name|Files
operator|.
name|createTempFile
argument_list|(
name|tempDir
argument_list|,
literal|"sorted"
argument_list|,
literal|"dat"
argument_list|)
decl_stmt|;
name|OfflineSorter
name|sorter
init|=
operator|new
name|OfflineSorter
argument_list|(
operator|new
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
argument_list|()
block|{
name|BytesRef
name|scratch1
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|BytesRef
name|scratch2
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|BytesRef
name|o1
parameter_list|,
name|BytesRef
name|o2
parameter_list|)
block|{
name|scratch1
operator|.
name|bytes
operator|=
name|o1
operator|.
name|bytes
expr_stmt|;
name|scratch1
operator|.
name|offset
operator|=
name|o1
operator|.
name|offset
expr_stmt|;
name|scratch1
operator|.
name|length
operator|=
name|o1
operator|.
name|length
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|scratch1
operator|.
name|length
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|scratch1
operator|.
name|bytes
index|[
name|scratch1
operator|.
name|offset
operator|+
name|i
index|]
operator|==
name|FLAG_SEPARATOR
operator|||
name|scratch1
operator|.
name|bytes
index|[
name|scratch1
operator|.
name|offset
operator|+
name|i
index|]
operator|==
name|MORPH_SEPARATOR
condition|)
block|{
name|scratch1
operator|.
name|length
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|scratch2
operator|.
name|bytes
operator|=
name|o2
operator|.
name|bytes
expr_stmt|;
name|scratch2
operator|.
name|offset
operator|=
name|o2
operator|.
name|offset
expr_stmt|;
name|scratch2
operator|.
name|length
operator|=
name|o2
operator|.
name|length
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|scratch2
operator|.
name|length
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|scratch2
operator|.
name|bytes
index|[
name|scratch2
operator|.
name|offset
operator|+
name|i
index|]
operator|==
name|FLAG_SEPARATOR
operator|||
name|scratch2
operator|.
name|bytes
index|[
name|scratch2
operator|.
name|offset
operator|+
name|i
index|]
operator|==
name|MORPH_SEPARATOR
condition|)
block|{
name|scratch2
operator|.
name|length
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|int
name|cmp
init|=
name|scratch1
operator|.
name|compareTo
argument_list|(
name|scratch2
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
comment|// tie break on whole row
return|return
name|o1
operator|.
name|compareTo
argument_list|(
name|o2
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|cmp
return|;
block|}
block|}
block|}
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|sorter
operator|.
name|sort
argument_list|(
name|unsorted
argument_list|,
name|sorted
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|Files
operator|.
name|delete
argument_list|(
name|unsorted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|deleteFilesIgnoringExceptions
argument_list|(
name|unsorted
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|success2
init|=
literal|false
decl_stmt|;
name|ByteSequencesReader
name|reader
init|=
operator|new
name|ByteSequencesReader
argument_list|(
name|sorted
argument_list|)
decl_stmt|;
try|try
block|{
name|BytesRefBuilder
name|scratchLine
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
comment|// TODO: the flags themselves can be double-chars (long) or also numeric
comment|// either way the trick is to encode them as char... but they must be parsed differently
name|String
name|currentEntry
init|=
literal|null
decl_stmt|;
name|IntsRefBuilder
name|currentOrds
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
name|String
name|line
decl_stmt|;
while|while
condition|(
name|reader
operator|.
name|read
argument_list|(
name|scratchLine
argument_list|)
condition|)
block|{
name|line
operator|=
name|scratchLine
operator|.
name|get
argument_list|()
operator|.
name|utf8ToString
argument_list|()
expr_stmt|;
name|String
name|entry
decl_stmt|;
name|char
name|wordForm
index|[]
decl_stmt|;
name|int
name|end
decl_stmt|;
name|int
name|flagSep
init|=
name|line
operator|.
name|indexOf
argument_list|(
name|FLAG_SEPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|flagSep
operator|==
operator|-
literal|1
condition|)
block|{
name|wordForm
operator|=
name|NOFLAGS
expr_stmt|;
name|end
operator|=
name|line
operator|.
name|indexOf
argument_list|(
name|MORPH_SEPARATOR
argument_list|)
expr_stmt|;
name|entry
operator|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|end
operator|=
name|line
operator|.
name|indexOf
argument_list|(
name|MORPH_SEPARATOR
argument_list|)
expr_stmt|;
name|String
name|flagPart
init|=
name|line
operator|.
name|substring
argument_list|(
name|flagSep
operator|+
literal|1
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|aliasCount
operator|>
literal|0
condition|)
block|{
name|flagPart
operator|=
name|getAliasValue
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|flagPart
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|wordForm
operator|=
name|flagParsingStrategy
operator|.
name|parseFlags
argument_list|(
name|flagPart
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|wordForm
argument_list|)
expr_stmt|;
name|entry
operator|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|flagSep
argument_list|)
expr_stmt|;
block|}
comment|// we possibly have morphological data
name|int
name|stemExceptionID
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hasStemExceptions
operator|&&
name|end
operator|+
literal|1
operator|<
name|line
operator|.
name|length
argument_list|()
condition|)
block|{
name|String
name|stemException
init|=
name|parseStemException
argument_list|(
name|line
operator|.
name|substring
argument_list|(
name|end
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|stemException
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|stemExceptionCount
operator|==
name|stemExceptions
operator|.
name|length
condition|)
block|{
name|int
name|newSize
init|=
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|stemExceptionCount
operator|+
literal|1
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
decl_stmt|;
name|stemExceptions
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|stemExceptions
argument_list|,
name|newSize
argument_list|)
expr_stmt|;
block|}
name|stemExceptionID
operator|=
name|stemExceptionCount
operator|+
literal|1
expr_stmt|;
comment|// we use '0' to indicate no exception for the form
name|stemExceptions
index|[
name|stemExceptionCount
operator|++
index|]
operator|=
name|stemException
expr_stmt|;
block|}
block|}
name|int
name|cmp
init|=
name|currentEntry
operator|==
literal|null
condition|?
literal|1
else|:
name|entry
operator|.
name|compareTo
argument_list|(
name|currentEntry
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"out of order: "
operator|+
name|entry
operator|+
literal|"< "
operator|+
name|currentEntry
argument_list|)
throw|;
block|}
else|else
block|{
name|encodeFlags
argument_list|(
name|flagsScratch
argument_list|,
name|wordForm
argument_list|)
expr_stmt|;
name|int
name|ord
init|=
name|flagLookup
operator|.
name|add
argument_list|(
name|flagsScratch
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ord
operator|<
literal|0
condition|)
block|{
comment|// already exists in our hash
name|ord
operator|=
operator|(
operator|-
name|ord
operator|)
operator|-
literal|1
expr_stmt|;
block|}
comment|// finalize current entry, and switch "current" if necessary
if|if
condition|(
name|cmp
operator|>
literal|0
operator|&&
name|currentEntry
operator|!=
literal|null
condition|)
block|{
name|Util
operator|.
name|toUTF32
argument_list|(
name|currentEntry
argument_list|,
name|scratchInts
argument_list|)
expr_stmt|;
name|words
operator|.
name|add
argument_list|(
name|scratchInts
operator|.
name|get
argument_list|()
argument_list|,
name|currentOrds
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// swap current
if|if
condition|(
name|cmp
operator|>
literal|0
operator|||
name|currentEntry
operator|==
literal|null
condition|)
block|{
name|currentEntry
operator|=
name|entry
expr_stmt|;
name|currentOrds
operator|=
operator|new
name|IntsRefBuilder
argument_list|()
expr_stmt|;
comment|// must be this way
block|}
if|if
condition|(
name|hasStemExceptions
condition|)
block|{
name|currentOrds
operator|.
name|append
argument_list|(
name|ord
argument_list|)
expr_stmt|;
name|currentOrds
operator|.
name|append
argument_list|(
name|stemExceptionID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentOrds
operator|.
name|append
argument_list|(
name|ord
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// finalize last entry
name|Util
operator|.
name|toUTF32
argument_list|(
name|currentEntry
argument_list|,
name|scratchInts
argument_list|)
expr_stmt|;
name|words
operator|.
name|add
argument_list|(
name|scratchInts
operator|.
name|get
argument_list|()
argument_list|,
name|currentOrds
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|success2
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|reader
argument_list|)
expr_stmt|;
if|if
condition|(
name|success2
condition|)
block|{
name|Files
operator|.
name|delete
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|deleteFilesIgnoringExceptions
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|decodeFlags
specifier|static
name|char
index|[]
name|decodeFlags
parameter_list|(
name|BytesRef
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|CharsRef
operator|.
name|EMPTY_CHARS
return|;
block|}
name|int
name|len
init|=
name|b
operator|.
name|length
operator|>>>
literal|1
decl_stmt|;
name|char
name|flags
index|[]
init|=
operator|new
name|char
index|[
name|len
index|]
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
name|b
operator|.
name|offset
operator|+
name|b
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|b
operator|.
name|offset
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|flags
index|[
name|upto
operator|++
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|b
operator|.
name|bytes
index|[
name|i
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|b
operator|.
name|bytes
index|[
name|i
operator|+
literal|1
index|]
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|flags
return|;
block|}
DECL|method|encodeFlags
specifier|static
name|void
name|encodeFlags
parameter_list|(
name|BytesRefBuilder
name|b
parameter_list|,
name|char
name|flags
index|[]
parameter_list|)
block|{
name|int
name|len
init|=
name|flags
operator|.
name|length
operator|<<
literal|1
decl_stmt|;
name|b
operator|.
name|grow
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|b
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|flags
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|flag
init|=
name|flags
index|[
name|i
index|]
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|flag
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|flag
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|parseAlias
specifier|private
name|void
name|parseAlias
parameter_list|(
name|String
name|line
parameter_list|)
block|{
name|String
name|ruleArgs
index|[]
init|=
name|line
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
if|if
condition|(
name|aliases
operator|==
literal|null
condition|)
block|{
comment|//first line should be the aliases count
specifier|final
name|int
name|count
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|ruleArgs
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|aliases
operator|=
operator|new
name|String
index|[
name|count
index|]
expr_stmt|;
block|}
else|else
block|{
comment|// an alias can map to no flags
name|String
name|aliasValue
init|=
name|ruleArgs
operator|.
name|length
operator|==
literal|1
condition|?
literal|""
else|:
name|ruleArgs
index|[
literal|1
index|]
decl_stmt|;
name|aliases
index|[
name|aliasCount
operator|++
index|]
operator|=
name|aliasValue
expr_stmt|;
block|}
block|}
DECL|method|getAliasValue
specifier|private
name|String
name|getAliasValue
parameter_list|(
name|int
name|id
parameter_list|)
block|{
try|try
block|{
return|return
name|aliases
index|[
name|id
operator|-
literal|1
index|]
return|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Bad flag alias number:"
operator|+
name|id
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
DECL|method|getStemException
name|String
name|getStemException
parameter_list|(
name|int
name|id
parameter_list|)
block|{
return|return
name|stemExceptions
index|[
name|id
operator|-
literal|1
index|]
return|;
block|}
DECL|method|parseMorphAlias
specifier|private
name|void
name|parseMorphAlias
parameter_list|(
name|String
name|line
parameter_list|)
block|{
if|if
condition|(
name|morphAliases
operator|==
literal|null
condition|)
block|{
comment|//first line should be the aliases count
specifier|final
name|int
name|count
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|line
operator|.
name|substring
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|morphAliases
operator|=
operator|new
name|String
index|[
name|count
index|]
expr_stmt|;
block|}
else|else
block|{
name|String
name|arg
init|=
name|line
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|// leave the space
name|morphAliases
index|[
name|morphAliasCount
operator|++
index|]
operator|=
name|arg
expr_stmt|;
block|}
block|}
DECL|method|parseStemException
specifier|private
name|String
name|parseStemException
parameter_list|(
name|String
name|morphData
parameter_list|)
block|{
comment|// first see if it's an alias
if|if
condition|(
name|morphAliasCount
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|int
name|alias
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|morphData
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
name|morphData
operator|=
name|morphAliases
index|[
name|alias
operator|-
literal|1
index|]
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
comment|// fine
block|}
block|}
comment|// try to parse morph entry
name|int
name|index
init|=
name|morphData
operator|.
name|indexOf
argument_list|(
literal|" st:"
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|index
operator|=
name|morphData
operator|.
name|indexOf
argument_list|(
literal|"\tst:"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|int
name|endIndex
init|=
name|indexOfSpaceOrTab
argument_list|(
name|morphData
argument_list|,
name|index
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|endIndex
operator|<
literal|0
condition|)
block|{
name|endIndex
operator|=
name|morphData
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
return|return
name|morphData
operator|.
name|substring
argument_list|(
name|index
operator|+
literal|4
argument_list|,
name|endIndex
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Abstraction of the process of parsing flags taken from the affix and dic files    */
DECL|class|FlagParsingStrategy
specifier|static
specifier|abstract
class|class
name|FlagParsingStrategy
block|{
comment|/**      * Parses the given String into a single flag      *      * @param rawFlag String to parse into a flag      * @return Parsed flag      */
DECL|method|parseFlag
name|char
name|parseFlag
parameter_list|(
name|String
name|rawFlag
parameter_list|)
block|{
name|char
name|flags
index|[]
init|=
name|parseFlags
argument_list|(
name|rawFlag
argument_list|)
decl_stmt|;
if|if
condition|(
name|flags
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"expected only one flag, got: "
operator|+
name|rawFlag
argument_list|)
throw|;
block|}
return|return
name|flags
index|[
literal|0
index|]
return|;
block|}
comment|/**      * Parses the given String into multiple flags      *      * @param rawFlags String to parse into flags      * @return Parsed flags      */
DECL|method|parseFlags
specifier|abstract
name|char
index|[]
name|parseFlags
parameter_list|(
name|String
name|rawFlags
parameter_list|)
function_decl|;
block|}
comment|/**    * Simple implementation of {@link FlagParsingStrategy} that treats the chars in each String as a individual flags.    * Can be used with both the ASCII and UTF-8 flag types.    */
DECL|class|SimpleFlagParsingStrategy
specifier|private
specifier|static
class|class
name|SimpleFlagParsingStrategy
extends|extends
name|FlagParsingStrategy
block|{
annotation|@
name|Override
DECL|method|parseFlags
specifier|public
name|char
index|[]
name|parseFlags
parameter_list|(
name|String
name|rawFlags
parameter_list|)
block|{
return|return
name|rawFlags
operator|.
name|toCharArray
argument_list|()
return|;
block|}
block|}
comment|/**    * Implementation of {@link FlagParsingStrategy} that assumes each flag is encoded in its numerical form.  In the case    * of multiple flags, each number is separated by a comma.    */
DECL|class|NumFlagParsingStrategy
specifier|private
specifier|static
class|class
name|NumFlagParsingStrategy
extends|extends
name|FlagParsingStrategy
block|{
annotation|@
name|Override
DECL|method|parseFlags
specifier|public
name|char
index|[]
name|parseFlags
parameter_list|(
name|String
name|rawFlags
parameter_list|)
block|{
name|String
index|[]
name|rawFlagParts
init|=
name|rawFlags
operator|.
name|trim
argument_list|()
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|char
index|[]
name|flags
init|=
operator|new
name|char
index|[
name|rawFlagParts
operator|.
name|length
index|]
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rawFlagParts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// note, removing the trailing X/leading I for nepali... what is the rule here?!
name|String
name|replacement
init|=
name|rawFlagParts
index|[
name|i
index|]
operator|.
name|replaceAll
argument_list|(
literal|"[^0-9]"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
comment|// note, ignoring empty flags (this happens in danish, for example)
if|if
condition|(
name|replacement
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|flags
index|[
name|upto
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|Integer
operator|.
name|parseInt
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|upto
operator|<
name|flags
operator|.
name|length
condition|)
block|{
name|flags
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|flags
argument_list|,
name|upto
argument_list|)
expr_stmt|;
block|}
return|return
name|flags
return|;
block|}
block|}
comment|/**    * Implementation of {@link FlagParsingStrategy} that assumes each flag is encoded as two ASCII characters whose codes    * must be combined into a single character.    */
DECL|class|DoubleASCIIFlagParsingStrategy
specifier|private
specifier|static
class|class
name|DoubleASCIIFlagParsingStrategy
extends|extends
name|FlagParsingStrategy
block|{
annotation|@
name|Override
DECL|method|parseFlags
specifier|public
name|char
index|[]
name|parseFlags
parameter_list|(
name|String
name|rawFlags
parameter_list|)
block|{
if|if
condition|(
name|rawFlags
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|char
index|[
literal|0
index|]
return|;
block|}
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|rawFlags
operator|.
name|length
argument_list|()
operator|%
literal|2
operator|==
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid flags (should be even number of characters): "
operator|+
name|rawFlags
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rawFlags
operator|.
name|length
argument_list|()
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|char
name|f1
init|=
name|rawFlags
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|char
name|f2
init|=
name|rawFlags
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|f1
operator|>=
literal|256
operator|||
name|f2
operator|>=
literal|256
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid flags (LONG flags must be double ASCII): "
operator|+
name|rawFlags
argument_list|)
throw|;
block|}
name|char
name|combined
init|=
call|(
name|char
call|)
argument_list|(
name|f1
operator|<<
literal|8
operator||
name|f2
argument_list|)
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|combined
argument_list|)
expr_stmt|;
block|}
name|char
name|flags
index|[]
init|=
operator|new
name|char
index|[
name|builder
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
name|builder
operator|.
name|getChars
argument_list|(
literal|0
argument_list|,
name|builder
operator|.
name|length
argument_list|()
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|flags
return|;
block|}
block|}
DECL|method|hasFlag
specifier|static
name|boolean
name|hasFlag
parameter_list|(
name|char
name|flags
index|[]
parameter_list|,
name|char
name|flag
parameter_list|)
block|{
return|return
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|flags
argument_list|,
name|flag
argument_list|)
operator|>=
literal|0
return|;
block|}
DECL|method|cleanInput
name|CharSequence
name|cleanInput
parameter_list|(
name|CharSequence
name|input
parameter_list|,
name|StringBuilder
name|reuse
parameter_list|)
block|{
name|reuse
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|input
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
init|=
name|input
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ignore
operator|!=
literal|null
operator|&&
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|ignore
argument_list|,
name|ch
argument_list|)
operator|>=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|ignoreCase
operator|&&
name|iconv
operator|==
literal|null
condition|)
block|{
comment|// if we have no input conversion mappings, do this on-the-fly
name|ch
operator|=
name|caseFold
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|reuse
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iconv
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|applyMappings
argument_list|(
name|iconv
argument_list|,
name|reuse
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|bogus
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|bogus
argument_list|)
throw|;
block|}
if|if
condition|(
name|ignoreCase
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|reuse
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|reuse
operator|.
name|setCharAt
argument_list|(
name|i
argument_list|,
name|caseFold
argument_list|(
name|reuse
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|reuse
return|;
block|}
comment|/** folds single character (according to LANG if present) */
DECL|method|caseFold
name|char
name|caseFold
parameter_list|(
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|alternateCasing
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'I'
condition|)
block|{
return|return
literal|'Ä±'
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'Ä°'
condition|)
block|{
return|return
literal|'i'
return|;
block|}
else|else
block|{
return|return
name|Character
operator|.
name|toLowerCase
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|Character
operator|.
name|toLowerCase
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
comment|// TODO: this could be more efficient!
DECL|method|applyMappings
specifier|static
name|void
name|applyMappings
parameter_list|(
name|FST
argument_list|<
name|CharsRef
argument_list|>
name|fst
parameter_list|,
name|StringBuilder
name|sb
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FST
operator|.
name|BytesReader
name|bytesReader
init|=
name|fst
operator|.
name|getBytesReader
argument_list|()
decl_stmt|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|CharsRef
argument_list|>
name|firstArc
init|=
name|fst
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|CharsRef
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|CharsRef
name|NO_OUTPUT
init|=
name|fst
operator|.
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
comment|// temporary stuff
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|CharsRef
argument_list|>
name|arc
init|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|longestMatch
decl_stmt|;
name|CharsRef
name|longestOutput
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sb
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|arc
operator|.
name|copyFrom
argument_list|(
name|firstArc
argument_list|)
expr_stmt|;
name|CharsRef
name|output
init|=
name|NO_OUTPUT
decl_stmt|;
name|longestMatch
operator|=
operator|-
literal|1
expr_stmt|;
name|longestOutput
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<
name|sb
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|char
name|ch
init|=
name|sb
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|fst
operator|.
name|findTargetArc
argument_list|(
name|ch
argument_list|,
name|arc
argument_list|,
name|arc
argument_list|,
name|bytesReader
argument_list|)
operator|==
literal|null
condition|)
block|{
break|break;
block|}
else|else
block|{
name|output
operator|=
name|fst
operator|.
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
name|longestOutput
operator|=
name|fst
operator|.
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
expr_stmt|;
name|longestMatch
operator|=
name|j
expr_stmt|;
block|}
block|}
if|if
condition|(
name|longestMatch
operator|>=
literal|0
condition|)
block|{
name|sb
operator|.
name|delete
argument_list|(
name|i
argument_list|,
name|longestMatch
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sb
operator|.
name|insert
argument_list|(
name|i
argument_list|,
name|longestOutput
argument_list|)
expr_stmt|;
name|i
operator|+=
operator|(
name|longestOutput
operator|.
name|length
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class
end_unit
