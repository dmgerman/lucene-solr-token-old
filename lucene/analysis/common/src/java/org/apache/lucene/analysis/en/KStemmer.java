begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/* This file was partially derived from the original CIIR University of Massachusetts Amherst version of KStemmer.java (license for the original shown below)  */
end_comment
begin_comment
comment|/*  Copyright Â© 2003,  Center for Intelligent Information Retrieval,  University of Massachusetts, Amherst.  All rights reserved.   Redistribution and use in source and binary forms, with or without modification,  are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice, this  list of conditions and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright notice,  this list of conditions and the following disclaimer in the documentation  and/or other materials provided with the distribution.   3. The names "Center for Intelligent Information Retrieval" and  "University of Massachusetts" must not be used to endorse or promote products  derived from this software without prior written permission. To obtain  permission, contact info@ciir.cs.umass.edu.   THIS SOFTWARE IS PROVIDED BY UNIVERSITY OF MASSACHUSETTS AND OTHER CONTRIBUTORS  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  SUCH DAMAGE.  */
end_comment
begin_package
DECL|package|org.apache.lucene.analysis.en
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|en
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|CharArrayMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|OpenStringBuilder
import|;
end_import
begin_comment
comment|/**  *<p>Title: Kstemmer</p>  *<p>Description: This is a java version of Bob Krovetz' kstem stemmer</p>  *<p>Copyright: Copyright 2008, Luicid Imagination, Inc.</p>  *<p>Copyright: Copyright 2003, CIIR University of Massachusetts Amherst (http://ciir.cs.umass.edu)</p>  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
import|;
end_import
begin_comment
comment|/**  * This class implements the Kstem algorithm  */
end_comment
begin_class
DECL|class|KStemmer
specifier|public
class|class
name|KStemmer
block|{
DECL|field|MaxWordLen
specifier|static
specifier|private
specifier|final
name|int
name|MaxWordLen
init|=
literal|50
decl_stmt|;
DECL|field|exceptionWords
specifier|static
specifier|private
specifier|final
name|String
index|[]
name|exceptionWords
init|=
block|{
literal|"aide"
block|,
literal|"bathe"
block|,
literal|"caste"
block|,
literal|"cute"
block|,
literal|"dame"
block|,
literal|"dime"
block|,
literal|"doge"
block|,
literal|"done"
block|,
literal|"dune"
block|,
literal|"envelope"
block|,
literal|"gage"
block|,
literal|"grille"
block|,
literal|"grippe"
block|,
literal|"lobe"
block|,
literal|"mane"
block|,
literal|"mare"
block|,
literal|"nape"
block|,
literal|"node"
block|,
literal|"pane"
block|,
literal|"pate"
block|,
literal|"plane"
block|,
literal|"pope"
block|,
literal|"programme"
block|,
literal|"quite"
block|,
literal|"ripe"
block|,
literal|"rote"
block|,
literal|"rune"
block|,
literal|"sage"
block|,
literal|"severe"
block|,
literal|"shoppe"
block|,
literal|"sine"
block|,
literal|"slime"
block|,
literal|"snipe"
block|,
literal|"steppe"
block|,
literal|"suite"
block|,
literal|"swinge"
block|,
literal|"tare"
block|,
literal|"tine"
block|,
literal|"tope"
block|,
literal|"tripe"
block|,
literal|"twine"
block|}
decl_stmt|;
DECL|field|directConflations
specifier|static
specifier|private
specifier|final
name|String
index|[]
index|[]
name|directConflations
init|=
block|{
block|{
literal|"aging"
block|,
literal|"age"
block|}
block|,
block|{
literal|"going"
block|,
literal|"go"
block|}
block|,
block|{
literal|"goes"
block|,
literal|"go"
block|}
block|,
block|{
literal|"lying"
block|,
literal|"lie"
block|}
block|,
block|{
literal|"using"
block|,
literal|"use"
block|}
block|,
block|{
literal|"owing"
block|,
literal|"owe"
block|}
block|,
block|{
literal|"suing"
block|,
literal|"sue"
block|}
block|,
block|{
literal|"dying"
block|,
literal|"die"
block|}
block|,
block|{
literal|"tying"
block|,
literal|"tie"
block|}
block|,
block|{
literal|"vying"
block|,
literal|"vie"
block|}
block|,
block|{
literal|"aged"
block|,
literal|"age"
block|}
block|,
block|{
literal|"used"
block|,
literal|"use"
block|}
block|,
block|{
literal|"vied"
block|,
literal|"vie"
block|}
block|,
block|{
literal|"cued"
block|,
literal|"cue"
block|}
block|,
block|{
literal|"died"
block|,
literal|"die"
block|}
block|,
block|{
literal|"eyed"
block|,
literal|"eye"
block|}
block|,
block|{
literal|"hued"
block|,
literal|"hue"
block|}
block|,
block|{
literal|"iced"
block|,
literal|"ice"
block|}
block|,
block|{
literal|"lied"
block|,
literal|"lie"
block|}
block|,
block|{
literal|"owed"
block|,
literal|"owe"
block|}
block|,
block|{
literal|"sued"
block|,
literal|"sue"
block|}
block|,
block|{
literal|"toed"
block|,
literal|"toe"
block|}
block|,
block|{
literal|"tied"
block|,
literal|"tie"
block|}
block|,
block|{
literal|"does"
block|,
literal|"do"
block|}
block|,
block|{
literal|"doing"
block|,
literal|"do"
block|}
block|,
block|{
literal|"aeronautical"
block|,
literal|"aeronautics"
block|}
block|,
block|{
literal|"mathematical"
block|,
literal|"mathematics"
block|}
block|,
block|{
literal|"political"
block|,
literal|"politics"
block|}
block|,
block|{
literal|"metaphysical"
block|,
literal|"metaphysics"
block|}
block|,
block|{
literal|"cylindrical"
block|,
literal|"cylinder"
block|}
block|,
block|{
literal|"nazism"
block|,
literal|"nazi"
block|}
block|,
block|{
literal|"ambiguity"
block|,
literal|"ambiguous"
block|}
block|,
block|{
literal|"barbarity"
block|,
literal|"barbarous"
block|}
block|,
block|{
literal|"credulity"
block|,
literal|"credulous"
block|}
block|,
block|{
literal|"generosity"
block|,
literal|"generous"
block|}
block|,
block|{
literal|"spontaneity"
block|,
literal|"spontaneous"
block|}
block|,
block|{
literal|"unanimity"
block|,
literal|"unanimous"
block|}
block|,
block|{
literal|"voracity"
block|,
literal|"voracious"
block|}
block|,
block|{
literal|"fled"
block|,
literal|"flee"
block|}
block|,
block|{
literal|"miscarriage"
block|,
literal|"miscarry"
block|}
block|}
decl_stmt|;
DECL|field|countryNationality
specifier|static
specifier|private
specifier|final
name|String
index|[]
index|[]
name|countryNationality
init|=
block|{
block|{
literal|"afghan"
block|,
literal|"afghanistan"
block|}
block|,
block|{
literal|"african"
block|,
literal|"africa"
block|}
block|,
block|{
literal|"albanian"
block|,
literal|"albania"
block|}
block|,
block|{
literal|"algerian"
block|,
literal|"algeria"
block|}
block|,
block|{
literal|"american"
block|,
literal|"america"
block|}
block|,
block|{
literal|"andorran"
block|,
literal|"andorra"
block|}
block|,
block|{
literal|"angolan"
block|,
literal|"angola"
block|}
block|,
block|{
literal|"arabian"
block|,
literal|"arabia"
block|}
block|,
block|{
literal|"argentine"
block|,
literal|"argentina"
block|}
block|,
block|{
literal|"armenian"
block|,
literal|"armenia"
block|}
block|,
block|{
literal|"asian"
block|,
literal|"asia"
block|}
block|,
block|{
literal|"australian"
block|,
literal|"australia"
block|}
block|,
block|{
literal|"austrian"
block|,
literal|"austria"
block|}
block|,
block|{
literal|"azerbaijani"
block|,
literal|"azerbaijan"
block|}
block|,
block|{
literal|"azeri"
block|,
literal|"azerbaijan"
block|}
block|,
block|{
literal|"bangladeshi"
block|,
literal|"bangladesh"
block|}
block|,
block|{
literal|"belgian"
block|,
literal|"belgium"
block|}
block|,
block|{
literal|"bermudan"
block|,
literal|"bermuda"
block|}
block|,
block|{
literal|"bolivian"
block|,
literal|"bolivia"
block|}
block|,
block|{
literal|"bosnian"
block|,
literal|"bosnia"
block|}
block|,
block|{
literal|"botswanan"
block|,
literal|"botswana"
block|}
block|,
block|{
literal|"brazilian"
block|,
literal|"brazil"
block|}
block|,
block|{
literal|"british"
block|,
literal|"britain"
block|}
block|,
block|{
literal|"bulgarian"
block|,
literal|"bulgaria"
block|}
block|,
block|{
literal|"burmese"
block|,
literal|"burma"
block|}
block|,
block|{
literal|"californian"
block|,
literal|"california"
block|}
block|,
block|{
literal|"cambodian"
block|,
literal|"cambodia"
block|}
block|,
block|{
literal|"canadian"
block|,
literal|"canada"
block|}
block|,
block|{
literal|"chadian"
block|,
literal|"chad"
block|}
block|,
block|{
literal|"chilean"
block|,
literal|"chile"
block|}
block|,
block|{
literal|"chinese"
block|,
literal|"china"
block|}
block|,
block|{
literal|"colombian"
block|,
literal|"colombia"
block|}
block|,
block|{
literal|"croat"
block|,
literal|"croatia"
block|}
block|,
block|{
literal|"croatian"
block|,
literal|"croatia"
block|}
block|,
block|{
literal|"cuban"
block|,
literal|"cuba"
block|}
block|,
block|{
literal|"cypriot"
block|,
literal|"cyprus"
block|}
block|,
block|{
literal|"czechoslovakian"
block|,
literal|"czechoslovakia"
block|}
block|,
block|{
literal|"danish"
block|,
literal|"denmark"
block|}
block|,
block|{
literal|"egyptian"
block|,
literal|"egypt"
block|}
block|,
block|{
literal|"equadorian"
block|,
literal|"equador"
block|}
block|,
block|{
literal|"eritrean"
block|,
literal|"eritrea"
block|}
block|,
block|{
literal|"estonian"
block|,
literal|"estonia"
block|}
block|,
block|{
literal|"ethiopian"
block|,
literal|"ethiopia"
block|}
block|,
block|{
literal|"european"
block|,
literal|"europe"
block|}
block|,
block|{
literal|"fijian"
block|,
literal|"fiji"
block|}
block|,
block|{
literal|"filipino"
block|,
literal|"philippines"
block|}
block|,
block|{
literal|"finnish"
block|,
literal|"finland"
block|}
block|,
block|{
literal|"french"
block|,
literal|"france"
block|}
block|,
block|{
literal|"gambian"
block|,
literal|"gambia"
block|}
block|,
block|{
literal|"georgian"
block|,
literal|"georgia"
block|}
block|,
block|{
literal|"german"
block|,
literal|"germany"
block|}
block|,
block|{
literal|"ghanian"
block|,
literal|"ghana"
block|}
block|,
block|{
literal|"greek"
block|,
literal|"greece"
block|}
block|,
block|{
literal|"grenadan"
block|,
literal|"grenada"
block|}
block|,
block|{
literal|"guamian"
block|,
literal|"guam"
block|}
block|,
block|{
literal|"guatemalan"
block|,
literal|"guatemala"
block|}
block|,
block|{
literal|"guinean"
block|,
literal|"guinea"
block|}
block|,
block|{
literal|"guyanan"
block|,
literal|"guyana"
block|}
block|,
block|{
literal|"haitian"
block|,
literal|"haiti"
block|}
block|,
block|{
literal|"hawaiian"
block|,
literal|"hawaii"
block|}
block|,
block|{
literal|"holland"
block|,
literal|"dutch"
block|}
block|,
block|{
literal|"honduran"
block|,
literal|"honduras"
block|}
block|,
block|{
literal|"hungarian"
block|,
literal|"hungary"
block|}
block|,
block|{
literal|"icelandic"
block|,
literal|"iceland"
block|}
block|,
block|{
literal|"indonesian"
block|,
literal|"indonesia"
block|}
block|,
block|{
literal|"iranian"
block|,
literal|"iran"
block|}
block|,
block|{
literal|"iraqi"
block|,
literal|"iraq"
block|}
block|,
block|{
literal|"iraqui"
block|,
literal|"iraq"
block|}
block|,
block|{
literal|"irish"
block|,
literal|"ireland"
block|}
block|,
block|{
literal|"israeli"
block|,
literal|"israel"
block|}
block|,
block|{
literal|"italian"
block|,
literal|"italy"
block|}
block|,
block|{
literal|"jamaican"
block|,
literal|"jamaica"
block|}
block|,
block|{
literal|"japanese"
block|,
literal|"japan"
block|}
block|,
block|{
literal|"jordanian"
block|,
literal|"jordan"
block|}
block|,
block|{
literal|"kampuchean"
block|,
literal|"cambodia"
block|}
block|,
block|{
literal|"kenyan"
block|,
literal|"kenya"
block|}
block|,
block|{
literal|"korean"
block|,
literal|"korea"
block|}
block|,
block|{
literal|"kuwaiti"
block|,
literal|"kuwait"
block|}
block|,
block|{
literal|"lankan"
block|,
literal|"lanka"
block|}
block|,
block|{
literal|"laotian"
block|,
literal|"laos"
block|}
block|,
block|{
literal|"latvian"
block|,
literal|"latvia"
block|}
block|,
block|{
literal|"lebanese"
block|,
literal|"lebanon"
block|}
block|,
block|{
literal|"liberian"
block|,
literal|"liberia"
block|}
block|,
block|{
literal|"libyan"
block|,
literal|"libya"
block|}
block|,
block|{
literal|"lithuanian"
block|,
literal|"lithuania"
block|}
block|,
block|{
literal|"macedonian"
block|,
literal|"macedonia"
block|}
block|,
block|{
literal|"madagascan"
block|,
literal|"madagascar"
block|}
block|,
block|{
literal|"malaysian"
block|,
literal|"malaysia"
block|}
block|,
block|{
literal|"maltese"
block|,
literal|"malta"
block|}
block|,
block|{
literal|"mauritanian"
block|,
literal|"mauritania"
block|}
block|,
block|{
literal|"mexican"
block|,
literal|"mexico"
block|}
block|,
block|{
literal|"micronesian"
block|,
literal|"micronesia"
block|}
block|,
block|{
literal|"moldovan"
block|,
literal|"moldova"
block|}
block|,
block|{
literal|"monacan"
block|,
literal|"monaco"
block|}
block|,
block|{
literal|"mongolian"
block|,
literal|"mongolia"
block|}
block|,
block|{
literal|"montenegran"
block|,
literal|"montenegro"
block|}
block|,
block|{
literal|"moroccan"
block|,
literal|"morocco"
block|}
block|,
block|{
literal|"myanmar"
block|,
literal|"burma"
block|}
block|,
block|{
literal|"namibian"
block|,
literal|"namibia"
block|}
block|,
block|{
literal|"nepalese"
block|,
literal|"nepal"
block|}
block|,
comment|// {"netherlands", "dutch"},
block|{
literal|"nicaraguan"
block|,
literal|"nicaragua"
block|}
block|,
block|{
literal|"nigerian"
block|,
literal|"nigeria"
block|}
block|,
block|{
literal|"norwegian"
block|,
literal|"norway"
block|}
block|,
block|{
literal|"omani"
block|,
literal|"oman"
block|}
block|,
block|{
literal|"pakistani"
block|,
literal|"pakistan"
block|}
block|,
block|{
literal|"panamanian"
block|,
literal|"panama"
block|}
block|,
block|{
literal|"papuan"
block|,
literal|"papua"
block|}
block|,
block|{
literal|"paraguayan"
block|,
literal|"paraguay"
block|}
block|,
block|{
literal|"peruvian"
block|,
literal|"peru"
block|}
block|,
block|{
literal|"portuguese"
block|,
literal|"portugal"
block|}
block|,
block|{
literal|"romanian"
block|,
literal|"romania"
block|}
block|,
block|{
literal|"rumania"
block|,
literal|"romania"
block|}
block|,
block|{
literal|"rumanian"
block|,
literal|"romania"
block|}
block|,
block|{
literal|"russian"
block|,
literal|"russia"
block|}
block|,
block|{
literal|"rwandan"
block|,
literal|"rwanda"
block|}
block|,
block|{
literal|"samoan"
block|,
literal|"samoa"
block|}
block|,
block|{
literal|"scottish"
block|,
literal|"scotland"
block|}
block|,
block|{
literal|"serb"
block|,
literal|"serbia"
block|}
block|,
block|{
literal|"serbian"
block|,
literal|"serbia"
block|}
block|,
block|{
literal|"siam"
block|,
literal|"thailand"
block|}
block|,
block|{
literal|"siamese"
block|,
literal|"thailand"
block|}
block|,
block|{
literal|"slovakia"
block|,
literal|"slovak"
block|}
block|,
block|{
literal|"slovakian"
block|,
literal|"slovak"
block|}
block|,
block|{
literal|"slovenian"
block|,
literal|"slovenia"
block|}
block|,
block|{
literal|"somali"
block|,
literal|"somalia"
block|}
block|,
block|{
literal|"somalian"
block|,
literal|"somalia"
block|}
block|,
block|{
literal|"spanish"
block|,
literal|"spain"
block|}
block|,
block|{
literal|"swedish"
block|,
literal|"sweden"
block|}
block|,
block|{
literal|"swiss"
block|,
literal|"switzerland"
block|}
block|,
block|{
literal|"syrian"
block|,
literal|"syria"
block|}
block|,
block|{
literal|"taiwanese"
block|,
literal|"taiwan"
block|}
block|,
block|{
literal|"tanzanian"
block|,
literal|"tanzania"
block|}
block|,
block|{
literal|"texan"
block|,
literal|"texas"
block|}
block|,
block|{
literal|"thai"
block|,
literal|"thailand"
block|}
block|,
block|{
literal|"tunisian"
block|,
literal|"tunisia"
block|}
block|,
block|{
literal|"turkish"
block|,
literal|"turkey"
block|}
block|,
block|{
literal|"ugandan"
block|,
literal|"uganda"
block|}
block|,
block|{
literal|"ukrainian"
block|,
literal|"ukraine"
block|}
block|,
block|{
literal|"uruguayan"
block|,
literal|"uruguay"
block|}
block|,
block|{
literal|"uzbek"
block|,
literal|"uzbekistan"
block|}
block|,
block|{
literal|"venezuelan"
block|,
literal|"venezuela"
block|}
block|,
block|{
literal|"vietnamese"
block|,
literal|"viet"
block|}
block|,
block|{
literal|"virginian"
block|,
literal|"virginia"
block|}
block|,
block|{
literal|"yemeni"
block|,
literal|"yemen"
block|}
block|,
block|{
literal|"yugoslav"
block|,
literal|"yugoslavia"
block|}
block|,
block|{
literal|"yugoslavian"
block|,
literal|"yugoslavia"
block|}
block|,
block|{
literal|"zambian"
block|,
literal|"zambia"
block|}
block|,
block|{
literal|"zealander"
block|,
literal|"zealand"
block|}
block|,
block|{
literal|"zimbabwean"
block|,
literal|"zimbabwe"
block|}
block|}
decl_stmt|;
DECL|field|supplementDict
specifier|static
specifier|private
specifier|final
name|String
index|[]
name|supplementDict
init|=
block|{
literal|"aids"
block|,
literal|"applicator"
block|,
literal|"capacitor"
block|,
literal|"digitize"
block|,
literal|"electromagnet"
block|,
literal|"ellipsoid"
block|,
literal|"exosphere"
block|,
literal|"extensible"
block|,
literal|"ferromagnet"
block|,
literal|"graphics"
block|,
literal|"hydromagnet"
block|,
literal|"polygraph"
block|,
literal|"toroid"
block|,
literal|"superconduct"
block|,
literal|"backscatter"
block|,
literal|"connectionism"
block|}
decl_stmt|;
DECL|field|properNouns
specifier|static
specifier|private
specifier|final
name|String
index|[]
name|properNouns
init|=
block|{
literal|"abrams"
block|,
literal|"achilles"
block|,
literal|"acropolis"
block|,
literal|"adams"
block|,
literal|"agnes"
block|,
literal|"aires"
block|,
literal|"alexander"
block|,
literal|"alexis"
block|,
literal|"alfred"
block|,
literal|"algiers"
block|,
literal|"alps"
block|,
literal|"amadeus"
block|,
literal|"ames"
block|,
literal|"amos"
block|,
literal|"andes"
block|,
literal|"angeles"
block|,
literal|"annapolis"
block|,
literal|"antilles"
block|,
literal|"aquarius"
block|,
literal|"archimedes"
block|,
literal|"arkansas"
block|,
literal|"asher"
block|,
literal|"ashly"
block|,
literal|"athens"
block|,
literal|"atkins"
block|,
literal|"atlantis"
block|,
literal|"avis"
block|,
literal|"bahamas"
block|,
literal|"bangor"
block|,
literal|"barbados"
block|,
literal|"barger"
block|,
literal|"bering"
block|,
literal|"brahms"
block|,
literal|"brandeis"
block|,
literal|"brussels"
block|,
literal|"bruxelles"
block|,
literal|"cairns"
block|,
literal|"camoros"
block|,
literal|"camus"
block|,
literal|"carlos"
block|,
literal|"celts"
block|,
literal|"chalker"
block|,
literal|"charles"
block|,
literal|"cheops"
block|,
literal|"ching"
block|,
literal|"christmas"
block|,
literal|"cocos"
block|,
literal|"collins"
block|,
literal|"columbus"
block|,
literal|"confucius"
block|,
literal|"conners"
block|,
literal|"connolly"
block|,
literal|"copernicus"
block|,
literal|"cramer"
block|,
literal|"cyclops"
block|,
literal|"cygnus"
block|,
literal|"cyprus"
block|,
literal|"dallas"
block|,
literal|"damascus"
block|,
literal|"daniels"
block|,
literal|"davies"
block|,
literal|"davis"
block|,
literal|"decker"
block|,
literal|"denning"
block|,
literal|"dennis"
block|,
literal|"descartes"
block|,
literal|"dickens"
block|,
literal|"doris"
block|,
literal|"douglas"
block|,
literal|"downs"
block|,
literal|"dreyfus"
block|,
literal|"dukakis"
block|,
literal|"dulles"
block|,
literal|"dumfries"
block|,
literal|"ecclesiastes"
block|,
literal|"edwards"
block|,
literal|"emily"
block|,
literal|"erasmus"
block|,
literal|"euphrates"
block|,
literal|"evans"
block|,
literal|"everglades"
block|,
literal|"fairbanks"
block|,
literal|"federales"
block|,
literal|"fisher"
block|,
literal|"fitzsimmons"
block|,
literal|"fleming"
block|,
literal|"forbes"
block|,
literal|"fowler"
block|,
literal|"france"
block|,
literal|"francis"
block|,
literal|"goering"
block|,
literal|"goodling"
block|,
literal|"goths"
block|,
literal|"grenadines"
block|,
literal|"guiness"
block|,
literal|"hades"
block|,
literal|"harding"
block|,
literal|"harris"
block|,
literal|"hastings"
block|,
literal|"hawkes"
block|,
literal|"hawking"
block|,
literal|"hayes"
block|,
literal|"heights"
block|,
literal|"hercules"
block|,
literal|"himalayas"
block|,
literal|"hippocrates"
block|,
literal|"hobbs"
block|,
literal|"holmes"
block|,
literal|"honduras"
block|,
literal|"hopkins"
block|,
literal|"hughes"
block|,
literal|"humphreys"
block|,
literal|"illinois"
block|,
literal|"indianapolis"
block|,
literal|"inverness"
block|,
literal|"iris"
block|,
literal|"iroquois"
block|,
literal|"irving"
block|,
literal|"isaacs"
block|,
literal|"italy"
block|,
literal|"james"
block|,
literal|"jarvis"
block|,
literal|"jeffreys"
block|,
literal|"jesus"
block|,
literal|"jones"
block|,
literal|"josephus"
block|,
literal|"judas"
block|,
literal|"julius"
block|,
literal|"kansas"
block|,
literal|"keynes"
block|,
literal|"kipling"
block|,
literal|"kiwanis"
block|,
literal|"lansing"
block|,
literal|"laos"
block|,
literal|"leeds"
block|,
literal|"levis"
block|,
literal|"leviticus"
block|,
literal|"lewis"
block|,
literal|"louis"
block|,
literal|"maccabees"
block|,
literal|"madras"
block|,
literal|"maimonides"
block|,
literal|"maldive"
block|,
literal|"massachusetts"
block|,
literal|"matthews"
block|,
literal|"mauritius"
block|,
literal|"memphis"
block|,
literal|"mercedes"
block|,
literal|"midas"
block|,
literal|"mingus"
block|,
literal|"minneapolis"
block|,
literal|"mohammed"
block|,
literal|"moines"
block|,
literal|"morris"
block|,
literal|"moses"
block|,
literal|"myers"
block|,
literal|"myknos"
block|,
literal|"nablus"
block|,
literal|"nanjing"
block|,
literal|"nantes"
block|,
literal|"naples"
block|,
literal|"neal"
block|,
literal|"netherlands"
block|,
literal|"nevis"
block|,
literal|"nostradamus"
block|,
literal|"oedipus"
block|,
literal|"olympus"
block|,
literal|"orleans"
block|,
literal|"orly"
block|,
literal|"papas"
block|,
literal|"paris"
block|,
literal|"parker"
block|,
literal|"pauling"
block|,
literal|"peking"
block|,
literal|"pershing"
block|,
literal|"peter"
block|,
literal|"peters"
block|,
literal|"philippines"
block|,
literal|"phineas"
block|,
literal|"pisces"
block|,
literal|"pryor"
block|,
literal|"pythagoras"
block|,
literal|"queens"
block|,
literal|"rabelais"
block|,
literal|"ramses"
block|,
literal|"reynolds"
block|,
literal|"rhesus"
block|,
literal|"rhodes"
block|,
literal|"richards"
block|,
literal|"robins"
block|,
literal|"rodgers"
block|,
literal|"rogers"
block|,
literal|"rubens"
block|,
literal|"sagittarius"
block|,
literal|"seychelles"
block|,
literal|"socrates"
block|,
literal|"texas"
block|,
literal|"thames"
block|,
literal|"thomas"
block|,
literal|"tiberias"
block|,
literal|"tunis"
block|,
literal|"venus"
block|,
literal|"vilnius"
block|,
literal|"wales"
block|,
literal|"warner"
block|,
literal|"wilkins"
block|,
literal|"williams"
block|,
literal|"wyoming"
block|,
literal|"xmas"
block|,
literal|"yonkers"
block|,
literal|"zeus"
block|,
literal|"frances"
block|,
literal|"aarhus"
block|,
literal|"adonis"
block|,
literal|"andrews"
block|,
literal|"angus"
block|,
literal|"antares"
block|,
literal|"aquinas"
block|,
literal|"arcturus"
block|,
literal|"ares"
block|,
literal|"artemis"
block|,
literal|"augustus"
block|,
literal|"ayers"
block|,
literal|"barnabas"
block|,
literal|"barnes"
block|,
literal|"becker"
block|,
literal|"bejing"
block|,
literal|"biggs"
block|,
literal|"billings"
block|,
literal|"boeing"
block|,
literal|"boris"
block|,
literal|"borroughs"
block|,
literal|"briggs"
block|,
literal|"buenos"
block|,
literal|"calais"
block|,
literal|"caracas"
block|,
literal|"cassius"
block|,
literal|"cerberus"
block|,
literal|"ceres"
block|,
literal|"cervantes"
block|,
literal|"chantilly"
block|,
literal|"chartres"
block|,
literal|"chester"
block|,
literal|"connally"
block|,
literal|"conner"
block|,
literal|"coors"
block|,
literal|"cummings"
block|,
literal|"curtis"
block|,
literal|"daedalus"
block|,
literal|"dionysus"
block|,
literal|"dobbs"
block|,
literal|"dolores"
block|,
literal|"edmonds"
block|}
decl_stmt|;
DECL|class|DictEntry
specifier|static
class|class
name|DictEntry
block|{
DECL|field|exception
name|boolean
name|exception
decl_stmt|;
DECL|field|root
name|String
name|root
decl_stmt|;
DECL|method|DictEntry
name|DictEntry
parameter_list|(
name|String
name|root
parameter_list|,
name|boolean
name|isException
parameter_list|)
block|{
name|this
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|this
operator|.
name|exception
operator|=
name|isException
expr_stmt|;
block|}
block|}
DECL|field|dict_ht
specifier|private
specifier|static
specifier|final
name|CharArrayMap
argument_list|<
name|DictEntry
argument_list|>
name|dict_ht
init|=
name|initializeDictHash
argument_list|()
decl_stmt|;
comment|/***    * caching off private int maxCacheSize; private CharArrayMap<String> cache =    * null; private static final String SAME = "SAME"; // use if stemmed form is    * the same    ***/
DECL|field|word
specifier|private
specifier|final
name|OpenStringBuilder
name|word
init|=
operator|new
name|OpenStringBuilder
argument_list|()
decl_stmt|;
DECL|field|j
specifier|private
name|int
name|j
decl_stmt|;
comment|/* index of final letter in stem (within word) */
DECL|field|k
specifier|private
name|int
name|k
decl_stmt|;
comment|/*                   * INDEX of final letter in word. You must add 1 to k to get                   * the current length of word. When you want the length of                   * word, use the method wordLength, which returns (k+1).                   */
comment|/***    * private void initializeStemHash() { if (maxCacheSize> 0) cache = new    * CharArrayMap<String>(maxCacheSize,false); }    ***/
DECL|method|finalChar
specifier|private
name|char
name|finalChar
parameter_list|()
block|{
return|return
name|word
operator|.
name|charAt
argument_list|(
name|k
argument_list|)
return|;
block|}
DECL|method|penultChar
specifier|private
name|char
name|penultChar
parameter_list|()
block|{
return|return
name|word
operator|.
name|charAt
argument_list|(
name|k
operator|-
literal|1
argument_list|)
return|;
block|}
DECL|method|isVowel
specifier|private
name|boolean
name|isVowel
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
operator|!
name|isCons
argument_list|(
name|index
argument_list|)
return|;
block|}
DECL|method|isCons
specifier|private
name|boolean
name|isCons
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|char
name|ch
decl_stmt|;
name|ch
operator|=
name|word
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|==
literal|'a'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'e'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'i'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'o'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'u'
operator|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|(
name|ch
operator|!=
literal|'y'
operator|)
operator|||
operator|(
name|index
operator|==
literal|0
operator|)
condition|)
return|return
literal|true
return|;
else|else
return|return
operator|(
operator|!
name|isCons
argument_list|(
name|index
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
DECL|method|initializeDictHash
specifier|private
specifier|static
name|CharArrayMap
argument_list|<
name|DictEntry
argument_list|>
name|initializeDictHash
parameter_list|()
block|{
name|DictEntry
name|defaultEntry
decl_stmt|;
name|DictEntry
name|entry
decl_stmt|;
name|CharArrayMap
argument_list|<
name|DictEntry
argument_list|>
name|d
init|=
operator|new
name|CharArrayMap
argument_list|<>
argument_list|(
name|Version
operator|.
name|LUCENE_CURRENT
argument_list|,
literal|1000
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exceptionWords
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|containsKey
argument_list|(
name|exceptionWords
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|entry
operator|=
operator|new
name|DictEntry
argument_list|(
name|exceptionWords
index|[
name|i
index|]
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|d
operator|.
name|put
argument_list|(
name|exceptionWords
index|[
name|i
index|]
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Warning: Entry ["
operator|+
name|exceptionWords
index|[
name|i
index|]
operator|+
literal|"] already in dictionary 1"
argument_list|)
throw|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|directConflations
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|containsKey
argument_list|(
name|directConflations
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|entry
operator|=
operator|new
name|DictEntry
argument_list|(
name|directConflations
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|d
operator|.
name|put
argument_list|(
name|directConflations
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Warning: Entry ["
operator|+
name|directConflations
index|[
name|i
index|]
index|[
literal|0
index|]
operator|+
literal|"] already in dictionary 2"
argument_list|)
throw|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|countryNationality
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|containsKey
argument_list|(
name|countryNationality
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|entry
operator|=
operator|new
name|DictEntry
argument_list|(
name|countryNationality
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|d
operator|.
name|put
argument_list|(
name|countryNationality
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Warning: Entry ["
operator|+
name|countryNationality
index|[
name|i
index|]
index|[
literal|0
index|]
operator|+
literal|"] already in dictionary 3"
argument_list|)
throw|;
block|}
block|}
name|defaultEntry
operator|=
operator|new
name|DictEntry
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|String
index|[]
name|array
decl_stmt|;
name|array
operator|=
name|KStemData1
operator|.
name|data
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|array
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|containsKey
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|d
operator|.
name|put
argument_list|(
name|array
index|[
name|i
index|]
argument_list|,
name|defaultEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Warning: Entry ["
operator|+
name|array
index|[
name|i
index|]
operator|+
literal|"] already in dictionary 4"
argument_list|)
throw|;
block|}
block|}
name|array
operator|=
name|KStemData2
operator|.
name|data
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|array
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|containsKey
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|d
operator|.
name|put
argument_list|(
name|array
index|[
name|i
index|]
argument_list|,
name|defaultEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Warning: Entry ["
operator|+
name|array
index|[
name|i
index|]
operator|+
literal|"] already in dictionary 4"
argument_list|)
throw|;
block|}
block|}
name|array
operator|=
name|KStemData3
operator|.
name|data
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|array
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|containsKey
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|d
operator|.
name|put
argument_list|(
name|array
index|[
name|i
index|]
argument_list|,
name|defaultEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Warning: Entry ["
operator|+
name|array
index|[
name|i
index|]
operator|+
literal|"] already in dictionary 4"
argument_list|)
throw|;
block|}
block|}
name|array
operator|=
name|KStemData4
operator|.
name|data
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|array
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|containsKey
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|d
operator|.
name|put
argument_list|(
name|array
index|[
name|i
index|]
argument_list|,
name|defaultEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Warning: Entry ["
operator|+
name|array
index|[
name|i
index|]
operator|+
literal|"] already in dictionary 4"
argument_list|)
throw|;
block|}
block|}
name|array
operator|=
name|KStemData5
operator|.
name|data
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|array
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|containsKey
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|d
operator|.
name|put
argument_list|(
name|array
index|[
name|i
index|]
argument_list|,
name|defaultEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Warning: Entry ["
operator|+
name|array
index|[
name|i
index|]
operator|+
literal|"] already in dictionary 4"
argument_list|)
throw|;
block|}
block|}
name|array
operator|=
name|KStemData6
operator|.
name|data
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|array
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|containsKey
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|d
operator|.
name|put
argument_list|(
name|array
index|[
name|i
index|]
argument_list|,
name|defaultEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Warning: Entry ["
operator|+
name|array
index|[
name|i
index|]
operator|+
literal|"] already in dictionary 4"
argument_list|)
throw|;
block|}
block|}
name|array
operator|=
name|KStemData7
operator|.
name|data
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|array
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|containsKey
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|d
operator|.
name|put
argument_list|(
name|array
index|[
name|i
index|]
argument_list|,
name|defaultEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Warning: Entry ["
operator|+
name|array
index|[
name|i
index|]
operator|+
literal|"] already in dictionary 4"
argument_list|)
throw|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|KStemData8
operator|.
name|data
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|containsKey
argument_list|(
name|KStemData8
operator|.
name|data
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|d
operator|.
name|put
argument_list|(
name|KStemData8
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|defaultEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Warning: Entry ["
operator|+
name|KStemData8
operator|.
name|data
index|[
name|i
index|]
operator|+
literal|"] already in dictionary 4"
argument_list|)
throw|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|supplementDict
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|containsKey
argument_list|(
name|supplementDict
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|d
operator|.
name|put
argument_list|(
name|supplementDict
index|[
name|i
index|]
argument_list|,
name|defaultEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Warning: Entry ["
operator|+
name|supplementDict
index|[
name|i
index|]
operator|+
literal|"] already in dictionary 5"
argument_list|)
throw|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|properNouns
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|containsKey
argument_list|(
name|properNouns
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|d
operator|.
name|put
argument_list|(
name|properNouns
index|[
name|i
index|]
argument_list|,
name|defaultEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Warning: Entry ["
operator|+
name|properNouns
index|[
name|i
index|]
operator|+
literal|"] already in dictionary 6"
argument_list|)
throw|;
block|}
block|}
return|return
name|d
return|;
block|}
DECL|method|isAlpha
specifier|private
name|boolean
name|isAlpha
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
return|;
comment|// terms must be lowercased already
block|}
comment|/* length of stem within word */
DECL|method|stemLength
specifier|private
name|int
name|stemLength
parameter_list|()
block|{
return|return
name|j
operator|+
literal|1
return|;
block|}
empty_stmt|;
DECL|method|endsIn
specifier|private
name|boolean
name|endsIn
parameter_list|(
name|char
index|[]
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|length
operator|>
name|k
condition|)
return|return
literal|false
return|;
name|int
name|r
init|=
name|word
operator|.
name|length
argument_list|()
operator|-
name|s
operator|.
name|length
decl_stmt|;
comment|/* length of word before this suffix */
name|j
operator|=
name|k
expr_stmt|;
for|for
control|(
name|int
name|r1
init|=
name|r
init|,
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
condition|;
name|i
operator|++
operator|,
name|r1
operator|++
control|)
block|{
if|if
condition|(
name|s
index|[
name|i
index|]
operator|!=
name|word
operator|.
name|charAt
argument_list|(
name|r1
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
name|j
operator|=
name|r
operator|-
literal|1
expr_stmt|;
comment|/* index of the character BEFORE the posfix */
return|return
literal|true
return|;
block|}
DECL|method|endsIn
specifier|private
name|boolean
name|endsIn
parameter_list|(
name|char
name|a
parameter_list|,
name|char
name|b
parameter_list|)
block|{
if|if
condition|(
literal|2
operator|>
name|k
condition|)
return|return
literal|false
return|;
comment|// check left to right since the endings have often already matched
if|if
condition|(
name|word
operator|.
name|charAt
argument_list|(
name|k
operator|-
literal|1
argument_list|)
operator|==
name|a
operator|&&
name|word
operator|.
name|charAt
argument_list|(
name|k
argument_list|)
operator|==
name|b
condition|)
block|{
name|j
operator|=
name|k
operator|-
literal|2
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|endsIn
specifier|private
name|boolean
name|endsIn
parameter_list|(
name|char
name|a
parameter_list|,
name|char
name|b
parameter_list|,
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
literal|3
operator|>
name|k
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|word
operator|.
name|charAt
argument_list|(
name|k
operator|-
literal|2
argument_list|)
operator|==
name|a
operator|&&
name|word
operator|.
name|charAt
argument_list|(
name|k
operator|-
literal|1
argument_list|)
operator|==
name|b
operator|&&
name|word
operator|.
name|charAt
argument_list|(
name|k
argument_list|)
operator|==
name|c
condition|)
block|{
name|j
operator|=
name|k
operator|-
literal|3
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|endsIn
specifier|private
name|boolean
name|endsIn
parameter_list|(
name|char
name|a
parameter_list|,
name|char
name|b
parameter_list|,
name|char
name|c
parameter_list|,
name|char
name|d
parameter_list|)
block|{
if|if
condition|(
literal|4
operator|>
name|k
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|word
operator|.
name|charAt
argument_list|(
name|k
operator|-
literal|3
argument_list|)
operator|==
name|a
operator|&&
name|word
operator|.
name|charAt
argument_list|(
name|k
operator|-
literal|2
argument_list|)
operator|==
name|b
operator|&&
name|word
operator|.
name|charAt
argument_list|(
name|k
operator|-
literal|1
argument_list|)
operator|==
name|c
operator|&&
name|word
operator|.
name|charAt
argument_list|(
name|k
argument_list|)
operator|==
name|d
condition|)
block|{
name|j
operator|=
name|k
operator|-
literal|4
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|wordInDict
specifier|private
name|DictEntry
name|wordInDict
parameter_list|()
block|{
comment|/***      * if (matchedEntry != null) { if (dict_ht.get(word.getArray(), 0,      * word.size()) != matchedEntry) {      * System.out.println("Uh oh... cached entry doesn't match"); } return      * matchedEntry; }      ***/
if|if
condition|(
name|matchedEntry
operator|!=
literal|null
condition|)
return|return
name|matchedEntry
return|;
name|DictEntry
name|e
init|=
name|dict_ht
operator|.
name|get
argument_list|(
name|word
operator|.
name|getArray
argument_list|()
argument_list|,
literal|0
argument_list|,
name|word
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|!=
literal|null
operator|&&
operator|!
name|e
operator|.
name|exception
condition|)
block|{
name|matchedEntry
operator|=
name|e
expr_stmt|;
comment|// only cache if it's not an exception.
block|}
comment|// lookups.add(word.toString());
return|return
name|e
return|;
block|}
comment|/* Convert plurals to singular form, and '-ies' to 'y' */
DECL|method|plural
specifier|private
name|void
name|plural
parameter_list|()
block|{
if|if
condition|(
name|word
operator|.
name|charAt
argument_list|(
name|k
argument_list|)
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
name|endsIn
argument_list|(
literal|'i'
argument_list|,
literal|'e'
argument_list|,
literal|'s'
argument_list|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|3
argument_list|)
expr_stmt|;
name|k
operator|--
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
comment|/* ensure calories -> calorie */
return|return;
name|k
operator|++
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|setSuffix
argument_list|(
literal|"y"
argument_list|)
expr_stmt|;
name|lookup
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|endsIn
argument_list|(
literal|'e'
argument_list|,
literal|'s'
argument_list|)
condition|)
block|{
comment|/* try just removing the "s" */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|2
argument_list|)
expr_stmt|;
name|k
operator|--
expr_stmt|;
comment|/*          * note: don't check for exceptions here. So, `aides' -> `aide', but          * `aided' -> `aid'. The exception for double s is used to prevent          * crosses -> crosse. This is actually correct if crosses is a plural          * noun (a type of racket used in lacrosse), but the verb is much more          * common          */
comment|/****          * YCS: this was the one place where lookup was not followed by return.          * So restructure it. if ((j>0)&&(lookup(word.toString()))&&          * !((word.charAt(j) == 's')&& (word.charAt(j-1) == 's'))) return;          *****/
name|boolean
name|tryE
init|=
name|j
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
operator|-
literal|1
argument_list|)
operator|==
literal|'s'
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|tryE
operator|&&
name|lookup
argument_list|()
condition|)
return|return;
comment|/* try removing the "es" */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|k
operator|--
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
comment|/* the default is to retain the "e" */
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|tryE
condition|)
name|lookup
argument_list|()
expr_stmt|;
comment|// if we didn't try the "e" ending before
return|return;
block|}
else|else
block|{
if|if
condition|(
name|word
operator|.
name|length
argument_list|()
operator|>
literal|3
operator|&&
name|penultChar
argument_list|()
operator|!=
literal|'s'
operator|&&
operator|!
name|endsIn
argument_list|(
literal|'o'
argument_list|,
literal|'u'
argument_list|,
literal|'s'
argument_list|)
condition|)
block|{
comment|/* unless the word ends in "ous" or a double "s", remove the final "s" */
name|word
operator|.
name|setLength
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|k
operator|--
expr_stmt|;
name|lookup
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|setSuffix
specifier|private
name|void
name|setSuffix
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|setSuff
argument_list|(
name|s
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* replace old suffix with s */
DECL|method|setSuff
specifier|private
name|void
name|setSuff
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|l
init|=
literal|0
init|;
name|l
operator|<
name|len
condition|;
name|l
operator|++
control|)
block|{
name|word
operator|.
name|unsafeWrite
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
name|j
operator|+
name|len
expr_stmt|;
block|}
comment|/* Returns true if the word is found in the dictionary */
comment|// almost all uses of lookup() return immediately and are
comment|// followed by another lookup in the dict. Store the match
comment|// to avoid this double lookup.
DECL|field|matchedEntry
name|DictEntry
name|matchedEntry
init|=
literal|null
decl_stmt|;
DECL|method|lookup
specifier|private
name|boolean
name|lookup
parameter_list|()
block|{
comment|/******      * debugging code String thisLookup = word.toString(); boolean added =      * lookups.add(thisLookup); if (!added) {      * System.out.println("######extra lookup:" + thisLookup); // occaasional      * extra lookups aren't necessarily errors... could happen by diff      * manipulations // throw new RuntimeException("######extra lookup:" +      * thisLookup); } else { // System.out.println("new lookup:" + thisLookup);      * }      ******/
name|matchedEntry
operator|=
name|dict_ht
operator|.
name|get
argument_list|(
name|word
operator|.
name|getArray
argument_list|()
argument_list|,
literal|0
argument_list|,
name|word
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|matchedEntry
operator|!=
literal|null
return|;
block|}
comment|// Set<String> lookups = new HashSet<>();
comment|/* convert past tense (-ed) to present, and `-ied' to `y' */
DECL|method|pastTense
specifier|private
name|void
name|pastTense
parameter_list|()
block|{
comment|/*      * Handle words less than 5 letters with a direct mapping This prevents      * (fled -> fl).      */
if|if
condition|(
name|word
operator|.
name|length
argument_list|()
operator|<=
literal|4
condition|)
return|return;
if|if
condition|(
name|endsIn
argument_list|(
literal|'i'
argument_list|,
literal|'e'
argument_list|,
literal|'d'
argument_list|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|3
argument_list|)
expr_stmt|;
name|k
operator|--
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
comment|/* we almost always want to convert -ied to -y, but */
return|return;
comment|/* this isn't true for short words (died->die) */
name|k
operator|++
expr_stmt|;
comment|/* I don't know any long words that this applies to, */
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
comment|/* but just in case... */
name|setSuffix
argument_list|(
literal|"y"
argument_list|)
expr_stmt|;
name|lookup
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* the vowelInStem() is necessary so we don't stem acronyms */
if|if
condition|(
name|endsIn
argument_list|(
literal|'e'
argument_list|,
literal|'d'
argument_list|)
operator|&&
name|vowelInStem
argument_list|()
condition|)
block|{
comment|/* see if the root ends in `e' */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|2
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
name|DictEntry
name|entry
init|=
name|wordInDict
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
if|if
condition|(
operator|!
name|entry
operator|.
name|exception
condition|)
comment|/*                                                 * if it's in the dictionary and                                                 * not an exception                                                 */
return|return;
comment|/* try removing the "ed" */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
comment|/*        * try removing a doubled consonant. if the root isn't found in the        * dictionary, the default is to leave it doubled. This will correctly        * capture `backfilled' -> `backfill' instead of `backfill' ->        * `backfille', and seems correct most of the time        */
if|if
condition|(
name|doubleC
argument_list|(
name|k
argument_list|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|k
operator|--
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|unsafeWrite
argument_list|(
name|word
operator|.
name|charAt
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
name|lookup
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if we have a `un-' prefix, then leave the word alone */
comment|/* (this will sometimes screw up with `under-', but we */
comment|/* will take care of that later) */
if|if
condition|(
operator|(
name|word
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'u'
operator|)
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
literal|1
argument_list|)
operator|==
literal|'n'
operator|)
condition|)
block|{
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
name|k
operator|=
name|k
operator|+
literal|2
expr_stmt|;
comment|// nolookup()
return|return;
block|}
comment|/*        * it wasn't found by just removing the `d' or the `ed', so prefer to end        * with an `e' (e.g., `microcoded' -> `microcode').        */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
comment|// nolookup() - we already tried the "e" ending
return|return;
block|}
block|}
comment|/* return TRUE if word ends with a double consonant */
DECL|method|doubleC
specifier|private
name|boolean
name|doubleC
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|<
literal|1
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|word
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|!=
name|word
operator|.
name|charAt
argument_list|(
name|i
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
operator|(
name|isCons
argument_list|(
name|i
argument_list|)
operator|)
return|;
block|}
DECL|method|vowelInStem
specifier|private
name|boolean
name|vowelInStem
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stemLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isVowel
argument_list|(
name|i
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/* handle `-ing' endings */
DECL|method|aspect
specifier|private
name|void
name|aspect
parameter_list|()
block|{
comment|/*      * handle short words (aging -> age) via a direct mapping. This prevents      * (thing -> the) in the version of this routine that ignores inflectional      * variants that are mentioned in the dictionary (when the root is also      * present)      */
if|if
condition|(
name|word
operator|.
name|length
argument_list|()
operator|<=
literal|5
condition|)
return|return;
comment|/* the vowelinstem() is necessary so we don't stem acronyms */
if|if
condition|(
name|endsIn
argument_list|(
literal|'i'
argument_list|,
literal|'n'
argument_list|,
literal|'g'
argument_list|)
operator|&&
name|vowelInStem
argument_list|()
condition|)
block|{
comment|/* try adding an `e' to the stem and check against the dictionary */
name|word
operator|.
name|setCharAt
argument_list|(
name|j
operator|+
literal|1
argument_list|,
literal|'e'
argument_list|)
expr_stmt|;
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|2
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
name|DictEntry
name|entry
init|=
name|wordInDict
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|entry
operator|.
name|exception
condition|)
comment|/* if it's in the dictionary and not an exception */
return|return;
block|}
comment|/* adding on the `e' didn't work, so remove it */
name|word
operator|.
name|setLength
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|k
operator|--
expr_stmt|;
comment|/* note that `ing' has also been removed */
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
comment|/* if I can remove a doubled consonant and get a word, then do so */
if|if
condition|(
name|doubleC
argument_list|(
name|k
argument_list|)
condition|)
block|{
name|k
operator|--
expr_stmt|;
name|word
operator|.
name|setLength
argument_list|(
name|k
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|unsafeWrite
argument_list|(
name|word
operator|.
name|charAt
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restore the doubled consonant */
comment|/* the default is to leave the consonant doubled */
comment|/* (e.g.,`fingerspelling' -> `fingerspell'). Unfortunately */
comment|/* `bookselling' -> `booksell' and `mislabelling' -> `mislabell'). */
comment|/* Without making the algorithm significantly more complicated, this */
comment|/* is the best I can do */
name|k
operator|++
expr_stmt|;
name|lookup
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/*        * the word wasn't in the dictionary after removing the stem, and then        * checking with and without a final `e'. The default is to add an `e'        * unless the word ends in two consonants, so `microcoding' ->        * `microcode'. The two consonants restriction wouldn't normally be        * necessary, but is needed because we don't try to deal with prefixes and        * compounds, and most of the time it is correct (e.g., footstamping ->        * footstamp, not footstampe; however, decoupled -> decoupl). We can        * prevent almost all of the incorrect stems if we try to do some prefix        * analysis first        */
if|if
condition|(
operator|(
name|j
operator|>
literal|0
operator|)
operator|&&
name|isCons
argument_list|(
name|j
argument_list|)
operator|&&
name|isCons
argument_list|(
name|j
operator|-
literal|1
argument_list|)
condition|)
block|{
name|k
operator|=
name|j
expr_stmt|;
name|word
operator|.
name|setLength
argument_list|(
name|k
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// nolookup() because we already did according to the comment
return|return;
block|}
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
comment|// nolookup(); we already tried an 'e' ending
return|return;
block|}
block|}
comment|/*    * this routine deals with -ity endings. It accepts -ability, -ibility, and    * -ality, even without checking the dictionary because they are so    * productive. The first two are mapped to -ble, and the -ity is remove for    * the latter    */
DECL|method|ityEndings
specifier|private
name|void
name|ityEndings
parameter_list|()
block|{
name|int
name|old_k
init|=
name|k
decl_stmt|;
if|if
condition|(
name|endsIn
argument_list|(
literal|'i'
argument_list|,
literal|'t'
argument_list|,
literal|'y'
argument_list|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* try just removing -ity */
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
comment|/* try removing -ity and adding -e */
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setCharAt
argument_list|(
name|j
operator|+
literal|1
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
name|word
operator|.
name|append
argument_list|(
literal|"ty"
argument_list|)
expr_stmt|;
name|k
operator|=
name|old_k
expr_stmt|;
comment|/*        * the -ability and -ibility endings are highly productive, so just accept        * them        */
if|if
condition|(
operator|(
name|j
operator|>
literal|0
operator|)
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
operator|-
literal|1
argument_list|)
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'l'
operator|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|-
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|append
argument_list|(
literal|"le"
argument_list|)
expr_stmt|;
comment|/* convert to -ble */
name|k
operator|=
name|j
expr_stmt|;
name|lookup
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* ditto for -ivity */
if|if
condition|(
operator|(
name|j
operator|>
literal|0
operator|)
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
operator|-
literal|1
argument_list|)
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'v'
operator|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
comment|/* convert to -ive */
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
name|lookup
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* ditto for -ality */
if|if
condition|(
operator|(
name|j
operator|>
literal|0
operator|)
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
operator|-
literal|1
argument_list|)
operator|==
literal|'a'
operator|)
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'l'
operator|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
name|lookup
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/*        * if the root isn't in the dictionary, and the variant *is* there, then        * use the variant. This allows `immunity'->`immune', but prevents        * `capacity'->`capac'. If neither the variant nor the root form are in        * the dictionary, then remove the ending as a default        */
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
comment|/* the default is to remove -ity altogether */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
comment|// nolookup(), we already did it.
return|return;
block|}
block|}
comment|/* handle -ence and -ance */
DECL|method|nceEndings
specifier|private
name|void
name|nceEndings
parameter_list|()
block|{
name|int
name|old_k
init|=
name|k
decl_stmt|;
name|char
name|word_char
decl_stmt|;
if|if
condition|(
name|endsIn
argument_list|(
literal|'n'
argument_list|,
literal|'c'
argument_list|,
literal|'e'
argument_list|)
condition|)
block|{
name|word_char
operator|=
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|word_char
operator|==
literal|'e'
operator|)
operator|||
operator|(
name|word_char
operator|==
literal|'a'
operator|)
operator|)
condition|)
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
comment|/* try converting -e/ance to -e (adherance/adhere) */
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
argument_list|)
expr_stmt|;
comment|/*                           * try removing -e/ance altogether                           * (disappearance/disappear)                           */
name|k
operator|=
name|j
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|unsafeWrite
argument_list|(
name|word_char
argument_list|)
expr_stmt|;
comment|/* restore the original ending */
name|word
operator|.
name|append
argument_list|(
literal|"nce"
argument_list|)
expr_stmt|;
name|k
operator|=
name|old_k
expr_stmt|;
comment|// nolookup() because we restored the original ending
block|}
return|return;
block|}
comment|/* handle -ness */
DECL|method|nessEndings
specifier|private
name|void
name|nessEndings
parameter_list|()
block|{
if|if
condition|(
name|endsIn
argument_list|(
literal|'n'
argument_list|,
literal|'e'
argument_list|,
literal|'s'
argument_list|,
literal|'s'
argument_list|)
condition|)
block|{
comment|/*                                        * this is a very productive endings, so                                        * just accept it                                        */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'i'
condition|)
name|word
operator|.
name|setCharAt
argument_list|(
name|j
argument_list|,
literal|'y'
argument_list|)
expr_stmt|;
name|lookup
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
comment|/* handle -ism */
DECL|method|ismEndings
specifier|private
name|void
name|ismEndings
parameter_list|()
block|{
if|if
condition|(
name|endsIn
argument_list|(
literal|'i'
argument_list|,
literal|'s'
argument_list|,
literal|'m'
argument_list|)
condition|)
block|{
comment|/*                                   * this is a very productive ending, so just                                   * accept it                                   */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
name|lookup
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
comment|/* this routine deals with -ment endings. */
DECL|method|mentEndings
specifier|private
name|void
name|mentEndings
parameter_list|()
block|{
name|int
name|old_k
init|=
name|k
decl_stmt|;
if|if
condition|(
name|endsIn
argument_list|(
literal|'m'
argument_list|,
literal|'e'
argument_list|,
literal|'n'
argument_list|,
literal|'t'
argument_list|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|append
argument_list|(
literal|"ment"
argument_list|)
expr_stmt|;
name|k
operator|=
name|old_k
expr_stmt|;
comment|// nolookup
block|}
return|return;
block|}
comment|/* this routine deals with -ize endings. */
DECL|method|izeEndings
specifier|private
name|void
name|izeEndings
parameter_list|()
block|{
name|int
name|old_k
init|=
name|k
decl_stmt|;
if|if
condition|(
name|endsIn
argument_list|(
literal|'i'
argument_list|,
literal|'z'
argument_list|,
literal|'e'
argument_list|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* try removing -ize entirely */
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
if|if
condition|(
name|doubleC
argument_list|(
name|j
argument_list|)
condition|)
block|{
comment|/* allow for a doubled consonant */
name|word
operator|.
name|setLength
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|unsafeWrite
argument_list|(
name|word
operator|.
name|charAt
argument_list|(
name|j
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
comment|/* try removing -ize and adding -e */
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|append
argument_list|(
literal|"ize"
argument_list|)
expr_stmt|;
name|k
operator|=
name|old_k
expr_stmt|;
comment|// nolookup()
block|}
return|return;
block|}
comment|/* handle -ency and -ancy */
DECL|method|ncyEndings
specifier|private
name|void
name|ncyEndings
parameter_list|()
block|{
if|if
condition|(
name|endsIn
argument_list|(
literal|'n'
argument_list|,
literal|'c'
argument_list|,
literal|'y'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'e'
operator|)
operator|||
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'a'
operator|)
operator|)
condition|)
return|return;
name|word
operator|.
name|setCharAt
argument_list|(
name|j
operator|+
literal|2
argument_list|,
literal|'t'
argument_list|)
expr_stmt|;
comment|/* try converting -ncy to -nt */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|3
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setCharAt
argument_list|(
name|j
operator|+
literal|2
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
comment|/* the default is to convert it to -nce */
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|+
literal|3
expr_stmt|;
name|lookup
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
comment|/* handle -able and -ible */
DECL|method|bleEndings
specifier|private
name|void
name|bleEndings
parameter_list|()
block|{
name|int
name|old_k
init|=
name|k
decl_stmt|;
name|char
name|word_char
decl_stmt|;
if|if
condition|(
name|endsIn
argument_list|(
literal|'b'
argument_list|,
literal|'l'
argument_list|,
literal|'e'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'a'
operator|)
operator|||
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'i'
operator|)
operator|)
condition|)
return|return;
name|word_char
operator|=
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|word
operator|.
name|setLength
argument_list|(
name|j
argument_list|)
expr_stmt|;
comment|/* try just removing the ending */
name|k
operator|=
name|j
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
if|if
condition|(
name|doubleC
argument_list|(
name|k
argument_list|)
condition|)
block|{
comment|/* allow for a doubled consonant */
name|word
operator|.
name|setLength
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|k
operator|--
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|k
operator|++
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
name|word
operator|.
name|charAt
argument_list|(
name|k
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|word
operator|.
name|setLength
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
comment|/* try removing -a/ible and adding -e */
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|word
operator|.
name|append
argument_list|(
literal|"ate"
argument_list|)
expr_stmt|;
comment|/* try removing -able and adding -ate */
comment|/* (e.g., compensable/compensate) */
name|k
operator|=
name|j
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
name|word_char
argument_list|)
expr_stmt|;
comment|/* restore the original values */
name|word
operator|.
name|append
argument_list|(
literal|"ble"
argument_list|)
expr_stmt|;
name|k
operator|=
name|old_k
expr_stmt|;
comment|// nolookup()
block|}
return|return;
block|}
comment|/*    * handle -ic endings. This is fairly straightforward, but this is also the    * only place we try *expanding* an ending, -ic -> -ical. This is to handle    * cases like `canonic' -> `canonical'    */
DECL|method|icEndings
specifier|private
name|void
name|icEndings
parameter_list|()
block|{
if|if
condition|(
name|endsIn
argument_list|(
literal|'i'
argument_list|,
literal|'c'
argument_list|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|3
argument_list|)
expr_stmt|;
name|word
operator|.
name|append
argument_list|(
literal|"al"
argument_list|)
expr_stmt|;
comment|/* try converting -ic to -ical */
name|k
operator|=
name|j
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setCharAt
argument_list|(
name|j
operator|+
literal|1
argument_list|,
literal|'y'
argument_list|)
expr_stmt|;
comment|/* try converting -ic to -y */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|2
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setCharAt
argument_list|(
name|j
operator|+
literal|1
argument_list|,
literal|'e'
argument_list|)
expr_stmt|;
comment|/* try converting -ic to -e */
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* try removing -ic altogether */
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|append
argument_list|(
literal|"ic"
argument_list|)
expr_stmt|;
comment|/* restore the original ending */
name|k
operator|=
name|j
operator|+
literal|2
expr_stmt|;
comment|// nolookup()
block|}
return|return;
block|}
DECL|field|ization
specifier|private
specifier|static
name|char
index|[]
name|ization
init|=
literal|"ization"
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
DECL|field|ition
specifier|private
specifier|static
name|char
index|[]
name|ition
init|=
literal|"ition"
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
DECL|field|ation
specifier|private
specifier|static
name|char
index|[]
name|ation
init|=
literal|"ation"
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
DECL|field|ication
specifier|private
specifier|static
name|char
index|[]
name|ication
init|=
literal|"ication"
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
comment|/* handle some derivational endings */
comment|/*    * this routine deals with -ion, -ition, -ation, -ization, and -ication. The    * -ization ending is always converted to -ize    */
DECL|method|ionEndings
specifier|private
name|void
name|ionEndings
parameter_list|()
block|{
name|int
name|old_k
init|=
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|endsIn
argument_list|(
literal|'i'
argument_list|,
literal|'o'
argument_list|,
literal|'n'
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|endsIn
argument_list|(
name|ization
argument_list|)
condition|)
block|{
comment|/*                             * the -ize ending is very productive, so simply                             * accept it as the root                             */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|3
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|+
literal|3
expr_stmt|;
name|lookup
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|endsIn
argument_list|(
name|ition
argument_list|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
comment|/*                      * remove -ition and add `e', and check against the                      * dictionary                      */
return|return;
comment|/* (e.g., definition->define, opposition->oppose) */
comment|/* restore original values */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|append
argument_list|(
literal|"ition"
argument_list|)
expr_stmt|;
name|k
operator|=
name|old_k
expr_stmt|;
comment|// nolookup()
block|}
elseif|else
if|if
condition|(
name|endsIn
argument_list|(
name|ation
argument_list|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|3
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
comment|/* remove -ion and add `e', and check against the dictionary */
return|return;
comment|/* (elmination -> eliminate) */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
comment|/*                               * remove -ation and add `e', and check against the                               * dictionary                               */
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*                              * just remove -ation (resignation->resign) and                              * check dictionary                              */
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
comment|/* restore original values */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|append
argument_list|(
literal|"ation"
argument_list|)
expr_stmt|;
name|k
operator|=
name|old_k
expr_stmt|;
comment|// nolookup()
block|}
comment|/*      * test -ication after -ation is attempted (e.g., `complication->complicate'      * rather than `complication->comply')      */
if|if
condition|(
name|endsIn
argument_list|(
name|ication
argument_list|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'y'
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
comment|/*                      * remove -ication and add `y', and check against the                      * dictionary                      */
return|return;
comment|/* (e.g., amplification -> amplify) */
comment|/* restore original values */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|append
argument_list|(
literal|"ication"
argument_list|)
expr_stmt|;
name|k
operator|=
name|old_k
expr_stmt|;
comment|// nolookup()
block|}
comment|// if (endsIn(ion)) {
if|if
condition|(
literal|true
condition|)
block|{
comment|// we checked for this earlier... just need to set "j"
name|j
operator|=
name|k
operator|-
literal|3
expr_stmt|;
comment|// YCS
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
comment|/* remove -ion and add `e', and check against the dictionary */
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
comment|/* remove -ion, and if it's found, treat that as the root */
return|return;
comment|/* restore original values */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|append
argument_list|(
literal|"ion"
argument_list|)
expr_stmt|;
name|k
operator|=
name|old_k
expr_stmt|;
comment|// nolookup()
block|}
comment|// nolookup(); all of the other paths restored original values
return|return;
block|}
comment|/*    * this routine deals with -er, -or, -ier, and -eer. The -izer ending is    * always converted to -ize    */
DECL|method|erAndOrEndings
specifier|private
name|void
name|erAndOrEndings
parameter_list|()
block|{
name|int
name|old_k
init|=
name|k
decl_stmt|;
if|if
condition|(
name|word
operator|.
name|charAt
argument_list|(
name|k
argument_list|)
operator|!=
literal|'r'
condition|)
return|return;
comment|// YCS
name|char
name|word_char
decl_stmt|;
comment|/* so we can remember if it was -er or -or */
if|if
condition|(
name|endsIn
argument_list|(
literal|'i'
argument_list|,
literal|'z'
argument_list|,
literal|'e'
argument_list|,
literal|'r'
argument_list|)
condition|)
block|{
comment|/*                                        * -ize is very productive, so accept it                                        * as the root                                        */
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|4
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|+
literal|3
expr_stmt|;
name|lookup
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|endsIn
argument_list|(
literal|'e'
argument_list|,
literal|'r'
argument_list|)
operator|||
name|endsIn
argument_list|(
literal|'o'
argument_list|,
literal|'r'
argument_list|)
condition|)
block|{
name|word_char
operator|=
name|word
operator|.
name|charAt
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|doubleC
argument_list|(
name|j
argument_list|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|unsafeWrite
argument_list|(
name|word
operator|.
name|charAt
argument_list|(
name|j
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restore the doubled consonant */
block|}
if|if
condition|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* do we have a -ier ending? */
name|word
operator|.
name|setCharAt
argument_list|(
name|j
argument_list|,
literal|'y'
argument_list|)
expr_stmt|;
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
comment|/* yes, so check against the dictionary */
return|return;
name|word
operator|.
name|setCharAt
argument_list|(
name|j
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
comment|/* restore the endings */
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'e'
condition|)
block|{
comment|/* handle -eer */
name|word
operator|.
name|setLength
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
block|}
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* remove the -r ending */
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* try removing -er/-or */
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
comment|/* try removing -or and adding -e */
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
name|word_char
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
comment|/* restore the word to the way it was */
name|k
operator|=
name|old_k
expr_stmt|;
comment|// nolookup()
block|}
block|}
comment|/*    * this routine deals with -ly endings. The -ally ending is always converted    * to -al Sometimes this will temporarily leave us with a non-word (e.g.,    * heuristically maps to heuristical), but then the -al is removed in the next    * step.    */
DECL|method|lyEndings
specifier|private
name|void
name|lyEndings
parameter_list|()
block|{
name|int
name|old_k
init|=
name|k
decl_stmt|;
if|if
condition|(
name|endsIn
argument_list|(
literal|'l'
argument_list|,
literal|'y'
argument_list|)
condition|)
block|{
name|word
operator|.
name|setCharAt
argument_list|(
name|j
operator|+
literal|2
argument_list|,
literal|'e'
argument_list|)
expr_stmt|;
comment|/* try converting -ly to -le */
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setCharAt
argument_list|(
name|j
operator|+
literal|2
argument_list|,
literal|'y'
argument_list|)
expr_stmt|;
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* try just removing the -ly */
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|(
name|j
operator|>
literal|0
operator|)
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
operator|-
literal|1
argument_list|)
operator|==
literal|'a'
operator|)
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'l'
operator|)
condition|)
comment|/*                                                                               * always                                                                               * convert                                                                               * -                                                                               * ally                                                                               * to                                                                               * -                                                                               * al                                                                               */
return|return;
name|word
operator|.
name|append
argument_list|(
literal|"ly"
argument_list|)
expr_stmt|;
name|k
operator|=
name|old_k
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|>
literal|0
operator|)
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
operator|-
literal|1
argument_list|)
operator|==
literal|'a'
operator|)
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'b'
operator|)
condition|)
block|{
comment|/*                                                                                 * always                                                                                 * convert                                                                                 * -                                                                                 * ably                                                                                 * to                                                                                 * -                                                                                 * able                                                                                 */
name|word
operator|.
name|setCharAt
argument_list|(
name|j
operator|+
literal|2
argument_list|,
literal|'e'
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|+
literal|2
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* e.g., militarily -> military */
name|word
operator|.
name|setLength
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'y'
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|word
operator|.
name|append
argument_list|(
literal|"ily"
argument_list|)
expr_stmt|;
name|k
operator|=
name|old_k
expr_stmt|;
block|}
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* the default is to remove -ly */
name|k
operator|=
name|j
expr_stmt|;
comment|// nolookup()... we already tried removing the "ly" variant
block|}
return|return;
block|}
comment|/*    * this routine deals with -al endings. Some of the endings from the previous    * routine are finished up here.    */
DECL|method|alEndings
specifier|private
name|void
name|alEndings
parameter_list|()
block|{
name|int
name|old_k
init|=
name|k
decl_stmt|;
if|if
condition|(
name|word
operator|.
name|length
argument_list|()
operator|<
literal|4
condition|)
return|return;
if|if
condition|(
name|endsIn
argument_list|(
literal|'a'
argument_list|,
literal|'l'
argument_list|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
comment|/* try just removing the -al */
return|return;
if|if
condition|(
name|doubleC
argument_list|(
name|j
argument_list|)
condition|)
block|{
comment|/* allow for a doubled consonant */
name|word
operator|.
name|setLength
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|unsafeWrite
argument_list|(
name|word
operator|.
name|charAt
argument_list|(
name|j
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
comment|/* try removing the -al and adding -e */
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|append
argument_list|(
literal|"um"
argument_list|)
expr_stmt|;
comment|/* try converting -al to -um */
comment|/* (e.g., optimal -> optimum ) */
name|k
operator|=
name|j
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|append
argument_list|(
literal|"al"
argument_list|)
expr_stmt|;
comment|/* restore the ending to the way it was */
name|k
operator|=
name|old_k
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|>
literal|0
operator|)
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
operator|-
literal|1
argument_list|)
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'c'
operator|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* try removing -ical */
name|k
operator|=
name|j
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|-
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'y'
argument_list|)
expr_stmt|;
comment|/* try turning -ical to -y (e.g., bibliographical) */
name|k
operator|=
name|j
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|-
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|append
argument_list|(
literal|"ic"
argument_list|)
expr_stmt|;
comment|/* the default is to convert -ical to -ic */
name|k
operator|=
name|j
expr_stmt|;
comment|// nolookup() ... converting ical to ic means removing "al" which we
comment|// already tried
comment|// ERROR
name|lookup
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* sometimes -ial endings should be removed */
name|word
operator|.
name|setLength
argument_list|(
name|j
argument_list|)
expr_stmt|;
comment|/* (sometimes it gets turned into -y, but we */
name|k
operator|=
name|j
operator|-
literal|1
expr_stmt|;
comment|/* aren't dealing with that case for now) */
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|append
argument_list|(
literal|"ial"
argument_list|)
expr_stmt|;
name|k
operator|=
name|old_k
expr_stmt|;
name|lookup
argument_list|()
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/*    * this routine deals with -ive endings. It normalizes some of the -ative    * endings directly, and also maps some -ive endings to -ion.    */
DECL|method|iveEndings
specifier|private
name|void
name|iveEndings
parameter_list|()
block|{
name|int
name|old_k
init|=
name|k
decl_stmt|;
if|if
condition|(
name|endsIn
argument_list|(
literal|'i'
argument_list|,
literal|'v'
argument_list|,
literal|'e'
argument_list|)
condition|)
block|{
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* try removing -ive entirely */
name|k
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|unsafeWrite
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
comment|/* try removing -ive and adding -e */
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
operator|.
name|append
argument_list|(
literal|"ive"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|>
literal|0
operator|)
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
operator|-
literal|1
argument_list|)
operator|==
literal|'a'
operator|)
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
operator|==
literal|'t'
operator|)
condition|)
block|{
name|word
operator|.
name|setCharAt
argument_list|(
name|j
operator|-
literal|1
argument_list|,
literal|'e'
argument_list|)
expr_stmt|;
comment|/* try removing -ative and adding -e */
name|word
operator|.
name|setLength
argument_list|(
name|j
argument_list|)
expr_stmt|;
comment|/* (e.g., determinative -> determine) */
name|k
operator|=
name|j
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setLength
argument_list|(
name|j
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* try just removing -ative */
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|append
argument_list|(
literal|"ative"
argument_list|)
expr_stmt|;
name|k
operator|=
name|old_k
expr_stmt|;
block|}
comment|/* try mapping -ive to -ion (e.g., injunctive/injunction) */
name|word
operator|.
name|setCharAt
argument_list|(
name|j
operator|+
literal|2
argument_list|,
literal|'o'
argument_list|)
expr_stmt|;
name|word
operator|.
name|setCharAt
argument_list|(
name|j
operator|+
literal|3
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|()
condition|)
return|return;
name|word
operator|.
name|setCharAt
argument_list|(
name|j
operator|+
literal|2
argument_list|,
literal|'v'
argument_list|)
expr_stmt|;
comment|/* restore the original values */
name|word
operator|.
name|setCharAt
argument_list|(
name|j
operator|+
literal|3
argument_list|,
literal|'e'
argument_list|)
expr_stmt|;
name|k
operator|=
name|old_k
expr_stmt|;
comment|// nolookup()
block|}
return|return;
block|}
DECL|method|KStemmer
name|KStemmer
parameter_list|()
block|{}
DECL|method|stem
name|String
name|stem
parameter_list|(
name|String
name|term
parameter_list|)
block|{
name|boolean
name|changed
init|=
name|stem
argument_list|(
name|term
operator|.
name|toCharArray
argument_list|()
argument_list|,
name|term
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changed
condition|)
return|return
name|term
return|;
return|return
name|asString
argument_list|()
return|;
block|}
comment|/**    * Returns the result of the stem (assuming the word was changed) as a String.    */
DECL|method|asString
name|String
name|asString
parameter_list|()
block|{
name|String
name|s
init|=
name|getString
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
return|return
name|s
return|;
return|return
name|word
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|asCharSequence
name|CharSequence
name|asCharSequence
parameter_list|()
block|{
return|return
name|result
operator|!=
literal|null
condition|?
name|result
else|:
name|word
return|;
block|}
DECL|method|getString
name|String
name|getString
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|getChars
name|char
index|[]
name|getChars
parameter_list|()
block|{
return|return
name|word
operator|.
name|getArray
argument_list|()
return|;
block|}
DECL|method|getLength
name|int
name|getLength
parameter_list|()
block|{
return|return
name|word
operator|.
name|length
argument_list|()
return|;
block|}
DECL|field|result
name|String
name|result
decl_stmt|;
DECL|method|matched
specifier|private
name|boolean
name|matched
parameter_list|()
block|{
comment|/***      * if (!lookups.contains(word.toString())) { throw new      * RuntimeException("didn't look up "+word.toString()+" prev="+prevLookup);      * }      ***/
comment|// lookup();
return|return
name|matchedEntry
operator|!=
literal|null
return|;
block|}
comment|/**    * Stems the text in the token. Returns true if changed.    */
DECL|method|stem
name|boolean
name|stem
parameter_list|(
name|char
index|[]
name|term
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|result
operator|=
literal|null
expr_stmt|;
name|k
operator|=
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|<=
literal|1
operator|)
operator|||
operator|(
name|k
operator|>=
name|MaxWordLen
operator|-
literal|1
operator|)
condition|)
block|{
return|return
literal|false
return|;
comment|// don't stem
block|}
comment|// first check the stemmer dictionaries, and avoid using the
comment|// cache if it's in there.
name|DictEntry
name|entry
init|=
name|dict_ht
operator|.
name|get
argument_list|(
name|term
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|entry
operator|.
name|root
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|entry
operator|.
name|root
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/***      * caching off is normally faster if (cache == null) initializeStemHash();      *       * // now check the cache, before we copy chars to "word" if (cache != null)      * { String val = cache.get(term, 0, len); if (val != null) { if (val !=      * SAME) { result = val; return true; } return false; } }      ***/
name|word
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// allocate enough space so that an expansion is never needed
name|word
operator|.
name|reserve
argument_list|(
name|len
operator|+
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
init|=
name|term
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isAlpha
argument_list|(
name|ch
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// don't stem
comment|// don't lowercase... it's a requirement that lowercase filter be
comment|// used before this stemmer.
name|word
operator|.
name|unsafeWrite
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|matchedEntry
operator|=
literal|null
expr_stmt|;
comment|/***      * lookups.clear(); lookups.add(word.toString());      ***/
comment|/*      * This while loop will never be executed more than one time; it is here      * only to allow the break statement to be used to escape as soon as a word      * is recognized      */
while|while
condition|(
literal|true
condition|)
block|{
comment|// YCS: extra lookup()s were inserted so we don't need to
comment|// do an extra wordInDict() here.
name|plural
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
argument_list|()
condition|)
break|break;
name|pastTense
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
argument_list|()
condition|)
break|break;
name|aspect
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
argument_list|()
condition|)
break|break;
name|ityEndings
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
argument_list|()
condition|)
break|break;
name|nessEndings
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
argument_list|()
condition|)
break|break;
name|ionEndings
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
argument_list|()
condition|)
break|break;
name|erAndOrEndings
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
argument_list|()
condition|)
break|break;
name|lyEndings
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
argument_list|()
condition|)
break|break;
name|alEndings
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
argument_list|()
condition|)
break|break;
name|entry
operator|=
name|wordInDict
argument_list|()
expr_stmt|;
name|iveEndings
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
argument_list|()
condition|)
break|break;
name|izeEndings
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
argument_list|()
condition|)
break|break;
name|mentEndings
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
argument_list|()
condition|)
break|break;
name|bleEndings
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
argument_list|()
condition|)
break|break;
name|ismEndings
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
argument_list|()
condition|)
break|break;
name|icEndings
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
argument_list|()
condition|)
break|break;
name|ncyEndings
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
argument_list|()
condition|)
break|break;
name|nceEndings
argument_list|()
expr_stmt|;
name|matched
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/*      * try for a direct mapping (allows for cases like `Italian'->`Italy' and      * `Italians'->`Italy')      */
name|entry
operator|=
name|matchedEntry
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|entry
operator|.
name|root
expr_stmt|;
comment|// may be null, which means that "word" is the stem
block|}
comment|/***      * caching off is normally faster if (cache != null&& cache.size()<      * maxCacheSize) { char[] key = new char[len]; System.arraycopy(term, 0,      * key, 0, len); if (result != null) { cache.put(key, result); } else {      * cache.put(key, word.toString()); } }      ***/
comment|/***      * if (entry == null) { if (!word.toString().equals(new String(term,0,len)))      * { System.out.println("CASE:" + word.toString() + "," + new      * String(term,0,len));      *       * } }      ***/
comment|// no entry matched means result is "word"
return|return
literal|true
return|;
block|}
block|}
end_class
end_unit
