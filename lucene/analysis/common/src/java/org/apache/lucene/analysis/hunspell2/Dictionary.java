begin_unit
begin_package
DECL|package|org.apache.lucene.analysis.hunspell2
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|hunspell2
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|CharArrayMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefHash
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|UnicodeUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Builder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FST
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|PositiveIntOutputs
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharsetDecoder
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CodingErrorAction
import|;
end_import
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_comment
comment|/**  * In-memory structure for the dictionary (.dic) and affix (.aff)  * data of a hunspell dictionary.  */
end_comment
begin_class
DECL|class|Dictionary
specifier|public
class|class
name|Dictionary
block|{
DECL|field|NOFLAGS
specifier|static
specifier|final
name|char
index|[]
name|NOFLAGS
init|=
operator|new
name|char
index|[
literal|0
index|]
decl_stmt|;
DECL|field|ALIAS_KEY
specifier|private
specifier|static
specifier|final
name|String
name|ALIAS_KEY
init|=
literal|"AF"
decl_stmt|;
DECL|field|PREFIX_KEY
specifier|private
specifier|static
specifier|final
name|String
name|PREFIX_KEY
init|=
literal|"PFX"
decl_stmt|;
DECL|field|SUFFIX_KEY
specifier|private
specifier|static
specifier|final
name|String
name|SUFFIX_KEY
init|=
literal|"SFX"
decl_stmt|;
DECL|field|FLAG_KEY
specifier|private
specifier|static
specifier|final
name|String
name|FLAG_KEY
init|=
literal|"FLAG"
decl_stmt|;
DECL|field|NUM_FLAG_TYPE
specifier|private
specifier|static
specifier|final
name|String
name|NUM_FLAG_TYPE
init|=
literal|"num"
decl_stmt|;
DECL|field|UTF8_FLAG_TYPE
specifier|private
specifier|static
specifier|final
name|String
name|UTF8_FLAG_TYPE
init|=
literal|"UTF-8"
decl_stmt|;
DECL|field|LONG_FLAG_TYPE
specifier|private
specifier|static
specifier|final
name|String
name|LONG_FLAG_TYPE
init|=
literal|"long"
decl_stmt|;
DECL|field|PREFIX_CONDITION_REGEX_PATTERN
specifier|private
specifier|static
specifier|final
name|String
name|PREFIX_CONDITION_REGEX_PATTERN
init|=
literal|"%s.*"
decl_stmt|;
DECL|field|SUFFIX_CONDITION_REGEX_PATTERN
specifier|private
specifier|static
specifier|final
name|String
name|SUFFIX_CONDITION_REGEX_PATTERN
init|=
literal|".*%s"
decl_stmt|;
DECL|field|prefixes
specifier|public
name|CharArrayMap
argument_list|<
name|List
argument_list|<
name|Affix
argument_list|>
argument_list|>
name|prefixes
decl_stmt|;
DECL|field|suffixes
specifier|public
name|CharArrayMap
argument_list|<
name|List
argument_list|<
name|Affix
argument_list|>
argument_list|>
name|suffixes
decl_stmt|;
comment|// the entries in the .dic file, mapping to their set of flags.
comment|// the fst output is the ordinal for flagLookup
DECL|field|words
specifier|public
name|FST
argument_list|<
name|Long
argument_list|>
name|words
decl_stmt|;
comment|// the list of unique flagsets (wordforms). theoretically huge, but practically
comment|// small (e.g. for polish this is 756), otherwise humans wouldn't be able to deal with it either.
DECL|field|flagLookup
specifier|public
name|BytesRefHash
name|flagLookup
init|=
operator|new
name|BytesRefHash
argument_list|()
decl_stmt|;
DECL|field|flagParsingStrategy
specifier|private
name|FlagParsingStrategy
name|flagParsingStrategy
init|=
operator|new
name|SimpleFlagParsingStrategy
argument_list|()
decl_stmt|;
comment|// Default flag parsing strategy
DECL|field|aliases
specifier|private
name|String
index|[]
name|aliases
decl_stmt|;
DECL|field|aliasCount
specifier|private
name|int
name|aliasCount
init|=
literal|0
decl_stmt|;
comment|/**    * Creates a new Dictionary containing the information read from the provided InputStreams to hunspell affix    * and dictionary files.    * You have to close the provided InputStreams yourself.    *    * @param affix InputStream for reading the hunspell affix file (won't be closed).    * @param dictionary InputStream for reading the hunspell dictionary file (won't be closed).    * @throws IOException Can be thrown while reading from the InputStreams    * @throws ParseException Can be thrown if the content of the files does not meet expected formats    */
DECL|method|Dictionary
specifier|public
name|Dictionary
parameter_list|(
name|InputStream
name|affix
parameter_list|,
name|InputStream
name|dictionary
parameter_list|)
throws|throws
name|IOException
throws|,
name|ParseException
block|{
name|BufferedInputStream
name|buffered
init|=
operator|new
name|BufferedInputStream
argument_list|(
name|affix
argument_list|,
literal|8192
argument_list|)
decl_stmt|;
name|buffered
operator|.
name|mark
argument_list|(
literal|8192
argument_list|)
expr_stmt|;
name|String
name|encoding
init|=
name|getDictionaryEncoding
argument_list|(
name|affix
argument_list|)
decl_stmt|;
name|buffered
operator|.
name|reset
argument_list|()
expr_stmt|;
name|CharsetDecoder
name|decoder
init|=
name|getJavaEncoding
argument_list|(
name|encoding
argument_list|)
decl_stmt|;
name|readAffixFile
argument_list|(
name|buffered
argument_list|,
name|decoder
argument_list|)
expr_stmt|;
name|flagLookup
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|()
argument_list|)
expr_stmt|;
comment|// no flags -> ord 0
name|PositiveIntOutputs
name|o
init|=
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
name|Builder
argument_list|<
name|Long
argument_list|>
name|b
init|=
operator|new
name|Builder
argument_list|<
name|Long
argument_list|>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE4
argument_list|,
name|o
argument_list|)
decl_stmt|;
name|readDictionaryFile
argument_list|(
name|dictionary
argument_list|,
name|decoder
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|words
operator|=
name|b
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
comment|/**    * Looks up words that match the String created from the given char array, offset and length    *    * @param word Char array to generate the String from    * @param offset Offset in the char array that the String starts at    * @param length Length from the offset that the String is    * @return List of HunspellWords that match the generated String, or {@code null} if none are found    */
DECL|method|lookupWord
name|char
index|[]
name|lookupWord
parameter_list|(
name|char
name|word
index|[]
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|BytesRef
name|scratch
parameter_list|)
block|{
name|Integer
name|ord
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ord
operator|=
name|lookupOrd
argument_list|(
name|word
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|/* bogus */
block|}
if|if
condition|(
name|ord
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|decodeFlags
argument_list|(
name|flagLookup
operator|.
name|get
argument_list|(
name|ord
argument_list|,
name|scratch
argument_list|)
argument_list|)
return|;
block|}
DECL|method|lookupOrd
specifier|public
name|Integer
name|lookupOrd
parameter_list|(
name|char
name|word
index|[]
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FST
operator|.
name|BytesReader
name|bytesReader
init|=
name|words
operator|.
name|getBytesReader
argument_list|()
decl_stmt|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|Long
argument_list|>
name|arc
init|=
name|words
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|Long
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|// Accumulate output as we go
specifier|final
name|Long
name|NO_OUTPUT
init|=
name|words
operator|.
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
name|Long
name|output
init|=
name|NO_OUTPUT
decl_stmt|;
name|int
name|l
init|=
name|offset
operator|+
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|offset
init|,
name|cp
init|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|cp
argument_list|)
control|)
block|{
name|cp
operator|=
name|Character
operator|.
name|codePointAt
argument_list|(
name|word
argument_list|,
name|i
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|.
name|findTargetArc
argument_list|(
name|cp
argument_list|,
name|arc
argument_list|,
name|arc
argument_list|,
name|bytesReader
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
name|output
operator|=
name|words
operator|.
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|words
operator|.
name|findTargetArc
argument_list|(
name|FST
operator|.
name|END_LABEL
argument_list|,
name|arc
argument_list|,
name|arc
argument_list|,
name|bytesReader
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|arc
operator|.
name|output
operator|!=
name|NO_OUTPUT
condition|)
block|{
return|return
name|words
operator|.
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
operator|.
name|intValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|output
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
comment|/**    * Looks up HunspellAffix prefixes that have an append that matches the String created from the given char array, offset and length    *    * @param word Char array to generate the String from    * @param offset Offset in the char array that the String starts at    * @param length Length from the offset that the String is    * @return List of HunspellAffix prefixes with an append that matches the String, or {@code null} if none are found    */
DECL|method|lookupPrefix
specifier|public
name|List
argument_list|<
name|Affix
argument_list|>
name|lookupPrefix
parameter_list|(
name|char
name|word
index|[]
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|prefixes
operator|.
name|get
argument_list|(
name|word
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|/**    * Looks up HunspellAffix suffixes that have an append that matches the String created from the given char array, offset and length    *    * @param word Char array to generate the String from    * @param offset Offset in the char array that the String starts at    * @param length Length from the offset that the String is    * @return List of HunspellAffix suffixes with an append that matches the String, or {@code null} if none are found    */
DECL|method|lookupSuffix
name|List
argument_list|<
name|Affix
argument_list|>
name|lookupSuffix
parameter_list|(
name|char
name|word
index|[]
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|suffixes
operator|.
name|get
argument_list|(
name|word
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|/**    * Reads the affix file through the provided InputStream, building up the prefix and suffix maps    *    * @param affixStream InputStream to read the content of the affix file from    * @param decoder CharsetDecoder to decode the content of the file    * @throws IOException Can be thrown while reading from the InputStream    */
DECL|method|readAffixFile
specifier|private
name|void
name|readAffixFile
parameter_list|(
name|InputStream
name|affixStream
parameter_list|,
name|CharsetDecoder
name|decoder
parameter_list|)
throws|throws
name|IOException
throws|,
name|ParseException
block|{
name|prefixes
operator|=
operator|new
name|CharArrayMap
argument_list|<
name|List
argument_list|<
name|Affix
argument_list|>
argument_list|>
argument_list|(
name|Version
operator|.
name|LUCENE_CURRENT
argument_list|,
literal|8
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|suffixes
operator|=
operator|new
name|CharArrayMap
argument_list|<
name|List
argument_list|<
name|Affix
argument_list|>
argument_list|>
argument_list|(
name|Version
operator|.
name|LUCENE_CURRENT
argument_list|,
literal|8
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|LineNumberReader
name|reader
init|=
operator|new
name|LineNumberReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|affixStream
argument_list|,
name|decoder
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|line
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|ALIAS_KEY
argument_list|)
condition|)
block|{
name|parseAlias
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|PREFIX_KEY
argument_list|)
condition|)
block|{
name|parseAffix
argument_list|(
name|prefixes
argument_list|,
name|line
argument_list|,
name|reader
argument_list|,
name|PREFIX_CONDITION_REGEX_PATTERN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|SUFFIX_KEY
argument_list|)
condition|)
block|{
name|parseAffix
argument_list|(
name|suffixes
argument_list|,
name|line
argument_list|,
name|reader
argument_list|,
name|SUFFIX_CONDITION_REGEX_PATTERN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|FLAG_KEY
argument_list|)
condition|)
block|{
comment|// Assume that the FLAG line comes before any prefix or suffixes
comment|// Store the strategy so it can be used when parsing the dic file
name|flagParsingStrategy
operator|=
name|getFlagParsingStrategy
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Parses a specific affix rule putting the result into the provided affix map    *     * @param affixes Map where the result of the parsing will be put    * @param header Header line of the affix rule    * @param reader BufferedReader to read the content of the rule from    * @param conditionPattern {@link String#format(String, Object...)} pattern to be used to generate the condition regex    *                         pattern    * @throws IOException Can be thrown while reading the rule    */
DECL|method|parseAffix
specifier|private
name|void
name|parseAffix
parameter_list|(
name|CharArrayMap
argument_list|<
name|List
argument_list|<
name|Affix
argument_list|>
argument_list|>
name|affixes
parameter_list|,
name|String
name|header
parameter_list|,
name|LineNumberReader
name|reader
parameter_list|,
name|String
name|conditionPattern
parameter_list|)
throws|throws
name|IOException
throws|,
name|ParseException
block|{
name|String
name|args
index|[]
init|=
name|header
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
name|boolean
name|crossProduct
init|=
name|args
index|[
literal|2
index|]
operator|.
name|equals
argument_list|(
literal|"Y"
argument_list|)
decl_stmt|;
name|int
name|numLines
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numLines
condition|;
name|i
operator|++
control|)
block|{
name|String
name|line
init|=
name|reader
operator|.
name|readLine
argument_list|()
decl_stmt|;
name|String
name|ruleArgs
index|[]
init|=
name|line
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
if|if
condition|(
name|ruleArgs
operator|.
name|length
operator|<
literal|5
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"The affix file contains a rule with less than five elements"
argument_list|,
name|reader
operator|.
name|getLineNumber
argument_list|()
argument_list|)
throw|;
block|}
name|Affix
name|affix
init|=
operator|new
name|Affix
argument_list|()
decl_stmt|;
name|affix
operator|.
name|setFlag
argument_list|(
name|flagParsingStrategy
operator|.
name|parseFlag
argument_list|(
name|ruleArgs
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|affix
operator|.
name|setStrip
argument_list|(
name|ruleArgs
index|[
literal|2
index|]
operator|.
name|equals
argument_list|(
literal|"0"
argument_list|)
condition|?
literal|""
else|:
name|ruleArgs
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|String
name|affixArg
init|=
name|ruleArgs
index|[
literal|3
index|]
decl_stmt|;
name|int
name|flagSep
init|=
name|affixArg
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|flagSep
operator|!=
operator|-
literal|1
condition|)
block|{
name|String
name|flagPart
init|=
name|affixArg
operator|.
name|substring
argument_list|(
name|flagSep
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|aliasCount
operator|>
literal|0
condition|)
block|{
name|flagPart
operator|=
name|getAliasValue
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|flagPart
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|char
name|appendFlags
index|[]
init|=
name|flagParsingStrategy
operator|.
name|parseFlags
argument_list|(
name|flagPart
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|appendFlags
argument_list|)
expr_stmt|;
name|affix
operator|.
name|setAppendFlags
argument_list|(
name|appendFlags
argument_list|)
expr_stmt|;
name|affix
operator|.
name|setAppend
argument_list|(
name|affixArg
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|flagSep
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|affix
operator|.
name|setAppend
argument_list|(
name|affixArg
argument_list|)
expr_stmt|;
block|}
name|String
name|condition
init|=
name|ruleArgs
index|[
literal|4
index|]
decl_stmt|;
comment|// at least the gascon affix file has this issue
if|if
condition|(
name|condition
operator|.
name|startsWith
argument_list|(
literal|"["
argument_list|)
operator|&&
operator|!
name|condition
operator|.
name|endsWith
argument_list|(
literal|"]"
argument_list|)
condition|)
block|{
name|condition
operator|=
name|condition
operator|+
literal|"]"
expr_stmt|;
block|}
comment|// "dash hasn't got special meaning" (we must escape it)
if|if
condition|(
name|condition
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|condition
operator|=
name|condition
operator|.
name|replace
argument_list|(
literal|"-"
argument_list|,
literal|"\\-"
argument_list|)
expr_stmt|;
block|}
name|affix
operator|.
name|setCondition
argument_list|(
name|condition
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
name|conditionPattern
argument_list|,
name|condition
argument_list|)
argument_list|)
expr_stmt|;
name|affix
operator|.
name|setCrossProduct
argument_list|(
name|crossProduct
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Affix
argument_list|>
name|list
init|=
name|affixes
operator|.
name|get
argument_list|(
name|affix
operator|.
name|getAppend
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
name|list
operator|=
operator|new
name|ArrayList
argument_list|<
name|Affix
argument_list|>
argument_list|()
expr_stmt|;
name|affixes
operator|.
name|put
argument_list|(
name|affix
operator|.
name|getAppend
argument_list|()
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|affix
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Parses the encoding specified in the affix file readable through the provided InputStream    *    * @param affix InputStream for reading the affix file    * @return Encoding specified in the affix file    * @throws IOException Can be thrown while reading from the InputStream    * @throws ParseException Thrown if the first non-empty non-comment line read from the file does not adhere to the format {@code SET<encoding>}    */
DECL|method|getDictionaryEncoding
specifier|private
name|String
name|getDictionaryEncoding
parameter_list|(
name|InputStream
name|affix
parameter_list|)
throws|throws
name|IOException
throws|,
name|ParseException
block|{
specifier|final
name|StringBuilder
name|encoding
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|encoding
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|affix
operator|.
name|read
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ch
operator|!=
literal|'\r'
condition|)
block|{
name|encoding
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|encoding
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|||
name|encoding
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'#'
operator|||
comment|// this test only at the end as ineffective but would allow lines only containing spaces:
name|encoding
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Unexpected end of affix file."
argument_list|,
literal|0
argument_list|)
throw|;
block|}
continue|continue;
block|}
if|if
condition|(
name|encoding
operator|.
name|length
argument_list|()
operator|>
literal|4
operator|&&
literal|"SET "
operator|.
name|equals
argument_list|(
name|encoding
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
argument_list|)
condition|)
block|{
comment|// cleanup the encoding string, too (whitespace)
return|return
name|encoding
operator|.
name|substring
argument_list|(
literal|4
argument_list|)
operator|.
name|trim
argument_list|()
return|;
block|}
block|}
block|}
DECL|field|CHARSET_ALIASES
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|CHARSET_ALIASES
decl_stmt|;
static|static
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|m
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"microsoft-cp1251"
argument_list|,
literal|"windows-1251"
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"TIS620-2533"
argument_list|,
literal|"TIS-620"
argument_list|)
expr_stmt|;
name|CHARSET_ALIASES
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/**    * Retrieves the CharsetDecoder for the given encoding.  Note, This isn't perfect as I think ISCII-DEVANAGARI and    * MICROSOFT-CP1251 etc are allowed...    *    * @param encoding Encoding to retrieve the CharsetDecoder for    * @return CharSetDecoder for the given encoding    */
DECL|method|getJavaEncoding
specifier|private
name|CharsetDecoder
name|getJavaEncoding
parameter_list|(
name|String
name|encoding
parameter_list|)
block|{
if|if
condition|(
literal|"ISO8859-14"
operator|.
name|equals
argument_list|(
name|encoding
argument_list|)
condition|)
block|{
return|return
operator|new
name|ISO8859_14Decoder
argument_list|()
return|;
block|}
name|String
name|canon
init|=
name|CHARSET_ALIASES
operator|.
name|get
argument_list|(
name|encoding
argument_list|)
decl_stmt|;
if|if
condition|(
name|canon
operator|!=
literal|null
condition|)
block|{
name|encoding
operator|=
name|canon
expr_stmt|;
block|}
name|Charset
name|charset
init|=
name|Charset
operator|.
name|forName
argument_list|(
name|encoding
argument_list|)
decl_stmt|;
return|return
name|charset
operator|.
name|newDecoder
argument_list|()
operator|.
name|onMalformedInput
argument_list|(
name|CodingErrorAction
operator|.
name|REPLACE
argument_list|)
return|;
block|}
comment|/**    * Determines the appropriate {@link FlagParsingStrategy} based on the FLAG definition line taken from the affix file    *    * @param flagLine Line containing the flag information    * @return FlagParsingStrategy that handles parsing flags in the way specified in the FLAG definition    */
DECL|method|getFlagParsingStrategy
specifier|private
name|FlagParsingStrategy
name|getFlagParsingStrategy
parameter_list|(
name|String
name|flagLine
parameter_list|)
block|{
name|String
name|flagType
init|=
name|flagLine
operator|.
name|substring
argument_list|(
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|NUM_FLAG_TYPE
operator|.
name|equals
argument_list|(
name|flagType
argument_list|)
condition|)
block|{
return|return
operator|new
name|NumFlagParsingStrategy
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|UTF8_FLAG_TYPE
operator|.
name|equals
argument_list|(
name|flagType
argument_list|)
condition|)
block|{
return|return
operator|new
name|SimpleFlagParsingStrategy
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|LONG_FLAG_TYPE
operator|.
name|equals
argument_list|(
name|flagType
argument_list|)
condition|)
block|{
return|return
operator|new
name|DoubleASCIIFlagParsingStrategy
argument_list|()
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown flag type: "
operator|+
name|flagType
argument_list|)
throw|;
block|}
comment|/**    * Reads the dictionary file through the provided InputStream, building up the words map    *    * @param dictionary InputStream to read the dictionary file through    * @param decoder CharsetDecoder used to decode the contents of the file    * @throws IOException Can be thrown while reading from the file    */
DECL|method|readDictionaryFile
specifier|private
name|void
name|readDictionaryFile
parameter_list|(
name|InputStream
name|dictionary
parameter_list|,
name|CharsetDecoder
name|decoder
parameter_list|,
name|Builder
argument_list|<
name|Long
argument_list|>
name|words
parameter_list|)
throws|throws
name|IOException
block|{
name|BytesRef
name|flagsScratch
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|IntsRef
name|scratchInts
init|=
operator|new
name|IntsRef
argument_list|()
decl_stmt|;
name|BufferedReader
name|reader
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|dictionary
argument_list|,
name|decoder
argument_list|)
argument_list|)
decl_stmt|;
comment|// TODO: don't create millions of strings.
name|String
name|line
init|=
name|reader
operator|.
name|readLine
argument_list|()
decl_stmt|;
comment|// first line is number of entries (approximately, sometimes)
comment|// sometimes the number of entries has a comment/copyright after it
name|line
operator|=
name|line
operator|.
name|replaceFirst
argument_list|(
literal|"\\s*\\#.*$"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|int
name|numEntries
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|line
argument_list|)
decl_stmt|;
name|String
name|lines
index|[]
init|=
operator|new
name|String
index|[
name|numEntries
index|]
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|upto
operator|==
name|lines
operator|.
name|length
condition|)
block|{
name|lines
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|lines
argument_list|,
call|(
name|int
call|)
argument_list|(
name|lines
operator|.
name|length
operator|*
literal|1.25
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lines
index|[
name|upto
operator|++
index|]
operator|=
name|line
expr_stmt|;
block|}
comment|// TODO: just replace this with offline sorter?
name|Arrays
operator|.
name|sort
argument_list|(
name|lines
argument_list|,
literal|0
argument_list|,
name|upto
argument_list|,
operator|new
name|Comparator
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|String
name|o1
parameter_list|,
name|String
name|o2
parameter_list|)
block|{
name|int
name|sep1
init|=
name|o1
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|sep1
operator|>=
literal|0
condition|)
block|{
name|o1
operator|=
name|o1
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|sep1
argument_list|)
expr_stmt|;
block|}
name|int
name|sep2
init|=
name|o2
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|sep2
operator|>=
literal|0
condition|)
block|{
name|o2
operator|=
name|o2
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|sep2
argument_list|)
expr_stmt|;
block|}
return|return
name|o1
operator|.
name|compareTo
argument_list|(
name|o2
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// TODO: the flags themselves can be double-chars (long) or also numeric
comment|// either way the trick is to encode them as char... but they must be parsed differently
name|BytesRef
name|currentEntry
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|char
name|currentFlags
index|[]
init|=
operator|new
name|char
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|upto
condition|;
name|i
operator|++
control|)
block|{
name|line
operator|=
name|lines
index|[
name|i
index|]
expr_stmt|;
name|String
name|entry
decl_stmt|;
name|char
name|wordForm
index|[]
decl_stmt|;
name|int
name|flagSep
init|=
name|line
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|flagSep
operator|==
operator|-
literal|1
condition|)
block|{
name|wordForm
operator|=
name|NOFLAGS
expr_stmt|;
name|entry
operator|=
name|line
expr_stmt|;
block|}
else|else
block|{
comment|// note, there can be comments (morph description) after a flag.
comment|// we should really look for any whitespace
name|int
name|end
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'\t'
argument_list|,
name|flagSep
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
operator|-
literal|1
condition|)
name|end
operator|=
name|line
operator|.
name|length
argument_list|()
expr_stmt|;
name|String
name|flagPart
init|=
name|line
operator|.
name|substring
argument_list|(
name|flagSep
operator|+
literal|1
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|aliasCount
operator|>
literal|0
condition|)
block|{
name|flagPart
operator|=
name|getAliasValue
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|flagPart
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|wordForm
operator|=
name|flagParsingStrategy
operator|.
name|parseFlags
argument_list|(
name|flagPart
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|wordForm
argument_list|)
expr_stmt|;
name|entry
operator|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|flagSep
argument_list|)
expr_stmt|;
block|}
name|BytesRef
name|scratch
init|=
operator|new
name|BytesRef
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|int
name|cmp
init|=
name|scratch
operator|.
name|compareTo
argument_list|(
name|currentEntry
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"out of order: "
operator|+
name|scratch
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|"< "
operator|+
name|currentEntry
operator|.
name|utf8ToString
argument_list|()
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|currentFlags
operator|=
name|merge
argument_list|(
name|currentFlags
argument_list|,
name|wordForm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|hashCode
init|=
name|encodeFlagsWithHash
argument_list|(
name|flagsScratch
argument_list|,
name|currentFlags
argument_list|)
decl_stmt|;
name|int
name|ord
init|=
name|flagLookup
operator|.
name|add
argument_list|(
name|flagsScratch
argument_list|,
name|hashCode
argument_list|)
decl_stmt|;
if|if
condition|(
name|ord
operator|<
literal|0
condition|)
block|{
comment|// already exists in our hash
name|ord
operator|=
operator|(
operator|-
name|ord
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|UnicodeUtil
operator|.
name|UTF8toUTF32
argument_list|(
name|currentEntry
argument_list|,
name|scratchInts
argument_list|)
expr_stmt|;
name|words
operator|.
name|add
argument_list|(
name|scratchInts
argument_list|,
operator|(
name|long
operator|)
name|ord
argument_list|)
expr_stmt|;
name|currentEntry
operator|=
name|scratch
expr_stmt|;
name|currentFlags
operator|=
name|wordForm
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|hashCode
init|=
name|encodeFlagsWithHash
argument_list|(
name|flagsScratch
argument_list|,
name|currentFlags
argument_list|)
decl_stmt|;
name|int
name|ord
init|=
name|flagLookup
operator|.
name|add
argument_list|(
name|flagsScratch
argument_list|,
name|hashCode
argument_list|)
decl_stmt|;
if|if
condition|(
name|ord
operator|<
literal|0
condition|)
block|{
comment|// already exists in our hash
name|ord
operator|=
operator|(
operator|-
name|ord
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|UnicodeUtil
operator|.
name|UTF8toUTF32
argument_list|(
name|currentEntry
argument_list|,
name|scratchInts
argument_list|)
expr_stmt|;
name|words
operator|.
name|add
argument_list|(
name|scratchInts
argument_list|,
operator|(
name|long
operator|)
name|ord
argument_list|)
expr_stmt|;
block|}
DECL|method|decodeFlags
specifier|static
name|char
index|[]
name|decodeFlags
parameter_list|(
name|BytesRef
name|b
parameter_list|)
block|{
name|int
name|len
init|=
name|b
operator|.
name|length
operator|>>>
literal|1
decl_stmt|;
name|char
name|flags
index|[]
init|=
operator|new
name|char
index|[
name|len
index|]
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
name|b
operator|.
name|offset
operator|+
name|b
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|b
operator|.
name|offset
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|flags
index|[
name|upto
operator|++
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|b
operator|.
name|bytes
index|[
name|i
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|b
operator|.
name|bytes
index|[
name|i
operator|+
literal|1
index|]
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|flags
return|;
block|}
DECL|method|encodeFlagsWithHash
specifier|static
name|int
name|encodeFlagsWithHash
parameter_list|(
name|BytesRef
name|b
parameter_list|,
name|char
name|flags
index|[]
parameter_list|)
block|{
name|int
name|hash
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
name|flags
operator|.
name|length
operator|<<
literal|1
decl_stmt|;
name|b
operator|.
name|grow
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|b
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|int
name|upto
init|=
name|b
operator|.
name|offset
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|flags
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|flag
init|=
name|flags
index|[
name|i
index|]
decl_stmt|;
name|hash
operator|=
literal|31
operator|*
name|hash
operator|+
operator|(
name|b
operator|.
name|bytes
index|[
name|upto
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|flag
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
operator|)
expr_stmt|;
name|hash
operator|=
literal|31
operator|*
name|hash
operator|+
operator|(
name|b
operator|.
name|bytes
index|[
name|upto
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|flag
operator|&
literal|0xff
argument_list|)
operator|)
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
DECL|method|parseAlias
specifier|private
name|void
name|parseAlias
parameter_list|(
name|String
name|line
parameter_list|)
block|{
name|String
name|ruleArgs
index|[]
init|=
name|line
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
if|if
condition|(
name|aliases
operator|==
literal|null
condition|)
block|{
comment|//first line should be the aliases count
specifier|final
name|int
name|count
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|ruleArgs
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|aliases
operator|=
operator|new
name|String
index|[
name|count
index|]
expr_stmt|;
block|}
else|else
block|{
name|aliases
index|[
name|aliasCount
operator|++
index|]
operator|=
name|ruleArgs
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
DECL|method|getAliasValue
specifier|private
name|String
name|getAliasValue
parameter_list|(
name|int
name|id
parameter_list|)
block|{
try|try
block|{
return|return
name|aliases
index|[
name|id
operator|-
literal|1
index|]
return|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Bad flag alias number:"
operator|+
name|id
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**    * Abstraction of the process of parsing flags taken from the affix and dic files    */
DECL|class|FlagParsingStrategy
specifier|private
specifier|static
specifier|abstract
class|class
name|FlagParsingStrategy
block|{
comment|/**      * Parses the given String into a single flag      *      * @param rawFlag String to parse into a flag      * @return Parsed flag      */
DECL|method|parseFlag
name|char
name|parseFlag
parameter_list|(
name|String
name|rawFlag
parameter_list|)
block|{
return|return
name|parseFlags
argument_list|(
name|rawFlag
argument_list|)
index|[
literal|0
index|]
return|;
block|}
comment|/**      * Parses the given String into multiple flags      *      * @param rawFlags String to parse into flags      * @return Parsed flags      */
DECL|method|parseFlags
specifier|abstract
name|char
index|[]
name|parseFlags
parameter_list|(
name|String
name|rawFlags
parameter_list|)
function_decl|;
block|}
comment|/**    * Simple implementation of {@link FlagParsingStrategy} that treats the chars in each String as a individual flags.    * Can be used with both the ASCII and UTF-8 flag types.    */
DECL|class|SimpleFlagParsingStrategy
specifier|private
specifier|static
class|class
name|SimpleFlagParsingStrategy
extends|extends
name|FlagParsingStrategy
block|{
annotation|@
name|Override
DECL|method|parseFlags
specifier|public
name|char
index|[]
name|parseFlags
parameter_list|(
name|String
name|rawFlags
parameter_list|)
block|{
return|return
name|rawFlags
operator|.
name|toCharArray
argument_list|()
return|;
block|}
block|}
comment|/**    * Implementation of {@link FlagParsingStrategy} that assumes each flag is encoded in its numerical form.  In the case    * of multiple flags, each number is separated by a comma.    */
DECL|class|NumFlagParsingStrategy
specifier|private
specifier|static
class|class
name|NumFlagParsingStrategy
extends|extends
name|FlagParsingStrategy
block|{
annotation|@
name|Override
DECL|method|parseFlags
specifier|public
name|char
index|[]
name|parseFlags
parameter_list|(
name|String
name|rawFlags
parameter_list|)
block|{
name|String
index|[]
name|rawFlagParts
init|=
name|rawFlags
operator|.
name|trim
argument_list|()
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|char
index|[]
name|flags
init|=
operator|new
name|char
index|[
name|rawFlagParts
operator|.
name|length
index|]
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rawFlagParts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// note, removing the trailing X/leading I for nepali... what is the rule here?!
name|String
name|replacement
init|=
name|rawFlagParts
index|[
name|i
index|]
operator|.
name|replaceAll
argument_list|(
literal|"[^0-9]"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
comment|// note, ignoring empty flags (this happens in danish, for example)
if|if
condition|(
name|replacement
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|flags
index|[
name|upto
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|Integer
operator|.
name|parseInt
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|upto
operator|<
name|flags
operator|.
name|length
condition|)
block|{
name|flags
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|flags
argument_list|,
name|upto
argument_list|)
expr_stmt|;
block|}
return|return
name|flags
return|;
block|}
block|}
comment|/**    * Implementation of {@link FlagParsingStrategy} that assumes each flag is encoded as two ASCII characters whose codes    * must be combined into a single character.    *    * TODO (rmuir) test    */
DECL|class|DoubleASCIIFlagParsingStrategy
specifier|private
specifier|static
class|class
name|DoubleASCIIFlagParsingStrategy
extends|extends
name|FlagParsingStrategy
block|{
annotation|@
name|Override
DECL|method|parseFlags
specifier|public
name|char
index|[]
name|parseFlags
parameter_list|(
name|String
name|rawFlags
parameter_list|)
block|{
if|if
condition|(
name|rawFlags
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|char
index|[
literal|0
index|]
return|;
block|}
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rawFlags
operator|.
name|length
argument_list|()
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|char
name|cookedFlag
init|=
call|(
name|char
call|)
argument_list|(
operator|(
name|int
operator|)
name|rawFlags
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|+
operator|(
name|int
operator|)
name|rawFlags
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|cookedFlag
argument_list|)
expr_stmt|;
block|}
name|char
name|flags
index|[]
init|=
operator|new
name|char
index|[
name|builder
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
name|builder
operator|.
name|getChars
argument_list|(
literal|0
argument_list|,
name|builder
operator|.
name|length
argument_list|()
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|flags
return|;
block|}
block|}
DECL|method|hasFlag
specifier|static
name|boolean
name|hasFlag
parameter_list|(
name|char
name|flags
index|[]
parameter_list|,
name|char
name|flag
parameter_list|)
block|{
return|return
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|flags
argument_list|,
name|flag
argument_list|)
operator|>=
literal|0
return|;
block|}
DECL|method|merge
specifier|static
name|char
index|[]
name|merge
parameter_list|(
name|char
index|[]
name|flags1
parameter_list|,
name|char
index|[]
name|flags2
parameter_list|)
block|{
name|char
name|merged
index|[]
init|=
operator|new
name|char
index|[
name|flags1
operator|.
name|length
operator|+
name|flags2
operator|.
name|length
index|]
decl_stmt|;
name|int
name|i1
init|=
literal|0
decl_stmt|,
name|i2
init|=
literal|0
decl_stmt|;
name|int
name|last
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i1
operator|<
name|flags1
operator|.
name|length
operator|&&
name|i2
operator|<
name|flags2
operator|.
name|length
condition|)
block|{
specifier|final
name|char
name|next
decl_stmt|;
if|if
condition|(
name|flags1
index|[
name|i1
index|]
operator|<=
name|flags2
index|[
name|i2
index|]
condition|)
block|{
name|next
operator|=
name|flags1
index|[
name|i1
operator|++
index|]
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|flags2
index|[
name|i2
operator|++
index|]
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|!=
name|last
condition|)
block|{
name|merged
index|[
name|upto
operator|++
index|]
operator|=
name|next
expr_stmt|;
name|last
operator|=
name|next
expr_stmt|;
block|}
block|}
while|while
condition|(
name|i1
operator|<
name|flags1
operator|.
name|length
condition|)
block|{
name|char
name|next
init|=
name|flags1
index|[
name|i1
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|next
operator|!=
name|last
condition|)
block|{
name|merged
index|[
name|upto
operator|++
index|]
operator|=
name|next
expr_stmt|;
name|last
operator|=
name|next
expr_stmt|;
block|}
block|}
while|while
condition|(
name|i2
operator|<
name|flags2
operator|.
name|length
condition|)
block|{
name|char
name|next
init|=
name|flags2
index|[
name|i2
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|next
operator|!=
name|last
condition|)
block|{
name|merged
index|[
name|upto
operator|++
index|]
operator|=
name|next
expr_stmt|;
name|last
operator|=
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|merged
operator|.
name|length
operator|!=
name|upto
condition|)
block|{
name|merged
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|merged
argument_list|,
name|upto
argument_list|)
expr_stmt|;
block|}
return|return
name|merged
return|;
block|}
block|}
end_class
end_unit
