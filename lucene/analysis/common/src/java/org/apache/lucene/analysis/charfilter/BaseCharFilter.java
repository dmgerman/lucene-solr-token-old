begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.analysis.charfilter
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|charfilter
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|CharFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_comment
comment|/**  * Base utility class for implementing a {@link CharFilter}.  * You subclass this, and then record mappings by calling  * {@link #addOffCorrectMap}, and then invoke the correct  * method to correct an offset.  */
end_comment
begin_class
DECL|class|BaseCharFilter
specifier|public
specifier|abstract
class|class
name|BaseCharFilter
extends|extends
name|CharFilter
block|{
DECL|field|offsets
specifier|private
name|int
name|offsets
index|[]
decl_stmt|;
DECL|field|diffs
specifier|private
name|int
name|diffs
index|[]
decl_stmt|;
DECL|field|size
specifier|private
name|int
name|size
init|=
literal|0
decl_stmt|;
DECL|method|BaseCharFilter
specifier|public
name|BaseCharFilter
parameter_list|(
name|Reader
name|in
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
comment|/** Retrieve the corrected offset. */
annotation|@
name|Override
DECL|method|correct
specifier|protected
name|int
name|correct
parameter_list|(
name|int
name|currentOff
parameter_list|)
block|{
if|if
condition|(
name|offsets
operator|==
literal|null
operator|||
name|currentOff
operator|<
name|offsets
index|[
literal|0
index|]
condition|)
block|{
return|return
name|currentOff
return|;
block|}
name|int
name|hi
init|=
name|size
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|currentOff
operator|>=
name|offsets
index|[
name|hi
index|]
condition|)
return|return
name|currentOff
operator|+
name|diffs
index|[
name|hi
index|]
return|;
name|int
name|lo
init|=
literal|0
decl_stmt|;
name|int
name|mid
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|hi
operator|>=
name|lo
condition|)
block|{
name|mid
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>>
literal|1
expr_stmt|;
if|if
condition|(
name|currentOff
operator|<
name|offsets
index|[
name|mid
index|]
condition|)
name|hi
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|currentOff
operator|>
name|offsets
index|[
name|mid
index|]
condition|)
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|currentOff
operator|+
name|diffs
index|[
name|mid
index|]
return|;
block|}
if|if
condition|(
name|currentOff
operator|<
name|offsets
index|[
name|mid
index|]
condition|)
return|return
name|mid
operator|==
literal|0
condition|?
name|currentOff
else|:
name|currentOff
operator|+
name|diffs
index|[
name|mid
operator|-
literal|1
index|]
return|;
else|else
return|return
name|currentOff
operator|+
name|diffs
index|[
name|mid
index|]
return|;
block|}
DECL|method|getLastCumulativeDiff
specifier|protected
name|int
name|getLastCumulativeDiff
parameter_list|()
block|{
return|return
name|offsets
operator|==
literal|null
condition|?
literal|0
else|:
name|diffs
index|[
name|size
operator|-
literal|1
index|]
return|;
block|}
comment|/**    *<p>    *   Adds an offset correction mapping at the given output stream offset.    *</p>    *<p>    *   Assumption: the offset given with each successive call to this method    *   will not be smaller than the offset given at the previous invocation.    *</p>    *    * @param off The output stream offset at which to apply the correction    * @param cumulativeDiff The input offset is given by adding this    *                       to the output offset    */
DECL|method|addOffCorrectMap
specifier|protected
name|void
name|addOffCorrectMap
parameter_list|(
name|int
name|off
parameter_list|,
name|int
name|cumulativeDiff
parameter_list|)
block|{
if|if
condition|(
name|offsets
operator|==
literal|null
condition|)
block|{
name|offsets
operator|=
operator|new
name|int
index|[
literal|64
index|]
expr_stmt|;
name|diffs
operator|=
operator|new
name|int
index|[
literal|64
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
name|offsets
operator|.
name|length
condition|)
block|{
name|offsets
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|offsets
argument_list|)
expr_stmt|;
name|diffs
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|diffs
argument_list|)
expr_stmt|;
block|}
assert|assert
operator|(
name|size
operator|==
literal|0
operator|||
name|off
operator|>=
name|offsets
index|[
name|size
operator|-
literal|1
index|]
operator|)
operator|:
literal|"Offset #"
operator|+
name|size
operator|+
literal|"("
operator|+
name|off
operator|+
literal|") is less than the last recorded offset "
operator|+
name|offsets
index|[
name|size
operator|-
literal|1
index|]
operator|+
literal|"\n"
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|offsets
argument_list|)
operator|+
literal|"\n"
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|diffs
argument_list|)
assert|;
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|off
operator|!=
name|offsets
index|[
name|size
operator|-
literal|1
index|]
condition|)
block|{
name|offsets
index|[
name|size
index|]
operator|=
name|off
expr_stmt|;
name|diffs
index|[
name|size
operator|++
index|]
operator|=
name|cumulativeDiff
expr_stmt|;
block|}
else|else
block|{
comment|// Overwrite the diff at the last recorded offset
name|diffs
index|[
name|size
operator|-
literal|1
index|]
operator|=
name|cumulativeDiff
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
