begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.analysis.pt
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|pt
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_comment
comment|/**  * Portuguese stemmer implementing the RSLP (Removedor de Sufixos da Lingua Portuguesa)  * algorithm. This is sometimes also referred to as the Orengo stemmer.  *   * @see RSLPStemmerBase  */
end_comment
begin_class
DECL|class|PortugueseStemmer
specifier|public
class|class
name|PortugueseStemmer
extends|extends
name|RSLPStemmerBase
block|{
DECL|field|plural
DECL|field|feminine
DECL|field|adverb
DECL|field|augmentative
DECL|field|noun
DECL|field|verb
DECL|field|vowel
specifier|private
specifier|static
specifier|final
name|Step
name|plural
decl_stmt|,
name|feminine
decl_stmt|,
name|adverb
decl_stmt|,
name|augmentative
decl_stmt|,
name|noun
decl_stmt|,
name|verb
decl_stmt|,
name|vowel
decl_stmt|;
static|static
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Step
argument_list|>
name|steps
init|=
name|parse
argument_list|(
name|PortugueseStemmer
operator|.
name|class
argument_list|,
literal|"portuguese.rslp"
argument_list|)
decl_stmt|;
name|plural
operator|=
name|steps
operator|.
name|get
argument_list|(
literal|"Plural"
argument_list|)
expr_stmt|;
name|feminine
operator|=
name|steps
operator|.
name|get
argument_list|(
literal|"Feminine"
argument_list|)
expr_stmt|;
name|adverb
operator|=
name|steps
operator|.
name|get
argument_list|(
literal|"Adverb"
argument_list|)
expr_stmt|;
name|augmentative
operator|=
name|steps
operator|.
name|get
argument_list|(
literal|"Augmentative"
argument_list|)
expr_stmt|;
name|noun
operator|=
name|steps
operator|.
name|get
argument_list|(
literal|"Noun"
argument_list|)
expr_stmt|;
name|verb
operator|=
name|steps
operator|.
name|get
argument_list|(
literal|"Verb"
argument_list|)
expr_stmt|;
name|vowel
operator|=
name|steps
operator|.
name|get
argument_list|(
literal|"Vowel"
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param s buffer, oversized to at least<code>len+1</code>    * @param len initial valid length of buffer    * @return new valid length, stemmed    */
DECL|method|stem
specifier|public
name|int
name|stem
parameter_list|(
name|char
name|s
index|[]
parameter_list|,
name|int
name|len
parameter_list|)
block|{
assert|assert
name|s
operator|.
name|length
operator|>=
name|len
operator|+
literal|1
operator|:
literal|"this stemmer requires an oversized array of at least 1"
assert|;
name|len
operator|=
name|plural
operator|.
name|apply
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|adverb
operator|.
name|apply
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|feminine
operator|.
name|apply
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|augmentative
operator|.
name|apply
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|int
name|oldlen
init|=
name|len
decl_stmt|;
name|len
operator|=
name|noun
operator|.
name|apply
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|oldlen
condition|)
block|{
comment|/* suffix not removed */
name|oldlen
operator|=
name|len
expr_stmt|;
name|len
operator|=
name|verb
operator|.
name|apply
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|oldlen
condition|)
block|{
comment|/* suffix not removed */
name|len
operator|=
name|vowel
operator|.
name|apply
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
comment|// rslp accent removal
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|s
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'Ã '
case|:
case|case
literal|'Ã¡'
case|:
case|case
literal|'Ã¢'
case|:
case|case
literal|'Ã£'
case|:
case|case
literal|'Ã¤'
case|:
case|case
literal|'Ã¥'
case|:
name|s
index|[
name|i
index|]
operator|=
literal|'a'
expr_stmt|;
break|break;
case|case
literal|'Ã§'
case|:
name|s
index|[
name|i
index|]
operator|=
literal|'c'
expr_stmt|;
break|break;
case|case
literal|'Ã¨'
case|:
case|case
literal|'Ã©'
case|:
case|case
literal|'Ãª'
case|:
case|case
literal|'Ã«'
case|:
name|s
index|[
name|i
index|]
operator|=
literal|'e'
expr_stmt|;
break|break;
case|case
literal|'Ã¬'
case|:
case|case
literal|'Ã­'
case|:
case|case
literal|'Ã®'
case|:
case|case
literal|'Ã¯'
case|:
name|s
index|[
name|i
index|]
operator|=
literal|'i'
expr_stmt|;
break|break;
case|case
literal|'Ã±'
case|:
name|s
index|[
name|i
index|]
operator|=
literal|'n'
expr_stmt|;
break|break;
case|case
literal|'Ã²'
case|:
case|case
literal|'Ã³'
case|:
case|case
literal|'Ã´'
case|:
case|case
literal|'Ãµ'
case|:
case|case
literal|'Ã¶'
case|:
name|s
index|[
name|i
index|]
operator|=
literal|'o'
expr_stmt|;
break|break;
case|case
literal|'Ã¹'
case|:
case|case
literal|'Ãº'
case|:
case|case
literal|'Ã»'
case|:
case|case
literal|'Ã¼'
case|:
name|s
index|[
name|i
index|]
operator|=
literal|'u'
expr_stmt|;
break|break;
case|case
literal|'Ã½'
case|:
case|case
literal|'Ã¿'
case|:
name|s
index|[
name|i
index|]
operator|=
literal|'y'
expr_stmt|;
break|break;
block|}
block|}
return|return
name|len
return|;
block|}
block|}
end_class
end_unit
