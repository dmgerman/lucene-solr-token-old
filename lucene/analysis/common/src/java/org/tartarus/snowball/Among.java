begin_unit
begin_comment
comment|/*  Copyright (c) 2001, Dr Martin Porter Copyright (c) 2002, Richard Boulton All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright notice,     * this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above copyright     * notice, this list of conditions and the following disclaimer in the     * documentation and/or other materials provided with the distribution.     * Neither the name of the copyright holders nor the names of its contributors     * may be used to endorse or promote products derived from this software     * without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   */
end_comment
begin_package
DECL|package|org.tartarus.snowball
package|package
name|org
operator|.
name|tartarus
operator|.
name|snowball
package|;
end_package
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import
begin_comment
comment|/**  * This is the rev 502 of the Snowball SVN trunk,  * but modified:  * made abstract and introduced abstract method stem to avoid expensive reflection in filter class.  * refactored StringBuffers to StringBuilder  * uses char[] as buffer instead of StringBuffer/StringBuilder  * eq_s,eq_s_b,insert,replace_s take CharSequence like eq_v and eq_v_b  * reflection calls (Lovins, etc) use EMPTY_ARGS/EMPTY_PARAMS  */
end_comment
begin_class
DECL|class|Among
specifier|public
class|class
name|Among
block|{
DECL|field|EMPTY_PARAMS
specifier|private
specifier|static
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|EMPTY_PARAMS
init|=
operator|new
name|Class
index|[
literal|0
index|]
decl_stmt|;
DECL|method|Among
specifier|public
name|Among
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|substring_i
parameter_list|,
name|int
name|result
parameter_list|,
name|String
name|methodname
parameter_list|,
name|SnowballProgram
name|methodobject
parameter_list|)
block|{
name|this
operator|.
name|s_size
operator|=
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
name|this
operator|.
name|s
operator|=
name|s
operator|.
name|toCharArray
argument_list|()
expr_stmt|;
name|this
operator|.
name|substring_i
operator|=
name|substring_i
expr_stmt|;
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
name|this
operator|.
name|methodobject
operator|=
name|methodobject
expr_stmt|;
if|if
condition|(
name|methodname
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|method
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|this
operator|.
name|method
operator|=
name|methodobject
operator|.
name|getClass
argument_list|()
operator|.
name|getDeclaredMethod
argument_list|(
name|methodname
argument_list|,
name|EMPTY_PARAMS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|field|s_size
specifier|public
specifier|final
name|int
name|s_size
decl_stmt|;
comment|/* search string */
DECL|field|s
specifier|public
specifier|final
name|char
index|[]
name|s
decl_stmt|;
comment|/* search string */
DECL|field|substring_i
specifier|public
specifier|final
name|int
name|substring_i
decl_stmt|;
comment|/* index to longest matching substring */
DECL|field|result
specifier|public
specifier|final
name|int
name|result
decl_stmt|;
comment|/* result of the lookup */
DECL|field|method
specifier|public
specifier|final
name|Method
name|method
decl_stmt|;
comment|/* method to use if substring matches */
DECL|field|methodobject
specifier|public
specifier|final
name|SnowballProgram
name|methodobject
decl_stmt|;
comment|/* object to invoke method on */
block|}
end_class
begin_empty_stmt
empty_stmt|;
end_empty_stmt
end_unit
