begin_unit
begin_package
DECL|package|org.apache.lucene.analysis.core
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|core
package|;
end_package
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|BaseTokenStreamTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Tokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|standard
operator|.
name|UAX29URLEmailTokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|TypeAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_class
DECL|class|TestUAX29URLEmailTokenizer
specifier|public
class|class
name|TestUAX29URLEmailTokenizer
extends|extends
name|BaseTokenStreamTestCase
block|{
comment|// LUCENE-5440: extremely slow tokenization of text matching email<local-part> (before the '@')
DECL|method|testLongEMAILatomText
specifier|public
name|void
name|testLongEMAILatomText
parameter_list|()
throws|throws
name|Exception
block|{
comment|// EMAILatomText = [A-Za-z0-9!#$%&'*+-/=?\^_`{|}~]
name|char
index|[]
name|emailAtomChars
init|=
literal|"!#$%&'*+,-./0123456789=?ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz{|}~"
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|numChars
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|100
operator|*
literal|1024
argument_list|,
literal|3
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numChars
condition|;
operator|++
name|i
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|emailAtomChars
index|[
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|emailAtomChars
operator|.
name|length
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
name|int
name|tokenCount
init|=
literal|0
decl_stmt|;
name|UAX29URLEmailTokenizer
name|ts
init|=
operator|new
name|UAX29URLEmailTokenizer
argument_list|()
decl_stmt|;
name|String
name|text
init|=
name|builder
operator|.
name|toString
argument_list|()
decl_stmt|;
name|ts
operator|.
name|setReader
argument_list|(
operator|new
name|StringReader
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|.
name|reset
argument_list|()
expr_stmt|;
while|while
condition|(
name|ts
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
name|tokenCount
operator|++
expr_stmt|;
block|}
name|ts
operator|.
name|end
argument_list|()
expr_stmt|;
name|ts
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|tokenCount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|tokenCount
operator|=
literal|0
expr_stmt|;
name|int
name|newBufferSize
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|200
argument_list|,
literal|8192
argument_list|)
decl_stmt|;
name|ts
operator|.
name|setMaxTokenLength
argument_list|(
name|newBufferSize
argument_list|)
expr_stmt|;
name|ts
operator|.
name|setReader
argument_list|(
operator|new
name|StringReader
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|.
name|reset
argument_list|()
expr_stmt|;
while|while
condition|(
name|ts
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
name|tokenCount
operator|++
expr_stmt|;
block|}
name|ts
operator|.
name|end
argument_list|()
expr_stmt|;
name|ts
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|tokenCount
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|testHugeDoc
specifier|public
name|void
name|testHugeDoc
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|char
name|whitespace
index|[]
init|=
operator|new
name|char
index|[
literal|4094
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|whitespace
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|whitespace
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"testing 1234"
argument_list|)
expr_stmt|;
name|String
name|input
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
name|UAX29URLEmailTokenizer
name|tokenizer
init|=
operator|new
name|UAX29URLEmailTokenizer
argument_list|(
name|newAttributeFactory
argument_list|()
argument_list|)
decl_stmt|;
name|tokenizer
operator|.
name|setReader
argument_list|(
operator|new
name|StringReader
argument_list|(
name|input
argument_list|)
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertTokenStreamContents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"testing"
block|,
literal|"1234"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|field|a
specifier|private
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|UAX29URLEmailTokenizer
argument_list|(
name|newAttributeFactory
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/** Passes through tokens with type "<URL>" and blocks all other types. */
DECL|class|URLFilter
specifier|private
class|class
name|URLFilter
extends|extends
name|TokenFilter
block|{
DECL|field|typeAtt
specifier|private
specifier|final
name|TypeAttribute
name|typeAtt
init|=
name|addAttribute
argument_list|(
name|TypeAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|URLFilter
specifier|public
name|URLFilter
parameter_list|(
name|TokenStream
name|in
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|incrementToken
specifier|public
specifier|final
name|boolean
name|incrementToken
parameter_list|()
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
name|boolean
name|isTokenAvailable
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|input
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
if|if
condition|(
name|typeAtt
operator|.
name|type
argument_list|()
operator|==
name|UAX29URLEmailTokenizer
operator|.
name|TOKEN_TYPES
index|[
name|UAX29URLEmailTokenizer
operator|.
name|URL
index|]
condition|)
block|{
name|isTokenAvailable
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
return|return
name|isTokenAvailable
return|;
block|}
block|}
comment|/** Passes through tokens with type "<EMAIL>" and blocks all other types. */
DECL|class|EmailFilter
specifier|private
class|class
name|EmailFilter
extends|extends
name|TokenFilter
block|{
DECL|field|typeAtt
specifier|private
specifier|final
name|TypeAttribute
name|typeAtt
init|=
name|addAttribute
argument_list|(
name|TypeAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|EmailFilter
specifier|public
name|EmailFilter
parameter_list|(
name|TokenStream
name|in
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|incrementToken
specifier|public
specifier|final
name|boolean
name|incrementToken
parameter_list|()
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
name|boolean
name|isTokenAvailable
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|input
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
if|if
condition|(
name|typeAtt
operator|.
name|type
argument_list|()
operator|==
name|UAX29URLEmailTokenizer
operator|.
name|TOKEN_TYPES
index|[
name|UAX29URLEmailTokenizer
operator|.
name|EMAIL
index|]
condition|)
block|{
name|isTokenAvailable
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
return|return
name|isTokenAvailable
return|;
block|}
block|}
DECL|field|urlAnalyzer
specifier|private
name|Analyzer
name|urlAnalyzer
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|UAX29URLEmailTokenizer
name|tokenizer
init|=
operator|new
name|UAX29URLEmailTokenizer
argument_list|(
name|newAttributeFactory
argument_list|()
argument_list|)
decl_stmt|;
name|tokenizer
operator|.
name|setMaxTokenLength
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
comment|// Tokenize arbitrary length URLs
name|TokenFilter
name|filter
init|=
operator|new
name|URLFilter
argument_list|(
name|tokenizer
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
name|filter
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|emailAnalyzer
specifier|private
name|Analyzer
name|emailAnalyzer
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|UAX29URLEmailTokenizer
name|tokenizer
init|=
operator|new
name|UAX29URLEmailTokenizer
argument_list|(
name|newAttributeFactory
argument_list|()
argument_list|)
decl_stmt|;
name|TokenFilter
name|filter
init|=
operator|new
name|EmailFilter
argument_list|(
name|tokenizer
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
name|filter
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|method|testArmenian
specifier|public
name|void
name|testArmenian
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"ÕÕ«ÖÕ«ÕºÕ¥Õ¤Õ«Õ¡ÕµÕ« 13 Õ´Õ«Õ¬Õ«Õ¸Õ¶ Õ°Õ¸Õ¤Õ¾Õ¡Õ®Õ¶Õ¥ÖÕ¨ (4,600` Õ°Õ¡ÕµÕ¥ÖÕ¥Õ¶ Õ¾Õ«ÖÕ«ÕºÕ¥Õ¤Õ«Õ¡ÕµÕ¸ÖÕ´) Õ£ÖÕ¾Õ¥Õ¬ Õ¥Õ¶ Õ¯Õ¡Õ´Õ¡Õ¾Õ¸ÖÕ¶Õ¥ÖÕ« Õ¯Õ¸Õ²Õ´Õ«Ö Õ¸Ö Õ°Õ¡Õ´Õ¡ÖÕµÕ¡ Õ¢Õ¸Õ¬Õ¸Ö Õ°Õ¸Õ¤Õ¾Õ¡Õ®Õ¶Õ¥ÖÕ¨ Õ¯Õ¡ÖÕ¸Õ² Õ§ Õ­Õ´Õ¢Õ¡Õ£ÖÕ¥Õ¬ ÖÕ¡Õ¶Õ¯Õ¡Ö Õ´Õ¡ÖÕ¤ Õ¸Õ¾ Õ¯Õ¡ÖÕ¸Õ² Õ§ Õ¢Õ¡ÖÕ¥Õ¬ ÕÕ«ÖÕ«ÕºÕ¥Õ¤Õ«Õ¡ÕµÕ« Õ¯Õ¡ÕµÖÕ¨Ö"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ÕÕ«ÖÕ«ÕºÕ¥Õ¤Õ«Õ¡ÕµÕ«"
block|,
literal|"13"
block|,
literal|"Õ´Õ«Õ¬Õ«Õ¸Õ¶"
block|,
literal|"Õ°Õ¸Õ¤Õ¾Õ¡Õ®Õ¶Õ¥ÖÕ¨"
block|,
literal|"4,600"
block|,
literal|"Õ°Õ¡ÕµÕ¥ÖÕ¥Õ¶"
block|,
literal|"Õ¾Õ«ÖÕ«ÕºÕ¥Õ¤Õ«Õ¡ÕµÕ¸ÖÕ´"
block|,
literal|"Õ£ÖÕ¾Õ¥Õ¬"
block|,
literal|"Õ¥Õ¶"
block|,
literal|"Õ¯Õ¡Õ´Õ¡Õ¾Õ¸ÖÕ¶Õ¥ÖÕ«"
block|,
literal|"Õ¯Õ¸Õ²Õ´Õ«Ö"
block|,
literal|"Õ¸Ö"
block|,
literal|"Õ°Õ¡Õ´Õ¡ÖÕµÕ¡"
block|,
literal|"Õ¢Õ¸Õ¬Õ¸Ö"
block|,
literal|"Õ°Õ¸Õ¤Õ¾Õ¡Õ®Õ¶Õ¥ÖÕ¨"
block|,
literal|"Õ¯Õ¡ÖÕ¸Õ²"
block|,
literal|"Õ§"
block|,
literal|"Õ­Õ´Õ¢Õ¡Õ£ÖÕ¥Õ¬"
block|,
literal|"ÖÕ¡Õ¶Õ¯Õ¡Ö"
block|,
literal|"Õ´Õ¡ÖÕ¤"
block|,
literal|"Õ¸Õ¾"
block|,
literal|"Õ¯Õ¡ÖÕ¸Õ²"
block|,
literal|"Õ§"
block|,
literal|"Õ¢Õ¡ÖÕ¥Õ¬"
block|,
literal|"ÕÕ«ÖÕ«ÕºÕ¥Õ¤Õ«Õ¡ÕµÕ«"
block|,
literal|"Õ¯Õ¡ÕµÖÕ¨"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testAmharic
specifier|public
name|void
name|testAmharic
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"ááªááµá« á¨á£á á¥á ááá á¨á°áá áµá­á­ááá áá» áááá  ááááµ (á¢áá³á­á­ááá²á«) ááá¢ ááááá"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ááªááµá«"
block|,
literal|"á¨á£á"
block|,
literal|"á¥á"
block|,
literal|"ááá"
block|,
literal|"á¨á°áá"
block|,
literal|"áµá­á­ááá"
block|,
literal|"áá»"
block|,
literal|"áááá "
block|,
literal|"ááááµ"
block|,
literal|"á¢áá³á­á­ááá²á«"
block|,
literal|"áá"
block|,
literal|"ááááá"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testArabic
specifier|public
name|void
name|testArabic
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"Ø§ÙÙÙÙÙ Ø§ÙÙØ«Ø§Ø¦ÙÙ Ø§ÙØ£ÙÙ Ø¹Ù ÙÙÙÙØ¨ÙØ¯ÙØ§ ÙØ³ÙÙ \"Ø§ÙØ­ÙÙÙØ© Ø¨Ø§ÙØ£Ø±ÙØ§Ù: ÙØµØ© ÙÙÙÙØ¨ÙØ¯ÙØ§\" (Ø¨Ø§ÙØ¥ÙØ¬ÙÙØ²ÙØ©: Truth in Numbers: The Wikipedia Story)Ø Ø³ÙØªÙ Ø¥Ø·ÙØ§ÙÙ ÙÙ 2008."
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"Ø§ÙÙÙÙÙ"
block|,
literal|"Ø§ÙÙØ«Ø§Ø¦ÙÙ"
block|,
literal|"Ø§ÙØ£ÙÙ"
block|,
literal|"Ø¹Ù"
block|,
literal|"ÙÙÙÙØ¨ÙØ¯ÙØ§"
block|,
literal|"ÙØ³ÙÙ"
block|,
literal|"Ø§ÙØ­ÙÙÙØ©"
block|,
literal|"Ø¨Ø§ÙØ£Ø±ÙØ§Ù"
block|,
literal|"ÙØµØ©"
block|,
literal|"ÙÙÙÙØ¨ÙØ¯ÙØ§"
block|,
literal|"Ø¨Ø§ÙØ¥ÙØ¬ÙÙØ²ÙØ©"
block|,
literal|"Truth"
block|,
literal|"in"
block|,
literal|"Numbers"
block|,
literal|"The"
block|,
literal|"Wikipedia"
block|,
literal|"Story"
block|,
literal|"Ø³ÙØªÙ"
block|,
literal|"Ø¥Ø·ÙØ§ÙÙ"
block|,
literal|"ÙÙ"
block|,
literal|"2008"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testAramaic
specifier|public
name|void
name|testAramaic
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"ÜÜÜ©ÜÜ¦ÜÜÜ (ÜÜ¢ÜÜ ÜÜ: Wikipedia) ÜÜ ÜÜÜ¢Ü£Ü©Ü ÜÜ¦ÜÜÜ ÜÜÜªÜ¬Ü ÜÜÜ¢ÜÜªÜ¢Ü ÜÜ Ü«Ü¢ÌÜ Ü£ÜÜÜÌÜÜ Ü«Ü¡Ü ÜÜ¬Ü Ü¡Ü¢ Ü¡ÌÜ Ü¬Ü Ü\"ÜÜÜ©Ü\" Ü\"ÜÜÜ¢Ü£Ü©Ü ÜÜ¦ÜÜÜ\"Ü"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ÜÜÜ©ÜÜ¦ÜÜÜ"
block|,
literal|"ÜÜ¢ÜÜ ÜÜ"
block|,
literal|"Wikipedia"
block|,
literal|"ÜÜ"
block|,
literal|"ÜÜÜ¢Ü£Ü©Ü ÜÜ¦ÜÜÜ"
block|,
literal|"ÜÜÜªÜ¬Ü"
block|,
literal|"ÜÜÜ¢ÜÜªÜ¢Ü"
block|,
literal|"ÜÜ Ü«Ü¢ÌÜ"
block|,
literal|"Ü£ÜÜÜÌÜ"
block|,
literal|"Ü«Ü¡Ü"
block|,
literal|"ÜÜ¬Ü"
block|,
literal|"Ü¡Ü¢"
block|,
literal|"Ü¡ÌÜ Ü¬Ü"
block|,
literal|"Ü"
block|,
literal|"ÜÜÜ©Ü"
block|,
literal|"Ü"
block|,
literal|"ÜÜÜ¢Ü£Ü©Ü ÜÜ¦ÜÜÜ"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testBengali
specifier|public
name|void
name|testBengali
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"à¦à¦ à¦¬à¦¿à¦¶à§à¦¬à¦à§à¦· à¦ªà¦°à¦¿à¦à¦¾à¦²à¦¨à¦¾ à¦à¦°à§ à¦à¦à¦à¦¿à¦®à¦¿à¦¡à¦¿à¦¯à¦¼à¦¾ à¦«à¦¾à¦à¦¨à§à¦¡à§à¦¶à¦¨ (à¦à¦à¦à¦¿ à¦à¦²à¦¾à¦­à¦à¦¨à¦ à¦¸à¦à¦¸à§à¦¥à¦¾)à¥¤ à¦à¦à¦à¦¿à¦ªà¦¿à¦¡à¦¿à¦¯à¦¼à¦¾à¦° à¦¶à§à¦°à§ à§§à§« à¦à¦¾à¦¨à§à¦¯à¦¼à¦¾à¦°à¦¿, à§¨à§¦à§¦à§§ à¦¸à¦¾à¦²à§à¥¤ à¦à¦à¦¨ à¦ªà¦°à§à¦¯à¦¨à§à¦¤ à§¨à§¦à§¦à¦à¦¿à¦°à¦ à¦¬à§à¦¶à§ à¦­à¦¾à¦·à¦¾à¦¯à¦¼ à¦à¦à¦à¦¿à¦ªà¦¿à¦¡à¦¿à¦¯à¦¼à¦¾ à¦°à¦¯à¦¼à§à¦à§à¥¤"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"à¦à¦"
block|,
literal|"à¦¬à¦¿à¦¶à§à¦¬à¦à§à¦·"
block|,
literal|"à¦ªà¦°à¦¿à¦à¦¾à¦²à¦¨à¦¾"
block|,
literal|"à¦à¦°à§"
block|,
literal|"à¦à¦à¦à¦¿à¦®à¦¿à¦¡à¦¿à¦¯à¦¼à¦¾"
block|,
literal|"à¦«à¦¾à¦à¦¨à§à¦¡à§à¦¶à¦¨"
block|,
literal|"à¦à¦à¦à¦¿"
block|,
literal|"à¦à¦²à¦¾à¦­à¦à¦¨à¦"
block|,
literal|"à¦¸à¦à¦¸à§à¦¥à¦¾"
block|,
literal|"à¦à¦à¦à¦¿à¦ªà¦¿à¦¡à¦¿à¦¯à¦¼à¦¾à¦°"
block|,
literal|"à¦¶à§à¦°à§"
block|,
literal|"à§§à§«"
block|,
literal|"à¦à¦¾à¦¨à§à¦¯à¦¼à¦¾à¦°à¦¿"
block|,
literal|"à§¨à§¦à§¦à§§"
block|,
literal|"à¦¸à¦¾à¦²à§"
block|,
literal|"à¦à¦à¦¨"
block|,
literal|"à¦ªà¦°à§à¦¯à¦¨à§à¦¤"
block|,
literal|"à§¨à§¦à§¦à¦à¦¿à¦°à¦"
block|,
literal|"à¦¬à§à¦¶à§"
block|,
literal|"à¦­à¦¾à¦·à¦¾à¦¯à¦¼"
block|,
literal|"à¦à¦à¦à¦¿à¦ªà¦¿à¦¡à¦¿à¦¯à¦¼à¦¾"
block|,
literal|"à¦°à¦¯à¦¼à§à¦à§"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testFarsi
specifier|public
name|void
name|testFarsi
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"ÙÛÚ©Û Ù¾Ø¯ÛØ§Û Ø§ÙÚ¯ÙÛØ³Û Ø¯Ø± ØªØ§Ø±ÛØ® Û²Ûµ Ø¯Û Û±Û³Û·Û¹ Ø¨Ù ØµÙØ±Øª ÙÚ©ÙÙÛ Ø¨Ø±Ø§Û Ø¯Ø§ÙØ´ÙØ§ÙÙÙ ØªØ®ØµØµÛ ÙÙÙ¾Ø¯ÛØ§ ÙÙØ´ØªÙ Ø´Ø¯."
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ÙÛÚ©Û"
block|,
literal|"Ù¾Ø¯ÛØ§Û"
block|,
literal|"Ø§ÙÚ¯ÙÛØ³Û"
block|,
literal|"Ø¯Ø±"
block|,
literal|"ØªØ§Ø±ÛØ®"
block|,
literal|"Û²Ûµ"
block|,
literal|"Ø¯Û"
block|,
literal|"Û±Û³Û·Û¹"
block|,
literal|"Ø¨Ù"
block|,
literal|"ØµÙØ±Øª"
block|,
literal|"ÙÚ©ÙÙÛ"
block|,
literal|"Ø¨Ø±Ø§Û"
block|,
literal|"Ø¯Ø§ÙØ´ÙØ§ÙÙÙ"
block|,
literal|"ØªØ®ØµØµÛ"
block|,
literal|"ÙÙÙ¾Ø¯ÛØ§"
block|,
literal|"ÙÙØ´ØªÙ"
block|,
literal|"Ø´Ø¯"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testGreek
specifier|public
name|void
name|testGreek
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"ÎÏÎ¬ÏÎµÏÎ±Î¹ ÏÎµ ÏÏÎ½ÎµÏÎ³Î±ÏÎ¯Î± Î±ÏÏ ÎµÎ¸ÎµÎ»Î¿Î½ÏÎ­Ï Î¼Îµ ÏÎ¿ Î»Î¿Î³Î¹ÏÎ¼Î¹ÎºÏ wiki, ÎºÎ¬ÏÎ¹ ÏÎ¿Ï ÏÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÏÏÎ¹ Î¬ÏÎ¸ÏÎ± Î¼ÏÎ¿ÏÎµÎ¯ Î½Î± ÏÏÎ¿ÏÏÎµÎ¸Î¿ÏÎ½ Î® Î½Î± Î±Î»Î»Î¬Î¾Î¿ÏÎ½ Î±ÏÏ ÏÎ¿Î½ ÎºÎ±Î¸Î­Î½Î±."
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ÎÏÎ¬ÏÎµÏÎ±Î¹"
block|,
literal|"ÏÎµ"
block|,
literal|"ÏÏÎ½ÎµÏÎ³Î±ÏÎ¯Î±"
block|,
literal|"Î±ÏÏ"
block|,
literal|"ÎµÎ¸ÎµÎ»Î¿Î½ÏÎ­Ï"
block|,
literal|"Î¼Îµ"
block|,
literal|"ÏÎ¿"
block|,
literal|"Î»Î¿Î³Î¹ÏÎ¼Î¹ÎºÏ"
block|,
literal|"wiki"
block|,
literal|"ÎºÎ¬ÏÎ¹"
block|,
literal|"ÏÎ¿Ï"
block|,
literal|"ÏÎ·Î¼Î±Î¯Î½ÎµÎ¹"
block|,
literal|"ÏÏÎ¹"
block|,
literal|"Î¬ÏÎ¸ÏÎ±"
block|,
literal|"Î¼ÏÎ¿ÏÎµÎ¯"
block|,
literal|"Î½Î±"
block|,
literal|"ÏÏÎ¿ÏÏÎµÎ¸Î¿ÏÎ½"
block|,
literal|"Î®"
block|,
literal|"Î½Î±"
block|,
literal|"Î±Î»Î»Î¬Î¾Î¿ÏÎ½"
block|,
literal|"Î±ÏÏ"
block|,
literal|"ÏÎ¿Î½"
block|,
literal|"ÎºÎ±Î¸Î­Î½Î±"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testThai
specifier|public
name|void
name|testThai
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"à¸à¸²à¸£à¸à¸µà¹à¹à¸à¹à¸à¹à¸­à¸à¹à¸ªà¸à¸à¸§à¹à¸²à¸à¸²à¸à¸à¸µ. à¹à¸¥à¹à¸§à¹à¸à¸­à¸à¸°à¹à¸à¹à¸«à¸? à¹à¹à¹à¹"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"à¸à¸²à¸£à¸à¸µà¹à¹à¸à¹à¸à¹à¸­à¸à¹à¸ªà¸à¸à¸§à¹à¸²à¸à¸²à¸à¸à¸µ"
block|,
literal|"à¹à¸¥à¹à¸§à¹à¸à¸­à¸à¸°à¹à¸à¹à¸«à¸"
block|,
literal|"à¹à¹à¹à¹"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testLao
specifier|public
name|void
name|testLao
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"àºªàº²àºàº²àº¥àº°àºàº°àº¥àº±àº àºàº°àºàº²àºàº´àºàº°à»àº àºàº°àºàº²àºàº»àºàº¥àº²àº§"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"àºªàº²àºàº²àº¥àº°àºàº°àº¥àº±àº"
block|,
literal|"àºàº°àºàº²àºàº´àºàº°à»àº"
block|,
literal|"àºàº°àºàº²àºàº»àºàº¥àº²àº§"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testTibetan
specifier|public
name|void
name|testTibetan
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"à½¦à¾£à½¼à½à¼à½à½à½¼à½à¼à½à½à¼à½£à½¦à¼à½ à½à½²à½¦à¼à½à½¼à½à¼à½¡à½²à½à¼à½à½²à¼à½à½à½¦à¼à½à½¼à½à¼à½ à½à½ºà½£à¼à½à½´à¼à½à½à½¼à½à¼à½à½¢à¼à½§à¼à½à½à¼à½à½à½ºà¼à½à½à½à¼à½à½à½²à½¦à¼à½¦à½¼à¼ à¼"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"à½¦à¾£à½¼à½"
block|,
literal|"à½à½à½¼à½"
block|,
literal|"à½à½"
block|,
literal|"à½£à½¦"
block|,
literal|"à½ à½à½²à½¦"
block|,
literal|"à½à½¼à½"
block|,
literal|"à½¡à½²à½"
block|,
literal|"à½à½²"
block|,
literal|"à½à½à½¦"
block|,
literal|"à½à½¼à½"
block|,
literal|"à½ à½à½ºà½£"
block|,
literal|"à½à½´"
block|,
literal|"à½à½à½¼à½"
block|,
literal|"à½à½¢"
block|,
literal|"à½§"
block|,
literal|"à½à½"
block|,
literal|"à½à½à½º"
block|,
literal|"à½à½à½"
block|,
literal|"à½à½à½²à½¦"
block|,
literal|"à½¦à½¼"
block|}
argument_list|)
expr_stmt|;
block|}
comment|/*    * For chinese, tokenize as char (these can later form bigrams or whatever)    */
DECL|method|testChinese
specifier|public
name|void
name|testChinese
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"ææ¯ä¸­å½äººã ï¼ï¼ï¼ï¼ ï¼´ï½ï½ï½ï½ "
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"æ"
block|,
literal|"æ¯"
block|,
literal|"ä¸­"
block|,
literal|"å½"
block|,
literal|"äºº"
block|,
literal|"ï¼ï¼ï¼ï¼"
block|,
literal|"ï¼´ï½ï½ï½ï½"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testEmpty
specifier|public
name|void
name|testEmpty
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|""
argument_list|,
operator|new
name|String
index|[]
block|{}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"."
argument_list|,
operator|new
name|String
index|[]
block|{}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|" "
argument_list|,
operator|new
name|String
index|[]
block|{}
argument_list|)
expr_stmt|;
block|}
comment|/* test various jira issues this analyzer is related to */
DECL|method|testLUCENE1545
specifier|public
name|void
name|testLUCENE1545
parameter_list|()
throws|throws
name|Exception
block|{
comment|/*      * Standard analyzer does not correctly tokenize combining character U+0364 COMBINING LATIN SMALL LETTRE E.      * The word "moÍ¤chte" is incorrectly tokenized into "mo" "chte", the combining character is lost.      * Expected result is only on token "moÍ¤chte".      */
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"moÍ¤chte"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"moÍ¤chte"
block|}
argument_list|)
expr_stmt|;
block|}
comment|/* Tests from StandardAnalyzer, just to show behavior is similar */
DECL|method|testAlphanumericSA
specifier|public
name|void
name|testAlphanumericSA
parameter_list|()
throws|throws
name|Exception
block|{
comment|// alphanumeric tokens
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"B2B"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"B2B"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"2B"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"2B"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testDelimitersSA
specifier|public
name|void
name|testDelimitersSA
parameter_list|()
throws|throws
name|Exception
block|{
comment|// other delimiters: "-", "/", ","
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"some-dashed-phrase"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"some"
block|,
literal|"dashed"
block|,
literal|"phrase"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"dogs,chase,cats"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"dogs"
block|,
literal|"chase"
block|,
literal|"cats"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"ac/dc"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ac"
block|,
literal|"dc"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testApostrophesSA
specifier|public
name|void
name|testApostrophesSA
parameter_list|()
throws|throws
name|Exception
block|{
comment|// internal apostrophes: O'Reilly, you're, O'Reilly's
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"O'Reilly"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"O'Reilly"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"you're"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"you're"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"she's"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"she's"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"Jim's"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"Jim's"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"don't"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"don't"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"O'Reilly's"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"O'Reilly's"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testNumericSA
specifier|public
name|void
name|testNumericSA
parameter_list|()
throws|throws
name|Exception
block|{
comment|// floating point, serial, model numbers, ip addresses, etc.
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"21.35"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"21.35"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"R2D2 C3PO"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"R2D2"
block|,
literal|"C3PO"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"216.239.63.104"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"216.239.63.104"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testTextWithNumbersSA
specifier|public
name|void
name|testTextWithNumbersSA
parameter_list|()
throws|throws
name|Exception
block|{
comment|// numbers
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"David has 5000 bones"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"David"
block|,
literal|"has"
block|,
literal|"5000"
block|,
literal|"bones"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testVariousTextSA
specifier|public
name|void
name|testVariousTextSA
parameter_list|()
throws|throws
name|Exception
block|{
comment|// various
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"C embedded developers wanted"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"C"
block|,
literal|"embedded"
block|,
literal|"developers"
block|,
literal|"wanted"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"foo bar FOO BAR"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"foo"
block|,
literal|"bar"
block|,
literal|"FOO"
block|,
literal|"BAR"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"foo      bar .  FOO<> BAR"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"foo"
block|,
literal|"bar"
block|,
literal|"FOO"
block|,
literal|"BAR"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"\"QUOTED\" word"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"QUOTED"
block|,
literal|"word"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testKoreanSA
specifier|public
name|void
name|testKoreanSA
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Korean words
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"ìëíì¸ì íê¸ìëë¤"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ìëíì¸ì"
block|,
literal|"íê¸ìëë¤"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testOffsets
specifier|public
name|void
name|testOffsets
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"David has 5000 bones"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"David"
block|,
literal|"has"
block|,
literal|"5000"
block|,
literal|"bones"
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|6
block|,
literal|10
block|,
literal|15
block|}
argument_list|,
operator|new
name|int
index|[]
block|{
literal|5
block|,
literal|9
block|,
literal|14
block|,
literal|20
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testTypes
specifier|public
name|void
name|testTypes
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"David has 5000 bones"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"David"
block|,
literal|"has"
block|,
literal|"5000"
block|,
literal|"bones"
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"<ALPHANUM>"
block|,
literal|"<ALPHANUM>"
block|,
literal|"<NUM>"
block|,
literal|"<ALPHANUM>"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testWikiURLs
specifier|public
name|void
name|testWikiURLs
parameter_list|()
throws|throws
name|Exception
block|{
name|Reader
name|reader
init|=
literal|null
decl_stmt|;
name|String
name|luceneResourcesWikiPage
decl_stmt|;
try|try
block|{
name|reader
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|getClass
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
literal|"LuceneResourcesWikiPage.html"
argument_list|)
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
expr_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|char
index|[]
name|buffer
init|=
operator|new
name|char
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|numCharsRead
decl_stmt|;
while|while
condition|(
operator|-
literal|1
operator|!=
operator|(
name|numCharsRead
operator|=
name|reader
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|numCharsRead
argument_list|)
expr_stmt|;
block|}
name|luceneResourcesWikiPage
operator|=
name|builder
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
literal|null
operator|!=
name|reader
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
literal|null
operator|!=
name|luceneResourcesWikiPage
operator|&&
name|luceneResourcesWikiPage
operator|.
name|length
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|BufferedReader
name|bufferedReader
init|=
literal|null
decl_stmt|;
name|String
index|[]
name|urls
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|urlList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|bufferedReader
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|getClass
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
literal|"LuceneResourcesWikiPageURLs.txt"
argument_list|)
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|line
decl_stmt|;
while|while
condition|(
literal|null
operator|!=
operator|(
name|line
operator|=
name|bufferedReader
operator|.
name|readLine
argument_list|()
operator|)
condition|)
block|{
name|line
operator|=
name|line
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|urlList
operator|.
name|add
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
name|urls
operator|=
name|urlList
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|urlList
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
literal|null
operator|!=
name|bufferedReader
condition|)
block|{
name|bufferedReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
literal|null
operator|!=
name|urls
operator|&&
name|urls
operator|.
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|urlAnalyzer
argument_list|,
name|luceneResourcesWikiPage
argument_list|,
name|urls
argument_list|)
expr_stmt|;
block|}
DECL|method|testEmails
specifier|public
name|void
name|testEmails
parameter_list|()
throws|throws
name|Exception
block|{
name|Reader
name|reader
init|=
literal|null
decl_stmt|;
name|String
name|randomTextWithEmails
decl_stmt|;
try|try
block|{
name|reader
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|getClass
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
literal|"random.text.with.email.addresses.txt"
argument_list|)
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
expr_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|char
index|[]
name|buffer
init|=
operator|new
name|char
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|numCharsRead
decl_stmt|;
while|while
condition|(
operator|-
literal|1
operator|!=
operator|(
name|numCharsRead
operator|=
name|reader
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|numCharsRead
argument_list|)
expr_stmt|;
block|}
name|randomTextWithEmails
operator|=
name|builder
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
literal|null
operator|!=
name|reader
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
literal|null
operator|!=
name|randomTextWithEmails
operator|&&
name|randomTextWithEmails
operator|.
name|length
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|BufferedReader
name|bufferedReader
init|=
literal|null
decl_stmt|;
name|String
index|[]
name|emails
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|emailList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|bufferedReader
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|getClass
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
literal|"email.addresses.from.random.text.with.email.addresses.txt"
argument_list|)
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|line
decl_stmt|;
while|while
condition|(
literal|null
operator|!=
operator|(
name|line
operator|=
name|bufferedReader
operator|.
name|readLine
argument_list|()
operator|)
condition|)
block|{
name|line
operator|=
name|line
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|emailList
operator|.
name|add
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
name|emails
operator|=
name|emailList
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|emailList
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
literal|null
operator|!=
name|bufferedReader
condition|)
block|{
name|bufferedReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
literal|null
operator|!=
name|emails
operator|&&
name|emails
operator|.
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|emailAnalyzer
argument_list|,
name|randomTextWithEmails
argument_list|,
name|emails
argument_list|)
expr_stmt|;
block|}
DECL|method|testMailtoSchemeEmails
specifier|public
name|void
name|testMailtoSchemeEmails
parameter_list|()
throws|throws
name|Exception
block|{
comment|// See LUCENE-3880
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"mailto:test@example.org"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"mailto"
block|,
literal|"test@example.org"
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"<ALPHANUM>"
block|,
literal|"<EMAIL>"
block|}
argument_list|)
expr_stmt|;
comment|// TODO: Support full mailto: scheme URIs. See RFC 6068: http://tools.ietf.org/html/rfc6068
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"mailto:personA@example.com,personB@example.com?cc=personC@example.com"
operator|+
literal|"&subject=Subjectivity&body=Corpusivity%20or%20something%20like%20that"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"mailto"
block|,
literal|"personA@example.com"
block|,
comment|// TODO: recognize ',' address delimiter. Also, see examples of ';' delimiter use at: http://www.mailto.co.uk/
literal|",personB@example.com"
block|,
literal|"?cc=personC@example.com"
block|,
comment|// TODO: split field keys/values
literal|"subject"
block|,
literal|"Subjectivity"
block|,
literal|"body"
block|,
literal|"Corpusivity"
block|,
literal|"20or"
block|,
literal|"20something"
block|,
literal|"20like"
block|,
literal|"20that"
block|}
argument_list|,
comment|// TODO: Hex decoding + re-tokenization
operator|new
name|String
index|[]
block|{
literal|"<ALPHANUM>"
block|,
literal|"<EMAIL>"
block|,
literal|"<EMAIL>"
block|,
literal|"<EMAIL>"
block|,
literal|"<ALPHANUM>"
block|,
literal|"<ALPHANUM>"
block|,
literal|"<ALPHANUM>"
block|,
literal|"<ALPHANUM>"
block|,
literal|"<ALPHANUM>"
block|,
literal|"<ALPHANUM>"
block|,
literal|"<ALPHANUM>"
block|,
literal|"<ALPHANUM>"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testURLs
specifier|public
name|void
name|testURLs
parameter_list|()
throws|throws
name|Exception
block|{
name|Reader
name|reader
init|=
literal|null
decl_stmt|;
name|String
name|randomTextWithURLs
decl_stmt|;
try|try
block|{
name|reader
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|getClass
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
literal|"random.text.with.urls.txt"
argument_list|)
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
expr_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|char
index|[]
name|buffer
init|=
operator|new
name|char
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|numCharsRead
decl_stmt|;
while|while
condition|(
operator|-
literal|1
operator|!=
operator|(
name|numCharsRead
operator|=
name|reader
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|numCharsRead
argument_list|)
expr_stmt|;
block|}
name|randomTextWithURLs
operator|=
name|builder
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
literal|null
operator|!=
name|reader
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
literal|null
operator|!=
name|randomTextWithURLs
operator|&&
name|randomTextWithURLs
operator|.
name|length
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|BufferedReader
name|bufferedReader
init|=
literal|null
decl_stmt|;
name|String
index|[]
name|urls
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|urlList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|bufferedReader
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|getClass
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
literal|"urls.from.random.text.with.urls.txt"
argument_list|)
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|line
decl_stmt|;
while|while
condition|(
literal|null
operator|!=
operator|(
name|line
operator|=
name|bufferedReader
operator|.
name|readLine
argument_list|()
operator|)
condition|)
block|{
name|line
operator|=
name|line
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|urlList
operator|.
name|add
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
name|urls
operator|=
name|urlList
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|urlList
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
literal|null
operator|!=
name|bufferedReader
condition|)
block|{
name|bufferedReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
literal|null
operator|!=
name|urls
operator|&&
name|urls
operator|.
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|urlAnalyzer
argument_list|,
name|randomTextWithURLs
argument_list|,
name|urls
argument_list|)
expr_stmt|;
block|}
DECL|method|testUnicodeWordBreaks
specifier|public
name|void
name|testUnicodeWordBreaks
parameter_list|()
throws|throws
name|Exception
block|{
name|WordBreakTestUnicode_6_3_0
name|wordBreakTest
init|=
operator|new
name|WordBreakTestUnicode_6_3_0
argument_list|()
decl_stmt|;
name|wordBreakTest
operator|.
name|test
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
DECL|method|testSupplementary
specifier|public
name|void
name|testSupplementary
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"ð©¬è±éä¹æ¯ç"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ð©¬"
block|,
literal|"è±"
block|,
literal|"é"
block|,
literal|"ä¹"
block|,
literal|"æ¯"
block|,
literal|"ç"
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"<IDEOGRAPHIC>"
block|,
literal|"<IDEOGRAPHIC>"
block|,
literal|"<IDEOGRAPHIC>"
block|,
literal|"<IDEOGRAPHIC>"
block|,
literal|"<IDEOGRAPHIC>"
block|,
literal|"<IDEOGRAPHIC>"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testKorean
specifier|public
name|void
name|testKorean
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"íë¯¼ì ì"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"íë¯¼ì ì"
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"<HANGUL>"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testJapanese
specifier|public
name|void
name|testJapanese
parameter_list|()
throws|throws
name|Exception
block|{
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"ä»®åé£ã ã«ã¿ã«ã"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ä»®"
block|,
literal|"å"
block|,
literal|"é£"
block|,
literal|"ã"
block|,
literal|"ã«ã¿ã«ã"
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"<IDEOGRAPHIC>"
block|,
literal|"<IDEOGRAPHIC>"
block|,
literal|"<IDEOGRAPHIC>"
block|,
literal|"<HIRAGANA>"
block|,
literal|"<KATAKANA>"
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|testCombiningMarks
specifier|public
name|void
name|testCombiningMarks
parameter_list|()
throws|throws
name|Exception
block|{
name|checkOneTerm
argument_list|(
name|a
argument_list|,
literal|"ãã"
argument_list|,
literal|"ãã"
argument_list|)
expr_stmt|;
comment|// hiragana
name|checkOneTerm
argument_list|(
name|a
argument_list|,
literal|"ãµã"
argument_list|,
literal|"ãµã"
argument_list|)
expr_stmt|;
comment|// katakana
name|checkOneTerm
argument_list|(
name|a
argument_list|,
literal|"å£¹ã"
argument_list|,
literal|"å£¹ã"
argument_list|)
expr_stmt|;
comment|// ideographic
name|checkOneTerm
argument_list|(
name|a
argument_list|,
literal|"ìã"
argument_list|,
literal|"ìã"
argument_list|)
expr_stmt|;
comment|// hangul
block|}
comment|/**    * Multiple consecutive chars in \p{Word_Break = MidLetter},    * \p{Word_Break = MidNumLet}, and/or \p{Word_Break = MidNum}    * should trigger a token split.    */
DECL|method|testMid
specifier|public
name|void
name|testMid
parameter_list|()
throws|throws
name|Exception
block|{
comment|// ':' is in \p{WB:MidLetter}, which should trigger a split unless there is a Letter char on both sides
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"A:B"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"A:B"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"A::B"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"A"
block|,
literal|"B"
block|}
argument_list|)
expr_stmt|;
comment|// '.' is in \p{WB:MidNumLet}, which should trigger a split unless there is a Letter or Numeric char on both sides
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"1.2"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"1.2"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"A.B"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"A.B"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"1..2"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"1"
block|,
literal|"2"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"A..B"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"A"
block|,
literal|"B"
block|}
argument_list|)
expr_stmt|;
comment|// ',' is in \p{WB:MidNum}, which should trigger a split unless there is a Numeric char on both sides
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"1,2"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"1,2"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"1,,2"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"1"
block|,
literal|"2"
block|}
argument_list|)
expr_stmt|;
comment|// Mixed consecutive \p{WB:MidLetter} and \p{WB:MidNumLet} should trigger a split
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"A.:B"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"A"
block|,
literal|"B"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"A:.B"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"A"
block|,
literal|"B"
block|}
argument_list|)
expr_stmt|;
comment|// Mixed consecutive \p{WB:MidNum} and \p{WB:MidNumLet} should trigger a split
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"1,.2"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"1"
block|,
literal|"2"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"1.,2"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"1"
block|,
literal|"2"
block|}
argument_list|)
expr_stmt|;
comment|// '_' is in \p{WB:ExtendNumLet}
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"A:B_A:B"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"A:B_A:B"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"A:B_A::B"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"A:B_A"
block|,
literal|"B"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"1.2_1.2"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"1.2_1.2"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"A.B_A.B"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"A.B_A.B"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"1.2_1..2"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"1.2_1"
block|,
literal|"2"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"A.B_A..B"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"A.B_A"
block|,
literal|"B"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"1,2_1,2"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"1,2_1,2"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"1,2_1,,2"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"1,2_1"
block|,
literal|"2"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"C_A.:B"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"C_A"
block|,
literal|"B"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"C_A:.B"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"C_A"
block|,
literal|"B"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"3_1,.2"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"3_1"
block|,
literal|"2"
block|}
argument_list|)
expr_stmt|;
name|BaseTokenStreamTestCase
operator|.
name|assertAnalyzesTo
argument_list|(
name|a
argument_list|,
literal|"3_1.,2"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"3_1"
block|,
literal|"2"
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** blast some random strings through the analyzer */
DECL|method|testRandomStrings
specifier|public
name|void
name|testRandomStrings
parameter_list|()
throws|throws
name|Exception
block|{
name|checkRandomData
argument_list|(
name|random
argument_list|()
argument_list|,
name|a
argument_list|,
literal|1000
operator|*
name|RANDOM_MULTIPLIER
argument_list|)
expr_stmt|;
block|}
comment|/** blast some random large strings through the analyzer */
DECL|method|testRandomHugeStrings
specifier|public
name|void
name|testRandomHugeStrings
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
name|checkRandomData
argument_list|(
name|random
argument_list|,
name|a
argument_list|,
literal|100
operator|*
name|RANDOM_MULTIPLIER
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
block|}
block|}
end_class
end_unit
