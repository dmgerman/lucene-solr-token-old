begin_unit
begin_package
DECL|package|org.apache.lucene.analysis.core
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|core
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import
begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|CharBuffer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|DirectoryStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|BaseTokenStreamTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|CachingTokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|CharFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|CrankyTokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockGraphTokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockRandomLookaheadTokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockTokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockTokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Tokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|ValidatingTokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|charfilter
operator|.
name|NormalizeCharMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|cjk
operator|.
name|CJKBigramFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|commongrams
operator|.
name|CommonGramsFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|commongrams
operator|.
name|CommonGramsQueryFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|compound
operator|.
name|HyphenationCompoundWordTokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|compound
operator|.
name|TestCompoundWordTokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|compound
operator|.
name|hyphenation
operator|.
name|HyphenationTree
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|hunspell
operator|.
name|Dictionary
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|hunspell
operator|.
name|TestHunspellStemFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|miscellaneous
operator|.
name|HyphenatedWordsFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|miscellaneous
operator|.
name|LimitTokenCountFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|miscellaneous
operator|.
name|LimitTokenPositionFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|miscellaneous
operator|.
name|StemmerOverrideFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|miscellaneous
operator|.
name|StemmerOverrideFilter
operator|.
name|StemmerOverrideMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|miscellaneous
operator|.
name|WordDelimiterFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|path
operator|.
name|PathHierarchyTokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|path
operator|.
name|ReversePathHierarchyTokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|payloads
operator|.
name|IdentityEncoder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|payloads
operator|.
name|PayloadEncoder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|snowball
operator|.
name|TestSnowball
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|standard
operator|.
name|StandardTokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|synonym
operator|.
name|SynonymMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|CharArrayMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|CharArraySet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|wikipedia
operator|.
name|WikipediaTokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|AttributeFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|AttributeSource
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CharsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Rethrow
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|CharacterRunAutomaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|AfterClass
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import
begin_import
import|import
name|org
operator|.
name|tartarus
operator|.
name|snowball
operator|.
name|SnowballProgram
import|;
end_import
begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|InputSource
import|;
end_import
begin_comment
comment|/** tests random analysis chains */
end_comment
begin_class
DECL|class|TestRandomChains
specifier|public
class|class
name|TestRandomChains
extends|extends
name|BaseTokenStreamTestCase
block|{
DECL|field|tokenizers
specifier|static
name|List
argument_list|<
name|Constructor
argument_list|<
name|?
extends|extends
name|Tokenizer
argument_list|>
argument_list|>
name|tokenizers
decl_stmt|;
DECL|field|tokenfilters
specifier|static
name|List
argument_list|<
name|Constructor
argument_list|<
name|?
extends|extends
name|TokenFilter
argument_list|>
argument_list|>
name|tokenfilters
decl_stmt|;
DECL|field|charfilters
specifier|static
name|List
argument_list|<
name|Constructor
argument_list|<
name|?
extends|extends
name|CharFilter
argument_list|>
argument_list|>
name|charfilters
decl_stmt|;
DECL|interface|Predicate
specifier|private
specifier|static
interface|interface
name|Predicate
parameter_list|<
name|T
parameter_list|>
block|{
DECL|method|apply
name|boolean
name|apply
parameter_list|(
name|T
name|o
parameter_list|)
function_decl|;
block|}
DECL|field|ALWAYS
specifier|private
specifier|static
specifier|final
name|Predicate
argument_list|<
name|Object
index|[]
argument_list|>
name|ALWAYS
init|=
operator|new
name|Predicate
argument_list|<
name|Object
index|[]
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|apply
parameter_list|(
name|Object
index|[]
name|args
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
empty_stmt|;
block|}
decl_stmt|;
DECL|field|brokenConstructors
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Constructor
argument_list|<
name|?
argument_list|>
argument_list|,
name|Predicate
argument_list|<
name|Object
index|[]
argument_list|>
argument_list|>
name|brokenConstructors
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
static|static
block|{
try|try
block|{
name|brokenConstructors
operator|.
name|put
argument_list|(
name|LimitTokenCountFilter
operator|.
name|class
operator|.
name|getConstructor
argument_list|(
name|TokenStream
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|)
argument_list|,
name|ALWAYS
argument_list|)
expr_stmt|;
name|brokenConstructors
operator|.
name|put
argument_list|(
name|LimitTokenCountFilter
operator|.
name|class
operator|.
name|getConstructor
argument_list|(
name|TokenStream
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|boolean
operator|.
name|class
argument_list|)
argument_list|,
operator|new
name|Predicate
argument_list|<
name|Object
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Object
index|[]
name|args
parameter_list|)
block|{
assert|assert
name|args
operator|.
name|length
operator|==
literal|3
assert|;
return|return
operator|!
operator|(
operator|(
name|Boolean
operator|)
name|args
index|[
literal|2
index|]
operator|)
return|;
comment|// args are broken if consumeAllTokens is false
block|}
block|}
argument_list|)
expr_stmt|;
name|brokenConstructors
operator|.
name|put
argument_list|(
name|LimitTokenPositionFilter
operator|.
name|class
operator|.
name|getConstructor
argument_list|(
name|TokenStream
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|)
argument_list|,
name|ALWAYS
argument_list|)
expr_stmt|;
name|brokenConstructors
operator|.
name|put
argument_list|(
name|LimitTokenPositionFilter
operator|.
name|class
operator|.
name|getConstructor
argument_list|(
name|TokenStream
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|boolean
operator|.
name|class
argument_list|)
argument_list|,
operator|new
name|Predicate
argument_list|<
name|Object
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Object
index|[]
name|args
parameter_list|)
block|{
assert|assert
name|args
operator|.
name|length
operator|==
literal|3
assert|;
return|return
operator|!
operator|(
operator|(
name|Boolean
operator|)
name|args
index|[
literal|2
index|]
operator|)
return|;
comment|// args are broken if consumeAllTokens is false
block|}
block|}
argument_list|)
expr_stmt|;
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|c
range|:
name|Arrays
operator|.
expr|<
name|Class
argument_list|<
name|?
argument_list|>
operator|>
name|asList
argument_list|(
comment|// TODO: can we promote some of these to be only
comment|// offsets offenders?
comment|// doesn't actual reset itself!
name|CachingTokenFilter
operator|.
name|class
argument_list|,
comment|// Not broken, simulates brokenness:
name|CrankyTokenFilter
operator|.
name|class
argument_list|,
comment|// Not broken: we forcefully add this, so we shouldn't
comment|// also randomly pick it:
name|ValidatingTokenFilter
operator|.
name|class
argument_list|,
comment|// TODO: needs to be a tokenizer, doesnt handle graph inputs properly (a shingle or similar following will then cause pain)
name|WordDelimiterFilter
operator|.
name|class
argument_list|)
control|)
block|{
for|for
control|(
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
range|:
name|c
operator|.
name|getConstructors
argument_list|()
control|)
block|{
name|brokenConstructors
operator|.
name|put
argument_list|(
name|ctor
argument_list|,
name|ALWAYS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|// TODO: also fix these and remove (maybe):
comment|// Classes/options that don't produce consistent graph offsets:
DECL|field|brokenOffsetsConstructors
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Constructor
argument_list|<
name|?
argument_list|>
argument_list|,
name|Predicate
argument_list|<
name|Object
index|[]
argument_list|>
argument_list|>
name|brokenOffsetsConstructors
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
static|static
block|{
try|try
block|{
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|c
range|:
name|Arrays
operator|.
expr|<
name|Class
argument_list|<
name|?
argument_list|>
operator|>
name|asList
argument_list|(
name|ReversePathHierarchyTokenizer
operator|.
name|class
argument_list|,
name|PathHierarchyTokenizer
operator|.
name|class
argument_list|,
comment|// TODO: it seems to mess up offsets!?
name|WikipediaTokenizer
operator|.
name|class
argument_list|,
comment|// TODO: doesn't handle graph inputs
name|CJKBigramFilter
operator|.
name|class
argument_list|,
comment|// TODO: doesn't handle graph inputs (or even look at positionIncrement)
name|HyphenatedWordsFilter
operator|.
name|class
argument_list|,
comment|// TODO: LUCENE-4983
name|CommonGramsFilter
operator|.
name|class
argument_list|,
comment|// TODO: doesn't handle graph inputs
name|CommonGramsQueryFilter
operator|.
name|class
argument_list|)
control|)
block|{
for|for
control|(
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
range|:
name|c
operator|.
name|getConstructors
argument_list|()
control|)
block|{
name|brokenOffsetsConstructors
operator|.
name|put
argument_list|(
name|ctor
argument_list|,
name|ALWAYS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|BeforeClass
DECL|method|beforeClass
specifier|public
specifier|static
name|void
name|beforeClass
parameter_list|()
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|analysisClasses
init|=
name|getClassesForPackage
argument_list|(
literal|"org.apache.lucene.analysis"
argument_list|)
decl_stmt|;
name|tokenizers
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|tokenfilters
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|charfilters
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|c
range|:
name|analysisClasses
control|)
block|{
specifier|final
name|int
name|modifiers
init|=
name|c
operator|.
name|getModifiers
argument_list|()
decl_stmt|;
if|if
condition|(
comment|// don't waste time with abstract classes or deprecated known-buggy ones
name|Modifier
operator|.
name|isAbstract
argument_list|(
name|modifiers
argument_list|)
operator|||
operator|!
name|Modifier
operator|.
name|isPublic
argument_list|(
name|modifiers
argument_list|)
operator|||
name|c
operator|.
name|isSynthetic
argument_list|()
operator|||
name|c
operator|.
name|isAnonymousClass
argument_list|()
operator|||
name|c
operator|.
name|isMemberClass
argument_list|()
operator|||
name|c
operator|.
name|isInterface
argument_list|()
operator|||
name|c
operator|.
name|isAnnotationPresent
argument_list|(
name|Deprecated
operator|.
name|class
argument_list|)
operator|||
operator|!
operator|(
name|Tokenizer
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
operator|||
name|TokenFilter
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
operator|||
name|CharFilter
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
for|for
control|(
specifier|final
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
range|:
name|c
operator|.
name|getConstructors
argument_list|()
control|)
block|{
comment|// don't test synthetic or deprecated ctors, they likely have known bugs:
if|if
condition|(
name|ctor
operator|.
name|isSynthetic
argument_list|()
operator|||
name|ctor
operator|.
name|isAnnotationPresent
argument_list|(
name|Deprecated
operator|.
name|class
argument_list|)
operator|||
name|brokenConstructors
operator|.
name|get
argument_list|(
name|ctor
argument_list|)
operator|==
name|ALWAYS
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|Tokenizer
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|assertTrue
argument_list|(
name|ctor
operator|.
name|toGenericString
argument_list|()
operator|+
literal|" has unsupported parameter types"
argument_list|,
name|allowedTokenizerArgs
operator|.
name|containsAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|ctor
operator|.
name|getParameterTypes
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tokenizers
operator|.
name|add
argument_list|(
name|castConstructor
argument_list|(
name|Tokenizer
operator|.
name|class
argument_list|,
name|ctor
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TokenFilter
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|assertTrue
argument_list|(
name|ctor
operator|.
name|toGenericString
argument_list|()
operator|+
literal|" has unsupported parameter types"
argument_list|,
name|allowedTokenFilterArgs
operator|.
name|containsAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|ctor
operator|.
name|getParameterTypes
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tokenfilters
operator|.
name|add
argument_list|(
name|castConstructor
argument_list|(
name|TokenFilter
operator|.
name|class
argument_list|,
name|ctor
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CharFilter
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|assertTrue
argument_list|(
name|ctor
operator|.
name|toGenericString
argument_list|()
operator|+
literal|" has unsupported parameter types"
argument_list|,
name|allowedCharFilterArgs
operator|.
name|containsAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|ctor
operator|.
name|getParameterTypes
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|charfilters
operator|.
name|add
argument_list|(
name|castConstructor
argument_list|(
name|CharFilter
operator|.
name|class
argument_list|,
name|ctor
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fail
argument_list|(
literal|"Cannot get here"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|final
name|Comparator
argument_list|<
name|Constructor
argument_list|<
name|?
argument_list|>
argument_list|>
name|ctorComp
init|=
operator|new
name|Comparator
argument_list|<
name|Constructor
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Constructor
argument_list|<
name|?
argument_list|>
name|arg0
parameter_list|,
name|Constructor
argument_list|<
name|?
argument_list|>
name|arg1
parameter_list|)
block|{
return|return
name|arg0
operator|.
name|toGenericString
argument_list|()
operator|.
name|compareTo
argument_list|(
name|arg1
operator|.
name|toGenericString
argument_list|()
argument_list|)
return|;
block|}
block|}
empty_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|tokenizers
argument_list|,
name|ctorComp
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|tokenfilters
argument_list|,
name|ctorComp
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|charfilters
argument_list|,
name|ctorComp
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"tokenizers = "
operator|+
name|tokenizers
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"tokenfilters = "
operator|+
name|tokenfilters
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"charfilters = "
operator|+
name|charfilters
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|AfterClass
DECL|method|afterClass
specifier|public
specifier|static
name|void
name|afterClass
parameter_list|()
block|{
name|tokenizers
operator|=
literal|null
expr_stmt|;
name|tokenfilters
operator|=
literal|null
expr_stmt|;
name|charfilters
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Hack to work around the stupidness of Oracle's strict Java backwards compatibility.    * {@code Class<T>#getConstructors()} should return unmodifiable {@code List<Constructor<T>>} not array! */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|castConstructor
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Constructor
argument_list|<
name|T
argument_list|>
name|castConstructor
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|instanceClazz
parameter_list|,
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
parameter_list|)
block|{
return|return
operator|(
name|Constructor
argument_list|<
name|T
argument_list|>
operator|)
name|ctor
return|;
block|}
DECL|method|getClassesForPackage
specifier|public
specifier|static
name|List
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|getClassesForPackage
parameter_list|(
name|String
name|pckgname
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|List
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|classes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|collectClassesForPackage
argument_list|(
name|pckgname
argument_list|,
name|classes
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"No classes found in package '"
operator|+
name|pckgname
operator|+
literal|"'; maybe your test classes are packaged as JAR file?"
argument_list|,
name|classes
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|classes
return|;
block|}
DECL|method|collectClassesForPackage
specifier|private
specifier|static
name|void
name|collectClassesForPackage
parameter_list|(
name|String
name|pckgname
parameter_list|,
name|List
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|classes
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|ClassLoader
name|cld
init|=
name|TestRandomChains
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
decl_stmt|;
specifier|final
name|String
name|path
init|=
name|pckgname
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
specifier|final
name|Enumeration
argument_list|<
name|URL
argument_list|>
name|resources
init|=
name|cld
operator|.
name|getResources
argument_list|(
name|path
argument_list|)
decl_stmt|;
while|while
condition|(
name|resources
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
specifier|final
name|URI
name|uri
init|=
name|resources
operator|.
name|nextElement
argument_list|()
operator|.
name|toURI
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
literal|"file"
operator|.
name|equalsIgnoreCase
argument_list|(
name|uri
operator|.
name|getScheme
argument_list|()
argument_list|)
condition|)
continue|continue;
specifier|final
name|Path
name|directory
init|=
name|Paths
operator|.
name|get
argument_list|(
name|uri
argument_list|)
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|directory
argument_list|)
condition|)
block|{
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|directory
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|file
range|:
name|stream
control|)
block|{
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|file
argument_list|)
condition|)
block|{
comment|// recurse
name|String
name|subPackage
init|=
name|pckgname
operator|+
literal|"."
operator|+
name|file
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|collectClassesForPackage
argument_list|(
name|subPackage
argument_list|,
name|classes
argument_list|)
expr_stmt|;
block|}
name|String
name|fname
init|=
name|file
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|fname
operator|.
name|endsWith
argument_list|(
literal|".class"
argument_list|)
condition|)
block|{
name|String
name|clazzName
init|=
name|fname
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|fname
operator|.
name|length
argument_list|()
operator|-
literal|6
argument_list|)
decl_stmt|;
comment|// exclude Test classes that happen to be in these packages.
comment|// class.ForName'ing some of them can cause trouble.
if|if
condition|(
operator|!
name|clazzName
operator|.
name|endsWith
argument_list|(
literal|"Test"
argument_list|)
operator|&&
operator|!
name|clazzName
operator|.
name|startsWith
argument_list|(
literal|"Test"
argument_list|)
condition|)
block|{
comment|// Don't run static initializers, as we won't use most of them.
comment|// Java will do that automatically once accessed/instantiated.
name|classes
operator|.
name|add
argument_list|(
name|Class
operator|.
name|forName
argument_list|(
name|pckgname
operator|+
literal|'.'
operator|+
name|clazzName
argument_list|,
literal|false
argument_list|,
name|cld
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
DECL|interface|ArgProducer
specifier|private
specifier|static
interface|interface
name|ArgProducer
block|{
DECL|method|create
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
function_decl|;
block|}
DECL|field|argProducers
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ArgProducer
argument_list|>
name|argProducers
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|ArgProducer
argument_list|>
argument_list|()
block|{
block|{
name|put
argument_list|(
name|int
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
comment|// TODO: could cause huge ram usage to use full int range for some filters
comment|// (e.g. allocate enormous arrays)
comment|// return Integer.valueOf(random.nextInt());
return|return
name|Integer
operator|.
name|valueOf
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
operator|-
literal|50
argument_list|,
literal|50
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|char
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
comment|// TODO: fix any filters that care to throw IAE instead.
comment|// also add a unicode validating filter to validate termAtt?
comment|// return Character.valueOf((char)random.nextInt(65536));
while|while
condition|(
literal|true
condition|)
block|{
name|char
name|c
init|=
operator|(
name|char
operator|)
name|random
operator|.
name|nextInt
argument_list|(
literal|65536
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
argument_list|<
literal|'\uD800'
operator|||
name|c
argument_list|>
literal|'\uDFFF'
condition|)
block|{
return|return
name|Character
operator|.
name|valueOf
argument_list|(
name|c
argument_list|)
return|;
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|float
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
return|return
name|Float
operator|.
name|valueOf
argument_list|(
name|random
operator|.
name|nextFloat
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|boolean
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|byte
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
comment|// this wraps to negative when casting to byte
return|return
name|Byte
operator|.
name|valueOf
argument_list|(
operator|(
name|byte
operator|)
name|random
operator|.
name|nextInt
argument_list|(
literal|256
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|byte
index|[]
operator|.
expr|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|byte
name|bytes
index|[]
init|=
operator|new
name|byte
index|[
name|random
operator|.
name|nextInt
argument_list|(
literal|256
argument_list|)
index|]
decl_stmt|;
name|random
operator|.
name|nextBytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
return|return
name|bytes
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|Random
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
return|return
operator|new
name|Random
argument_list|(
name|random
operator|.
name|nextLong
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|Version
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
comment|// we expect bugs in emulating old versions
return|return
name|Version
operator|.
name|LATEST
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|AttributeFactory
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
return|return
name|newAttributeFactory
argument_list|(
name|random
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|Set
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
comment|// TypeTokenFilter
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|num
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|set
operator|.
name|add
argument_list|(
name|StandardTokenizer
operator|.
name|TOKEN_TYPES
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|StandardTokenizer
operator|.
name|TOKEN_TYPES
operator|.
name|length
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|Collection
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
comment|// CapitalizationFilter
name|Collection
argument_list|<
name|char
index|[]
argument_list|>
name|col
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|num
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|col
operator|.
name|add
argument_list|(
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|)
operator|.
name|toCharArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|col
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|CharArraySet
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|int
name|num
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|CharArraySet
name|set
init|=
operator|new
name|CharArraySet
argument_list|(
name|num
argument_list|,
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|// TODO: make nastier
name|set
operator|.
name|add
argument_list|(
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|Pattern
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
comment|// TODO: don't want to make the exponentially slow ones Dawid documents
comment|// in TestPatternReplaceFilter, so dont use truly random patterns (for now)
return|return
name|Pattern
operator|.
name|compile
argument_list|(
literal|"a"
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|Pattern
index|[]
operator|.
expr|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
return|return
operator|new
name|Pattern
index|[]
block|{
name|Pattern
operator|.
name|compile
argument_list|(
literal|"([a-z]+)"
argument_list|)
block|,
name|Pattern
operator|.
name|compile
argument_list|(
literal|"([0-9]+)"
argument_list|)
block|}
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|PayloadEncoder
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
return|return
operator|new
name|IdentityEncoder
argument_list|()
return|;
comment|// the other encoders will throw exceptions if tokens arent numbers?
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|Dictionary
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
comment|// TODO: make nastier
name|InputStream
name|affixStream
init|=
name|TestHunspellStemFilter
operator|.
name|class
operator|.
name|getResourceAsStream
argument_list|(
literal|"simple.aff"
argument_list|)
decl_stmt|;
name|InputStream
name|dictStream
init|=
name|TestHunspellStemFilter
operator|.
name|class
operator|.
name|getResourceAsStream
argument_list|(
literal|"simple.dic"
argument_list|)
decl_stmt|;
try|try
block|{
return|return
operator|new
name|Dictionary
argument_list|(
name|affixStream
argument_list|,
name|dictStream
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|Rethrow
operator|.
name|rethrow
argument_list|(
name|ex
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// unreachable code
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|HyphenationTree
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
comment|// TODO: make nastier
try|try
block|{
name|InputSource
name|is
init|=
operator|new
name|InputSource
argument_list|(
name|TestCompoundWordTokenFilter
operator|.
name|class
operator|.
name|getResource
argument_list|(
literal|"da_UTF8.xml"
argument_list|)
operator|.
name|toExternalForm
argument_list|()
argument_list|)
decl_stmt|;
name|HyphenationTree
name|hyphenator
init|=
name|HyphenationCompoundWordTokenFilter
operator|.
name|getHyphenationTree
argument_list|(
name|is
argument_list|)
decl_stmt|;
return|return
name|hyphenator
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|Rethrow
operator|.
name|rethrow
argument_list|(
name|ex
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// unreachable code
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|SnowballProgram
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
try|try
block|{
name|String
name|lang
init|=
name|TestSnowball
operator|.
name|SNOWBALL_LANGS
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|TestSnowball
operator|.
name|SNOWBALL_LANGS
operator|.
name|length
argument_list|)
index|]
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|SnowballProgram
argument_list|>
name|clazz
init|=
name|Class
operator|.
name|forName
argument_list|(
literal|"org.tartarus.snowball.ext."
operator|+
name|lang
operator|+
literal|"Stemmer"
argument_list|)
operator|.
name|asSubclass
argument_list|(
name|SnowballProgram
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|clazz
operator|.
name|newInstance
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|Rethrow
operator|.
name|rethrow
argument_list|(
name|ex
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// unreachable code
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|String
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
comment|// TODO: make nastier
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// a token type
return|return
name|StandardTokenizer
operator|.
name|TOKEN_TYPES
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|StandardTokenizer
operator|.
name|TOKEN_TYPES
operator|.
name|length
argument_list|)
index|]
return|;
block|}
else|else
block|{
return|return
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|)
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|NormalizeCharMap
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|NormalizeCharMap
operator|.
name|Builder
name|builder
init|=
operator|new
name|NormalizeCharMap
operator|.
name|Builder
argument_list|()
decl_stmt|;
comment|// we can't add duplicate keys, or NormalizeCharMap gets angry
name|Set
argument_list|<
name|String
argument_list|>
name|keys
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|num
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
decl_stmt|;
comment|//System.out.println("NormalizeCharMap=");
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|String
name|key
init|=
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|keys
operator|.
name|contains
argument_list|(
name|key
argument_list|)
operator|&&
name|key
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
name|value
init|=
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|keys
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|//System.out.println("mapping: '" + key + "' => '" + value + "'");
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|CharacterRunAutomaton
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
comment|// TODO: could probably use a purely random automaton
switch|switch
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
name|MockTokenizer
operator|.
name|KEYWORD
return|;
case|case
literal|1
case|:
return|return
name|MockTokenizer
operator|.
name|SIMPLE
return|;
case|case
literal|2
case|:
return|return
name|MockTokenizer
operator|.
name|WHITESPACE
return|;
case|case
literal|3
case|:
return|return
name|MockTokenFilter
operator|.
name|EMPTY_STOPSET
return|;
default|default:
return|return
name|MockTokenFilter
operator|.
name|ENGLISH_STOPSET
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|CharArrayMap
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|int
name|num
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|CharArrayMap
argument_list|<
name|String
argument_list|>
name|map
init|=
operator|new
name|CharArrayMap
argument_list|<>
argument_list|(
name|num
argument_list|,
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|// TODO: make nastier
name|map
operator|.
name|put
argument_list|(
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|)
argument_list|,
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|StemmerOverrideMap
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|int
name|num
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|StemmerOverrideFilter
operator|.
name|Builder
name|builder
init|=
operator|new
name|StemmerOverrideFilter
operator|.
name|Builder
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|String
name|input
init|=
literal|""
decl_stmt|;
do|do
block|{
name|input
operator|=
name|TestUtil
operator|.
name|randomRealisticUnicodeString
argument_list|(
name|random
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|input
operator|.
name|isEmpty
argument_list|()
condition|)
do|;
name|String
name|out
init|=
literal|""
decl_stmt|;
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|)
expr_stmt|;
do|do
block|{
name|out
operator|=
name|TestUtil
operator|.
name|randomRealisticUnicodeString
argument_list|(
name|random
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|out
operator|.
name|isEmpty
argument_list|()
condition|)
do|;
name|builder
operator|.
name|add
argument_list|(
name|input
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
try|try
block|{
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|Rethrow
operator|.
name|rethrow
argument_list|(
name|ex
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// unreachable code
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|SynonymMap
operator|.
name|class
argument_list|,
operator|new
name|ArgProducer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|create
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|SynonymMap
operator|.
name|Builder
name|b
init|=
operator|new
name|SynonymMap
operator|.
name|Builder
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numEntries
init|=
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numEntries
condition|;
name|j
operator|++
control|)
block|{
name|addSyn
argument_list|(
name|b
argument_list|,
name|randomNonEmptyString
argument_list|(
name|random
argument_list|)
argument_list|,
name|randomNonEmptyString
argument_list|(
name|random
argument_list|)
argument_list|,
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
return|return
name|b
operator|.
name|build
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|Rethrow
operator|.
name|rethrow
argument_list|(
name|ex
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// unreachable code
block|}
block|}
specifier|private
name|void
name|addSyn
parameter_list|(
name|SynonymMap
operator|.
name|Builder
name|b
parameter_list|,
name|String
name|input
parameter_list|,
name|String
name|output
parameter_list|,
name|boolean
name|keepOrig
parameter_list|)
block|{
name|b
operator|.
name|add
argument_list|(
operator|new
name|CharsRef
argument_list|(
name|input
operator|.
name|replaceAll
argument_list|(
literal|" +"
argument_list|,
literal|"\u0000"
argument_list|)
argument_list|)
argument_list|,
operator|new
name|CharsRef
argument_list|(
name|output
operator|.
name|replaceAll
argument_list|(
literal|" +"
argument_list|,
literal|"\u0000"
argument_list|)
argument_list|)
argument_list|,
name|keepOrig
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|randomNonEmptyString
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|String
name|s
init|=
name|TestUtil
operator|.
name|randomUnicodeString
argument_list|(
name|random
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|!=
literal|0
operator|&&
name|s
operator|.
name|indexOf
argument_list|(
literal|'\u0000'
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
DECL|field|allowedTokenizerArgs
DECL|field|allowedTokenFilterArgs
DECL|field|allowedCharFilterArgs
specifier|static
specifier|final
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|allowedTokenizerArgs
decl_stmt|,
name|allowedTokenFilterArgs
decl_stmt|,
name|allowedCharFilterArgs
decl_stmt|;
static|static
block|{
name|allowedTokenizerArgs
operator|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|IdentityHashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|allowedTokenizerArgs
operator|.
name|addAll
argument_list|(
name|argProducers
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|allowedTokenizerArgs
operator|.
name|add
argument_list|(
name|Reader
operator|.
name|class
argument_list|)
expr_stmt|;
name|allowedTokenizerArgs
operator|.
name|add
argument_list|(
name|AttributeFactory
operator|.
name|class
argument_list|)
expr_stmt|;
name|allowedTokenizerArgs
operator|.
name|add
argument_list|(
name|AttributeSource
operator|.
name|class
argument_list|)
expr_stmt|;
name|allowedTokenFilterArgs
operator|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|IdentityHashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|allowedTokenFilterArgs
operator|.
name|addAll
argument_list|(
name|argProducers
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|allowedTokenFilterArgs
operator|.
name|add
argument_list|(
name|TokenStream
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// TODO: fix this one, thats broken:
name|allowedTokenFilterArgs
operator|.
name|add
argument_list|(
name|CommonGramsFilter
operator|.
name|class
argument_list|)
expr_stmt|;
name|allowedCharFilterArgs
operator|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|IdentityHashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|allowedCharFilterArgs
operator|.
name|addAll
argument_list|(
name|argProducers
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|allowedCharFilterArgs
operator|.
name|add
argument_list|(
name|Reader
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|newRandomArg
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|newRandomArg
parameter_list|(
name|Random
name|random
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|paramType
parameter_list|)
block|{
specifier|final
name|ArgProducer
name|producer
init|=
name|argProducers
operator|.
name|get
argument_list|(
name|paramType
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"No producer for arguments of type "
operator|+
name|paramType
operator|.
name|getName
argument_list|()
operator|+
literal|" found"
argument_list|,
name|producer
argument_list|)
expr_stmt|;
return|return
operator|(
name|T
operator|)
name|producer
operator|.
name|create
argument_list|(
name|random
argument_list|)
return|;
block|}
DECL|method|newTokenizerArgs
specifier|static
name|Object
index|[]
name|newTokenizerArgs
parameter_list|(
name|Random
name|random
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|paramTypes
parameter_list|)
block|{
name|Object
index|[]
name|args
init|=
operator|new
name|Object
index|[
name|paramTypes
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|paramType
init|=
name|paramTypes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|paramType
operator|==
name|AttributeSource
operator|.
name|class
condition|)
block|{
comment|// TODO: args[i] = new AttributeSource();
comment|// this is currently too scary to deal with!
name|args
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
comment|// force IAE
block|}
else|else
block|{
name|args
index|[
name|i
index|]
operator|=
name|newRandomArg
argument_list|(
name|random
argument_list|,
name|paramType
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|args
return|;
block|}
DECL|method|newCharFilterArgs
specifier|static
name|Object
index|[]
name|newCharFilterArgs
parameter_list|(
name|Random
name|random
parameter_list|,
name|Reader
name|reader
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|paramTypes
parameter_list|)
block|{
name|Object
index|[]
name|args
init|=
operator|new
name|Object
index|[
name|paramTypes
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|paramType
init|=
name|paramTypes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|paramType
operator|==
name|Reader
operator|.
name|class
condition|)
block|{
name|args
index|[
name|i
index|]
operator|=
name|reader
expr_stmt|;
block|}
else|else
block|{
name|args
index|[
name|i
index|]
operator|=
name|newRandomArg
argument_list|(
name|random
argument_list|,
name|paramType
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|args
return|;
block|}
DECL|method|newFilterArgs
specifier|static
name|Object
index|[]
name|newFilterArgs
parameter_list|(
name|Random
name|random
parameter_list|,
name|TokenStream
name|stream
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|paramTypes
parameter_list|)
block|{
name|Object
index|[]
name|args
init|=
operator|new
name|Object
index|[
name|paramTypes
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|paramType
init|=
name|paramTypes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|paramType
operator|==
name|TokenStream
operator|.
name|class
condition|)
block|{
name|args
index|[
name|i
index|]
operator|=
name|stream
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|paramType
operator|==
name|CommonGramsFilter
operator|.
name|class
condition|)
block|{
comment|// TODO: fix this one, thats broken: CommonGramsQueryFilter takes this one explicitly
name|args
index|[
name|i
index|]
operator|=
operator|new
name|CommonGramsFilter
argument_list|(
name|stream
argument_list|,
name|newRandomArg
argument_list|(
name|random
argument_list|,
name|CharArraySet
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|args
index|[
name|i
index|]
operator|=
name|newRandomArg
argument_list|(
name|random
argument_list|,
name|paramType
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|args
return|;
block|}
DECL|class|MockRandomAnalyzer
specifier|static
class|class
name|MockRandomAnalyzer
extends|extends
name|Analyzer
block|{
DECL|field|seed
specifier|final
name|long
name|seed
decl_stmt|;
DECL|method|MockRandomAnalyzer
name|MockRandomAnalyzer
parameter_list|(
name|long
name|seed
parameter_list|)
block|{
name|this
operator|.
name|seed
operator|=
name|seed
expr_stmt|;
block|}
DECL|method|offsetsAreCorrect
specifier|public
name|boolean
name|offsetsAreCorrect
parameter_list|()
block|{
comment|// TODO: can we not do the full chain here!?
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
decl_stmt|;
name|TokenizerSpec
name|tokenizerSpec
init|=
name|newTokenizer
argument_list|(
name|random
argument_list|)
decl_stmt|;
name|TokenFilterSpec
name|filterSpec
init|=
name|newFilterChain
argument_list|(
name|random
argument_list|,
name|tokenizerSpec
operator|.
name|tokenizer
argument_list|,
name|tokenizerSpec
operator|.
name|offsetsAreCorrect
argument_list|)
decl_stmt|;
return|return
name|filterSpec
operator|.
name|offsetsAreCorrect
return|;
block|}
annotation|@
name|Override
DECL|method|createComponents
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
decl_stmt|;
name|TokenizerSpec
name|tokenizerSpec
init|=
name|newTokenizer
argument_list|(
name|random
argument_list|)
decl_stmt|;
comment|//System.out.println("seed=" + seed + ",create tokenizer=" + tokenizerSpec.toString);
name|TokenFilterSpec
name|filterSpec
init|=
name|newFilterChain
argument_list|(
name|random
argument_list|,
name|tokenizerSpec
operator|.
name|tokenizer
argument_list|,
name|tokenizerSpec
operator|.
name|offsetsAreCorrect
argument_list|)
decl_stmt|;
comment|//System.out.println("seed=" + seed + ",create filter=" + filterSpec.toString);
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizerSpec
operator|.
name|tokenizer
argument_list|,
name|filterSpec
operator|.
name|stream
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|initReader
specifier|protected
name|Reader
name|initReader
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
decl_stmt|;
name|CharFilterSpec
name|charfilterspec
init|=
name|newCharFilterChain
argument_list|(
name|random
argument_list|,
name|reader
argument_list|)
decl_stmt|;
return|return
name|charfilterspec
operator|.
name|reader
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|CharFilterSpec
name|charFilterSpec
init|=
name|newCharFilterChain
argument_list|(
name|random
argument_list|,
operator|new
name|StringReader
argument_list|(
literal|""
argument_list|)
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\ncharfilters="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|charFilterSpec
operator|.
name|toString
argument_list|)
expr_stmt|;
comment|// intentional: initReader gets its own separate random
name|random
operator|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
expr_stmt|;
name|TokenizerSpec
name|tokenizerSpec
init|=
name|newTokenizer
argument_list|(
name|random
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"tokenizer="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|tokenizerSpec
operator|.
name|toString
argument_list|)
expr_stmt|;
name|TokenFilterSpec
name|tokenFilterSpec
init|=
name|newFilterChain
argument_list|(
name|random
argument_list|,
name|tokenizerSpec
operator|.
name|tokenizer
argument_list|,
name|tokenizerSpec
operator|.
name|offsetsAreCorrect
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"filters="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|tokenFilterSpec
operator|.
name|toString
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"offsetsAreCorrect="
operator|+
name|tokenFilterSpec
operator|.
name|offsetsAreCorrect
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|createComponent
specifier|private
parameter_list|<
name|T
parameter_list|>
name|T
name|createComponent
parameter_list|(
name|Constructor
argument_list|<
name|T
argument_list|>
name|ctor
parameter_list|,
name|Object
index|[]
name|args
parameter_list|,
name|StringBuilder
name|descr
parameter_list|)
block|{
try|try
block|{
specifier|final
name|T
name|instance
init|=
name|ctor
operator|.
name|newInstance
argument_list|(
name|args
argument_list|)
decl_stmt|;
comment|/*         if (descr.length()> 0) {           descr.append(",");         }         */
name|descr
operator|.
name|append
argument_list|(
literal|"\n  "
argument_list|)
expr_stmt|;
name|descr
operator|.
name|append
argument_list|(
name|ctor
operator|.
name|getDeclaringClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|params
init|=
name|Arrays
operator|.
name|deepToString
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|params
operator|=
name|params
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|params
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|descr
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
operator|.
name|append
argument_list|(
name|params
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|instance
return|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|ite
parameter_list|)
block|{
specifier|final
name|Throwable
name|cause
init|=
name|ite
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|cause
operator|instanceof
name|IllegalArgumentException
operator|||
name|cause
operator|instanceof
name|UnsupportedOperationException
condition|)
block|{
comment|// thats ok, ignore
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Ignoring IAE/UOE from ctor:"
argument_list|)
expr_stmt|;
name|cause
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Rethrow
operator|.
name|rethrow
argument_list|(
name|cause
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
decl||
name|InstantiationException
name|iae
parameter_list|)
block|{
name|Rethrow
operator|.
name|rethrow
argument_list|(
name|iae
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
comment|// no success
block|}
DECL|method|broken
specifier|private
name|boolean
name|broken
parameter_list|(
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
parameter_list|,
name|Object
index|[]
name|args
parameter_list|)
block|{
specifier|final
name|Predicate
argument_list|<
name|Object
index|[]
argument_list|>
name|pred
init|=
name|brokenConstructors
operator|.
name|get
argument_list|(
name|ctor
argument_list|)
decl_stmt|;
return|return
name|pred
operator|!=
literal|null
operator|&&
name|pred
operator|.
name|apply
argument_list|(
name|args
argument_list|)
return|;
block|}
DECL|method|brokenOffsets
specifier|private
name|boolean
name|brokenOffsets
parameter_list|(
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
parameter_list|,
name|Object
index|[]
name|args
parameter_list|)
block|{
specifier|final
name|Predicate
argument_list|<
name|Object
index|[]
argument_list|>
name|pred
init|=
name|brokenOffsetsConstructors
operator|.
name|get
argument_list|(
name|ctor
argument_list|)
decl_stmt|;
return|return
name|pred
operator|!=
literal|null
operator|&&
name|pred
operator|.
name|apply
argument_list|(
name|args
argument_list|)
return|;
block|}
comment|// create a new random tokenizer from classpath
DECL|method|newTokenizer
specifier|private
name|TokenizerSpec
name|newTokenizer
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|TokenizerSpec
name|spec
init|=
operator|new
name|TokenizerSpec
argument_list|()
decl_stmt|;
while|while
condition|(
name|spec
operator|.
name|tokenizer
operator|==
literal|null
condition|)
block|{
specifier|final
name|Constructor
argument_list|<
name|?
extends|extends
name|Tokenizer
argument_list|>
name|ctor
init|=
name|tokenizers
operator|.
name|get
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
name|tokenizers
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|StringBuilder
name|descr
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|args
index|[]
init|=
name|newTokenizerArgs
argument_list|(
name|random
argument_list|,
name|ctor
operator|.
name|getParameterTypes
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|broken
argument_list|(
name|ctor
argument_list|,
name|args
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|spec
operator|.
name|tokenizer
operator|=
name|createComponent
argument_list|(
name|ctor
argument_list|,
name|args
argument_list|,
name|descr
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|.
name|tokenizer
operator|!=
literal|null
condition|)
block|{
name|spec
operator|.
name|offsetsAreCorrect
operator|&=
operator|!
name|brokenOffsets
argument_list|(
name|ctor
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|spec
operator|.
name|toString
operator|=
name|descr
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|spec
return|;
block|}
DECL|method|newCharFilterChain
specifier|private
name|CharFilterSpec
name|newCharFilterChain
parameter_list|(
name|Random
name|random
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|CharFilterSpec
name|spec
init|=
operator|new
name|CharFilterSpec
argument_list|()
decl_stmt|;
name|spec
operator|.
name|reader
operator|=
name|reader
expr_stmt|;
name|StringBuilder
name|descr
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|numFilters
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFilters
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|Constructor
argument_list|<
name|?
extends|extends
name|CharFilter
argument_list|>
name|ctor
init|=
name|charfilters
operator|.
name|get
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
name|charfilters
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|args
index|[]
init|=
name|newCharFilterArgs
argument_list|(
name|random
argument_list|,
name|spec
operator|.
name|reader
argument_list|,
name|ctor
operator|.
name|getParameterTypes
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|broken
argument_list|(
name|ctor
argument_list|,
name|args
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|reader
operator|=
name|createComponent
argument_list|(
name|ctor
argument_list|,
name|args
argument_list|,
name|descr
argument_list|)
expr_stmt|;
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|spec
operator|.
name|reader
operator|=
name|reader
expr_stmt|;
break|break;
block|}
block|}
block|}
name|spec
operator|.
name|toString
operator|=
name|descr
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|spec
return|;
block|}
DECL|method|newFilterChain
specifier|private
name|TokenFilterSpec
name|newFilterChain
parameter_list|(
name|Random
name|random
parameter_list|,
name|Tokenizer
name|tokenizer
parameter_list|,
name|boolean
name|offsetsAreCorrect
parameter_list|)
block|{
name|TokenFilterSpec
name|spec
init|=
operator|new
name|TokenFilterSpec
argument_list|()
decl_stmt|;
name|spec
operator|.
name|offsetsAreCorrect
operator|=
name|offsetsAreCorrect
expr_stmt|;
name|spec
operator|.
name|stream
operator|=
name|tokenizer
expr_stmt|;
name|StringBuilder
name|descr
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|numFilters
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFilters
condition|;
name|i
operator|++
control|)
block|{
comment|// Insert ValidatingTF after each stage so we can
comment|// catch problems right after the TF that "caused"
comment|// them:
name|spec
operator|.
name|stream
operator|=
operator|new
name|ValidatingTokenFilter
argument_list|(
name|spec
operator|.
name|stream
argument_list|,
literal|"stage "
operator|+
name|i
argument_list|,
name|spec
operator|.
name|offsetsAreCorrect
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|Constructor
argument_list|<
name|?
extends|extends
name|TokenFilter
argument_list|>
name|ctor
init|=
name|tokenfilters
operator|.
name|get
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
name|tokenfilters
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// hack: MockGraph/MockLookahead has assertions that will trip if they follow
comment|// an offsets violator. so we cant use them after e.g. wikipediatokenizer
if|if
condition|(
operator|!
name|spec
operator|.
name|offsetsAreCorrect
operator|&&
operator|(
name|ctor
operator|.
name|getDeclaringClass
argument_list|()
operator|.
name|equals
argument_list|(
name|MockGraphTokenFilter
operator|.
name|class
argument_list|)
operator|||
name|ctor
operator|.
name|getDeclaringClass
argument_list|()
operator|.
name|equals
argument_list|(
name|MockRandomLookaheadTokenFilter
operator|.
name|class
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
specifier|final
name|Object
name|args
index|[]
init|=
name|newFilterArgs
argument_list|(
name|random
argument_list|,
name|spec
operator|.
name|stream
argument_list|,
name|ctor
operator|.
name|getParameterTypes
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|broken
argument_list|(
name|ctor
argument_list|,
name|args
argument_list|)
condition|)
block|{
continue|continue;
block|}
specifier|final
name|TokenFilter
name|flt
init|=
name|createComponent
argument_list|(
name|ctor
argument_list|,
name|args
argument_list|,
name|descr
argument_list|)
decl_stmt|;
if|if
condition|(
name|flt
operator|!=
literal|null
condition|)
block|{
name|spec
operator|.
name|offsetsAreCorrect
operator|&=
operator|!
name|brokenOffsets
argument_list|(
name|ctor
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|spec
operator|.
name|stream
operator|=
name|flt
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// Insert ValidatingTF after each stage so we can
comment|// catch problems right after the TF that "caused"
comment|// them:
name|spec
operator|.
name|stream
operator|=
operator|new
name|ValidatingTokenFilter
argument_list|(
name|spec
operator|.
name|stream
argument_list|,
literal|"last stage"
argument_list|,
name|spec
operator|.
name|offsetsAreCorrect
argument_list|)
expr_stmt|;
name|spec
operator|.
name|toString
operator|=
name|descr
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|spec
return|;
block|}
block|}
DECL|class|CheckThatYouDidntReadAnythingReaderWrapper
specifier|static
class|class
name|CheckThatYouDidntReadAnythingReaderWrapper
extends|extends
name|CharFilter
block|{
DECL|field|readSomething
name|boolean
name|readSomething
decl_stmt|;
DECL|method|CheckThatYouDidntReadAnythingReaderWrapper
name|CheckThatYouDidntReadAnythingReaderWrapper
parameter_list|(
name|Reader
name|in
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|correct
specifier|public
name|int
name|correct
parameter_list|(
name|int
name|currentOff
parameter_list|)
block|{
return|return
name|currentOff
return|;
comment|// we don't change any offsets
block|}
annotation|@
name|Override
DECL|method|read
specifier|public
name|int
name|read
parameter_list|(
name|char
index|[]
name|cbuf
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|readSomething
operator|=
literal|true
expr_stmt|;
return|return
name|input
operator|.
name|read
argument_list|(
name|cbuf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|read
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|readSomething
operator|=
literal|true
expr_stmt|;
return|return
name|input
operator|.
name|read
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|read
specifier|public
name|int
name|read
parameter_list|(
name|CharBuffer
name|target
parameter_list|)
throws|throws
name|IOException
block|{
name|readSomething
operator|=
literal|true
expr_stmt|;
return|return
name|input
operator|.
name|read
argument_list|(
name|target
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|read
specifier|public
name|int
name|read
parameter_list|(
name|char
index|[]
name|cbuf
parameter_list|)
throws|throws
name|IOException
block|{
name|readSomething
operator|=
literal|true
expr_stmt|;
return|return
name|input
operator|.
name|read
argument_list|(
name|cbuf
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|skip
specifier|public
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|readSomething
operator|=
literal|true
expr_stmt|;
return|return
name|input
operator|.
name|skip
argument_list|(
name|n
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|mark
specifier|public
name|void
name|mark
parameter_list|(
name|int
name|readAheadLimit
parameter_list|)
throws|throws
name|IOException
block|{
name|input
operator|.
name|mark
argument_list|(
name|readAheadLimit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|markSupported
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
name|input
operator|.
name|markSupported
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|ready
specifier|public
name|boolean
name|ready
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|input
operator|.
name|ready
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
name|input
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|TokenizerSpec
specifier|static
class|class
name|TokenizerSpec
block|{
DECL|field|tokenizer
name|Tokenizer
name|tokenizer
decl_stmt|;
DECL|field|toString
name|String
name|toString
decl_stmt|;
DECL|field|offsetsAreCorrect
name|boolean
name|offsetsAreCorrect
init|=
literal|true
decl_stmt|;
block|}
DECL|class|TokenFilterSpec
specifier|static
class|class
name|TokenFilterSpec
block|{
DECL|field|stream
name|TokenStream
name|stream
decl_stmt|;
DECL|field|toString
name|String
name|toString
decl_stmt|;
DECL|field|offsetsAreCorrect
name|boolean
name|offsetsAreCorrect
init|=
literal|true
decl_stmt|;
block|}
DECL|class|CharFilterSpec
specifier|static
class|class
name|CharFilterSpec
block|{
DECL|field|reader
name|Reader
name|reader
decl_stmt|;
DECL|field|toString
name|String
name|toString
decl_stmt|;
block|}
DECL|method|testRandomChains
specifier|public
name|void
name|testRandomChains
parameter_list|()
throws|throws
name|Throwable
block|{
name|int
name|numIterations
init|=
name|TEST_NIGHTLY
condition|?
name|atLeast
argument_list|(
literal|20
argument_list|)
else|:
literal|3
decl_stmt|;
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIterations
condition|;
name|i
operator|++
control|)
block|{
try|try
init|(
name|MockRandomAnalyzer
name|a
init|=
operator|new
name|MockRandomAnalyzer
argument_list|(
name|random
operator|.
name|nextLong
argument_list|()
argument_list|)
init|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Creating random analyzer:"
operator|+
name|a
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|checkRandomData
argument_list|(
name|random
argument_list|,
name|a
argument_list|,
literal|500
operator|*
name|RANDOM_MULTIPLIER
argument_list|,
literal|20
argument_list|,
literal|false
argument_list|,
literal|false
comment|/* We already validate our own offsets... */
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Exception from random analyzer: "
operator|+
name|a
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
block|}
comment|// we might regret this decision...
DECL|method|testRandomChainsWithLargeStrings
specifier|public
name|void
name|testRandomChainsWithLargeStrings
parameter_list|()
throws|throws
name|Throwable
block|{
name|int
name|numIterations
init|=
name|TEST_NIGHTLY
condition|?
name|atLeast
argument_list|(
literal|20
argument_list|)
else|:
literal|3
decl_stmt|;
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIterations
condition|;
name|i
operator|++
control|)
block|{
try|try
init|(
name|MockRandomAnalyzer
name|a
init|=
operator|new
name|MockRandomAnalyzer
argument_list|(
name|random
operator|.
name|nextLong
argument_list|()
argument_list|)
init|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Creating random analyzer:"
operator|+
name|a
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|checkRandomData
argument_list|(
name|random
argument_list|,
name|a
argument_list|,
literal|50
operator|*
name|RANDOM_MULTIPLIER
argument_list|,
literal|80
argument_list|,
literal|false
argument_list|,
literal|false
comment|/* We already validate our own offsets... */
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Exception from random analyzer: "
operator|+
name|a
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
block|}
block|}
end_class
end_unit
