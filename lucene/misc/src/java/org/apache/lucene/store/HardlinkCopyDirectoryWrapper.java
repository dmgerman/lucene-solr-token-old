begin_unit
begin_package
DECL|package|org.apache.lucene.store
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|FileAlreadyExistsException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|NoSuchFileException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import
begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedAction
import|;
end_import
begin_comment
comment|/**  * This directory wrapper overrides {@link Directory#copyFrom(Directory, String, String, IOContext)} in order  * to optionally use a hard-link instead of a full byte by byte file copy if applicable. Hard-links are only used if the  * underlying filesystem supports it and if the {@link java.nio.file.LinkPermission} "hard" is granted.  *  *<p><b>NOTE:</b> Using hard-links changes the copy semantics of  * {@link Directory#copyFrom(Directory, String, String, IOContext)}. When hard-links are used changes to the source file  * will be reflected in the target file and vice-versa. Within Lucene, files are write once and should not be modified  * after they have been written. This directory should not be used in situations where files change after they have  * been written.  *</p>  */
end_comment
begin_class
DECL|class|HardlinkCopyDirectoryWrapper
specifier|public
specifier|final
class|class
name|HardlinkCopyDirectoryWrapper
extends|extends
name|FilterDirectory
block|{
comment|/**    * Creates a new HardlinkCopyDirectoryWrapper delegating to the given directory    */
DECL|method|HardlinkCopyDirectoryWrapper
specifier|public
name|HardlinkCopyDirectoryWrapper
parameter_list|(
name|Directory
name|in
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|copyFrom
specifier|public
name|void
name|copyFrom
parameter_list|(
name|Directory
name|from
parameter_list|,
name|String
name|srcFile
parameter_list|,
name|String
name|destFile
parameter_list|,
name|IOContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Directory
name|fromUnwrapped
init|=
name|FilterDirectory
operator|.
name|unwrap
argument_list|(
name|from
argument_list|)
decl_stmt|;
specifier|final
name|Directory
name|toUnwrapped
init|=
name|FilterDirectory
operator|.
name|unwrap
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|// try to unwrap to FSDirectory - we might be able to just create hard-links of these files and save copying
comment|// the entire file.
name|Exception
name|suppressedException
init|=
literal|null
decl_stmt|;
name|boolean
name|tryCopy
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|fromUnwrapped
operator|instanceof
name|FSDirectory
operator|&&
name|toUnwrapped
operator|instanceof
name|FSDirectory
condition|)
block|{
specifier|final
name|Path
name|fromPath
init|=
operator|(
operator|(
name|FSDirectory
operator|)
name|fromUnwrapped
operator|)
operator|.
name|getDirectory
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|toPath
init|=
operator|(
operator|(
name|FSDirectory
operator|)
name|toUnwrapped
operator|)
operator|.
name|getDirectory
argument_list|()
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isReadable
argument_list|(
name|fromPath
operator|.
name|resolve
argument_list|(
name|srcFile
argument_list|)
argument_list|)
operator|&&
name|Files
operator|.
name|isWritable
argument_list|(
name|toPath
argument_list|)
condition|)
block|{
comment|// only try hardlinks if we have permission to access the files
comment|// if not super.copyFrom() will give us the right exceptions
name|suppressedException
operator|=
name|AccessController
operator|.
name|doPrivileged
argument_list|(
call|(
name|PrivilegedAction
argument_list|<
name|Exception
argument_list|>
call|)
argument_list|()
operator|->
block|{
try|try
block|{
name|Files
operator|.
name|createLink
argument_list|(
name|toPath
operator|.
name|resolve
argument_list|(
name|destFile
argument_list|)
argument_list|,
name|fromPath
operator|.
name|resolve
argument_list|(
name|srcFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
decl||
name|NoSuchFileException
decl||
name|FileAlreadyExistsException
name|ex
parameter_list|)
block|{
return|return
name|ex
return|;
comment|// in these cases we bubble up since it's a true error condition.
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|UnsupportedOperationException
comment|// if the FS doesn't support hard-links
decl||
name|SecurityException
name|ex
comment|// we don't have permission to use hard-links just fall back to byte copy
parameter_list|)
block|{
comment|// hard-links are not supported or the files are on different filesystems
comment|// we could go deeper and check if their filesstores are the same and opt
comment|// out earlier but for now we just fall back to normal file-copy
return|return
name|ex
return|;
block|}
return|return
literal|null
return|;
block|}
block|)
empty_stmt|;
name|tryCopy
operator|=
name|suppressedException
operator|!=
literal|null
expr_stmt|;
block|}
block|}
end_class
begin_if
if|if
condition|(
name|tryCopy
condition|)
block|{
try|try
block|{
name|super
operator|.
name|copyFrom
argument_list|(
name|from
argument_list|,
name|srcFile
argument_list|,
name|destFile
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
if|if
condition|(
name|suppressedException
operator|!=
literal|null
condition|)
block|{
name|ex
operator|.
name|addSuppressed
argument_list|(
name|suppressedException
argument_list|)
expr_stmt|;
block|}
throw|throw
name|ex
throw|;
block|}
block|}
end_if
unit|} }
end_unit
