begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.uninverting
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|uninverting
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|PostingsFormat
import|;
end_import
begin_comment
comment|// javadocs
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValuesType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|PostingsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedSetDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Accountable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PagedBytes
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import
begin_comment
comment|/**  * This class enables fast access to multiple term ords for  * a specified field across all docIDs.  *  * Like FieldCache, it uninverts the index and holds a  * packed data structure in RAM to enable fast access.  * Unlike FieldCache, it can handle multi-valued fields,  * and, it does not hold the term bytes in RAM.  Rather, you  * must obtain a TermsEnum from the {@link #getOrdTermsEnum}  * method, and then seek-by-ord to get the term's bytes.  *  * While normally term ords are type long, in this API they are  * int as the internal representation here cannot address  * more than MAX_INT unique terms.  Also, typically this  * class is used on fields with relatively few unique terms  * vs the number of documents.  In addition, there is an  * internal limit (16 MB) on how many bytes each chunk of  * documents may consume.  If you trip this limit you'll hit  * an IllegalStateException.  *  * Deleted documents are skipped during uninversion, and if  * you look them up you'll get 0 ords.  *  * The returned per-document ords do not retain their  * original order in the document.  Instead they are returned  * in sorted (by ord, ie term's BytesRef comparator) order.  They  * are also de-dup'd (ie if doc has same term more than once  * in this field, you'll only get that ord back once).  *  * This class  * will create its own term index internally, allowing to  * create a wrapped TermsEnum that can handle ord.  The  * {@link #getOrdTermsEnum} method then provides this  * wrapped enum.  *  * The RAM consumption of this class can be high!  *  * @lucene.experimental  */
end_comment
begin_comment
comment|/*  * Final form of the un-inverted field:  *   Each document points to a list of term numbers that are contained in that document.  *  *   Term numbers are in sorted order, and are encoded as variable-length deltas from the  *   previous term number.  Real term numbers start at 2 since 0 and 1 are reserved.  A  *   term number of 0 signals the end of the termNumber list.  *  *   There is a single int[maxDoc()] which either contains a pointer into a byte[] for  *   the termNumber lists, or directly contains the termNumber list if it fits in the 4  *   bytes of an integer.  If the first byte in the integer is 1, the next 3 bytes  *   are a pointer into a byte[] where the termNumber list starts.  *  *   There are actually 256 byte arrays, to compensate for the fact that the pointers  *   into the byte arrays are only 3 bytes long.  The correct byte array for a document  *   is a function of its id.  *  *   To save space and speed up faceting, any term that matches enough documents will  *   not be un-inverted... it will be skipped while building the un-inverted field structure,  *   and will use a set intersection method during faceting.  *  *   To further save memory, the terms (the actual string values) are not all stored in  *   memory, but a TermIndex is used to convert term numbers to term values only  *   for the terms needed after faceting has completed.  Only every 128th term value  *   is stored, along with its corresponding term number, and this is used as an  *   index to find the closest term and iterate until the desired number is hit (very  *   much like Lucene's own internal term index).  *  */
end_comment
begin_class
DECL|class|DocTermOrds
specifier|public
class|class
name|DocTermOrds
implements|implements
name|Accountable
block|{
comment|// Term ords are shifted by this, internally, to reserve
comment|// values 0 (end term) and 1 (index is a pointer into byte array)
DECL|field|TNUM_OFFSET
specifier|private
specifier|final
specifier|static
name|int
name|TNUM_OFFSET
init|=
literal|2
decl_stmt|;
comment|/** Every 128th term is indexed, by default. */
DECL|field|DEFAULT_INDEX_INTERVAL_BITS
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_INDEX_INTERVAL_BITS
init|=
literal|7
decl_stmt|;
comment|// decrease to a low number like 2 for testing
DECL|field|indexIntervalBits
specifier|private
name|int
name|indexIntervalBits
decl_stmt|;
DECL|field|indexIntervalMask
specifier|private
name|int
name|indexIntervalMask
decl_stmt|;
DECL|field|indexInterval
specifier|private
name|int
name|indexInterval
decl_stmt|;
comment|/** Don't uninvert terms that exceed this count. */
DECL|field|maxTermDocFreq
specifier|protected
specifier|final
name|int
name|maxTermDocFreq
decl_stmt|;
comment|/** Field we are uninverting. */
DECL|field|field
specifier|protected
specifier|final
name|String
name|field
decl_stmt|;
comment|/** Number of terms in the field. */
DECL|field|numTermsInField
specifier|protected
name|int
name|numTermsInField
decl_stmt|;
comment|/** Total number of references to term numbers. */
DECL|field|termInstances
specifier|protected
name|long
name|termInstances
decl_stmt|;
DECL|field|memsz
specifier|private
name|long
name|memsz
decl_stmt|;
comment|/** Total time to uninvert the field. */
DECL|field|total_time
specifier|protected
name|int
name|total_time
decl_stmt|;
comment|/** Time for phase1 of the uninvert process. */
DECL|field|phase1_time
specifier|protected
name|int
name|phase1_time
decl_stmt|;
comment|/** Holds the per-document ords or a pointer to the ords. */
DECL|field|index
specifier|protected
name|int
index|[]
name|index
decl_stmt|;
comment|/** Holds term ords for documents. */
DECL|field|tnums
specifier|protected
name|byte
index|[]
index|[]
name|tnums
init|=
operator|new
name|byte
index|[
literal|256
index|]
index|[]
decl_stmt|;
comment|/** Total bytes (sum of term lengths) for all indexed terms.*/
DECL|field|sizeOfIndexedStrings
specifier|protected
name|long
name|sizeOfIndexedStrings
decl_stmt|;
comment|/** Holds the indexed (by default every 128th) terms. */
DECL|field|indexedTermsArray
specifier|protected
name|BytesRef
index|[]
name|indexedTermsArray
init|=
operator|new
name|BytesRef
index|[
literal|0
index|]
decl_stmt|;
comment|/** If non-null, only terms matching this prefix were    *  indexed. */
DECL|field|prefix
specifier|protected
name|BytesRef
name|prefix
decl_stmt|;
comment|/** Ordinal of the first term in the field, or 0 if the    *  {@link PostingsFormat} does not implement {@link    *  TermsEnum#ord}. */
DECL|field|ordBase
specifier|protected
name|int
name|ordBase
decl_stmt|;
comment|/** Used while uninverting. */
DECL|field|postingsEnum
specifier|protected
name|PostingsEnum
name|postingsEnum
decl_stmt|;
comment|/** Returns total bytes used. */
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
comment|// can cache the mem size since it shouldn't change
if|if
condition|(
name|memsz
operator|!=
literal|0
condition|)
return|return
name|memsz
return|;
name|long
name|sz
init|=
literal|8
operator|*
literal|8
operator|+
literal|32
decl_stmt|;
comment|// local fields
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
name|sz
operator|+=
name|index
operator|.
name|length
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|tnums
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|byte
index|[]
name|arr
range|:
name|tnums
control|)
if|if
condition|(
name|arr
operator|!=
literal|null
condition|)
name|sz
operator|+=
name|arr
operator|.
name|length
expr_stmt|;
block|}
name|memsz
operator|=
name|sz
expr_stmt|;
return|return
name|sz
return|;
block|}
comment|/** Inverts all terms */
DECL|method|DocTermOrds
specifier|public
name|DocTermOrds
parameter_list|(
name|LeafReader
name|reader
parameter_list|,
name|Bits
name|liveDocs
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|reader
argument_list|,
name|liveDocs
argument_list|,
name|field
argument_list|,
literal|null
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
comment|// TODO: instead of all these ctors and options, take termsenum!
comment|/** Inverts only terms starting w/ prefix */
DECL|method|DocTermOrds
specifier|public
name|DocTermOrds
parameter_list|(
name|LeafReader
name|reader
parameter_list|,
name|Bits
name|liveDocs
parameter_list|,
name|String
name|field
parameter_list|,
name|BytesRef
name|termPrefix
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|reader
argument_list|,
name|liveDocs
argument_list|,
name|field
argument_list|,
name|termPrefix
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
comment|/** Inverts only terms starting w/ prefix, and only terms    *  whose docFreq (not taking deletions into account) is    *&lt;=  maxTermDocFreq */
DECL|method|DocTermOrds
specifier|public
name|DocTermOrds
parameter_list|(
name|LeafReader
name|reader
parameter_list|,
name|Bits
name|liveDocs
parameter_list|,
name|String
name|field
parameter_list|,
name|BytesRef
name|termPrefix
parameter_list|,
name|int
name|maxTermDocFreq
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|reader
argument_list|,
name|liveDocs
argument_list|,
name|field
argument_list|,
name|termPrefix
argument_list|,
name|maxTermDocFreq
argument_list|,
name|DEFAULT_INDEX_INTERVAL_BITS
argument_list|)
expr_stmt|;
block|}
comment|/** Inverts only terms starting w/ prefix, and only terms    *  whose docFreq (not taking deletions into account) is    *&lt;=  maxTermDocFreq, with a custom indexing interval    *  (default is every 128nd term). */
DECL|method|DocTermOrds
specifier|public
name|DocTermOrds
parameter_list|(
name|LeafReader
name|reader
parameter_list|,
name|Bits
name|liveDocs
parameter_list|,
name|String
name|field
parameter_list|,
name|BytesRef
name|termPrefix
parameter_list|,
name|int
name|maxTermDocFreq
parameter_list|,
name|int
name|indexIntervalBits
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|field
argument_list|,
name|maxTermDocFreq
argument_list|,
name|indexIntervalBits
argument_list|)
expr_stmt|;
name|uninvert
argument_list|(
name|reader
argument_list|,
name|liveDocs
argument_list|,
name|termPrefix
argument_list|)
expr_stmt|;
block|}
comment|/** Subclass inits w/ this, but be sure you then call    *  uninvert, only once */
DECL|method|DocTermOrds
specifier|protected
name|DocTermOrds
parameter_list|(
name|String
name|field
parameter_list|,
name|int
name|maxTermDocFreq
parameter_list|,
name|int
name|indexIntervalBits
parameter_list|)
block|{
comment|//System.out.println("DTO init field=" + field + " maxTDFreq=" + maxTermDocFreq);
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|maxTermDocFreq
operator|=
name|maxTermDocFreq
expr_stmt|;
name|this
operator|.
name|indexIntervalBits
operator|=
name|indexIntervalBits
expr_stmt|;
name|indexIntervalMask
operator|=
literal|0xffffffff
operator|>>>
operator|(
literal|32
operator|-
name|indexIntervalBits
operator|)
expr_stmt|;
name|indexInterval
operator|=
literal|1
operator|<<
name|indexIntervalBits
expr_stmt|;
block|}
comment|/**     * Returns a TermsEnum that implements ord, or null if no terms in field.    *<p>    *  we build a "private" terms    *  index internally (WARNING: consumes RAM) and use that    *  index to implement ord.  This also enables ord on top    *  of a composite reader.  The returned TermsEnum is    *  unpositioned.  This returns null if there are no terms.    *</p>    *<p><b>NOTE</b>: you must pass the same reader that was    *  used when creating this class     */
DECL|method|getOrdTermsEnum
specifier|public
name|TermsEnum
name|getOrdTermsEnum
parameter_list|(
name|LeafReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
comment|// NOTE: see LUCENE-6529 before attempting to optimize this method to
comment|// return a TermsEnum directly from the reader if it already supports ord().
assert|assert
literal|null
operator|!=
name|indexedTermsArray
assert|;
if|if
condition|(
literal|0
operator|==
name|indexedTermsArray
operator|.
name|length
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
operator|new
name|OrdWrappedTermsEnum
argument_list|(
name|reader
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns the number of terms in this field    */
DECL|method|numTerms
specifier|public
name|int
name|numTerms
parameter_list|()
block|{
return|return
name|numTermsInField
return|;
block|}
comment|/**    * Returns {@code true} if no terms were indexed.    */
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|index
operator|==
literal|null
return|;
block|}
comment|/** Subclass can override this */
DECL|method|visitTerm
specifier|protected
name|void
name|visitTerm
parameter_list|(
name|TermsEnum
name|te
parameter_list|,
name|int
name|termNum
parameter_list|)
throws|throws
name|IOException
block|{   }
comment|/** Invoked during {@link #uninvert(org.apache.lucene.index.LeafReader,Bits,BytesRef)}    *  to record the document frequency for each uninverted    *  term. */
DECL|method|setActualDocFreq
specifier|protected
name|void
name|setActualDocFreq
parameter_list|(
name|int
name|termNum
parameter_list|,
name|int
name|df
parameter_list|)
throws|throws
name|IOException
block|{   }
comment|/** Call this only once (if you subclass!) */
DECL|method|uninvert
specifier|protected
name|void
name|uninvert
parameter_list|(
specifier|final
name|LeafReader
name|reader
parameter_list|,
name|Bits
name|liveDocs
parameter_list|,
specifier|final
name|BytesRef
name|termPrefix
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FieldInfo
name|info
init|=
name|reader
operator|.
name|getFieldInfos
argument_list|()
operator|.
name|fieldInfo
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|getDocValuesType
argument_list|()
operator|!=
name|DocValuesType
operator|.
name|NONE
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Type mismatch: "
operator|+
name|field
operator|+
literal|" was indexed as "
operator|+
name|info
operator|.
name|getDocValuesType
argument_list|()
argument_list|)
throw|;
block|}
comment|//System.out.println("DTO uninvert field=" + field + " prefix=" + termPrefix);
specifier|final
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|prefix
operator|=
name|termPrefix
operator|==
literal|null
condition|?
literal|null
else|:
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|termPrefix
argument_list|)
expr_stmt|;
specifier|final
name|int
name|maxDoc
init|=
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
specifier|final
name|int
index|[]
name|index
init|=
operator|new
name|int
index|[
name|maxDoc
index|]
decl_stmt|;
comment|// immediate term numbers, or the index into the byte[] representing the last number
specifier|final
name|int
index|[]
name|lastTerm
init|=
operator|new
name|int
index|[
name|maxDoc
index|]
decl_stmt|;
comment|// last term we saw for this document
specifier|final
name|byte
index|[]
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|maxDoc
index|]
index|[]
decl_stmt|;
comment|// list of term numbers for the doc (delta encoded vInts)
specifier|final
name|Terms
name|terms
init|=
name|reader
operator|.
name|terms
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|==
literal|null
condition|)
block|{
comment|// No terms
return|return;
block|}
specifier|final
name|TermsEnum
name|te
init|=
name|terms
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|final
name|BytesRef
name|seekStart
init|=
name|termPrefix
operator|!=
literal|null
condition|?
name|termPrefix
else|:
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
comment|//System.out.println("seekStart=" + seekStart.utf8ToString());
if|if
condition|(
name|te
operator|.
name|seekCeil
argument_list|(
name|seekStart
argument_list|)
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|END
condition|)
block|{
comment|// No terms match
return|return;
block|}
comment|// For our "term index wrapper"
specifier|final
name|List
argument_list|<
name|BytesRef
argument_list|>
name|indexedTerms
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|PagedBytes
name|indexedTermsBytes
init|=
operator|new
name|PagedBytes
argument_list|(
literal|15
argument_list|)
decl_stmt|;
comment|// we need a minimum of 9 bytes, but round up to 12 since the space would
comment|// be wasted with most allocators anyway.
name|byte
index|[]
name|tempArr
init|=
operator|new
name|byte
index|[
literal|12
index|]
decl_stmt|;
comment|//
comment|// enumerate all terms, and build an intermediate form of the un-inverted field.
comment|//
comment|// During this intermediate form, every document has a (potential) byte[]
comment|// and the int[maxDoc()] array either contains the termNumber list directly
comment|// or the *end* offset of the termNumber list in its byte array (for faster
comment|// appending and faster creation of the final form).
comment|//
comment|// idea... if things are too large while building, we could do a range of docs
comment|// at a time (but it would be a fair amount slower to build)
comment|// could also do ranges in parallel to take advantage of multiple CPUs
comment|// OPTIONAL: remap the largest df terms to the lowest 128 (single byte)
comment|// values.  This requires going over the field first to find the most
comment|// frequent terms ahead of time.
name|int
name|termNum
init|=
literal|0
decl_stmt|;
name|postingsEnum
operator|=
literal|null
expr_stmt|;
comment|// Loop begins with te positioned to first term (we call
comment|// seek above):
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|final
name|BytesRef
name|t
init|=
name|te
operator|.
name|term
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
operator|||
operator|(
name|termPrefix
operator|!=
literal|null
operator|&&
operator|!
name|StringHelper
operator|.
name|startsWith
argument_list|(
name|t
argument_list|,
name|termPrefix
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
comment|//System.out.println("visit term=" + t.utf8ToString() + " " + t + " termNum=" + termNum);
name|visitTerm
argument_list|(
name|te
argument_list|,
name|termNum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|termNum
operator|&
name|indexIntervalMask
operator|)
operator|==
literal|0
condition|)
block|{
comment|// Index this term
name|sizeOfIndexedStrings
operator|+=
name|t
operator|.
name|length
expr_stmt|;
name|BytesRef
name|indexedTerm
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|indexedTermsBytes
operator|.
name|copy
argument_list|(
name|t
argument_list|,
name|indexedTerm
argument_list|)
expr_stmt|;
comment|// TODO: really should 1) strip off useless suffix,
comment|// and 2) use FST not array/PagedBytes
name|indexedTerms
operator|.
name|add
argument_list|(
name|indexedTerm
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|df
init|=
name|te
operator|.
name|docFreq
argument_list|()
decl_stmt|;
if|if
condition|(
name|df
operator|<=
name|maxTermDocFreq
condition|)
block|{
name|postingsEnum
operator|=
name|te
operator|.
name|postings
argument_list|(
name|liveDocs
argument_list|,
name|postingsEnum
argument_list|,
name|PostingsEnum
operator|.
name|NONE
argument_list|)
expr_stmt|;
comment|// dF, but takes deletions into account
name|int
name|actualDF
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|doc
init|=
name|postingsEnum
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
break|break;
block|}
comment|//System.out.println("  chunk=" + chunk + " docs");
name|actualDF
operator|++
expr_stmt|;
name|termInstances
operator|++
expr_stmt|;
comment|//System.out.println("    docID=" + doc);
comment|// add TNUM_OFFSET to the term number to make room for special reserved values:
comment|// 0 (end term) and 1 (index into byte array follows)
name|int
name|delta
init|=
name|termNum
operator|-
name|lastTerm
index|[
name|doc
index|]
operator|+
name|TNUM_OFFSET
decl_stmt|;
name|lastTerm
index|[
name|doc
index|]
operator|=
name|termNum
expr_stmt|;
name|int
name|val
init|=
name|index
index|[
name|doc
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0xff
operator|)
operator|==
literal|1
condition|)
block|{
comment|// index into byte array (actually the end of
comment|// the doc-specific byte[] when building)
name|int
name|pos
init|=
name|val
operator|>>>
literal|8
decl_stmt|;
name|int
name|ilen
init|=
name|vIntSize
argument_list|(
name|delta
argument_list|)
decl_stmt|;
name|byte
index|[]
name|arr
init|=
name|bytes
index|[
name|doc
index|]
decl_stmt|;
name|int
name|newend
init|=
name|pos
operator|+
name|ilen
decl_stmt|;
if|if
condition|(
name|newend
operator|>
name|arr
operator|.
name|length
condition|)
block|{
comment|// We avoid a doubling strategy to lower memory usage.
comment|// this faceting method isn't for docs with many terms.
comment|// In hotspot, objects have 2 words of overhead, then fields, rounded up to a 64-bit boundary.
comment|// TODO: figure out what array lengths we can round up to w/o actually using more memory
comment|// (how much space does a byte[] take up?  Is data preceded by a 32 bit length only?
comment|// It should be safe to round up to the nearest 32 bits in any case.
name|int
name|newLen
init|=
operator|(
name|newend
operator|+
literal|3
operator|)
operator|&
literal|0xfffffffc
decl_stmt|;
comment|// 4 byte alignment
name|byte
index|[]
name|newarr
init|=
operator|new
name|byte
index|[
name|newLen
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|arr
argument_list|,
literal|0
argument_list|,
name|newarr
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|arr
operator|=
name|newarr
expr_stmt|;
name|bytes
index|[
name|doc
index|]
operator|=
name|newarr
expr_stmt|;
block|}
name|pos
operator|=
name|writeInt
argument_list|(
name|delta
argument_list|,
name|arr
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|index
index|[
name|doc
index|]
operator|=
operator|(
name|pos
operator|<<
literal|8
operator|)
operator||
literal|1
expr_stmt|;
comment|// update pointer to end index in byte[]
block|}
else|else
block|{
comment|// OK, this int has data in it... find the end (a zero starting byte - not
comment|// part of another number, hence not following a byte with the high bit set).
name|int
name|ipos
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|ipos
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
literal|0x0000ff80
operator|)
operator|==
literal|0
condition|)
block|{
name|ipos
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
literal|0x00ff8000
operator|)
operator|==
literal|0
condition|)
block|{
name|ipos
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
literal|0xff800000
operator|)
operator|==
literal|0
condition|)
block|{
name|ipos
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|ipos
operator|=
literal|4
expr_stmt|;
block|}
comment|//System.out.println("      ipos=" + ipos);
name|int
name|endPos
init|=
name|writeInt
argument_list|(
name|delta
argument_list|,
name|tempArr
argument_list|,
name|ipos
argument_list|)
decl_stmt|;
comment|//System.out.println("      endpos=" + endPos);
if|if
condition|(
name|endPos
operator|<=
literal|4
condition|)
block|{
comment|//System.out.println("      fits!");
comment|// value will fit in the integer... move bytes back
for|for
control|(
name|int
name|j
init|=
name|ipos
init|;
name|j
operator|<
name|endPos
condition|;
name|j
operator|++
control|)
block|{
name|val
operator||=
operator|(
name|tempArr
index|[
name|j
index|]
operator|&
literal|0xff
operator|)
operator|<<
operator|(
name|j
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
name|index
index|[
name|doc
index|]
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
comment|// value won't fit... move integer into byte[]
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|ipos
condition|;
name|j
operator|++
control|)
block|{
name|tempArr
index|[
name|j
index|]
operator|=
operator|(
name|byte
operator|)
name|val
expr_stmt|;
name|val
operator|>>>=
literal|8
expr_stmt|;
block|}
comment|// point at the end index in the byte[]
name|index
index|[
name|doc
index|]
operator|=
operator|(
name|endPos
operator|<<
literal|8
operator|)
operator||
literal|1
expr_stmt|;
name|bytes
index|[
name|doc
index|]
operator|=
name|tempArr
expr_stmt|;
name|tempArr
operator|=
operator|new
name|byte
index|[
literal|12
index|]
expr_stmt|;
block|}
block|}
block|}
name|setActualDocFreq
argument_list|(
name|termNum
argument_list|,
name|actualDF
argument_list|)
expr_stmt|;
block|}
name|termNum
operator|++
expr_stmt|;
if|if
condition|(
name|te
operator|.
name|next
argument_list|()
operator|==
literal|null
condition|)
block|{
break|break;
block|}
block|}
name|numTermsInField
operator|=
name|termNum
expr_stmt|;
name|long
name|midPoint
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|termInstances
operator|==
literal|0
condition|)
block|{
comment|// we didn't invert anything
comment|// lower memory consumption.
name|tnums
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
comment|//
comment|// transform intermediate form into the final form, building a single byte[]
comment|// at a time, and releasing the intermediate byte[]s as we go to avoid
comment|// increasing the memory footprint.
comment|//
for|for
control|(
name|int
name|pass
init|=
literal|0
init|;
name|pass
operator|<
literal|256
condition|;
name|pass
operator|++
control|)
block|{
name|byte
index|[]
name|target
init|=
name|tnums
index|[
name|pass
index|]
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
comment|// end in target;
if|if
condition|(
name|target
operator|!=
literal|null
condition|)
block|{
name|pos
operator|=
name|target
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
operator|new
name|byte
index|[
literal|4096
index|]
expr_stmt|;
block|}
comment|// loop over documents, 0x00ppxxxx, 0x01ppxxxx, 0x02ppxxxx
comment|// where pp is the pass (which array we are building), and xx is all values.
comment|// each pass shares the same byte[] for termNumber lists.
for|for
control|(
name|int
name|docbase
init|=
name|pass
operator|<<
literal|16
init|;
name|docbase
operator|<
name|maxDoc
condition|;
name|docbase
operator|+=
operator|(
literal|1
operator|<<
literal|24
operator|)
control|)
block|{
name|int
name|lim
init|=
name|Math
operator|.
name|min
argument_list|(
name|docbase
operator|+
operator|(
literal|1
operator|<<
literal|16
operator|)
argument_list|,
name|maxDoc
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|doc
init|=
name|docbase
init|;
name|doc
operator|<
name|lim
condition|;
name|doc
operator|++
control|)
block|{
comment|//System.out.println("  pass=" + pass + " process docID=" + doc);
name|int
name|val
init|=
name|index
index|[
name|doc
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0xff
operator|)
operator|==
literal|1
condition|)
block|{
name|int
name|len
init|=
name|val
operator|>>>
literal|8
decl_stmt|;
comment|//System.out.println("    ptr pos=" + pos);
name|index
index|[
name|doc
index|]
operator|=
operator|(
name|pos
operator|<<
literal|8
operator|)
operator||
literal|1
expr_stmt|;
comment|// change index to point to start of array
if|if
condition|(
operator|(
name|pos
operator|&
literal|0xff000000
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// we only have 24 bits for the array index
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Too many values for UnInvertedField faceting on field "
operator|+
name|field
argument_list|)
throw|;
block|}
name|byte
index|[]
name|arr
init|=
name|bytes
index|[
name|doc
index|]
decl_stmt|;
comment|/*               for(byte b : arr) {                 //System.out.println("      b=" + Integer.toHexString((int) b));               }               */
name|bytes
index|[
name|doc
index|]
operator|=
literal|null
expr_stmt|;
comment|// IMPORTANT: allow GC to avoid OOM
if|if
condition|(
name|target
operator|.
name|length
operator|<=
name|pos
operator|+
name|len
condition|)
block|{
name|int
name|newlen
init|=
name|target
operator|.
name|length
decl_stmt|;
comment|/*** we don't have to worry about the array getting too large                  * since the "pos" param will overflow first (only 24 bits available)                 if ((newlen<<1)<= 0) {                   // overflow...                   newlen = Integer.MAX_VALUE;                   if (newlen<= pos + len) {                     throw new SolrException(400,"Too many terms to uninvert field!");                   }                 } else {                   while (newlen<= pos + len) newlen<<=1;  // doubling strategy                 }                 ****/
while|while
condition|(
name|newlen
operator|<=
name|pos
operator|+
name|len
condition|)
name|newlen
operator|<<=
literal|1
expr_stmt|;
comment|// doubling strategy
name|byte
index|[]
name|newtarget
init|=
operator|new
name|byte
index|[
name|newlen
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|target
argument_list|,
literal|0
argument_list|,
name|newtarget
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|target
operator|=
name|newtarget
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|arr
argument_list|,
literal|0
argument_list|,
name|target
argument_list|,
name|pos
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
comment|// skip single byte at end and leave it 0 for terminator
block|}
block|}
block|}
comment|// shrink array
if|if
condition|(
name|pos
operator|<
name|target
operator|.
name|length
condition|)
block|{
name|byte
index|[]
name|newtarget
init|=
operator|new
name|byte
index|[
name|pos
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|target
argument_list|,
literal|0
argument_list|,
name|newtarget
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|target
operator|=
name|newtarget
expr_stmt|;
block|}
name|tnums
index|[
name|pass
index|]
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|(
name|pass
operator|<<
literal|16
operator|)
operator|>
name|maxDoc
condition|)
break|break;
block|}
block|}
name|indexedTermsArray
operator|=
name|indexedTerms
operator|.
name|toArray
argument_list|(
operator|new
name|BytesRef
index|[
name|indexedTerms
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|long
name|endTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|total_time
operator|=
call|(
name|int
call|)
argument_list|(
name|endTime
operator|-
name|startTime
argument_list|)
expr_stmt|;
name|phase1_time
operator|=
call|(
name|int
call|)
argument_list|(
name|midPoint
operator|-
name|startTime
argument_list|)
expr_stmt|;
block|}
comment|/** Number of bytes to represent an unsigned int as a vint. */
DECL|method|vIntSize
specifier|private
specifier|static
name|int
name|vIntSize
parameter_list|(
name|int
name|x
parameter_list|)
block|{
if|if
condition|(
operator|(
name|x
operator|&
operator|(
literal|0xffffffff
operator|<<
operator|(
literal|7
operator|*
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|x
operator|&
operator|(
literal|0xffffffff
operator|<<
operator|(
literal|7
operator|*
literal|2
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|2
return|;
block|}
if|if
condition|(
operator|(
name|x
operator|&
operator|(
literal|0xffffffff
operator|<<
operator|(
literal|7
operator|*
literal|3
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|3
return|;
block|}
if|if
condition|(
operator|(
name|x
operator|&
operator|(
literal|0xffffffff
operator|<<
operator|(
literal|7
operator|*
literal|4
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|4
return|;
block|}
return|return
literal|5
return|;
block|}
comment|// todo: if we know the size of the vInt already, we could do
comment|// a single switch on the size
DECL|method|writeInt
specifier|private
specifier|static
name|int
name|writeInt
parameter_list|(
name|int
name|x
parameter_list|,
name|byte
index|[]
name|arr
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|int
name|a
decl_stmt|;
name|a
operator|=
operator|(
name|x
operator|>>>
operator|(
literal|7
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|a
operator|!=
literal|0
condition|)
block|{
name|arr
index|[
name|pos
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|a
operator||
literal|0x80
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
operator|(
name|x
operator|>>>
operator|(
literal|7
operator|*
literal|3
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|a
operator|!=
literal|0
condition|)
block|{
name|arr
index|[
name|pos
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|a
operator||
literal|0x80
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
operator|(
name|x
operator|>>>
operator|(
literal|7
operator|*
literal|2
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|a
operator|!=
literal|0
condition|)
block|{
name|arr
index|[
name|pos
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|a
operator||
literal|0x80
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
operator|(
name|x
operator|>>>
operator|(
literal|7
operator|*
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|a
operator|!=
literal|0
condition|)
block|{
name|arr
index|[
name|pos
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|a
operator||
literal|0x80
argument_list|)
expr_stmt|;
block|}
name|arr
index|[
name|pos
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|x
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
comment|/**     * "wrap" our own terms index around the original IndexReader.     * Only valid if there are terms for this field rom the original reader    */
DECL|class|OrdWrappedTermsEnum
specifier|private
specifier|final
class|class
name|OrdWrappedTermsEnum
extends|extends
name|TermsEnum
block|{
DECL|field|termsEnum
specifier|private
specifier|final
name|TermsEnum
name|termsEnum
decl_stmt|;
DECL|field|term
specifier|private
name|BytesRef
name|term
decl_stmt|;
DECL|field|ord
specifier|private
name|long
name|ord
init|=
operator|-
name|indexInterval
operator|-
literal|1
decl_stmt|;
comment|// force "real" seek
DECL|method|OrdWrappedTermsEnum
specifier|public
name|OrdWrappedTermsEnum
parameter_list|(
name|LeafReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|indexedTermsArray
operator|!=
literal|null
assert|;
assert|assert
literal|0
operator|!=
name|indexedTermsArray
operator|.
name|length
assert|;
name|termsEnum
operator|=
name|reader
operator|.
name|fields
argument_list|()
operator|.
name|terms
argument_list|(
name|field
argument_list|)
operator|.
name|iterator
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|postings
specifier|public
name|PostingsEnum
name|postings
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|PostingsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|termsEnum
operator|.
name|postings
argument_list|(
name|liveDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
block|{
return|return
name|term
return|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|++
name|ord
operator|<
literal|0
condition|)
block|{
name|ord
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|termsEnum
operator|.
name|next
argument_list|()
operator|==
literal|null
condition|)
block|{
name|term
operator|=
literal|null
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|setTerm
argument_list|()
return|;
comment|// this is extra work if we know we are in bounds...
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|termsEnum
operator|.
name|docFreq
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|termsEnum
operator|.
name|totalTermFreq
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
block|{
return|return
name|ordBase
operator|+
name|ord
return|;
block|}
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
name|BytesRef
name|target
parameter_list|)
throws|throws
name|IOException
block|{
comment|// already here
if|if
condition|(
name|term
operator|!=
literal|null
operator|&&
name|term
operator|.
name|equals
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
name|int
name|startIdx
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|indexedTermsArray
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|startIdx
operator|>=
literal|0
condition|)
block|{
comment|// we hit the term exactly... lucky us!
name|TermsEnum
operator|.
name|SeekStatus
name|seekStatus
init|=
name|termsEnum
operator|.
name|seekCeil
argument_list|(
name|target
argument_list|)
decl_stmt|;
assert|assert
name|seekStatus
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|FOUND
assert|;
name|ord
operator|=
name|startIdx
operator|<<
name|indexIntervalBits
expr_stmt|;
name|setTerm
argument_list|()
expr_stmt|;
assert|assert
name|term
operator|!=
literal|null
assert|;
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
comment|// we didn't hit the term exactly
name|startIdx
operator|=
operator|-
name|startIdx
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|startIdx
operator|==
literal|0
condition|)
block|{
comment|// our target occurs *before* the first term
name|TermsEnum
operator|.
name|SeekStatus
name|seekStatus
init|=
name|termsEnum
operator|.
name|seekCeil
argument_list|(
name|target
argument_list|)
decl_stmt|;
assert|assert
name|seekStatus
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|NOT_FOUND
assert|;
name|ord
operator|=
literal|0
expr_stmt|;
name|setTerm
argument_list|()
expr_stmt|;
assert|assert
name|term
operator|!=
literal|null
assert|;
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
comment|// back up to the start of the block
name|startIdx
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|ord
operator|>>
name|indexIntervalBits
operator|)
operator|==
name|startIdx
operator|&&
name|term
operator|!=
literal|null
operator|&&
name|term
operator|.
name|compareTo
argument_list|(
name|target
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|// we are already in the right block and the current term is before the term we want,
comment|// so we don't need to seek.
block|}
else|else
block|{
comment|// seek to the right block
name|TermsEnum
operator|.
name|SeekStatus
name|seekStatus
init|=
name|termsEnum
operator|.
name|seekCeil
argument_list|(
name|indexedTermsArray
index|[
name|startIdx
index|]
argument_list|)
decl_stmt|;
assert|assert
name|seekStatus
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|FOUND
assert|;
name|ord
operator|=
name|startIdx
operator|<<
name|indexIntervalBits
expr_stmt|;
name|setTerm
argument_list|()
expr_stmt|;
assert|assert
name|term
operator|!=
literal|null
assert|;
comment|// should be non-null since it's in the index
block|}
while|while
condition|(
name|term
operator|!=
literal|null
operator|&&
name|term
operator|.
name|compareTo
argument_list|(
name|target
argument_list|)
operator|<
literal|0
condition|)
block|{
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|term
operator|==
literal|null
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
elseif|else
if|if
condition|(
name|term
operator|.
name|compareTo
argument_list|(
name|target
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
else|else
block|{
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|targetOrd
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|delta
init|=
call|(
name|int
call|)
argument_list|(
name|targetOrd
operator|-
name|ordBase
operator|-
name|ord
argument_list|)
decl_stmt|;
comment|//System.out.println("  seek(ord) targetOrd=" + targetOrd + " delta=" + delta + " ord=" + ord + " ii=" + indexInterval);
if|if
condition|(
name|delta
argument_list|<
literal|0
operator|||
name|delta
argument_list|>
name|indexInterval
condition|)
block|{
specifier|final
name|int
name|idx
init|=
call|(
name|int
call|)
argument_list|(
name|targetOrd
operator|>>>
name|indexIntervalBits
argument_list|)
decl_stmt|;
specifier|final
name|BytesRef
name|base
init|=
name|indexedTermsArray
index|[
name|idx
index|]
decl_stmt|;
comment|//System.out.println("  do seek term=" + base.utf8ToString());
name|ord
operator|=
name|idx
operator|<<
name|indexIntervalBits
expr_stmt|;
name|delta
operator|=
call|(
name|int
call|)
argument_list|(
name|targetOrd
operator|-
name|ord
argument_list|)
expr_stmt|;
specifier|final
name|TermsEnum
operator|.
name|SeekStatus
name|seekStatus
init|=
name|termsEnum
operator|.
name|seekCeil
argument_list|(
name|base
argument_list|)
decl_stmt|;
assert|assert
name|seekStatus
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|FOUND
assert|;
block|}
else|else
block|{
comment|//System.out.println("seek w/in block");
block|}
while|while
condition|(
operator|--
name|delta
operator|>=
literal|0
condition|)
block|{
name|BytesRef
name|br
init|=
name|termsEnum
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|br
operator|==
literal|null
condition|)
block|{
assert|assert
literal|false
assert|;
return|return;
block|}
name|ord
operator|++
expr_stmt|;
block|}
name|setTerm
argument_list|()
expr_stmt|;
assert|assert
name|term
operator|!=
literal|null
assert|;
block|}
DECL|method|setTerm
specifier|private
name|BytesRef
name|setTerm
parameter_list|()
throws|throws
name|IOException
block|{
name|term
operator|=
name|termsEnum
operator|.
name|term
argument_list|()
expr_stmt|;
comment|//System.out.println("  setTerm() term=" + term.utf8ToString() + " vs prefix=" + (prefix == null ? "null" : prefix.utf8ToString()));
if|if
condition|(
name|prefix
operator|!=
literal|null
operator|&&
operator|!
name|StringHelper
operator|.
name|startsWith
argument_list|(
name|term
argument_list|,
name|prefix
argument_list|)
condition|)
block|{
name|term
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|term
return|;
block|}
block|}
comment|/** Returns the term ({@link BytesRef}) corresponding to    *  the provided ordinal. */
DECL|method|lookupTerm
specifier|public
name|BytesRef
name|lookupTerm
parameter_list|(
name|TermsEnum
name|termsEnum
parameter_list|,
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
name|termsEnum
operator|.
name|seekExact
argument_list|(
name|ord
argument_list|)
expr_stmt|;
return|return
name|termsEnum
operator|.
name|term
argument_list|()
return|;
block|}
comment|/** Returns a SortedSetDocValues view of this instance */
DECL|method|iterator
specifier|public
name|SortedSetDocValues
name|iterator
parameter_list|(
name|LeafReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|DocValues
operator|.
name|emptySortedSet
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|new
name|Iterator
argument_list|(
name|reader
argument_list|)
return|;
block|}
block|}
DECL|class|Iterator
specifier|private
class|class
name|Iterator
extends|extends
name|SortedSetDocValues
block|{
DECL|field|reader
specifier|final
name|LeafReader
name|reader
decl_stmt|;
DECL|field|te
specifier|final
name|TermsEnum
name|te
decl_stmt|;
comment|// used internally for lookupOrd() and lookupTerm()
comment|// currently we read 5 at a time (using the logic of the old iterator)
DECL|field|buffer
specifier|final
name|int
name|buffer
index|[]
init|=
operator|new
name|int
index|[
literal|5
index|]
decl_stmt|;
DECL|field|bufferUpto
name|int
name|bufferUpto
decl_stmt|;
DECL|field|bufferLength
name|int
name|bufferLength
decl_stmt|;
DECL|field|tnum
specifier|private
name|int
name|tnum
decl_stmt|;
DECL|field|upto
specifier|private
name|int
name|upto
decl_stmt|;
DECL|field|arr
specifier|private
name|byte
index|[]
name|arr
decl_stmt|;
DECL|method|Iterator
name|Iterator
parameter_list|(
name|LeafReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|reader
operator|=
name|reader
expr_stmt|;
name|this
operator|.
name|te
operator|=
name|termsEnum
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|nextOrd
specifier|public
name|long
name|nextOrd
parameter_list|()
block|{
while|while
condition|(
name|bufferUpto
operator|==
name|bufferLength
condition|)
block|{
if|if
condition|(
name|bufferLength
operator|<
name|buffer
operator|.
name|length
condition|)
block|{
return|return
name|NO_MORE_ORDS
return|;
block|}
else|else
block|{
name|bufferLength
operator|=
name|read
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|bufferUpto
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|buffer
index|[
name|bufferUpto
operator|++
index|]
return|;
block|}
comment|/** Buffer must be at least 5 ints long.  Returns number      *  of term ords placed into buffer; if this count is      *  less than buffer.length then that is the end. */
DECL|method|read
name|int
name|read
parameter_list|(
name|int
index|[]
name|buffer
parameter_list|)
block|{
name|int
name|bufferUpto
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arr
operator|==
literal|null
condition|)
block|{
comment|// code is inlined into upto
comment|//System.out.println("inlined");
name|int
name|code
init|=
name|upto
decl_stmt|;
name|int
name|delta
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|delta
operator|=
operator|(
name|delta
operator|<<
literal|7
operator|)
operator||
operator|(
name|code
operator|&
literal|0x7f
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
break|break;
name|tnum
operator|+=
name|delta
operator|-
name|TNUM_OFFSET
expr_stmt|;
name|buffer
index|[
name|bufferUpto
operator|++
index|]
operator|=
name|ordBase
operator|+
name|tnum
expr_stmt|;
comment|//System.out.println("  tnum=" + tnum);
name|delta
operator|=
literal|0
expr_stmt|;
block|}
name|code
operator|>>>=
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// code is a pointer
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|delta
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|byte
name|b
init|=
name|arr
index|[
name|upto
operator|++
index|]
decl_stmt|;
name|delta
operator|=
operator|(
name|delta
operator|<<
literal|7
operator|)
operator||
operator|(
name|b
operator|&
literal|0x7f
operator|)
expr_stmt|;
comment|//System.out.println("    cycle: upto=" + upto + " delta=" + delta + " b=" + b);
if|if
condition|(
operator|(
name|b
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|//System.out.println("  delta=" + delta);
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
break|break;
name|tnum
operator|+=
name|delta
operator|-
name|TNUM_OFFSET
expr_stmt|;
comment|//System.out.println("  tnum=" + tnum);
name|buffer
index|[
name|bufferUpto
operator|++
index|]
operator|=
name|ordBase
operator|+
name|tnum
expr_stmt|;
if|if
condition|(
name|bufferUpto
operator|==
name|buffer
operator|.
name|length
condition|)
block|{
break|break;
block|}
block|}
block|}
return|return
name|bufferUpto
return|;
block|}
annotation|@
name|Override
DECL|method|setDocument
specifier|public
name|void
name|setDocument
parameter_list|(
name|int
name|docID
parameter_list|)
block|{
name|tnum
operator|=
literal|0
expr_stmt|;
specifier|final
name|int
name|code
init|=
name|index
index|[
name|docID
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|0xff
operator|)
operator|==
literal|1
condition|)
block|{
comment|// a pointer
name|upto
operator|=
name|code
operator|>>>
literal|8
expr_stmt|;
comment|//System.out.println("    pointer!  upto=" + upto);
name|int
name|whichArray
init|=
operator|(
name|docID
operator|>>>
literal|16
operator|)
operator|&
literal|0xff
decl_stmt|;
name|arr
operator|=
name|tnums
index|[
name|whichArray
index|]
expr_stmt|;
block|}
else|else
block|{
comment|//System.out.println("    inline!");
name|arr
operator|=
literal|null
expr_stmt|;
name|upto
operator|=
name|code
expr_stmt|;
block|}
name|bufferUpto
operator|=
literal|0
expr_stmt|;
name|bufferLength
operator|=
name|read
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|lookupOrd
specifier|public
name|BytesRef
name|lookupOrd
parameter_list|(
name|long
name|ord
parameter_list|)
block|{
try|try
block|{
return|return
name|DocTermOrds
operator|.
name|this
operator|.
name|lookupTerm
argument_list|(
name|te
argument_list|,
operator|(
name|int
operator|)
name|ord
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getValueCount
specifier|public
name|long
name|getValueCount
parameter_list|()
block|{
return|return
name|numTerms
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|lookupTerm
specifier|public
name|long
name|lookupTerm
parameter_list|(
name|BytesRef
name|key
parameter_list|)
block|{
try|try
block|{
switch|switch
condition|(
name|te
operator|.
name|seekCeil
argument_list|(
name|key
argument_list|)
condition|)
block|{
case|case
name|FOUND
case|:
assert|assert
name|te
operator|.
name|ord
argument_list|()
operator|>=
literal|0
assert|;
return|return
name|te
operator|.
name|ord
argument_list|()
return|;
case|case
name|NOT_FOUND
case|:
assert|assert
name|te
operator|.
name|ord
argument_list|()
operator|>=
literal|0
assert|;
return|return
operator|-
name|te
operator|.
name|ord
argument_list|()
operator|-
literal|1
return|;
default|default:
comment|/* END */
return|return
operator|-
name|numTerms
argument_list|()
operator|-
literal|1
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|termsEnum
specifier|public
name|TermsEnum
name|termsEnum
parameter_list|()
block|{
try|try
block|{
return|return
name|getOrdTermsEnum
argument_list|(
name|reader
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class
end_unit
