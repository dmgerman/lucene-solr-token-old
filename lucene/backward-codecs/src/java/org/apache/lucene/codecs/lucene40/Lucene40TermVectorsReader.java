begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.lucene40
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene40
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|TermVectorsReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Fields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFileNames
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_comment
comment|/**  * Lucene 4.0 Term Vectors reader.  *<p>  * It reads .tvd, .tvf, and .tvx files.  *   * @see Lucene40TermVectorsFormat  */
end_comment
begin_class
DECL|class|Lucene40TermVectorsReader
specifier|public
class|class
name|Lucene40TermVectorsReader
extends|extends
name|TermVectorsReader
implements|implements
name|Closeable
block|{
DECL|field|STORE_POSITIONS_WITH_TERMVECTOR
specifier|static
specifier|final
name|byte
name|STORE_POSITIONS_WITH_TERMVECTOR
init|=
literal|0x1
decl_stmt|;
DECL|field|STORE_OFFSET_WITH_TERMVECTOR
specifier|static
specifier|final
name|byte
name|STORE_OFFSET_WITH_TERMVECTOR
init|=
literal|0x2
decl_stmt|;
DECL|field|STORE_PAYLOAD_WITH_TERMVECTOR
specifier|static
specifier|final
name|byte
name|STORE_PAYLOAD_WITH_TERMVECTOR
init|=
literal|0x4
decl_stmt|;
comment|/** Extension of vectors fields file */
DECL|field|VECTORS_FIELDS_EXTENSION
specifier|static
specifier|final
name|String
name|VECTORS_FIELDS_EXTENSION
init|=
literal|"tvf"
decl_stmt|;
comment|/** Extension of vectors documents file */
DECL|field|VECTORS_DOCUMENTS_EXTENSION
specifier|static
specifier|final
name|String
name|VECTORS_DOCUMENTS_EXTENSION
init|=
literal|"tvd"
decl_stmt|;
comment|/** Extension of vectors index file */
DECL|field|VECTORS_INDEX_EXTENSION
specifier|static
specifier|final
name|String
name|VECTORS_INDEX_EXTENSION
init|=
literal|"tvx"
decl_stmt|;
DECL|field|CODEC_NAME_FIELDS
specifier|static
specifier|final
name|String
name|CODEC_NAME_FIELDS
init|=
literal|"Lucene40TermVectorsFields"
decl_stmt|;
DECL|field|CODEC_NAME_DOCS
specifier|static
specifier|final
name|String
name|CODEC_NAME_DOCS
init|=
literal|"Lucene40TermVectorsDocs"
decl_stmt|;
DECL|field|CODEC_NAME_INDEX
specifier|static
specifier|final
name|String
name|CODEC_NAME_INDEX
init|=
literal|"Lucene40TermVectorsIndex"
decl_stmt|;
DECL|field|VERSION_NO_PAYLOADS
specifier|static
specifier|final
name|int
name|VERSION_NO_PAYLOADS
init|=
literal|0
decl_stmt|;
DECL|field|VERSION_PAYLOADS
specifier|static
specifier|final
name|int
name|VERSION_PAYLOADS
init|=
literal|1
decl_stmt|;
DECL|field|VERSION_START
specifier|static
specifier|final
name|int
name|VERSION_START
init|=
name|VERSION_NO_PAYLOADS
decl_stmt|;
DECL|field|VERSION_CURRENT
specifier|static
specifier|final
name|int
name|VERSION_CURRENT
init|=
name|VERSION_PAYLOADS
decl_stmt|;
DECL|field|HEADER_LENGTH_FIELDS
specifier|static
specifier|final
name|long
name|HEADER_LENGTH_FIELDS
init|=
name|CodecUtil
operator|.
name|headerLength
argument_list|(
name|CODEC_NAME_FIELDS
argument_list|)
decl_stmt|;
DECL|field|HEADER_LENGTH_DOCS
specifier|static
specifier|final
name|long
name|HEADER_LENGTH_DOCS
init|=
name|CodecUtil
operator|.
name|headerLength
argument_list|(
name|CODEC_NAME_DOCS
argument_list|)
decl_stmt|;
DECL|field|HEADER_LENGTH_INDEX
specifier|static
specifier|final
name|long
name|HEADER_LENGTH_INDEX
init|=
name|CodecUtil
operator|.
name|headerLength
argument_list|(
name|CODEC_NAME_INDEX
argument_list|)
decl_stmt|;
DECL|field|fieldInfos
specifier|private
name|FieldInfos
name|fieldInfos
decl_stmt|;
DECL|field|tvx
specifier|private
name|IndexInput
name|tvx
decl_stmt|;
DECL|field|tvd
specifier|private
name|IndexInput
name|tvd
decl_stmt|;
DECL|field|tvf
specifier|private
name|IndexInput
name|tvf
decl_stmt|;
DECL|field|size
specifier|private
name|int
name|size
decl_stmt|;
DECL|field|numTotalDocs
specifier|private
name|int
name|numTotalDocs
decl_stmt|;
comment|/** Used by clone. */
DECL|method|Lucene40TermVectorsReader
name|Lucene40TermVectorsReader
parameter_list|(
name|FieldInfos
name|fieldInfos
parameter_list|,
name|IndexInput
name|tvx
parameter_list|,
name|IndexInput
name|tvd
parameter_list|,
name|IndexInput
name|tvf
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|numTotalDocs
parameter_list|)
block|{
name|this
operator|.
name|fieldInfos
operator|=
name|fieldInfos
expr_stmt|;
name|this
operator|.
name|tvx
operator|=
name|tvx
expr_stmt|;
name|this
operator|.
name|tvd
operator|=
name|tvd
expr_stmt|;
name|this
operator|.
name|tvf
operator|=
name|tvf
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|this
operator|.
name|numTotalDocs
operator|=
name|numTotalDocs
expr_stmt|;
block|}
comment|/** Sole constructor. */
DECL|method|Lucene40TermVectorsReader
specifier|public
name|Lucene40TermVectorsReader
parameter_list|(
name|Directory
name|d
parameter_list|,
name|SegmentInfo
name|si
parameter_list|,
name|FieldInfos
name|fieldInfos
parameter_list|,
name|IOContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|segment
init|=
name|si
operator|.
name|name
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|si
operator|.
name|getDocCount
argument_list|()
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|String
name|idxName
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segment
argument_list|,
literal|""
argument_list|,
name|VECTORS_INDEX_EXTENSION
argument_list|)
decl_stmt|;
name|tvx
operator|=
name|d
operator|.
name|openInput
argument_list|(
name|idxName
argument_list|,
name|context
argument_list|)
expr_stmt|;
specifier|final
name|int
name|tvxVersion
init|=
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|tvx
argument_list|,
name|CODEC_NAME_INDEX
argument_list|,
name|VERSION_START
argument_list|,
name|VERSION_CURRENT
argument_list|)
decl_stmt|;
name|String
name|fn
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segment
argument_list|,
literal|""
argument_list|,
name|VECTORS_DOCUMENTS_EXTENSION
argument_list|)
decl_stmt|;
name|tvd
operator|=
name|d
operator|.
name|openInput
argument_list|(
name|fn
argument_list|,
name|context
argument_list|)
expr_stmt|;
specifier|final
name|int
name|tvdVersion
init|=
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|tvd
argument_list|,
name|CODEC_NAME_DOCS
argument_list|,
name|VERSION_START
argument_list|,
name|VERSION_CURRENT
argument_list|)
decl_stmt|;
name|fn
operator|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segment
argument_list|,
literal|""
argument_list|,
name|VECTORS_FIELDS_EXTENSION
argument_list|)
expr_stmt|;
name|tvf
operator|=
name|d
operator|.
name|openInput
argument_list|(
name|fn
argument_list|,
name|context
argument_list|)
expr_stmt|;
specifier|final
name|int
name|tvfVersion
init|=
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|tvf
argument_list|,
name|CODEC_NAME_FIELDS
argument_list|,
name|VERSION_START
argument_list|,
name|VERSION_CURRENT
argument_list|)
decl_stmt|;
assert|assert
name|HEADER_LENGTH_INDEX
operator|==
name|tvx
operator|.
name|getFilePointer
argument_list|()
assert|;
assert|assert
name|HEADER_LENGTH_DOCS
operator|==
name|tvd
operator|.
name|getFilePointer
argument_list|()
assert|;
assert|assert
name|HEADER_LENGTH_FIELDS
operator|==
name|tvf
operator|.
name|getFilePointer
argument_list|()
assert|;
assert|assert
name|tvxVersion
operator|==
name|tvdVersion
assert|;
assert|assert
name|tvxVersion
operator|==
name|tvfVersion
assert|;
name|numTotalDocs
operator|=
call|(
name|int
call|)
argument_list|(
name|tvx
operator|.
name|length
argument_list|()
operator|-
name|HEADER_LENGTH_INDEX
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|numTotalDocs
expr_stmt|;
assert|assert
name|size
operator|==
literal|0
operator|||
name|numTotalDocs
operator|==
name|size
assert|;
name|this
operator|.
name|fieldInfos
operator|=
name|fieldInfos
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
comment|// With lock-less commits, it's entirely possible (and
comment|// fine) to hit a FileNotFound exception above. In
comment|// this case, we want to explicitly close any subset
comment|// of things that were opened so that we don't have to
comment|// wait for a GC to do so.
if|if
condition|(
operator|!
name|success
condition|)
block|{
try|try
block|{
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{}
comment|// ensure we throw our original exception
block|}
block|}
block|}
comment|// Not private to avoid synthetic access$NNN methods
DECL|method|seekTvx
name|void
name|seekTvx
parameter_list|(
specifier|final
name|int
name|docNum
parameter_list|)
throws|throws
name|IOException
block|{
name|tvx
operator|.
name|seek
argument_list|(
name|docNum
operator|*
literal|16L
operator|+
name|HEADER_LENGTH_INDEX
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|tvx
argument_list|,
name|tvd
argument_list|,
name|tvf
argument_list|)
expr_stmt|;
block|}
comment|/**    *     * @return The number of documents in the reader    */
DECL|method|size
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
DECL|class|TVFields
specifier|private
class|class
name|TVFields
extends|extends
name|Fields
block|{
DECL|field|fieldNumbers
specifier|private
specifier|final
name|int
index|[]
name|fieldNumbers
decl_stmt|;
DECL|field|fieldFPs
specifier|private
specifier|final
name|long
index|[]
name|fieldFPs
decl_stmt|;
DECL|field|fieldNumberToIndex
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|fieldNumberToIndex
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|TVFields
specifier|public
name|TVFields
parameter_list|(
name|int
name|docID
parameter_list|)
throws|throws
name|IOException
block|{
name|seekTvx
argument_list|(
name|docID
argument_list|)
expr_stmt|;
name|tvd
operator|.
name|seek
argument_list|(
name|tvx
operator|.
name|readLong
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|tvd
operator|.
name|readVInt
argument_list|()
decl_stmt|;
assert|assert
name|fieldCount
operator|>=
literal|0
assert|;
if|if
condition|(
name|fieldCount
operator|!=
literal|0
condition|)
block|{
name|fieldNumbers
operator|=
operator|new
name|int
index|[
name|fieldCount
index|]
expr_stmt|;
name|fieldFPs
operator|=
operator|new
name|long
index|[
name|fieldCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|fieldUpto
init|=
literal|0
init|;
name|fieldUpto
operator|<
name|fieldCount
condition|;
name|fieldUpto
operator|++
control|)
block|{
specifier|final
name|int
name|fieldNumber
init|=
name|tvd
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|fieldNumbers
index|[
name|fieldUpto
index|]
operator|=
name|fieldNumber
expr_stmt|;
name|fieldNumberToIndex
operator|.
name|put
argument_list|(
name|fieldNumber
argument_list|,
name|fieldUpto
argument_list|)
expr_stmt|;
block|}
name|long
name|position
init|=
name|tvx
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|fieldFPs
index|[
literal|0
index|]
operator|=
name|position
expr_stmt|;
for|for
control|(
name|int
name|fieldUpto
init|=
literal|1
init|;
name|fieldUpto
operator|<
name|fieldCount
condition|;
name|fieldUpto
operator|++
control|)
block|{
name|position
operator|+=
name|tvd
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|fieldFPs
index|[
name|fieldUpto
index|]
operator|=
name|position
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// TODO: we can improve writer here, eg write 0 into
comment|// tvx file, so we know on first read from tvx that
comment|// this doc has no TVs
name|fieldNumbers
operator|=
literal|null
expr_stmt|;
name|fieldFPs
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|fieldUpto
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|next
parameter_list|()
block|{
if|if
condition|(
name|fieldNumbers
operator|!=
literal|null
operator|&&
name|fieldUpto
operator|<
name|fieldNumbers
operator|.
name|length
condition|)
block|{
return|return
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|fieldNumbers
index|[
name|fieldUpto
operator|++
index|]
argument_list|)
operator|.
name|name
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|fieldNumbers
operator|!=
literal|null
operator|&&
name|fieldUpto
operator|<
name|fieldNumbers
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|terms
specifier|public
name|Terms
name|terms
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FieldInfo
name|fieldInfo
init|=
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldInfo
operator|==
literal|null
condition|)
block|{
comment|// No such field
return|return
literal|null
return|;
block|}
specifier|final
name|Integer
name|fieldIndex
init|=
name|fieldNumberToIndex
operator|.
name|get
argument_list|(
name|fieldInfo
operator|.
name|number
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldIndex
operator|==
literal|null
condition|)
block|{
comment|// Term vectors were not indexed for this field
return|return
literal|null
return|;
block|}
return|return
operator|new
name|TVTerms
argument_list|(
name|fieldFPs
index|[
name|fieldIndex
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
if|if
condition|(
name|fieldNumbers
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|fieldNumbers
operator|.
name|length
return|;
block|}
block|}
block|}
DECL|class|TVTerms
specifier|private
class|class
name|TVTerms
extends|extends
name|Terms
block|{
DECL|field|numTerms
specifier|private
specifier|final
name|int
name|numTerms
decl_stmt|;
DECL|field|tvfFPStart
specifier|private
specifier|final
name|long
name|tvfFPStart
decl_stmt|;
DECL|field|storePositions
specifier|private
specifier|final
name|boolean
name|storePositions
decl_stmt|;
DECL|field|storeOffsets
specifier|private
specifier|final
name|boolean
name|storeOffsets
decl_stmt|;
DECL|field|storePayloads
specifier|private
specifier|final
name|boolean
name|storePayloads
decl_stmt|;
DECL|method|TVTerms
specifier|public
name|TVTerms
parameter_list|(
name|long
name|tvfFP
parameter_list|)
throws|throws
name|IOException
block|{
name|tvf
operator|.
name|seek
argument_list|(
name|tvfFP
argument_list|)
expr_stmt|;
name|numTerms
operator|=
name|tvf
operator|.
name|readVInt
argument_list|()
expr_stmt|;
specifier|final
name|byte
name|bits
init|=
name|tvf
operator|.
name|readByte
argument_list|()
decl_stmt|;
name|storePositions
operator|=
operator|(
name|bits
operator|&
name|STORE_POSITIONS_WITH_TERMVECTOR
operator|)
operator|!=
literal|0
expr_stmt|;
name|storeOffsets
operator|=
operator|(
name|bits
operator|&
name|STORE_OFFSET_WITH_TERMVECTOR
operator|)
operator|!=
literal|0
expr_stmt|;
name|storePayloads
operator|=
operator|(
name|bits
operator|&
name|STORE_PAYLOAD_WITH_TERMVECTOR
operator|)
operator|!=
literal|0
expr_stmt|;
name|tvfFPStart
operator|=
name|tvf
operator|.
name|getFilePointer
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|TermsEnum
name|iterator
parameter_list|(
name|TermsEnum
name|reuse
parameter_list|)
throws|throws
name|IOException
block|{
name|TVTermsEnum
name|termsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|instanceof
name|TVTermsEnum
condition|)
block|{
name|termsEnum
operator|=
operator|(
name|TVTermsEnum
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
operator|!
name|termsEnum
operator|.
name|canReuse
argument_list|(
name|tvf
argument_list|)
condition|)
block|{
name|termsEnum
operator|=
operator|new
name|TVTermsEnum
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|termsEnum
operator|=
operator|new
name|TVTermsEnum
argument_list|()
expr_stmt|;
block|}
name|termsEnum
operator|.
name|reset
argument_list|(
name|numTerms
argument_list|,
name|tvfFPStart
argument_list|,
name|storePositions
argument_list|,
name|storeOffsets
argument_list|,
name|storePayloads
argument_list|)
expr_stmt|;
return|return
name|termsEnum
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|long
name|size
parameter_list|()
block|{
return|return
name|numTerms
return|;
block|}
annotation|@
name|Override
DECL|method|getSumTotalTermFreq
specifier|public
name|long
name|getSumTotalTermFreq
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|getSumDocFreq
specifier|public
name|long
name|getSumDocFreq
parameter_list|()
block|{
comment|// Every term occurs in just one doc:
return|return
name|numTerms
return|;
block|}
annotation|@
name|Override
DECL|method|getDocCount
specifier|public
name|int
name|getDocCount
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|hasFreqs
specifier|public
name|boolean
name|hasFreqs
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|hasOffsets
specifier|public
name|boolean
name|hasOffsets
parameter_list|()
block|{
return|return
name|storeOffsets
return|;
block|}
annotation|@
name|Override
DECL|method|hasPositions
specifier|public
name|boolean
name|hasPositions
parameter_list|()
block|{
return|return
name|storePositions
return|;
block|}
annotation|@
name|Override
DECL|method|hasPayloads
specifier|public
name|boolean
name|hasPayloads
parameter_list|()
block|{
return|return
name|storePayloads
return|;
block|}
block|}
DECL|class|TVTermsEnum
specifier|private
class|class
name|TVTermsEnum
extends|extends
name|TermsEnum
block|{
DECL|field|origTVF
specifier|private
specifier|final
name|IndexInput
name|origTVF
decl_stmt|;
DECL|field|tvf
specifier|private
specifier|final
name|IndexInput
name|tvf
decl_stmt|;
DECL|field|numTerms
specifier|private
name|int
name|numTerms
decl_stmt|;
DECL|field|nextTerm
specifier|private
name|int
name|nextTerm
decl_stmt|;
DECL|field|freq
specifier|private
name|int
name|freq
decl_stmt|;
DECL|field|lastTerm
specifier|private
name|BytesRefBuilder
name|lastTerm
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
DECL|field|term
specifier|private
name|BytesRefBuilder
name|term
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
DECL|field|storePositions
specifier|private
name|boolean
name|storePositions
decl_stmt|;
DECL|field|storeOffsets
specifier|private
name|boolean
name|storeOffsets
decl_stmt|;
DECL|field|storePayloads
specifier|private
name|boolean
name|storePayloads
decl_stmt|;
DECL|field|tvfFP
specifier|private
name|long
name|tvfFP
decl_stmt|;
DECL|field|positions
specifier|private
name|int
index|[]
name|positions
decl_stmt|;
DECL|field|startOffsets
specifier|private
name|int
index|[]
name|startOffsets
decl_stmt|;
DECL|field|endOffsets
specifier|private
name|int
index|[]
name|endOffsets
decl_stmt|;
comment|// one shared byte[] for any term's payloads
DECL|field|payloadOffsets
specifier|private
name|int
index|[]
name|payloadOffsets
decl_stmt|;
DECL|field|lastPayloadLength
specifier|private
name|int
name|lastPayloadLength
decl_stmt|;
DECL|field|payloadData
specifier|private
name|byte
index|[]
name|payloadData
decl_stmt|;
comment|// NOTE: tvf is pre-positioned by caller
DECL|method|TVTermsEnum
specifier|public
name|TVTermsEnum
parameter_list|()
block|{
name|this
operator|.
name|origTVF
operator|=
name|Lucene40TermVectorsReader
operator|.
name|this
operator|.
name|tvf
expr_stmt|;
name|tvf
operator|=
name|origTVF
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
DECL|method|canReuse
specifier|public
name|boolean
name|canReuse
parameter_list|(
name|IndexInput
name|tvf
parameter_list|)
block|{
return|return
name|tvf
operator|==
name|origTVF
return|;
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|(
name|int
name|numTerms
parameter_list|,
name|long
name|tvfFPStart
parameter_list|,
name|boolean
name|storePositions
parameter_list|,
name|boolean
name|storeOffsets
parameter_list|,
name|boolean
name|storePayloads
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|numTerms
operator|=
name|numTerms
expr_stmt|;
name|this
operator|.
name|storePositions
operator|=
name|storePositions
expr_stmt|;
name|this
operator|.
name|storeOffsets
operator|=
name|storeOffsets
expr_stmt|;
name|this
operator|.
name|storePayloads
operator|=
name|storePayloads
expr_stmt|;
name|nextTerm
operator|=
literal|0
expr_stmt|;
name|tvf
operator|.
name|seek
argument_list|(
name|tvfFPStart
argument_list|)
expr_stmt|;
name|tvfFP
operator|=
name|tvfFPStart
expr_stmt|;
name|positions
operator|=
literal|null
expr_stmt|;
name|startOffsets
operator|=
literal|null
expr_stmt|;
name|endOffsets
operator|=
literal|null
expr_stmt|;
name|payloadOffsets
operator|=
literal|null
expr_stmt|;
name|payloadData
operator|=
literal|null
expr_stmt|;
name|lastPayloadLength
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|// NOTE: slow!  (linear scan)
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
name|BytesRef
name|text
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|nextTerm
operator|!=
literal|0
condition|)
block|{
specifier|final
name|int
name|cmp
init|=
name|text
operator|.
name|compareTo
argument_list|(
name|term
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|nextTerm
operator|=
literal|0
expr_stmt|;
name|tvf
operator|.
name|seek
argument_list|(
name|tvfFP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
block|}
while|while
condition|(
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|cmp
init|=
name|text
operator|.
name|compareTo
argument_list|(
name|term
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
block|}
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|ord
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|nextTerm
operator|>=
name|numTerms
condition|)
block|{
return|return
literal|null
return|;
block|}
name|term
operator|.
name|copyBytes
argument_list|(
name|lastTerm
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
name|start
init|=
name|tvf
operator|.
name|readVInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|deltaLen
init|=
name|tvf
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|term
operator|.
name|setLength
argument_list|(
name|start
operator|+
name|deltaLen
argument_list|)
expr_stmt|;
name|term
operator|.
name|grow
argument_list|(
name|term
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|tvf
operator|.
name|readBytes
argument_list|(
name|term
operator|.
name|bytes
argument_list|()
argument_list|,
name|start
argument_list|,
name|deltaLen
argument_list|)
expr_stmt|;
name|freq
operator|=
name|tvf
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|storePayloads
condition|)
block|{
name|positions
operator|=
operator|new
name|int
index|[
name|freq
index|]
expr_stmt|;
name|payloadOffsets
operator|=
operator|new
name|int
index|[
name|freq
index|]
expr_stmt|;
name|int
name|totalPayloadLength
init|=
literal|0
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|posUpto
init|=
literal|0
init|;
name|posUpto
operator|<
name|freq
condition|;
name|posUpto
operator|++
control|)
block|{
name|int
name|code
init|=
name|tvf
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|pos
operator|+=
name|code
operator|>>>
literal|1
expr_stmt|;
name|positions
index|[
name|posUpto
index|]
operator|=
name|pos
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// length change
name|lastPayloadLength
operator|=
name|tvf
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
name|payloadOffsets
index|[
name|posUpto
index|]
operator|=
name|totalPayloadLength
expr_stmt|;
name|totalPayloadLength
operator|+=
name|lastPayloadLength
expr_stmt|;
assert|assert
name|totalPayloadLength
operator|>=
literal|0
assert|;
block|}
name|payloadData
operator|=
operator|new
name|byte
index|[
name|totalPayloadLength
index|]
expr_stmt|;
name|tvf
operator|.
name|readBytes
argument_list|(
name|payloadData
argument_list|,
literal|0
argument_list|,
name|payloadData
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storePositions
comment|/* no payloads */
condition|)
block|{
comment|// TODO: we could maybe reuse last array, if we can
comment|// somehow be careful about consumer never using two
comment|// D&PEnums at once...
name|positions
operator|=
operator|new
name|int
index|[
name|freq
index|]
expr_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|posUpto
init|=
literal|0
init|;
name|posUpto
operator|<
name|freq
condition|;
name|posUpto
operator|++
control|)
block|{
name|pos
operator|+=
name|tvf
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|positions
index|[
name|posUpto
index|]
operator|=
name|pos
expr_stmt|;
block|}
block|}
if|if
condition|(
name|storeOffsets
condition|)
block|{
name|startOffsets
operator|=
operator|new
name|int
index|[
name|freq
index|]
expr_stmt|;
name|endOffsets
operator|=
operator|new
name|int
index|[
name|freq
index|]
expr_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|posUpto
init|=
literal|0
init|;
name|posUpto
operator|<
name|freq
condition|;
name|posUpto
operator|++
control|)
block|{
name|startOffsets
index|[
name|posUpto
index|]
operator|=
name|offset
operator|+
name|tvf
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|offset
operator|=
name|endOffsets
index|[
name|posUpto
index|]
operator|=
name|startOffsets
index|[
name|posUpto
index|]
operator|+
name|tvf
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
block|}
name|lastTerm
operator|.
name|copyBytes
argument_list|(
name|term
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|nextTerm
operator|++
expr_stmt|;
return|return
name|term
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
block|{
return|return
name|term
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
block|{
return|return
name|freq
return|;
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|int
name|flags
comment|/* ignored */
parameter_list|)
throws|throws
name|IOException
block|{
name|TVDocsEnum
name|docsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|!=
literal|null
operator|&&
name|reuse
operator|instanceof
name|TVDocsEnum
condition|)
block|{
name|docsEnum
operator|=
operator|(
name|TVDocsEnum
operator|)
name|reuse
expr_stmt|;
block|}
else|else
block|{
name|docsEnum
operator|=
operator|new
name|TVDocsEnum
argument_list|()
expr_stmt|;
block|}
name|docsEnum
operator|.
name|reset
argument_list|(
name|liveDocs
argument_list|,
name|freq
argument_list|)
expr_stmt|;
return|return
name|docsEnum
return|;
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|storePositions
operator|&&
operator|!
name|storeOffsets
condition|)
block|{
return|return
literal|null
return|;
block|}
name|TVDocsAndPositionsEnum
name|docsAndPositionsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|!=
literal|null
operator|&&
name|reuse
operator|instanceof
name|TVDocsAndPositionsEnum
condition|)
block|{
name|docsAndPositionsEnum
operator|=
operator|(
name|TVDocsAndPositionsEnum
operator|)
name|reuse
expr_stmt|;
block|}
else|else
block|{
name|docsAndPositionsEnum
operator|=
operator|new
name|TVDocsAndPositionsEnum
argument_list|()
expr_stmt|;
block|}
name|docsAndPositionsEnum
operator|.
name|reset
argument_list|(
name|liveDocs
argument_list|,
name|positions
argument_list|,
name|startOffsets
argument_list|,
name|endOffsets
argument_list|,
name|payloadOffsets
argument_list|,
name|payloadData
argument_list|)
expr_stmt|;
return|return
name|docsAndPositionsEnum
return|;
block|}
block|}
comment|// NOTE: sort of a silly class, since you can get the
comment|// freq() already by TermsEnum.totalTermFreq
DECL|class|TVDocsEnum
specifier|private
specifier|static
class|class
name|TVDocsEnum
extends|extends
name|DocsEnum
block|{
DECL|field|didNext
specifier|private
name|boolean
name|didNext
decl_stmt|;
DECL|field|doc
specifier|private
name|int
name|doc
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|freq
specifier|private
name|int
name|freq
decl_stmt|;
DECL|field|liveDocs
specifier|private
name|Bits
name|liveDocs
decl_stmt|;
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|freq
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
block|{
if|if
condition|(
operator|!
name|didNext
operator|&&
operator|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
block|{
name|didNext
operator|=
literal|true
expr_stmt|;
return|return
operator|(
name|doc
operator|=
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|doc
operator|=
name|NO_MORE_DOCS
operator|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|slowAdvance
argument_list|(
name|target
argument_list|)
return|;
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
name|this
operator|.
name|freq
operator|=
name|freq
expr_stmt|;
name|this
operator|.
name|doc
operator|=
operator|-
literal|1
expr_stmt|;
name|didNext
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
block|}
DECL|class|TVDocsAndPositionsEnum
specifier|private
specifier|static
class|class
name|TVDocsAndPositionsEnum
extends|extends
name|DocsAndPositionsEnum
block|{
DECL|field|didNext
specifier|private
name|boolean
name|didNext
decl_stmt|;
DECL|field|doc
specifier|private
name|int
name|doc
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|nextPos
specifier|private
name|int
name|nextPos
decl_stmt|;
DECL|field|liveDocs
specifier|private
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|positions
specifier|private
name|int
index|[]
name|positions
decl_stmt|;
DECL|field|startOffsets
specifier|private
name|int
index|[]
name|startOffsets
decl_stmt|;
DECL|field|endOffsets
specifier|private
name|int
index|[]
name|endOffsets
decl_stmt|;
DECL|field|payloadOffsets
specifier|private
name|int
index|[]
name|payloadOffsets
decl_stmt|;
DECL|field|payload
specifier|private
name|BytesRef
name|payload
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
DECL|field|payloadBytes
specifier|private
name|byte
index|[]
name|payloadBytes
decl_stmt|;
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|positions
operator|!=
literal|null
condition|)
block|{
return|return
name|positions
operator|.
name|length
return|;
block|}
else|else
block|{
assert|assert
name|startOffsets
operator|!=
literal|null
assert|;
return|return
name|startOffsets
operator|.
name|length
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
block|{
if|if
condition|(
operator|!
name|didNext
operator|&&
operator|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
block|{
name|didNext
operator|=
literal|true
expr_stmt|;
return|return
operator|(
name|doc
operator|=
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|doc
operator|=
name|NO_MORE_DOCS
operator|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|slowAdvance
argument_list|(
name|target
argument_list|)
return|;
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|int
index|[]
name|positions
parameter_list|,
name|int
index|[]
name|startOffsets
parameter_list|,
name|int
index|[]
name|endOffsets
parameter_list|,
name|int
index|[]
name|payloadLengths
parameter_list|,
name|byte
index|[]
name|payloadBytes
parameter_list|)
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
name|this
operator|.
name|positions
operator|=
name|positions
expr_stmt|;
name|this
operator|.
name|startOffsets
operator|=
name|startOffsets
expr_stmt|;
name|this
operator|.
name|endOffsets
operator|=
name|endOffsets
expr_stmt|;
name|this
operator|.
name|payloadOffsets
operator|=
name|payloadLengths
expr_stmt|;
name|this
operator|.
name|payloadBytes
operator|=
name|payloadBytes
expr_stmt|;
name|this
operator|.
name|doc
operator|=
operator|-
literal|1
expr_stmt|;
name|didNext
operator|=
literal|false
expr_stmt|;
name|nextPos
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getPayload
specifier|public
name|BytesRef
name|getPayload
parameter_list|()
block|{
if|if
condition|(
name|payloadOffsets
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|int
name|off
init|=
name|payloadOffsets
index|[
name|nextPos
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|end
init|=
name|nextPos
operator|==
name|payloadOffsets
operator|.
name|length
condition|?
name|payloadBytes
operator|.
name|length
else|:
name|payloadOffsets
index|[
name|nextPos
index|]
decl_stmt|;
if|if
condition|(
name|end
operator|-
name|off
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|payload
operator|.
name|bytes
operator|=
name|payloadBytes
expr_stmt|;
name|payload
operator|.
name|offset
operator|=
name|off
expr_stmt|;
name|payload
operator|.
name|length
operator|=
name|end
operator|-
name|off
expr_stmt|;
return|return
name|payload
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|nextPosition
specifier|public
name|int
name|nextPosition
parameter_list|()
block|{
assert|assert
operator|(
name|positions
operator|!=
literal|null
operator|&&
name|nextPos
operator|<
name|positions
operator|.
name|length
operator|)
operator|||
name|startOffsets
operator|!=
literal|null
operator|&&
name|nextPos
operator|<
name|startOffsets
operator|.
name|length
assert|;
if|if
condition|(
name|positions
operator|!=
literal|null
condition|)
block|{
return|return
name|positions
index|[
name|nextPos
operator|++
index|]
return|;
block|}
else|else
block|{
name|nextPos
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|startOffset
specifier|public
name|int
name|startOffset
parameter_list|()
block|{
if|if
condition|(
name|startOffsets
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|startOffsets
index|[
name|nextPos
operator|-
literal|1
index|]
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|endOffset
specifier|public
name|int
name|endOffset
parameter_list|()
block|{
if|if
condition|(
name|endOffsets
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|endOffsets
index|[
name|nextPos
operator|-
literal|1
index|]
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|get
specifier|public
name|Fields
name|get
parameter_list|(
name|int
name|docID
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tvx
operator|!=
literal|null
condition|)
block|{
name|Fields
name|fields
init|=
operator|new
name|TVFields
argument_list|(
name|docID
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// TODO: we can improve writer here, eg write 0 into
comment|// tvx file, so we know on first read from tvx that
comment|// this doc has no TVs
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|fields
return|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|clone
specifier|public
name|TermVectorsReader
name|clone
parameter_list|()
block|{
name|IndexInput
name|cloneTvx
init|=
literal|null
decl_stmt|;
name|IndexInput
name|cloneTvd
init|=
literal|null
decl_stmt|;
name|IndexInput
name|cloneTvf
init|=
literal|null
decl_stmt|;
comment|// These are null when a TermVectorsReader was created
comment|// on a segment that did not have term vectors saved
if|if
condition|(
name|tvx
operator|!=
literal|null
operator|&&
name|tvd
operator|!=
literal|null
operator|&&
name|tvf
operator|!=
literal|null
condition|)
block|{
name|cloneTvx
operator|=
name|tvx
operator|.
name|clone
argument_list|()
expr_stmt|;
name|cloneTvd
operator|=
name|tvd
operator|.
name|clone
argument_list|()
expr_stmt|;
name|cloneTvf
operator|=
name|tvf
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|Lucene40TermVectorsReader
argument_list|(
name|fieldInfos
argument_list|,
name|cloneTvx
argument_list|,
name|cloneTvd
argument_list|,
name|cloneTvf
argument_list|,
name|size
argument_list|,
name|numTotalDocs
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|checkIntegrity
specifier|public
name|void
name|checkIntegrity
parameter_list|()
throws|throws
name|IOException
block|{}
block|}
end_class
end_unit
