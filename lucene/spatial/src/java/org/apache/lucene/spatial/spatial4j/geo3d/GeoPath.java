begin_unit
begin_package
DECL|package|org.apache.lucene.spatial.spatial4j.geo3d
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|spatial4j
operator|.
name|geo3d
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_comment
comment|/**  * GeoSearchableShape representing a path across the surface of the globe,  * with a specified half-width.  Path is described by a series of points.  * Distances are measured from the starting point along the path, and then at right  * angles to the path.  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|GeoPath
specifier|public
class|class
name|GeoPath
extends|extends
name|GeoBaseExtendedShape
implements|implements
name|GeoDistanceShape
block|{
DECL|field|cutoffAngle
specifier|public
specifier|final
name|double
name|cutoffAngle
decl_stmt|;
DECL|field|cutoffOffset
specifier|public
specifier|final
name|double
name|cutoffOffset
decl_stmt|;
DECL|field|originDistance
specifier|public
specifier|final
name|double
name|originDistance
decl_stmt|;
DECL|field|chordDistance
specifier|public
specifier|final
name|double
name|chordDistance
decl_stmt|;
DECL|field|points
specifier|public
specifier|final
name|List
argument_list|<
name|SegmentEndpoint
argument_list|>
name|points
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentEndpoint
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|segments
specifier|public
specifier|final
name|List
argument_list|<
name|PathSegment
argument_list|>
name|segments
init|=
operator|new
name|ArrayList
argument_list|<
name|PathSegment
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|edgePoints
specifier|public
name|GeoPoint
index|[]
name|edgePoints
init|=
literal|null
decl_stmt|;
DECL|method|GeoPath
specifier|public
name|GeoPath
parameter_list|(
specifier|final
name|double
name|cutoffAngle
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
if|if
condition|(
name|cutoffAngle
operator|<=
literal|0.0
operator|||
name|cutoffAngle
operator|>
name|Math
operator|.
name|PI
operator|*
literal|0.5
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cutoff angle out of bounds"
argument_list|)
throw|;
name|this
operator|.
name|cutoffAngle
operator|=
name|cutoffAngle
expr_stmt|;
specifier|final
name|double
name|cosAngle
init|=
name|Math
operator|.
name|cos
argument_list|(
name|cutoffAngle
argument_list|)
decl_stmt|;
specifier|final
name|double
name|sinAngle
init|=
name|Math
operator|.
name|sin
argument_list|(
name|cutoffAngle
argument_list|)
decl_stmt|;
comment|// Cutoff offset is the linear distance given the angle
name|this
operator|.
name|cutoffOffset
operator|=
name|sinAngle
expr_stmt|;
name|this
operator|.
name|originDistance
operator|=
name|cosAngle
expr_stmt|;
comment|// Compute chord distance
name|double
name|xDiff
init|=
literal|1.0
operator|-
name|cosAngle
decl_stmt|;
name|this
operator|.
name|chordDistance
operator|=
name|Math
operator|.
name|sqrt
argument_list|(
name|xDiff
operator|*
name|xDiff
operator|+
name|sinAngle
operator|*
name|sinAngle
argument_list|)
expr_stmt|;
block|}
DECL|method|addPoint
specifier|public
name|void
name|addPoint
parameter_list|(
name|double
name|lat
parameter_list|,
name|double
name|lon
parameter_list|)
block|{
if|if
condition|(
name|lat
argument_list|<
operator|-
name|Math
operator|.
name|PI
operator|*
literal|0.5
operator|||
name|lat
argument_list|>
name|Math
operator|.
name|PI
operator|*
literal|0.5
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Latitude out of range"
argument_list|)
throw|;
if|if
condition|(
name|lon
argument_list|<
operator|-
name|Math
operator|.
name|PI
operator|||
name|lon
argument_list|>
name|Math
operator|.
name|PI
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Longitude out of range"
argument_list|)
throw|;
specifier|final
name|GeoPoint
name|end
init|=
operator|new
name|GeoPoint
argument_list|(
name|lat
argument_list|,
name|lon
argument_list|)
decl_stmt|;
if|if
condition|(
name|points
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
specifier|final
name|GeoPoint
name|start
init|=
name|points
operator|.
name|get
argument_list|(
name|points
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|point
decl_stmt|;
specifier|final
name|PathSegment
name|ps
init|=
operator|new
name|PathSegment
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|cutoffOffset
argument_list|,
name|cutoffAngle
argument_list|,
name|chordDistance
argument_list|)
decl_stmt|;
comment|// Check for degeneracy; if the segment is degenerate, don't include the point
if|if
condition|(
name|ps
operator|.
name|isDegenerate
argument_list|()
condition|)
return|return;
name|segments
operator|.
name|add
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// First point.  We compute the basic set of edgepoints here because we've got the lat and lon available.
comment|// Move from center only in latitude.  Then, if we go past the north pole, adjust the longitude also.
name|double
name|newLat
init|=
name|lat
operator|+
name|cutoffAngle
decl_stmt|;
name|double
name|newLon
init|=
name|lon
decl_stmt|;
if|if
condition|(
name|newLat
operator|>
name|Math
operator|.
name|PI
operator|*
literal|0.5
condition|)
block|{
name|newLat
operator|=
name|Math
operator|.
name|PI
operator|-
name|newLat
expr_stmt|;
name|newLon
operator|+=
name|Math
operator|.
name|PI
expr_stmt|;
block|}
while|while
condition|(
name|newLon
operator|>
name|Math
operator|.
name|PI
condition|)
block|{
name|newLon
operator|-=
name|Math
operator|.
name|PI
operator|*
literal|2.0
expr_stmt|;
block|}
specifier|final
name|GeoPoint
name|edgePoint
init|=
operator|new
name|GeoPoint
argument_list|(
name|newLat
argument_list|,
name|newLon
argument_list|)
decl_stmt|;
name|this
operator|.
name|edgePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|edgePoint
block|}
expr_stmt|;
block|}
specifier|final
name|SegmentEndpoint
name|se
init|=
operator|new
name|SegmentEndpoint
argument_list|(
name|end
argument_list|,
name|originDistance
argument_list|,
name|cutoffOffset
argument_list|,
name|cutoffAngle
argument_list|,
name|chordDistance
argument_list|)
decl_stmt|;
name|points
operator|.
name|add
argument_list|(
name|se
argument_list|)
expr_stmt|;
block|}
DECL|method|done
specifier|public
name|void
name|done
parameter_list|()
block|{
if|if
condition|(
name|points
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Path must have at least one point"
argument_list|)
throw|;
if|if
condition|(
name|segments
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|edgePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|points
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|circlePlane
operator|.
name|getSampleIntersectionPoint
argument_list|(
name|segments
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|invertedStartCutoffPlane
argument_list|)
block|}
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|points
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentEndpoint
name|pathPoint
init|=
name|points
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Membership
name|previousEndBound
init|=
literal|null
decl_stmt|;
name|GeoPoint
index|[]
name|previousEndNotablePoints
init|=
literal|null
decl_stmt|;
name|Membership
name|nextStartBound
init|=
literal|null
decl_stmt|;
name|GeoPoint
index|[]
name|nextStartNotablePoints
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
specifier|final
name|PathSegment
name|previousSegment
init|=
name|segments
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
name|previousEndBound
operator|=
name|previousSegment
operator|.
name|invertedEndCutoffPlane
expr_stmt|;
name|previousEndNotablePoints
operator|=
name|previousSegment
operator|.
name|endCutoffPlanePoints
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|segments
operator|.
name|size
argument_list|()
condition|)
block|{
specifier|final
name|PathSegment
name|nextSegment
init|=
name|segments
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|nextStartBound
operator|=
name|nextSegment
operator|.
name|invertedStartCutoffPlane
expr_stmt|;
name|nextStartNotablePoints
operator|=
name|nextSegment
operator|.
name|startCutoffPlanePoints
expr_stmt|;
block|}
name|pathPoint
operator|.
name|setCutoffPlanes
argument_list|(
name|previousEndNotablePoints
argument_list|,
name|previousEndBound
argument_list|,
name|nextStartNotablePoints
argument_list|,
name|nextStartBound
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Compute an estimate of "distance" to the GeoPoint.    * A return value of Double.MAX_VALUE should be returned for    * points outside of the shape.    */
annotation|@
name|Override
DECL|method|computeNormalDistance
specifier|public
name|double
name|computeNormalDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
comment|// Algorithm:
comment|// (1) If the point is within any of the segments along the path, return that value.
comment|// (2) If the point is within any of the segment end circles along the path, return that value.
name|double
name|currentDistance
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|PathSegment
name|segment
range|:
name|segments
control|)
block|{
name|double
name|distance
init|=
name|segment
operator|.
name|pathNormalDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|!=
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|currentDistance
operator|+
name|distance
return|;
name|currentDistance
operator|+=
name|segment
operator|.
name|fullNormalDistance
expr_stmt|;
block|}
name|int
name|segmentIndex
init|=
literal|0
decl_stmt|;
name|currentDistance
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|SegmentEndpoint
name|endpoint
range|:
name|points
control|)
block|{
name|double
name|distance
init|=
name|endpoint
operator|.
name|pathNormalDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|!=
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|currentDistance
operator|+
name|distance
return|;
if|if
condition|(
name|segmentIndex
operator|<
name|segments
operator|.
name|size
argument_list|()
condition|)
name|currentDistance
operator|+=
name|segments
operator|.
name|get
argument_list|(
name|segmentIndex
operator|++
argument_list|)
operator|.
name|fullNormalDistance
expr_stmt|;
block|}
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
block|}
comment|/**    * Compute an estimate of "distance" to the GeoPoint.    * A return value of Double.MAX_VALUE should be returned for    * points outside of the shape.    */
annotation|@
name|Override
DECL|method|computeNormalDistance
specifier|public
name|double
name|computeNormalDistance
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|computeNormalDistance
argument_list|(
operator|new
name|GeoPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Compute a squared estimate of the "distance" to the    * GeoPoint.  Double.MAX_VALUE indicates a point outside of the    * shape.    */
annotation|@
name|Override
DECL|method|computeSquaredNormalDistance
specifier|public
name|double
name|computeSquaredNormalDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
name|double
name|pd
init|=
name|computeNormalDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|pd
operator|==
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|pd
return|;
return|return
name|pd
operator|*
name|pd
return|;
block|}
comment|/**    * Compute a squared estimate of the "distance" to the    * GeoPoint.  Double.MAX_VALUE indicates a point outside of the    * shape.    */
annotation|@
name|Override
DECL|method|computeSquaredNormalDistance
specifier|public
name|double
name|computeSquaredNormalDistance
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|computeSquaredNormalDistance
argument_list|(
operator|new
name|GeoPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Compute a linear distance to the point.    */
annotation|@
name|Override
DECL|method|computeLinearDistance
specifier|public
name|double
name|computeLinearDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
comment|// Algorithm:
comment|// (1) If the point is within any of the segments along the path, return that value.
comment|// (2) If the point is within any of the segment end circles along the path, return that value.
name|double
name|currentDistance
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|PathSegment
name|segment
range|:
name|segments
control|)
block|{
name|double
name|distance
init|=
name|segment
operator|.
name|pathLinearDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|!=
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|currentDistance
operator|+
name|distance
return|;
name|currentDistance
operator|+=
name|segment
operator|.
name|fullLinearDistance
expr_stmt|;
block|}
name|int
name|segmentIndex
init|=
literal|0
decl_stmt|;
name|currentDistance
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|SegmentEndpoint
name|endpoint
range|:
name|points
control|)
block|{
name|double
name|distance
init|=
name|endpoint
operator|.
name|pathLinearDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|!=
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|currentDistance
operator|+
name|distance
return|;
if|if
condition|(
name|segmentIndex
operator|<
name|segments
operator|.
name|size
argument_list|()
condition|)
name|currentDistance
operator|+=
name|segments
operator|.
name|get
argument_list|(
name|segmentIndex
operator|++
argument_list|)
operator|.
name|fullLinearDistance
expr_stmt|;
block|}
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
block|}
comment|/**    * Compute a linear distance to the point.    */
annotation|@
name|Override
DECL|method|computeLinearDistance
specifier|public
name|double
name|computeLinearDistance
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|computeLinearDistance
argument_list|(
operator|new
name|GeoPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Compute a squared linear distance to the vector.    */
annotation|@
name|Override
DECL|method|computeSquaredLinearDistance
specifier|public
name|double
name|computeSquaredLinearDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
name|double
name|pd
init|=
name|computeLinearDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|pd
operator|==
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|pd
return|;
return|return
name|pd
operator|*
name|pd
return|;
block|}
comment|/**    * Compute a squared linear distance to the vector.    */
annotation|@
name|Override
DECL|method|computeSquaredLinearDistance
specifier|public
name|double
name|computeSquaredLinearDistance
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|computeSquaredLinearDistance
argument_list|(
operator|new
name|GeoPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Compute a true, accurate, great-circle distance.    * Double.MAX_VALUE indicates a point is outside of the shape.    */
annotation|@
name|Override
DECL|method|computeArcDistance
specifier|public
name|double
name|computeArcDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
comment|// Algorithm:
comment|// (1) If the point is within any of the segments along the path, return that value.
comment|// (2) If the point is within any of the segment end circles along the path, return that value.
name|double
name|currentDistance
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|PathSegment
name|segment
range|:
name|segments
control|)
block|{
name|double
name|distance
init|=
name|segment
operator|.
name|pathDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|!=
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|currentDistance
operator|+
name|distance
return|;
name|currentDistance
operator|+=
name|segment
operator|.
name|fullDistance
expr_stmt|;
block|}
name|int
name|segmentIndex
init|=
literal|0
decl_stmt|;
name|currentDistance
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|SegmentEndpoint
name|endpoint
range|:
name|points
control|)
block|{
name|double
name|distance
init|=
name|endpoint
operator|.
name|pathDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|!=
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|currentDistance
operator|+
name|distance
return|;
if|if
condition|(
name|segmentIndex
operator|<
name|segments
operator|.
name|size
argument_list|()
condition|)
name|currentDistance
operator|+=
name|segments
operator|.
name|get
argument_list|(
name|segmentIndex
operator|++
argument_list|)
operator|.
name|fullDistance
expr_stmt|;
block|}
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
block|}
annotation|@
name|Override
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|Vector
name|point
parameter_list|)
block|{
for|for
control|(
name|SegmentEndpoint
name|pathPoint
range|:
name|points
control|)
block|{
if|if
condition|(
name|pathPoint
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
for|for
control|(
name|PathSegment
name|pathSegment
range|:
name|segments
control|)
block|{
if|if
condition|(
name|pathSegment
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
for|for
control|(
name|SegmentEndpoint
name|pathPoint
range|:
name|points
control|)
block|{
if|if
condition|(
name|pathPoint
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
for|for
control|(
name|PathSegment
name|pathSegment
range|:
name|segments
control|)
block|{
if|if
condition|(
name|pathSegment
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|getEdgePoints
specifier|public
name|GeoPoint
index|[]
name|getEdgePoints
parameter_list|()
block|{
return|return
name|edgePoints
return|;
block|}
annotation|@
name|Override
DECL|method|intersects
specifier|public
name|boolean
name|intersects
parameter_list|(
specifier|final
name|Plane
name|plane
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|notablePoints
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
comment|// We look for an intersection with any of the exterior edges of the path.
comment|// We also have to look for intersections with the cones described by the endpoints.
comment|// Return "true" if any such intersections are found.
comment|// For plane intersections, the basic idea is to come up with an equation of the line that is
comment|// the intersection (if any).  Then, find the intersections with the unit sphere (if any).  If
comment|// any of the intersection points are within the bounds, then we've detected an intersection.
comment|// Well, sort of.  We can detect intersections also due to overlap of segments with each other.
comment|// But that's an edge case and we won't be optimizing for it.
for|for
control|(
specifier|final
name|SegmentEndpoint
name|pathPoint
range|:
name|points
control|)
block|{
if|if
condition|(
name|pathPoint
operator|.
name|intersects
argument_list|(
name|plane
argument_list|,
name|notablePoints
argument_list|,
name|bounds
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
for|for
control|(
specifier|final
name|PathSegment
name|pathSegment
range|:
name|segments
control|)
block|{
if|if
condition|(
name|pathSegment
operator|.
name|intersects
argument_list|(
name|plane
argument_list|,
name|notablePoints
argument_list|,
name|bounds
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Compute longitude/latitude bounds for the shape.    *    * @param bounds is the optional input bounds object.  If this is null,    *               a bounds object will be created.  Otherwise, the input object will be modified.    * @return a Bounds object describing the shape's bounds.  If the bounds cannot    * be computed, then return a Bounds object with noLongitudeBound,    * noTopLatitudeBound, and noBottomLatitudeBound.    */
annotation|@
name|Override
DECL|method|getBounds
specifier|public
name|Bounds
name|getBounds
parameter_list|(
name|Bounds
name|bounds
parameter_list|)
block|{
name|bounds
operator|=
name|super
operator|.
name|getBounds
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
comment|// For building bounds, order matters.  We want to traverse
comment|// never more than 180 degrees longitude at a pop or we risk having the
comment|// bounds object get itself inverted.  So do the edges first.
for|for
control|(
name|PathSegment
name|pathSegment
range|:
name|segments
control|)
block|{
name|pathSegment
operator|.
name|getBounds
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SegmentEndpoint
name|pathPoint
range|:
name|points
control|)
block|{
name|pathPoint
operator|.
name|getBounds
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
block|}
return|return
name|bounds
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|GeoPath
operator|)
condition|)
return|return
literal|false
return|;
name|GeoPath
name|p
init|=
operator|(
name|GeoPath
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|points
operator|.
name|size
argument_list|()
operator|!=
name|p
operator|.
name|points
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|cutoffAngle
operator|!=
name|p
operator|.
name|cutoffAngle
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|points
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SegmentEndpoint
name|point
init|=
name|points
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|SegmentEndpoint
name|point2
init|=
name|p
operator|.
name|points
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|point
operator|.
name|equals
argument_list|(
name|point2
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
decl_stmt|;
name|long
name|temp
decl_stmt|;
name|temp
operator|=
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|cutoffAngle
argument_list|)
expr_stmt|;
name|result
operator|=
call|(
name|int
call|)
argument_list|(
name|temp
operator|^
operator|(
name|temp
operator|>>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|points
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"GeoPath: {width="
operator|+
name|cutoffAngle
operator|+
literal|"("
operator|+
name|cutoffAngle
operator|*
literal|180.0
operator|/
name|Math
operator|.
name|PI
operator|+
literal|"), points={"
operator|+
name|points
operator|+
literal|"}}"
return|;
block|}
comment|/**    * This is precalculated data for segment endpoint.    */
DECL|class|SegmentEndpoint
specifier|public
specifier|static
class|class
name|SegmentEndpoint
block|{
DECL|field|point
specifier|public
specifier|final
name|GeoPoint
name|point
decl_stmt|;
DECL|field|circlePlane
specifier|public
specifier|final
name|SidedPlane
name|circlePlane
decl_stmt|;
DECL|field|cutoffNormalDistance
specifier|public
specifier|final
name|double
name|cutoffNormalDistance
decl_stmt|;
DECL|field|cutoffAngle
specifier|public
specifier|final
name|double
name|cutoffAngle
decl_stmt|;
DECL|field|chordDistance
specifier|public
specifier|final
name|double
name|chordDistance
decl_stmt|;
DECL|field|cutoffPlanes
specifier|public
name|Membership
index|[]
name|cutoffPlanes
init|=
literal|null
decl_stmt|;
DECL|field|notablePoints
specifier|public
name|GeoPoint
index|[]
name|notablePoints
init|=
literal|null
decl_stmt|;
DECL|field|circlePoints
specifier|public
specifier|final
specifier|static
name|GeoPoint
index|[]
name|circlePoints
init|=
operator|new
name|GeoPoint
index|[
literal|0
index|]
decl_stmt|;
DECL|method|SegmentEndpoint
specifier|public
name|SegmentEndpoint
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|double
name|originDistance
parameter_list|,
specifier|final
name|double
name|cutoffOffset
parameter_list|,
specifier|final
name|double
name|cutoffAngle
parameter_list|,
specifier|final
name|double
name|chordDistance
parameter_list|)
block|{
name|this
operator|.
name|point
operator|=
name|point
expr_stmt|;
name|this
operator|.
name|cutoffNormalDistance
operator|=
name|cutoffOffset
expr_stmt|;
name|this
operator|.
name|cutoffAngle
operator|=
name|cutoffAngle
expr_stmt|;
name|this
operator|.
name|chordDistance
operator|=
name|chordDistance
expr_stmt|;
name|this
operator|.
name|circlePlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|point
argument_list|,
name|point
argument_list|,
operator|-
name|originDistance
argument_list|)
expr_stmt|;
block|}
DECL|method|setCutoffPlanes
specifier|public
name|void
name|setCutoffPlanes
parameter_list|(
specifier|final
name|GeoPoint
index|[]
name|previousEndNotablePoints
parameter_list|,
specifier|final
name|Membership
name|previousEndPlane
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|nextStartNotablePoints
parameter_list|,
specifier|final
name|Membership
name|nextStartPlane
parameter_list|)
block|{
if|if
condition|(
name|previousEndNotablePoints
operator|==
literal|null
operator|&&
name|nextStartNotablePoints
operator|==
literal|null
condition|)
block|{
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[
literal|0
index|]
expr_stmt|;
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|previousEndNotablePoints
operator|!=
literal|null
operator|&&
name|nextStartNotablePoints
operator|==
literal|null
condition|)
block|{
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
name|previousEndPlane
block|}
expr_stmt|;
name|notablePoints
operator|=
name|previousEndNotablePoints
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|previousEndNotablePoints
operator|==
literal|null
operator|&&
name|nextStartNotablePoints
operator|!=
literal|null
condition|)
block|{
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
name|nextStartPlane
block|}
expr_stmt|;
name|notablePoints
operator|=
name|nextStartNotablePoints
expr_stmt|;
block|}
else|else
block|{
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
name|previousEndPlane
block|,
name|nextStartPlane
block|}
expr_stmt|;
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[
name|previousEndNotablePoints
operator|.
name|length
operator|+
name|nextStartNotablePoints
operator|.
name|length
index|]
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|GeoPoint
name|p
range|:
name|previousEndNotablePoints
control|)
block|{
name|notablePoints
index|[
name|i
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
for|for
control|(
name|GeoPoint
name|p
range|:
name|nextStartNotablePoints
control|)
block|{
name|notablePoints
index|[
name|i
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|Vector
name|point
parameter_list|)
block|{
return|return
name|circlePlane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
return|;
block|}
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|circlePlane
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
return|;
block|}
DECL|method|pathDistance
specifier|public
name|double
name|pathDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
name|double
name|dist
init|=
name|this
operator|.
name|point
operator|.
name|arcDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|dist
operator|>
name|cutoffAngle
condition|)
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
return|return
name|dist
return|;
block|}
DECL|method|pathNormalDistance
specifier|public
name|double
name|pathNormalDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
name|double
name|dist
init|=
name|this
operator|.
name|point
operator|.
name|normalDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|dist
operator|>
name|cutoffNormalDistance
condition|)
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
return|return
name|dist
return|;
block|}
DECL|method|pathLinearDistance
specifier|public
name|double
name|pathLinearDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
name|double
name|dist
init|=
name|this
operator|.
name|point
operator|.
name|linearDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|dist
operator|>
name|chordDistance
condition|)
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
return|return
name|dist
return|;
block|}
DECL|method|intersects
specifier|public
name|boolean
name|intersects
parameter_list|(
specifier|final
name|Plane
name|p
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|notablePoints
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|)
block|{
return|return
name|circlePlane
operator|.
name|intersects
argument_list|(
name|p
argument_list|,
name|notablePoints
argument_list|,
name|this
operator|.
name|notablePoints
argument_list|,
name|bounds
argument_list|,
name|this
operator|.
name|cutoffPlanes
argument_list|)
return|;
block|}
DECL|method|getBounds
specifier|public
name|void
name|getBounds
parameter_list|(
name|Bounds
name|bounds
parameter_list|)
block|{
name|bounds
operator|.
name|addPoint
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|circlePlane
operator|.
name|recordBounds
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|SegmentEndpoint
operator|)
condition|)
return|return
literal|false
return|;
name|SegmentEndpoint
name|other
init|=
operator|(
name|SegmentEndpoint
operator|)
name|o
decl_stmt|;
return|return
name|point
operator|.
name|equals
argument_list|(
name|other
operator|.
name|point
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|point
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|point
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * This is the precalculated data for a path segment.    */
DECL|class|PathSegment
specifier|public
specifier|static
class|class
name|PathSegment
block|{
DECL|field|start
specifier|public
specifier|final
name|GeoPoint
name|start
decl_stmt|;
DECL|field|end
specifier|public
specifier|final
name|GeoPoint
name|end
decl_stmt|;
DECL|field|fullDistance
specifier|public
specifier|final
name|double
name|fullDistance
decl_stmt|;
DECL|field|fullNormalDistance
specifier|public
specifier|final
name|double
name|fullNormalDistance
decl_stmt|;
DECL|field|fullLinearDistance
specifier|public
specifier|final
name|double
name|fullLinearDistance
decl_stmt|;
DECL|field|normalizedConnectingPlane
specifier|public
specifier|final
name|Plane
name|normalizedConnectingPlane
decl_stmt|;
DECL|field|upperConnectingPlane
specifier|public
specifier|final
name|SidedPlane
name|upperConnectingPlane
decl_stmt|;
DECL|field|lowerConnectingPlane
specifier|public
specifier|final
name|SidedPlane
name|lowerConnectingPlane
decl_stmt|;
DECL|field|startCutoffPlane
specifier|public
specifier|final
name|SidedPlane
name|startCutoffPlane
decl_stmt|;
DECL|field|endCutoffPlane
specifier|public
specifier|final
name|SidedPlane
name|endCutoffPlane
decl_stmt|;
DECL|field|upperConnectingPlanePoints
specifier|public
specifier|final
name|GeoPoint
index|[]
name|upperConnectingPlanePoints
decl_stmt|;
DECL|field|lowerConnectingPlanePoints
specifier|public
specifier|final
name|GeoPoint
index|[]
name|lowerConnectingPlanePoints
decl_stmt|;
DECL|field|startCutoffPlanePoints
specifier|public
specifier|final
name|GeoPoint
index|[]
name|startCutoffPlanePoints
decl_stmt|;
DECL|field|endCutoffPlanePoints
specifier|public
specifier|final
name|GeoPoint
index|[]
name|endCutoffPlanePoints
decl_stmt|;
DECL|field|planeBoundingOffset
specifier|public
specifier|final
name|double
name|planeBoundingOffset
decl_stmt|;
DECL|field|arcWidth
specifier|public
specifier|final
name|double
name|arcWidth
decl_stmt|;
DECL|field|chordDistance
specifier|public
specifier|final
name|double
name|chordDistance
decl_stmt|;
comment|// For the adjoining SegmentEndpoint...
DECL|field|invertedStartCutoffPlane
specifier|public
specifier|final
name|SidedPlane
name|invertedStartCutoffPlane
decl_stmt|;
DECL|field|invertedEndCutoffPlane
specifier|public
specifier|final
name|SidedPlane
name|invertedEndCutoffPlane
decl_stmt|;
DECL|method|PathSegment
specifier|public
name|PathSegment
parameter_list|(
specifier|final
name|GeoPoint
name|start
parameter_list|,
specifier|final
name|GeoPoint
name|end
parameter_list|,
specifier|final
name|double
name|planeBoundingOffset
parameter_list|,
specifier|final
name|double
name|arcWidth
parameter_list|,
specifier|final
name|double
name|chordDistance
parameter_list|)
block|{
name|this
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|this
operator|.
name|end
operator|=
name|end
expr_stmt|;
name|this
operator|.
name|planeBoundingOffset
operator|=
name|planeBoundingOffset
expr_stmt|;
name|this
operator|.
name|arcWidth
operator|=
name|arcWidth
expr_stmt|;
name|this
operator|.
name|chordDistance
operator|=
name|chordDistance
expr_stmt|;
name|fullDistance
operator|=
name|start
operator|.
name|arcDistance
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|fullNormalDistance
operator|=
name|start
operator|.
name|normalDistance
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|fullLinearDistance
operator|=
name|start
operator|.
name|linearDistance
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|normalizedConnectingPlane
operator|=
operator|new
name|Plane
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
operator|.
name|normalize
argument_list|()
expr_stmt|;
if|if
condition|(
name|normalizedConnectingPlane
operator|==
literal|null
condition|)
block|{
name|upperConnectingPlane
operator|=
literal|null
expr_stmt|;
name|lowerConnectingPlane
operator|=
literal|null
expr_stmt|;
name|startCutoffPlane
operator|=
literal|null
expr_stmt|;
name|endCutoffPlane
operator|=
literal|null
expr_stmt|;
name|upperConnectingPlanePoints
operator|=
literal|null
expr_stmt|;
name|lowerConnectingPlanePoints
operator|=
literal|null
expr_stmt|;
name|startCutoffPlanePoints
operator|=
literal|null
expr_stmt|;
name|endCutoffPlanePoints
operator|=
literal|null
expr_stmt|;
name|invertedStartCutoffPlane
operator|=
literal|null
expr_stmt|;
name|invertedEndCutoffPlane
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// Either start or end should be on the correct side
name|upperConnectingPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|start
argument_list|,
name|normalizedConnectingPlane
argument_list|,
operator|-
name|planeBoundingOffset
argument_list|)
expr_stmt|;
name|lowerConnectingPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|start
argument_list|,
name|normalizedConnectingPlane
argument_list|,
name|planeBoundingOffset
argument_list|)
expr_stmt|;
comment|// Cutoff planes use opposite endpoints as correct side examples
name|startCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|end
argument_list|,
name|normalizedConnectingPlane
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|endCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|start
argument_list|,
name|normalizedConnectingPlane
argument_list|,
name|end
argument_list|)
expr_stmt|;
specifier|final
name|Membership
index|[]
name|upperSide
init|=
operator|new
name|Membership
index|[]
block|{
name|upperConnectingPlane
block|}
decl_stmt|;
specifier|final
name|Membership
index|[]
name|lowerSide
init|=
operator|new
name|Membership
index|[]
block|{
name|lowerConnectingPlane
block|}
decl_stmt|;
specifier|final
name|Membership
index|[]
name|startSide
init|=
operator|new
name|Membership
index|[]
block|{
name|startCutoffPlane
block|}
decl_stmt|;
specifier|final
name|Membership
index|[]
name|endSide
init|=
operator|new
name|Membership
index|[]
block|{
name|endCutoffPlane
block|}
decl_stmt|;
specifier|final
name|GeoPoint
name|ULHC
init|=
name|upperConnectingPlane
operator|.
name|findIntersections
argument_list|(
name|startCutoffPlane
argument_list|,
name|lowerSide
argument_list|,
name|endSide
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|GeoPoint
name|URHC
init|=
name|upperConnectingPlane
operator|.
name|findIntersections
argument_list|(
name|endCutoffPlane
argument_list|,
name|lowerSide
argument_list|,
name|startSide
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|GeoPoint
name|LLHC
init|=
name|lowerConnectingPlane
operator|.
name|findIntersections
argument_list|(
name|startCutoffPlane
argument_list|,
name|upperSide
argument_list|,
name|endSide
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|GeoPoint
name|LRHC
init|=
name|lowerConnectingPlane
operator|.
name|findIntersections
argument_list|(
name|endCutoffPlane
argument_list|,
name|upperSide
argument_list|,
name|startSide
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
name|upperConnectingPlanePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|ULHC
block|,
name|URHC
block|}
expr_stmt|;
name|lowerConnectingPlanePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|LLHC
block|,
name|LRHC
block|}
expr_stmt|;
name|startCutoffPlanePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|ULHC
block|,
name|LLHC
block|}
expr_stmt|;
name|endCutoffPlanePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|URHC
block|,
name|LRHC
block|}
expr_stmt|;
name|invertedStartCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|startCutoffPlane
argument_list|)
expr_stmt|;
name|invertedEndCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|endCutoffPlane
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isDegenerate
specifier|public
name|boolean
name|isDegenerate
parameter_list|()
block|{
return|return
name|normalizedConnectingPlane
operator|==
literal|null
return|;
block|}
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|Vector
name|point
parameter_list|)
block|{
return|return
name|startCutoffPlane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
operator|&&
name|endCutoffPlane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
operator|&&
name|upperConnectingPlane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
operator|&&
name|lowerConnectingPlane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
return|;
block|}
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|startCutoffPlane
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
operator|&&
name|endCutoffPlane
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
operator|&&
name|upperConnectingPlane
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
operator|&&
name|lowerConnectingPlane
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
return|;
block|}
DECL|method|pathDistance
specifier|public
name|double
name|pathDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
comment|// Compute the distance, filling in both components.
specifier|final
name|double
name|perpDistance
init|=
name|Math
operator|.
name|PI
operator|*
literal|0.5
operator|-
name|Tools
operator|.
name|safeAcos
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|normalizedConnectingPlane
operator|.
name|evaluate
argument_list|(
name|point
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Plane
name|normalizedPerpPlane
init|=
operator|new
name|Plane
argument_list|(
name|normalizedConnectingPlane
argument_list|,
name|point
argument_list|)
operator|.
name|normalize
argument_list|()
decl_stmt|;
specifier|final
name|double
name|pathDistance
init|=
name|Math
operator|.
name|PI
operator|*
literal|0.5
operator|-
name|Tools
operator|.
name|safeAcos
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|normalizedPerpPlane
operator|.
name|evaluate
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|perpDistance
operator|+
name|pathDistance
return|;
block|}
DECL|method|pathNormalDistance
specifier|public
name|double
name|pathNormalDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
specifier|final
name|double
name|pointEval
init|=
name|Math
operator|.
name|abs
argument_list|(
name|normalizedConnectingPlane
operator|.
name|evaluate
argument_list|(
name|point
argument_list|)
argument_list|)
decl_stmt|;
comment|// Want no allocations or expensive operations!  so we do this the hard way
specifier|final
name|double
name|perpX
init|=
name|normalizedConnectingPlane
operator|.
name|y
operator|*
name|point
operator|.
name|z
operator|-
name|normalizedConnectingPlane
operator|.
name|z
operator|*
name|point
operator|.
name|y
decl_stmt|;
specifier|final
name|double
name|perpY
init|=
name|normalizedConnectingPlane
operator|.
name|z
operator|*
name|point
operator|.
name|x
operator|-
name|normalizedConnectingPlane
operator|.
name|x
operator|*
name|point
operator|.
name|z
decl_stmt|;
specifier|final
name|double
name|perpZ
init|=
name|normalizedConnectingPlane
operator|.
name|x
operator|*
name|point
operator|.
name|y
operator|-
name|normalizedConnectingPlane
operator|.
name|y
operator|*
name|point
operator|.
name|x
decl_stmt|;
comment|// If we have a degenerate line, then just compute the normal distance from point x to the start
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|perpX
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|perpY
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|perpZ
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
condition|)
return|return
name|point
operator|.
name|normalDistance
argument_list|(
name|start
argument_list|)
return|;
specifier|final
name|double
name|normFactor
init|=
literal|1.0
operator|/
name|Math
operator|.
name|sqrt
argument_list|(
name|perpX
operator|*
name|perpX
operator|+
name|perpY
operator|*
name|perpY
operator|+
name|perpZ
operator|*
name|perpZ
argument_list|)
decl_stmt|;
specifier|final
name|double
name|perpEval
init|=
name|Math
operator|.
name|abs
argument_list|(
name|perpX
operator|*
name|start
operator|.
name|x
operator|+
name|perpY
operator|*
name|start
operator|.
name|y
operator|+
name|perpZ
operator|*
name|start
operator|.
name|z
argument_list|)
decl_stmt|;
return|return
name|perpEval
operator|*
name|normFactor
operator|+
name|pointEval
return|;
block|}
DECL|method|pathLinearDistance
specifier|public
name|double
name|pathLinearDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
comment|// We have a normalized connecting plane.
comment|// First, compute the perpendicular plane.
comment|// Want no allocations or expensive operations!  so we do this the hard way
specifier|final
name|double
name|perpX
init|=
name|normalizedConnectingPlane
operator|.
name|y
operator|*
name|point
operator|.
name|z
operator|-
name|normalizedConnectingPlane
operator|.
name|z
operator|*
name|point
operator|.
name|y
decl_stmt|;
specifier|final
name|double
name|perpY
init|=
name|normalizedConnectingPlane
operator|.
name|z
operator|*
name|point
operator|.
name|x
operator|-
name|normalizedConnectingPlane
operator|.
name|x
operator|*
name|point
operator|.
name|z
decl_stmt|;
specifier|final
name|double
name|perpZ
init|=
name|normalizedConnectingPlane
operator|.
name|x
operator|*
name|point
operator|.
name|y
operator|-
name|normalizedConnectingPlane
operator|.
name|y
operator|*
name|point
operator|.
name|x
decl_stmt|;
comment|// If we have a degenerate line, then just compute the normal distance from point x to the start
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|perpX
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|perpY
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|perpZ
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
condition|)
return|return
name|point
operator|.
name|linearDistance
argument_list|(
name|start
argument_list|)
return|;
comment|// Next, we need the vector of the line, which is the cross product of the normalized connecting plane
comment|// and the perpendicular plane that we just calculated.
specifier|final
name|double
name|lineX
init|=
name|normalizedConnectingPlane
operator|.
name|y
operator|*
name|perpZ
operator|-
name|normalizedConnectingPlane
operator|.
name|z
operator|*
name|perpY
decl_stmt|;
specifier|final
name|double
name|lineY
init|=
name|normalizedConnectingPlane
operator|.
name|z
operator|*
name|perpX
operator|-
name|normalizedConnectingPlane
operator|.
name|x
operator|*
name|perpZ
decl_stmt|;
specifier|final
name|double
name|lineZ
init|=
name|normalizedConnectingPlane
operator|.
name|x
operator|*
name|perpY
operator|-
name|normalizedConnectingPlane
operator|.
name|y
operator|*
name|perpX
decl_stmt|;
comment|// Now, compute a normalization factor
specifier|final
name|double
name|normalizer
init|=
literal|1.0
operator|/
name|Math
operator|.
name|sqrt
argument_list|(
name|lineX
operator|*
name|lineX
operator|+
name|lineY
operator|*
name|lineY
operator|+
name|lineZ
operator|*
name|lineZ
argument_list|)
decl_stmt|;
comment|// Pick which point by using bounding planes
name|double
name|normLineX
init|=
name|lineX
operator|*
name|normalizer
decl_stmt|;
name|double
name|normLineY
init|=
name|lineY
operator|*
name|normalizer
decl_stmt|;
name|double
name|normLineZ
init|=
name|lineZ
operator|*
name|normalizer
decl_stmt|;
if|if
condition|(
operator|!
name|startCutoffPlane
operator|.
name|isWithin
argument_list|(
name|normLineX
argument_list|,
name|normLineY
argument_list|,
name|normLineZ
argument_list|)
operator|||
operator|!
name|endCutoffPlane
operator|.
name|isWithin
argument_list|(
name|normLineX
argument_list|,
name|normLineY
argument_list|,
name|normLineZ
argument_list|)
condition|)
block|{
name|normLineX
operator|=
operator|-
name|normLineX
expr_stmt|;
name|normLineY
operator|=
operator|-
name|normLineY
expr_stmt|;
name|normLineZ
operator|=
operator|-
name|normLineZ
expr_stmt|;
block|}
comment|// Compute linear distance for the two points
return|return
name|point
operator|.
name|linearDistance
argument_list|(
name|normLineX
argument_list|,
name|normLineY
argument_list|,
name|normLineZ
argument_list|)
operator|+
name|start
operator|.
name|linearDistance
argument_list|(
name|normLineX
argument_list|,
name|normLineY
argument_list|,
name|normLineZ
argument_list|)
return|;
block|}
DECL|method|intersects
specifier|public
name|boolean
name|intersects
parameter_list|(
specifier|final
name|Plane
name|p
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|notablePoints
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|)
block|{
return|return
name|upperConnectingPlane
operator|.
name|intersects
argument_list|(
name|p
argument_list|,
name|notablePoints
argument_list|,
name|upperConnectingPlanePoints
argument_list|,
name|bounds
argument_list|,
name|lowerConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|,
name|endCutoffPlane
argument_list|)
operator|||
name|lowerConnectingPlane
operator|.
name|intersects
argument_list|(
name|p
argument_list|,
name|notablePoints
argument_list|,
name|lowerConnectingPlanePoints
argument_list|,
name|bounds
argument_list|,
name|upperConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|,
name|endCutoffPlane
argument_list|)
return|;
block|}
DECL|method|getBounds
specifier|public
name|void
name|getBounds
parameter_list|(
name|Bounds
name|bounds
parameter_list|)
block|{
comment|// We need to do all bounding planes as well as corner points
name|bounds
operator|.
name|addPoint
argument_list|(
name|start
argument_list|)
operator|.
name|addPoint
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|upperConnectingPlane
operator|.
name|recordBounds
argument_list|(
name|startCutoffPlane
argument_list|,
name|bounds
argument_list|,
name|lowerConnectingPlane
argument_list|,
name|endCutoffPlane
argument_list|)
expr_stmt|;
name|startCutoffPlane
operator|.
name|recordBounds
argument_list|(
name|lowerConnectingPlane
argument_list|,
name|bounds
argument_list|,
name|endCutoffPlane
argument_list|,
name|upperConnectingPlane
argument_list|)
expr_stmt|;
name|lowerConnectingPlane
operator|.
name|recordBounds
argument_list|(
name|endCutoffPlane
argument_list|,
name|bounds
argument_list|,
name|upperConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|)
expr_stmt|;
name|endCutoffPlane
operator|.
name|recordBounds
argument_list|(
name|upperConnectingPlane
argument_list|,
name|bounds
argument_list|,
name|startCutoffPlane
argument_list|,
name|lowerConnectingPlane
argument_list|)
expr_stmt|;
name|upperConnectingPlane
operator|.
name|recordBounds
argument_list|(
name|bounds
argument_list|,
name|lowerConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|,
name|endCutoffPlane
argument_list|)
expr_stmt|;
name|lowerConnectingPlane
operator|.
name|recordBounds
argument_list|(
name|bounds
argument_list|,
name|upperConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|,
name|endCutoffPlane
argument_list|)
expr_stmt|;
name|startCutoffPlane
operator|.
name|recordBounds
argument_list|(
name|bounds
argument_list|,
name|endCutoffPlane
argument_list|,
name|upperConnectingPlane
argument_list|,
name|lowerConnectingPlane
argument_list|)
expr_stmt|;
name|endCutoffPlane
operator|.
name|recordBounds
argument_list|(
name|bounds
argument_list|,
name|startCutoffPlane
argument_list|,
name|upperConnectingPlane
argument_list|,
name|lowerConnectingPlane
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullDistance
operator|>=
name|Math
operator|.
name|PI
condition|)
block|{
comment|// Too large a segment basically means that we can confuse the Bounds object.  Specifically, if our span exceeds 180 degrees
comment|// in longitude (which even a segment whose actual length is less than that might if it goes close to a pole).
comment|// Unfortunately, we can get arbitrarily close to the pole, so this may still not work in all cases.
name|bounds
operator|.
name|noLongitudeBound
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_class
end_unit
