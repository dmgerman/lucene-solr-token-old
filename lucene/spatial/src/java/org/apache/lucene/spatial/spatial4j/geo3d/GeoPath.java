begin_unit
begin_package
DECL|package|org.apache.lucene.spatial.spatial4j.geo3d
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|spatial4j
operator|.
name|geo3d
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_comment
comment|/**  * GeoSearchableShape representing a path across the surface of the globe,  * with a specified half-width.  Path is described by a series of points.  * Distances are measured from the starting point along the path, and then at right  * angles to the path.  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|GeoPath
specifier|public
class|class
name|GeoPath
extends|extends
name|GeoBaseExtendedShape
implements|implements
name|GeoDistanceShape
block|{
DECL|field|cutoffAngle
specifier|public
specifier|final
name|double
name|cutoffAngle
decl_stmt|;
DECL|field|sinAngle
specifier|public
specifier|final
name|double
name|sinAngle
decl_stmt|;
DECL|field|cosAngle
specifier|public
specifier|final
name|double
name|cosAngle
decl_stmt|;
DECL|field|points
specifier|public
specifier|final
name|List
argument_list|<
name|GeoPoint
argument_list|>
name|points
init|=
operator|new
name|ArrayList
argument_list|<
name|GeoPoint
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|endPoints
specifier|public
specifier|final
name|List
argument_list|<
name|SegmentEndpoint
argument_list|>
name|endPoints
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentEndpoint
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|segments
specifier|public
specifier|final
name|List
argument_list|<
name|PathSegment
argument_list|>
name|segments
init|=
operator|new
name|ArrayList
argument_list|<
name|PathSegment
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|edgePoints
specifier|public
name|GeoPoint
index|[]
name|edgePoints
init|=
literal|null
decl_stmt|;
DECL|method|GeoPath
specifier|public
name|GeoPath
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|double
name|maxCutoffAngle
parameter_list|)
block|{
name|super
argument_list|(
name|planetModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxCutoffAngle
operator|<=
literal|0.0
operator|||
name|maxCutoffAngle
operator|>
name|Math
operator|.
name|PI
operator|*
literal|0.5
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cutoff angle out of bounds"
argument_list|)
throw|;
name|this
operator|.
name|cutoffAngle
operator|=
name|maxCutoffAngle
expr_stmt|;
name|this
operator|.
name|cosAngle
operator|=
name|Math
operator|.
name|cos
argument_list|(
name|maxCutoffAngle
argument_list|)
expr_stmt|;
name|this
operator|.
name|sinAngle
operator|=
name|Math
operator|.
name|sin
argument_list|(
name|maxCutoffAngle
argument_list|)
expr_stmt|;
block|}
DECL|method|addPoint
specifier|public
name|void
name|addPoint
parameter_list|(
name|double
name|lat
parameter_list|,
name|double
name|lon
parameter_list|)
block|{
if|if
condition|(
name|lat
argument_list|<
operator|-
name|Math
operator|.
name|PI
operator|*
literal|0.5
operator|||
name|lat
argument_list|>
name|Math
operator|.
name|PI
operator|*
literal|0.5
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Latitude out of range"
argument_list|)
throw|;
if|if
condition|(
name|lon
argument_list|<
operator|-
name|Math
operator|.
name|PI
operator|||
name|lon
argument_list|>
name|Math
operator|.
name|PI
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Longitude out of range"
argument_list|)
throw|;
name|points
operator|.
name|add
argument_list|(
operator|new
name|GeoPoint
argument_list|(
name|planetModel
argument_list|,
name|lat
argument_list|,
name|lon
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|done
specifier|public
name|void
name|done
parameter_list|()
block|{
if|if
condition|(
name|points
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Path must have at least one point"
argument_list|)
throw|;
comment|// Compute an offset to use for all segments.  This will be based on the minimum magnitude of
comment|// the entire ellipsoid.
specifier|final
name|double
name|cutoffOffset
init|=
name|this
operator|.
name|sinAngle
operator|*
name|planetModel
operator|.
name|getMinimumMagnitude
argument_list|()
decl_stmt|;
comment|// First, build all segments.  We'll then go back and build corresponding segment endpoints.
name|GeoPoint
name|lastPoint
init|=
literal|null
decl_stmt|;
for|for
control|(
specifier|final
name|GeoPoint
name|end
range|:
name|points
control|)
block|{
if|if
condition|(
name|lastPoint
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Plane
name|normalizedConnectingPlane
init|=
operator|new
name|Plane
argument_list|(
name|lastPoint
argument_list|,
name|end
argument_list|)
operator|.
name|normalize
argument_list|()
decl_stmt|;
if|if
condition|(
name|normalizedConnectingPlane
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|segments
operator|.
name|add
argument_list|(
operator|new
name|PathSegment
argument_list|(
name|planetModel
argument_list|,
name|lastPoint
argument_list|,
name|end
argument_list|,
name|normalizedConnectingPlane
argument_list|,
name|cutoffOffset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lastPoint
operator|=
name|end
expr_stmt|;
block|}
if|if
condition|(
name|segments
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Simple circle
specifier|final
name|SegmentEndpoint
name|onlyEndpoint
init|=
operator|new
name|SegmentEndpoint
argument_list|(
name|points
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|cutoffOffset
argument_list|)
decl_stmt|;
name|endPoints
operator|.
name|add
argument_list|(
name|onlyEndpoint
argument_list|)
expr_stmt|;
comment|// Find an edgepoint
comment|// We already have circle plane, which is the definitive determination of the edge of the "circle".
comment|// Next, compute vertical plane going through origin and the center point (C = 0, D = 0).
name|Plane
name|verticalPlane
init|=
name|Plane
operator|.
name|constructNormalizedVerticalPlane
argument_list|(
name|onlyEndpoint
operator|.
name|point
operator|.
name|x
argument_list|,
name|onlyEndpoint
operator|.
name|point
operator|.
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|verticalPlane
operator|==
literal|null
condition|)
block|{
name|verticalPlane
operator|=
operator|new
name|Plane
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
comment|// Finally, use Plane.findIntersections() to find the intersection points.
specifier|final
name|GeoPoint
name|edgePoint
init|=
name|onlyEndpoint
operator|.
name|circlePlane
operator|.
name|getSampleIntersectionPoint
argument_list|(
name|planetModel
argument_list|,
name|verticalPlane
argument_list|)
decl_stmt|;
if|if
condition|(
name|edgePoint
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not find edge point for path endpoint="
operator|+
name|onlyEndpoint
operator|.
name|point
operator|+
literal|" cutoffOffset="
operator|+
name|cutoffOffset
operator|+
literal|" planetModel="
operator|+
name|planetModel
argument_list|)
throw|;
block|}
name|this
operator|.
name|edgePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|edgePoint
block|}
expr_stmt|;
return|return;
block|}
comment|// Create segment endpoints.  Use an appropriate constructor for the start and end of the path.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|PathSegment
name|currentSegment
init|=
name|segments
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|// Starting endpoint
specifier|final
name|SegmentEndpoint
name|startEndpoint
init|=
operator|new
name|SegmentEndpoint
argument_list|(
name|currentSegment
operator|.
name|start
argument_list|,
name|currentSegment
operator|.
name|startCutoffPlane
argument_list|,
name|currentSegment
operator|.
name|ULHC
argument_list|,
name|currentSegment
operator|.
name|LLHC
argument_list|)
decl_stmt|;
name|endPoints
operator|.
name|add
argument_list|(
name|startEndpoint
argument_list|)
expr_stmt|;
name|this
operator|.
name|edgePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|currentSegment
operator|.
name|ULHC
block|}
expr_stmt|;
continue|continue;
block|}
comment|// General intersection case
specifier|final
name|PathSegment
name|prevSegment
init|=
name|segments
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// We construct four separate planes, and evaluate which one includes all interior points with least overlap
specifier|final
name|SidedPlane
name|candidate1
init|=
name|SidedPlane
operator|.
name|constructNormalizedThreePointSidedPlane
argument_list|(
name|currentSegment
operator|.
name|start
argument_list|,
name|prevSegment
operator|.
name|URHC
argument_list|,
name|currentSegment
operator|.
name|ULHC
argument_list|,
name|currentSegment
operator|.
name|LLHC
argument_list|)
decl_stmt|;
specifier|final
name|SidedPlane
name|candidate2
init|=
name|SidedPlane
operator|.
name|constructNormalizedThreePointSidedPlane
argument_list|(
name|currentSegment
operator|.
name|start
argument_list|,
name|currentSegment
operator|.
name|ULHC
argument_list|,
name|currentSegment
operator|.
name|LLHC
argument_list|,
name|prevSegment
operator|.
name|LRHC
argument_list|)
decl_stmt|;
specifier|final
name|SidedPlane
name|candidate3
init|=
name|SidedPlane
operator|.
name|constructNormalizedThreePointSidedPlane
argument_list|(
name|currentSegment
operator|.
name|start
argument_list|,
name|currentSegment
operator|.
name|LLHC
argument_list|,
name|prevSegment
operator|.
name|LRHC
argument_list|,
name|prevSegment
operator|.
name|URHC
argument_list|)
decl_stmt|;
specifier|final
name|SidedPlane
name|candidate4
init|=
name|SidedPlane
operator|.
name|constructNormalizedThreePointSidedPlane
argument_list|(
name|currentSegment
operator|.
name|start
argument_list|,
name|prevSegment
operator|.
name|LRHC
argument_list|,
name|prevSegment
operator|.
name|URHC
argument_list|,
name|currentSegment
operator|.
name|ULHC
argument_list|)
decl_stmt|;
if|if
condition|(
name|candidate1
operator|==
literal|null
operator|&&
name|candidate2
operator|==
literal|null
operator|&&
name|candidate3
operator|==
literal|null
operator|&&
name|candidate4
operator|==
literal|null
condition|)
block|{
comment|// The planes are identical.  We wouldn't need a circle at all except for the possibility of
comment|// backing up, which is hard to detect here.
specifier|final
name|SegmentEndpoint
name|midEndpoint
init|=
operator|new
name|SegmentEndpoint
argument_list|(
name|currentSegment
operator|.
name|start
argument_list|,
name|prevSegment
operator|.
name|endCutoffPlane
argument_list|,
name|currentSegment
operator|.
name|startCutoffPlane
argument_list|,
name|currentSegment
operator|.
name|ULHC
argument_list|,
name|currentSegment
operator|.
name|LLHC
argument_list|)
decl_stmt|;
comment|//don't need a circle at all.  Special constructor...
name|endPoints
operator|.
name|add
argument_list|(
name|midEndpoint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|endPoints
operator|.
name|add
argument_list|(
operator|new
name|SegmentEndpoint
argument_list|(
name|currentSegment
operator|.
name|start
argument_list|,
name|prevSegment
operator|.
name|endCutoffPlane
argument_list|,
name|currentSegment
operator|.
name|startCutoffPlane
argument_list|,
name|prevSegment
operator|.
name|URHC
argument_list|,
name|prevSegment
operator|.
name|LRHC
argument_list|,
name|currentSegment
operator|.
name|ULHC
argument_list|,
name|currentSegment
operator|.
name|LLHC
argument_list|,
name|candidate1
argument_list|,
name|candidate2
argument_list|,
name|candidate3
argument_list|,
name|candidate4
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Do final endpoint
specifier|final
name|PathSegment
name|lastSegment
init|=
name|segments
operator|.
name|get
argument_list|(
name|segments
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|endPoints
operator|.
name|add
argument_list|(
operator|new
name|SegmentEndpoint
argument_list|(
name|lastSegment
operator|.
name|end
argument_list|,
name|lastSegment
operator|.
name|endCutoffPlane
argument_list|,
name|lastSegment
operator|.
name|URHC
argument_list|,
name|lastSegment
operator|.
name|LRHC
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compute an estimate of "distance" to the GeoPoint.    * A return value of Double.MAX_VALUE should be returned for    * points outside of the shape.    */
annotation|@
name|Override
DECL|method|computeNormalDistance
specifier|public
name|double
name|computeNormalDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
comment|// Algorithm:
comment|// (1) If the point is within any of the segments along the path, return that value.
comment|// (2) If the point is within any of the segment end circles along the path, return that value.
name|double
name|currentDistance
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|PathSegment
name|segment
range|:
name|segments
control|)
block|{
name|double
name|distance
init|=
name|segment
operator|.
name|pathNormalDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|!=
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|currentDistance
operator|+
name|distance
return|;
name|currentDistance
operator|+=
name|segment
operator|.
name|fullNormalDistance
expr_stmt|;
block|}
name|int
name|segmentIndex
init|=
literal|0
decl_stmt|;
name|currentDistance
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|SegmentEndpoint
name|endpoint
range|:
name|endPoints
control|)
block|{
name|double
name|distance
init|=
name|endpoint
operator|.
name|pathNormalDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|!=
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|currentDistance
operator|+
name|distance
return|;
if|if
condition|(
name|segmentIndex
operator|<
name|segments
operator|.
name|size
argument_list|()
condition|)
name|currentDistance
operator|+=
name|segments
operator|.
name|get
argument_list|(
name|segmentIndex
operator|++
argument_list|)
operator|.
name|fullNormalDistance
expr_stmt|;
block|}
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
block|}
comment|/**    * Compute an estimate of "distance" to the GeoPoint.    * A return value of Double.MAX_VALUE should be returned for    * points outside of the shape.    */
annotation|@
name|Override
DECL|method|computeNormalDistance
specifier|public
name|double
name|computeNormalDistance
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|computeNormalDistance
argument_list|(
operator|new
name|GeoPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Compute a squared estimate of the "distance" to the    * GeoPoint.  Double.MAX_VALUE indicates a point outside of the    * shape.    */
annotation|@
name|Override
DECL|method|computeSquaredNormalDistance
specifier|public
name|double
name|computeSquaredNormalDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
name|double
name|pd
init|=
name|computeNormalDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|pd
operator|==
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|pd
return|;
return|return
name|pd
operator|*
name|pd
return|;
block|}
comment|/**    * Compute a squared estimate of the "distance" to the    * GeoPoint.  Double.MAX_VALUE indicates a point outside of the    * shape.    */
annotation|@
name|Override
DECL|method|computeSquaredNormalDistance
specifier|public
name|double
name|computeSquaredNormalDistance
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|computeSquaredNormalDistance
argument_list|(
operator|new
name|GeoPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Compute a linear distance to the point.    */
annotation|@
name|Override
DECL|method|computeLinearDistance
specifier|public
name|double
name|computeLinearDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
comment|// Algorithm:
comment|// (1) If the point is within any of the segments along the path, return that value.
comment|// (2) If the point is within any of the segment end circles along the path, return that value.
name|double
name|currentDistance
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|PathSegment
name|segment
range|:
name|segments
control|)
block|{
name|double
name|distance
init|=
name|segment
operator|.
name|pathLinearDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|!=
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|currentDistance
operator|+
name|distance
return|;
name|currentDistance
operator|+=
name|segment
operator|.
name|fullLinearDistance
expr_stmt|;
block|}
name|int
name|segmentIndex
init|=
literal|0
decl_stmt|;
name|currentDistance
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|SegmentEndpoint
name|endpoint
range|:
name|endPoints
control|)
block|{
name|double
name|distance
init|=
name|endpoint
operator|.
name|pathLinearDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|!=
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|currentDistance
operator|+
name|distance
return|;
if|if
condition|(
name|segmentIndex
operator|<
name|segments
operator|.
name|size
argument_list|()
condition|)
name|currentDistance
operator|+=
name|segments
operator|.
name|get
argument_list|(
name|segmentIndex
operator|++
argument_list|)
operator|.
name|fullLinearDistance
expr_stmt|;
block|}
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
block|}
comment|/**    * Compute a linear distance to the point.    */
annotation|@
name|Override
DECL|method|computeLinearDistance
specifier|public
name|double
name|computeLinearDistance
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|computeLinearDistance
argument_list|(
operator|new
name|GeoPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Compute a squared linear distance to the vector.    */
annotation|@
name|Override
DECL|method|computeSquaredLinearDistance
specifier|public
name|double
name|computeSquaredLinearDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
name|double
name|pd
init|=
name|computeLinearDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|pd
operator|==
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|pd
return|;
return|return
name|pd
operator|*
name|pd
return|;
block|}
comment|/**    * Compute a squared linear distance to the vector.    */
annotation|@
name|Override
DECL|method|computeSquaredLinearDistance
specifier|public
name|double
name|computeSquaredLinearDistance
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|computeSquaredLinearDistance
argument_list|(
operator|new
name|GeoPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Compute a true, accurate, great-circle distance.    * Double.MAX_VALUE indicates a point is outside of the shape.    */
annotation|@
name|Override
DECL|method|computeArcDistance
specifier|public
name|double
name|computeArcDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
comment|// Algorithm:
comment|// (1) If the point is within any of the segments along the path, return that value.
comment|// (2) If the point is within any of the segment end circles along the path, return that value.
name|double
name|currentDistance
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|PathSegment
name|segment
range|:
name|segments
control|)
block|{
name|double
name|distance
init|=
name|segment
operator|.
name|pathDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|!=
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|currentDistance
operator|+
name|distance
return|;
name|currentDistance
operator|+=
name|segment
operator|.
name|fullDistance
expr_stmt|;
block|}
name|int
name|segmentIndex
init|=
literal|0
decl_stmt|;
name|currentDistance
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|SegmentEndpoint
name|endpoint
range|:
name|endPoints
control|)
block|{
name|double
name|distance
init|=
name|endpoint
operator|.
name|pathDistance
argument_list|(
name|point
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|!=
name|Double
operator|.
name|MAX_VALUE
condition|)
return|return
name|currentDistance
operator|+
name|distance
return|;
if|if
condition|(
name|segmentIndex
operator|<
name|segments
operator|.
name|size
argument_list|()
condition|)
name|currentDistance
operator|+=
name|segments
operator|.
name|get
argument_list|(
name|segmentIndex
operator|++
argument_list|)
operator|.
name|fullDistance
expr_stmt|;
block|}
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
block|}
annotation|@
name|Override
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|Vector
name|point
parameter_list|)
block|{
comment|//System.err.println("Assessing whether point "+point+" is within geopath "+this);
for|for
control|(
name|SegmentEndpoint
name|pathPoint
range|:
name|endPoints
control|)
block|{
if|if
condition|(
name|pathPoint
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
block|{
comment|//System.err.println(" point is within SegmentEndpoint "+pathPoint);
return|return
literal|true
return|;
block|}
block|}
for|for
control|(
name|PathSegment
name|pathSegment
range|:
name|segments
control|)
block|{
if|if
condition|(
name|pathSegment
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
block|{
comment|//System.err.println(" point is within PathSegment "+pathSegment);
return|return
literal|true
return|;
block|}
block|}
comment|//System.err.println(" point is not within geopath");
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
for|for
control|(
name|SegmentEndpoint
name|pathPoint
range|:
name|endPoints
control|)
block|{
if|if
condition|(
name|pathPoint
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
for|for
control|(
name|PathSegment
name|pathSegment
range|:
name|segments
control|)
block|{
if|if
condition|(
name|pathSegment
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|getEdgePoints
specifier|public
name|GeoPoint
index|[]
name|getEdgePoints
parameter_list|()
block|{
return|return
name|edgePoints
return|;
block|}
annotation|@
name|Override
DECL|method|intersects
specifier|public
name|boolean
name|intersects
parameter_list|(
specifier|final
name|Plane
name|plane
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|notablePoints
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
comment|// We look for an intersection with any of the exterior edges of the path.
comment|// We also have to look for intersections with the cones described by the endpoints.
comment|// Return "true" if any such intersections are found.
comment|// For plane intersections, the basic idea is to come up with an equation of the line that is
comment|// the intersection (if any).  Then, find the intersections with the unit sphere (if any).  If
comment|// any of the intersection points are within the bounds, then we've detected an intersection.
comment|// Well, sort of.  We can detect intersections also due to overlap of segments with each other.
comment|// But that's an edge case and we won't be optimizing for it.
comment|//System.err.println(" Looking for intersection of plane "+plane+" with path "+this);
for|for
control|(
specifier|final
name|SegmentEndpoint
name|pathPoint
range|:
name|endPoints
control|)
block|{
if|if
condition|(
name|pathPoint
operator|.
name|intersects
argument_list|(
name|planetModel
argument_list|,
name|plane
argument_list|,
name|notablePoints
argument_list|,
name|bounds
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
for|for
control|(
specifier|final
name|PathSegment
name|pathSegment
range|:
name|segments
control|)
block|{
if|if
condition|(
name|pathSegment
operator|.
name|intersects
argument_list|(
name|planetModel
argument_list|,
name|plane
argument_list|,
name|notablePoints
argument_list|,
name|bounds
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Compute longitude/latitude bounds for the shape.    *    * @param bounds is the optional input bounds object.  If this is null,    *               a bounds object will be created.  Otherwise, the input object will be modified.    * @return a Bounds object describing the shape's bounds.  If the bounds cannot    * be computed, then return a Bounds object with noLongitudeBound,    * noTopLatitudeBound, and noBottomLatitudeBound.    */
annotation|@
name|Override
DECL|method|getBounds
specifier|public
name|Bounds
name|getBounds
parameter_list|(
name|Bounds
name|bounds
parameter_list|)
block|{
name|bounds
operator|=
name|super
operator|.
name|getBounds
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
comment|// For building bounds, order matters.  We want to traverse
comment|// never more than 180 degrees longitude at a pop or we risk having the
comment|// bounds object get itself inverted.  So do the edges first.
for|for
control|(
name|PathSegment
name|pathSegment
range|:
name|segments
control|)
block|{
name|pathSegment
operator|.
name|getBounds
argument_list|(
name|planetModel
argument_list|,
name|bounds
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SegmentEndpoint
name|pathPoint
range|:
name|endPoints
control|)
block|{
name|pathPoint
operator|.
name|getBounds
argument_list|(
name|planetModel
argument_list|,
name|bounds
argument_list|)
expr_stmt|;
block|}
return|return
name|bounds
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|GeoPath
operator|)
condition|)
return|return
literal|false
return|;
name|GeoPath
name|p
init|=
operator|(
name|GeoPath
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|!
name|super
operator|.
name|equals
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|endPoints
operator|.
name|size
argument_list|()
operator|!=
name|p
operator|.
name|endPoints
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|cutoffAngle
operator|!=
name|p
operator|.
name|cutoffAngle
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|endPoints
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SegmentEndpoint
name|point
init|=
name|endPoints
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|SegmentEndpoint
name|point2
init|=
name|p
operator|.
name|endPoints
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|point
operator|.
name|equals
argument_list|(
name|point2
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|super
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|long
name|temp
init|=
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|cutoffAngle
argument_list|)
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
call|(
name|int
call|)
argument_list|(
name|temp
operator|^
operator|(
name|temp
operator|>>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|endPoints
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"GeoPath: {planetmodel="
operator|+
name|planetModel
operator|+
literal|", width="
operator|+
name|cutoffAngle
operator|+
literal|"("
operator|+
name|cutoffAngle
operator|*
literal|180.0
operator|/
name|Math
operator|.
name|PI
operator|+
literal|"), points={"
operator|+
name|points
operator|+
literal|"}}"
return|;
block|}
comment|/**    * This is precalculated data for segment endpoint.    * Note well: This is not necessarily a circle.  There are four cases:    * (1) The path consists of a single endpoint.  In this case, we build a simple circle with the proper cutoff offset.    * (2) This is the end of a path.  The circle plane must be constructed to go through two supplied points and be perpendicular to a connecting plane.    * (2.5) Intersection, but the path on both sides is linear.  We generate a circle, but we use the cutoff planes to limit its influence in the straight line case.    * (3) This is an intersection in a path.  We are supplied FOUR planes.  If there are intersections within bounds for both upper and lower, then    *    we generate no circle at all.  If there is one intersection only, then we generate a plane that includes that intersection, as well as the remaining    *    cutoff plane/edge plane points.    */
DECL|class|SegmentEndpoint
specifier|public
specifier|static
class|class
name|SegmentEndpoint
block|{
DECL|field|point
specifier|public
specifier|final
name|GeoPoint
name|point
decl_stmt|;
DECL|field|circlePlane
specifier|public
specifier|final
name|SidedPlane
name|circlePlane
decl_stmt|;
DECL|field|cutoffPlanes
specifier|public
specifier|final
name|Membership
index|[]
name|cutoffPlanes
decl_stmt|;
DECL|field|notablePoints
specifier|public
specifier|final
name|GeoPoint
index|[]
name|notablePoints
decl_stmt|;
DECL|field|circlePoints
specifier|public
specifier|final
specifier|static
name|GeoPoint
index|[]
name|circlePoints
init|=
operator|new
name|GeoPoint
index|[
literal|0
index|]
decl_stmt|;
comment|/** Base case.  Does nothing at all.      */
DECL|method|SegmentEndpoint
specifier|public
name|SegmentEndpoint
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
name|this
operator|.
name|point
operator|=
name|point
expr_stmt|;
name|this
operator|.
name|circlePlane
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Constructor for case (1).      * Generate a simple circle cutoff plane.      */
DECL|method|SegmentEndpoint
specifier|public
name|SegmentEndpoint
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|double
name|cutoffOffset
parameter_list|)
block|{
name|this
operator|.
name|point
operator|=
name|point
expr_stmt|;
specifier|final
name|double
name|magnitude
init|=
name|point
operator|.
name|magnitude
argument_list|()
decl_stmt|;
comment|// Normalize vector to make D value correct
name|this
operator|.
name|circlePlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|point
argument_list|,
name|point
operator|.
name|normalize
argument_list|()
argument_list|,
operator|-
name|Math
operator|.
name|sqrt
argument_list|(
name|magnitude
operator|*
name|magnitude
operator|-
name|cutoffOffset
operator|*
name|cutoffOffset
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[
literal|0
index|]
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/** Constructor for case (2).      * Generate an endpoint, given a single cutoff plane plus upper and lower edge points.      */
DECL|method|SegmentEndpoint
specifier|public
name|SegmentEndpoint
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|SidedPlane
name|cutoffPlane
parameter_list|,
specifier|final
name|GeoPoint
name|topEdgePoint
parameter_list|,
specifier|final
name|GeoPoint
name|bottomEdgePoint
parameter_list|)
block|{
name|this
operator|.
name|point
operator|=
name|point
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
operator|new
name|SidedPlane
argument_list|(
name|cutoffPlane
argument_list|)
block|}
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|topEdgePoint
block|,
name|bottomEdgePoint
block|}
expr_stmt|;
comment|// To construct the plane, we now just need D, which is simply the negative of the evaluation of the circle normal vector at one of the points.
name|this
operator|.
name|circlePlane
operator|=
name|SidedPlane
operator|.
name|constructNormalizedPerpendicularSidedPlane
argument_list|(
name|point
argument_list|,
name|cutoffPlane
argument_list|,
name|topEdgePoint
argument_list|,
name|bottomEdgePoint
argument_list|)
expr_stmt|;
block|}
comment|/** Constructor for case (2.5).      * Generate an endpoint, given two cutoff planes plus upper and lower edge points.      */
DECL|method|SegmentEndpoint
specifier|public
name|SegmentEndpoint
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|SidedPlane
name|cutoffPlane1
parameter_list|,
specifier|final
name|SidedPlane
name|cutoffPlane2
parameter_list|,
specifier|final
name|GeoPoint
name|topEdgePoint
parameter_list|,
specifier|final
name|GeoPoint
name|bottomEdgePoint
parameter_list|)
block|{
name|this
operator|.
name|point
operator|=
name|point
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
operator|new
name|SidedPlane
argument_list|(
name|cutoffPlane1
argument_list|)
block|,
operator|new
name|SidedPlane
argument_list|(
name|cutoffPlane2
argument_list|)
block|}
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|topEdgePoint
block|,
name|bottomEdgePoint
block|}
expr_stmt|;
comment|// To construct the plane, we now just need D, which is simply the negative of the evaluation of the circle normal vector at one of the points.
name|this
operator|.
name|circlePlane
operator|=
name|SidedPlane
operator|.
name|constructNormalizedPerpendicularSidedPlane
argument_list|(
name|point
argument_list|,
name|cutoffPlane1
argument_list|,
name|topEdgePoint
argument_list|,
name|bottomEdgePoint
argument_list|)
expr_stmt|;
block|}
comment|/** Constructor for case (3).      * Generate an endpoint for an intersection, given four points.      */
DECL|method|SegmentEndpoint
specifier|public
name|SegmentEndpoint
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|,
specifier|final
name|SidedPlane
name|prevCutoffPlane
parameter_list|,
specifier|final
name|SidedPlane
name|nextCutoffPlane
parameter_list|,
specifier|final
name|GeoPoint
name|notCand2Point
parameter_list|,
specifier|final
name|GeoPoint
name|notCand1Point
parameter_list|,
specifier|final
name|GeoPoint
name|notCand3Point
parameter_list|,
specifier|final
name|GeoPoint
name|notCand4Point
parameter_list|,
specifier|final
name|SidedPlane
name|candidate1
parameter_list|,
specifier|final
name|SidedPlane
name|candidate2
parameter_list|,
specifier|final
name|SidedPlane
name|candidate3
parameter_list|,
specifier|final
name|SidedPlane
name|candidate4
parameter_list|)
block|{
comment|// Note: What we really need is a single plane that goes through all four points.
comment|// Since that's not possible in the ellipsoid case (because three points determine a plane, not four), we
comment|// need an approximation that at least creates a boundary that has no interruptions.
comment|// There are three obvious choices for the third point: either (a) one of the two remaining points, or (b) the top or bottom edge
comment|// intersection point.  (a) has no guarantee of continuity, while (b) is capable of producing something very far from a circle if
comment|// the angle between segments is acute.
comment|// The solution is to look for the side (top or bottom) that has an intersection within the shape.  We use the two points from
comment|// the opposite side to determine the plane, AND we pick the third to be either of the two points on the intersecting side
comment|// PROVIDED that the other point is within the final circle we come up with.
name|this
operator|.
name|point
operator|=
name|point
expr_stmt|;
comment|// We construct four separate planes, and evaluate which one includes all interior points with least overlap
comment|// (Constructed beforehand because we need them for degeneracy check)
specifier|final
name|boolean
name|cand1IsOtherWithin
init|=
name|candidate1
operator|!=
literal|null
condition|?
name|candidate1
operator|.
name|isWithin
argument_list|(
name|notCand1Point
argument_list|)
else|:
literal|false
decl_stmt|;
specifier|final
name|boolean
name|cand2IsOtherWithin
init|=
name|candidate2
operator|!=
literal|null
condition|?
name|candidate2
operator|.
name|isWithin
argument_list|(
name|notCand2Point
argument_list|)
else|:
literal|false
decl_stmt|;
specifier|final
name|boolean
name|cand3IsOtherWithin
init|=
name|candidate3
operator|!=
literal|null
condition|?
name|candidate3
operator|.
name|isWithin
argument_list|(
name|notCand3Point
argument_list|)
else|:
literal|false
decl_stmt|;
specifier|final
name|boolean
name|cand4IsOtherWithin
init|=
name|candidate4
operator|!=
literal|null
condition|?
name|candidate4
operator|.
name|isWithin
argument_list|(
name|notCand4Point
argument_list|)
else|:
literal|false
decl_stmt|;
if|if
condition|(
name|cand1IsOtherWithin
operator|&&
name|cand2IsOtherWithin
operator|&&
name|cand3IsOtherWithin
operator|&&
name|cand4IsOtherWithin
condition|)
block|{
comment|// The only way we should see both within is if all four points are coplanar.  In that case, we default to the simplest treatment.
name|this
operator|.
name|circlePlane
operator|=
name|candidate1
expr_stmt|;
comment|// doesn't matter which
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|notCand2Point
block|,
name|notCand3Point
block|,
name|notCand1Point
block|,
name|notCand4Point
block|}
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
operator|new
name|SidedPlane
argument_list|(
name|prevCutoffPlane
argument_list|)
block|,
operator|new
name|SidedPlane
argument_list|(
name|nextCutoffPlane
argument_list|)
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cand1IsOtherWithin
condition|)
block|{
comment|// Use candidate1, and DON'T include prevCutoffPlane in the cutoff planes list
name|this
operator|.
name|circlePlane
operator|=
name|candidate1
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|notCand2Point
block|,
name|notCand3Point
block|,
name|notCand4Point
block|}
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
operator|new
name|SidedPlane
argument_list|(
name|nextCutoffPlane
argument_list|)
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cand2IsOtherWithin
condition|)
block|{
comment|// Use candidate2
name|this
operator|.
name|circlePlane
operator|=
name|candidate2
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|notCand3Point
block|,
name|notCand4Point
block|,
name|notCand1Point
block|}
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
operator|new
name|SidedPlane
argument_list|(
name|nextCutoffPlane
argument_list|)
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cand3IsOtherWithin
condition|)
block|{
name|this
operator|.
name|circlePlane
operator|=
name|candidate3
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|notCand4Point
block|,
name|notCand1Point
block|,
name|notCand2Point
block|}
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
operator|new
name|SidedPlane
argument_list|(
name|prevCutoffPlane
argument_list|)
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cand4IsOtherWithin
condition|)
block|{
name|this
operator|.
name|circlePlane
operator|=
name|candidate4
expr_stmt|;
name|this
operator|.
name|notablePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|notCand1Point
block|,
name|notCand2Point
block|,
name|notCand3Point
block|}
expr_stmt|;
name|this
operator|.
name|cutoffPlanes
operator|=
operator|new
name|Membership
index|[]
block|{
operator|new
name|SidedPlane
argument_list|(
name|prevCutoffPlane
argument_list|)
block|}
expr_stmt|;
block|}
else|else
block|{
comment|// dunno what happened
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Couldn't come up with a plane through three points that included the fourth"
argument_list|)
throw|;
block|}
block|}
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|Vector
name|point
parameter_list|)
block|{
if|if
condition|(
name|circlePlane
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|circlePlane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
return|;
block|}
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
if|if
condition|(
name|circlePlane
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|circlePlane
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
return|;
block|}
DECL|method|pathDistance
specifier|public
name|double
name|pathDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
return|return
name|this
operator|.
name|point
operator|.
name|arcDistance
argument_list|(
name|point
argument_list|)
return|;
block|}
DECL|method|pathNormalDistance
specifier|public
name|double
name|pathNormalDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
return|return
name|this
operator|.
name|point
operator|.
name|normalDistance
argument_list|(
name|point
argument_list|)
return|;
block|}
DECL|method|pathLinearDistance
specifier|public
name|double
name|pathLinearDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
return|return
name|this
operator|.
name|point
operator|.
name|linearDistance
argument_list|(
name|point
argument_list|)
return|;
block|}
DECL|method|intersects
specifier|public
name|boolean
name|intersects
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|Plane
name|p
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|notablePoints
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|)
block|{
comment|//System.err.println("  looking for intersection between plane "+p+" and circle "+circlePlane+" on proper side of "+cutoffPlanes+" within "+bounds);
if|if
condition|(
name|circlePlane
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|circlePlane
operator|.
name|intersects
argument_list|(
name|planetModel
argument_list|,
name|p
argument_list|,
name|notablePoints
argument_list|,
name|this
operator|.
name|notablePoints
argument_list|,
name|bounds
argument_list|,
name|this
operator|.
name|cutoffPlanes
argument_list|)
return|;
block|}
DECL|method|getBounds
specifier|public
name|void
name|getBounds
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
name|Bounds
name|bounds
parameter_list|)
block|{
name|bounds
operator|.
name|addPoint
argument_list|(
name|point
argument_list|)
expr_stmt|;
if|if
condition|(
name|circlePlane
operator|==
literal|null
condition|)
return|return;
name|circlePlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|bounds
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|SegmentEndpoint
operator|)
condition|)
return|return
literal|false
return|;
name|SegmentEndpoint
name|other
init|=
operator|(
name|SegmentEndpoint
operator|)
name|o
decl_stmt|;
return|return
name|point
operator|.
name|equals
argument_list|(
name|other
operator|.
name|point
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|point
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|point
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * This is the precalculated data for a path segment.    */
DECL|class|PathSegment
specifier|public
specifier|static
class|class
name|PathSegment
block|{
DECL|field|start
specifier|public
specifier|final
name|GeoPoint
name|start
decl_stmt|;
DECL|field|end
specifier|public
specifier|final
name|GeoPoint
name|end
decl_stmt|;
DECL|field|fullDistance
specifier|public
specifier|final
name|double
name|fullDistance
decl_stmt|;
DECL|field|fullNormalDistance
specifier|public
specifier|final
name|double
name|fullNormalDistance
decl_stmt|;
DECL|field|fullLinearDistance
specifier|public
specifier|final
name|double
name|fullLinearDistance
decl_stmt|;
DECL|field|normalizedConnectingPlane
specifier|public
specifier|final
name|Plane
name|normalizedConnectingPlane
decl_stmt|;
DECL|field|upperConnectingPlane
specifier|public
specifier|final
name|SidedPlane
name|upperConnectingPlane
decl_stmt|;
DECL|field|lowerConnectingPlane
specifier|public
specifier|final
name|SidedPlane
name|lowerConnectingPlane
decl_stmt|;
DECL|field|startCutoffPlane
specifier|public
specifier|final
name|SidedPlane
name|startCutoffPlane
decl_stmt|;
DECL|field|endCutoffPlane
specifier|public
specifier|final
name|SidedPlane
name|endCutoffPlane
decl_stmt|;
DECL|field|URHC
specifier|public
specifier|final
name|GeoPoint
name|URHC
decl_stmt|;
DECL|field|LRHC
specifier|public
specifier|final
name|GeoPoint
name|LRHC
decl_stmt|;
DECL|field|ULHC
specifier|public
specifier|final
name|GeoPoint
name|ULHC
decl_stmt|;
DECL|field|LLHC
specifier|public
specifier|final
name|GeoPoint
name|LLHC
decl_stmt|;
DECL|field|upperConnectingPlanePoints
specifier|public
specifier|final
name|GeoPoint
index|[]
name|upperConnectingPlanePoints
decl_stmt|;
DECL|field|lowerConnectingPlanePoints
specifier|public
specifier|final
name|GeoPoint
index|[]
name|lowerConnectingPlanePoints
decl_stmt|;
DECL|field|startCutoffPlanePoints
specifier|public
specifier|final
name|GeoPoint
index|[]
name|startCutoffPlanePoints
decl_stmt|;
DECL|field|endCutoffPlanePoints
specifier|public
specifier|final
name|GeoPoint
index|[]
name|endCutoffPlanePoints
decl_stmt|;
DECL|field|planeBoundingOffset
specifier|public
specifier|final
name|double
name|planeBoundingOffset
decl_stmt|;
DECL|method|PathSegment
specifier|public
name|PathSegment
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|GeoPoint
name|start
parameter_list|,
specifier|final
name|GeoPoint
name|end
parameter_list|,
specifier|final
name|Plane
name|normalizedConnectingPlane
parameter_list|,
specifier|final
name|double
name|planeBoundingOffset
parameter_list|)
block|{
name|this
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|this
operator|.
name|end
operator|=
name|end
expr_stmt|;
name|this
operator|.
name|normalizedConnectingPlane
operator|=
name|normalizedConnectingPlane
expr_stmt|;
name|this
operator|.
name|planeBoundingOffset
operator|=
name|planeBoundingOffset
expr_stmt|;
name|fullDistance
operator|=
name|start
operator|.
name|arcDistance
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|fullNormalDistance
operator|=
name|start
operator|.
name|normalDistance
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|fullLinearDistance
operator|=
name|start
operator|.
name|linearDistance
argument_list|(
name|end
argument_list|)
expr_stmt|;
comment|// Either start or end should be on the correct side
name|upperConnectingPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|start
argument_list|,
name|normalizedConnectingPlane
argument_list|,
operator|-
name|planeBoundingOffset
argument_list|)
expr_stmt|;
name|lowerConnectingPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|start
argument_list|,
name|normalizedConnectingPlane
argument_list|,
name|planeBoundingOffset
argument_list|)
expr_stmt|;
comment|// Cutoff planes use opposite endpoints as correct side examples
name|startCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|end
argument_list|,
name|normalizedConnectingPlane
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|endCutoffPlane
operator|=
operator|new
name|SidedPlane
argument_list|(
name|start
argument_list|,
name|normalizedConnectingPlane
argument_list|,
name|end
argument_list|)
expr_stmt|;
specifier|final
name|Membership
index|[]
name|upperSide
init|=
operator|new
name|Membership
index|[]
block|{
name|upperConnectingPlane
block|}
decl_stmt|;
specifier|final
name|Membership
index|[]
name|lowerSide
init|=
operator|new
name|Membership
index|[]
block|{
name|lowerConnectingPlane
block|}
decl_stmt|;
specifier|final
name|Membership
index|[]
name|startSide
init|=
operator|new
name|Membership
index|[]
block|{
name|startCutoffPlane
block|}
decl_stmt|;
specifier|final
name|Membership
index|[]
name|endSide
init|=
operator|new
name|Membership
index|[]
block|{
name|endCutoffPlane
block|}
decl_stmt|;
name|GeoPoint
index|[]
name|points
decl_stmt|;
name|points
operator|=
name|upperConnectingPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|startCutoffPlane
argument_list|,
name|lowerSide
argument_list|,
name|endSide
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Some segment boundary points are off the ellipsoid; path too wide"
argument_list|)
throw|;
block|}
name|this
operator|.
name|ULHC
operator|=
name|points
index|[
literal|0
index|]
expr_stmt|;
name|points
operator|=
name|upperConnectingPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|endCutoffPlane
argument_list|,
name|lowerSide
argument_list|,
name|startSide
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Some segment boundary points are off the ellipsoid; path too wide"
argument_list|)
throw|;
block|}
name|this
operator|.
name|URHC
operator|=
name|points
index|[
literal|0
index|]
expr_stmt|;
name|points
operator|=
name|lowerConnectingPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|startCutoffPlane
argument_list|,
name|upperSide
argument_list|,
name|endSide
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Some segment boundary points are off the ellipsoid; path too wide"
argument_list|)
throw|;
block|}
name|this
operator|.
name|LLHC
operator|=
name|points
index|[
literal|0
index|]
expr_stmt|;
name|points
operator|=
name|lowerConnectingPlane
operator|.
name|findIntersections
argument_list|(
name|planetModel
argument_list|,
name|endCutoffPlane
argument_list|,
name|upperSide
argument_list|,
name|startSide
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Some segment boundary points are off the ellipsoid; path too wide"
argument_list|)
throw|;
block|}
name|this
operator|.
name|LRHC
operator|=
name|points
index|[
literal|0
index|]
expr_stmt|;
name|upperConnectingPlanePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|ULHC
block|,
name|URHC
block|}
expr_stmt|;
name|lowerConnectingPlanePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|LLHC
block|,
name|LRHC
block|}
expr_stmt|;
name|startCutoffPlanePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|ULHC
block|,
name|LLHC
block|}
expr_stmt|;
name|endCutoffPlanePoints
operator|=
operator|new
name|GeoPoint
index|[]
block|{
name|URHC
block|,
name|LRHC
block|}
expr_stmt|;
block|}
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|Vector
name|point
parameter_list|)
block|{
comment|//System.err.println(" assessing whether point "+point+" is within path segment "+this);
comment|//System.err.println("  within "+startCutoffPlane+": "+startCutoffPlane.isWithin(point));
comment|//System.err.println("  within "+endCutoffPlane+": "+endCutoffPlane.isWithin(point));
comment|//System.err.println("  within "+upperConnectingPlane+": "+upperConnectingPlane.isWithin(point));
comment|//System.err.println("  within "+lowerConnectingPlane+": "+lowerConnectingPlane.isWithin(point));
return|return
name|startCutoffPlane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
operator|&&
name|endCutoffPlane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
operator|&&
name|upperConnectingPlane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
operator|&&
name|lowerConnectingPlane
operator|.
name|isWithin
argument_list|(
name|point
argument_list|)
return|;
block|}
DECL|method|isWithin
specifier|public
name|boolean
name|isWithin
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
return|return
name|startCutoffPlane
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
operator|&&
name|endCutoffPlane
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
operator|&&
name|upperConnectingPlane
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
operator|&&
name|lowerConnectingPlane
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
return|;
block|}
DECL|method|pathDistance
specifier|public
name|double
name|pathDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
comment|// Compute the distance, filling in both components.
specifier|final
name|double
name|perpDistance
init|=
name|Math
operator|.
name|PI
operator|*
literal|0.5
operator|-
name|Tools
operator|.
name|safeAcos
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|normalizedConnectingPlane
operator|.
name|evaluate
argument_list|(
name|point
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Plane
name|normalizedPerpPlane
init|=
operator|new
name|Plane
argument_list|(
name|normalizedConnectingPlane
argument_list|,
name|point
argument_list|)
operator|.
name|normalize
argument_list|()
decl_stmt|;
specifier|final
name|double
name|pathDistance
init|=
name|Math
operator|.
name|PI
operator|*
literal|0.5
operator|-
name|Tools
operator|.
name|safeAcos
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|normalizedPerpPlane
operator|.
name|evaluate
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|perpDistance
operator|+
name|pathDistance
return|;
block|}
DECL|method|pathNormalDistance
specifier|public
name|double
name|pathNormalDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
specifier|final
name|double
name|pointEval
init|=
name|Math
operator|.
name|abs
argument_list|(
name|normalizedConnectingPlane
operator|.
name|evaluate
argument_list|(
name|point
argument_list|)
argument_list|)
decl_stmt|;
comment|// Want no allocations or expensive operations!  so we do this the hard way
specifier|final
name|double
name|perpX
init|=
name|normalizedConnectingPlane
operator|.
name|y
operator|*
name|point
operator|.
name|z
operator|-
name|normalizedConnectingPlane
operator|.
name|z
operator|*
name|point
operator|.
name|y
decl_stmt|;
specifier|final
name|double
name|perpY
init|=
name|normalizedConnectingPlane
operator|.
name|z
operator|*
name|point
operator|.
name|x
operator|-
name|normalizedConnectingPlane
operator|.
name|x
operator|*
name|point
operator|.
name|z
decl_stmt|;
specifier|final
name|double
name|perpZ
init|=
name|normalizedConnectingPlane
operator|.
name|x
operator|*
name|point
operator|.
name|y
operator|-
name|normalizedConnectingPlane
operator|.
name|y
operator|*
name|point
operator|.
name|x
decl_stmt|;
comment|// If we have a degenerate line, then just compute the normal distance from point x to the start
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|perpX
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|perpY
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|perpZ
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
condition|)
return|return
name|point
operator|.
name|normalDistance
argument_list|(
name|start
argument_list|)
return|;
specifier|final
name|double
name|normFactor
init|=
literal|1.0
operator|/
name|Math
operator|.
name|sqrt
argument_list|(
name|perpX
operator|*
name|perpX
operator|+
name|perpY
operator|*
name|perpY
operator|+
name|perpZ
operator|*
name|perpZ
argument_list|)
decl_stmt|;
specifier|final
name|double
name|perpEval
init|=
name|Math
operator|.
name|abs
argument_list|(
name|perpX
operator|*
name|start
operator|.
name|x
operator|+
name|perpY
operator|*
name|start
operator|.
name|y
operator|+
name|perpZ
operator|*
name|start
operator|.
name|z
argument_list|)
decl_stmt|;
return|return
name|perpEval
operator|*
name|normFactor
operator|+
name|pointEval
return|;
block|}
DECL|method|pathLinearDistance
specifier|public
name|double
name|pathLinearDistance
parameter_list|(
specifier|final
name|GeoPoint
name|point
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isWithin
argument_list|(
name|point
argument_list|)
condition|)
return|return
name|Double
operator|.
name|MAX_VALUE
return|;
comment|// We have a normalized connecting plane.
comment|// First, compute the perpendicular plane.
comment|// Want no allocations or expensive operations!  so we do this the hard way
specifier|final
name|double
name|perpX
init|=
name|normalizedConnectingPlane
operator|.
name|y
operator|*
name|point
operator|.
name|z
operator|-
name|normalizedConnectingPlane
operator|.
name|z
operator|*
name|point
operator|.
name|y
decl_stmt|;
specifier|final
name|double
name|perpY
init|=
name|normalizedConnectingPlane
operator|.
name|z
operator|*
name|point
operator|.
name|x
operator|-
name|normalizedConnectingPlane
operator|.
name|x
operator|*
name|point
operator|.
name|z
decl_stmt|;
specifier|final
name|double
name|perpZ
init|=
name|normalizedConnectingPlane
operator|.
name|x
operator|*
name|point
operator|.
name|y
operator|-
name|normalizedConnectingPlane
operator|.
name|y
operator|*
name|point
operator|.
name|x
decl_stmt|;
comment|// If we have a degenerate line, then just compute the normal distance from point x to the start
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|perpX
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|perpY
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|perpZ
argument_list|)
operator|<
name|Vector
operator|.
name|MINIMUM_RESOLUTION
condition|)
return|return
name|point
operator|.
name|linearDistance
argument_list|(
name|start
argument_list|)
return|;
comment|// Next, we need the vector of the line, which is the cross product of the normalized connecting plane
comment|// and the perpendicular plane that we just calculated.
specifier|final
name|double
name|lineX
init|=
name|normalizedConnectingPlane
operator|.
name|y
operator|*
name|perpZ
operator|-
name|normalizedConnectingPlane
operator|.
name|z
operator|*
name|perpY
decl_stmt|;
specifier|final
name|double
name|lineY
init|=
name|normalizedConnectingPlane
operator|.
name|z
operator|*
name|perpX
operator|-
name|normalizedConnectingPlane
operator|.
name|x
operator|*
name|perpZ
decl_stmt|;
specifier|final
name|double
name|lineZ
init|=
name|normalizedConnectingPlane
operator|.
name|x
operator|*
name|perpY
operator|-
name|normalizedConnectingPlane
operator|.
name|y
operator|*
name|perpX
decl_stmt|;
comment|// Now, compute a normalization factor
specifier|final
name|double
name|normalizer
init|=
literal|1.0
operator|/
name|Math
operator|.
name|sqrt
argument_list|(
name|lineX
operator|*
name|lineX
operator|+
name|lineY
operator|*
name|lineY
operator|+
name|lineZ
operator|*
name|lineZ
argument_list|)
decl_stmt|;
comment|// Pick which point by using bounding planes
name|double
name|normLineX
init|=
name|lineX
operator|*
name|normalizer
decl_stmt|;
name|double
name|normLineY
init|=
name|lineY
operator|*
name|normalizer
decl_stmt|;
name|double
name|normLineZ
init|=
name|lineZ
operator|*
name|normalizer
decl_stmt|;
if|if
condition|(
operator|!
name|startCutoffPlane
operator|.
name|isWithin
argument_list|(
name|normLineX
argument_list|,
name|normLineY
argument_list|,
name|normLineZ
argument_list|)
operator|||
operator|!
name|endCutoffPlane
operator|.
name|isWithin
argument_list|(
name|normLineX
argument_list|,
name|normLineY
argument_list|,
name|normLineZ
argument_list|)
condition|)
block|{
name|normLineX
operator|=
operator|-
name|normLineX
expr_stmt|;
name|normLineY
operator|=
operator|-
name|normLineY
expr_stmt|;
name|normLineZ
operator|=
operator|-
name|normLineZ
expr_stmt|;
block|}
comment|// Compute linear distance for the two points
return|return
name|point
operator|.
name|linearDistance
argument_list|(
name|normLineX
argument_list|,
name|normLineY
argument_list|,
name|normLineZ
argument_list|)
operator|+
name|start
operator|.
name|linearDistance
argument_list|(
name|normLineX
argument_list|,
name|normLineY
argument_list|,
name|normLineZ
argument_list|)
return|;
block|}
DECL|method|intersects
specifier|public
name|boolean
name|intersects
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
specifier|final
name|Plane
name|p
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|notablePoints
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|)
block|{
return|return
name|upperConnectingPlane
operator|.
name|intersects
argument_list|(
name|planetModel
argument_list|,
name|p
argument_list|,
name|notablePoints
argument_list|,
name|upperConnectingPlanePoints
argument_list|,
name|bounds
argument_list|,
name|lowerConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|,
name|endCutoffPlane
argument_list|)
operator|||
name|lowerConnectingPlane
operator|.
name|intersects
argument_list|(
name|planetModel
argument_list|,
name|p
argument_list|,
name|notablePoints
argument_list|,
name|lowerConnectingPlanePoints
argument_list|,
name|bounds
argument_list|,
name|upperConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|,
name|endCutoffPlane
argument_list|)
return|;
block|}
DECL|method|getBounds
specifier|public
name|void
name|getBounds
parameter_list|(
specifier|final
name|PlanetModel
name|planetModel
parameter_list|,
name|Bounds
name|bounds
parameter_list|)
block|{
comment|// We need to do all bounding planes as well as corner points
name|bounds
operator|.
name|addPoint
argument_list|(
name|start
argument_list|)
operator|.
name|addPoint
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|upperConnectingPlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|startCutoffPlane
argument_list|,
name|bounds
argument_list|,
name|lowerConnectingPlane
argument_list|,
name|endCutoffPlane
argument_list|)
expr_stmt|;
name|startCutoffPlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|lowerConnectingPlane
argument_list|,
name|bounds
argument_list|,
name|endCutoffPlane
argument_list|,
name|upperConnectingPlane
argument_list|)
expr_stmt|;
name|lowerConnectingPlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|endCutoffPlane
argument_list|,
name|bounds
argument_list|,
name|upperConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|)
expr_stmt|;
name|endCutoffPlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|upperConnectingPlane
argument_list|,
name|bounds
argument_list|,
name|startCutoffPlane
argument_list|,
name|lowerConnectingPlane
argument_list|)
expr_stmt|;
name|upperConnectingPlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|bounds
argument_list|,
name|lowerConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|,
name|endCutoffPlane
argument_list|)
expr_stmt|;
name|lowerConnectingPlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|bounds
argument_list|,
name|upperConnectingPlane
argument_list|,
name|startCutoffPlane
argument_list|,
name|endCutoffPlane
argument_list|)
expr_stmt|;
name|startCutoffPlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|bounds
argument_list|,
name|endCutoffPlane
argument_list|,
name|upperConnectingPlane
argument_list|,
name|lowerConnectingPlane
argument_list|)
expr_stmt|;
name|endCutoffPlane
operator|.
name|recordBounds
argument_list|(
name|planetModel
argument_list|,
name|bounds
argument_list|,
name|startCutoffPlane
argument_list|,
name|upperConnectingPlane
argument_list|,
name|lowerConnectingPlane
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullDistance
operator|>=
name|Math
operator|.
name|PI
condition|)
block|{
comment|// Too large a segment basically means that we can confuse the Bounds object.  Specifically, if our span exceeds 180 degrees
comment|// in longitude (which even a segment whose actual length is less than that might if it goes close to a pole).
comment|// Unfortunately, we can get arbitrarily close to the pole, so this may still not work in all cases.
name|bounds
operator|.
name|noLongitudeBound
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_class
end_unit
