begin_unit
begin_package
DECL|package|org.apache.lucene.spatial.prefix.tree
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|prefix
operator|.
name|tree
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|context
operator|.
name|SpatialContext
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|context
operator|.
name|SpatialContextFactory
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Point
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Rectangle
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Shape
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|SpatialRelation
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|impl
operator|.
name|RectangleImpl
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import
begin_comment
comment|/**  * A SpatialPrefixTree for single-dimensional numbers and number ranges of fixed precision values (not floating point).  * Despite its name, the indexed values (and queries) need not actually be ranges, they can be unit instance/values.  *<p />  * Why might you use this instead of Lucene's built-in integer/long support?  Here are some reasons with features based  * on code in this class,<em>or are possible based on this class but require a subclass to fully realize it</em>.  *<ul>  *<li>Index ranges, not just unit instances. This is especially useful when the requirement calls for a  *   multi-valued range.</li>  *<li>Instead of a fixed "precisionStep", this prefixTree can have a customizable number of child values for any  *   prefix (up to 32768). This allows exact alignment of the prefix-tree with typical/expected values, which  *   results in better performance.  For example in a Date implementation, every month can get its own dedicated prefix,  *   every day, etc., even though months vary in duration.</li>  *<li>Arbitrary precision, like {@link java.math.BigDecimal}.</li>  *<li>Standard Lucene integer/long indexing always indexes the full precision of those data types but this one  *   is customizable.</li>  *</ul>  *  * Unlike "normal" spatial components in this module, this special-purpose one only works with {@link Shape}s  * created by the methods on this class, not from any {@link com.spatial4j.core.context.SpatialContext}.  *  * @see org.apache.lucene.spatial.NumberRangePrefixTreeStrategy  * @see<a href="https://issues.apache.org/jira/browse/LUCENE-5648">LUCENE-5648</a>  * @lucene.experimental  */
end_comment
begin_class
DECL|class|NumberRangePrefixTree
specifier|public
specifier|abstract
class|class
name|NumberRangePrefixTree
extends|extends
name|SpatialPrefixTree
block|{
comment|//
comment|//    Dummy SpatialContext
comment|//
DECL|field|DUMMY_CTX
specifier|private
specifier|static
specifier|final
name|SpatialContext
name|DUMMY_CTX
decl_stmt|;
static|static
block|{
name|SpatialContextFactory
name|factory
init|=
operator|new
name|SpatialContextFactory
argument_list|()
decl_stmt|;
name|factory
operator|.
name|geo
operator|=
literal|false
expr_stmt|;
name|factory
operator|.
name|worldBounds
operator|=
operator|new
name|RectangleImpl
argument_list|(
name|Double
operator|.
name|NEGATIVE_INFINITY
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|DUMMY_CTX
operator|=
name|factory
operator|.
name|newSpatialContext
argument_list|()
expr_stmt|;
block|}
comment|/** Base interface for {@link Shape}s this prefix tree supports. It extends {@link Shape} (Spatial4j) for compatibility    * with the spatial API even though it doesn't intermix with conventional 2D shapes.    * @lucene.experimental    */
DECL|interface|NRShape
specifier|public
specifier|static
interface|interface
name|NRShape
extends|extends
name|Shape
extends|,
name|Cloneable
block|{
comment|/** The result should be parseable by {@link #parseShape(String)}. */
DECL|method|toString
specifier|abstract
name|String
name|toString
parameter_list|()
function_decl|;
comment|/** Returns this shape rounded to the target level. If we are already more course than the level then the shape is      * simply returned.  The result may refer to internal state of the argument so you may want to clone it.      */
DECL|method|roundToLevel
specifier|public
name|NRShape
name|roundToLevel
parameter_list|(
name|int
name|targetLevel
parameter_list|)
function_decl|;
block|}
comment|//
comment|//  Factory / Conversions / parsing relating to NRShapes
comment|//
comment|/** Converts the value to a unit shape. Doesn't parse strings; see {@link #parseShape(String)} for    * that. This is the reverse of {@link #toObject(org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape)}. */
DECL|method|toUnitShape
specifier|public
specifier|abstract
name|UnitNRShape
name|toUnitShape
parameter_list|(
name|Object
name|value
parameter_list|)
function_decl|;
comment|/** Returns a shape that represents the continuous range between {@code start} and {@code end}. It will    * be normalized, and so sometimes a {@link org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape}    * will be returned, other times a    * {@link org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.SpanUnitsNRShape} will be.    *    * @throws IllegalArgumentException if the arguments are in the wrong order, or if either contains the other (yet they    * aren't equal).    */
DECL|method|toRangeShape
specifier|public
name|NRShape
name|toRangeShape
parameter_list|(
name|UnitNRShape
name|startUnit
parameter_list|,
name|UnitNRShape
name|endUnit
parameter_list|)
block|{
comment|//note: this normalization/optimization process is actually REQUIRED based on assumptions elsewhere.
comment|//Normalize start& end
name|startUnit
operator|=
name|startUnit
operator|.
name|getShapeAtLevel
argument_list|(
name|truncateStartVals
argument_list|(
name|startUnit
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// chops off trailing min-vals (zeroes)
name|endUnit
operator|=
name|endUnit
operator|.
name|getShapeAtLevel
argument_list|(
name|truncateEndVals
argument_list|(
name|endUnit
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// chops off trailing max-vals
comment|//Optimize to just start or end if it's equivalent, e.g. April to April 1st is April 1st.
name|int
name|cmp
init|=
name|comparePrefix
argument_list|(
name|startUnit
argument_list|,
name|endUnit
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Wrong order: "
operator|+
name|startUnit
operator|+
literal|" TO "
operator|+
name|endUnit
argument_list|)
throw|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
comment|//one is a prefix of the other
if|if
condition|(
name|startUnit
operator|.
name|getLevel
argument_list|()
operator|==
name|endUnit
operator|.
name|getLevel
argument_list|()
condition|)
block|{
comment|//same
return|return
name|startUnit
return|;
block|}
elseif|else
if|if
condition|(
name|endUnit
operator|.
name|getLevel
argument_list|()
operator|>
name|startUnit
operator|.
name|getLevel
argument_list|()
condition|)
block|{
comment|// e.g. April to April 1st
if|if
condition|(
name|truncateStartVals
argument_list|(
name|endUnit
argument_list|,
name|startUnit
operator|.
name|getLevel
argument_list|()
argument_list|)
operator|==
name|startUnit
operator|.
name|getLevel
argument_list|()
condition|)
block|{
return|return
name|endUnit
return|;
block|}
block|}
else|else
block|{
comment|//minLV level> maxLV level
comment|// e.g. April 30 to April
if|if
condition|(
name|truncateEndVals
argument_list|(
name|startUnit
argument_list|,
name|endUnit
operator|.
name|getLevel
argument_list|()
argument_list|)
operator|==
name|endUnit
operator|.
name|getLevel
argument_list|()
condition|)
block|{
return|return
name|startUnit
return|;
block|}
block|}
block|}
return|return
operator|new
name|SpanUnitsNRShape
argument_list|(
name|startUnit
argument_list|,
name|endUnit
argument_list|)
return|;
block|}
comment|/** From lv.getLevel on up, it returns the first Level seen with val != 0. It doesn't check past endLevel. */
DECL|method|truncateStartVals
specifier|private
name|int
name|truncateStartVals
parameter_list|(
name|UnitNRShape
name|lv
parameter_list|,
name|int
name|endLevel
parameter_list|)
block|{
for|for
control|(
name|int
name|level
init|=
name|lv
operator|.
name|getLevel
argument_list|()
init|;
name|level
operator|>
name|endLevel
condition|;
name|level
operator|--
control|)
block|{
if|if
condition|(
name|lv
operator|.
name|getValAtLevel
argument_list|(
name|level
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|level
return|;
block|}
return|return
name|endLevel
return|;
block|}
DECL|method|truncateEndVals
specifier|private
name|int
name|truncateEndVals
parameter_list|(
name|UnitNRShape
name|lv
parameter_list|,
name|int
name|endLevel
parameter_list|)
block|{
for|for
control|(
name|int
name|level
init|=
name|lv
operator|.
name|getLevel
argument_list|()
init|;
name|level
operator|>
name|endLevel
condition|;
name|level
operator|--
control|)
block|{
name|int
name|max
init|=
name|getNumSubCells
argument_list|(
name|lv
operator|.
name|getShapeAtLevel
argument_list|(
name|level
operator|-
literal|1
argument_list|)
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|lv
operator|.
name|getValAtLevel
argument_list|(
name|level
argument_list|)
operator|!=
name|max
condition|)
return|return
name|level
return|;
block|}
return|return
name|endLevel
return|;
block|}
comment|/** Converts a UnitNRShape shape to the corresponding type supported by this class, such as a Calendar/BigDecimal.    * This is the reverse of {@link #toUnitShape(Object)}.    */
DECL|method|toObject
specifier|public
specifier|abstract
name|Object
name|toObject
parameter_list|(
name|UnitNRShape
name|shape
parameter_list|)
function_decl|;
comment|/** A string representation of the UnitNRShape that is parse-able by {@link #parseUnitShape(String)}. */
DECL|method|toString
specifier|protected
specifier|abstract
name|String
name|toString
parameter_list|(
name|UnitNRShape
name|lv
parameter_list|)
function_decl|;
DECL|method|toStringUnitRaw
specifier|protected
specifier|static
name|String
name|toStringUnitRaw
parameter_list|(
name|UnitNRShape
name|lv
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<=
name|lv
operator|.
name|getLevel
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|lv
operator|.
name|getValAtLevel
argument_list|(
name|level
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|setLength
argument_list|(
name|buf
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//chop off ','
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Detects a range pattern and parses it, otherwise it's parsed as one shape via    * {@link #parseUnitShape(String)}.  The range pattern looks like this BNF:    *<pre>    *   '[' + parseShapeLV + ' TO ' + parseShapeLV + ']'    *</pre>    * It's the same thing as the toString() of the range shape, notwithstanding range optimization.    *    * @param str not null or empty    * @return not null    * @throws java.text.ParseException If there is a problem    */
DECL|method|parseShape
specifier|public
name|NRShape
name|parseShape
parameter_list|(
name|String
name|str
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|str
operator|==
literal|null
operator|||
name|str
operator|.
name|isEmpty
argument_list|()
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"str is null or blank"
argument_list|)
throw|;
if|if
condition|(
name|str
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'['
condition|)
block|{
if|if
condition|(
name|str
operator|.
name|charAt
argument_list|(
name|str
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|!=
literal|']'
condition|)
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"If starts with [ must end with ]; got "
operator|+
name|str
argument_list|,
name|str
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
throw|;
name|int
name|middle
init|=
name|str
operator|.
name|indexOf
argument_list|(
literal|" TO "
argument_list|)
decl_stmt|;
if|if
condition|(
name|middle
operator|<
literal|0
condition|)
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"If starts with [ must contain ' TO '; got "
operator|+
name|str
argument_list|,
operator|-
literal|1
argument_list|)
throw|;
name|String
name|leftStr
init|=
name|str
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|middle
argument_list|)
decl_stmt|;
name|String
name|rightStr
init|=
name|str
operator|.
name|substring
argument_list|(
name|middle
operator|+
literal|" TO "
operator|.
name|length
argument_list|()
argument_list|,
name|str
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
name|toRangeShape
argument_list|(
name|parseUnitShape
argument_list|(
name|leftStr
argument_list|)
argument_list|,
name|parseUnitShape
argument_list|(
name|rightStr
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|str
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'{'
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Exclusive ranges not supported; got "
operator|+
name|str
argument_list|,
literal|0
argument_list|)
throw|;
block|}
else|else
block|{
return|return
name|parseUnitShape
argument_list|(
name|str
argument_list|)
return|;
block|}
block|}
comment|/** Parse a String to a UnitNRShape. "*" should be the full-range (level 0 shape). */
DECL|method|parseUnitShape
specifier|protected
specifier|abstract
name|UnitNRShape
name|parseUnitShape
parameter_list|(
name|String
name|str
parameter_list|)
throws|throws
name|ParseException
function_decl|;
comment|//
comment|//    UnitNRShape
comment|//
comment|/**    * A unit value Shape implemented as a stack of numbers, one for each level in the prefix tree. It directly    * corresponds to a {@link Cell}.  Spatially speaking, it's analogous to a Point but 1D and has some precision width.    * @lucene.experimental    */
DECL|interface|UnitNRShape
specifier|public
specifier|static
interface|interface
name|UnitNRShape
extends|extends
name|NRShape
extends|,
name|Comparable
argument_list|<
name|UnitNRShape
argument_list|>
block|{
comment|//note: formerly known as LevelledValue; thus some variables still use 'lv'
comment|/** Get the prefix tree level, the higher the more precise. 0 means the world (universe). */
DECL|method|getLevel
name|int
name|getLevel
parameter_list|()
function_decl|;
comment|/** Gets the value at the specified level of this unit. level must be&gt;= 0 and&lt;= getLevel(). */
DECL|method|getValAtLevel
name|int
name|getValAtLevel
parameter_list|(
name|int
name|level
parameter_list|)
function_decl|;
comment|/** Gets an ancestor at the specified level. It shares state, so you may want to clone() it. */
DECL|method|getShapeAtLevel
name|UnitNRShape
name|getShapeAtLevel
parameter_list|(
name|int
name|level
parameter_list|)
function_decl|;
annotation|@
name|Override
DECL|method|roundToLevel
name|UnitNRShape
name|roundToLevel
parameter_list|(
name|int
name|targetLevel
parameter_list|)
function_decl|;
comment|/** Deep clone */
DECL|method|clone
name|UnitNRShape
name|clone
parameter_list|()
function_decl|;
block|}
comment|/** Compares a to b, returning less than 0, 0, or greater than 0, if a is less than, equal to, or    * greater than b, respectively, up to their common prefix (i.e. only min(a.levels,b.levels) are compared).    * @lucene.internal */
DECL|method|comparePrefix
specifier|protected
specifier|static
name|int
name|comparePrefix
parameter_list|(
name|UnitNRShape
name|a
parameter_list|,
name|UnitNRShape
name|b
parameter_list|)
block|{
name|int
name|minLevel
init|=
name|Math
operator|.
name|min
argument_list|(
name|a
operator|.
name|getLevel
argument_list|()
argument_list|,
name|b
operator|.
name|getLevel
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<=
name|minLevel
condition|;
name|level
operator|++
control|)
block|{
name|int
name|diff
init|=
name|a
operator|.
name|getValAtLevel
argument_list|(
name|level
argument_list|)
operator|-
name|b
operator|.
name|getValAtLevel
argument_list|(
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
return|return
name|diff
return|;
block|}
return|return
literal|0
return|;
block|}
comment|//
comment|//    SpanUnitsNRShape
comment|//
comment|/** A range Shape; based on a pair of {@link org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape}.    * Spatially speaking, it's analogous to a Rectangle but 1D. It might have been named with Range in the name but it    * may be confusing since even the {@link org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape}    * is in some sense a range.    * @lucene.experimental */
DECL|class|SpanUnitsNRShape
specifier|public
class|class
name|SpanUnitsNRShape
implements|implements
name|NRShape
block|{
DECL|field|minLV
DECL|field|maxLV
specifier|private
specifier|final
name|UnitNRShape
name|minLV
decl_stmt|,
name|maxLV
decl_stmt|;
DECL|field|lastLevelInCommon
specifier|private
specifier|final
name|int
name|lastLevelInCommon
decl_stmt|;
comment|//computed; not part of identity
comment|/** Don't call directly; see      * {@link #toRangeShape(org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape, org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape)}. */
DECL|method|SpanUnitsNRShape
specifier|private
name|SpanUnitsNRShape
parameter_list|(
name|UnitNRShape
name|minLV
parameter_list|,
name|UnitNRShape
name|maxLV
parameter_list|)
block|{
name|this
operator|.
name|minLV
operator|=
name|minLV
expr_stmt|;
name|this
operator|.
name|maxLV
operator|=
name|maxLV
expr_stmt|;
comment|//calc lastLevelInCommon
name|int
name|level
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
name|level
operator|<=
name|minLV
operator|.
name|getLevel
argument_list|()
operator|&&
name|level
operator|<=
name|maxLV
operator|.
name|getLevel
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|minLV
operator|.
name|getValAtLevel
argument_list|(
name|level
argument_list|)
operator|!=
name|maxLV
operator|.
name|getValAtLevel
argument_list|(
name|level
argument_list|)
condition|)
break|break;
block|}
name|lastLevelInCommon
operator|=
name|level
operator|-
literal|1
expr_stmt|;
block|}
DECL|method|getMinUnit
specifier|public
name|UnitNRShape
name|getMinUnit
parameter_list|()
block|{
return|return
name|minLV
return|;
block|}
DECL|method|getMaxUnit
specifier|public
name|UnitNRShape
name|getMaxUnit
parameter_list|()
block|{
return|return
name|maxLV
return|;
block|}
comment|/** How many levels are in common between minUnit and maxUnit, not including level 0. */
DECL|method|getLevelsInCommon
specifier|private
name|int
name|getLevelsInCommon
parameter_list|()
block|{
return|return
name|lastLevelInCommon
return|;
block|}
annotation|@
name|Override
DECL|method|roundToLevel
specifier|public
name|NRShape
name|roundToLevel
parameter_list|(
name|int
name|targetLevel
parameter_list|)
block|{
return|return
name|toRangeShape
argument_list|(
name|minLV
operator|.
name|roundToLevel
argument_list|(
name|targetLevel
argument_list|)
argument_list|,
name|maxLV
operator|.
name|roundToLevel
argument_list|(
name|targetLevel
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|relate
specifier|public
name|SpatialRelation
name|relate
parameter_list|(
name|Shape
name|shape
parameter_list|)
block|{
comment|//      if (shape instanceof UnitNRShape)
comment|//        return relate((UnitNRShape)shape);
if|if
condition|(
name|shape
operator|instanceof
name|SpanUnitsNRShape
condition|)
return|return
name|relate
argument_list|(
operator|(
name|SpanUnitsNRShape
operator|)
name|shape
argument_list|)
return|;
return|return
name|shape
operator|.
name|relate
argument_list|(
name|this
argument_list|)
operator|.
name|transpose
argument_list|()
return|;
comment|//probably a UnitNRShape
block|}
DECL|method|relate
specifier|public
name|SpatialRelation
name|relate
parameter_list|(
name|SpanUnitsNRShape
name|ext
parameter_list|)
block|{
comment|//This logic somewhat mirrors RectangleImpl.relate_range()
name|int
name|extMin_intMax
init|=
name|comparePrefix
argument_list|(
name|ext
operator|.
name|getMinUnit
argument_list|()
argument_list|,
name|getMaxUnit
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|extMin_intMax
operator|>
literal|0
condition|)
return|return
name|SpatialRelation
operator|.
name|DISJOINT
return|;
name|int
name|extMax_intMin
init|=
name|comparePrefix
argument_list|(
name|ext
operator|.
name|getMaxUnit
argument_list|()
argument_list|,
name|getMinUnit
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|extMax_intMin
operator|<
literal|0
condition|)
return|return
name|SpatialRelation
operator|.
name|DISJOINT
return|;
name|int
name|extMin_intMin
init|=
name|comparePrefix
argument_list|(
name|ext
operator|.
name|getMinUnit
argument_list|()
argument_list|,
name|getMinUnit
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|extMax_intMax
init|=
name|comparePrefix
argument_list|(
name|ext
operator|.
name|getMaxUnit
argument_list|()
argument_list|,
name|getMaxUnit
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|extMin_intMin
operator|>
literal|0
operator|||
name|extMin_intMin
operator|==
literal|0
operator|&&
name|ext
operator|.
name|getMinUnit
argument_list|()
operator|.
name|getLevel
argument_list|()
operator|>=
name|getMinUnit
argument_list|()
operator|.
name|getLevel
argument_list|()
operator|)
operator|&&
operator|(
name|extMax_intMax
operator|<
literal|0
operator|||
name|extMax_intMax
operator|==
literal|0
operator|&&
name|ext
operator|.
name|getMaxUnit
argument_list|()
operator|.
name|getLevel
argument_list|()
operator|>=
name|getMaxUnit
argument_list|()
operator|.
name|getLevel
argument_list|()
operator|)
condition|)
return|return
name|SpatialRelation
operator|.
name|CONTAINS
return|;
if|if
condition|(
operator|(
name|extMin_intMin
operator|<
literal|0
operator|||
name|extMin_intMin
operator|==
literal|0
operator|&&
name|ext
operator|.
name|getMinUnit
argument_list|()
operator|.
name|getLevel
argument_list|()
operator|<=
name|getMinUnit
argument_list|()
operator|.
name|getLevel
argument_list|()
operator|)
operator|&&
operator|(
name|extMax_intMax
operator|>
literal|0
operator|||
name|extMax_intMax
operator|==
literal|0
operator|&&
name|ext
operator|.
name|getMaxUnit
argument_list|()
operator|.
name|getLevel
argument_list|()
operator|<=
name|getMaxUnit
argument_list|()
operator|.
name|getLevel
argument_list|()
operator|)
condition|)
return|return
name|SpatialRelation
operator|.
name|WITHIN
return|;
return|return
name|SpatialRelation
operator|.
name|INTERSECTS
return|;
block|}
annotation|@
name|Override
DECL|method|getBoundingBox
specifier|public
name|Rectangle
name|getBoundingBox
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|hasArea
specifier|public
name|boolean
name|hasArea
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|getArea
specifier|public
name|double
name|getArea
parameter_list|(
name|SpatialContext
name|spatialContext
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getCenter
specifier|public
name|Point
name|getCenter
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getBuffered
specifier|public
name|Shape
name|getBuffered
parameter_list|(
name|double
name|v
parameter_list|,
name|SpatialContext
name|spatialContext
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/** A deep clone. */
annotation|@
name|Override
DECL|method|clone
specifier|public
name|SpanUnitsNRShape
name|clone
parameter_list|()
block|{
return|return
operator|new
name|SpanUnitsNRShape
argument_list|(
name|minLV
operator|.
name|clone
argument_list|()
argument_list|,
name|maxLV
operator|.
name|clone
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"["
operator|+
name|NumberRangePrefixTree
operator|.
name|this
operator|.
name|toString
argument_list|(
name|minLV
argument_list|)
operator|+
literal|" TO "
operator|+
name|NumberRangePrefixTree
operator|.
name|this
operator|.
name|toString
argument_list|(
name|maxLV
argument_list|)
operator|+
literal|"]"
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
name|SpanUnitsNRShape
name|spanShape
init|=
operator|(
name|SpanUnitsNRShape
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|!
name|maxLV
operator|.
name|equals
argument_list|(
name|spanShape
operator|.
name|maxLV
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|minLV
operator|.
name|equals
argument_list|(
name|spanShape
operator|.
name|minLV
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|minLV
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|maxLV
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|// class SpanUnitsNRShape
comment|//
comment|//    NumberRangePrefixTree
comment|//
DECL|field|maxSubCellsByLevel
specifier|protected
specifier|final
name|int
index|[]
name|maxSubCellsByLevel
decl_stmt|;
DECL|field|termLenByLevel
specifier|protected
specifier|final
name|int
index|[]
name|termLenByLevel
decl_stmt|;
DECL|field|levelByTermLen
specifier|protected
specifier|final
name|int
index|[]
name|levelByTermLen
decl_stmt|;
DECL|field|maxTermLen
specifier|protected
specifier|final
name|int
name|maxTermLen
decl_stmt|;
comment|// how long could cell.getToken... (that is a leaf) possibly be?
DECL|method|NumberRangePrefixTree
specifier|protected
name|NumberRangePrefixTree
parameter_list|(
name|int
index|[]
name|maxSubCellsByLevel
parameter_list|)
block|{
name|super
argument_list|(
name|DUMMY_CTX
argument_list|,
name|maxSubCellsByLevel
operator|.
name|length
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxSubCellsByLevel
operator|=
name|maxSubCellsByLevel
expr_stmt|;
comment|// Fill termLenByLevel
name|this
operator|.
name|termLenByLevel
operator|=
operator|new
name|int
index|[
name|maxLevels
operator|+
literal|1
index|]
expr_stmt|;
name|termLenByLevel
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
specifier|final
name|int
name|MAX_STATES
init|=
literal|1
operator|<<
literal|15
decl_stmt|;
comment|//1 bit less than 2 bytes
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<=
name|maxLevels
condition|;
name|level
operator|++
control|)
block|{
specifier|final
name|int
name|states
init|=
name|maxSubCellsByLevel
index|[
name|level
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|states
operator|>=
name|MAX_STATES
operator|||
name|states
operator|<=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Max states is "
operator|+
name|MAX_STATES
operator|+
literal|", given "
operator|+
name|states
operator|+
literal|" at level "
operator|+
name|level
argument_list|)
throw|;
block|}
name|boolean
name|twoBytes
init|=
name|states
operator|>=
literal|256
decl_stmt|;
name|termLenByLevel
index|[
name|level
index|]
operator|=
name|termLenByLevel
index|[
name|level
operator|-
literal|1
index|]
operator|+
operator|(
name|twoBytes
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
block|}
name|maxTermLen
operator|=
name|termLenByLevel
index|[
name|maxLevels
index|]
operator|+
literal|1
expr_stmt|;
comment|// + 1 for leaf byte
comment|// Fill levelByTermLen
name|levelByTermLen
operator|=
operator|new
name|int
index|[
name|maxTermLen
index|]
expr_stmt|;
name|levelByTermLen
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|termLenByLevel
operator|.
name|length
condition|;
name|level
operator|++
control|)
block|{
name|int
name|termLen
init|=
name|termLenByLevel
index|[
name|level
index|]
decl_stmt|;
name|int
name|prevTermLen
init|=
name|termLenByLevel
index|[
name|level
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|termLen
operator|-
name|prevTermLen
operator|==
literal|2
condition|)
block|{
comment|//2 byte delta
comment|//if the term doesn't completely cover this cell then it must be a leaf of the prior.
name|levelByTermLen
index|[
name|termLen
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|//won't be used; otherwise erroneous
name|levelByTermLen
index|[
name|termLen
index|]
operator|=
name|level
expr_stmt|;
block|}
else|else
block|{
comment|//1 byte delta
assert|assert
name|termLen
operator|-
name|prevTermLen
operator|==
literal|1
assert|;
name|levelByTermLen
index|[
name|termLen
index|]
operator|=
name|level
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getLevelForDistance
specifier|public
name|int
name|getLevelForDistance
parameter_list|(
name|double
name|dist
parameter_list|)
block|{
comment|//note: it might be useful to compute which level has a raw width (counted in
comment|// bottom units, e.g. milliseconds), that covers the provided dist in those units?
return|return
name|maxLevels
return|;
comment|// thus always use full precision. We don't do approximations in this tree/strategy.
comment|//throw new UnsupportedOperationException("Not applicable.");
block|}
annotation|@
name|Override
DECL|method|getDistanceForLevel
specifier|public
name|double
name|getDistanceForLevel
parameter_list|(
name|int
name|level
parameter_list|)
block|{
comment|//note: we could compute this... should we?
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Not applicable."
argument_list|)
throw|;
block|}
DECL|method|toShape
specifier|protected
name|UnitNRShape
name|toShape
parameter_list|(
name|int
index|[]
name|valStack
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|final
name|NRCell
index|[]
name|cellStack
init|=
name|newCellStack
argument_list|(
name|len
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|cellStack
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|resetCellWithCellNum
argument_list|(
name|valStack
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|cellStack
index|[
name|len
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|getWorldCell
specifier|public
name|Cell
name|getWorldCell
parameter_list|()
block|{
return|return
name|newCellStack
argument_list|(
name|maxLevels
argument_list|)
index|[
literal|0
index|]
return|;
block|}
DECL|method|newCellStack
specifier|protected
name|NRCell
index|[]
name|newCellStack
parameter_list|(
name|int
name|levels
parameter_list|)
block|{
specifier|final
name|NRCell
index|[]
name|cellsByLevel
init|=
operator|new
name|NRCell
index|[
name|levels
operator|+
literal|1
index|]
decl_stmt|;
specifier|final
name|BytesRef
name|term
init|=
operator|new
name|BytesRef
argument_list|(
name|maxTermLen
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<=
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|cellsByLevel
index|[
name|level
index|]
operator|=
operator|new
name|NRCell
argument_list|(
name|cellsByLevel
argument_list|,
name|term
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
return|return
name|cellsByLevel
return|;
block|}
annotation|@
name|Override
DECL|method|readCell
specifier|public
name|Cell
name|readCell
parameter_list|(
name|BytesRef
name|term
parameter_list|,
name|Cell
name|scratch
parameter_list|)
block|{
if|if
condition|(
name|scratch
operator|==
literal|null
condition|)
name|scratch
operator|=
name|getWorldCell
argument_list|()
expr_stmt|;
comment|//We decode level #, leaf boolean, and populate bytes by reference. We don't decode the stack.
comment|//reverse lookup term length to the level and hence the cell
name|NRCell
index|[]
name|cellsByLevel
init|=
operator|(
operator|(
name|NRCell
operator|)
name|scratch
operator|)
operator|.
name|cellsByLevel
decl_stmt|;
name|boolean
name|isLeaf
init|=
name|term
operator|.
name|bytes
index|[
name|term
operator|.
name|offset
operator|+
name|term
operator|.
name|length
operator|-
literal|1
index|]
operator|==
literal|0
decl_stmt|;
name|int
name|lenNoLeaf
init|=
name|isLeaf
condition|?
name|term
operator|.
name|length
operator|-
literal|1
else|:
name|term
operator|.
name|length
decl_stmt|;
name|NRCell
name|result
init|=
name|cellsByLevel
index|[
name|levelByTermLen
index|[
name|lenNoLeaf
index|]
index|]
decl_stmt|;
if|if
condition|(
name|cellsByLevel
index|[
literal|0
index|]
operator|.
name|termBuf
operator|==
literal|null
condition|)
name|cellsByLevel
index|[
literal|0
index|]
operator|.
name|termBuf
operator|=
name|result
operator|.
name|term
operator|.
name|bytes
expr_stmt|;
comment|//a kluge; see cell.ensureOwnTermBytes()
name|result
operator|.
name|term
operator|.
name|bytes
operator|=
name|term
operator|.
name|bytes
expr_stmt|;
name|result
operator|.
name|term
operator|.
name|offset
operator|=
name|term
operator|.
name|offset
expr_stmt|;
name|result
operator|.
name|term
operator|.
name|length
operator|=
name|lenNoLeaf
expr_stmt|;
comment|//technically this isn't used but may help debugging
name|result
operator|.
name|reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|isLeaf
condition|)
name|result
operator|.
name|setLeaf
argument_list|()
expr_stmt|;
name|result
operator|.
name|cellNumber
operator|=
operator|-
literal|1
expr_stmt|;
comment|//lazy decode flag
return|return
name|result
return|;
block|}
comment|/** Returns the number of sub-cells beneath the given UnitNRShape. */
DECL|method|getNumSubCells
specifier|public
name|int
name|getNumSubCells
parameter_list|(
name|UnitNRShape
name|lv
parameter_list|)
block|{
return|return
name|maxSubCellsByLevel
index|[
name|lv
operator|.
name|getLevel
argument_list|()
index|]
return|;
block|}
comment|//
comment|//    NRCell
comment|//
comment|/** Most of the PrefixTree implementation is in this one class, which is both    * the Cell, the CellIterator, and the Shape to reduce object allocation. It's implemented as a re-used array/stack    * of Cells at adjacent levels, that all have a reference back to the cell array to traverse. They also share a common    * BytesRef for the term.    * @lucene.internal */
DECL|class|NRCell
specifier|protected
class|class
name|NRCell
extends|extends
name|CellIterator
implements|implements
name|Cell
implements|,
name|UnitNRShape
block|{
comment|//Shared: (TODO put this in a new class)
DECL|field|cellsByLevel
specifier|final
name|NRCell
index|[]
name|cellsByLevel
decl_stmt|;
DECL|field|term
specifier|final
name|BytesRef
name|term
decl_stmt|;
comment|//AKA the token
DECL|field|termBuf
name|byte
index|[]
name|termBuf
decl_stmt|;
comment|// see ensureOwnTermBytes(), only for cell0
comment|//Cell state...
DECL|field|cellLevel
specifier|final
name|int
name|cellLevel
decl_stmt|;
comment|// assert levelStack[cellLevel] == this
DECL|field|cellNumber
name|int
name|cellNumber
decl_stmt|;
comment|//relative to parent cell. It's unused for level 0. Starts at 0.
DECL|field|cellShapeRel
name|SpatialRelation
name|cellShapeRel
decl_stmt|;
DECL|field|cellIsLeaf
name|boolean
name|cellIsLeaf
decl_stmt|;
comment|//CellIterator state is defined further below
DECL|method|NRCell
name|NRCell
parameter_list|(
name|NRCell
index|[]
name|cellsByLevel
parameter_list|,
name|BytesRef
name|term
parameter_list|,
name|int
name|cellLevel
parameter_list|)
block|{
name|this
operator|.
name|cellsByLevel
operator|=
name|cellsByLevel
expr_stmt|;
name|this
operator|.
name|term
operator|=
name|term
expr_stmt|;
name|this
operator|.
name|cellLevel
operator|=
name|cellLevel
expr_stmt|;
name|this
operator|.
name|cellNumber
operator|=
name|cellLevel
operator|==
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|cellIsLeaf
operator|=
literal|false
expr_stmt|;
assert|assert
name|cellsByLevel
index|[
name|cellLevel
index|]
operator|==
literal|null
assert|;
block|}
comment|/** Ensure we own term.bytes so that it's safe to modify. We detect via a kluge in which cellsByLevel[0].termBuf      * is non-null, which is a pre-allocated for use to replace term.bytes. */
DECL|method|ensureOwnTermBytes
name|void
name|ensureOwnTermBytes
parameter_list|()
block|{
name|NRCell
name|cell0
init|=
name|cellsByLevel
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|cell0
operator|.
name|termBuf
operator|==
literal|null
condition|)
return|return;
comment|//we already own the bytes
name|System
operator|.
name|arraycopy
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|term
operator|.
name|offset
argument_list|,
name|cell0
operator|.
name|termBuf
argument_list|,
literal|0
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
name|term
operator|.
name|bytes
operator|=
name|cell0
operator|.
name|termBuf
expr_stmt|;
name|term
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|cell0
operator|.
name|termBuf
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|reset
specifier|private
name|void
name|reset
parameter_list|()
block|{
name|this
operator|.
name|cellIsLeaf
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|cellShapeRel
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|resetCellWithCellNum
specifier|private
name|void
name|resetCellWithCellNum
parameter_list|(
name|int
name|cellNumber
parameter_list|)
block|{
name|reset
argument_list|()
expr_stmt|;
comment|//update bytes
comment|//  note: see lazyInitCellNumsFromBytes() for the reverse
if|if
condition|(
name|cellNumber
operator|>=
literal|0
condition|)
block|{
comment|//valid
name|ensureOwnTermBytes
argument_list|()
expr_stmt|;
name|int
name|termLen
init|=
name|termLenByLevel
index|[
name|getLevel
argument_list|()
index|]
decl_stmt|;
name|boolean
name|twoBytes
init|=
operator|(
name|termLen
operator|-
name|termLenByLevel
index|[
name|getLevel
argument_list|()
operator|-
literal|1
index|]
operator|)
operator|>
literal|1
decl_stmt|;
if|if
condition|(
name|twoBytes
condition|)
block|{
comment|//right 7 bits, plus 1 (may overflow to 8th bit which is okay)
name|term
operator|.
name|bytes
index|[
name|termLen
operator|-
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|cellNumber
operator|>>
literal|7
argument_list|)
expr_stmt|;
name|term
operator|.
name|bytes
index|[
name|termLen
operator|-
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|cellNumber
operator|&
literal|0x7F
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|term
operator|.
name|bytes
index|[
name|termLen
operator|-
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|cellNumber
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
assert|assert
name|term
operator|.
name|bytes
index|[
name|termLen
operator|-
literal|1
index|]
operator|!=
literal|0
assert|;
name|term
operator|.
name|length
operator|=
name|termLen
expr_stmt|;
block|}
name|this
operator|.
name|cellNumber
operator|=
name|cellNumber
expr_stmt|;
block|}
DECL|method|ensureDecoded
specifier|private
name|void
name|ensureDecoded
parameter_list|()
block|{
if|if
condition|(
name|cellNumber
operator|>=
literal|0
condition|)
return|return;
comment|//Decode cell numbers from bytes. This is the inverse of resetCellWithCellNum().
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<=
name|getLevel
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
name|NRCell
name|cell
init|=
name|cellsByLevel
index|[
name|level
index|]
decl_stmt|;
name|int
name|termLen
init|=
name|termLenByLevel
index|[
name|level
index|]
decl_stmt|;
name|boolean
name|twoBytes
init|=
operator|(
name|termLen
operator|-
name|termLenByLevel
index|[
name|level
operator|-
literal|1
index|]
operator|)
operator|>
literal|1
decl_stmt|;
if|if
condition|(
name|twoBytes
condition|)
block|{
name|int
name|byteH
init|=
operator|(
name|term
operator|.
name|bytes
index|[
name|term
operator|.
name|offset
operator|+
name|termLen
operator|-
literal|2
index|]
operator|&
literal|0xFF
operator|)
decl_stmt|;
name|int
name|byteL
init|=
operator|(
name|term
operator|.
name|bytes
index|[
name|term
operator|.
name|offset
operator|+
name|termLen
operator|-
literal|1
index|]
operator|&
literal|0xFF
operator|)
decl_stmt|;
assert|assert
name|byteL
operator|-
literal|1
operator|<
operator|(
literal|1
operator|<<
literal|7
operator|)
assert|;
name|cell
operator|.
name|cellNumber
operator|=
operator|(
name|byteH
operator|<<
literal|7
operator|)
operator|+
operator|(
name|byteL
operator|-
literal|1
operator|)
expr_stmt|;
assert|assert
name|cell
operator|.
name|cellNumber
operator|<
literal|1
operator|<<
literal|15
assert|;
block|}
else|else
block|{
name|cell
operator|.
name|cellNumber
operator|=
operator|(
name|term
operator|.
name|bytes
index|[
name|term
operator|.
name|offset
operator|+
name|termLen
operator|-
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|-
literal|1
expr_stmt|;
assert|assert
name|cell
operator|.
name|cellNumber
operator|<
literal|255
assert|;
block|}
name|cell
operator|.
name|assertDecoded
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|assertDecoded
specifier|private
name|void
name|assertDecoded
parameter_list|()
block|{
assert|assert
name|cellNumber
operator|>=
literal|0
operator|:
literal|"Illegal state; ensureDecoded() wasn't called"
assert|;
block|}
annotation|@
name|Override
comment|// for Cell& for UnitNRShape
DECL|method|getLevel
specifier|public
name|int
name|getLevel
parameter_list|()
block|{
return|return
name|cellLevel
return|;
block|}
annotation|@
name|Override
DECL|method|getShapeRel
specifier|public
name|SpatialRelation
name|getShapeRel
parameter_list|()
block|{
return|return
name|cellShapeRel
return|;
block|}
annotation|@
name|Override
DECL|method|setShapeRel
specifier|public
name|void
name|setShapeRel
parameter_list|(
name|SpatialRelation
name|rel
parameter_list|)
block|{
name|cellShapeRel
operator|=
name|rel
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isLeaf
specifier|public
name|boolean
name|isLeaf
parameter_list|()
block|{
return|return
name|cellIsLeaf
return|;
block|}
annotation|@
name|Override
DECL|method|setLeaf
specifier|public
name|void
name|setLeaf
parameter_list|()
block|{
name|cellIsLeaf
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getShape
specifier|public
name|UnitNRShape
name|getShape
parameter_list|()
block|{
name|ensureDecoded
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|getTokenBytesNoLeaf
specifier|public
name|BytesRef
name|getTokenBytesNoLeaf
parameter_list|(
name|BytesRef
name|result
parameter_list|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
condition|)
name|result
operator|=
operator|new
name|BytesRef
argument_list|()
expr_stmt|;
name|result
operator|.
name|bytes
operator|=
name|term
operator|.
name|bytes
expr_stmt|;
name|result
operator|.
name|offset
operator|=
name|term
operator|.
name|offset
expr_stmt|;
name|result
operator|.
name|length
operator|=
name|termLenByLevel
index|[
name|cellLevel
index|]
expr_stmt|;
assert|assert
name|result
operator|.
name|length
operator|<=
name|term
operator|.
name|length
assert|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|getTokenBytesWithLeaf
specifier|public
name|BytesRef
name|getTokenBytesWithLeaf
parameter_list|(
name|BytesRef
name|result
parameter_list|)
block|{
name|ensureOwnTermBytes
argument_list|()
expr_stmt|;
comment|//normally shouldn't do anything
name|result
operator|=
name|getTokenBytesNoLeaf
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLeaf
argument_list|()
condition|)
block|{
name|result
operator|.
name|bytes
index|[
name|result
operator|.
name|length
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|isPrefixOf
specifier|public
name|boolean
name|isPrefixOf
parameter_list|(
name|Cell
name|c
parameter_list|)
block|{
name|NRCell
name|otherCell
init|=
operator|(
name|NRCell
operator|)
name|c
decl_stmt|;
assert|assert
name|term
operator|!=
name|otherCell
operator|.
name|term
assert|;
comment|//trick to re-use bytesref; provided that we re-instate it
name|int
name|myLastLen
init|=
name|term
operator|.
name|length
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|termLenByLevel
index|[
name|getLevel
argument_list|()
index|]
expr_stmt|;
name|int
name|otherLastLen
init|=
name|otherCell
operator|.
name|term
operator|.
name|length
decl_stmt|;
name|otherCell
operator|.
name|term
operator|.
name|length
operator|=
name|termLenByLevel
index|[
name|otherCell
operator|.
name|getLevel
argument_list|()
index|]
expr_stmt|;
name|boolean
name|answer
init|=
name|StringHelper
operator|.
name|startsWith
argument_list|(
name|otherCell
operator|.
name|term
argument_list|,
name|term
argument_list|)
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|myLastLen
expr_stmt|;
name|otherCell
operator|.
name|term
operator|.
name|length
operator|=
name|otherLastLen
expr_stmt|;
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|compareToNoLeaf
specifier|public
name|int
name|compareToNoLeaf
parameter_list|(
name|Cell
name|fromCell
parameter_list|)
block|{
specifier|final
name|NRCell
name|nrCell
init|=
operator|(
name|NRCell
operator|)
name|fromCell
decl_stmt|;
assert|assert
name|term
operator|!=
name|nrCell
operator|.
name|term
assert|;
comment|//trick to re-use bytesref; provided that we re-instate it
name|int
name|myLastLen
init|=
name|term
operator|.
name|length
decl_stmt|;
name|int
name|otherLastLen
init|=
name|nrCell
operator|.
name|term
operator|.
name|length
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|termLenByLevel
index|[
name|getLevel
argument_list|()
index|]
expr_stmt|;
name|nrCell
operator|.
name|term
operator|.
name|length
operator|=
name|termLenByLevel
index|[
name|nrCell
operator|.
name|getLevel
argument_list|()
index|]
expr_stmt|;
name|int
name|answer
init|=
name|term
operator|.
name|compareTo
argument_list|(
name|nrCell
operator|.
name|term
argument_list|)
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|myLastLen
expr_stmt|;
name|nrCell
operator|.
name|term
operator|.
name|length
operator|=
name|otherLastLen
expr_stmt|;
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|getNextLevelCells
specifier|public
name|CellIterator
name|getNextLevelCells
parameter_list|(
name|Shape
name|shapeFilter
parameter_list|)
block|{
name|ensureDecoded
argument_list|()
expr_stmt|;
name|NRCell
name|subCell
init|=
name|cellsByLevel
index|[
name|cellLevel
operator|+
literal|1
index|]
decl_stmt|;
name|subCell
operator|.
name|initIter
argument_list|(
name|shapeFilter
argument_list|)
expr_stmt|;
return|return
name|subCell
return|;
block|}
comment|//----------- CellIterator
DECL|field|iterFilter
name|Shape
name|iterFilter
decl_stmt|;
comment|//UnitNRShape or NRShape
DECL|field|iterFirstIsIntersects
name|boolean
name|iterFirstIsIntersects
decl_stmt|;
DECL|field|iterLastIsIntersects
name|boolean
name|iterLastIsIntersects
decl_stmt|;
DECL|field|iterFirstCellNumber
name|int
name|iterFirstCellNumber
decl_stmt|;
DECL|field|iterLastCellNumber
name|int
name|iterLastCellNumber
decl_stmt|;
DECL|method|initIter
specifier|private
name|void
name|initIter
parameter_list|(
name|Shape
name|filter
parameter_list|)
block|{
name|cellNumber
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|filter
operator|instanceof
name|UnitNRShape
operator|&&
operator|(
operator|(
name|UnitNRShape
operator|)
name|filter
operator|)
operator|.
name|getLevel
argument_list|()
operator|==
literal|0
condition|)
name|filter
operator|=
literal|null
expr_stmt|;
comment|//world means everything -- no filter
name|iterFilter
operator|=
name|filter
expr_stmt|;
name|NRCell
name|parent
init|=
name|getShapeAtLevel
argument_list|(
name|getLevel
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// Initialize iter* members.
comment|//no filter means all subcells
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
block|{
name|iterFirstCellNumber
operator|=
literal|0
expr_stmt|;
name|iterFirstIsIntersects
operator|=
literal|false
expr_stmt|;
name|iterLastCellNumber
operator|=
name|getNumSubCells
argument_list|(
name|parent
argument_list|)
operator|-
literal|1
expr_stmt|;
name|iterLastIsIntersects
operator|=
literal|false
expr_stmt|;
return|return;
block|}
specifier|final
name|UnitNRShape
name|minLV
decl_stmt|;
specifier|final
name|UnitNRShape
name|maxLV
decl_stmt|;
specifier|final
name|int
name|lastLevelInCommon
decl_stmt|;
comment|//between minLV& maxLV
if|if
condition|(
name|filter
operator|instanceof
name|SpanUnitsNRShape
condition|)
block|{
name|SpanUnitsNRShape
name|spanShape
init|=
operator|(
name|SpanUnitsNRShape
operator|)
name|iterFilter
decl_stmt|;
name|minLV
operator|=
name|spanShape
operator|.
name|getMinUnit
argument_list|()
expr_stmt|;
name|maxLV
operator|=
name|spanShape
operator|.
name|getMaxUnit
argument_list|()
expr_stmt|;
name|lastLevelInCommon
operator|=
name|spanShape
operator|.
name|getLevelsInCommon
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|minLV
operator|=
operator|(
name|UnitNRShape
operator|)
name|iterFilter
expr_stmt|;
name|maxLV
operator|=
name|minLV
expr_stmt|;
name|lastLevelInCommon
operator|=
name|minLV
operator|.
name|getLevel
argument_list|()
expr_stmt|;
block|}
comment|//fast path optimization that is usually true, but never first level
if|if
condition|(
name|iterFilter
operator|==
name|parent
operator|.
name|iterFilter
operator|&&
operator|(
name|getLevel
argument_list|()
operator|<=
name|lastLevelInCommon
operator|||
name|parent
operator|.
name|iterFirstCellNumber
operator|!=
name|parent
operator|.
name|iterLastCellNumber
operator|)
condition|)
block|{
comment|//TODO benchmark if this optimization pays off. We avoid two comparePrefixLV calls.
if|if
condition|(
name|parent
operator|.
name|iterFirstIsIntersects
operator|&&
name|parent
operator|.
name|cellNumber
operator|==
name|parent
operator|.
name|iterFirstCellNumber
operator|&&
name|minLV
operator|.
name|getLevel
argument_list|()
operator|>=
name|getLevel
argument_list|()
condition|)
block|{
name|iterFirstCellNumber
operator|=
name|minLV
operator|.
name|getValAtLevel
argument_list|(
name|getLevel
argument_list|()
argument_list|)
expr_stmt|;
name|iterFirstIsIntersects
operator|=
operator|(
name|minLV
operator|.
name|getLevel
argument_list|()
operator|>
name|getLevel
argument_list|()
operator|)
expr_stmt|;
block|}
else|else
block|{
name|iterFirstCellNumber
operator|=
literal|0
expr_stmt|;
name|iterFirstIsIntersects
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|.
name|iterLastIsIntersects
operator|&&
name|parent
operator|.
name|cellNumber
operator|==
name|parent
operator|.
name|iterLastCellNumber
operator|&&
name|maxLV
operator|.
name|getLevel
argument_list|()
operator|>=
name|getLevel
argument_list|()
condition|)
block|{
name|iterLastCellNumber
operator|=
name|maxLV
operator|.
name|getValAtLevel
argument_list|(
name|getLevel
argument_list|()
argument_list|)
expr_stmt|;
name|iterLastIsIntersects
operator|=
operator|(
name|maxLV
operator|.
name|getLevel
argument_list|()
operator|>
name|getLevel
argument_list|()
operator|)
expr_stmt|;
block|}
else|else
block|{
name|iterLastCellNumber
operator|=
name|getNumSubCells
argument_list|(
name|parent
argument_list|)
operator|-
literal|1
expr_stmt|;
name|iterLastIsIntersects
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|iterFirstCellNumber
operator|==
name|iterLastCellNumber
condition|)
block|{
if|if
condition|(
name|iterLastIsIntersects
condition|)
name|iterFirstIsIntersects
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|iterFirstIsIntersects
condition|)
name|iterLastIsIntersects
operator|=
literal|true
expr_stmt|;
block|}
return|return;
block|}
comment|//not common to get here, except for level 1 which always happens
name|int
name|startCmp
init|=
name|comparePrefix
argument_list|(
name|minLV
argument_list|,
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|startCmp
operator|>
literal|0
condition|)
block|{
comment|//start comes after this cell
name|iterFirstCellNumber
operator|=
literal|0
expr_stmt|;
name|iterFirstIsIntersects
operator|=
literal|false
expr_stmt|;
name|iterLastCellNumber
operator|=
operator|-
literal|1
expr_stmt|;
comment|//so ends early (no cells)
name|iterLastIsIntersects
operator|=
literal|false
expr_stmt|;
return|return;
block|}
name|int
name|endCmp
init|=
name|comparePrefix
argument_list|(
name|maxLV
argument_list|,
name|parent
argument_list|)
decl_stmt|;
comment|//compare to end cell
if|if
condition|(
name|endCmp
operator|<
literal|0
condition|)
block|{
comment|//end comes before this cell
name|iterFirstCellNumber
operator|=
literal|0
expr_stmt|;
name|iterFirstIsIntersects
operator|=
literal|false
expr_stmt|;
name|iterLastCellNumber
operator|=
operator|-
literal|1
expr_stmt|;
comment|//so ends early (no cells)
name|iterLastIsIntersects
operator|=
literal|false
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|startCmp
operator|<
literal|0
operator|||
name|minLV
operator|.
name|getLevel
argument_list|()
operator|<
name|getLevel
argument_list|()
condition|)
block|{
comment|//start comes before...
name|iterFirstCellNumber
operator|=
literal|0
expr_stmt|;
name|iterFirstIsIntersects
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|iterFirstCellNumber
operator|=
name|minLV
operator|.
name|getValAtLevel
argument_list|(
name|getLevel
argument_list|()
argument_list|)
expr_stmt|;
name|iterFirstIsIntersects
operator|=
operator|(
name|minLV
operator|.
name|getLevel
argument_list|()
operator|>
name|getLevel
argument_list|()
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|endCmp
operator|>
literal|0
operator|||
name|maxLV
operator|.
name|getLevel
argument_list|()
operator|<
name|getLevel
argument_list|()
condition|)
block|{
comment|//end comes after...
name|iterLastCellNumber
operator|=
name|getNumSubCells
argument_list|(
name|parent
argument_list|)
operator|-
literal|1
expr_stmt|;
name|iterLastIsIntersects
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|iterLastCellNumber
operator|=
name|maxLV
operator|.
name|getValAtLevel
argument_list|(
name|getLevel
argument_list|()
argument_list|)
expr_stmt|;
name|iterLastIsIntersects
operator|=
operator|(
name|maxLV
operator|.
name|getLevel
argument_list|()
operator|>
name|getLevel
argument_list|()
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|iterFirstCellNumber
operator|==
name|iterLastCellNumber
condition|)
block|{
if|if
condition|(
name|iterLastIsIntersects
condition|)
name|iterFirstIsIntersects
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|iterFirstIsIntersects
condition|)
name|iterLastIsIntersects
operator|=
literal|true
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
name|thisCell
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|nextCell
operator|!=
literal|null
condition|)
comment|//calling hasNext twice in a row
return|return
literal|true
return|;
if|if
condition|(
name|cellNumber
operator|>=
name|iterLastCellNumber
condition|)
return|return
literal|false
return|;
name|resetCellWithCellNum
argument_list|(
name|cellNumber
operator|<
name|iterFirstCellNumber
condition|?
name|iterFirstCellNumber
else|:
name|cellNumber
operator|+
literal|1
argument_list|)
expr_stmt|;
name|boolean
name|hasChildren
init|=
operator|(
name|cellNumber
operator|==
name|iterFirstCellNumber
operator|&&
name|iterFirstIsIntersects
operator|)
operator|||
operator|(
name|cellNumber
operator|==
name|iterLastCellNumber
operator|&&
name|iterLastIsIntersects
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|hasChildren
condition|)
block|{
name|setLeaf
argument_list|()
expr_stmt|;
name|setShapeRel
argument_list|(
name|SpatialRelation
operator|.
name|WITHIN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iterFirstCellNumber
operator|==
name|iterLastCellNumber
condition|)
block|{
name|setShapeRel
argument_list|(
name|SpatialRelation
operator|.
name|CONTAINS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setShapeRel
argument_list|(
name|SpatialRelation
operator|.
name|INTERSECTS
argument_list|)
expr_stmt|;
block|}
name|nextCell
operator|=
name|this
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|//TODO override nextFrom to be more efficient
comment|//----------- UnitNRShape
annotation|@
name|Override
DECL|method|getValAtLevel
specifier|public
name|int
name|getValAtLevel
parameter_list|(
name|int
name|level
parameter_list|)
block|{
specifier|final
name|int
name|result
init|=
name|cellsByLevel
index|[
name|level
index|]
operator|.
name|cellNumber
decl_stmt|;
assert|assert
name|result
operator|>=
literal|0
assert|;
comment|//initialized (decoded)
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|getShapeAtLevel
specifier|public
name|NRCell
name|getShapeAtLevel
parameter_list|(
name|int
name|level
parameter_list|)
block|{
assert|assert
name|level
operator|<=
name|cellLevel
assert|;
return|return
name|cellsByLevel
index|[
name|level
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|roundToLevel
specifier|public
name|UnitNRShape
name|roundToLevel
parameter_list|(
name|int
name|targetLevel
parameter_list|)
block|{
if|if
condition|(
name|getLevel
argument_list|()
operator|<=
name|targetLevel
condition|)
block|{
return|return
name|this
return|;
block|}
else|else
block|{
return|return
name|getShapeAtLevel
argument_list|(
name|targetLevel
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|relate
specifier|public
name|SpatialRelation
name|relate
parameter_list|(
name|Shape
name|shape
parameter_list|)
block|{
name|assertDecoded
argument_list|()
expr_stmt|;
if|if
condition|(
name|shape
operator|==
name|iterFilter
operator|&&
name|cellShapeRel
operator|!=
literal|null
condition|)
return|return
name|cellShapeRel
return|;
if|if
condition|(
name|shape
operator|instanceof
name|UnitNRShape
condition|)
return|return
name|relate
argument_list|(
operator|(
name|UnitNRShape
operator|)
name|shape
argument_list|)
return|;
if|if
condition|(
name|shape
operator|instanceof
name|SpanUnitsNRShape
condition|)
return|return
name|relate
argument_list|(
operator|(
name|SpanUnitsNRShape
operator|)
name|shape
argument_list|)
return|;
return|return
name|shape
operator|.
name|relate
argument_list|(
name|this
argument_list|)
operator|.
name|transpose
argument_list|()
return|;
block|}
DECL|method|relate
specifier|public
name|SpatialRelation
name|relate
parameter_list|(
name|UnitNRShape
name|lv
parameter_list|)
block|{
name|assertDecoded
argument_list|()
expr_stmt|;
name|int
name|cmp
init|=
name|comparePrefix
argument_list|(
name|this
argument_list|,
name|lv
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|SpatialRelation
operator|.
name|DISJOINT
return|;
if|if
condition|(
name|getLevel
argument_list|()
operator|>
name|lv
operator|.
name|getLevel
argument_list|()
condition|)
return|return
name|SpatialRelation
operator|.
name|WITHIN
return|;
return|return
name|SpatialRelation
operator|.
name|CONTAINS
return|;
comment|//or equals
comment|//no INTERSECTS; that won't happen.
block|}
DECL|method|relate
specifier|public
name|SpatialRelation
name|relate
parameter_list|(
name|SpanUnitsNRShape
name|spanShape
parameter_list|)
block|{
name|assertDecoded
argument_list|()
expr_stmt|;
name|int
name|startCmp
init|=
name|comparePrefix
argument_list|(
name|spanShape
operator|.
name|getMinUnit
argument_list|()
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|startCmp
operator|>
literal|0
condition|)
block|{
comment|//start comes after this cell
return|return
name|SpatialRelation
operator|.
name|DISJOINT
return|;
block|}
name|int
name|endCmp
init|=
name|comparePrefix
argument_list|(
name|spanShape
operator|.
name|getMaxUnit
argument_list|()
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|endCmp
operator|<
literal|0
condition|)
block|{
comment|//end comes before this cell
return|return
name|SpatialRelation
operator|.
name|DISJOINT
return|;
block|}
name|int
name|nrMinLevel
init|=
name|spanShape
operator|.
name|getMinUnit
argument_list|()
operator|.
name|getLevel
argument_list|()
decl_stmt|;
name|int
name|nrMaxLevel
init|=
name|spanShape
operator|.
name|getMaxUnit
argument_list|()
operator|.
name|getLevel
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|startCmp
operator|<
literal|0
operator|||
name|startCmp
operator|==
literal|0
operator|&&
name|nrMinLevel
operator|<=
name|getLevel
argument_list|()
operator|)
operator|&&
operator|(
name|endCmp
operator|>
literal|0
operator|||
name|endCmp
operator|==
literal|0
operator|&&
name|nrMaxLevel
operator|<=
name|getLevel
argument_list|()
operator|)
condition|)
return|return
name|SpatialRelation
operator|.
name|WITHIN
return|;
comment|//or equals
comment|//At this point it's Contains or Within.
if|if
condition|(
name|startCmp
operator|!=
literal|0
operator|||
name|endCmp
operator|!=
literal|0
condition|)
return|return
name|SpatialRelation
operator|.
name|INTERSECTS
return|;
comment|//if min or max Level is less, it might be on the equivalent edge.
for|for
control|(
init|;
name|nrMinLevel
operator|<
name|getLevel
argument_list|()
condition|;
name|nrMinLevel
operator|++
control|)
block|{
if|if
condition|(
name|getValAtLevel
argument_list|(
name|nrMinLevel
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|SpatialRelation
operator|.
name|INTERSECTS
return|;
block|}
for|for
control|(
init|;
name|nrMaxLevel
operator|<
name|getLevel
argument_list|()
condition|;
name|nrMaxLevel
operator|++
control|)
block|{
if|if
condition|(
name|getValAtLevel
argument_list|(
name|nrMaxLevel
operator|+
literal|1
argument_list|)
operator|!=
name|getNumSubCells
argument_list|(
name|getShapeAtLevel
argument_list|(
name|nrMaxLevel
argument_list|)
argument_list|)
operator|-
literal|1
condition|)
return|return
name|SpatialRelation
operator|.
name|INTERSECTS
return|;
block|}
return|return
name|SpatialRelation
operator|.
name|CONTAINS
return|;
block|}
annotation|@
name|Override
DECL|method|clone
specifier|public
name|UnitNRShape
name|clone
parameter_list|()
block|{
comment|//no leaf distinction; this is purely based on UnitNRShape
name|NRCell
name|cell
init|=
operator|(
name|NRCell
operator|)
name|readCell
argument_list|(
name|getTokenBytesNoLeaf
argument_list|(
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|cell
operator|.
name|ensureOwnTermBytes
argument_list|()
expr_stmt|;
return|return
name|cell
operator|.
name|getShape
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|UnitNRShape
name|o
parameter_list|)
block|{
name|assertDecoded
argument_list|()
expr_stmt|;
comment|//no leaf distinction; this is purely based on UnitNRShape
name|int
name|cmp
init|=
name|comparePrefix
argument_list|(
name|this
argument_list|,
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
else|else
block|{
return|return
name|getLevel
argument_list|()
operator|-
name|o
operator|.
name|getLevel
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getBoundingBox
specifier|public
name|Rectangle
name|getBoundingBox
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|hasArea
specifier|public
name|boolean
name|hasArea
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|getArea
specifier|public
name|double
name|getArea
parameter_list|(
name|SpatialContext
name|ctx
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getCenter
specifier|public
name|Point
name|getCenter
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getBuffered
specifier|public
name|Shape
name|getBuffered
parameter_list|(
name|double
name|distance
parameter_list|,
name|SpatialContext
name|ctx
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|//------- Object
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|NRCell
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|==
name|obj
condition|)
return|return
literal|true
return|;
name|NRCell
name|nrCell
init|=
operator|(
name|NRCell
operator|)
name|obj
decl_stmt|;
assert|assert
name|term
operator|!=
name|nrCell
operator|.
name|term
assert|;
if|if
condition|(
name|getLevel
argument_list|()
operator|!=
name|nrCell
operator|.
name|getLevel
argument_list|()
condition|)
return|return
literal|false
return|;
comment|//trick to re-use bytesref; provided that we re-instate it
name|int
name|myLastLen
init|=
name|term
operator|.
name|length
decl_stmt|;
name|int
name|otherLastLen
init|=
name|nrCell
operator|.
name|term
operator|.
name|length
decl_stmt|;
name|boolean
name|answer
init|=
name|getTokenBytesNoLeaf
argument_list|(
name|term
argument_list|)
operator|.
name|equals
argument_list|(
name|nrCell
operator|.
name|getTokenBytesNoLeaf
argument_list|(
name|nrCell
operator|.
name|term
argument_list|)
argument_list|)
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|myLastLen
expr_stmt|;
name|nrCell
operator|.
name|term
operator|.
name|length
operator|=
name|otherLastLen
expr_stmt|;
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|//trick to re-use bytesref; provided that we re-instate it
name|int
name|myLastLen
init|=
name|term
operator|.
name|length
decl_stmt|;
name|int
name|result
init|=
name|getTokenBytesNoLeaf
argument_list|(
name|term
argument_list|)
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|myLastLen
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|NumberRangePrefixTree
operator|.
name|this
operator|.
name|toString
argument_list|(
name|getShape
argument_list|()
argument_list|)
return|;
block|}
comment|/** Configure your IDE to use this. */
DECL|method|toStringDebug
specifier|public
name|String
name|toStringDebug
parameter_list|()
block|{
name|String
name|pretty
init|=
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|getLevel
argument_list|()
operator|==
literal|0
condition|)
return|return
name|pretty
return|;
return|return
name|toStringUnitRaw
argument_list|(
name|this
argument_list|)
operator|+
operator|(
name|isLeaf
argument_list|()
condition|?
literal|""
else|:
literal|""
operator|)
operator|+
literal|" "
operator|+
name|pretty
return|;
block|}
block|}
comment|// END OF NRCell
block|}
end_class
end_unit
