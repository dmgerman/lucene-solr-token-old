begin_unit
begin_package
DECL|package|org.apache.lucene.spatial.prefix.tree
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|prefix
operator|.
name|tree
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|context
operator|.
name|SpatialContext
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|context
operator|.
name|SpatialContextFactory
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Point
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Rectangle
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Shape
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|SpatialRelation
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|impl
operator|.
name|RectangleImpl
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import
begin_comment
comment|/**  * A special SpatialPrefixTree for single-dimensional number ranges of integral values. It's based  * on a stack of integers, and thus it's not limited to a long.  * @see<a href="https://issues.apache.org/jira/browse/LUCENE-5648">LUCENE-5648</a>  * @lucene.experimental  */
end_comment
begin_class
DECL|class|NumberRangePrefixTree
specifier|public
specifier|abstract
class|class
name|NumberRangePrefixTree
extends|extends
name|SpatialPrefixTree
block|{
comment|//
comment|//    Dummy SpatialContext
comment|//
DECL|field|DUMMY_CTX
specifier|private
specifier|static
specifier|final
name|SpatialContext
name|DUMMY_CTX
decl_stmt|;
static|static
block|{
name|SpatialContextFactory
name|factory
init|=
operator|new
name|SpatialContextFactory
argument_list|()
decl_stmt|;
name|factory
operator|.
name|geo
operator|=
literal|false
expr_stmt|;
name|factory
operator|.
name|worldBounds
operator|=
operator|new
name|RectangleImpl
argument_list|(
name|Double
operator|.
name|NEGATIVE_INFINITY
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|DUMMY_CTX
operator|=
name|factory
operator|.
name|newSpatialContext
argument_list|()
expr_stmt|;
block|}
comment|//
comment|//    LevelledValue
comment|//
comment|/** A value implemented as a stack of numbers. Spatially speaking, it's    * analogous to a Point but 1D yet has some precision width.    * @lucene.internal */
DECL|interface|LevelledValue
specifier|protected
specifier|static
interface|interface
name|LevelledValue
extends|extends
name|Shape
block|{
DECL|method|getLevel
name|int
name|getLevel
parameter_list|()
function_decl|;
comment|//0 means the world (universe).
DECL|method|getValAtLevel
name|int
name|getValAtLevel
parameter_list|(
name|int
name|level
parameter_list|)
function_decl|;
comment|//level>= 0&&<= getLevel()
DECL|method|getLVAtLevel
name|LevelledValue
name|getLVAtLevel
parameter_list|(
name|int
name|level
parameter_list|)
function_decl|;
block|}
comment|/** Compares a to b, returning less than 0, 0, or greater than 0, if a is less than, equal to, or    * greater than b, respectively. Only min(a.levels,b.levels) are compared.    * @lucene.internal */
DECL|method|comparePrefixLV
specifier|protected
specifier|static
name|int
name|comparePrefixLV
parameter_list|(
name|LevelledValue
name|a
parameter_list|,
name|LevelledValue
name|b
parameter_list|)
block|{
name|int
name|minLevel
init|=
name|Math
operator|.
name|min
argument_list|(
name|a
operator|.
name|getLevel
argument_list|()
argument_list|,
name|b
operator|.
name|getLevel
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<=
name|minLevel
condition|;
name|level
operator|++
control|)
block|{
name|int
name|diff
init|=
name|a
operator|.
name|getValAtLevel
argument_list|(
name|level
argument_list|)
operator|-
name|b
operator|.
name|getValAtLevel
argument_list|(
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
return|return
name|diff
return|;
block|}
return|return
literal|0
return|;
block|}
DECL|method|toStringLV
specifier|protected
name|String
name|toStringLV
parameter_list|(
name|LevelledValue
name|lv
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<=
name|lv
operator|.
name|getLevel
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|lv
operator|.
name|getValAtLevel
argument_list|(
name|level
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|setLength
argument_list|(
name|buf
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//chop off ','
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|//
comment|//    NRShape
comment|//
comment|/** Number Range Shape; based on a pair of {@link LevelledValue}.    * Spatially speaking, it's analogous to a Rectangle but 1D.    * @lucene.internal */
DECL|class|NRShape
specifier|protected
class|class
name|NRShape
implements|implements
name|Shape
block|{
DECL|field|minLV
DECL|field|maxLV
specifier|private
specifier|final
name|LevelledValue
name|minLV
decl_stmt|,
name|maxLV
decl_stmt|;
DECL|field|lastLevelInCommon
specifier|private
specifier|final
name|int
name|lastLevelInCommon
decl_stmt|;
comment|//computed; not part of identity
comment|/** Don't call directly; see {@link #toRangeShape(com.spatial4j.core.shape.Shape, com.spatial4j.core.shape.Shape)}. */
DECL|method|NRShape
specifier|private
name|NRShape
parameter_list|(
name|LevelledValue
name|minLV
parameter_list|,
name|LevelledValue
name|maxLV
parameter_list|)
block|{
name|this
operator|.
name|minLV
operator|=
name|minLV
expr_stmt|;
name|this
operator|.
name|maxLV
operator|=
name|maxLV
expr_stmt|;
comment|//calc lastLevelInCommon
name|int
name|level
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
name|level
operator|<=
name|minLV
operator|.
name|getLevel
argument_list|()
operator|&&
name|level
operator|<=
name|maxLV
operator|.
name|getLevel
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|minLV
operator|.
name|getValAtLevel
argument_list|(
name|level
argument_list|)
operator|!=
name|maxLV
operator|.
name|getValAtLevel
argument_list|(
name|level
argument_list|)
condition|)
break|break;
block|}
name|lastLevelInCommon
operator|=
name|level
operator|-
literal|1
expr_stmt|;
block|}
DECL|method|getMinLV
specifier|public
name|LevelledValue
name|getMinLV
parameter_list|()
block|{
return|return
name|minLV
return|;
block|}
DECL|method|getMaxLV
specifier|public
name|LevelledValue
name|getMaxLV
parameter_list|()
block|{
return|return
name|maxLV
return|;
block|}
comment|/** How many levels are in common between minLV and maxLV. */
DECL|method|getLastLevelInCommon
specifier|private
name|int
name|getLastLevelInCommon
parameter_list|()
block|{
return|return
name|lastLevelInCommon
return|;
block|}
annotation|@
name|Override
DECL|method|relate
specifier|public
name|SpatialRelation
name|relate
parameter_list|(
name|Shape
name|shape
parameter_list|)
block|{
comment|//      if (shape instanceof LevelledValue)
comment|//        return relate((LevelledValue)shape);
if|if
condition|(
name|shape
operator|instanceof
name|NRShape
condition|)
return|return
name|relate
argument_list|(
operator|(
name|NRShape
operator|)
name|shape
argument_list|)
return|;
return|return
name|shape
operator|.
name|relate
argument_list|(
name|this
argument_list|)
operator|.
name|transpose
argument_list|()
return|;
comment|//probably a LevelledValue
block|}
DECL|method|relate
specifier|public
name|SpatialRelation
name|relate
parameter_list|(
name|NRShape
name|ext
parameter_list|)
block|{
comment|//This logic somewhat mirrors RectangleImpl.relate_range()
name|int
name|extMin_intMax
init|=
name|comparePrefixLV
argument_list|(
name|ext
operator|.
name|getMinLV
argument_list|()
argument_list|,
name|getMaxLV
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|extMin_intMax
operator|>
literal|0
condition|)
return|return
name|SpatialRelation
operator|.
name|DISJOINT
return|;
name|int
name|extMax_intMin
init|=
name|comparePrefixLV
argument_list|(
name|ext
operator|.
name|getMaxLV
argument_list|()
argument_list|,
name|getMinLV
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|extMax_intMin
operator|<
literal|0
condition|)
return|return
name|SpatialRelation
operator|.
name|DISJOINT
return|;
name|int
name|extMin_intMin
init|=
name|comparePrefixLV
argument_list|(
name|ext
operator|.
name|getMinLV
argument_list|()
argument_list|,
name|getMinLV
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|extMax_intMax
init|=
name|comparePrefixLV
argument_list|(
name|ext
operator|.
name|getMaxLV
argument_list|()
argument_list|,
name|getMaxLV
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|extMin_intMin
operator|>
literal|0
operator|||
name|extMin_intMin
operator|==
literal|0
operator|&&
name|ext
operator|.
name|getMinLV
argument_list|()
operator|.
name|getLevel
argument_list|()
operator|>=
name|getMinLV
argument_list|()
operator|.
name|getLevel
argument_list|()
operator|)
operator|&&
operator|(
name|extMax_intMax
operator|<
literal|0
operator|||
name|extMax_intMax
operator|==
literal|0
operator|&&
name|ext
operator|.
name|getMaxLV
argument_list|()
operator|.
name|getLevel
argument_list|()
operator|>=
name|getMaxLV
argument_list|()
operator|.
name|getLevel
argument_list|()
operator|)
condition|)
return|return
name|SpatialRelation
operator|.
name|CONTAINS
return|;
if|if
condition|(
operator|(
name|extMin_intMin
operator|<
literal|0
operator|||
name|extMin_intMin
operator|==
literal|0
operator|&&
name|ext
operator|.
name|getMinLV
argument_list|()
operator|.
name|getLevel
argument_list|()
operator|<=
name|getMinLV
argument_list|()
operator|.
name|getLevel
argument_list|()
operator|)
operator|&&
operator|(
name|extMax_intMax
operator|>
literal|0
operator|||
name|extMax_intMax
operator|==
literal|0
operator|&&
name|ext
operator|.
name|getMaxLV
argument_list|()
operator|.
name|getLevel
argument_list|()
operator|<=
name|getMaxLV
argument_list|()
operator|.
name|getLevel
argument_list|()
operator|)
condition|)
return|return
name|SpatialRelation
operator|.
name|WITHIN
return|;
return|return
name|SpatialRelation
operator|.
name|INTERSECTS
return|;
block|}
annotation|@
name|Override
DECL|method|getBoundingBox
specifier|public
name|Rectangle
name|getBoundingBox
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|hasArea
specifier|public
name|boolean
name|hasArea
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|getArea
specifier|public
name|double
name|getArea
parameter_list|(
name|SpatialContext
name|spatialContext
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getCenter
specifier|public
name|Point
name|getCenter
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getBuffered
specifier|public
name|Shape
name|getBuffered
parameter_list|(
name|double
name|v
parameter_list|,
name|SpatialContext
name|spatialContext
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"["
operator|+
name|toStringLV
argument_list|(
name|minLV
argument_list|)
operator|+
literal|" TO "
operator|+
name|toStringLV
argument_list|(
name|maxLV
argument_list|)
operator|+
literal|"]"
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
name|NRShape
name|nrShape
init|=
operator|(
name|NRShape
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|!
name|maxLV
operator|.
name|equals
argument_list|(
name|nrShape
operator|.
name|maxLV
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|minLV
operator|.
name|equals
argument_list|(
name|nrShape
operator|.
name|minLV
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|minLV
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|maxLV
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|// class NRShapeImpl
comment|/** Converts the value to a shape (usually not a range). If it's a JDK object (e.g. Number, Calendar)    * that could be parsed from a String, this class won't do it; you must parse it. */
DECL|method|toShape
specifier|public
specifier|abstract
name|Shape
name|toShape
parameter_list|(
name|Object
name|value
parameter_list|)
function_decl|;
comment|/** Detects a range pattern and parses it, otherwise it's parsed as one shape via    * {@link #parseShapeLV(String)}.  The range pattern looks like this BNF:    *<pre>    *   '[' + parseShapeLV + ' TO ' + parseShapeLV + ']'    *</pre>    * It's the same thing as the toString() of the range shape, notwithstanding range optimization.    * @param str not null or empty    * @return not null    * @throws java.text.ParseException If there is a problem    */
DECL|method|parseShape
specifier|public
name|Shape
name|parseShape
parameter_list|(
name|String
name|str
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|str
operator|==
literal|null
operator|||
name|str
operator|.
name|isEmpty
argument_list|()
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"str is null or blank"
argument_list|)
throw|;
if|if
condition|(
name|str
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'['
condition|)
block|{
if|if
condition|(
name|str
operator|.
name|charAt
argument_list|(
name|str
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|!=
literal|']'
condition|)
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"If starts with [ must end with ]; got "
operator|+
name|str
argument_list|,
name|str
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
throw|;
name|int
name|middle
init|=
name|str
operator|.
name|indexOf
argument_list|(
literal|" TO "
argument_list|)
decl_stmt|;
if|if
condition|(
name|middle
operator|<
literal|0
condition|)
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"If starts with [ must contain ' TO '; got "
operator|+
name|str
argument_list|,
operator|-
literal|1
argument_list|)
throw|;
name|String
name|leftStr
init|=
name|str
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|middle
argument_list|)
decl_stmt|;
name|String
name|rightStr
init|=
name|str
operator|.
name|substring
argument_list|(
name|middle
operator|+
literal|" TO "
operator|.
name|length
argument_list|()
argument_list|,
name|str
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
name|toRangeShape
argument_list|(
name|parseShapeLV
argument_list|(
name|leftStr
argument_list|)
argument_list|,
name|parseShapeLV
argument_list|(
name|rightStr
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|str
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'{'
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Exclusive ranges not supported; got "
operator|+
name|str
argument_list|,
literal|0
argument_list|)
throw|;
block|}
else|else
block|{
return|return
name|parseShapeLV
argument_list|(
name|str
argument_list|)
return|;
block|}
block|}
comment|/** Parse a String to a LevelledValue. "*" should be the full-range. */
DECL|method|parseShapeLV
specifier|protected
specifier|abstract
name|LevelledValue
name|parseShapeLV
parameter_list|(
name|String
name|str
parameter_list|)
throws|throws
name|ParseException
function_decl|;
comment|/** Returns a shape that represents the continuous range between {@code start} and {@code end}. It will    * be optimized.    * @throws IllegalArgumentException if the arguments are in the wrong order, or if either contains the other.    */
DECL|method|toRangeShape
specifier|public
name|Shape
name|toRangeShape
parameter_list|(
name|Shape
name|start
parameter_list|,
name|Shape
name|end
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|start
operator|instanceof
name|LevelledValue
operator|&&
name|end
operator|instanceof
name|LevelledValue
operator|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Must pass "
operator|+
name|LevelledValue
operator|.
name|class
operator|+
literal|" but got "
operator|+
name|start
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
name|LevelledValue
name|minLV
init|=
operator|(
name|LevelledValue
operator|)
name|start
decl_stmt|;
name|LevelledValue
name|maxLV
init|=
operator|(
name|LevelledValue
operator|)
name|end
decl_stmt|;
if|if
condition|(
name|minLV
operator|.
name|equals
argument_list|(
name|maxLV
argument_list|)
condition|)
return|return
name|minLV
return|;
comment|//Optimize precision of the range, e.g. April 1st to April 30th is April.
name|minLV
operator|=
name|minLV
operator|.
name|getLVAtLevel
argument_list|(
name|truncateStartVals
argument_list|(
name|minLV
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|maxLV
operator|=
name|maxLV
operator|.
name|getLVAtLevel
argument_list|(
name|truncateEndVals
argument_list|(
name|maxLV
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|cmp
init|=
name|comparePrefixLV
argument_list|(
name|minLV
argument_list|,
name|maxLV
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Wrong order: "
operator|+
name|start
operator|+
literal|" TO "
operator|+
name|end
argument_list|)
throw|;
block|}
if|if
condition|(
name|cmp
operator|==
literal|0
operator|&&
name|minLV
operator|.
name|getLevel
argument_list|()
operator|==
name|maxLV
operator|.
name|getLevel
argument_list|()
condition|)
return|return
name|minLV
return|;
return|return
operator|new
name|NRShape
argument_list|(
name|minLV
argument_list|,
name|maxLV
argument_list|)
return|;
block|}
comment|/** From lv.getLevel on up, it returns the first Level seen with val != 0. It doesn't check past endLevel. */
DECL|method|truncateStartVals
specifier|private
name|int
name|truncateStartVals
parameter_list|(
name|LevelledValue
name|lv
parameter_list|,
name|int
name|endLevel
parameter_list|)
block|{
for|for
control|(
name|int
name|level
init|=
name|lv
operator|.
name|getLevel
argument_list|()
init|;
name|level
operator|>
name|endLevel
condition|;
name|level
operator|--
control|)
block|{
if|if
condition|(
name|lv
operator|.
name|getValAtLevel
argument_list|(
name|level
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|level
return|;
block|}
return|return
name|endLevel
return|;
block|}
DECL|method|truncateEndVals
specifier|private
name|int
name|truncateEndVals
parameter_list|(
name|LevelledValue
name|lv
parameter_list|,
name|int
name|endLevel
parameter_list|)
block|{
for|for
control|(
name|int
name|level
init|=
name|lv
operator|.
name|getLevel
argument_list|()
init|;
name|level
operator|>
name|endLevel
condition|;
name|level
operator|--
control|)
block|{
name|int
name|max
init|=
name|getNumSubCells
argument_list|(
name|lv
operator|.
name|getLVAtLevel
argument_list|(
name|level
operator|-
literal|1
argument_list|)
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|lv
operator|.
name|getValAtLevel
argument_list|(
name|level
argument_list|)
operator|!=
name|max
condition|)
return|return
name|level
return|;
block|}
return|return
name|endLevel
return|;
block|}
comment|//
comment|//    NumberRangePrefixTree
comment|//
DECL|field|maxSubCellsByLevel
specifier|protected
specifier|final
name|int
index|[]
name|maxSubCellsByLevel
decl_stmt|;
DECL|field|termLenByLevel
specifier|protected
specifier|final
name|int
index|[]
name|termLenByLevel
decl_stmt|;
DECL|field|levelByTermLen
specifier|protected
specifier|final
name|int
index|[]
name|levelByTermLen
decl_stmt|;
DECL|field|maxTermLen
specifier|protected
specifier|final
name|int
name|maxTermLen
decl_stmt|;
comment|// how long could cell.getToken... (that is a leaf) possibly be?
DECL|method|NumberRangePrefixTree
specifier|protected
name|NumberRangePrefixTree
parameter_list|(
name|int
index|[]
name|maxSubCellsByLevel
parameter_list|)
block|{
name|super
argument_list|(
name|DUMMY_CTX
argument_list|,
name|maxSubCellsByLevel
operator|.
name|length
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxSubCellsByLevel
operator|=
name|maxSubCellsByLevel
expr_stmt|;
comment|// Fill termLenByLevel
name|this
operator|.
name|termLenByLevel
operator|=
operator|new
name|int
index|[
name|maxLevels
operator|+
literal|1
index|]
expr_stmt|;
name|termLenByLevel
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
specifier|final
name|int
name|MAX_STATES
init|=
literal|1
operator|<<
literal|15
decl_stmt|;
comment|//1 bit less than 2 bytes
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<=
name|maxLevels
condition|;
name|level
operator|++
control|)
block|{
specifier|final
name|int
name|states
init|=
name|maxSubCellsByLevel
index|[
name|level
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|states
operator|>=
name|MAX_STATES
operator|||
name|states
operator|<=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Max states is "
operator|+
name|MAX_STATES
operator|+
literal|", given "
operator|+
name|states
operator|+
literal|" at level "
operator|+
name|level
argument_list|)
throw|;
block|}
name|boolean
name|twoBytes
init|=
name|states
operator|>=
literal|256
decl_stmt|;
name|termLenByLevel
index|[
name|level
index|]
operator|=
name|termLenByLevel
index|[
name|level
operator|-
literal|1
index|]
operator|+
operator|(
name|twoBytes
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
block|}
name|maxTermLen
operator|=
name|termLenByLevel
index|[
name|maxLevels
index|]
operator|+
literal|1
expr_stmt|;
comment|// + 1 for leaf byte
comment|// Fill levelByTermLen
name|levelByTermLen
operator|=
operator|new
name|int
index|[
name|maxTermLen
index|]
expr_stmt|;
name|levelByTermLen
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<
name|termLenByLevel
operator|.
name|length
condition|;
name|level
operator|++
control|)
block|{
name|int
name|termLen
init|=
name|termLenByLevel
index|[
name|level
index|]
decl_stmt|;
name|int
name|prevTermLen
init|=
name|termLenByLevel
index|[
name|level
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|termLen
operator|-
name|prevTermLen
operator|==
literal|2
condition|)
block|{
comment|//2 byte delta
comment|//if the term doesn't completely cover this cell then it must be a leaf of the prior.
name|levelByTermLen
index|[
name|termLen
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|//won't be used; otherwise erroneous
name|levelByTermLen
index|[
name|termLen
index|]
operator|=
name|level
expr_stmt|;
block|}
else|else
block|{
comment|//1 byte delta
assert|assert
name|termLen
operator|-
name|prevTermLen
operator|==
literal|1
assert|;
name|levelByTermLen
index|[
name|termLen
index|]
operator|=
name|level
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getLevelForDistance
specifier|public
name|int
name|getLevelForDistance
parameter_list|(
name|double
name|dist
parameter_list|)
block|{
return|return
name|maxLevels
return|;
block|}
annotation|@
name|Override
DECL|method|getDistanceForLevel
specifier|public
name|double
name|getDistanceForLevel
parameter_list|(
name|int
name|level
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Not applicable."
argument_list|)
throw|;
block|}
DECL|method|toShape
specifier|protected
name|Shape
name|toShape
parameter_list|(
name|int
index|[]
name|valStack
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|final
name|NRCell
index|[]
name|cellStack
init|=
name|newCellStack
argument_list|(
name|len
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|cellStack
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|resetCellWithCellNum
argument_list|(
name|valStack
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|cellStack
index|[
name|len
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|getWorldCell
specifier|public
name|Cell
name|getWorldCell
parameter_list|()
block|{
return|return
name|newCellStack
argument_list|(
name|maxLevels
argument_list|)
index|[
literal|0
index|]
return|;
block|}
DECL|method|newCellStack
specifier|protected
name|NRCell
index|[]
name|newCellStack
parameter_list|(
name|int
name|levels
parameter_list|)
block|{
specifier|final
name|NRCell
index|[]
name|cellsByLevel
init|=
operator|new
name|NRCell
index|[
name|levels
operator|+
literal|1
index|]
decl_stmt|;
specifier|final
name|BytesRef
name|term
init|=
operator|new
name|BytesRef
argument_list|(
name|maxTermLen
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<=
name|levels
condition|;
name|level
operator|++
control|)
block|{
name|cellsByLevel
index|[
name|level
index|]
operator|=
operator|new
name|NRCell
argument_list|(
name|cellsByLevel
argument_list|,
name|term
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
return|return
name|cellsByLevel
return|;
block|}
annotation|@
name|Override
DECL|method|readCell
specifier|public
name|Cell
name|readCell
parameter_list|(
name|BytesRef
name|term
parameter_list|,
name|Cell
name|scratch
parameter_list|)
block|{
if|if
condition|(
name|scratch
operator|==
literal|null
condition|)
name|scratch
operator|=
name|getWorldCell
argument_list|()
expr_stmt|;
comment|//We decode level, leaf, and populate bytes.
comment|//reverse lookup term length to the level and hence the cell
name|NRCell
index|[]
name|cellsByLevel
init|=
operator|(
operator|(
name|NRCell
operator|)
name|scratch
operator|)
operator|.
name|cellsByLevel
decl_stmt|;
name|boolean
name|isLeaf
init|=
name|term
operator|.
name|bytes
index|[
name|term
operator|.
name|offset
operator|+
name|term
operator|.
name|length
operator|-
literal|1
index|]
operator|==
literal|0
decl_stmt|;
name|int
name|lenNoLeaf
init|=
name|isLeaf
condition|?
name|term
operator|.
name|length
operator|-
literal|1
else|:
name|term
operator|.
name|length
decl_stmt|;
name|NRCell
name|result
init|=
name|cellsByLevel
index|[
name|levelByTermLen
index|[
name|lenNoLeaf
index|]
index|]
decl_stmt|;
if|if
condition|(
name|cellsByLevel
index|[
literal|0
index|]
operator|.
name|termBuf
operator|==
literal|null
condition|)
name|cellsByLevel
index|[
literal|0
index|]
operator|.
name|termBuf
operator|=
name|result
operator|.
name|term
operator|.
name|bytes
expr_stmt|;
comment|//a kluge; see cell.ensureOwnTermBytes()
name|result
operator|.
name|term
operator|.
name|bytes
operator|=
name|term
operator|.
name|bytes
expr_stmt|;
name|result
operator|.
name|term
operator|.
name|offset
operator|=
name|term
operator|.
name|offset
expr_stmt|;
name|result
operator|.
name|term
operator|.
name|length
operator|=
name|lenNoLeaf
expr_stmt|;
comment|//technically this isn't used but may help debugging
name|result
operator|.
name|reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|isLeaf
condition|)
name|result
operator|.
name|setLeaf
argument_list|()
expr_stmt|;
name|result
operator|.
name|cellNumber
operator|=
operator|-
literal|1
expr_stmt|;
comment|//lazy decode flag
return|return
name|result
return|;
block|}
DECL|method|getNumSubCells
specifier|protected
name|int
name|getNumSubCells
parameter_list|(
name|LevelledValue
name|lv
parameter_list|)
block|{
return|return
name|maxSubCellsByLevel
index|[
name|lv
operator|.
name|getLevel
argument_list|()
index|]
return|;
block|}
comment|//
comment|//    NRCell
comment|//
comment|/** Most of the PrefixTree implementation is in this one class, which is both    * the Cell, the CellIterator, and the Shape to reduce object allocation. It's implemented as a re-used array/stack    * of Cells at adjacent levels, that all have a reference back to the cell array to traverse. They also share a common    * BytesRef for the term.    * @lucene.internal */
DECL|class|NRCell
specifier|protected
class|class
name|NRCell
extends|extends
name|CellIterator
implements|implements
name|Cell
implements|,
name|LevelledValue
block|{
comment|//Shared: (TODO put this in a new class)
DECL|field|cellsByLevel
specifier|final
name|NRCell
index|[]
name|cellsByLevel
decl_stmt|;
DECL|field|term
specifier|final
name|BytesRef
name|term
decl_stmt|;
comment|//AKA the token
DECL|field|termBuf
name|byte
index|[]
name|termBuf
decl_stmt|;
comment|// see ensureOwnTermBytes(), only for cell0
comment|//Cell state...
DECL|field|cellLevel
specifier|final
name|int
name|cellLevel
decl_stmt|;
comment|// assert levelStack[cellLevel] == this
DECL|field|cellNumber
name|int
name|cellNumber
decl_stmt|;
comment|//relative to parent cell. It's unused for level 0. Starts at 0.
DECL|field|cellShapeRel
name|SpatialRelation
name|cellShapeRel
decl_stmt|;
DECL|field|cellIsLeaf
name|boolean
name|cellIsLeaf
decl_stmt|;
comment|//CellIterator state is defined further below
DECL|method|NRCell
name|NRCell
parameter_list|(
name|NRCell
index|[]
name|cellsByLevel
parameter_list|,
name|BytesRef
name|term
parameter_list|,
name|int
name|cellLevel
parameter_list|)
block|{
name|this
operator|.
name|cellsByLevel
operator|=
name|cellsByLevel
expr_stmt|;
name|this
operator|.
name|term
operator|=
name|term
expr_stmt|;
name|this
operator|.
name|cellLevel
operator|=
name|cellLevel
expr_stmt|;
name|this
operator|.
name|cellNumber
operator|=
name|cellLevel
operator|==
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|cellIsLeaf
operator|=
literal|false
expr_stmt|;
assert|assert
name|cellsByLevel
index|[
name|cellLevel
index|]
operator|==
literal|null
assert|;
block|}
comment|/** Ensure we own term.bytes so that it's safe to modify. We detect via a kluge in which cellsByLevel[0].termBuf      * is non-null, which is a pre-allocated for use to replace term.bytes. */
DECL|method|ensureOwnTermBytes
name|void
name|ensureOwnTermBytes
parameter_list|()
block|{
name|NRCell
name|cell0
init|=
name|cellsByLevel
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|cell0
operator|.
name|termBuf
operator|==
literal|null
condition|)
return|return;
comment|//we already own the bytes
name|System
operator|.
name|arraycopy
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|term
operator|.
name|offset
argument_list|,
name|cell0
operator|.
name|termBuf
argument_list|,
literal|0
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
name|term
operator|.
name|bytes
operator|=
name|cell0
operator|.
name|termBuf
expr_stmt|;
name|term
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|cell0
operator|.
name|termBuf
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|reset
specifier|private
name|void
name|reset
parameter_list|()
block|{
name|this
operator|.
name|cellIsLeaf
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|cellShapeRel
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|resetCellWithCellNum
specifier|private
name|void
name|resetCellWithCellNum
parameter_list|(
name|int
name|cellNumber
parameter_list|)
block|{
name|reset
argument_list|()
expr_stmt|;
comment|//update bytes
comment|//  note: see lazyInitCellNumsFromBytes() for the reverse
if|if
condition|(
name|cellNumber
operator|>=
literal|0
condition|)
block|{
comment|//valid
name|ensureOwnTermBytes
argument_list|()
expr_stmt|;
name|int
name|termLen
init|=
name|termLenByLevel
index|[
name|getLevel
argument_list|()
index|]
decl_stmt|;
name|boolean
name|twoBytes
init|=
operator|(
name|termLen
operator|-
name|termLenByLevel
index|[
name|getLevel
argument_list|()
operator|-
literal|1
index|]
operator|)
operator|>
literal|1
decl_stmt|;
if|if
condition|(
name|twoBytes
condition|)
block|{
comment|//right 7 bits, plus 1 (may overflow to 8th bit which is okay)
name|term
operator|.
name|bytes
index|[
name|termLen
operator|-
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|cellNumber
operator|>>
literal|7
argument_list|)
expr_stmt|;
name|term
operator|.
name|bytes
index|[
name|termLen
operator|-
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|cellNumber
operator|&
literal|0x7F
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|term
operator|.
name|bytes
index|[
name|termLen
operator|-
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|cellNumber
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
assert|assert
name|term
operator|.
name|bytes
index|[
name|termLen
operator|-
literal|1
index|]
operator|!=
literal|0
assert|;
name|term
operator|.
name|length
operator|=
name|termLen
expr_stmt|;
block|}
name|this
operator|.
name|cellNumber
operator|=
name|cellNumber
expr_stmt|;
block|}
DECL|method|ensureDecoded
specifier|private
name|void
name|ensureDecoded
parameter_list|()
block|{
if|if
condition|(
name|cellNumber
operator|>=
literal|0
condition|)
return|return;
comment|//Decode cell numbers from bytes. This is the inverse of resetCellWithCellNum().
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<=
name|getLevel
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
name|NRCell
name|cell
init|=
name|cellsByLevel
index|[
name|level
index|]
decl_stmt|;
name|int
name|termLen
init|=
name|termLenByLevel
index|[
name|level
index|]
decl_stmt|;
name|boolean
name|twoBytes
init|=
operator|(
name|termLen
operator|-
name|termLenByLevel
index|[
name|level
operator|-
literal|1
index|]
operator|)
operator|>
literal|1
decl_stmt|;
if|if
condition|(
name|twoBytes
condition|)
block|{
name|int
name|byteH
init|=
operator|(
name|term
operator|.
name|bytes
index|[
name|term
operator|.
name|offset
operator|+
name|termLen
operator|-
literal|2
index|]
operator|&
literal|0xFF
operator|)
decl_stmt|;
name|int
name|byteL
init|=
operator|(
name|term
operator|.
name|bytes
index|[
name|term
operator|.
name|offset
operator|+
name|termLen
operator|-
literal|1
index|]
operator|&
literal|0xFF
operator|)
decl_stmt|;
assert|assert
name|byteL
operator|-
literal|1
operator|<
operator|(
literal|1
operator|<<
literal|7
operator|)
assert|;
name|cell
operator|.
name|cellNumber
operator|=
operator|(
name|byteH
operator|<<
literal|7
operator|)
operator|+
operator|(
name|byteL
operator|-
literal|1
operator|)
expr_stmt|;
assert|assert
name|cell
operator|.
name|cellNumber
operator|<
literal|1
operator|<<
literal|15
assert|;
block|}
else|else
block|{
name|cell
operator|.
name|cellNumber
operator|=
operator|(
name|term
operator|.
name|bytes
index|[
name|term
operator|.
name|offset
operator|+
name|termLen
operator|-
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|-
literal|1
expr_stmt|;
assert|assert
name|cell
operator|.
name|cellNumber
operator|<
literal|255
assert|;
block|}
assert|assert
name|cell
operator|.
name|cellNumber
operator|>=
literal|0
assert|;
block|}
block|}
annotation|@
name|Override
comment|// for Cell& for LevelledValue
DECL|method|getLevel
specifier|public
name|int
name|getLevel
parameter_list|()
block|{
return|return
name|cellLevel
return|;
block|}
annotation|@
name|Override
DECL|method|getShapeRel
specifier|public
name|SpatialRelation
name|getShapeRel
parameter_list|()
block|{
return|return
name|cellShapeRel
return|;
block|}
annotation|@
name|Override
DECL|method|setShapeRel
specifier|public
name|void
name|setShapeRel
parameter_list|(
name|SpatialRelation
name|rel
parameter_list|)
block|{
name|cellShapeRel
operator|=
name|rel
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isLeaf
specifier|public
name|boolean
name|isLeaf
parameter_list|()
block|{
return|return
name|cellIsLeaf
return|;
block|}
annotation|@
name|Override
DECL|method|setLeaf
specifier|public
name|void
name|setLeaf
parameter_list|()
block|{
name|cellIsLeaf
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getShape
specifier|public
name|Shape
name|getShape
parameter_list|()
block|{
name|ensureDecoded
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|getTokenBytesNoLeaf
specifier|public
name|BytesRef
name|getTokenBytesNoLeaf
parameter_list|(
name|BytesRef
name|result
parameter_list|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
condition|)
name|result
operator|=
operator|new
name|BytesRef
argument_list|()
expr_stmt|;
name|result
operator|.
name|bytes
operator|=
name|term
operator|.
name|bytes
expr_stmt|;
name|result
operator|.
name|offset
operator|=
name|term
operator|.
name|offset
expr_stmt|;
name|result
operator|.
name|length
operator|=
name|termLenByLevel
index|[
name|cellLevel
index|]
expr_stmt|;
assert|assert
name|result
operator|.
name|length
operator|<=
name|term
operator|.
name|length
assert|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|getTokenBytesWithLeaf
specifier|public
name|BytesRef
name|getTokenBytesWithLeaf
parameter_list|(
name|BytesRef
name|result
parameter_list|)
block|{
name|ensureOwnTermBytes
argument_list|()
expr_stmt|;
comment|//normally shouldn't do anything
name|result
operator|=
name|getTokenBytesNoLeaf
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLeaf
argument_list|()
condition|)
block|{
name|result
operator|.
name|bytes
index|[
name|result
operator|.
name|length
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|isPrefixOf
specifier|public
name|boolean
name|isPrefixOf
parameter_list|(
name|Cell
name|c
parameter_list|)
block|{
name|NRCell
name|otherCell
init|=
operator|(
name|NRCell
operator|)
name|c
decl_stmt|;
assert|assert
name|term
operator|!=
name|otherCell
operator|.
name|term
assert|;
comment|//trick to re-use bytesref; provided that we re-instate it
name|int
name|myLastLen
init|=
name|term
operator|.
name|length
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|termLenByLevel
index|[
name|getLevel
argument_list|()
index|]
expr_stmt|;
name|int
name|otherLastLen
init|=
name|otherCell
operator|.
name|term
operator|.
name|length
decl_stmt|;
name|otherCell
operator|.
name|term
operator|.
name|length
operator|=
name|termLenByLevel
index|[
name|otherCell
operator|.
name|getLevel
argument_list|()
index|]
expr_stmt|;
name|boolean
name|answer
init|=
name|StringHelper
operator|.
name|startsWith
argument_list|(
name|otherCell
operator|.
name|term
argument_list|,
name|term
argument_list|)
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|myLastLen
expr_stmt|;
name|otherCell
operator|.
name|term
operator|.
name|length
operator|=
name|otherLastLen
expr_stmt|;
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|compareToNoLeaf
specifier|public
name|int
name|compareToNoLeaf
parameter_list|(
name|Cell
name|fromCell
parameter_list|)
block|{
specifier|final
name|NRCell
name|nrCell
init|=
operator|(
name|NRCell
operator|)
name|fromCell
decl_stmt|;
assert|assert
name|term
operator|!=
name|nrCell
operator|.
name|term
assert|;
comment|//trick to re-use bytesref; provided that we re-instate it
name|int
name|myLastLen
init|=
name|term
operator|.
name|length
decl_stmt|;
name|int
name|otherLastLen
init|=
name|nrCell
operator|.
name|term
operator|.
name|length
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|termLenByLevel
index|[
name|getLevel
argument_list|()
index|]
expr_stmt|;
name|nrCell
operator|.
name|term
operator|.
name|length
operator|=
name|termLenByLevel
index|[
name|nrCell
operator|.
name|getLevel
argument_list|()
index|]
expr_stmt|;
name|int
name|answer
init|=
name|term
operator|.
name|compareTo
argument_list|(
name|nrCell
operator|.
name|term
argument_list|)
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|myLastLen
expr_stmt|;
name|nrCell
operator|.
name|term
operator|.
name|length
operator|=
name|otherLastLen
expr_stmt|;
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|getNextLevelCells
specifier|public
name|CellIterator
name|getNextLevelCells
parameter_list|(
name|Shape
name|shapeFilter
parameter_list|)
block|{
name|ensureDecoded
argument_list|()
expr_stmt|;
name|NRCell
name|subCell
init|=
name|cellsByLevel
index|[
name|cellLevel
operator|+
literal|1
index|]
decl_stmt|;
name|subCell
operator|.
name|initIter
argument_list|(
name|shapeFilter
argument_list|)
expr_stmt|;
return|return
name|subCell
return|;
block|}
comment|//----------- CellIterator
DECL|field|iterFilter
name|Shape
name|iterFilter
decl_stmt|;
comment|//LevelledValue or NRShape
DECL|field|iterFirstIsIntersects
name|boolean
name|iterFirstIsIntersects
decl_stmt|;
DECL|field|iterLastIsIntersects
name|boolean
name|iterLastIsIntersects
decl_stmt|;
DECL|field|iterFirstCellNumber
name|int
name|iterFirstCellNumber
decl_stmt|;
DECL|field|iterLastCellNumber
name|int
name|iterLastCellNumber
decl_stmt|;
DECL|method|initIter
specifier|private
name|void
name|initIter
parameter_list|(
name|Shape
name|filter
parameter_list|)
block|{
name|cellNumber
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|filter
operator|instanceof
name|LevelledValue
operator|&&
operator|(
operator|(
name|LevelledValue
operator|)
name|filter
operator|)
operator|.
name|getLevel
argument_list|()
operator|==
literal|0
condition|)
name|filter
operator|=
literal|null
expr_stmt|;
comment|//world means everything -- no filter
name|iterFilter
operator|=
name|filter
expr_stmt|;
name|NRCell
name|parent
init|=
name|getLVAtLevel
argument_list|(
name|getLevel
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// Initialize iter* members.
comment|//no filter means all subcells
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
block|{
name|iterFirstCellNumber
operator|=
literal|0
expr_stmt|;
name|iterFirstIsIntersects
operator|=
literal|false
expr_stmt|;
name|iterLastCellNumber
operator|=
name|getNumSubCells
argument_list|(
name|parent
argument_list|)
operator|-
literal|1
expr_stmt|;
name|iterLastIsIntersects
operator|=
literal|false
expr_stmt|;
return|return;
block|}
specifier|final
name|LevelledValue
name|minLV
decl_stmt|;
specifier|final
name|LevelledValue
name|maxLV
decl_stmt|;
specifier|final
name|int
name|lastLevelInCommon
decl_stmt|;
comment|//between minLV& maxLV
if|if
condition|(
name|filter
operator|instanceof
name|NRShape
condition|)
block|{
name|NRShape
name|nrShape
init|=
operator|(
name|NRShape
operator|)
name|iterFilter
decl_stmt|;
name|minLV
operator|=
name|nrShape
operator|.
name|getMinLV
argument_list|()
expr_stmt|;
name|maxLV
operator|=
name|nrShape
operator|.
name|getMaxLV
argument_list|()
expr_stmt|;
name|lastLevelInCommon
operator|=
name|nrShape
operator|.
name|getLastLevelInCommon
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|minLV
operator|=
operator|(
name|LevelledValue
operator|)
name|iterFilter
expr_stmt|;
name|maxLV
operator|=
name|minLV
expr_stmt|;
name|lastLevelInCommon
operator|=
name|minLV
operator|.
name|getLevel
argument_list|()
expr_stmt|;
block|}
comment|//fast path optimization that is usually true, but never first level
if|if
condition|(
name|iterFilter
operator|==
name|parent
operator|.
name|iterFilter
operator|&&
operator|(
name|getLevel
argument_list|()
operator|<=
name|lastLevelInCommon
operator|||
name|parent
operator|.
name|iterFirstCellNumber
operator|!=
name|parent
operator|.
name|iterLastCellNumber
operator|)
condition|)
block|{
comment|//TODO benchmark if this optimization pays off. We avoid two comparePrefixLV calls.
if|if
condition|(
name|parent
operator|.
name|iterFirstIsIntersects
operator|&&
name|parent
operator|.
name|cellNumber
operator|==
name|parent
operator|.
name|iterFirstCellNumber
operator|&&
name|minLV
operator|.
name|getLevel
argument_list|()
operator|>=
name|getLevel
argument_list|()
condition|)
block|{
name|iterFirstCellNumber
operator|=
name|minLV
operator|.
name|getValAtLevel
argument_list|(
name|getLevel
argument_list|()
argument_list|)
expr_stmt|;
name|iterFirstIsIntersects
operator|=
operator|(
name|minLV
operator|.
name|getLevel
argument_list|()
operator|>
name|getLevel
argument_list|()
operator|)
expr_stmt|;
block|}
else|else
block|{
name|iterFirstCellNumber
operator|=
literal|0
expr_stmt|;
name|iterFirstIsIntersects
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|.
name|iterLastIsIntersects
operator|&&
name|parent
operator|.
name|cellNumber
operator|==
name|parent
operator|.
name|iterLastCellNumber
operator|&&
name|maxLV
operator|.
name|getLevel
argument_list|()
operator|>=
name|getLevel
argument_list|()
condition|)
block|{
name|iterLastCellNumber
operator|=
name|maxLV
operator|.
name|getValAtLevel
argument_list|(
name|getLevel
argument_list|()
argument_list|)
expr_stmt|;
name|iterLastIsIntersects
operator|=
operator|(
name|maxLV
operator|.
name|getLevel
argument_list|()
operator|>
name|getLevel
argument_list|()
operator|)
expr_stmt|;
block|}
else|else
block|{
name|iterLastCellNumber
operator|=
name|getNumSubCells
argument_list|(
name|parent
argument_list|)
operator|-
literal|1
expr_stmt|;
name|iterLastIsIntersects
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|iterFirstCellNumber
operator|==
name|iterLastCellNumber
condition|)
block|{
if|if
condition|(
name|iterLastIsIntersects
condition|)
name|iterFirstIsIntersects
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|iterFirstIsIntersects
condition|)
name|iterLastIsIntersects
operator|=
literal|true
expr_stmt|;
block|}
return|return;
block|}
comment|//not common to get here, except for level 1 which always happens
name|int
name|startCmp
init|=
name|comparePrefixLV
argument_list|(
name|minLV
argument_list|,
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|startCmp
operator|>
literal|0
condition|)
block|{
comment|//start comes after this cell
name|iterFirstCellNumber
operator|=
literal|0
expr_stmt|;
name|iterFirstIsIntersects
operator|=
literal|false
expr_stmt|;
name|iterLastCellNumber
operator|=
operator|-
literal|1
expr_stmt|;
comment|//so ends early (no cells)
name|iterLastIsIntersects
operator|=
literal|false
expr_stmt|;
return|return;
block|}
name|int
name|endCmp
init|=
name|comparePrefixLV
argument_list|(
name|maxLV
argument_list|,
name|parent
argument_list|)
decl_stmt|;
comment|//compare to end cell
if|if
condition|(
name|endCmp
operator|<
literal|0
condition|)
block|{
comment|//end comes before this cell
name|iterFirstCellNumber
operator|=
literal|0
expr_stmt|;
name|iterFirstIsIntersects
operator|=
literal|false
expr_stmt|;
name|iterLastCellNumber
operator|=
operator|-
literal|1
expr_stmt|;
comment|//so ends early (no cells)
name|iterLastIsIntersects
operator|=
literal|false
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|startCmp
operator|<
literal|0
operator|||
name|minLV
operator|.
name|getLevel
argument_list|()
operator|<
name|getLevel
argument_list|()
condition|)
block|{
comment|//start comes before...
name|iterFirstCellNumber
operator|=
literal|0
expr_stmt|;
name|iterFirstIsIntersects
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|iterFirstCellNumber
operator|=
name|minLV
operator|.
name|getValAtLevel
argument_list|(
name|getLevel
argument_list|()
argument_list|)
expr_stmt|;
name|iterFirstIsIntersects
operator|=
operator|(
name|minLV
operator|.
name|getLevel
argument_list|()
operator|>
name|getLevel
argument_list|()
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|endCmp
operator|>
literal|0
operator|||
name|maxLV
operator|.
name|getLevel
argument_list|()
operator|<
name|getLevel
argument_list|()
condition|)
block|{
comment|//end comes after...
name|iterLastCellNumber
operator|=
name|getNumSubCells
argument_list|(
name|parent
argument_list|)
operator|-
literal|1
expr_stmt|;
name|iterLastIsIntersects
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|iterLastCellNumber
operator|=
name|maxLV
operator|.
name|getValAtLevel
argument_list|(
name|getLevel
argument_list|()
argument_list|)
expr_stmt|;
name|iterLastIsIntersects
operator|=
operator|(
name|maxLV
operator|.
name|getLevel
argument_list|()
operator|>
name|getLevel
argument_list|()
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|iterFirstCellNumber
operator|==
name|iterLastCellNumber
condition|)
block|{
if|if
condition|(
name|iterLastIsIntersects
condition|)
name|iterFirstIsIntersects
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|iterFirstIsIntersects
condition|)
name|iterLastIsIntersects
operator|=
literal|true
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
name|thisCell
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|nextCell
operator|!=
literal|null
condition|)
comment|//calling hasNext twice in a row
return|return
literal|true
return|;
if|if
condition|(
name|cellNumber
operator|>=
name|iterLastCellNumber
condition|)
return|return
literal|false
return|;
name|resetCellWithCellNum
argument_list|(
name|cellNumber
operator|<
name|iterFirstCellNumber
condition|?
name|iterFirstCellNumber
else|:
name|cellNumber
operator|+
literal|1
argument_list|)
expr_stmt|;
name|boolean
name|hasChildren
init|=
operator|(
name|cellNumber
operator|==
name|iterFirstCellNumber
operator|&&
name|iterFirstIsIntersects
operator|)
operator|||
operator|(
name|cellNumber
operator|==
name|iterLastCellNumber
operator|&&
name|iterLastIsIntersects
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|hasChildren
condition|)
block|{
name|setLeaf
argument_list|()
expr_stmt|;
name|setShapeRel
argument_list|(
name|SpatialRelation
operator|.
name|WITHIN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iterFirstCellNumber
operator|==
name|iterLastCellNumber
condition|)
block|{
name|setShapeRel
argument_list|(
name|SpatialRelation
operator|.
name|CONTAINS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setShapeRel
argument_list|(
name|SpatialRelation
operator|.
name|INTERSECTS
argument_list|)
expr_stmt|;
block|}
name|nextCell
operator|=
name|this
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|//TODO override nextFrom to be more efficient
comment|//----------- LevelledValue / Shape
annotation|@
name|Override
DECL|method|getValAtLevel
specifier|public
name|int
name|getValAtLevel
parameter_list|(
name|int
name|level
parameter_list|)
block|{
specifier|final
name|int
name|result
init|=
name|cellsByLevel
index|[
name|level
index|]
operator|.
name|cellNumber
decl_stmt|;
assert|assert
name|result
operator|>=
literal|0
assert|;
comment|//initialized
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|getLVAtLevel
specifier|public
name|NRCell
name|getLVAtLevel
parameter_list|(
name|int
name|level
parameter_list|)
block|{
assert|assert
name|level
operator|<=
name|cellLevel
assert|;
return|return
name|cellsByLevel
index|[
name|level
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|relate
specifier|public
name|SpatialRelation
name|relate
parameter_list|(
name|Shape
name|shape
parameter_list|)
block|{
name|ensureDecoded
argument_list|()
expr_stmt|;
if|if
condition|(
name|shape
operator|==
name|iterFilter
operator|&&
name|cellShapeRel
operator|!=
literal|null
condition|)
return|return
name|cellShapeRel
return|;
if|if
condition|(
name|shape
operator|instanceof
name|LevelledValue
condition|)
return|return
name|relate
argument_list|(
operator|(
name|LevelledValue
operator|)
name|shape
argument_list|)
return|;
if|if
condition|(
name|shape
operator|instanceof
name|NRShape
condition|)
return|return
name|relate
argument_list|(
operator|(
name|NRShape
operator|)
name|shape
argument_list|)
return|;
return|return
name|shape
operator|.
name|relate
argument_list|(
name|this
argument_list|)
operator|.
name|transpose
argument_list|()
return|;
block|}
DECL|method|relate
specifier|public
name|SpatialRelation
name|relate
parameter_list|(
name|LevelledValue
name|lv
parameter_list|)
block|{
name|ensureDecoded
argument_list|()
expr_stmt|;
name|int
name|cmp
init|=
name|comparePrefixLV
argument_list|(
name|this
argument_list|,
name|lv
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|SpatialRelation
operator|.
name|DISJOINT
return|;
if|if
condition|(
name|getLevel
argument_list|()
operator|>
name|lv
operator|.
name|getLevel
argument_list|()
condition|)
return|return
name|SpatialRelation
operator|.
name|WITHIN
return|;
comment|//or equals
return|return
name|SpatialRelation
operator|.
name|CONTAINS
return|;
comment|//no INTERSECTS; that won't happen.
block|}
DECL|method|relate
specifier|public
name|SpatialRelation
name|relate
parameter_list|(
name|NRShape
name|nrShape
parameter_list|)
block|{
name|ensureDecoded
argument_list|()
expr_stmt|;
name|int
name|startCmp
init|=
name|comparePrefixLV
argument_list|(
name|nrShape
operator|.
name|getMinLV
argument_list|()
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|startCmp
operator|>
literal|0
condition|)
block|{
comment|//start comes after this cell
return|return
name|SpatialRelation
operator|.
name|DISJOINT
return|;
block|}
name|int
name|endCmp
init|=
name|comparePrefixLV
argument_list|(
name|nrShape
operator|.
name|getMaxLV
argument_list|()
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|endCmp
operator|<
literal|0
condition|)
block|{
comment|//end comes before this cell
return|return
name|SpatialRelation
operator|.
name|DISJOINT
return|;
block|}
name|int
name|nrMinLevel
init|=
name|nrShape
operator|.
name|getMinLV
argument_list|()
operator|.
name|getLevel
argument_list|()
decl_stmt|;
name|int
name|nrMaxLevel
init|=
name|nrShape
operator|.
name|getMaxLV
argument_list|()
operator|.
name|getLevel
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|startCmp
operator|<
literal|0
operator|||
name|startCmp
operator|==
literal|0
operator|&&
name|nrMinLevel
operator|<=
name|getLevel
argument_list|()
operator|)
operator|&&
operator|(
name|endCmp
operator|>
literal|0
operator|||
name|endCmp
operator|==
literal|0
operator|&&
name|nrMaxLevel
operator|<=
name|getLevel
argument_list|()
operator|)
condition|)
return|return
name|SpatialRelation
operator|.
name|WITHIN
return|;
comment|//or equals
comment|//At this point it's Contains or Within.
if|if
condition|(
name|startCmp
operator|!=
literal|0
operator|||
name|endCmp
operator|!=
literal|0
condition|)
return|return
name|SpatialRelation
operator|.
name|INTERSECTS
return|;
comment|//if min or max Level is less, it might be on the equivalent edge.
for|for
control|(
init|;
name|nrMinLevel
operator|<
name|getLevel
argument_list|()
condition|;
name|nrMinLevel
operator|++
control|)
block|{
if|if
condition|(
name|getValAtLevel
argument_list|(
name|nrMinLevel
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|SpatialRelation
operator|.
name|INTERSECTS
return|;
block|}
for|for
control|(
init|;
name|nrMaxLevel
operator|<
name|getLevel
argument_list|()
condition|;
name|nrMaxLevel
operator|++
control|)
block|{
if|if
condition|(
name|getValAtLevel
argument_list|(
name|nrMaxLevel
operator|+
literal|1
argument_list|)
operator|!=
name|getNumSubCells
argument_list|(
name|getLVAtLevel
argument_list|(
name|nrMaxLevel
argument_list|)
argument_list|)
operator|-
literal|1
condition|)
return|return
name|SpatialRelation
operator|.
name|INTERSECTS
return|;
block|}
return|return
name|SpatialRelation
operator|.
name|CONTAINS
return|;
block|}
annotation|@
name|Override
DECL|method|getBoundingBox
specifier|public
name|Rectangle
name|getBoundingBox
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|hasArea
specifier|public
name|boolean
name|hasArea
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|getArea
specifier|public
name|double
name|getArea
parameter_list|(
name|SpatialContext
name|ctx
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getCenter
specifier|public
name|Point
name|getCenter
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getBuffered
specifier|public
name|Shape
name|getBuffered
parameter_list|(
name|double
name|distance
parameter_list|,
name|SpatialContext
name|ctx
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|//------- Object
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|NRCell
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|==
name|obj
condition|)
return|return
literal|true
return|;
name|NRCell
name|nrCell
init|=
operator|(
name|NRCell
operator|)
name|obj
decl_stmt|;
assert|assert
name|term
operator|!=
name|nrCell
operator|.
name|term
assert|;
if|if
condition|(
name|getLevel
argument_list|()
operator|!=
name|nrCell
operator|.
name|getLevel
argument_list|()
condition|)
return|return
literal|false
return|;
comment|//trick to re-use bytesref; provided that we re-instate it
name|int
name|myLastLen
init|=
name|term
operator|.
name|length
decl_stmt|;
name|int
name|otherLastLen
init|=
name|nrCell
operator|.
name|term
operator|.
name|length
decl_stmt|;
name|boolean
name|answer
init|=
name|getTokenBytesNoLeaf
argument_list|(
name|term
argument_list|)
operator|.
name|equals
argument_list|(
name|nrCell
operator|.
name|getTokenBytesNoLeaf
argument_list|(
name|nrCell
operator|.
name|term
argument_list|)
argument_list|)
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|myLastLen
expr_stmt|;
name|nrCell
operator|.
name|term
operator|.
name|length
operator|=
name|otherLastLen
expr_stmt|;
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|//trick to re-use bytesref; provided that we re-instate it
name|int
name|myLastLen
init|=
name|term
operator|.
name|length
decl_stmt|;
name|int
name|result
init|=
name|getTokenBytesNoLeaf
argument_list|(
name|term
argument_list|)
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|myLastLen
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|ensureDecoded
argument_list|()
expr_stmt|;
name|String
name|str
init|=
name|NumberRangePrefixTree
operator|.
name|this
operator|.
name|toStringLV
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|isLeaf
argument_list|()
condition|)
name|str
operator|+=
literal|"â¢"
expr_stmt|;
comment|//bullet (won't be confused with textual representation)
return|return
name|str
return|;
block|}
comment|/** Configure your IDE to use this. */
DECL|method|toStringDebug
specifier|public
name|String
name|toStringDebug
parameter_list|()
block|{
name|String
name|pretty
init|=
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|getLevel
argument_list|()
operator|==
literal|0
condition|)
return|return
name|pretty
return|;
comment|//now prefix it by an array of integers of the cell levels
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|1
init|;
name|level
operator|<=
name|getLevel
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|level
operator|!=
literal|1
condition|)
name|buf
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|getLVAtLevel
argument_list|(
name|level
argument_list|)
operator|.
name|cellNumber
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"] "
argument_list|)
operator|.
name|append
argument_list|(
name|pretty
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|// END OF NRCell
block|}
end_class
end_unit
