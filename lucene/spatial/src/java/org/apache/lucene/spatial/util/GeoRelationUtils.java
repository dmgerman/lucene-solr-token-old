begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.spatial.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|util
package|;
end_package
begin_comment
comment|/**  * Reusable geo-relation utility methods  */
end_comment
begin_class
DECL|class|GeoRelationUtils
specifier|public
class|class
name|GeoRelationUtils
block|{
comment|// No instance:
DECL|method|GeoRelationUtils
specifier|private
name|GeoRelationUtils
parameter_list|()
block|{   }
comment|/**    * Determine if a bbox (defined by minLat, maxLat, minLon, maxLon) contains the provided point (defined by lat, lon)    * NOTE: this is a basic method that does not handle dateline or pole crossing. Unwrapping must be done before    * calling this method.    */
DECL|method|pointInRectPrecise
specifier|public
specifier|static
name|boolean
name|pointInRectPrecise
parameter_list|(
specifier|final
name|double
name|lat
parameter_list|,
specifier|final
name|double
name|lon
parameter_list|,
specifier|final
name|double
name|minLat
parameter_list|,
specifier|final
name|double
name|maxLat
parameter_list|,
specifier|final
name|double
name|minLon
parameter_list|,
specifier|final
name|double
name|maxLon
parameter_list|)
block|{
return|return
name|lat
operator|>=
name|minLat
operator|&&
name|lat
operator|<=
name|maxLat
operator|&&
name|lon
operator|>=
name|minLon
operator|&&
name|lon
operator|<=
name|maxLon
return|;
block|}
comment|/**    * simple even-odd point in polygon computation    *    1.  Determine if point is contained in the longitudinal range    *    2.  Determine whether point crosses the edge by computing the latitudinal delta    *        between the end-point of a parallel vector (originating at the point) and the    *        y-component of the edge sink    *    * NOTE: Requires polygon point (x,y) order either clockwise or counter-clockwise    */
DECL|method|pointInPolygon
specifier|public
specifier|static
name|boolean
name|pointInPolygon
parameter_list|(
name|double
index|[]
name|polyLats
parameter_list|,
name|double
index|[]
name|polyLons
parameter_list|,
name|double
name|lat
parameter_list|,
name|double
name|lon
parameter_list|)
block|{
assert|assert
name|polyLats
operator|.
name|length
operator|==
name|polyLons
operator|.
name|length
assert|;
name|boolean
name|inPoly
init|=
literal|false
decl_stmt|;
comment|/**      * Note: This is using a euclidean coordinate system which could result in      * upwards of 110KM error at the equator.      * TODO convert coordinates to cylindrical projection (e.g. mercator)      */
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|polyLats
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|polyLons
index|[
name|i
index|]
operator|<=
name|lon
operator|&&
name|polyLons
index|[
name|i
operator|-
literal|1
index|]
operator|>=
name|lon
operator|||
name|polyLons
index|[
name|i
operator|-
literal|1
index|]
operator|<=
name|lon
operator|&&
name|polyLons
index|[
name|i
index|]
operator|>=
name|lon
condition|)
block|{
if|if
condition|(
name|polyLats
index|[
name|i
index|]
operator|+
operator|(
name|lon
operator|-
name|polyLons
index|[
name|i
index|]
operator|)
operator|/
operator|(
name|polyLons
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|polyLons
index|[
name|i
index|]
operator|)
operator|*
operator|(
name|polyLats
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|polyLats
index|[
name|i
index|]
operator|)
operator|<=
name|lat
condition|)
block|{
name|inPoly
operator|=
operator|!
name|inPoly
expr_stmt|;
block|}
block|}
block|}
return|return
name|inPoly
return|;
block|}
comment|/////////////////////////
comment|// Rectangle relations
comment|/////////////////////////
comment|/**    * Computes whether two rectangles are disjoint    */
DECL|method|rectDisjoint
specifier|private
specifier|static
name|boolean
name|rectDisjoint
parameter_list|(
specifier|final
name|double
name|aMinLat
parameter_list|,
specifier|final
name|double
name|aMaxLat
parameter_list|,
specifier|final
name|double
name|aMinLon
parameter_list|,
specifier|final
name|double
name|aMaxLon
parameter_list|,
specifier|final
name|double
name|bMinLat
parameter_list|,
specifier|final
name|double
name|bMaxLat
parameter_list|,
specifier|final
name|double
name|bMinLon
parameter_list|,
specifier|final
name|double
name|bMaxLon
parameter_list|)
block|{
return|return
operator|(
name|aMaxLon
argument_list|<
name|bMinLon
operator|||
name|aMinLon
argument_list|>
name|bMaxLon
operator|||
name|aMaxLat
argument_list|<
name|bMinLat
operator|||
name|aMinLat
argument_list|>
name|bMaxLat
operator|)
return|;
block|}
comment|/**    * Computes whether the first (a) rectangle is wholly within another (b) rectangle (shared boundaries allowed)    */
DECL|method|rectWithin
specifier|public
specifier|static
name|boolean
name|rectWithin
parameter_list|(
specifier|final
name|double
name|aMinLat
parameter_list|,
specifier|final
name|double
name|aMaxLat
parameter_list|,
specifier|final
name|double
name|aMinLon
parameter_list|,
specifier|final
name|double
name|aMaxLon
parameter_list|,
specifier|final
name|double
name|bMinLat
parameter_list|,
specifier|final
name|double
name|bMaxLat
parameter_list|,
specifier|final
name|double
name|bMinLon
parameter_list|,
specifier|final
name|double
name|bMaxLon
parameter_list|)
block|{
return|return
operator|!
operator|(
name|aMinLon
argument_list|<
name|bMinLon
operator|||
name|aMinLat
argument_list|<
name|bMinLat
operator|||
name|aMaxLon
argument_list|>
name|bMaxLon
operator|||
name|aMaxLat
argument_list|>
name|bMaxLat
operator|)
return|;
block|}
comment|/**    * Computes whether two rectangles cross    */
DECL|method|rectCrosses
specifier|public
specifier|static
name|boolean
name|rectCrosses
parameter_list|(
specifier|final
name|double
name|aMinLat
parameter_list|,
specifier|final
name|double
name|aMaxLat
parameter_list|,
specifier|final
name|double
name|aMinLon
parameter_list|,
specifier|final
name|double
name|aMaxLon
parameter_list|,
specifier|final
name|double
name|bMinLat
parameter_list|,
specifier|final
name|double
name|bMaxLat
parameter_list|,
specifier|final
name|double
name|bMinLon
parameter_list|,
specifier|final
name|double
name|bMaxLon
parameter_list|)
block|{
return|return
operator|!
operator|(
name|rectDisjoint
argument_list|(
name|aMinLat
argument_list|,
name|aMaxLat
argument_list|,
name|aMinLon
argument_list|,
name|aMaxLon
argument_list|,
name|bMinLat
argument_list|,
name|bMaxLat
argument_list|,
name|bMinLon
argument_list|,
name|bMaxLon
argument_list|)
operator|||
name|rectWithin
argument_list|(
name|aMinLat
argument_list|,
name|aMaxLat
argument_list|,
name|aMinLon
argument_list|,
name|aMaxLon
argument_list|,
name|bMinLat
argument_list|,
name|bMaxLat
argument_list|,
name|bMinLon
argument_list|,
name|bMaxLon
argument_list|)
operator|)
return|;
block|}
comment|/**    * Computes whether a rectangle intersects another rectangle (crosses, within, touching, etc)    */
DECL|method|rectIntersects
specifier|public
specifier|static
name|boolean
name|rectIntersects
parameter_list|(
specifier|final
name|double
name|aMinLat
parameter_list|,
specifier|final
name|double
name|aMaxLat
parameter_list|,
specifier|final
name|double
name|aMinLon
parameter_list|,
specifier|final
name|double
name|aMaxLon
parameter_list|,
specifier|final
name|double
name|bMinLat
parameter_list|,
specifier|final
name|double
name|bMaxLat
parameter_list|,
specifier|final
name|double
name|bMinLon
parameter_list|,
specifier|final
name|double
name|bMaxLon
parameter_list|)
block|{
return|return
operator|!
operator|(
operator|(
name|aMaxLon
argument_list|<
name|bMinLon
operator|||
name|aMinLon
argument_list|>
name|bMaxLon
operator|||
name|aMaxLat
argument_list|<
name|bMinLat
operator|||
name|aMinLat
argument_list|>
name|bMaxLat
operator|)
operator|)
return|;
block|}
comment|/////////////////////////
comment|// Polygon relations
comment|/////////////////////////
comment|/**    * Convenience method for accurately computing whether a rectangle crosses a poly    */
DECL|method|rectCrossesPolyPrecise
specifier|public
specifier|static
name|boolean
name|rectCrossesPolyPrecise
parameter_list|(
specifier|final
name|double
name|rMinLat
parameter_list|,
specifier|final
name|double
name|rMaxLat
parameter_list|,
specifier|final
name|double
name|rMinLon
parameter_list|,
specifier|final
name|double
name|rMaxLon
parameter_list|,
specifier|final
name|double
index|[]
name|shapeLat
parameter_list|,
specifier|final
name|double
index|[]
name|shapeLon
parameter_list|,
specifier|final
name|double
name|sMinLat
parameter_list|,
specifier|final
name|double
name|sMaxLat
parameter_list|,
specifier|final
name|double
name|sMinLon
parameter_list|,
specifier|final
name|double
name|sMaxLon
parameter_list|)
block|{
comment|// short-circuit: if the bounding boxes are disjoint then the shape does not cross
if|if
condition|(
name|rectDisjoint
argument_list|(
name|rMinLat
argument_list|,
name|rMaxLat
argument_list|,
name|rMinLon
argument_list|,
name|rMaxLon
argument_list|,
name|sMinLat
argument_list|,
name|sMaxLat
argument_list|,
name|sMinLon
argument_list|,
name|sMaxLon
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|rectCrossesPoly
argument_list|(
name|rMinLat
argument_list|,
name|rMaxLat
argument_list|,
name|rMinLon
argument_list|,
name|rMaxLon
argument_list|,
name|shapeLat
argument_list|,
name|shapeLon
argument_list|)
return|;
block|}
comment|/**    * Compute whether a rectangle crosses a shape. (touching not allowed) Includes a flag for approximating the    * relation.    */
DECL|method|rectCrossesPolyApprox
specifier|public
specifier|static
name|boolean
name|rectCrossesPolyApprox
parameter_list|(
specifier|final
name|double
name|rMinLat
parameter_list|,
specifier|final
name|double
name|rMaxLat
parameter_list|,
specifier|final
name|double
name|rMinLon
parameter_list|,
specifier|final
name|double
name|rMaxLon
parameter_list|,
specifier|final
name|double
index|[]
name|shapeLat
parameter_list|,
specifier|final
name|double
index|[]
name|shapeLon
parameter_list|,
specifier|final
name|double
name|sMinLat
parameter_list|,
specifier|final
name|double
name|sMaxLat
parameter_list|,
specifier|final
name|double
name|sMinLon
parameter_list|,
specifier|final
name|double
name|sMaxLon
parameter_list|)
block|{
comment|// short-circuit: if the bounding boxes are disjoint then the shape does not cross
if|if
condition|(
name|rectDisjoint
argument_list|(
name|rMinLat
argument_list|,
name|rMaxLat
argument_list|,
name|rMinLon
argument_list|,
name|rMaxLon
argument_list|,
name|sMinLat
argument_list|,
name|sMaxLat
argument_list|,
name|sMinLon
argument_list|,
name|sMaxLon
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|polyLength
init|=
name|shapeLon
operator|.
name|length
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|short
name|p
init|=
literal|0
init|;
name|p
operator|<
name|polyLength
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|lineCrossesRect
argument_list|(
name|shapeLat
index|[
name|p
index|]
argument_list|,
name|shapeLon
index|[
name|p
index|]
argument_list|,
name|shapeLat
index|[
name|p
operator|+
literal|1
index|]
argument_list|,
name|shapeLon
index|[
name|p
operator|+
literal|1
index|]
argument_list|,
name|rMinLat
argument_list|,
name|rMaxLat
argument_list|,
name|rMinLon
argument_list|,
name|rMaxLon
argument_list|)
operator|==
literal|true
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Accurately compute (within restrictions of cartesian decimal degrees) whether a rectangle crosses a polygon    */
DECL|method|rectCrossesPoly
specifier|private
specifier|static
name|boolean
name|rectCrossesPoly
parameter_list|(
specifier|final
name|double
name|rMinLat
parameter_list|,
specifier|final
name|double
name|rMaxLat
parameter_list|,
specifier|final
name|double
name|rMinLon
parameter_list|,
specifier|final
name|double
name|rMaxLon
parameter_list|,
specifier|final
name|double
index|[]
name|shapeLats
parameter_list|,
specifier|final
name|double
index|[]
name|shapeLons
parameter_list|)
block|{
specifier|final
name|double
index|[]
index|[]
name|bbox
init|=
operator|new
name|double
index|[]
index|[]
block|{
block|{
name|rMinLon
block|,
name|rMinLat
block|}
block|,
block|{
name|rMaxLon
block|,
name|rMinLat
block|}
block|,
block|{
name|rMaxLon
block|,
name|rMaxLat
block|}
block|,
block|{
name|rMinLon
block|,
name|rMaxLat
block|}
block|,
block|{
name|rMinLon
block|,
name|rMinLat
block|}
block|}
decl_stmt|;
specifier|final
name|int
name|polyLength
init|=
name|shapeLons
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|double
name|d
decl_stmt|,
name|s
decl_stmt|,
name|t
decl_stmt|,
name|a1
decl_stmt|,
name|b1
decl_stmt|,
name|c1
decl_stmt|,
name|a2
decl_stmt|,
name|b2
decl_stmt|,
name|c2
decl_stmt|;
name|double
name|x00
decl_stmt|,
name|y00
decl_stmt|,
name|x01
decl_stmt|,
name|y01
decl_stmt|,
name|x10
decl_stmt|,
name|y10
decl_stmt|,
name|x11
decl_stmt|,
name|y11
decl_stmt|;
comment|// computes the intersection point between each bbox edge and the polygon edge
for|for
control|(
name|short
name|b
init|=
literal|0
init|;
name|b
operator|<
literal|4
condition|;
operator|++
name|b
control|)
block|{
name|a1
operator|=
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|1
index|]
operator|-
name|bbox
index|[
name|b
index|]
index|[
literal|1
index|]
expr_stmt|;
name|b1
operator|=
name|bbox
index|[
name|b
index|]
index|[
literal|0
index|]
operator|-
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|c1
operator|=
name|a1
operator|*
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|b1
operator|*
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|int
name|p
init|=
literal|0
init|;
name|p
operator|<
name|polyLength
condition|;
operator|++
name|p
control|)
block|{
name|a2
operator|=
name|shapeLats
index|[
name|p
operator|+
literal|1
index|]
operator|-
name|shapeLats
index|[
name|p
index|]
expr_stmt|;
name|b2
operator|=
name|shapeLons
index|[
name|p
index|]
operator|-
name|shapeLons
index|[
name|p
operator|+
literal|1
index|]
expr_stmt|;
comment|// compute determinant
name|d
operator|=
name|a1
operator|*
name|b2
operator|-
name|a2
operator|*
name|b1
expr_stmt|;
if|if
condition|(
name|d
operator|!=
literal|0
condition|)
block|{
comment|// lines are not parallel, check intersecting points
name|c2
operator|=
name|a2
operator|*
name|shapeLons
index|[
name|p
operator|+
literal|1
index|]
operator|+
name|b2
operator|*
name|shapeLats
index|[
name|p
operator|+
literal|1
index|]
expr_stmt|;
name|s
operator|=
operator|(
literal|1
operator|/
name|d
operator|)
operator|*
operator|(
name|b2
operator|*
name|c1
operator|-
name|b1
operator|*
name|c2
operator|)
expr_stmt|;
name|t
operator|=
operator|(
literal|1
operator|/
name|d
operator|)
operator|*
operator|(
name|a1
operator|*
name|c2
operator|-
name|a2
operator|*
name|c1
operator|)
expr_stmt|;
name|x00
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|bbox
index|[
name|b
index|]
index|[
literal|0
index|]
argument_list|,
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|-
name|GeoEncodingUtils
operator|.
name|TOLERANCE
expr_stmt|;
name|x01
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|bbox
index|[
name|b
index|]
index|[
literal|0
index|]
argument_list|,
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|+
name|GeoEncodingUtils
operator|.
name|TOLERANCE
expr_stmt|;
name|y00
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|bbox
index|[
name|b
index|]
index|[
literal|1
index|]
argument_list|,
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|-
name|GeoEncodingUtils
operator|.
name|TOLERANCE
expr_stmt|;
name|y01
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|bbox
index|[
name|b
index|]
index|[
literal|1
index|]
argument_list|,
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|+
name|GeoEncodingUtils
operator|.
name|TOLERANCE
expr_stmt|;
name|x10
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|shapeLons
index|[
name|p
index|]
argument_list|,
name|shapeLons
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
operator|-
name|GeoEncodingUtils
operator|.
name|TOLERANCE
expr_stmt|;
name|x11
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|shapeLons
index|[
name|p
index|]
argument_list|,
name|shapeLons
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
operator|+
name|GeoEncodingUtils
operator|.
name|TOLERANCE
expr_stmt|;
name|y10
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|shapeLats
index|[
name|p
index|]
argument_list|,
name|shapeLats
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
operator|-
name|GeoEncodingUtils
operator|.
name|TOLERANCE
expr_stmt|;
name|y11
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|shapeLats
index|[
name|p
index|]
argument_list|,
name|shapeLats
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
operator|+
name|GeoEncodingUtils
operator|.
name|TOLERANCE
expr_stmt|;
comment|// check whether the intersection point is touching one of the line segments
name|boolean
name|touching
init|=
operator|(
operator|(
name|x00
operator|==
name|s
operator|&&
name|y00
operator|==
name|t
operator|)
operator|||
operator|(
name|x01
operator|==
name|s
operator|&&
name|y01
operator|==
name|t
operator|)
operator|)
operator|||
operator|(
operator|(
name|x10
operator|==
name|s
operator|&&
name|y10
operator|==
name|t
operator|)
operator|||
operator|(
name|x11
operator|==
name|s
operator|&&
name|y11
operator|==
name|t
operator|)
operator|)
decl_stmt|;
comment|// if line segments are not touching and the intersection point is within the range of either segment
if|if
condition|(
operator|!
operator|(
name|touching
operator|||
name|x00
operator|>
name|s
operator|||
name|x01
argument_list|<
name|s
operator|||
name|y00
argument_list|>
name|t
operator|||
name|y01
argument_list|<
name|t
operator|||
name|x10
argument_list|>
name|s
operator|||
name|x11
argument_list|<
name|s
operator|||
name|y10
argument_list|>
name|t
operator|||
name|y11
operator|<
name|t
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
comment|// for each poly edge
block|}
comment|// for each bbox edge
return|return
literal|false
return|;
block|}
DECL|method|lineCrossesRect
specifier|private
specifier|static
name|boolean
name|lineCrossesRect
parameter_list|(
name|double
name|aLat1
parameter_list|,
name|double
name|aLon1
parameter_list|,
name|double
name|aLat2
parameter_list|,
name|double
name|aLon2
parameter_list|,
specifier|final
name|double
name|rMinLat
parameter_list|,
specifier|final
name|double
name|rMaxLat
parameter_list|,
specifier|final
name|double
name|rMinLon
parameter_list|,
specifier|final
name|double
name|rMaxLon
parameter_list|)
block|{
comment|// short-circuit: if one point inside rect, other outside
if|if
condition|(
name|pointInRectPrecise
argument_list|(
name|aLat1
argument_list|,
name|aLon1
argument_list|,
name|rMinLat
argument_list|,
name|rMaxLat
argument_list|,
name|rMinLon
argument_list|,
name|rMaxLon
argument_list|)
condition|)
block|{
if|if
condition|(
name|pointInRectPrecise
argument_list|(
name|aLat2
argument_list|,
name|aLon2
argument_list|,
name|rMinLat
argument_list|,
name|rMaxLat
argument_list|,
name|rMinLon
argument_list|,
name|rMaxLon
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|pointInRectPrecise
argument_list|(
name|aLat2
argument_list|,
name|aLon2
argument_list|,
name|rMinLat
argument_list|,
name|rMaxLat
argument_list|,
name|rMinLon
argument_list|,
name|rMaxLon
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|lineCrossesLine
argument_list|(
name|aLat1
argument_list|,
name|aLon1
argument_list|,
name|aLat2
argument_list|,
name|aLon2
argument_list|,
name|rMinLat
argument_list|,
name|rMinLon
argument_list|,
name|rMaxLat
argument_list|,
name|rMaxLon
argument_list|)
operator|||
name|lineCrossesLine
argument_list|(
name|aLat1
argument_list|,
name|aLon1
argument_list|,
name|aLat2
argument_list|,
name|aLon2
argument_list|,
name|rMaxLat
argument_list|,
name|rMinLon
argument_list|,
name|rMinLat
argument_list|,
name|rMaxLon
argument_list|)
return|;
block|}
DECL|method|lineCrossesLine
specifier|private
specifier|static
name|boolean
name|lineCrossesLine
parameter_list|(
specifier|final
name|double
name|aLat1
parameter_list|,
specifier|final
name|double
name|aLon1
parameter_list|,
specifier|final
name|double
name|aLat2
parameter_list|,
specifier|final
name|double
name|aLon2
parameter_list|,
specifier|final
name|double
name|bLat1
parameter_list|,
specifier|final
name|double
name|bLon1
parameter_list|,
specifier|final
name|double
name|bLat2
parameter_list|,
specifier|final
name|double
name|bLon2
parameter_list|)
block|{
comment|// determine if three points are ccw (right-hand rule) by computing the determinate
specifier|final
name|double
name|aX2X1d
init|=
name|aLon2
operator|-
name|aLon1
decl_stmt|;
specifier|final
name|double
name|aY2Y1d
init|=
name|aLat2
operator|-
name|aLat1
decl_stmt|;
specifier|final
name|double
name|bX2X1d
init|=
name|bLon2
operator|-
name|bLon1
decl_stmt|;
specifier|final
name|double
name|bY2Y1d
init|=
name|bLat2
operator|-
name|bLat1
decl_stmt|;
specifier|final
name|double
name|t1B
init|=
name|aX2X1d
operator|*
operator|(
name|bLat2
operator|-
name|aLat1
operator|)
operator|-
name|aY2Y1d
operator|*
operator|(
name|bLon2
operator|-
name|aLon1
operator|)
decl_stmt|;
specifier|final
name|double
name|test1
init|=
operator|(
name|aX2X1d
operator|*
operator|(
name|bLat1
operator|-
name|aLat1
operator|)
operator|-
name|aY2Y1d
operator|*
operator|(
name|bLon1
operator|-
name|aLon1
operator|)
operator|)
operator|*
name|t1B
decl_stmt|;
specifier|final
name|double
name|t2B
init|=
name|bX2X1d
operator|*
operator|(
name|aLat2
operator|-
name|bLat1
operator|)
operator|-
name|bY2Y1d
operator|*
operator|(
name|aLon2
operator|-
name|bLon1
operator|)
decl_stmt|;
specifier|final
name|double
name|test2
init|=
operator|(
name|bX2X1d
operator|*
operator|(
name|aLat1
operator|-
name|bLat1
operator|)
operator|-
name|bY2Y1d
operator|*
operator|(
name|aLon1
operator|-
name|bLon1
operator|)
operator|)
operator|*
name|t2B
decl_stmt|;
if|if
condition|(
name|test1
operator|<
literal|0
operator|&&
name|test2
operator|<
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|test1
operator|==
literal|0
operator|||
name|test2
operator|==
literal|0
condition|)
block|{
comment|// vertically collinear
if|if
condition|(
name|aLon1
operator|==
name|aLon2
operator|||
name|bLon1
operator|==
name|bLon2
condition|)
block|{
specifier|final
name|double
name|minAy
init|=
name|Math
operator|.
name|min
argument_list|(
name|aLat1
argument_list|,
name|aLat2
argument_list|)
decl_stmt|;
specifier|final
name|double
name|maxAy
init|=
name|Math
operator|.
name|max
argument_list|(
name|aLat1
argument_list|,
name|aLat2
argument_list|)
decl_stmt|;
specifier|final
name|double
name|minBy
init|=
name|Math
operator|.
name|min
argument_list|(
name|bLat1
argument_list|,
name|bLat2
argument_list|)
decl_stmt|;
specifier|final
name|double
name|maxBy
init|=
name|Math
operator|.
name|max
argument_list|(
name|bLat1
argument_list|,
name|bLat2
argument_list|)
decl_stmt|;
return|return
operator|!
operator|(
name|minBy
operator|>=
name|maxAy
operator|||
name|maxBy
operator|<=
name|minAy
operator|)
return|;
block|}
comment|// horizontally collinear
specifier|final
name|double
name|minAx
init|=
name|Math
operator|.
name|min
argument_list|(
name|aLon1
argument_list|,
name|aLon2
argument_list|)
decl_stmt|;
specifier|final
name|double
name|maxAx
init|=
name|Math
operator|.
name|max
argument_list|(
name|aLon1
argument_list|,
name|aLon2
argument_list|)
decl_stmt|;
specifier|final
name|double
name|minBx
init|=
name|Math
operator|.
name|min
argument_list|(
name|bLon1
argument_list|,
name|bLon2
argument_list|)
decl_stmt|;
specifier|final
name|double
name|maxBx
init|=
name|Math
operator|.
name|max
argument_list|(
name|bLon1
argument_list|,
name|bLon2
argument_list|)
decl_stmt|;
return|return
operator|!
operator|(
name|minBx
operator|>=
name|maxAx
operator|||
name|maxBx
operator|<=
name|minAx
operator|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Computes whether a rectangle is within a polygon (shared boundaries not allowed) with more rigor than the    * {@link GeoRelationUtils#rectWithinPolyApprox} counterpart    */
DECL|method|rectWithinPolyPrecise
specifier|public
specifier|static
name|boolean
name|rectWithinPolyPrecise
parameter_list|(
specifier|final
name|double
name|rMinLat
parameter_list|,
specifier|final
name|double
name|rMaxLat
parameter_list|,
specifier|final
name|double
name|rMinLon
parameter_list|,
specifier|final
name|double
name|rMaxLon
parameter_list|,
specifier|final
name|double
index|[]
name|shapeLats
parameter_list|,
specifier|final
name|double
index|[]
name|shapeLons
parameter_list|,
specifier|final
name|double
name|sMinLat
parameter_list|,
specifier|final
name|double
name|sMaxLat
parameter_list|,
specifier|final
name|double
name|sMinLon
parameter_list|,
specifier|final
name|double
name|sMaxLon
parameter_list|)
block|{
comment|// check if rectangle crosses poly (to handle concave/pacman polys), then check that all 4 corners
comment|// are contained
return|return
operator|!
operator|(
name|rectCrossesPolyPrecise
argument_list|(
name|rMinLat
argument_list|,
name|rMaxLat
argument_list|,
name|rMinLon
argument_list|,
name|rMaxLon
argument_list|,
name|shapeLats
argument_list|,
name|shapeLons
argument_list|,
name|sMinLat
argument_list|,
name|sMaxLat
argument_list|,
name|sMinLon
argument_list|,
name|sMaxLon
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeLats
argument_list|,
name|shapeLons
argument_list|,
name|rMinLat
argument_list|,
name|rMinLon
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeLats
argument_list|,
name|shapeLons
argument_list|,
name|rMinLat
argument_list|,
name|rMaxLon
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeLats
argument_list|,
name|shapeLons
argument_list|,
name|rMaxLat
argument_list|,
name|rMaxLon
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeLats
argument_list|,
name|shapeLons
argument_list|,
name|rMaxLat
argument_list|,
name|rMinLon
argument_list|)
operator|)
return|;
block|}
comment|/**    * Computes whether a rectangle is within a given polygon (shared boundaries allowed)    */
DECL|method|rectWithinPolyApprox
specifier|public
specifier|static
name|boolean
name|rectWithinPolyApprox
parameter_list|(
specifier|final
name|double
name|rMinLat
parameter_list|,
specifier|final
name|double
name|rMaxLat
parameter_list|,
specifier|final
name|double
name|rMinLon
parameter_list|,
specifier|final
name|double
name|rMaxLon
parameter_list|,
specifier|final
name|double
index|[]
name|shapeLats
parameter_list|,
specifier|final
name|double
index|[]
name|shapeLons
parameter_list|,
specifier|final
name|double
name|sMinLat
parameter_list|,
specifier|final
name|double
name|sMaxLat
parameter_list|,
specifier|final
name|double
name|sMinLon
parameter_list|,
specifier|final
name|double
name|sMaxLon
parameter_list|)
block|{
comment|// approximation: check if rectangle crosses poly (to handle concave/pacman polys), then check one of the corners
comment|// are contained
comment|// short-cut: if bounding boxes cross, rect is not within
if|if
condition|(
name|rectCrosses
argument_list|(
name|rMinLat
argument_list|,
name|rMaxLat
argument_list|,
name|rMinLon
argument_list|,
name|rMaxLon
argument_list|,
name|sMinLat
argument_list|,
name|sMaxLat
argument_list|,
name|sMinLon
argument_list|,
name|sMaxLon
argument_list|)
operator|==
literal|true
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|!
operator|(
name|rectCrossesPolyApprox
argument_list|(
name|rMinLat
argument_list|,
name|rMaxLat
argument_list|,
name|rMinLon
argument_list|,
name|rMaxLon
argument_list|,
name|shapeLats
argument_list|,
name|shapeLons
argument_list|,
name|sMinLat
argument_list|,
name|sMaxLat
argument_list|,
name|sMinLon
argument_list|,
name|sMaxLon
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeLats
argument_list|,
name|shapeLons
argument_list|,
name|rMinLat
argument_list|,
name|rMinLon
argument_list|)
operator|)
return|;
block|}
block|}
end_class
end_unit
