begin_unit
begin_package
DECL|package|org.apache.lucene.spatial.spatial4j.geo3d
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|spatial4j
operator|.
name|geo3d
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/** We know about three kinds of planes.  First kind: general plain through two points and origin * Second kind: horizontal plane at specified height.  Third kind: vertical plane with specified x and y value, through origin. */
end_comment
begin_class
DECL|class|Plane
specifier|public
class|class
name|Plane
extends|extends
name|Vector
block|{
DECL|field|NO_POINTS
specifier|protected
specifier|final
specifier|static
name|GeoPoint
index|[]
name|NO_POINTS
init|=
operator|new
name|GeoPoint
index|[
literal|0
index|]
decl_stmt|;
DECL|field|NO_BOUNDS
specifier|protected
specifier|final
specifier|static
name|Membership
index|[]
name|NO_BOUNDS
init|=
operator|new
name|Membership
index|[
literal|0
index|]
decl_stmt|;
DECL|field|D
specifier|public
specifier|final
name|double
name|D
decl_stmt|;
comment|/** Construct a plane through two points and origin.      *@param A is the first point (origin based).      *@param B is the second point (origin based).      */
DECL|method|Plane
specifier|public
name|Plane
parameter_list|(
specifier|final
name|Vector
name|A
parameter_list|,
specifier|final
name|Vector
name|B
parameter_list|)
block|{
name|super
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
expr_stmt|;
name|D
operator|=
literal|0.0
expr_stmt|;
block|}
comment|/** Construct a horizontal plane at a specified Z.      *@param height is the specified Z coordinate.      */
DECL|method|Plane
specifier|public
name|Plane
parameter_list|(
specifier|final
name|double
name|height
parameter_list|)
block|{
name|super
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|D
operator|=
operator|-
name|height
expr_stmt|;
block|}
comment|/** Construct a vertical plane through a specified      * x, y and origin.      *@param x is the specified x value.      *@param y is the specified y value.      */
DECL|method|Plane
specifier|public
name|Plane
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|)
block|{
name|super
argument_list|(
name|y
argument_list|,
operator|-
name|x
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|D
operator|=
literal|0.0
expr_stmt|;
block|}
comment|/** Construct a plane with a specific vector, and D offset      * from origin.      *@param D is the D offset from the origin.      */
DECL|method|Plane
specifier|public
name|Plane
parameter_list|(
specifier|final
name|Vector
name|v
parameter_list|,
specifier|final
name|double
name|D
parameter_list|)
block|{
name|super
argument_list|(
name|v
operator|.
name|x
argument_list|,
name|v
operator|.
name|y
argument_list|,
name|v
operator|.
name|z
argument_list|)
expr_stmt|;
name|this
operator|.
name|D
operator|=
name|D
expr_stmt|;
block|}
comment|/** Evaluate the plane equation for a given point, as represented      * by a vector.      *@param v is the vector.      *@return the result of the evaluation.      */
DECL|method|evaluate
specifier|public
name|double
name|evaluate
parameter_list|(
specifier|final
name|Vector
name|v
parameter_list|)
block|{
return|return
name|super
operator|.
name|evaluate
argument_list|(
name|v
argument_list|)
operator|+
name|D
return|;
block|}
comment|/** Build a normalized plane, so that the vector is normalized.      *@return the normalized plane object, or null if the plane is indeterminate.      */
DECL|method|normalize
specifier|public
name|Plane
name|normalize
parameter_list|()
block|{
name|Vector
name|normVect
init|=
name|super
operator|.
name|normalize
argument_list|()
decl_stmt|;
if|if
condition|(
name|normVect
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|Plane
argument_list|(
name|normVect
argument_list|,
name|this
operator|.
name|D
argument_list|)
return|;
block|}
comment|/** Find the intersection points between two planes, given a set of bounds.     *@param q is the plane to intersect with.     *@param bounds is the set of bounds.     *@param moreBounds is another set of bounds.     *@return the intersection point(s) on the unit sphere, if there are any.     */
DECL|method|findIntersections
specifier|protected
name|GeoPoint
index|[]
name|findIntersections
parameter_list|(
specifier|final
name|Plane
name|q
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|,
specifier|final
name|Membership
index|[]
name|moreBounds
parameter_list|)
block|{
specifier|final
name|Vector
name|lineVector
init|=
operator|new
name|Vector
argument_list|(
name|this
argument_list|,
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|lineVector
operator|.
name|x
operator|==
literal|0.0
operator|&&
name|lineVector
operator|.
name|y
operator|==
literal|0.0
operator|&&
name|lineVector
operator|.
name|z
operator|==
literal|0.0
condition|)
block|{
comment|// Degenerate case: parallel planes
return|return
name|NO_POINTS
return|;
block|}
comment|// The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.
comment|// We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.
comment|// To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations
comment|// simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:
comment|// 0.7 x + 0.3 y + 0.1 z + 0.0 = 0
comment|// and
comment|// 0.9 x - 0.1 y + 0.2 z + 4.0 = 0
comment|// Then we'd pick z = 0, so the equations to solve for x and y would be:
comment|// 0.7 x + 0.3y = 0.0
comment|// 0.9 x - 0.1y = -4.0
comment|// ... which can readily be solved using standard linear algebra.  Generally:
comment|// Q0 x + R0 y = S0
comment|// Q1 x + R1 y = S1
comment|// ... can be solved by Cramer's rule:
comment|// x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)
comment|// y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)
comment|// ... where det( a b / c d ) = ad - bc, so:
comment|// x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)
comment|// y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)
name|double
name|x0
decl_stmt|;
name|double
name|y0
decl_stmt|;
name|double
name|z0
decl_stmt|;
comment|// We try to maximize the determinant in the denominator
specifier|final
name|double
name|denomYZ
init|=
name|this
operator|.
name|y
operator|*
name|q
operator|.
name|z
operator|-
name|this
operator|.
name|z
operator|*
name|q
operator|.
name|y
decl_stmt|;
specifier|final
name|double
name|denomXZ
init|=
name|this
operator|.
name|x
operator|*
name|q
operator|.
name|z
operator|-
name|this
operator|.
name|z
operator|*
name|q
operator|.
name|x
decl_stmt|;
specifier|final
name|double
name|denomXY
init|=
name|this
operator|.
name|x
operator|*
name|q
operator|.
name|y
operator|-
name|this
operator|.
name|y
operator|*
name|q
operator|.
name|x
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|denomYZ
argument_list|)
operator|>=
name|Math
operator|.
name|abs
argument_list|(
name|denomXZ
argument_list|)
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|denomYZ
argument_list|)
operator|>=
name|Math
operator|.
name|abs
argument_list|(
name|denomXY
argument_list|)
condition|)
block|{
comment|// X is the biggest, so our point will have x0 = 0.0
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|denomYZ
argument_list|)
operator|<
literal|1.0e-35
condition|)
return|return
name|NO_POINTS
return|;
specifier|final
name|double
name|denom
init|=
literal|1.0
operator|/
name|denomYZ
decl_stmt|;
name|x0
operator|=
literal|0.0
expr_stmt|;
name|y0
operator|=
operator|(
operator|-
name|this
operator|.
name|D
operator|*
name|q
operator|.
name|z
operator|-
name|this
operator|.
name|z
operator|*
operator|-
name|q
operator|.
name|D
operator|)
operator|*
name|denom
expr_stmt|;
name|z0
operator|=
operator|(
name|this
operator|.
name|y
operator|*
operator|-
name|q
operator|.
name|D
operator|+
name|this
operator|.
name|D
operator|*
name|q
operator|.
name|y
operator|)
operator|*
name|denom
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|denomXZ
argument_list|)
operator|>=
name|Math
operator|.
name|abs
argument_list|(
name|denomXY
argument_list|)
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|denomXZ
argument_list|)
operator|>=
name|Math
operator|.
name|abs
argument_list|(
name|denomYZ
argument_list|)
condition|)
block|{
comment|// Y is the biggest, so y0 = 0.0
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|denomXZ
argument_list|)
operator|<
literal|1.0e-35
condition|)
return|return
name|NO_POINTS
return|;
specifier|final
name|double
name|denom
init|=
literal|1.0
operator|/
name|denomXZ
decl_stmt|;
name|x0
operator|=
operator|(
operator|-
name|this
operator|.
name|D
operator|*
name|q
operator|.
name|z
operator|-
name|this
operator|.
name|z
operator|*
operator|-
name|q
operator|.
name|D
operator|)
operator|*
name|denom
expr_stmt|;
name|y0
operator|=
literal|0.0
expr_stmt|;
name|z0
operator|=
operator|(
name|this
operator|.
name|x
operator|*
operator|-
name|q
operator|.
name|D
operator|+
name|this
operator|.
name|D
operator|*
name|q
operator|.
name|x
operator|)
operator|*
name|denom
expr_stmt|;
block|}
else|else
block|{
comment|// Z is the biggest, so Z0 = 0.0
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|denomXY
argument_list|)
operator|<
literal|1.0e-35
condition|)
return|return
name|NO_POINTS
return|;
specifier|final
name|double
name|denom
init|=
literal|1.0
operator|/
name|denomXY
decl_stmt|;
name|x0
operator|=
operator|(
operator|-
name|this
operator|.
name|D
operator|*
name|q
operator|.
name|y
operator|-
name|this
operator|.
name|y
operator|*
operator|-
name|q
operator|.
name|D
operator|)
operator|*
name|denom
expr_stmt|;
name|y0
operator|=
operator|(
name|this
operator|.
name|x
operator|*
operator|-
name|q
operator|.
name|D
operator|+
name|this
operator|.
name|D
operator|*
name|q
operator|.
name|x
operator|)
operator|*
name|denom
expr_stmt|;
name|z0
operator|=
literal|0.0
expr_stmt|;
block|}
comment|// Once an intersecting line is determined, the next step is to intersect that line with the unit sphere, which
comment|// will yield zero, one, or two points.
comment|// The equation of the sphere is: 1.0 = x^2 + y^2 + z^2.  Plugging in the parameterized line values yields:
comment|// 1.0 = (At+A0)^2 + (Bt+B0)^2 + (Ct+C0)^2
comment|// A^2 t^2 + 2AA0t + A0^2 + B^2 t^2 + 2BB0t + B0^2 + C^2 t^2 + 2CC0t + C0^2 - 1,0 = 0.0
comment|// [A^2 + B^2 + C^2] t^2 + [2AA0 + 2BB0 + 2CC0] t + [A0^2 + B0^2 + C0^2 - 1,0] = 0.0
comment|// Use the quadratic formula to determine t values and candidate point(s)
specifier|final
name|double
name|A
init|=
name|lineVector
operator|.
name|x
operator|*
name|lineVector
operator|.
name|x
operator|+
name|lineVector
operator|.
name|y
operator|*
name|lineVector
operator|.
name|y
operator|+
name|lineVector
operator|.
name|z
operator|*
name|lineVector
operator|.
name|z
decl_stmt|;
specifier|final
name|double
name|B
init|=
literal|2.0
operator|*
operator|(
name|lineVector
operator|.
name|x
operator|*
name|x0
operator|+
name|lineVector
operator|.
name|y
operator|*
name|y0
operator|+
name|lineVector
operator|.
name|z
operator|*
name|z0
operator|)
decl_stmt|;
specifier|final
name|double
name|C
init|=
name|x0
operator|*
name|x0
operator|+
name|y0
operator|*
name|y0
operator|+
name|z0
operator|*
name|z0
operator|-
literal|1.0
decl_stmt|;
specifier|final
name|double
name|BsquaredMinus
init|=
name|B
operator|*
name|B
operator|-
literal|4.0
operator|*
name|A
operator|*
name|C
decl_stmt|;
if|if
condition|(
name|BsquaredMinus
operator|<
literal|0.0
condition|)
return|return
name|NO_POINTS
return|;
specifier|final
name|double
name|inverse2A
init|=
literal|1.0
operator|/
operator|(
literal|2.0
operator|*
name|A
operator|)
decl_stmt|;
if|if
condition|(
name|BsquaredMinus
operator|==
literal|0.0
condition|)
block|{
comment|// One solution only
specifier|final
name|double
name|t
init|=
operator|-
name|B
operator|*
name|inverse2A
decl_stmt|;
name|GeoPoint
name|point
init|=
operator|new
name|GeoPoint
argument_list|(
name|lineVector
operator|.
name|x
operator|*
name|t
operator|+
name|x0
argument_list|,
name|lineVector
operator|.
name|y
operator|*
name|t
operator|+
name|y0
argument_list|,
name|lineVector
operator|.
name|z
operator|*
name|t
operator|+
name|z0
argument_list|)
decl_stmt|;
if|if
condition|(
name|point
operator|.
name|isWithin
argument_list|(
name|bounds
argument_list|,
name|moreBounds
argument_list|)
condition|)
return|return
operator|new
name|GeoPoint
index|[]
block|{
name|point
block|}
return|;
return|return
name|NO_POINTS
return|;
block|}
else|else
block|{
comment|// Two solutions
specifier|final
name|double
name|sqrtTerm
init|=
name|Math
operator|.
name|sqrt
argument_list|(
name|BsquaredMinus
argument_list|)
decl_stmt|;
specifier|final
name|double
name|t1
init|=
operator|(
operator|-
name|B
operator|+
name|sqrtTerm
operator|)
operator|*
name|inverse2A
decl_stmt|;
specifier|final
name|double
name|t2
init|=
operator|(
operator|-
name|B
operator|-
name|sqrtTerm
operator|)
operator|*
name|inverse2A
decl_stmt|;
name|GeoPoint
name|point1
init|=
operator|new
name|GeoPoint
argument_list|(
name|lineVector
operator|.
name|x
operator|*
name|t1
operator|+
name|x0
argument_list|,
name|lineVector
operator|.
name|y
operator|*
name|t1
operator|+
name|y0
argument_list|,
name|lineVector
operator|.
name|z
operator|*
name|t1
operator|+
name|z0
argument_list|)
decl_stmt|;
name|GeoPoint
name|point2
init|=
operator|new
name|GeoPoint
argument_list|(
name|lineVector
operator|.
name|x
operator|*
name|t2
operator|+
name|x0
argument_list|,
name|lineVector
operator|.
name|y
operator|*
name|t2
operator|+
name|y0
argument_list|,
name|lineVector
operator|.
name|z
operator|*
name|t2
operator|+
name|z0
argument_list|)
decl_stmt|;
if|if
condition|(
name|point1
operator|.
name|isWithin
argument_list|(
name|bounds
argument_list|,
name|moreBounds
argument_list|)
condition|)
block|{
if|if
condition|(
name|point2
operator|.
name|isWithin
argument_list|(
name|bounds
argument_list|,
name|moreBounds
argument_list|)
condition|)
return|return
operator|new
name|GeoPoint
index|[]
block|{
name|point1
block|,
name|point2
block|}
return|;
return|return
operator|new
name|GeoPoint
index|[]
block|{
name|point1
block|}
return|;
block|}
if|if
condition|(
name|point2
operator|.
name|isWithin
argument_list|(
name|bounds
argument_list|,
name|moreBounds
argument_list|)
condition|)
return|return
operator|new
name|GeoPoint
index|[]
block|{
name|point2
block|}
return|;
return|return
name|NO_POINTS
return|;
block|}
block|}
comment|/** Accumulate bounds information for this plane, intersected with another plane     * and with the unit sphere.     * Updates both latitude and longitude information, using max/min points found     * within the specified bounds.     *@param q is the plane to intersect with.     *@param boundsInfo is the info to update with additional bounding information.     *@param bounds are the surfaces delineating what's inside the shape.     */
DECL|method|recordBounds
specifier|public
name|void
name|recordBounds
parameter_list|(
specifier|final
name|Plane
name|q
parameter_list|,
specifier|final
name|Bounds
name|boundsInfo
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
specifier|final
name|GeoPoint
index|[]
name|intersectionPoints
init|=
name|findIntersections
argument_list|(
name|q
argument_list|,
name|bounds
argument_list|,
name|NO_BOUNDS
argument_list|)
decl_stmt|;
for|for
control|(
name|GeoPoint
name|intersectionPoint
range|:
name|intersectionPoints
control|)
block|{
name|boundsInfo
operator|.
name|addPoint
argument_list|(
name|intersectionPoint
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Accumulate bounds information for this plane, intersected with the unit sphere.     * Updates both latitude and longitude information, using max/min points found     * within the specified bounds.     *@param boundsInfo is the info to update with additional bounding information.     *@param bounds are the surfaces delineating what's inside the shape.     */
DECL|method|recordBounds
specifier|public
name|void
name|recordBounds
parameter_list|(
specifier|final
name|Bounds
name|boundsInfo
parameter_list|,
specifier|final
name|Membership
modifier|...
name|bounds
parameter_list|)
block|{
comment|// For clarity, load local variables with good names
name|double
name|A
init|=
name|this
operator|.
name|x
decl_stmt|;
name|double
name|B
init|=
name|this
operator|.
name|y
decl_stmt|;
name|double
name|C
init|=
name|this
operator|.
name|z
decl_stmt|;
comment|// Now compute latitude min/max points
if|if
condition|(
operator|!
name|boundsInfo
operator|.
name|checkNoTopLatitudeBound
argument_list|()
operator|||
operator|!
name|boundsInfo
operator|.
name|checkNoBottomLatitudeBound
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|Math
operator|.
name|abs
argument_list|(
name|A
argument_list|)
operator|>=
name|MINIMUM_RESOLUTION
operator|||
name|Math
operator|.
name|abs
argument_list|(
name|B
argument_list|)
operator|>=
name|MINIMUM_RESOLUTION
operator|)
condition|)
block|{
comment|//System.out.println("A = "+A+" B = "+B+" C = "+C+" D = "+D);
comment|// sin (phi) = z
comment|// cos (theta - phi) = D
comment|// sin (theta) = C  (the dot product of (0,0,1) and (A,B,C) )
comment|// Q: what is z?
comment|//
comment|// cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|C
argument_list|)
operator|<
literal|1.0e-10
condition|)
block|{
comment|// Special case: circle is vertical.
comment|//System.out.println("Degenerate case; it's vertical circle");
comment|// cos(phi) = D, and we want sin(phi) = z
comment|// There are two solutions for phi given cos(phi) = D: a positive solution and a negative solution.
comment|// So, when we compute z = sqrt(1-D^2), it's really z = +/- sqrt(1-D^2) .
name|double
name|z
decl_stmt|;
name|double
name|x
decl_stmt|;
name|double
name|y
decl_stmt|;
name|double
name|denom
init|=
literal|1.0
operator|/
operator|(
name|A
operator|*
name|A
operator|+
name|B
operator|*
name|B
operator|)
decl_stmt|;
name|z
operator|=
name|Math
operator|.
name|sqrt
argument_list|(
literal|1.0
operator|-
name|D
operator|*
name|D
argument_list|)
expr_stmt|;
name|y
operator|=
operator|-
name|B
operator|*
name|D
operator|*
name|denom
expr_stmt|;
name|x
operator|=
operator|-
name|A
operator|*
name|D
operator|*
name|denom
expr_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|z
operator|=
operator|-
name|z
expr_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We might be able to identify a specific new latitude maximum or minimum.
comment|//
comment|// cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D
comment|//
comment|// This is tricky.  If cos(phi) = something, and we want to figure out
comment|// what sin(phi) is, in order to capture all solutions we need to recognize
comment|// that sin(phi) = +/- sqrt(1 - cos(phi)^2).  Basically, this means that
comment|// whatever solution we find we have to mirror it across the x-y plane,
comment|// and include both +z and -z solutions.
comment|//
comment|// cos (phi) = +/- sqrt(1-sin(phi)^2) = +/- sqrt(1-z^2)
comment|// cos (theta) = +/- sqrt(1-sin(theta)^2) = +/- sqrt(1-C^2)
comment|//
comment|// D = cos(theta)cos(phi) + sin(theta)sin(phi)
comment|// Substitute:
comment|// D = sqrt(1-C^2) * sqrt(1-z^2) + C * z
comment|// Solve for z...
comment|// D-Cz = sqrt(1-C^2)*sqrt(1-z^2) = sqrt(1 - z^2 - C^2 + z^2*C^2)
comment|// Square both sides.
comment|// (D-Cz)^2 = 1 - z^2 - C^2 + z^2*C^2
comment|// D^2 - 2DCz + C^2*z^2 = 1 - z^2 - C^2 + z^2*C^2
comment|// D^2 - 2DCz  = 1 - C^2 - z^2
comment|// 0 = z^2 - 2DCz + (C^2 +D^2-1) = 0
comment|//
comment|// z = (2DC +/- sqrt(4*D^2*C^2 - 4*(C^2+D^2-1))) / (2)
comment|// z  = DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2 )
comment|//    = DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2)
name|double
name|z
decl_stmt|;
name|double
name|x
decl_stmt|;
name|double
name|y
decl_stmt|;
name|double
name|sqrtValue
init|=
name|D
operator|*
name|D
operator|*
name|C
operator|*
name|C
operator|+
literal|1.0
operator|-
name|C
operator|*
name|C
operator|-
name|D
operator|*
name|D
decl_stmt|;
if|if
condition|(
name|sqrtValue
operator|>=
literal|0.0
condition|)
block|{
comment|// y = -B[D+Cz] / [A^2 + B^2]
comment|// x = -A[D+Cz] / [A^2 + B^2]
name|double
name|denom
init|=
literal|1.0
operator|/
operator|(
name|A
operator|*
name|A
operator|+
name|B
operator|*
name|B
operator|)
decl_stmt|;
if|if
condition|(
name|sqrtValue
operator|==
literal|0.0
condition|)
block|{
comment|//System.out.println("Zero sqrt term");
name|z
operator|=
name|D
operator|*
name|C
expr_stmt|;
comment|// Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|D
operator|-
name|C
operator|*
name|z
operator|-
name|Math
operator|.
name|sqrt
argument_list|(
literal|1.0
operator|-
name|z
operator|*
name|z
operator|-
name|C
operator|*
name|C
operator|+
name|z
operator|*
name|z
operator|*
name|C
operator|*
name|C
argument_list|)
argument_list|)
operator|<
literal|1.0e-10
condition|)
block|{
name|y
operator|=
operator|-
name|B
operator|*
operator|(
name|D
operator|+
name|C
operator|*
name|z
operator|)
operator|*
name|denom
expr_stmt|;
name|x
operator|=
operator|-
name|A
operator|*
operator|(
name|D
operator|+
name|C
operator|*
name|z
operator|)
operator|*
name|denom
expr_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
name|z
operator|=
operator|-
name|D
operator|*
name|C
expr_stmt|;
comment|// Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|D
operator|+
name|C
operator|*
name|z
operator|+
name|Math
operator|.
name|sqrt
argument_list|(
literal|1.0
operator|-
name|z
operator|*
name|z
operator|-
name|C
operator|*
name|C
operator|+
name|z
operator|*
name|z
operator|*
name|C
operator|*
name|C
argument_list|)
argument_list|)
operator|<
literal|1.0e-10
condition|)
block|{
name|y
operator|=
operator|-
name|B
operator|*
operator|(
name|D
operator|+
name|C
operator|*
name|z
operator|)
operator|*
name|denom
expr_stmt|;
name|x
operator|=
operator|-
name|A
operator|*
operator|(
name|D
operator|+
name|C
operator|*
name|z
operator|)
operator|*
name|denom
expr_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|double
name|sqrtResult
init|=
name|Math
operator|.
name|sqrt
argument_list|(
name|sqrtValue
argument_list|)
decl_stmt|;
name|z
operator|=
name|D
operator|*
name|C
operator|+
name|sqrtResult
expr_stmt|;
comment|//System.out.println("z= "+z+" D-C*z = " + (D-C*z) + " Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = "+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));
comment|// Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|D
operator|-
name|C
operator|*
name|z
operator|-
name|Math
operator|.
name|sqrt
argument_list|(
literal|1.0
operator|-
name|z
operator|*
name|z
operator|-
name|C
operator|*
name|C
operator|+
name|z
operator|*
name|z
operator|*
name|C
operator|*
name|C
argument_list|)
argument_list|)
operator|<
literal|1.0e-10
condition|)
block|{
comment|//System.out.println("found a point; z = "+z);
name|y
operator|=
operator|-
name|B
operator|*
operator|(
name|D
operator|+
name|C
operator|*
name|z
operator|)
operator|*
name|denom
expr_stmt|;
name|x
operator|=
operator|-
name|A
operator|*
operator|(
name|D
operator|+
name|C
operator|*
name|z
operator|)
operator|*
name|denom
expr_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
name|z
operator|=
name|D
operator|*
name|C
operator|-
name|sqrtResult
expr_stmt|;
comment|//System.out.println("z= "+z+" D-C*z = " + (D-C*z) + " Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = "+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));
comment|// Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|D
operator|-
name|C
operator|*
name|z
operator|-
name|Math
operator|.
name|sqrt
argument_list|(
literal|1.0
operator|-
name|z
operator|*
name|z
operator|-
name|C
operator|*
name|C
operator|+
name|z
operator|*
name|z
operator|*
name|C
operator|*
name|C
argument_list|)
argument_list|)
operator|<
literal|1.0e-10
condition|)
block|{
comment|//System.out.println("found a point; z="+z);
name|y
operator|=
operator|-
name|B
operator|*
operator|(
name|D
operator|+
name|C
operator|*
name|z
operator|)
operator|*
name|denom
expr_stmt|;
name|x
operator|=
operator|-
name|A
operator|*
operator|(
name|D
operator|+
name|C
operator|*
name|z
operator|)
operator|*
name|denom
expr_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
name|z
operator|=
operator|-
operator|(
name|D
operator|*
name|C
operator|+
name|sqrtResult
operator|)
expr_stmt|;
comment|//System.out.println("z= "+z+" D+C*z = " + (D+C*z) + " -Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = "+(-Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));
comment|// Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|D
operator|+
name|C
operator|*
name|z
operator|+
name|Math
operator|.
name|sqrt
argument_list|(
literal|1.0
operator|-
name|z
operator|*
name|z
operator|-
name|C
operator|*
name|C
operator|+
name|z
operator|*
name|z
operator|*
name|C
operator|*
name|C
argument_list|)
argument_list|)
operator|<
literal|1.0e-10
condition|)
block|{
comment|//System.out.println("found a point; z = "+z);
name|y
operator|=
operator|-
name|B
operator|*
operator|(
name|D
operator|+
name|C
operator|*
name|z
operator|)
operator|*
name|denom
expr_stmt|;
name|x
operator|=
operator|-
name|A
operator|*
operator|(
name|D
operator|+
name|C
operator|*
name|z
operator|)
operator|*
name|denom
expr_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
name|z
operator|=
operator|-
operator|(
name|D
operator|*
name|C
operator|-
name|sqrtResult
operator|)
expr_stmt|;
comment|//System.out.println("z= "+z+" D+C*z = " + (D+C*z) + " -Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = "+(-Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));
comment|// Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|D
operator|+
name|C
operator|*
name|z
operator|+
name|Math
operator|.
name|sqrt
argument_list|(
literal|1
operator|-
name|z
operator|*
name|z
operator|-
name|C
operator|*
name|C
operator|+
name|z
operator|*
name|z
operator|*
name|C
operator|*
name|C
argument_list|)
argument_list|)
operator|<
literal|1.0e-10
condition|)
block|{
comment|//System.out.println("found a point; z="+z);
name|y
operator|=
operator|-
name|B
operator|*
operator|(
name|D
operator|+
name|C
operator|*
name|z
operator|)
operator|*
name|denom
expr_stmt|;
name|x
operator|=
operator|-
name|A
operator|*
operator|(
name|D
operator|+
name|C
operator|*
name|z
operator|)
operator|*
name|denom
expr_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
comment|// Horizontal circle.
comment|// Since the recordBounds() method will be called ONLY for planes that constitute edges of a shape,
comment|// we can be sure that some part of the horizontal circle will be part of the boundary, so we don't need
comment|// to check Membership objects.
name|boundsInfo
operator|.
name|addHorizontalCircle
argument_list|(
operator|-
name|D
operator|*
name|C
argument_list|)
expr_stmt|;
block|}
block|}
comment|// First, figure out our longitude bounds, unless we no longer need to consider that
if|if
condition|(
operator|!
name|boundsInfo
operator|.
name|checkNoLongitudeBound
argument_list|()
condition|)
block|{
comment|//System.out.println("A = "+A+" B = "+B+" C = "+C+" D = "+D);
comment|// Compute longitude bounds
name|double
name|a
decl_stmt|;
name|double
name|b
decl_stmt|;
name|double
name|c
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|C
argument_list|)
operator|<
name|MINIMUM_RESOLUTION
condition|)
block|{
comment|// Degenerate; the equation describes a line
comment|//System.out.println("It's a zero-width ellipse");
comment|// Ax + By + D = 0
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|D
argument_list|)
operator|>=
name|MINIMUM_RESOLUTION
condition|)
block|{
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|A
argument_list|)
operator|>
name|Math
operator|.
name|abs
argument_list|(
name|B
argument_list|)
condition|)
block|{
comment|// Use equation suitable for A != 0
comment|// We need to find the endpoints of the zero-width ellipse.
comment|// Geometrically, we have a line segment in x-y space.  We need to locate the endpoints
comment|// of that line.  But luckily, we know some things: specifically, since it is a
comment|// degenerate situation in projection, the C value had to have been 0.  That
comment|// means that our line's endpoints will coincide with the unit circle.  All we
comment|// need to do then is to find the intersection of the unit circle and the line
comment|// equation:
comment|//
comment|// A x + B y + D = 0
comment|//
comment|// Since A != 0:
comment|// x = (-By - D)/A
comment|//
comment|// The unit circle:
comment|// x^2 + y^2 - 1 = 0
comment|// Substitute:
comment|// [(-By-D)/A]^2 + y^2 -1 = 0
comment|// Multiply through by A^2:
comment|// [-By - D]^2 + A^2*y^2 - A^2 = 0
comment|// Multiply out:
comment|// B^2*y^2 + 2BDy + D^2 + A^2*y^2 - A^2 = 0
comment|// Group:
comment|// y^2 * [B^2 + A^2] + y [2BD] + [D^2-A^2] = 0
name|a
operator|=
name|B
operator|*
name|B
operator|+
name|A
operator|*
name|A
expr_stmt|;
name|b
operator|=
literal|2.0
operator|*
name|B
operator|*
name|D
expr_stmt|;
name|c
operator|=
name|D
operator|*
name|D
operator|-
name|A
operator|*
name|A
expr_stmt|;
name|double
name|sqrtClause
init|=
name|b
operator|*
name|b
operator|-
literal|4.0
operator|*
name|a
operator|*
name|c
decl_stmt|;
if|if
condition|(
name|sqrtClause
operator|>=
literal|0.0
condition|)
block|{
if|if
condition|(
name|sqrtClause
operator|==
literal|0.0
condition|)
block|{
name|double
name|y0
init|=
operator|-
name|b
operator|/
operator|(
literal|2.0
operator|*
name|a
operator|)
decl_stmt|;
name|double
name|x0
init|=
operator|(
operator|-
name|D
operator|-
name|B
operator|*
name|y0
operator|)
operator|/
name|A
decl_stmt|;
name|double
name|z0
init|=
literal|0.0
decl_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|z0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|double
name|sqrtResult
init|=
name|Math
operator|.
name|sqrt
argument_list|(
name|sqrtClause
argument_list|)
decl_stmt|;
name|double
name|denom
init|=
literal|1.0
operator|/
operator|(
literal|2.0
operator|*
name|a
operator|)
decl_stmt|;
name|double
name|Hdenom
init|=
literal|1.0
operator|/
name|A
decl_stmt|;
name|double
name|y0a
init|=
operator|(
operator|-
name|b
operator|+
name|sqrtResult
operator|)
operator|*
name|denom
decl_stmt|;
name|double
name|y0b
init|=
operator|(
operator|-
name|b
operator|-
name|sqrtResult
operator|)
operator|*
name|denom
decl_stmt|;
name|double
name|x0a
init|=
operator|(
operator|-
name|D
operator|-
name|B
operator|*
name|y0a
operator|)
operator|*
name|Hdenom
decl_stmt|;
name|double
name|x0b
init|=
operator|(
operator|-
name|D
operator|-
name|B
operator|*
name|y0b
operator|)
operator|*
name|Hdenom
decl_stmt|;
name|double
name|z0a
init|=
literal|0.0
decl_stmt|;
name|double
name|z0b
init|=
literal|0.0
decl_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0a
argument_list|,
name|y0a
argument_list|,
name|z0a
argument_list|)
expr_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0b
argument_list|,
name|y0b
argument_list|,
name|z0b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// Use equation suitable for B != 0
comment|// Since I != 0, we rewrite:
comment|// y = (-Ax - D)/B
name|a
operator|=
name|B
operator|*
name|B
operator|+
name|A
operator|*
name|A
expr_stmt|;
name|b
operator|=
literal|2.0
operator|*
name|A
operator|*
name|D
expr_stmt|;
name|c
operator|=
name|D
operator|*
name|D
operator|-
name|B
operator|*
name|B
expr_stmt|;
name|double
name|sqrtClause
init|=
name|b
operator|*
name|b
operator|-
literal|4.0
operator|*
name|a
operator|*
name|c
decl_stmt|;
if|if
condition|(
name|sqrtClause
operator|>=
literal|0.0
condition|)
block|{
if|if
condition|(
name|sqrtClause
operator|==
literal|0.0
condition|)
block|{
name|double
name|x0
init|=
operator|-
name|b
operator|/
operator|(
literal|2.0
operator|*
name|a
operator|)
decl_stmt|;
name|double
name|y0
init|=
operator|(
operator|-
name|D
operator|-
name|A
operator|*
name|x0
operator|)
operator|/
name|B
decl_stmt|;
name|double
name|z0
init|=
literal|0.0
decl_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|z0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|double
name|sqrtResult
init|=
name|Math
operator|.
name|sqrt
argument_list|(
name|sqrtClause
argument_list|)
decl_stmt|;
name|double
name|denom
init|=
literal|1.0
operator|/
operator|(
literal|2.0
operator|*
name|a
operator|)
decl_stmt|;
name|double
name|Idenom
init|=
literal|1.0
operator|/
name|B
decl_stmt|;
name|double
name|x0a
init|=
operator|(
operator|-
name|b
operator|+
name|sqrtResult
operator|)
operator|*
name|denom
decl_stmt|;
name|double
name|x0b
init|=
operator|(
operator|-
name|b
operator|-
name|sqrtResult
operator|)
operator|*
name|denom
decl_stmt|;
name|double
name|y0a
init|=
operator|(
operator|-
name|D
operator|-
name|A
operator|*
name|x0a
operator|)
operator|*
name|Idenom
decl_stmt|;
name|double
name|y0b
init|=
operator|(
operator|-
name|D
operator|-
name|A
operator|*
name|x0b
operator|)
operator|*
name|Idenom
decl_stmt|;
name|double
name|z0a
init|=
literal|0.0
decl_stmt|;
name|double
name|z0b
init|=
literal|0.0
decl_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0a
argument_list|,
name|y0a
argument_list|,
name|z0a
argument_list|)
expr_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0b
argument_list|,
name|y0b
argument_list|,
name|z0b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
comment|// (1) Intersect the plane and the unit sphere, and project the results into the x-y plane:
comment|// From plane:
comment|// z = (-Ax - By - D) / C
comment|// From unit sphere:
comment|// x^2 + y^2 + [(-Ax - By - D) / C]^2 = 1
comment|// Simplify/expand:
comment|// C^2*x^2 + C^2*y^2 + (-Ax - By - D)^2 = C^2
comment|//
comment|// x^2 * C^2 + y^2 * C^2 + x^2 * (A^2 + ABxy + ADx) + (ABxy + y^2 * B^2 + BDy) + (ADx + BDy + D^2) = C^2
comment|// Group:
comment|// [A^2 + C^2] x^2 + [B^2 + C^2] y^2 + [2AB]xy + [2AD]x + [2BD]y + [D^2-C^2] = 0
comment|// For convenience, introduce post-projection coefficient variables to make life easier.
comment|// E x^2 + F y^2 + G xy + H x + I y + J = 0
name|double
name|E
init|=
name|A
operator|*
name|A
operator|+
name|C
operator|*
name|C
decl_stmt|;
name|double
name|F
init|=
name|B
operator|*
name|B
operator|+
name|C
operator|*
name|C
decl_stmt|;
name|double
name|G
init|=
literal|2.0
operator|*
name|A
operator|*
name|B
decl_stmt|;
name|double
name|H
init|=
literal|2.0
operator|*
name|A
operator|*
name|D
decl_stmt|;
name|double
name|I
init|=
literal|2.0
operator|*
name|B
operator|*
name|D
decl_stmt|;
name|double
name|J
init|=
name|D
operator|*
name|D
operator|-
name|C
operator|*
name|C
decl_stmt|;
comment|//System.out.println("E = " + E + " F = " + F + " G = " + G + " H = "+ H + " I = " + I + " J = " + J);
comment|// Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero
if|if
condition|(
name|J
operator|>
literal|0.0
condition|)
block|{
comment|// The derivative of the curve above is:
comment|// 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0
comment|// (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0
comment|// dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)
comment|//
comment|// The equation of a line going through the origin with the slope dy/dx is:
comment|// y = dy/dx x
comment|// y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x
comment|// Rearrange:
comment|// (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0
comment|// 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0
comment|// 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0
comment|//
comment|// Multiply the original equation by 2:
comment|// 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0
comment|// Subtract one from the other, to remove the high-order terms:
comment|// Hx + Iy + 2J = 0
comment|// Now, we can substitute either x = or y = into the derivative equation, or into the original equation.
comment|// But we will need to base this on which coefficient is non-zero
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|H
argument_list|)
operator|>
name|Math
operator|.
name|abs
argument_list|(
name|I
argument_list|)
condition|)
block|{
comment|//System.out.println("Using the y quadratic");
comment|// x = (-2J - Iy)/H
comment|// Plug into the original equation:
comment|// E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0
comment|// E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0
comment|// Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.
comment|// Plug into derivative equation:
comment|// 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0
comment|// 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0
comment|// E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0
comment|// Multiply by H^2 to make manipulation easier
comment|// E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0
comment|// Do the square
comment|// E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0
comment|// Multiply it out
comment|// 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0
comment|// Group:
comment|// y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0
name|a
operator|=
name|E
operator|*
name|I
operator|*
name|I
operator|-
name|G
operator|*
name|H
operator|*
name|I
operator|+
name|F
operator|*
name|H
operator|*
name|H
expr_stmt|;
name|b
operator|=
literal|4.0
operator|*
name|E
operator|*
name|I
operator|*
name|J
operator|-
literal|2.0
operator|*
name|G
operator|*
name|H
operator|*
name|J
expr_stmt|;
name|c
operator|=
literal|4.0
operator|*
name|E
operator|*
name|J
operator|*
name|J
operator|-
name|J
operator|*
name|H
operator|*
name|H
expr_stmt|;
comment|//System.out.println("a="+a+" b="+b+" c="+c);
name|double
name|sqrtClause
init|=
name|b
operator|*
name|b
operator|-
literal|4.0
operator|*
name|a
operator|*
name|c
decl_stmt|;
comment|//System.out.println("sqrtClause="+sqrtClause);
if|if
condition|(
name|sqrtClause
operator|>=
literal|0.0
condition|)
block|{
if|if
condition|(
name|sqrtClause
operator|==
literal|0.0
condition|)
block|{
comment|//System.out.println("One solution");
name|double
name|y0
init|=
operator|-
name|b
operator|/
operator|(
literal|2.0
operator|*
name|a
operator|)
decl_stmt|;
name|double
name|x0
init|=
operator|(
operator|-
literal|2.0
operator|*
name|J
operator|-
name|I
operator|*
name|y0
operator|)
operator|/
name|H
decl_stmt|;
name|double
name|z0
init|=
operator|(
operator|-
name|A
operator|*
name|x0
operator|-
name|B
operator|*
name|y0
operator|-
name|D
operator|)
operator|/
name|C
decl_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|z0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//System.out.println("Two solutions");
name|double
name|sqrtResult
init|=
name|Math
operator|.
name|sqrt
argument_list|(
name|sqrtClause
argument_list|)
decl_stmt|;
name|double
name|denom
init|=
literal|1.0
operator|/
operator|(
literal|2.0
operator|*
name|a
operator|)
decl_stmt|;
name|double
name|Hdenom
init|=
literal|1.0
operator|/
name|H
decl_stmt|;
name|double
name|Cdenom
init|=
literal|1.0
operator|/
name|C
decl_stmt|;
name|double
name|y0a
init|=
operator|(
operator|-
name|b
operator|+
name|sqrtResult
operator|)
operator|*
name|denom
decl_stmt|;
name|double
name|y0b
init|=
operator|(
operator|-
name|b
operator|-
name|sqrtResult
operator|)
operator|*
name|denom
decl_stmt|;
name|double
name|x0a
init|=
operator|(
operator|-
literal|2.0
operator|*
name|J
operator|-
name|I
operator|*
name|y0a
operator|)
operator|*
name|Hdenom
decl_stmt|;
name|double
name|x0b
init|=
operator|(
operator|-
literal|2.0
operator|*
name|J
operator|-
name|I
operator|*
name|y0b
operator|)
operator|*
name|Hdenom
decl_stmt|;
name|double
name|z0a
init|=
operator|(
operator|-
name|A
operator|*
name|x0a
operator|-
name|B
operator|*
name|y0a
operator|-
name|D
operator|)
operator|*
name|Cdenom
decl_stmt|;
name|double
name|z0b
init|=
operator|(
operator|-
name|A
operator|*
name|x0b
operator|-
name|B
operator|*
name|y0b
operator|-
name|D
operator|)
operator|*
name|Cdenom
decl_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0a
argument_list|,
name|y0a
argument_list|,
name|z0a
argument_list|)
expr_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0b
argument_list|,
name|y0b
argument_list|,
name|z0b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|//System.out.println("Using the x quadratic");
comment|// y = (-2J - Hx)/I
comment|// Plug into the original equation:
comment|// E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0
comment|// Multiply by I^2 to make manipulation easier
comment|// E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0
comment|// Do the square
comment|// E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0
comment|// Multiply it out
comment|// E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0
comment|// Group:
comment|// x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0
name|a
operator|=
name|E
operator|*
name|I
operator|*
name|I
operator|-
name|G
operator|*
name|H
operator|*
name|I
operator|+
name|F
operator|*
name|H
operator|*
name|H
expr_stmt|;
name|b
operator|=
literal|4.0
operator|*
name|F
operator|*
name|H
operator|*
name|J
operator|-
literal|2.0
operator|*
name|G
operator|*
name|I
operator|*
name|J
expr_stmt|;
name|c
operator|=
literal|4.0
operator|*
name|F
operator|*
name|J
operator|*
name|J
operator|-
name|J
operator|*
name|I
operator|*
name|I
expr_stmt|;
comment|//System.out.println("a="+a+" b="+b+" c="+c);
name|double
name|sqrtClause
init|=
name|b
operator|*
name|b
operator|-
literal|4.0
operator|*
name|a
operator|*
name|c
decl_stmt|;
comment|//System.out.println("sqrtClause="+sqrtClause);
if|if
condition|(
name|sqrtClause
operator|>=
literal|0.0
condition|)
block|{
if|if
condition|(
name|sqrtClause
operator|==
literal|0.0
condition|)
block|{
comment|//System.out.println("One solution");
name|double
name|x0
init|=
operator|-
name|b
operator|/
operator|(
literal|2.0
operator|*
name|a
operator|)
decl_stmt|;
name|double
name|y0
init|=
operator|(
operator|-
literal|2.0
operator|*
name|J
operator|-
name|H
operator|*
name|x0
operator|)
operator|/
name|I
decl_stmt|;
name|double
name|z0
init|=
operator|(
operator|-
name|A
operator|*
name|x0
operator|-
name|B
operator|*
name|y0
operator|-
name|D
operator|)
operator|/
name|C
decl_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|z0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//System.out.println("Two solutions");
name|double
name|sqrtResult
init|=
name|Math
operator|.
name|sqrt
argument_list|(
name|sqrtClause
argument_list|)
decl_stmt|;
name|double
name|denom
init|=
literal|1.0
operator|/
operator|(
literal|2.0
operator|*
name|a
operator|)
decl_stmt|;
name|double
name|Idenom
init|=
literal|1.0
operator|/
name|I
decl_stmt|;
name|double
name|Cdenom
init|=
literal|1.0
operator|/
name|C
decl_stmt|;
name|double
name|x0a
init|=
operator|(
operator|-
name|b
operator|+
name|sqrtResult
operator|)
operator|*
name|denom
decl_stmt|;
name|double
name|x0b
init|=
operator|(
operator|-
name|b
operator|-
name|sqrtResult
operator|)
operator|*
name|denom
decl_stmt|;
name|double
name|y0a
init|=
operator|(
operator|-
literal|2.0
operator|*
name|J
operator|-
name|H
operator|*
name|x0a
operator|)
operator|*
name|Idenom
decl_stmt|;
name|double
name|y0b
init|=
operator|(
operator|-
literal|2.0
operator|*
name|J
operator|-
name|H
operator|*
name|x0b
operator|)
operator|*
name|Idenom
decl_stmt|;
name|double
name|z0a
init|=
operator|(
operator|-
name|A
operator|*
name|x0a
operator|-
name|B
operator|*
name|y0a
operator|-
name|D
operator|)
operator|*
name|Cdenom
decl_stmt|;
name|double
name|z0b
init|=
operator|(
operator|-
name|A
operator|*
name|x0b
operator|-
name|B
operator|*
name|y0b
operator|-
name|D
operator|)
operator|*
name|Cdenom
decl_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0a
argument_list|,
name|y0a
argument_list|,
name|z0a
argument_list|)
expr_stmt|;
name|addPoint
argument_list|(
name|boundsInfo
argument_list|,
name|bounds
argument_list|,
name|x0b
argument_list|,
name|y0b
argument_list|,
name|z0b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
DECL|method|addPoint
specifier|protected
specifier|static
name|void
name|addPoint
parameter_list|(
specifier|final
name|Bounds
name|boundsInfo
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|,
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|)
block|{
comment|// Make sure the discovered point is within the bounds
for|for
control|(
name|Membership
name|bound
range|:
name|bounds
control|)
block|{
if|if
condition|(
operator|!
name|bound
operator|.
name|isWithin
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
return|return;
block|}
comment|// Add the point
comment|//System.out.println("Adding point x="+x+" y="+y+" z="+z);
name|boundsInfo
operator|.
name|addPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
comment|/** Determine whether the plane intersects another plane within the      * bounds provided.      *@param q is the other plane.      *@param notablePoints are points to look at to disambiguate cases when the two planes are identical.      *@param moreNotablePoints are additional points to look at to disambiguate cases when the two planes are identical.      *@param bounds is one part of the bounds.      *@param moreBounds are more bounds.      *@return true if there's an intersection.      */
DECL|method|intersects
specifier|public
name|boolean
name|intersects
parameter_list|(
specifier|final
name|Plane
name|q
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|notablePoints
parameter_list|,
specifier|final
name|GeoPoint
index|[]
name|moreNotablePoints
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|,
specifier|final
name|Membership
modifier|...
name|moreBounds
parameter_list|)
block|{
comment|// If the two planes are identical, then the math will find no points of intersection.
comment|// So a special case of this is to check for plane equality.  But that is not enough, because
comment|// what we really need at that point is to determine whether overlap occurs between the two parts of the intersection
comment|// of plane and circle.  That is, are there *any* points on the plane that are within the bounds described?
if|if
condition|(
name|equals
argument_list|(
name|q
argument_list|)
condition|)
block|{
comment|// The only way to efficiently figure this out will be to have a list of trial points available to evaluate.
comment|// We look for any point that fulfills all the bounds.
for|for
control|(
name|GeoPoint
name|p
range|:
name|notablePoints
control|)
block|{
if|if
condition|(
name|meetsAllBounds
argument_list|(
name|p
argument_list|,
name|bounds
argument_list|,
name|moreBounds
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
for|for
control|(
name|GeoPoint
name|p
range|:
name|moreNotablePoints
control|)
block|{
if|if
condition|(
name|meetsAllBounds
argument_list|(
name|p
argument_list|,
name|bounds
argument_list|,
name|moreBounds
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
return|return
name|findIntersections
argument_list|(
name|q
argument_list|,
name|bounds
argument_list|,
name|moreBounds
argument_list|)
operator|.
name|length
operator|>
literal|0
return|;
block|}
DECL|method|meetsAllBounds
specifier|protected
specifier|static
name|boolean
name|meetsAllBounds
parameter_list|(
specifier|final
name|GeoPoint
name|p
parameter_list|,
specifier|final
name|Membership
index|[]
name|bounds
parameter_list|,
specifier|final
name|Membership
index|[]
name|moreBounds
parameter_list|)
block|{
for|for
control|(
specifier|final
name|Membership
name|bound
range|:
name|bounds
control|)
block|{
if|if
condition|(
operator|!
name|bound
operator|.
name|isWithin
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
for|for
control|(
specifier|final
name|Membership
name|bound
range|:
name|moreBounds
control|)
block|{
if|if
condition|(
operator|!
name|bound
operator|.
name|isWithin
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Find a sample point on the intersection between two planes and the unit sphere.     */
DECL|method|getSampleIntersectionPoint
specifier|public
name|GeoPoint
name|getSampleIntersectionPoint
parameter_list|(
specifier|final
name|Plane
name|q
parameter_list|)
block|{
specifier|final
name|GeoPoint
index|[]
name|intersections
init|=
name|findIntersections
argument_list|(
name|q
argument_list|,
name|NO_BOUNDS
argument_list|,
name|NO_BOUNDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|intersections
operator|.
name|length
operator|==
literal|0
condition|)
return|return
literal|null
return|;
return|return
name|intersections
index|[
literal|0
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"[A="
operator|+
name|x
operator|+
literal|", B="
operator|+
name|y
operator|+
literal|"; C="
operator|+
name|z
operator|+
literal|"; D="
operator|+
name|D
operator|+
literal|"]"
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|super
operator|.
name|equals
argument_list|(
name|o
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Plane
operator|)
condition|)
return|return
literal|false
return|;
name|Plane
name|other
init|=
operator|(
name|Plane
operator|)
name|o
decl_stmt|;
return|return
name|other
operator|.
name|D
operator|==
name|D
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|super
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|long
name|temp
decl_stmt|;
name|temp
operator|=
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|D
argument_list|)
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
call|(
name|int
call|)
argument_list|(
name|temp
operator|^
operator|(
name|temp
operator|>>>
literal|32
operator|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_class
end_unit
