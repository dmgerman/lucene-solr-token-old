begin_unit
begin_package
DECL|package|org.apache.lucene.spatial.prefix
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|prefix
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|context
operator|.
name|SpatialContext
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Point
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Rectangle
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Shape
import|;
end_import
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|SpatialRelation
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|prefix
operator|.
name|tree
operator|.
name|Cell
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|prefix
operator|.
name|tree
operator|.
name|CellIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|prefix
operator|.
name|tree
operator|.
name|SpatialPrefixTree
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_comment
comment|/**  * Computes spatial facets in two dimensions as a grid of numbers.  The data is often visualized as a so-called  * "heatmap", hence the name.  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|HeatmapFacetCounter
specifier|public
class|class
name|HeatmapFacetCounter
block|{
comment|//TODO where should this code live? It could go to PrefixTreeFacetCounter, or maybe here in its own class is fine.
comment|/** Maximum number of supported rows (or columns). */
DECL|field|MAX_ROWS_OR_COLUMNS
specifier|public
specifier|static
specifier|final
name|int
name|MAX_ROWS_OR_COLUMNS
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|sqrt
argument_list|(
name|ArrayUtil
operator|.
name|MAX_ARRAY_LENGTH
argument_list|)
decl_stmt|;
static|static
block|{
name|Math
operator|.
name|multiplyExact
argument_list|(
name|MAX_ROWS_OR_COLUMNS
argument_list|,
name|MAX_ROWS_OR_COLUMNS
argument_list|)
expr_stmt|;
comment|//will throw if doesn't stay within integer
block|}
comment|/** Response structure */
DECL|class|Heatmap
specifier|public
specifier|static
class|class
name|Heatmap
block|{
DECL|field|columns
specifier|public
specifier|final
name|int
name|columns
decl_stmt|;
DECL|field|rows
specifier|public
specifier|final
name|int
name|rows
decl_stmt|;
DECL|field|counts
specifier|public
specifier|final
name|int
index|[]
name|counts
decl_stmt|;
comment|//in order of 1st column (all rows) then 2nd column (all rows) etc.
DECL|field|region
specifier|public
specifier|final
name|Rectangle
name|region
decl_stmt|;
DECL|method|Heatmap
specifier|public
name|Heatmap
parameter_list|(
name|int
name|columns
parameter_list|,
name|int
name|rows
parameter_list|,
name|Rectangle
name|region
parameter_list|)
block|{
name|this
operator|.
name|columns
operator|=
name|columns
expr_stmt|;
name|this
operator|.
name|rows
operator|=
name|rows
expr_stmt|;
name|this
operator|.
name|counts
operator|=
operator|new
name|int
index|[
name|columns
operator|*
name|rows
index|]
expr_stmt|;
name|this
operator|.
name|region
operator|=
name|region
expr_stmt|;
block|}
DECL|method|getCount
specifier|public
name|int
name|getCount
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
return|return
name|counts
index|[
name|x
operator|*
name|rows
operator|+
name|y
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Heatmap{"
operator|+
name|columns
operator|+
literal|"x"
operator|+
name|rows
operator|+
literal|" "
operator|+
name|region
operator|+
literal|'}'
return|;
block|}
block|}
comment|/**    * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.    * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly    * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative    * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}    * uses when approximating what level to go to when indexing a shape given a distErrPct.    *    * @param context the IndexReader's context    * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.    * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.    *                   The<em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap    *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle    *                   -- the non-intersecting cells will all be 0.    *                   If null is given, the entire world is assumed.    * @param facetLevel the target depth (detail) of cells.    * @param maxCells the maximum number of cells to return. If the cells exceed this count, an    */
DECL|method|calcFacets
specifier|public
specifier|static
name|Heatmap
name|calcFacets
parameter_list|(
name|PrefixTreeStrategy
name|strategy
parameter_list|,
name|IndexReaderContext
name|context
parameter_list|,
name|Bits
name|topAcceptDocs
parameter_list|,
name|Shape
name|inputShape
parameter_list|,
specifier|final
name|int
name|facetLevel
parameter_list|,
name|int
name|maxCells
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|maxCells
operator|>
operator|(
name|MAX_ROWS_OR_COLUMNS
operator|*
name|MAX_ROWS_OR_COLUMNS
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxCells ("
operator|+
name|maxCells
operator|+
literal|") should be<= "
operator|+
name|MAX_ROWS_OR_COLUMNS
argument_list|)
throw|;
block|}
if|if
condition|(
name|inputShape
operator|==
literal|null
condition|)
block|{
name|inputShape
operator|=
name|strategy
operator|.
name|getSpatialContext
argument_list|()
operator|.
name|getWorldBounds
argument_list|()
expr_stmt|;
block|}
specifier|final
name|Rectangle
name|inputRect
init|=
name|inputShape
operator|.
name|getBoundingBox
argument_list|()
decl_stmt|;
comment|//First get the rect of the cell at the bottom-left at depth facetLevel
specifier|final
name|SpatialPrefixTree
name|grid
init|=
name|strategy
operator|.
name|getGrid
argument_list|()
decl_stmt|;
specifier|final
name|SpatialContext
name|ctx
init|=
name|grid
operator|.
name|getSpatialContext
argument_list|()
decl_stmt|;
specifier|final
name|Point
name|cornerPt
init|=
name|ctx
operator|.
name|makePoint
argument_list|(
name|inputRect
operator|.
name|getMinX
argument_list|()
argument_list|,
name|inputRect
operator|.
name|getMinY
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|CellIterator
name|cellIterator
init|=
name|grid
operator|.
name|getTreeCellIterator
argument_list|(
name|cornerPt
argument_list|,
name|facetLevel
argument_list|)
decl_stmt|;
name|Cell
name|cornerCell
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|cellIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|cornerCell
operator|=
name|cellIterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
assert|assert
name|cornerCell
operator|!=
literal|null
operator|&&
name|cornerCell
operator|.
name|getLevel
argument_list|()
operator|==
name|facetLevel
operator|:
literal|"Cell not at target level: "
operator|+
name|cornerCell
assert|;
specifier|final
name|Rectangle
name|cornerRect
init|=
operator|(
name|Rectangle
operator|)
name|cornerCell
operator|.
name|getShape
argument_list|()
decl_stmt|;
assert|assert
name|cornerRect
operator|.
name|hasArea
argument_list|()
assert|;
comment|//Now calculate the number of columns and rows necessary to cover the inputRect
name|double
name|heatMinX
init|=
name|cornerRect
operator|.
name|getMinX
argument_list|()
decl_stmt|;
comment|//note: we might change this below...
specifier|final
name|double
name|cellWidth
init|=
name|cornerRect
operator|.
name|getWidth
argument_list|()
decl_stmt|;
specifier|final
name|Rectangle
name|worldRect
init|=
name|ctx
operator|.
name|getWorldBounds
argument_list|()
decl_stmt|;
specifier|final
name|int
name|columns
init|=
name|calcRowsOrCols
argument_list|(
name|cellWidth
argument_list|,
name|heatMinX
argument_list|,
name|inputRect
operator|.
name|getWidth
argument_list|()
argument_list|,
name|inputRect
operator|.
name|getMinX
argument_list|()
argument_list|,
name|worldRect
operator|.
name|getWidth
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|double
name|heatMinY
init|=
name|cornerRect
operator|.
name|getMinY
argument_list|()
decl_stmt|;
specifier|final
name|double
name|cellHeight
init|=
name|cornerRect
operator|.
name|getHeight
argument_list|()
decl_stmt|;
specifier|final
name|int
name|rows
init|=
name|calcRowsOrCols
argument_list|(
name|cellHeight
argument_list|,
name|heatMinY
argument_list|,
name|inputRect
operator|.
name|getHeight
argument_list|()
argument_list|,
name|inputRect
operator|.
name|getMinY
argument_list|()
argument_list|,
name|worldRect
operator|.
name|getHeight
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|rows
operator|>
literal|0
operator|&&
name|columns
operator|>
literal|0
assert|;
if|if
condition|(
name|columns
operator|>
name|MAX_ROWS_OR_COLUMNS
operator|||
name|rows
operator|>
name|MAX_ROWS_OR_COLUMNS
operator|||
name|columns
operator|*
name|rows
operator|>
name|maxCells
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Too many cells ("
operator|+
name|columns
operator|+
literal|" x "
operator|+
name|rows
operator|+
literal|") for level "
operator|+
name|facetLevel
operator|+
literal|" shape "
operator|+
name|inputRect
argument_list|)
throw|;
block|}
comment|//Create resulting heatmap bounding rectangle& Heatmap object.
specifier|final
name|double
name|halfCellWidth
init|=
name|cellWidth
operator|/
literal|2.0
decl_stmt|;
comment|// if X world-wraps, use world bounds' range
if|if
condition|(
name|columns
operator|*
name|cellWidth
operator|+
name|halfCellWidth
operator|>
name|worldRect
operator|.
name|getWidth
argument_list|()
condition|)
block|{
name|heatMinX
operator|=
name|worldRect
operator|.
name|getMinX
argument_list|()
expr_stmt|;
block|}
name|double
name|heatMaxX
init|=
name|heatMinX
operator|+
name|columns
operator|*
name|cellWidth
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|heatMaxX
operator|-
name|worldRect
operator|.
name|getMaxX
argument_list|()
argument_list|)
operator|<
name|halfCellWidth
condition|)
block|{
comment|//numeric conditioning issue
name|heatMaxX
operator|=
name|worldRect
operator|.
name|getMaxX
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|heatMaxX
operator|>
name|worldRect
operator|.
name|getMaxX
argument_list|()
condition|)
block|{
comment|//wraps dateline (won't happen if !geo)
name|heatMaxX
operator|=
name|heatMaxX
operator|-
name|worldRect
operator|.
name|getMaxX
argument_list|()
operator|+
name|worldRect
operator|.
name|getMinX
argument_list|()
expr_stmt|;
block|}
specifier|final
name|double
name|halfCellHeight
init|=
name|cellHeight
operator|/
literal|2.0
decl_stmt|;
name|double
name|heatMaxY
init|=
name|heatMinY
operator|+
name|rows
operator|*
name|cellHeight
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|heatMaxY
operator|-
name|worldRect
operator|.
name|getMaxY
argument_list|()
argument_list|)
operator|<
name|halfCellHeight
condition|)
block|{
comment|//numeric conditioning issue
name|heatMaxY
operator|=
name|worldRect
operator|.
name|getMaxY
argument_list|()
expr_stmt|;
block|}
specifier|final
name|Heatmap
name|heatmap
init|=
operator|new
name|Heatmap
argument_list|(
name|columns
argument_list|,
name|rows
argument_list|,
name|ctx
operator|.
name|makeRectangle
argument_list|(
name|heatMinX
argument_list|,
name|heatMaxX
argument_list|,
name|heatMinY
argument_list|,
name|heatMaxY
argument_list|)
argument_list|)
decl_stmt|;
comment|//All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is
comment|// just points then there won't be any ancestors.
comment|//Facet count of ancestors covering all of the heatmap:
name|int
index|[]
name|allCellsAncestorCount
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
comment|// single-element array so it can be accumulated in the inner class
comment|//All other ancestors:
name|Map
argument_list|<
name|Rectangle
argument_list|,
name|Integer
argument_list|>
name|ancestors
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|//Now lets count some facets!
name|PrefixTreeFacetCounter
operator|.
name|compute
argument_list|(
name|strategy
argument_list|,
name|context
argument_list|,
name|topAcceptDocs
argument_list|,
name|inputShape
argument_list|,
name|facetLevel
argument_list|,
operator|new
name|PrefixTreeFacetCounter
operator|.
name|FacetVisitor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|int
name|count
parameter_list|)
block|{
specifier|final
name|double
name|heatMinX
init|=
name|heatmap
operator|.
name|region
operator|.
name|getMinX
argument_list|()
decl_stmt|;
specifier|final
name|Rectangle
name|rect
init|=
operator|(
name|Rectangle
operator|)
name|cell
operator|.
name|getShape
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|.
name|getLevel
argument_list|()
operator|==
name|facetLevel
condition|)
block|{
comment|//heatmap level; count it directly
comment|//convert to col& row
name|int
name|column
decl_stmt|;
if|if
condition|(
name|rect
operator|.
name|getMinX
argument_list|()
operator|>=
name|heatMinX
condition|)
block|{
name|column
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|round
argument_list|(
operator|(
name|rect
operator|.
name|getMinX
argument_list|()
operator|-
name|heatMinX
operator|)
operator|/
name|cellWidth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// due to dateline wrap
name|column
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|round
argument_list|(
operator|(
name|rect
operator|.
name|getMinX
argument_list|()
operator|+
literal|360
operator|-
name|heatMinX
operator|)
operator|/
name|cellWidth
argument_list|)
expr_stmt|;
block|}
name|int
name|row
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|round
argument_list|(
operator|(
name|rect
operator|.
name|getMinY
argument_list|()
operator|-
name|heatMinY
operator|)
operator|/
name|cellHeight
argument_list|)
decl_stmt|;
comment|//note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree
comment|// allows adjacent cells to overlap on the seam), so we need to skip them
if|if
condition|(
name|column
operator|<
literal|0
operator|||
name|column
operator|>=
name|heatmap
operator|.
name|columns
operator|||
name|row
operator|<
literal|0
operator|||
name|row
operator|>=
name|heatmap
operator|.
name|rows
condition|)
block|{
return|return;
block|}
comment|// increment
name|heatmap
operator|.
name|counts
index|[
name|column
operator|*
name|heatmap
operator|.
name|rows
operator|+
name|row
index|]
operator|+=
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rect
operator|.
name|relate
argument_list|(
name|heatmap
operator|.
name|region
argument_list|)
operator|==
name|SpatialRelation
operator|.
name|CONTAINS
condition|)
block|{
comment|//containing ancestor
name|allCellsAncestorCount
index|[
literal|0
index|]
operator|+=
name|count
expr_stmt|;
block|}
else|else
block|{
comment|// ancestor
comment|// note: not particularly efficient (possible put twice, and Integer wrapper); oh well
name|Integer
name|existingCount
init|=
name|ancestors
operator|.
name|put
argument_list|(
name|rect
argument_list|,
name|count
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingCount
operator|!=
literal|null
condition|)
block|{
name|ancestors
operator|.
name|put
argument_list|(
name|rect
argument_list|,
name|count
operator|+
name|existingCount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|//Update the heatmap counts with ancestor counts
comment|// Apply allCellsAncestorCount
if|if
condition|(
name|allCellsAncestorCount
index|[
literal|0
index|]
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|heatmap
operator|.
name|counts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|heatmap
operator|.
name|counts
index|[
name|i
index|]
operator|+=
name|allCellsAncestorCount
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
comment|// Apply ancestors
comment|//  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells
comment|//    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it
comment|//    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)
comment|//    and iterate them cleverly such that we just make one pass at this stage.
name|int
index|[]
name|pair
init|=
operator|new
name|int
index|[
literal|2
index|]
decl_stmt|;
comment|//output of intersectInterval
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Rectangle
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|ancestors
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Rectangle
name|rect
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|int
name|count
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|//note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)
name|intersectInterval
argument_list|(
name|heatMinY
argument_list|,
name|heatMaxY
argument_list|,
name|cellHeight
argument_list|,
name|rows
argument_list|,
name|rect
operator|.
name|getMinY
argument_list|()
argument_list|,
name|rect
operator|.
name|getMaxY
argument_list|()
argument_list|,
name|pair
argument_list|)
expr_stmt|;
specifier|final
name|int
name|startRow
init|=
name|pair
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|int
name|endRow
init|=
name|pair
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|heatmap
operator|.
name|region
operator|.
name|getCrossesDateLine
argument_list|()
condition|)
block|{
name|intersectInterval
argument_list|(
name|heatMinX
argument_list|,
name|heatMaxX
argument_list|,
name|cellWidth
argument_list|,
name|columns
argument_list|,
name|rect
operator|.
name|getMinX
argument_list|()
argument_list|,
name|rect
operator|.
name|getMaxX
argument_list|()
argument_list|,
name|pair
argument_list|)
expr_stmt|;
specifier|final
name|int
name|startCol
init|=
name|pair
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|int
name|endCol
init|=
name|pair
index|[
literal|1
index|]
decl_stmt|;
name|incrementRange
argument_list|(
name|heatmap
argument_list|,
name|startCol
argument_list|,
name|endCol
argument_list|,
name|startRow
argument_list|,
name|endRow
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//left half of dateline:
if|if
condition|(
name|rect
operator|.
name|getMaxX
argument_list|()
operator|>=
name|heatMinX
condition|)
block|{
specifier|final
name|int
name|leftColumns
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|round
argument_list|(
operator|(
literal|180
operator|-
name|heatMinX
operator|)
operator|/
name|cellWidth
argument_list|)
operator|+
literal|1
decl_stmt|;
name|intersectInterval
argument_list|(
name|heatMinX
argument_list|,
literal|180
argument_list|,
name|cellWidth
argument_list|,
name|leftColumns
argument_list|,
name|rect
operator|.
name|getMinX
argument_list|()
argument_list|,
name|rect
operator|.
name|getMaxX
argument_list|()
argument_list|,
name|pair
argument_list|)
expr_stmt|;
specifier|final
name|int
name|startCol
init|=
name|pair
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|int
name|endCol
init|=
name|pair
index|[
literal|1
index|]
decl_stmt|;
name|incrementRange
argument_list|(
name|heatmap
argument_list|,
name|startCol
argument_list|,
name|endCol
argument_list|,
name|startRow
argument_list|,
name|endRow
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
comment|//right half of dateline
if|if
condition|(
name|rect
operator|.
name|getMinY
argument_list|()
operator|<=
name|heatMaxX
condition|)
block|{
specifier|final
name|int
name|rightColumns
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|round
argument_list|(
name|heatMaxX
operator|/
name|cellWidth
argument_list|)
operator|+
literal|1
decl_stmt|;
name|intersectInterval
argument_list|(
literal|0
argument_list|,
name|heatMaxX
argument_list|,
name|cellWidth
argument_list|,
name|rightColumns
argument_list|,
name|rect
operator|.
name|getMinX
argument_list|()
argument_list|,
name|rect
operator|.
name|getMaxX
argument_list|()
argument_list|,
name|pair
argument_list|)
expr_stmt|;
specifier|final
name|int
name|startCol
init|=
name|pair
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|int
name|endCol
init|=
name|pair
index|[
literal|1
index|]
decl_stmt|;
name|incrementRange
argument_list|(
name|heatmap
argument_list|,
name|startCol
argument_list|,
name|endCol
argument_list|,
name|startRow
argument_list|,
name|endRow
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|heatmap
return|;
block|}
DECL|method|intersectInterval
specifier|private
specifier|static
name|void
name|intersectInterval
parameter_list|(
name|double
name|heatMin
parameter_list|,
name|double
name|heatMax
parameter_list|,
name|double
name|heatCellLen
parameter_list|,
name|int
name|heatLen
parameter_list|,
name|double
name|cellMin
parameter_list|,
name|double
name|cellMax
parameter_list|,
name|int
index|[]
name|out
parameter_list|)
block|{
comment|//precondition: we know there's an intersection
if|if
condition|(
name|heatMin
operator|>=
name|cellMin
condition|)
block|{
name|out
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|out
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|round
argument_list|(
operator|(
name|cellMin
operator|-
name|heatMin
operator|)
operator|/
name|heatCellLen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|heatMax
operator|<=
name|cellMax
condition|)
block|{
name|out
index|[
literal|1
index|]
operator|=
name|heatLen
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|out
index|[
literal|1
index|]
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|round
argument_list|(
operator|(
name|cellMax
operator|-
name|heatMin
operator|)
operator|/
name|heatCellLen
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
DECL|method|incrementRange
specifier|private
specifier|static
name|void
name|incrementRange
parameter_list|(
name|Heatmap
name|heatmap
parameter_list|,
name|int
name|startColumn
parameter_list|,
name|int
name|endColumn
parameter_list|,
name|int
name|startRow
parameter_list|,
name|int
name|endRow
parameter_list|,
name|int
name|count
parameter_list|)
block|{
comment|//startColumn& startRow are not necessarily within the heatmap range; likewise numRows/columns may overlap.
if|if
condition|(
name|startColumn
operator|<
literal|0
condition|)
block|{
name|endColumn
operator|+=
name|startColumn
expr_stmt|;
name|startColumn
operator|=
literal|0
expr_stmt|;
block|}
name|endColumn
operator|=
name|Math
operator|.
name|min
argument_list|(
name|heatmap
operator|.
name|columns
operator|-
literal|1
argument_list|,
name|endColumn
argument_list|)
expr_stmt|;
if|if
condition|(
name|startRow
operator|<
literal|0
condition|)
block|{
name|endRow
operator|+=
name|startRow
expr_stmt|;
name|startRow
operator|=
literal|0
expr_stmt|;
block|}
name|endRow
operator|=
name|Math
operator|.
name|min
argument_list|(
name|heatmap
operator|.
name|rows
operator|-
literal|1
argument_list|,
name|endRow
argument_list|)
expr_stmt|;
if|if
condition|(
name|startRow
operator|>
name|endRow
condition|)
block|{
return|return;
comment|//short-circuit
block|}
for|for
control|(
name|int
name|c
init|=
name|startColumn
init|;
name|c
operator|<=
name|endColumn
condition|;
name|c
operator|++
control|)
block|{
name|int
name|cBase
init|=
name|c
operator|*
name|heatmap
operator|.
name|rows
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
name|startRow
init|;
name|r
operator|<=
name|endRow
condition|;
name|r
operator|++
control|)
block|{
name|heatmap
operator|.
name|counts
index|[
name|cBase
operator|+
name|r
index|]
operator|+=
name|count
expr_stmt|;
block|}
block|}
block|}
comment|/** Computes the number of intervals (rows or columns) to cover a range given the sizes. */
DECL|method|calcRowsOrCols
specifier|private
specifier|static
name|int
name|calcRowsOrCols
parameter_list|(
name|double
name|cellRange
parameter_list|,
name|double
name|cellMin
parameter_list|,
name|double
name|requestRange
parameter_list|,
name|double
name|requestMin
parameter_list|,
name|double
name|worldRange
parameter_list|)
block|{
assert|assert
name|requestMin
operator|>=
name|cellMin
assert|;
comment|//Idealistically this wouldn't be so complicated but we concern ourselves with overflow and edge cases
name|double
name|range
init|=
operator|(
name|requestRange
operator|+
operator|(
name|requestMin
operator|-
name|cellMin
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|range
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
specifier|final
name|double
name|intervals
init|=
name|Math
operator|.
name|ceil
argument_list|(
name|range
operator|/
name|cellRange
argument_list|)
decl_stmt|;
if|if
condition|(
name|intervals
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
comment|//should result in an error soon (exceed thresholds)
block|}
comment|// ensures we don't have more intervals than world bounds (possibly due to rounding/edge issue)
specifier|final
name|long
name|intervalsMax
init|=
name|Math
operator|.
name|round
argument_list|(
name|worldRange
operator|/
name|cellRange
argument_list|)
decl_stmt|;
if|if
condition|(
name|intervalsMax
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
comment|//just return intervals
return|return
operator|(
name|int
operator|)
name|intervals
return|;
block|}
return|return
name|Math
operator|.
name|min
argument_list|(
operator|(
name|int
operator|)
name|intervalsMax
argument_list|,
operator|(
name|int
operator|)
name|intervals
argument_list|)
return|;
block|}
DECL|method|HeatmapFacetCounter
specifier|private
name|HeatmapFacetCounter
parameter_list|()
block|{   }
block|}
end_class
end_unit
