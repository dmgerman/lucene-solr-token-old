begin_unit
begin_package
DECL|package|org.apache.lucene.spatial.prefix.tree
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|prefix
operator|.
name|tree
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Shape
import|;
end_import
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|GregorianCalendar
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import
begin_comment
comment|/**  * A PrefixTree for date ranges in which the levels of the tree occur at natural periods of time (e.g. years,  * months, ...). You pass in {@link Calendar} objects with the desired fields set and the unspecified  * fields unset, which conveys the precision.  The implementation tries to be generic to the Calendar  * abstraction, making some optimizations when a Gregorian is used, but no others have been tested.  *<p/>  * Warning: If you construct a Calendar and then get something from the object like a field (e.g. year) or  * milliseconds, then every field is fully set by side-effect. So after setting the fields, pass it to this  * API first.  * @lucene.experimental  */
end_comment
begin_class
DECL|class|DateRangePrefixTree
specifier|public
class|class
name|DateRangePrefixTree
extends|extends
name|NumberRangePrefixTree
block|{
comment|/*     WARNING  java.util.Calendar is tricky to work with:     * If you "get" any field value, every fields because "set". This can introduce a Heisenbug effect,         when in a debugger in some cases. Fortunately, Calendar.toString() doesn't apply.     * Beware Calendar underflow of the underlying long.  If you create a Calendar from LONG.MIN_VALUE, and clear      a field, it will underflow and appear close to LONG.MAX_VALUE (BC to AD).      There are no doubt other reasons but those two were hard fought lessons here.      TODO Improvements:     * Make max precision configurable (i.e. to SECOND).     * Make min& max year span configurable. Use that to remove pointless top levels of the SPT.         If year span is> 10k, then add 1k year level. If year span is> 10k of 1k levels, add 1M level.     * NumberRangePrefixTree: override getTreeCellIterator for optimized case where the shape isn't a date span; use       FilterCellIterator of the cell stack.    */
DECL|field|UTC
specifier|private
specifier|static
specifier|final
name|TimeZone
name|UTC
init|=
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"UTC"
argument_list|)
decl_stmt|;
DECL|field|CAL_TMP
specifier|private
specifier|static
name|Calendar
name|CAL_TMP
decl_stmt|;
comment|//template
static|static
block|{
name|CAL_TMP
operator|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|UTC
argument_list|,
name|Locale
operator|.
name|ROOT
argument_list|)
expr_stmt|;
name|CAL_TMP
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|field|MINCAL
specifier|private
specifier|static
specifier|final
name|Calendar
name|MINCAL
init|=
operator|(
name|Calendar
operator|)
name|CAL_TMP
operator|.
name|clone
argument_list|()
decl_stmt|;
DECL|field|MAXCAL
specifier|private
specifier|static
specifier|final
name|Calendar
name|MAXCAL
init|=
operator|(
name|Calendar
operator|)
name|CAL_TMP
operator|.
name|clone
argument_list|()
decl_stmt|;
static|static
block|{
name|MINCAL
operator|.
name|setTimeInMillis
argument_list|(
name|Long
operator|.
name|MIN_VALUE
argument_list|)
expr_stmt|;
name|MAXCAL
operator|.
name|setTimeInMillis
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
comment|//BC years are decreasing, remember.  Yet ActualMaximum is the numerically high value, ActualMinimum is 1.
DECL|field|BC_FIRSTYEAR
specifier|private
specifier|static
specifier|final
name|int
name|BC_FIRSTYEAR
init|=
name|MINCAL
operator|.
name|getActualMaximum
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
decl_stmt|;
DECL|field|BC_LASTYEAR
specifier|private
specifier|static
specifier|final
name|int
name|BC_LASTYEAR
init|=
name|MINCAL
operator|.
name|getActualMinimum
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
decl_stmt|;
comment|//1
DECL|field|BC_YEARS
specifier|private
specifier|static
specifier|final
name|int
name|BC_YEARS
init|=
name|BC_FIRSTYEAR
operator|-
name|BC_LASTYEAR
operator|+
literal|1
decl_stmt|;
DECL|field|AD_FIRSTYEAR
specifier|private
specifier|static
specifier|final
name|int
name|AD_FIRSTYEAR
init|=
name|MAXCAL
operator|.
name|getActualMinimum
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
decl_stmt|;
comment|//1
DECL|field|AD_LASTYEAR
specifier|private
specifier|static
specifier|final
name|int
name|AD_LASTYEAR
init|=
name|MAXCAL
operator|.
name|getActualMaximum
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
decl_stmt|;
DECL|field|AD_YEAR_BASE
specifier|private
specifier|static
specifier|final
name|int
name|AD_YEAR_BASE
init|=
operator|(
operator|(
operator|(
name|BC_YEARS
operator|-
literal|1
operator|)
operator|/
literal|1000_000
operator|)
operator|+
literal|1
operator|)
operator|*
literal|1000_000
decl_stmt|;
static|static
block|{
assert|assert
name|BC_LASTYEAR
operator|==
literal|1
operator|&&
name|AD_FIRSTYEAR
operator|==
literal|1
assert|;
block|}
comment|//how many million years are there?
DECL|field|NUM_MYEARS
specifier|private
specifier|static
specifier|final
name|int
name|NUM_MYEARS
init|=
operator|(
name|AD_YEAR_BASE
operator|+
name|AD_LASTYEAR
operator|)
operator|/
literal|1000_000
decl_stmt|;
DECL|method|calFieldLen
specifier|private
specifier|static
name|int
name|calFieldLen
parameter_list|(
name|int
name|field
parameter_list|)
block|{
return|return
name|CAL_TMP
operator|.
name|getMaximum
argument_list|(
name|field
argument_list|)
operator|-
name|CAL_TMP
operator|.
name|getMinimum
argument_list|(
name|field
argument_list|)
operator|+
literal|1
return|;
block|}
DECL|field|FIELD_BY_LEVEL
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|FIELD_BY_LEVEL
init|=
block|{
operator|-
literal|1
comment|/*unused*/
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Calendar
operator|.
name|YEAR
block|,
name|Calendar
operator|.
name|MONTH
block|,
name|Calendar
operator|.
name|DAY_OF_MONTH
block|,
name|Calendar
operator|.
name|HOUR_OF_DAY
block|,
name|Calendar
operator|.
name|MINUTE
block|,
name|Calendar
operator|.
name|SECOND
block|,
name|Calendar
operator|.
name|MILLISECOND
block|}
decl_stmt|;
DECL|field|yearLevel
specifier|private
specifier|static
specifier|final
name|int
name|yearLevel
init|=
literal|3
decl_stmt|;
DECL|field|INSTANCE
specifier|public
specifier|static
specifier|final
name|DateRangePrefixTree
name|INSTANCE
init|=
operator|new
name|DateRangePrefixTree
argument_list|()
decl_stmt|;
DECL|field|minLV
DECL|field|maxLV
specifier|private
specifier|final
name|LevelledValue
name|minLV
decl_stmt|,
name|maxLV
decl_stmt|;
DECL|field|gregorianChangeDateLV
specifier|private
specifier|final
name|LevelledValue
name|gregorianChangeDateLV
decl_stmt|;
DECL|method|DateRangePrefixTree
specifier|private
name|DateRangePrefixTree
parameter_list|()
block|{
name|super
argument_list|(
operator|new
name|int
index|[]
block|{
comment|//sublevels by level
name|NUM_MYEARS
block|,
literal|1000
block|,
comment|//1 thousand thousand-years in a million years
literal|1000
block|,
comment|//1 thousand years in a thousand-year
name|calFieldLen
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|)
block|,
name|calFieldLen
argument_list|(
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|)
block|,
name|calFieldLen
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|)
block|,
name|calFieldLen
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|)
block|,
name|calFieldLen
argument_list|(
name|Calendar
operator|.
name|SECOND
argument_list|)
block|,
name|calFieldLen
argument_list|(
name|Calendar
operator|.
name|MILLISECOND
argument_list|)
block|,     }
argument_list|)
expr_stmt|;
name|maxLV
operator|=
operator|(
name|LevelledValue
operator|)
name|toShape
argument_list|(
operator|(
name|Calendar
operator|)
name|MAXCAL
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
name|minLV
operator|=
operator|(
name|LevelledValue
operator|)
name|toShape
argument_list|(
operator|(
name|Calendar
operator|)
name|MINCAL
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAXCAL
operator|instanceof
name|GregorianCalendar
condition|)
block|{
comment|//TODO this should be a configurable param by passing a Calendar surving as a template.
name|GregorianCalendar
name|gCal
init|=
operator|(
name|GregorianCalendar
operator|)
name|MAXCAL
decl_stmt|;
name|gregorianChangeDateLV
operator|=
operator|(
name|LevelledValue
operator|)
name|toShape
argument_list|(
name|gCal
operator|.
name|getGregorianChange
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gregorianChangeDateLV
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getNumSubCells
specifier|protected
name|int
name|getNumSubCells
parameter_list|(
name|LevelledValue
name|lv
parameter_list|)
block|{
name|int
name|cmp
init|=
name|comparePrefixLV
argument_list|(
name|lv
argument_list|,
name|maxLV
argument_list|)
decl_stmt|;
assert|assert
name|cmp
operator|<=
literal|0
assert|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
comment|//edge case (literally!)
return|return
name|maxLV
operator|.
name|getValAtLevel
argument_list|(
name|lv
operator|.
name|getLevel
argument_list|()
operator|+
literal|1
argument_list|)
return|;
comment|// if using GregorianCalendar and we're after the "Gregorian change date" then we'll compute
comment|//  the sub-cells ourselves more efficiently without the need to construct a Calendar.
name|cmp
operator|=
name|gregorianChangeDateLV
operator|!=
literal|null
condition|?
name|comparePrefixLV
argument_list|(
name|lv
argument_list|,
name|gregorianChangeDateLV
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
comment|//TODO consider also doing fast-path if field is<= hours even if before greg change date
if|if
condition|(
name|cmp
operator|>=
literal|0
condition|)
block|{
name|int
name|result
init|=
name|fastSubCells
argument_list|(
name|lv
argument_list|)
decl_stmt|;
assert|assert
name|result
operator|==
name|slowSubCells
argument_list|(
name|lv
argument_list|)
operator|:
literal|"fast/slow numSubCells inconsistency"
assert|;
return|return
name|result
return|;
block|}
else|else
block|{
return|return
name|slowSubCells
argument_list|(
name|lv
argument_list|)
return|;
block|}
block|}
DECL|method|fastSubCells
specifier|private
name|int
name|fastSubCells
parameter_list|(
name|LevelledValue
name|lv
parameter_list|)
block|{
if|if
condition|(
name|lv
operator|.
name|getLevel
argument_list|()
operator|==
name|yearLevel
operator|+
literal|1
condition|)
block|{
comment|//month
switch|switch
condition|(
name|lv
operator|.
name|getValAtLevel
argument_list|(
name|lv
operator|.
name|getLevel
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|Calendar
operator|.
name|SEPTEMBER
case|:
case|case
name|Calendar
operator|.
name|APRIL
case|:
case|case
name|Calendar
operator|.
name|JUNE
case|:
case|case
name|Calendar
operator|.
name|NOVEMBER
case|:
return|return
literal|30
return|;
case|case
name|Calendar
operator|.
name|FEBRUARY
case|:
comment|//get the year (negative numbers for BC)
name|int
name|yearAdj
init|=
name|lv
operator|.
name|getValAtLevel
argument_list|(
literal|1
argument_list|)
operator|*
literal|1_000_000
decl_stmt|;
name|yearAdj
operator|+=
name|lv
operator|.
name|getValAtLevel
argument_list|(
literal|2
argument_list|)
operator|*
literal|1000
expr_stmt|;
name|yearAdj
operator|+=
name|lv
operator|.
name|getValAtLevel
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|int
name|year
init|=
name|yearAdj
operator|-
name|AD_YEAR_BASE
decl_stmt|;
if|if
condition|(
name|year
operator|%
literal|4
operator|==
literal|0
operator|&&
operator|!
operator|(
name|year
operator|%
literal|100
operator|==
literal|0
operator|&&
name|year
operator|%
literal|400
operator|!=
literal|0
operator|)
condition|)
comment|//leap year
return|return
literal|29
return|;
else|else
return|return
literal|28
return|;
default|default:
return|return
literal|31
return|;
block|}
block|}
else|else
block|{
comment|//typical:
return|return
name|super
operator|.
name|getNumSubCells
argument_list|(
name|lv
argument_list|)
return|;
block|}
block|}
DECL|method|slowSubCells
specifier|private
name|int
name|slowSubCells
parameter_list|(
name|LevelledValue
name|lv
parameter_list|)
block|{
name|int
name|field
init|=
name|FIELD_BY_LEVEL
index|[
name|lv
operator|.
name|getLevel
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
comment|//short-circuit optimization (GregorianCalendar assumptions)
if|if
condition|(
name|field
operator|==
operator|-
literal|1
operator|||
name|field
operator|==
name|Calendar
operator|.
name|YEAR
operator|||
name|field
operator|>=
name|Calendar
operator|.
name|HOUR_OF_DAY
condition|)
comment|//TODO make configurable
return|return
name|super
operator|.
name|getNumSubCells
argument_list|(
name|lv
argument_list|)
return|;
name|Calendar
name|cal
init|=
name|toCalendarLV
argument_list|(
name|lv
argument_list|)
decl_stmt|;
comment|//somewhat heavyweight op; ideally should be stored on LevelledValue somehow
return|return
name|cal
operator|.
name|getActualMaximum
argument_list|(
name|field
argument_list|)
operator|-
name|cal
operator|.
name|getActualMinimum
argument_list|(
name|field
argument_list|)
operator|+
literal|1
return|;
block|}
comment|/** Calendar utility method:    * Returns a new {@link Calendar} in UTC TimeZone, ROOT Locale, with all fields cleared. */
DECL|method|newCal
specifier|public
name|Calendar
name|newCal
parameter_list|()
block|{
return|return
operator|(
name|Calendar
operator|)
name|CAL_TMP
operator|.
name|clone
argument_list|()
return|;
block|}
comment|/** Calendar utility method:    * Gets the Calendar field code of the last field that is set prior to an unset field. It only    * examines fields relevant to the prefix tree. If no fields are set, it returns -1. */
DECL|method|getCalPrecisionField
specifier|public
name|int
name|getCalPrecisionField
parameter_list|(
name|Calendar
name|cal
parameter_list|)
block|{
name|int
name|lastField
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
name|yearLevel
init|;
name|level
operator|<
name|FIELD_BY_LEVEL
operator|.
name|length
condition|;
name|level
operator|++
control|)
block|{
name|int
name|field
init|=
name|FIELD_BY_LEVEL
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|cal
operator|.
name|isSet
argument_list|(
name|field
argument_list|)
condition|)
break|break;
name|lastField
operator|=
name|field
expr_stmt|;
block|}
return|return
name|lastField
return|;
block|}
comment|/** Calendar utility method:    * Calls {@link Calendar#clear(int)} for every field after {@code field}. Beware of Calendar underflow. */
DECL|method|clearFieldsAfter
specifier|public
name|void
name|clearFieldsAfter
parameter_list|(
name|Calendar
name|cal
parameter_list|,
name|int
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|==
operator|-
literal|1
condition|)
block|{
name|cal
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
name|int
name|assertEra
init|=
operator|-
literal|1
decl_stmt|;
assert|assert
operator|(
name|assertEra
operator|=
operator|(
operator|(
operator|(
name|Calendar
operator|)
name|cal
operator|.
name|clone
argument_list|()
operator|)
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|)
operator|)
operator|)
operator|>=
literal|0
assert|;
comment|//a trick to only get this if assert enabled
for|for
control|(
name|int
name|f
init|=
name|field
operator|+
literal|1
init|;
name|f
operator|<
name|Calendar
operator|.
name|FIELD_COUNT
condition|;
name|f
operator|++
control|)
block|{
name|cal
operator|.
name|clear
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
assert|assert
operator|(
operator|(
name|Calendar
operator|)
name|cal
operator|.
name|clone
argument_list|()
operator|)
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|)
operator|==
name|assertEra
operator|:
literal|"Calendar underflow"
assert|;
block|}
comment|/** Converts {@code value} from a {@link Calendar} or {@link Date} to a {@link Shape}. Other arguments    * result in a {@link java.lang.IllegalArgumentException}.    */
annotation|@
name|Override
DECL|method|toShape
specifier|public
name|Shape
name|toShape
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Calendar
condition|)
block|{
return|return
name|toShape
argument_list|(
operator|(
name|Calendar
operator|)
name|value
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Date
condition|)
block|{
name|Calendar
name|cal
init|=
name|newCal
argument_list|()
decl_stmt|;
name|cal
operator|.
name|setTime
argument_list|(
operator|(
name|Date
operator|)
name|value
argument_list|)
expr_stmt|;
return|return
name|toShape
argument_list|(
name|cal
argument_list|)
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting Calendar or Date but got: "
operator|+
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
comment|/** Converts the Calendar into a Shape.    * The isSet() state of the Calendar is re-instated when done. */
DECL|method|toShape
specifier|public
name|Shape
name|toShape
parameter_list|(
name|Calendar
name|cal
parameter_list|)
block|{
comment|// Convert a Calendar into a stack of cell numbers
specifier|final
name|int
name|calPrecField
init|=
name|getCalPrecisionField
argument_list|(
name|cal
argument_list|)
decl_stmt|;
comment|//must call first; getters set all fields
try|try
block|{
name|int
index|[]
name|valStack
init|=
operator|new
name|int
index|[
name|maxLevels
index|]
decl_stmt|;
comment|//starts at level 1, not 0
name|int
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|calPrecField
operator|>=
name|Calendar
operator|.
name|YEAR
condition|)
block|{
comment|//year or better precision
name|int
name|year
init|=
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
decl_stmt|;
name|int
name|yearAdj
init|=
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|)
operator|==
literal|0
condition|?
name|AD_YEAR_BASE
operator|-
operator|(
name|year
operator|-
literal|1
operator|)
else|:
name|AD_YEAR_BASE
operator|+
name|year
decl_stmt|;
name|valStack
index|[
name|len
operator|++
index|]
operator|=
name|yearAdj
operator|/
literal|1000_000
expr_stmt|;
name|yearAdj
operator|-=
name|valStack
index|[
name|len
operator|-
literal|1
index|]
operator|*
literal|1000_000
expr_stmt|;
name|valStack
index|[
name|len
operator|++
index|]
operator|=
name|yearAdj
operator|/
literal|1000
expr_stmt|;
name|yearAdj
operator|-=
name|valStack
index|[
name|len
operator|-
literal|1
index|]
operator|*
literal|1000
expr_stmt|;
name|valStack
index|[
name|len
operator|++
index|]
operator|=
name|yearAdj
expr_stmt|;
for|for
control|(
name|int
name|level
init|=
name|yearLevel
operator|+
literal|1
init|;
name|level
operator|<
name|FIELD_BY_LEVEL
operator|.
name|length
condition|;
name|level
operator|++
control|)
block|{
name|int
name|field
init|=
name|FIELD_BY_LEVEL
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|field
operator|>
name|calPrecField
condition|)
break|break;
name|valStack
index|[
name|len
operator|++
index|]
operator|=
name|cal
operator|.
name|get
argument_list|(
name|field
argument_list|)
operator|-
name|cal
operator|.
name|getActualMinimum
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|toShape
argument_list|(
name|valStack
argument_list|,
name|len
argument_list|)
return|;
block|}
finally|finally
block|{
name|clearFieldsAfter
argument_list|(
name|cal
argument_list|,
name|calPrecField
argument_list|)
expr_stmt|;
comment|//restore precision state modified by get()
block|}
block|}
DECL|method|toCalendar
specifier|public
name|Calendar
name|toCalendar
parameter_list|(
name|Shape
name|shape
parameter_list|)
block|{
if|if
condition|(
name|shape
operator|instanceof
name|LevelledValue
condition|)
return|return
name|toCalendarLV
argument_list|(
operator|(
name|LevelledValue
operator|)
name|shape
argument_list|)
return|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't be converted to Calendar: "
operator|+
name|shape
argument_list|)
throw|;
block|}
DECL|method|toCalendarLV
specifier|private
name|Calendar
name|toCalendarLV
parameter_list|(
name|LevelledValue
name|lv
parameter_list|)
block|{
if|if
condition|(
name|lv
operator|.
name|getLevel
argument_list|()
operator|==
literal|0
condition|)
return|return
name|newCal
argument_list|()
return|;
if|if
condition|(
name|comparePrefixLV
argument_list|(
name|lv
argument_list|,
name|minLV
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|//shouldn't typically happen; sometimes in a debugger
return|return
operator|(
name|Calendar
operator|)
name|MINCAL
operator|.
name|clone
argument_list|()
return|;
comment|//full precision; truncation would cause underflow
block|}
assert|assert
name|comparePrefixLV
argument_list|(
name|lv
argument_list|,
name|maxLV
argument_list|)
operator|<=
literal|0
assert|;
name|Calendar
name|cal
init|=
name|newCal
argument_list|()
decl_stmt|;
name|int
name|yearAdj
init|=
name|lv
operator|.
name|getValAtLevel
argument_list|(
literal|1
argument_list|)
operator|*
literal|1_000_000
decl_stmt|;
if|if
condition|(
name|lv
operator|.
name|getLevel
argument_list|()
operator|>
literal|1
condition|)
block|{
name|yearAdj
operator|+=
name|lv
operator|.
name|getValAtLevel
argument_list|(
literal|2
argument_list|)
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
name|lv
operator|.
name|getLevel
argument_list|()
operator|>
literal|2
condition|)
block|{
name|yearAdj
operator|+=
name|lv
operator|.
name|getValAtLevel
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|yearAdj
operator|>
name|AD_YEAR_BASE
condition|)
block|{
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|,
name|yearAdj
operator|-
name|AD_YEAR_BASE
argument_list|)
expr_stmt|;
comment|//setting the year resets the era
block|}
else|else
block|{
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|//we assert this "sticks" at the end
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|,
operator|(
name|AD_YEAR_BASE
operator|-
name|yearAdj
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|level
init|=
name|yearLevel
operator|+
literal|1
init|;
name|level
operator|<=
name|lv
operator|.
name|getLevel
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
name|int
name|field
init|=
name|FIELD_BY_LEVEL
index|[
name|level
index|]
decl_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|field
argument_list|,
name|lv
operator|.
name|getValAtLevel
argument_list|(
name|level
argument_list|)
operator|+
name|cal
operator|.
name|getActualMinimum
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
assert|assert
name|yearAdj
operator|>
name|AD_YEAR_BASE
operator|||
operator|(
operator|(
name|Calendar
operator|)
name|cal
operator|.
name|clone
argument_list|()
operator|)
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|)
operator|==
literal|0
operator|:
literal|"ERA / YEAR underflow"
assert|;
return|return
name|cal
return|;
block|}
annotation|@
name|Override
DECL|method|toStringLV
specifier|protected
name|String
name|toStringLV
parameter_list|(
name|LevelledValue
name|lv
parameter_list|)
block|{
return|return
name|toString
argument_list|(
name|toCalendarLV
argument_list|(
name|lv
argument_list|)
argument_list|)
return|;
block|}
comment|/** Calendar utility method:    * Converts to calendar to ISO-8601, to include proper BC handling (1BC is "0000", 2BC is "-0001", etc.);    * and WITHOUT a trailing 'Z'.    * A fully cleared calendar will yield the string "*".    * The isSet() state of the Calendar is re-instated when done. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"fallthrough"
argument_list|)
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|(
name|Calendar
name|cal
parameter_list|)
block|{
specifier|final
name|int
name|calPrecField
init|=
name|getCalPrecisionField
argument_list|(
name|cal
argument_list|)
decl_stmt|;
comment|//must call first; getters set all fields
if|if
condition|(
name|calPrecField
operator|==
operator|-
literal|1
condition|)
return|return
literal|"*"
return|;
try|try
block|{
comment|//TODO not fully optimized because I only expect this to be used in tests / debugging.
comment|//  Borrow code from Solr DateUtil, and have it reference this back?
name|String
name|pattern
init|=
literal|"yyyy-MM-dd'T'HH:mm:ss.SSS"
decl_stmt|;
name|int
name|ptnLen
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|calPrecField
condition|)
block|{
comment|//switch fall-through is deliberate
case|case
name|Calendar
operator|.
name|MILLISECOND
case|:
name|ptnLen
operator|+=
literal|4
expr_stmt|;
case|case
name|Calendar
operator|.
name|SECOND
case|:
name|ptnLen
operator|+=
literal|3
expr_stmt|;
case|case
name|Calendar
operator|.
name|MINUTE
case|:
name|ptnLen
operator|+=
literal|3
expr_stmt|;
case|case
name|Calendar
operator|.
name|HOUR_OF_DAY
case|:
name|ptnLen
operator|+=
literal|5
expr_stmt|;
case|case
name|Calendar
operator|.
name|DAY_OF_MONTH
case|:
name|ptnLen
operator|+=
literal|3
expr_stmt|;
case|case
name|Calendar
operator|.
name|MONTH
case|:
name|ptnLen
operator|+=
literal|3
expr_stmt|;
case|case
name|Calendar
operator|.
name|YEAR
case|:
name|ptnLen
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|""
operator|+
name|calPrecField
argument_list|)
throw|;
block|}
name|pattern
operator|=
name|pattern
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|ptnLen
argument_list|)
expr_stmt|;
name|SimpleDateFormat
name|format
init|=
operator|new
name|SimpleDateFormat
argument_list|(
name|pattern
argument_list|,
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
name|format
operator|.
name|setTimeZone
argument_list|(
name|cal
operator|.
name|getTimeZone
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|//BC
comment|//SDF doesn't do this properly according to ISO-8601
comment|// Example: 1BC == "0000" (actually 0 AD), 2BC == "-0001", 3BC == "-0002", ...
specifier|final
name|int
name|yearOrig
init|=
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
decl_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|,
name|yearOrig
operator|-
literal|1
argument_list|)
expr_stmt|;
name|String
name|str
decl_stmt|;
try|try
block|{
name|str
operator|=
name|format
operator|.
name|format
argument_list|(
name|cal
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|//reset to what it was
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|//necessary!
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|,
name|yearOrig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yearOrig
operator|>
literal|1
condition|)
return|return
literal|"-"
operator|+
name|str
return|;
else|else
return|return
literal|"0000"
operator|+
name|str
operator|.
name|substring
argument_list|(
literal|4
argument_list|)
return|;
block|}
return|return
name|format
operator|.
name|format
argument_list|(
name|cal
operator|.
name|getTime
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|clearFieldsAfter
argument_list|(
name|cal
argument_list|,
name|calPrecField
argument_list|)
expr_stmt|;
comment|//restore precision state modified by get()
block|}
block|}
annotation|@
name|Override
DECL|method|parseShapeLV
specifier|protected
name|LevelledValue
name|parseShapeLV
parameter_list|(
name|String
name|str
parameter_list|)
throws|throws
name|ParseException
block|{
return|return
operator|(
name|LevelledValue
operator|)
name|toShape
argument_list|(
name|parseCalendar
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
block|}
comment|/** Calendar utility method:    * The reverse of {@link #toString(java.util.Calendar)}. It will only set the fields found, leaving    * the remainder in an un-set state. A leading '-' or '+' is optional (positive assumed), and a    * trailing 'Z' is also optional.    * @param str not null and not empty    * @return not null    */
DECL|method|parseCalendar
specifier|public
name|Calendar
name|parseCalendar
parameter_list|(
name|String
name|str
parameter_list|)
throws|throws
name|ParseException
block|{
comment|// example: +2014-10-23T21:22:33.159Z
if|if
condition|(
name|str
operator|==
literal|null
operator|||
name|str
operator|.
name|isEmpty
argument_list|()
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"str is null or blank"
argument_list|)
throw|;
name|Calendar
name|cal
init|=
name|newCal
argument_list|()
decl_stmt|;
if|if
condition|(
name|str
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
condition|)
return|return
name|cal
return|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|//a pointer
try|try
block|{
comment|//year& era:
name|int
name|lastOffset
init|=
name|str
operator|.
name|charAt
argument_list|(
name|str
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'Z'
condition|?
name|str
operator|.
name|length
argument_list|()
operator|-
literal|1
else|:
name|str
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|hyphenIdx
init|=
name|str
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|//look past possible leading hyphen
if|if
condition|(
name|hyphenIdx
operator|<
literal|0
condition|)
name|hyphenIdx
operator|=
name|lastOffset
expr_stmt|;
name|int
name|year
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|offset
argument_list|,
name|hyphenIdx
argument_list|)
argument_list|)
decl_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|,
name|year
operator|<=
literal|0
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|,
name|year
operator|<=
literal|0
condition|?
operator|-
literal|1
operator|*
name|year
operator|+
literal|1
else|:
name|year
argument_list|)
expr_stmt|;
name|offset
operator|=
name|hyphenIdx
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lastOffset
operator|<
name|offset
condition|)
return|return
name|cal
return|;
comment|//NOTE: We aren't validating separator chars, and we unintentionally accept leading +/-.
comment|// The str.substring()'s hopefully get optimized to be stack-allocated.
comment|//month:
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//starts at 0
name|offset
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|lastOffset
operator|<
name|offset
condition|)
return|return
name|cal
return|;
comment|//day:
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|lastOffset
operator|<
name|offset
condition|)
return|return
name|cal
return|;
comment|//hour:
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|lastOffset
operator|<
name|offset
condition|)
return|return
name|cal
return|;
comment|//minute:
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|lastOffset
operator|<
name|offset
condition|)
return|return
name|cal
return|;
comment|//second:
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|SECOND
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|lastOffset
operator|<
name|offset
condition|)
return|return
name|cal
return|;
comment|//ms:
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MILLISECOND
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|3
expr_stmt|;
comment|//last one, move to next char
if|if
condition|(
name|lastOffset
operator|==
name|offset
condition|)
return|return
name|cal
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|ParseException
name|pe
init|=
operator|new
name|ParseException
argument_list|(
literal|"Improperly formatted date: "
operator|+
name|str
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|pe
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|pe
throw|;
block|}
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Improperly formatted date: "
operator|+
name|str
argument_list|,
name|offset
argument_list|)
throw|;
block|}
block|}
end_class
end_unit
