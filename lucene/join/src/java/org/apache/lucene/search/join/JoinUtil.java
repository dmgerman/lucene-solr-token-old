begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.search.join
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|join
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BiConsumer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|LongFunction
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|DoublePoint
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
operator|.
name|LegacyNumericType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FloatPoint
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|IntPoint
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|LongPoint
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|BinaryDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValuesType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|NumericDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedNumericDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedSetDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Collector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|MatchNoDocsQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|PointInSetQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Scorer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|SimpleCollector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|join
operator|.
name|DocValuesTermsCollector
operator|.
name|Function
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_comment
comment|/**  * Utility for query time joining.  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|JoinUtil
specifier|public
specifier|final
class|class
name|JoinUtil
block|{
comment|// No instances allowed
DECL|method|JoinUtil
specifier|private
name|JoinUtil
parameter_list|()
block|{   }
comment|/**    * Method for query time joining.    *<p>    * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the    * to field that match with documents matching the specified fromQuery and have the same terms in the from field.    *<p>    * In the case a single document relates to more than one document the<code>multipleValuesPerDocument</code> option    * should be set to true. When the<code>multipleValuesPerDocument</code> is set to<code>true</code> only the    * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.    * Even in the case when a second join value related to a specific document yields a higher score. Obviously this    * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.    *<p>    * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode    * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.    * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique    * join value.    *    * @param fromField                 The from field to join from    * @param multipleValuesPerDocument Whether the from field has multiple terms per document    * @param toField                   The to field to join to    * @param fromQuery                 The query to match documents on the from side    * @param fromSearcher              The searcher that executed the specified fromQuery    * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query    * @return a {@link Query} instance that can be used to join documents based on the    *         terms in the from and to field    * @throws IOException If I/O related errors occur    */
DECL|method|createJoinQuery
specifier|public
specifier|static
name|Query
name|createJoinQuery
parameter_list|(
name|String
name|fromField
parameter_list|,
name|boolean
name|multipleValuesPerDocument
parameter_list|,
name|String
name|toField
parameter_list|,
name|Query
name|fromQuery
parameter_list|,
name|IndexSearcher
name|fromSearcher
parameter_list|,
name|ScoreMode
name|scoreMode
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|GenericTermsCollector
name|termsWithScoreCollector
decl_stmt|;
if|if
condition|(
name|multipleValuesPerDocument
condition|)
block|{
name|Function
argument_list|<
name|SortedSetDocValues
argument_list|>
name|mvFunction
init|=
name|DocValuesTermsCollector
operator|.
name|sortedSetDocValues
argument_list|(
name|fromField
argument_list|)
decl_stmt|;
name|termsWithScoreCollector
operator|=
name|GenericTermsCollector
operator|.
name|createCollectorMV
argument_list|(
name|mvFunction
argument_list|,
name|scoreMode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Function
argument_list|<
name|BinaryDocValues
argument_list|>
name|svFunction
init|=
name|DocValuesTermsCollector
operator|.
name|binaryDocValues
argument_list|(
name|fromField
argument_list|)
decl_stmt|;
name|termsWithScoreCollector
operator|=
name|GenericTermsCollector
operator|.
name|createCollectorSV
argument_list|(
name|svFunction
argument_list|,
name|scoreMode
argument_list|)
expr_stmt|;
block|}
return|return
name|createJoinQuery
argument_list|(
name|multipleValuesPerDocument
argument_list|,
name|toField
argument_list|,
name|fromQuery
argument_list|,
name|fromSearcher
argument_list|,
name|scoreMode
argument_list|,
name|termsWithScoreCollector
argument_list|)
return|;
block|}
comment|/**    * @deprecated Because {@link LegacyNumericType} is deprecated, instead use {@link #createJoinQuery(String, boolean, String, Class, Query, IndexSearcher, ScoreMode)}    *    * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints.     * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,    * though memory consumption might be higher.    *<p>    *    * @param fromField                 The from field to join from    * @param multipleValuesPerDocument Whether the from field has multiple terms per document    *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},    *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}    * @param toField                   The to field to join to, should be {@link org.apache.lucene.document.LegacyIntField} or {@link org.apache.lucene.document.LegacyLongField}    * @param numericType               either {@link org.apache.lucene.document.FieldType.LegacyNumericType#INT} or {@link org.apache.lucene.document.FieldType.LegacyNumericType#LONG}, it should correspond to fromField and toField types    * @param fromQuery                 The query to match documents on the from side    * @param fromSearcher              The searcher that executed the specified fromQuery    * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query    * @return a {@link Query} instance that can be used to join documents based on the    *         terms in the from and to field    * @throws IOException If I/O related errors occur    */
annotation|@
name|Deprecated
DECL|method|createJoinQuery
specifier|public
specifier|static
name|Query
name|createJoinQuery
parameter_list|(
name|String
name|fromField
parameter_list|,
name|boolean
name|multipleValuesPerDocument
parameter_list|,
name|String
name|toField
parameter_list|,
name|LegacyNumericType
name|numericType
parameter_list|,
name|Query
name|fromQuery
parameter_list|,
name|IndexSearcher
name|fromSearcher
parameter_list|,
name|ScoreMode
name|scoreMode
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|GenericTermsCollector
name|termsCollector
decl_stmt|;
if|if
condition|(
name|multipleValuesPerDocument
condition|)
block|{
name|Function
argument_list|<
name|SortedSetDocValues
argument_list|>
name|mvFunction
init|=
name|DocValuesTermsCollector
operator|.
name|sortedNumericAsSortedSetDocValues
argument_list|(
name|fromField
argument_list|,
name|numericType
argument_list|)
decl_stmt|;
name|termsCollector
operator|=
name|GenericTermsCollector
operator|.
name|createCollectorMV
argument_list|(
name|mvFunction
argument_list|,
name|scoreMode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Function
argument_list|<
name|BinaryDocValues
argument_list|>
name|svFunction
init|=
name|DocValuesTermsCollector
operator|.
name|numericAsBinaryDocValues
argument_list|(
name|fromField
argument_list|,
name|numericType
argument_list|)
decl_stmt|;
name|termsCollector
operator|=
name|GenericTermsCollector
operator|.
name|createCollectorSV
argument_list|(
name|svFunction
argument_list|,
name|scoreMode
argument_list|)
expr_stmt|;
block|}
return|return
name|createJoinQuery
argument_list|(
name|multipleValuesPerDocument
argument_list|,
name|toField
argument_list|,
name|fromQuery
argument_list|,
name|fromSearcher
argument_list|,
name|scoreMode
argument_list|,
name|termsCollector
argument_list|)
return|;
block|}
comment|/**    * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.    * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,    * though memory consumption might be higher.    *<p>    *    * @param fromField                 The from field to join from    * @param multipleValuesPerDocument Whether the from field has multiple terms per document    *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},    *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}    * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}    *                                  or {@link DoublePoint}.    * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}    *                                  or {@link java.lang.Double} it should correspond to toField types    * @param fromQuery                 The query to match documents on the from side    * @param fromSearcher              The searcher that executed the specified fromQuery    * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query    * @return a {@link Query} instance that can be used to join documents based on the    *         terms in the from and to field    * @throws IOException If I/O related errors occur    */
DECL|method|createJoinQuery
specifier|public
specifier|static
name|Query
name|createJoinQuery
parameter_list|(
name|String
name|fromField
parameter_list|,
name|boolean
name|multipleValuesPerDocument
parameter_list|,
name|String
name|toField
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Number
argument_list|>
name|numericType
parameter_list|,
name|Query
name|fromQuery
parameter_list|,
name|IndexSearcher
name|fromSearcher
parameter_list|,
name|ScoreMode
name|scoreMode
parameter_list|)
throws|throws
name|IOException
block|{
name|TreeSet
argument_list|<
name|Long
argument_list|>
name|joinValues
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Long
argument_list|,
name|Float
argument_list|>
name|aggregatedScores
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
name|occurrences
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|needsScore
init|=
name|scoreMode
operator|!=
name|ScoreMode
operator|.
name|None
decl_stmt|;
name|BiConsumer
argument_list|<
name|Long
argument_list|,
name|Float
argument_list|>
name|scoreAggregator
decl_stmt|;
if|if
condition|(
name|scoreMode
operator|==
name|ScoreMode
operator|.
name|Max
condition|)
block|{
name|scoreAggregator
operator|=
parameter_list|(
name|key
parameter_list|,
name|score
parameter_list|)
lambda|->
block|{
name|Float
name|currentValue
init|=
name|aggregatedScores
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
name|score
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentValue
operator|!=
literal|null
condition|)
block|{
name|aggregatedScores
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|currentValue
argument_list|,
name|score
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scoreMode
operator|==
name|ScoreMode
operator|.
name|Min
condition|)
block|{
name|scoreAggregator
operator|=
parameter_list|(
name|key
parameter_list|,
name|score
parameter_list|)
lambda|->
block|{
name|Float
name|currentValue
init|=
name|aggregatedScores
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
name|score
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentValue
operator|!=
literal|null
condition|)
block|{
name|aggregatedScores
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|currentValue
argument_list|,
name|score
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scoreMode
operator|==
name|ScoreMode
operator|.
name|Total
condition|)
block|{
name|scoreAggregator
operator|=
parameter_list|(
name|key
parameter_list|,
name|score
parameter_list|)
lambda|->
block|{
name|Float
name|currentValue
init|=
name|aggregatedScores
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
name|score
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentValue
operator|!=
literal|null
condition|)
block|{
name|aggregatedScores
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|currentValue
operator|+
name|score
argument_list|)
expr_stmt|;
block|}
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scoreMode
operator|==
name|ScoreMode
operator|.
name|Avg
condition|)
block|{
name|scoreAggregator
operator|=
parameter_list|(
name|key
parameter_list|,
name|score
parameter_list|)
lambda|->
block|{
name|Float
name|currentSore
init|=
name|aggregatedScores
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
name|score
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentSore
operator|!=
literal|null
condition|)
block|{
name|aggregatedScores
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|currentSore
operator|+
name|score
argument_list|)
expr_stmt|;
block|}
name|Integer
name|currentOccurrence
init|=
name|occurrences
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentOccurrence
operator|!=
literal|null
condition|)
block|{
name|occurrences
operator|.
name|put
argument_list|(
name|key
argument_list|,
operator|++
name|currentOccurrence
argument_list|)
expr_stmt|;
block|}
block|}
expr_stmt|;
block|}
else|else
block|{
name|scoreAggregator
operator|=
parameter_list|(
name|key
parameter_list|,
name|score
parameter_list|)
lambda|->
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
expr_stmt|;
block|}
name|LongFunction
argument_list|<
name|Float
argument_list|>
name|joinScorer
decl_stmt|;
if|if
condition|(
name|scoreMode
operator|==
name|ScoreMode
operator|.
name|Avg
condition|)
block|{
name|joinScorer
operator|=
parameter_list|(
name|joinValue
parameter_list|)
lambda|->
block|{
name|Float
name|aggregatedScore
init|=
name|aggregatedScores
operator|.
name|get
argument_list|(
name|joinValue
argument_list|)
decl_stmt|;
name|Integer
name|occurrence
init|=
name|occurrences
operator|.
name|get
argument_list|(
name|joinValue
argument_list|)
decl_stmt|;
return|return
name|aggregatedScore
operator|/
name|occurrence
return|;
block|}
expr_stmt|;
block|}
else|else
block|{
name|joinScorer
operator|=
name|aggregatedScores
operator|::
name|get
expr_stmt|;
block|}
name|Collector
name|collector
decl_stmt|;
if|if
condition|(
name|multipleValuesPerDocument
condition|)
block|{
name|collector
operator|=
operator|new
name|SimpleCollector
argument_list|()
block|{
name|SortedNumericDocValues
name|sortedNumericDocValues
decl_stmt|;
name|Scorer
name|scorer
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|sortedNumericDocValues
operator|.
name|setDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedNumericDocValues
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|long
name|value
init|=
name|sortedNumericDocValues
operator|.
name|valueAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|joinValues
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsScore
condition|)
block|{
name|scoreAggregator
operator|.
name|accept
argument_list|(
name|value
argument_list|,
name|scorer
operator|.
name|score
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doSetNextReader
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|sortedNumericDocValues
operator|=
name|DocValues
operator|.
name|getSortedNumeric
argument_list|(
name|context
operator|.
name|reader
argument_list|()
argument_list|,
name|fromField
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|needsScores
parameter_list|()
block|{
return|return
name|needsScore
return|;
block|}
block|}
expr_stmt|;
block|}
else|else
block|{
name|collector
operator|=
operator|new
name|SimpleCollector
argument_list|()
block|{
name|NumericDocValues
name|numericDocValues
decl_stmt|;
name|Scorer
name|scorer
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|value
init|=
name|numericDocValues
operator|.
name|get
argument_list|(
name|doc
argument_list|)
decl_stmt|;
name|joinValues
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsScore
condition|)
block|{
name|scoreAggregator
operator|.
name|accept
argument_list|(
name|value
argument_list|,
name|scorer
operator|.
name|score
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doSetNextReader
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|numericDocValues
operator|=
name|DocValues
operator|.
name|getNumeric
argument_list|(
name|context
operator|.
name|reader
argument_list|()
argument_list|,
name|fromField
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|needsScores
parameter_list|()
block|{
return|return
name|needsScore
return|;
block|}
block|}
expr_stmt|;
block|}
name|fromSearcher
operator|.
name|search
argument_list|(
name|fromQuery
argument_list|,
name|collector
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Long
argument_list|>
name|iterator
init|=
name|joinValues
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|final
name|int
name|bytesPerDim
decl_stmt|;
specifier|final
name|BytesRef
name|encoded
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
specifier|final
name|PointInSetIncludingScoreQuery
operator|.
name|Stream
name|stream
decl_stmt|;
if|if
condition|(
name|Integer
operator|.
name|class
operator|.
name|equals
argument_list|(
name|numericType
argument_list|)
condition|)
block|{
name|bytesPerDim
operator|=
name|Integer
operator|.
name|BYTES
expr_stmt|;
name|stream
operator|=
operator|new
name|PointInSetIncludingScoreQuery
operator|.
name|Stream
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|BytesRef
name|next
parameter_list|()
block|{
if|if
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|long
name|value
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|IntPoint
operator|.
name|encodeDimension
argument_list|(
operator|(
name|int
operator|)
name|value
argument_list|,
name|encoded
operator|.
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsScore
condition|)
block|{
name|score
operator|=
name|joinScorer
operator|.
name|apply
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|encoded
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Long
operator|.
name|class
operator|.
name|equals
argument_list|(
name|numericType
argument_list|)
condition|)
block|{
name|bytesPerDim
operator|=
name|Long
operator|.
name|BYTES
expr_stmt|;
name|stream
operator|=
operator|new
name|PointInSetIncludingScoreQuery
operator|.
name|Stream
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|BytesRef
name|next
parameter_list|()
block|{
if|if
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|long
name|value
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|LongPoint
operator|.
name|encodeDimension
argument_list|(
name|value
argument_list|,
name|encoded
operator|.
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsScore
condition|)
block|{
name|score
operator|=
name|joinScorer
operator|.
name|apply
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|encoded
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Float
operator|.
name|class
operator|.
name|equals
argument_list|(
name|numericType
argument_list|)
condition|)
block|{
name|bytesPerDim
operator|=
name|Float
operator|.
name|BYTES
expr_stmt|;
name|stream
operator|=
operator|new
name|PointInSetIncludingScoreQuery
operator|.
name|Stream
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|BytesRef
name|next
parameter_list|()
block|{
if|if
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|long
name|value
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|FloatPoint
operator|.
name|encodeDimension
argument_list|(
name|Float
operator|.
name|intBitsToFloat
argument_list|(
operator|(
name|int
operator|)
name|value
argument_list|)
argument_list|,
name|encoded
operator|.
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsScore
condition|)
block|{
name|score
operator|=
name|joinScorer
operator|.
name|apply
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|encoded
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Double
operator|.
name|class
operator|.
name|equals
argument_list|(
name|numericType
argument_list|)
condition|)
block|{
name|bytesPerDim
operator|=
name|Double
operator|.
name|BYTES
expr_stmt|;
name|stream
operator|=
operator|new
name|PointInSetIncludingScoreQuery
operator|.
name|Stream
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|BytesRef
name|next
parameter_list|()
block|{
if|if
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|long
name|value
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|DoublePoint
operator|.
name|encodeDimension
argument_list|(
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|value
argument_list|)
argument_list|,
name|encoded
operator|.
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsScore
condition|)
block|{
name|score
operator|=
name|joinScorer
operator|.
name|apply
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|encoded
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unsupported numeric type, only Integer, Long, Float and Double are supported"
argument_list|)
throw|;
block|}
name|encoded
operator|.
name|bytes
operator|=
operator|new
name|byte
index|[
name|bytesPerDim
index|]
expr_stmt|;
name|encoded
operator|.
name|length
operator|=
name|bytesPerDim
expr_stmt|;
if|if
condition|(
name|needsScore
condition|)
block|{
return|return
operator|new
name|PointInSetIncludingScoreQuery
argument_list|(
name|fromQuery
argument_list|,
name|multipleValuesPerDocument
argument_list|,
name|toField
argument_list|,
name|bytesPerDim
argument_list|,
name|stream
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|String
name|toString
parameter_list|(
name|byte
index|[]
name|value
parameter_list|)
block|{
return|return
name|toString
operator|.
name|apply
argument_list|(
name|value
argument_list|,
name|numericType
argument_list|)
return|;
block|}
block|}
return|;
block|}
else|else
block|{
return|return
operator|new
name|PointInSetQuery
argument_list|(
name|toField
argument_list|,
literal|1
argument_list|,
name|bytesPerDim
argument_list|,
name|stream
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|String
name|toString
parameter_list|(
name|byte
index|[]
name|value
parameter_list|)
block|{
return|return
name|PointInSetIncludingScoreQuery
operator|.
name|toString
operator|.
name|apply
argument_list|(
name|value
argument_list|,
name|numericType
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
DECL|method|createJoinQuery
specifier|private
specifier|static
name|Query
name|createJoinQuery
parameter_list|(
name|boolean
name|multipleValuesPerDocument
parameter_list|,
name|String
name|toField
parameter_list|,
name|Query
name|fromQuery
parameter_list|,
name|IndexSearcher
name|fromSearcher
parameter_list|,
name|ScoreMode
name|scoreMode
parameter_list|,
specifier|final
name|GenericTermsCollector
name|collector
parameter_list|)
throws|throws
name|IOException
block|{
name|fromSearcher
operator|.
name|search
argument_list|(
name|fromQuery
argument_list|,
name|collector
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|scoreMode
condition|)
block|{
case|case
name|None
case|:
return|return
operator|new
name|TermsQuery
argument_list|(
name|toField
argument_list|,
name|fromQuery
argument_list|,
name|collector
operator|.
name|getCollectedTerms
argument_list|()
argument_list|)
return|;
case|case
name|Total
case|:
case|case
name|Max
case|:
case|case
name|Min
case|:
case|case
name|Avg
case|:
return|return
operator|new
name|TermsIncludingScoreQuery
argument_list|(
name|toField
argument_list|,
name|multipleValuesPerDocument
argument_list|,
name|collector
operator|.
name|getCollectedTerms
argument_list|()
argument_list|,
name|collector
operator|.
name|getScoresPerTerm
argument_list|()
argument_list|,
name|fromQuery
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Score mode %s isn't supported."
argument_list|,
name|scoreMode
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**    * Delegates to {@link #createJoinQuery(String, Query, Query, IndexSearcher, ScoreMode, MultiDocValues.OrdinalMap, int, int)},    * but disables the min and max filtering.    *    * @param joinField   The {@link SortedDocValues} field containing the join values    * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match "from" documents.    * @param toQuery     The query identifying all documents on the "to" side.    * @param searcher    The index searcher used to execute the from query    * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query    * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map    *                    needs to be provided.    * @return a {@link Query} instance that can be used to join documents based on the join field    * @throws IOException If I/O related errors occur    */
DECL|method|createJoinQuery
specifier|public
specifier|static
name|Query
name|createJoinQuery
parameter_list|(
name|String
name|joinField
parameter_list|,
name|Query
name|fromQuery
parameter_list|,
name|Query
name|toQuery
parameter_list|,
name|IndexSearcher
name|searcher
parameter_list|,
name|ScoreMode
name|scoreMode
parameter_list|,
name|MultiDocValues
operator|.
name|OrdinalMap
name|ordinalMap
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createJoinQuery
argument_list|(
name|joinField
argument_list|,
name|fromQuery
argument_list|,
name|toQuery
argument_list|,
name|searcher
argument_list|,
name|scoreMode
argument_list|,
name|ordinalMap
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
comment|/**    * A query time join using global ordinals over a dedicated join field.    *    * This join has certain restrictions and requirements:    * 1) A document can only refer to one other document. (but can be referred by one or more documents)    * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field    *    that identifies the "from" and "to" side and then the fromQuery and toQuery must take the this into account.    * 3) There must be a single sorted doc values join field used by both the "from" and "to" documents. This join field    *    should store the join values as UTF-8 strings.    * 4) An ordinal map must be provided that is created on top of the join field.    *    * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times    * a document matches per join value. This will increase the per join cost in terms of execution time and memory.    *    * @param joinField   The {@link SortedDocValues} field containing the join values    * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match "from" documents.    * @param toQuery     The query identifying all documents on the "to" side.    * @param searcher    The index searcher used to execute the from query    * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query    * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map    *                    needs to be provided.    * @param min         Optionally the minimum number of "from" documents that are required to match for a "to" document    *                    to be a match. The min is inclusive. Setting min to 0 and max to<code>Interger.MAX_VALUE</code>    *                    disables the min and max "from" documents filtering    * @param max         Optionally the maximum number of "from" documents that are allowed to match for a "to" document    *                    to be a match. The max is inclusive. Setting min to 0 and max to<code>Interger.MAX_VALUE</code>    *                    disables the min and max "from" documents filtering    * @return a {@link Query} instance that can be used to join documents based on the join field    * @throws IOException If I/O related errors occur    */
DECL|method|createJoinQuery
specifier|public
specifier|static
name|Query
name|createJoinQuery
parameter_list|(
name|String
name|joinField
parameter_list|,
name|Query
name|fromQuery
parameter_list|,
name|Query
name|toQuery
parameter_list|,
name|IndexSearcher
name|searcher
parameter_list|,
name|ScoreMode
name|scoreMode
parameter_list|,
name|MultiDocValues
operator|.
name|OrdinalMap
name|ordinalMap
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
throws|throws
name|IOException
block|{
name|IndexReader
name|indexReader
init|=
name|searcher
operator|.
name|getIndexReader
argument_list|()
decl_stmt|;
name|int
name|numSegments
init|=
name|indexReader
operator|.
name|leaves
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|long
name|valueCount
decl_stmt|;
if|if
condition|(
name|numSegments
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|MatchNoDocsQuery
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|numSegments
operator|==
literal|1
condition|)
block|{
comment|// No need to use the ordinal map, because there is just one segment.
name|ordinalMap
operator|=
literal|null
expr_stmt|;
name|LeafReader
name|leafReader
init|=
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|.
name|leaves
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|reader
argument_list|()
decl_stmt|;
name|SortedDocValues
name|joinSortedDocValues
init|=
name|leafReader
operator|.
name|getSortedDocValues
argument_list|(
name|joinField
argument_list|)
decl_stmt|;
if|if
condition|(
name|joinSortedDocValues
operator|!=
literal|null
condition|)
block|{
name|valueCount
operator|=
name|joinSortedDocValues
operator|.
name|getValueCount
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return
operator|new
name|MatchNoDocsQuery
argument_list|()
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ordinalMap
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"OrdinalMap is required, because there is more than 1 segment"
argument_list|)
throw|;
block|}
name|valueCount
operator|=
name|ordinalMap
operator|.
name|getValueCount
argument_list|()
expr_stmt|;
block|}
specifier|final
name|Query
name|rewrittenFromQuery
init|=
name|searcher
operator|.
name|rewrite
argument_list|(
name|fromQuery
argument_list|)
decl_stmt|;
specifier|final
name|Query
name|rewrittenToQuery
init|=
name|searcher
operator|.
name|rewrite
argument_list|(
name|toQuery
argument_list|)
decl_stmt|;
name|GlobalOrdinalsWithScoreCollector
name|globalOrdinalsWithScoreCollector
decl_stmt|;
switch|switch
condition|(
name|scoreMode
condition|)
block|{
case|case
name|Total
case|:
name|globalOrdinalsWithScoreCollector
operator|=
operator|new
name|GlobalOrdinalsWithScoreCollector
operator|.
name|Sum
argument_list|(
name|joinField
argument_list|,
name|ordinalMap
argument_list|,
name|valueCount
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
case|case
name|Min
case|:
name|globalOrdinalsWithScoreCollector
operator|=
operator|new
name|GlobalOrdinalsWithScoreCollector
operator|.
name|Min
argument_list|(
name|joinField
argument_list|,
name|ordinalMap
argument_list|,
name|valueCount
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
case|case
name|Max
case|:
name|globalOrdinalsWithScoreCollector
operator|=
operator|new
name|GlobalOrdinalsWithScoreCollector
operator|.
name|Max
argument_list|(
name|joinField
argument_list|,
name|ordinalMap
argument_list|,
name|valueCount
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
case|case
name|Avg
case|:
name|globalOrdinalsWithScoreCollector
operator|=
operator|new
name|GlobalOrdinalsWithScoreCollector
operator|.
name|Avg
argument_list|(
name|joinField
argument_list|,
name|ordinalMap
argument_list|,
name|valueCount
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
case|case
name|None
case|:
if|if
condition|(
name|min
operator|<=
literal|0
operator|&&
name|max
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|GlobalOrdinalsCollector
name|globalOrdinalsCollector
init|=
operator|new
name|GlobalOrdinalsCollector
argument_list|(
name|joinField
argument_list|,
name|ordinalMap
argument_list|,
name|valueCount
argument_list|)
decl_stmt|;
name|searcher
operator|.
name|search
argument_list|(
name|rewrittenFromQuery
argument_list|,
name|globalOrdinalsCollector
argument_list|)
expr_stmt|;
return|return
operator|new
name|GlobalOrdinalsQuery
argument_list|(
name|globalOrdinalsCollector
operator|.
name|getCollectorOrdinals
argument_list|()
argument_list|,
name|joinField
argument_list|,
name|ordinalMap
argument_list|,
name|rewrittenToQuery
argument_list|,
name|rewrittenFromQuery
argument_list|,
name|indexReader
argument_list|)
return|;
block|}
else|else
block|{
name|globalOrdinalsWithScoreCollector
operator|=
operator|new
name|GlobalOrdinalsWithScoreCollector
operator|.
name|NoScore
argument_list|(
name|joinField
argument_list|,
name|ordinalMap
argument_list|,
name|valueCount
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Score mode %s isn't supported."
argument_list|,
name|scoreMode
argument_list|)
argument_list|)
throw|;
block|}
name|searcher
operator|.
name|search
argument_list|(
name|rewrittenFromQuery
argument_list|,
name|globalOrdinalsWithScoreCollector
argument_list|)
expr_stmt|;
return|return
operator|new
name|GlobalOrdinalsWithScoreQuery
argument_list|(
name|globalOrdinalsWithScoreCollector
argument_list|,
name|joinField
argument_list|,
name|ordinalMap
argument_list|,
name|rewrittenToQuery
argument_list|,
name|rewrittenFromQuery
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|indexReader
argument_list|)
return|;
block|}
block|}
end_class
end_unit
