begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.idversion
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|idversion
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|BlockTermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|FieldsConsumer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|PostingsWriterBase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|blocktree
operator|.
name|BlockTreeTermsWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Fields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFileNames
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentWriteState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RAMOutputStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|FixedBitSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Builder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|ByteSequenceOutputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|BytesRefFSTEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FST
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|PairOutputs
operator|.
name|Pair
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|PairOutputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|PositiveIntOutputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Util
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|PackedInts
import|;
end_import
begin_comment
comment|/*   TODO:        - Currently there is a one-to-one mapping of indexed       term to term block, but we could decouple the two, ie,       put more terms into the index than there are blocks.       The index would take up more RAM but then it'd be able       to avoid seeking more often and could make PK/FuzzyQ       faster if the additional indexed terms could store       the offset into the terms block.      - The blocks are not written in true depth-first       order, meaning if you just next() the file pointer will       sometimes jump backwards.  For example, block foo* will       be written before block f* because it finished before.       This could possibly hurt performance if the terms dict is       not hot, since OSs anticipate sequential file access.  We       could fix the writer to re-order the blocks as a 2nd       pass.      - Each block encodes the term suffixes packed       sequentially using a separate vInt per term, which is       1) wasteful and 2) slow (must linear scan to find a       particular suffix).  We should instead 1) make       random-access array so we can directly access the Nth       suffix, and 2) bulk-encode this array using bulk int[]       codecs; then at search time we can binary search when       we seek a particular term. */
end_comment
begin_comment
comment|/**  * This is just like {@link BlockTreeTermsWriter}, except it also stores a version per term, and adds a method to its TermsEnum  * implementation to seekExact only if the version is>= the specified version.  The version is added to the terms index to avoid seeking if  * no term in the block has a high enough version.  The term blocks file is .tiv and the terms index extension is .tipv.  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|VersionBlockTreeTermsWriter
specifier|public
specifier|final
class|class
name|VersionBlockTreeTermsWriter
extends|extends
name|FieldsConsumer
block|{
DECL|field|FST_OUTPUTS
specifier|static
specifier|final
name|PairOutputs
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
name|FST_OUTPUTS
init|=
operator|new
name|PairOutputs
argument_list|<>
argument_list|(
name|ByteSequenceOutputs
operator|.
name|getSingleton
argument_list|()
argument_list|,
name|PositiveIntOutputs
operator|.
name|getSingleton
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|NO_OUTPUT
specifier|static
specifier|final
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
name|NO_OUTPUT
init|=
name|FST_OUTPUTS
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
comment|/** Suggested default value for the {@code    *  minItemsInBlock} parameter to {@link    *  #VersionBlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int)}. */
DECL|field|DEFAULT_MIN_BLOCK_SIZE
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MIN_BLOCK_SIZE
init|=
literal|25
decl_stmt|;
comment|/** Suggested default value for the {@code    *  maxItemsInBlock} parameter to {@link    *  #VersionBlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int)}. */
DECL|field|DEFAULT_MAX_BLOCK_SIZE
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_BLOCK_SIZE
init|=
literal|48
decl_stmt|;
comment|// public final static boolean DEBUG = false;
comment|//private final static boolean SAVE_DOT_FILES = false;
DECL|field|OUTPUT_FLAGS_NUM_BITS
specifier|static
specifier|final
name|int
name|OUTPUT_FLAGS_NUM_BITS
init|=
literal|2
decl_stmt|;
DECL|field|OUTPUT_FLAGS_MASK
specifier|static
specifier|final
name|int
name|OUTPUT_FLAGS_MASK
init|=
literal|0x3
decl_stmt|;
DECL|field|OUTPUT_FLAG_IS_FLOOR
specifier|static
specifier|final
name|int
name|OUTPUT_FLAG_IS_FLOOR
init|=
literal|0x1
decl_stmt|;
DECL|field|OUTPUT_FLAG_HAS_TERMS
specifier|static
specifier|final
name|int
name|OUTPUT_FLAG_HAS_TERMS
init|=
literal|0x2
decl_stmt|;
comment|/** Extension of terms file */
DECL|field|TERMS_EXTENSION
specifier|static
specifier|final
name|String
name|TERMS_EXTENSION
init|=
literal|"tiv"
decl_stmt|;
DECL|field|TERMS_CODEC_NAME
specifier|final
specifier|static
name|String
name|TERMS_CODEC_NAME
init|=
literal|"VERSION_BLOCK_TREE_TERMS_DICT"
decl_stmt|;
comment|/** Initial terms format. */
DECL|field|VERSION_START
specifier|public
specifier|static
specifier|final
name|int
name|VERSION_START
init|=
literal|1
decl_stmt|;
comment|/** Current terms format. */
DECL|field|VERSION_CURRENT
specifier|public
specifier|static
specifier|final
name|int
name|VERSION_CURRENT
init|=
name|VERSION_START
decl_stmt|;
comment|/** Extension of terms index file */
DECL|field|TERMS_INDEX_EXTENSION
specifier|static
specifier|final
name|String
name|TERMS_INDEX_EXTENSION
init|=
literal|"tipv"
decl_stmt|;
DECL|field|TERMS_INDEX_CODEC_NAME
specifier|final
specifier|static
name|String
name|TERMS_INDEX_CODEC_NAME
init|=
literal|"VERSION_BLOCK_TREE_TERMS_INDEX"
decl_stmt|;
DECL|field|out
specifier|private
specifier|final
name|IndexOutput
name|out
decl_stmt|;
DECL|field|indexOut
specifier|private
specifier|final
name|IndexOutput
name|indexOut
decl_stmt|;
DECL|field|maxDoc
specifier|final
name|int
name|maxDoc
decl_stmt|;
DECL|field|minItemsInBlock
specifier|final
name|int
name|minItemsInBlock
decl_stmt|;
DECL|field|maxItemsInBlock
specifier|final
name|int
name|maxItemsInBlock
decl_stmt|;
DECL|field|postingsWriter
specifier|final
name|PostingsWriterBase
name|postingsWriter
decl_stmt|;
DECL|field|fieldInfos
specifier|final
name|FieldInfos
name|fieldInfos
decl_stmt|;
DECL|class|FieldMetaData
specifier|private
specifier|static
class|class
name|FieldMetaData
block|{
DECL|field|fieldInfo
specifier|public
specifier|final
name|FieldInfo
name|fieldInfo
decl_stmt|;
DECL|field|rootCode
specifier|public
specifier|final
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
name|rootCode
decl_stmt|;
DECL|field|numTerms
specifier|public
specifier|final
name|long
name|numTerms
decl_stmt|;
DECL|field|indexStartFP
specifier|public
specifier|final
name|long
name|indexStartFP
decl_stmt|;
DECL|field|longsSize
specifier|private
specifier|final
name|int
name|longsSize
decl_stmt|;
DECL|field|minTerm
specifier|public
specifier|final
name|BytesRef
name|minTerm
decl_stmt|;
DECL|field|maxTerm
specifier|public
specifier|final
name|BytesRef
name|maxTerm
decl_stmt|;
DECL|method|FieldMetaData
specifier|public
name|FieldMetaData
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
name|rootCode
parameter_list|,
name|long
name|numTerms
parameter_list|,
name|long
name|indexStartFP
parameter_list|,
name|int
name|longsSize
parameter_list|,
name|BytesRef
name|minTerm
parameter_list|,
name|BytesRef
name|maxTerm
parameter_list|)
block|{
assert|assert
name|numTerms
operator|>
literal|0
assert|;
name|this
operator|.
name|fieldInfo
operator|=
name|fieldInfo
expr_stmt|;
assert|assert
name|rootCode
operator|!=
literal|null
operator|:
literal|"field="
operator|+
name|fieldInfo
operator|.
name|name
operator|+
literal|" numTerms="
operator|+
name|numTerms
assert|;
name|this
operator|.
name|rootCode
operator|=
name|rootCode
expr_stmt|;
name|this
operator|.
name|indexStartFP
operator|=
name|indexStartFP
expr_stmt|;
name|this
operator|.
name|numTerms
operator|=
name|numTerms
expr_stmt|;
name|this
operator|.
name|longsSize
operator|=
name|longsSize
expr_stmt|;
name|this
operator|.
name|minTerm
operator|=
name|minTerm
expr_stmt|;
name|this
operator|.
name|maxTerm
operator|=
name|maxTerm
expr_stmt|;
block|}
block|}
DECL|field|fields
specifier|private
specifier|final
name|List
argument_list|<
name|FieldMetaData
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// private final String segment;
comment|/** Create a new writer.  The number of items (terms or    *  sub-blocks) per block will aim to be between    *  minItemsPerBlock and maxItemsPerBlock, though in some    *  cases the blocks may be smaller than the min. */
DECL|method|VersionBlockTreeTermsWriter
specifier|public
name|VersionBlockTreeTermsWriter
parameter_list|(
name|SegmentWriteState
name|state
parameter_list|,
name|PostingsWriterBase
name|postingsWriter
parameter_list|,
name|int
name|minItemsInBlock
parameter_list|,
name|int
name|maxItemsInBlock
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|minItemsInBlock
operator|<=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"minItemsInBlock must be>= 2; got "
operator|+
name|minItemsInBlock
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxItemsInBlock
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxItemsInBlock must be>= 1; got "
operator|+
name|maxItemsInBlock
argument_list|)
throw|;
block|}
if|if
condition|(
name|minItemsInBlock
operator|>
name|maxItemsInBlock
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxItemsInBlock must be>= minItemsInBlock; got maxItemsInBlock="
operator|+
name|maxItemsInBlock
operator|+
literal|" minItemsInBlock="
operator|+
name|minItemsInBlock
argument_list|)
throw|;
block|}
if|if
condition|(
literal|2
operator|*
operator|(
name|minItemsInBlock
operator|-
literal|1
operator|)
operator|>
name|maxItemsInBlock
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxItemsInBlock must be at least 2*(minItemsInBlock-1); got maxItemsInBlock="
operator|+
name|maxItemsInBlock
operator|+
literal|" minItemsInBlock="
operator|+
name|minItemsInBlock
argument_list|)
throw|;
block|}
name|maxDoc
operator|=
name|state
operator|.
name|segmentInfo
operator|.
name|getDocCount
argument_list|()
expr_stmt|;
specifier|final
name|String
name|termsFileName
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|state
operator|.
name|segmentInfo
operator|.
name|name
argument_list|,
name|state
operator|.
name|segmentSuffix
argument_list|,
name|TERMS_EXTENSION
argument_list|)
decl_stmt|;
name|out
operator|=
name|state
operator|.
name|directory
operator|.
name|createOutput
argument_list|(
name|termsFileName
argument_list|,
name|state
operator|.
name|context
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|IndexOutput
name|indexOut
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fieldInfos
operator|=
name|state
operator|.
name|fieldInfos
expr_stmt|;
name|this
operator|.
name|minItemsInBlock
operator|=
name|minItemsInBlock
expr_stmt|;
name|this
operator|.
name|maxItemsInBlock
operator|=
name|maxItemsInBlock
expr_stmt|;
name|CodecUtil
operator|.
name|writeSegmentHeader
argument_list|(
name|out
argument_list|,
name|TERMS_CODEC_NAME
argument_list|,
name|VERSION_CURRENT
argument_list|,
name|state
operator|.
name|segmentInfo
operator|.
name|getId
argument_list|()
argument_list|,
name|state
operator|.
name|segmentSuffix
argument_list|)
expr_stmt|;
comment|//DEBUG = state.segmentName.equals("_4a");
specifier|final
name|String
name|termsIndexFileName
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|state
operator|.
name|segmentInfo
operator|.
name|name
argument_list|,
name|state
operator|.
name|segmentSuffix
argument_list|,
name|TERMS_INDEX_EXTENSION
argument_list|)
decl_stmt|;
name|indexOut
operator|=
name|state
operator|.
name|directory
operator|.
name|createOutput
argument_list|(
name|termsIndexFileName
argument_list|,
name|state
operator|.
name|context
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|writeSegmentHeader
argument_list|(
name|indexOut
argument_list|,
name|TERMS_INDEX_CODEC_NAME
argument_list|,
name|VERSION_CURRENT
argument_list|,
name|state
operator|.
name|segmentInfo
operator|.
name|getId
argument_list|()
argument_list|,
name|state
operator|.
name|segmentSuffix
argument_list|)
expr_stmt|;
name|this
operator|.
name|postingsWriter
operator|=
name|postingsWriter
expr_stmt|;
comment|// segment = state.segmentInfo.name;
comment|// System.out.println("BTW.init seg=" + state.segmentName);
name|postingsWriter
operator|.
name|init
argument_list|(
name|out
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|// have consumer write its format/header
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|out
argument_list|,
name|indexOut
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|indexOut
operator|=
name|indexOut
expr_stmt|;
block|}
comment|/** Writes the terms file trailer. */
DECL|method|writeTrailer
specifier|private
name|void
name|writeTrailer
parameter_list|(
name|IndexOutput
name|out
parameter_list|,
name|long
name|dirStart
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeLong
argument_list|(
name|dirStart
argument_list|)
expr_stmt|;
block|}
comment|/** Writes the index file trailer. */
DECL|method|writeIndexTrailer
specifier|private
name|void
name|writeIndexTrailer
parameter_list|(
name|IndexOutput
name|indexOut
parameter_list|,
name|long
name|dirStart
parameter_list|)
throws|throws
name|IOException
block|{
name|indexOut
operator|.
name|writeLong
argument_list|(
name|dirStart
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|write
specifier|public
name|void
name|write
parameter_list|(
name|Fields
name|fields
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|lastField
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
assert|assert
name|lastField
operator|==
literal|null
operator|||
name|lastField
operator|.
name|compareTo
argument_list|(
name|field
argument_list|)
operator|<
literal|0
assert|;
name|lastField
operator|=
name|field
expr_stmt|;
name|Terms
name|terms
init|=
name|fields
operator|.
name|terms
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|TermsEnum
name|termsEnum
init|=
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|TermsWriter
name|termsWriter
init|=
operator|new
name|TermsWriter
argument_list|(
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|BytesRef
name|term
init|=
name|termsEnum
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|term
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|termsWriter
operator|.
name|write
argument_list|(
name|term
argument_list|,
name|termsEnum
argument_list|)
expr_stmt|;
block|}
name|termsWriter
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|encodeOutput
specifier|static
name|long
name|encodeOutput
parameter_list|(
name|long
name|fp
parameter_list|,
name|boolean
name|hasTerms
parameter_list|,
name|boolean
name|isFloor
parameter_list|)
block|{
assert|assert
name|fp
operator|<
operator|(
literal|1L
operator|<<
literal|62
operator|)
assert|;
return|return
operator|(
name|fp
operator|<<
literal|2
operator|)
operator||
operator|(
name|hasTerms
condition|?
name|OUTPUT_FLAG_HAS_TERMS
else|:
literal|0
operator|)
operator||
operator|(
name|isFloor
condition|?
name|OUTPUT_FLAG_IS_FLOOR
else|:
literal|0
operator|)
return|;
block|}
DECL|class|PendingEntry
specifier|private
specifier|static
class|class
name|PendingEntry
block|{
DECL|field|isTerm
specifier|public
specifier|final
name|boolean
name|isTerm
decl_stmt|;
DECL|method|PendingEntry
specifier|protected
name|PendingEntry
parameter_list|(
name|boolean
name|isTerm
parameter_list|)
block|{
name|this
operator|.
name|isTerm
operator|=
name|isTerm
expr_stmt|;
block|}
block|}
DECL|class|PendingTerm
specifier|private
specifier|static
specifier|final
class|class
name|PendingTerm
extends|extends
name|PendingEntry
block|{
DECL|field|termBytes
specifier|public
specifier|final
name|byte
index|[]
name|termBytes
decl_stmt|;
comment|// stats + metadata
DECL|field|state
specifier|public
specifier|final
name|BlockTermState
name|state
decl_stmt|;
DECL|method|PendingTerm
specifier|public
name|PendingTerm
parameter_list|(
name|BytesRef
name|term
parameter_list|,
name|BlockTermState
name|state
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|termBytes
operator|=
operator|new
name|byte
index|[
name|term
operator|.
name|length
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|term
operator|.
name|offset
argument_list|,
name|termBytes
argument_list|,
literal|0
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|brToString
argument_list|(
name|termBytes
argument_list|)
return|;
block|}
block|}
comment|// for debugging
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
DECL|method|brToString
specifier|static
name|String
name|brToString
parameter_list|(
name|BytesRef
name|b
parameter_list|)
block|{
try|try
block|{
return|return
name|b
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" "
operator|+
name|b
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// If BytesRef isn't actually UTF8, or it's eg a
comment|// prefix of UTF8 that ends mid-unicode-char, we
comment|// fallback to hex:
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|// for debugging
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
DECL|method|brToString
specifier|static
name|String
name|brToString
parameter_list|(
name|byte
index|[]
name|b
parameter_list|)
block|{
return|return
name|brToString
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|b
argument_list|)
argument_list|)
return|;
block|}
DECL|class|PendingBlock
specifier|private
specifier|static
specifier|final
class|class
name|PendingBlock
extends|extends
name|PendingEntry
block|{
DECL|field|prefix
specifier|public
specifier|final
name|BytesRef
name|prefix
decl_stmt|;
DECL|field|fp
specifier|public
specifier|final
name|long
name|fp
decl_stmt|;
DECL|field|index
specifier|public
name|FST
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
name|index
decl_stmt|;
DECL|field|subIndices
specifier|public
name|List
argument_list|<
name|FST
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|>
name|subIndices
decl_stmt|;
DECL|field|hasTerms
specifier|public
specifier|final
name|boolean
name|hasTerms
decl_stmt|;
DECL|field|isFloor
specifier|public
specifier|final
name|boolean
name|isFloor
decl_stmt|;
DECL|field|floorLeadByte
specifier|public
specifier|final
name|int
name|floorLeadByte
decl_stmt|;
comment|/** Max version for all terms in this block. */
DECL|field|maxVersion
specifier|private
specifier|final
name|long
name|maxVersion
decl_stmt|;
DECL|method|PendingBlock
specifier|public
name|PendingBlock
parameter_list|(
name|BytesRef
name|prefix
parameter_list|,
name|long
name|maxVersion
parameter_list|,
name|long
name|fp
parameter_list|,
name|boolean
name|hasTerms
parameter_list|,
name|boolean
name|isFloor
parameter_list|,
name|int
name|floorLeadByte
parameter_list|,
name|List
argument_list|<
name|FST
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|>
name|subIndices
parameter_list|)
block|{
name|super
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|prefix
operator|=
name|prefix
expr_stmt|;
name|this
operator|.
name|maxVersion
operator|=
name|maxVersion
expr_stmt|;
name|this
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|this
operator|.
name|hasTerms
operator|=
name|hasTerms
expr_stmt|;
name|this
operator|.
name|isFloor
operator|=
name|isFloor
expr_stmt|;
name|this
operator|.
name|floorLeadByte
operator|=
name|floorLeadByte
expr_stmt|;
name|this
operator|.
name|subIndices
operator|=
name|subIndices
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"BLOCK: "
operator|+
name|brToString
argument_list|(
name|prefix
argument_list|)
return|;
block|}
DECL|method|compileIndex
specifier|public
name|void
name|compileIndex
parameter_list|(
name|List
argument_list|<
name|PendingBlock
argument_list|>
name|blocks
parameter_list|,
name|RAMOutputStream
name|scratchBytes
parameter_list|,
name|IntsRefBuilder
name|scratchIntsRef
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|(
name|isFloor
operator|&&
name|blocks
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|)
operator|||
operator|(
name|isFloor
operator|==
literal|false
operator|&&
name|blocks
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
operator|:
literal|"isFloor="
operator|+
name|isFloor
operator|+
literal|" blocks="
operator|+
name|blocks
assert|;
assert|assert
name|this
operator|==
name|blocks
operator|.
name|get
argument_list|(
literal|0
argument_list|)
assert|;
assert|assert
name|scratchBytes
operator|.
name|getFilePointer
argument_list|()
operator|==
literal|0
assert|;
name|long
name|maxVersionIndex
init|=
name|maxVersion
decl_stmt|;
comment|// TODO: try writing the leading vLong in MSB order
comment|// (opposite of what Lucene does today), for better
comment|// outputs sharing in the FST
name|scratchBytes
operator|.
name|writeVLong
argument_list|(
name|encodeOutput
argument_list|(
name|fp
argument_list|,
name|hasTerms
argument_list|,
name|isFloor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFloor
condition|)
block|{
name|scratchBytes
operator|.
name|writeVInt
argument_list|(
name|blocks
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|blocks
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|PendingBlock
name|sub
init|=
name|blocks
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|maxVersionIndex
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxVersionIndex
argument_list|,
name|sub
operator|.
name|maxVersion
argument_list|)
expr_stmt|;
comment|//if (DEBUG) {
comment|//  System.out.println("    write floorLeadByte=" + Integer.toHexString(sub.floorLeadByte&0xff));
comment|//}
name|scratchBytes
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|sub
operator|.
name|floorLeadByte
argument_list|)
expr_stmt|;
assert|assert
name|sub
operator|.
name|fp
operator|>
name|fp
assert|;
name|scratchBytes
operator|.
name|writeVLong
argument_list|(
operator|(
name|sub
operator|.
name|fp
operator|-
name|fp
operator|)
operator|<<
literal|1
operator||
operator|(
name|sub
operator|.
name|hasTerms
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|Builder
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
name|indexBuilder
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|FST_OUTPUTS
argument_list|,
literal|false
argument_list|,
name|PackedInts
operator|.
name|COMPACT
argument_list|,
literal|true
argument_list|,
literal|15
argument_list|)
decl_stmt|;
comment|//if (DEBUG) {
comment|//  System.out.println("  compile index for prefix=" + prefix);
comment|//}
comment|//indexBuilder.DEBUG = false;
specifier|final
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|scratchBytes
operator|.
name|getFilePointer
argument_list|()
index|]
decl_stmt|;
assert|assert
name|bytes
operator|.
name|length
operator|>
literal|0
assert|;
name|scratchBytes
operator|.
name|writeTo
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|indexBuilder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|prefix
argument_list|,
name|scratchIntsRef
argument_list|)
argument_list|,
name|FST_OUTPUTS
operator|.
name|newPair
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
argument_list|,
name|Long
operator|.
name|MAX_VALUE
operator|-
name|maxVersionIndex
argument_list|)
argument_list|)
expr_stmt|;
name|scratchBytes
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Copy over index for all sub-blocks
for|for
control|(
name|PendingBlock
name|block
range|:
name|blocks
control|)
block|{
if|if
condition|(
name|block
operator|.
name|subIndices
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|FST
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
name|subIndex
range|:
name|block
operator|.
name|subIndices
control|)
block|{
name|append
argument_list|(
name|indexBuilder
argument_list|,
name|subIndex
argument_list|,
name|scratchIntsRef
argument_list|)
expr_stmt|;
block|}
name|block
operator|.
name|subIndices
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|index
operator|=
name|indexBuilder
operator|.
name|finish
argument_list|()
expr_stmt|;
assert|assert
name|subIndices
operator|==
literal|null
assert|;
comment|/*       Writer w = new OutputStreamWriter(new FileOutputStream("out.dot"));       Util.toDot(index, w, false, false);       System.out.println("SAVED to out.dot");       w.close();       */
block|}
comment|// TODO: maybe we could add bulk-add method to
comment|// Builder?  Takes FST and unions it w/ current
comment|// FST.
DECL|method|append
specifier|private
name|void
name|append
parameter_list|(
name|Builder
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
name|builder
parameter_list|,
name|FST
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
name|subIndex
parameter_list|,
name|IntsRefBuilder
name|scratchIntsRef
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|BytesRefFSTEnum
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
name|subIndexEnum
init|=
operator|new
name|BytesRefFSTEnum
argument_list|<>
argument_list|(
name|subIndex
argument_list|)
decl_stmt|;
name|BytesRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
name|indexEnt
decl_stmt|;
while|while
condition|(
operator|(
name|indexEnt
operator|=
name|subIndexEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("      add sub=" + indexEnt.input + " " + indexEnt.input + " output=" + indexEnt.output);
comment|//}
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|indexEnt
operator|.
name|input
argument_list|,
name|scratchIntsRef
argument_list|)
argument_list|,
name|indexEnt
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|field|scratchBytes
specifier|private
specifier|final
name|RAMOutputStream
name|scratchBytes
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
DECL|field|scratchIntsRef
specifier|private
specifier|final
name|IntsRefBuilder
name|scratchIntsRef
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
DECL|class|TermsWriter
class|class
name|TermsWriter
block|{
DECL|field|fieldInfo
specifier|private
specifier|final
name|FieldInfo
name|fieldInfo
decl_stmt|;
DECL|field|longsSize
specifier|private
specifier|final
name|int
name|longsSize
decl_stmt|;
DECL|field|numTerms
specifier|private
name|long
name|numTerms
decl_stmt|;
DECL|field|docsSeen
specifier|final
name|FixedBitSet
name|docsSeen
decl_stmt|;
DECL|field|indexStartFP
name|long
name|indexStartFP
decl_stmt|;
comment|// Records index into pending where the current prefix at that
comment|// length "started"; for example, if current term starts with 't',
comment|// startsByPrefix[0] is the index into pending for the first
comment|// term/sub-block starting with 't'.  We use this to figure out when
comment|// to write a new block:
DECL|field|lastTerm
specifier|private
specifier|final
name|BytesRefBuilder
name|lastTerm
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
DECL|field|prefixStarts
specifier|private
name|int
index|[]
name|prefixStarts
init|=
operator|new
name|int
index|[
literal|8
index|]
decl_stmt|;
DECL|field|longs
specifier|private
specifier|final
name|long
index|[]
name|longs
decl_stmt|;
comment|// Pending stack of terms and blocks.  As terms arrive (in sorted order)
comment|// we append to this stack, and once the top of the stack has enough
comment|// terms starting with a common prefix, we write a new block with
comment|// those terms and replace those terms in the stack with a new block:
DECL|field|pending
specifier|private
specifier|final
name|List
argument_list|<
name|PendingEntry
argument_list|>
name|pending
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Reused in writeBlocks:
DECL|field|newBlocks
specifier|private
specifier|final
name|List
argument_list|<
name|PendingBlock
argument_list|>
name|newBlocks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|firstPendingTerm
specifier|private
name|PendingTerm
name|firstPendingTerm
decl_stmt|;
DECL|field|lastPendingTerm
specifier|private
name|PendingTerm
name|lastPendingTerm
decl_stmt|;
comment|/** Writes the top count entries in pending, using prevTerm to compute the prefix. */
DECL|method|writeBlocks
name|void
name|writeBlocks
parameter_list|(
name|int
name|prefixLength
parameter_list|,
name|int
name|count
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|count
operator|>
literal|0
assert|;
comment|/*       if (DEBUG) {         BytesRef br = new BytesRef(lastTerm.bytes);         br.offset = lastTerm.offset;         br.length = prefixLength;         System.out.println("writeBlocks: " + br.utf8ToString() + " count=" + count);       }       */
comment|// Root block better write all remaining pending entries:
assert|assert
name|prefixLength
operator|>
literal|0
operator|||
name|count
operator|==
name|pending
operator|.
name|size
argument_list|()
assert|;
name|int
name|lastSuffixLeadLabel
init|=
operator|-
literal|1
decl_stmt|;
comment|// True if we saw at least one term in this block (we record if a block
comment|// only points to sub-blocks in the terms index so we can avoid seeking
comment|// to it when we are looking for a term):
name|boolean
name|hasTerms
init|=
literal|false
decl_stmt|;
name|boolean
name|hasSubBlocks
init|=
literal|false
decl_stmt|;
name|int
name|start
init|=
name|pending
operator|.
name|size
argument_list|()
operator|-
name|count
decl_stmt|;
name|int
name|end
init|=
name|pending
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|nextBlockStart
init|=
name|start
decl_stmt|;
name|int
name|nextFloorLeadLabel
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|PendingEntry
name|ent
init|=
name|pending
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|suffixLeadLabel
decl_stmt|;
if|if
condition|(
name|ent
operator|.
name|isTerm
condition|)
block|{
name|PendingTerm
name|term
init|=
operator|(
name|PendingTerm
operator|)
name|ent
decl_stmt|;
if|if
condition|(
name|term
operator|.
name|termBytes
operator|.
name|length
operator|==
name|prefixLength
condition|)
block|{
comment|// Suffix is 0, i.e. prefix 'foo' and term is
comment|// 'foo' so the term has empty string suffix
comment|// in this block
assert|assert
name|lastSuffixLeadLabel
operator|==
operator|-
literal|1
assert|;
name|suffixLeadLabel
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|suffixLeadLabel
operator|=
name|term
operator|.
name|termBytes
index|[
name|prefixLength
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
else|else
block|{
name|PendingBlock
name|block
init|=
operator|(
name|PendingBlock
operator|)
name|ent
decl_stmt|;
assert|assert
name|block
operator|.
name|prefix
operator|.
name|length
operator|>
name|prefixLength
assert|;
name|suffixLeadLabel
operator|=
name|block
operator|.
name|prefix
operator|.
name|bytes
index|[
name|block
operator|.
name|prefix
operator|.
name|offset
operator|+
name|prefixLength
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
comment|// if (DEBUG) System.out.println("  i=" + i + " ent=" + ent + " suffixLeadLabel=" + suffixLeadLabel);
if|if
condition|(
name|suffixLeadLabel
operator|!=
name|lastSuffixLeadLabel
condition|)
block|{
name|int
name|itemsInBlock
init|=
name|i
operator|-
name|nextBlockStart
decl_stmt|;
if|if
condition|(
name|itemsInBlock
operator|>=
name|minItemsInBlock
operator|&&
name|end
operator|-
name|nextBlockStart
operator|>
name|maxItemsInBlock
condition|)
block|{
comment|// The count is too large for one block, so we must break it into "floor" blocks, where we record
comment|// the leading label of the suffix of the first term in each floor block, so at search time we can
comment|// jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor
comment|// block as soon as we have at least minItemsInBlock.  This is not always best: it often produces
comment|// a too-small block as the final block:
name|boolean
name|isFloor
init|=
name|itemsInBlock
operator|<
name|count
decl_stmt|;
name|newBlocks
operator|.
name|add
argument_list|(
name|writeBlock
argument_list|(
name|prefixLength
argument_list|,
name|isFloor
argument_list|,
name|nextFloorLeadLabel
argument_list|,
name|nextBlockStart
argument_list|,
name|i
argument_list|,
name|hasTerms
argument_list|,
name|hasSubBlocks
argument_list|)
argument_list|)
expr_stmt|;
name|hasTerms
operator|=
literal|false
expr_stmt|;
name|hasSubBlocks
operator|=
literal|false
expr_stmt|;
name|nextFloorLeadLabel
operator|=
name|suffixLeadLabel
expr_stmt|;
name|nextBlockStart
operator|=
name|i
expr_stmt|;
block|}
name|lastSuffixLeadLabel
operator|=
name|suffixLeadLabel
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|.
name|isTerm
condition|)
block|{
name|hasTerms
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|hasSubBlocks
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Write last block, if any:
if|if
condition|(
name|nextBlockStart
operator|<
name|end
condition|)
block|{
name|int
name|itemsInBlock
init|=
name|end
operator|-
name|nextBlockStart
decl_stmt|;
name|boolean
name|isFloor
init|=
name|itemsInBlock
operator|<
name|count
decl_stmt|;
name|newBlocks
operator|.
name|add
argument_list|(
name|writeBlock
argument_list|(
name|prefixLength
argument_list|,
name|isFloor
argument_list|,
name|nextFloorLeadLabel
argument_list|,
name|nextBlockStart
argument_list|,
name|end
argument_list|,
name|hasTerms
argument_list|,
name|hasSubBlocks
argument_list|)
argument_list|)
expr_stmt|;
block|}
assert|assert
name|newBlocks
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
assert|;
name|PendingBlock
name|firstBlock
init|=
name|newBlocks
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
name|firstBlock
operator|.
name|isFloor
operator|||
name|newBlocks
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
name|firstBlock
operator|.
name|compileIndex
argument_list|(
name|newBlocks
argument_list|,
name|scratchBytes
argument_list|,
name|scratchIntsRef
argument_list|)
expr_stmt|;
comment|// Remove slice from the top of the pending stack, that we just wrote:
name|pending
operator|.
name|subList
argument_list|(
name|pending
operator|.
name|size
argument_list|()
operator|-
name|count
argument_list|,
name|pending
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Append new block
name|pending
operator|.
name|add
argument_list|(
name|firstBlock
argument_list|)
expr_stmt|;
name|newBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/** Writes the specified slice (start is inclusive, end is exclusive)      *  from pending stack as a new block.  If isFloor is true, there      *  were too many (more than maxItemsInBlock) entries sharing the      *  same prefix, and so we broke it into multiple floor blocks where      *  we record the starting label of the suffix of each floor block. */
DECL|method|writeBlock
specifier|private
name|PendingBlock
name|writeBlock
parameter_list|(
name|int
name|prefixLength
parameter_list|,
name|boolean
name|isFloor
parameter_list|,
name|int
name|floorLeadLabel
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|boolean
name|hasTerms
parameter_list|,
name|boolean
name|hasSubBlocks
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|end
operator|>
name|start
assert|;
name|long
name|startFP
init|=
name|out
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
comment|// if (DEBUG) System.out.println("    writeBlock fp=" + startFP + " isFloor=" + isFloor + " floorLeadLabel=" + floorLeadLabel + " start=" + start + " end=" + end + " hasTerms=" + hasTerms + " hasSubBlocks=" + hasSubBlocks);
name|boolean
name|hasFloorLeadLabel
init|=
name|isFloor
operator|&&
name|floorLeadLabel
operator|!=
operator|-
literal|1
decl_stmt|;
specifier|final
name|BytesRef
name|prefix
init|=
operator|new
name|BytesRef
argument_list|(
name|prefixLength
operator|+
operator|(
name|hasFloorLeadLabel
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|lastTerm
operator|.
name|bytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|prefix
operator|.
name|bytes
argument_list|,
literal|0
argument_list|,
name|prefixLength
argument_list|)
expr_stmt|;
name|prefix
operator|.
name|length
operator|=
name|prefixLength
expr_stmt|;
comment|// Write block header:
name|int
name|numEntries
init|=
name|end
operator|-
name|start
decl_stmt|;
name|int
name|code
init|=
name|numEntries
operator|<<
literal|1
decl_stmt|;
if|if
condition|(
name|end
operator|==
name|pending
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// Last block:
name|code
operator||=
literal|1
expr_stmt|;
block|}
name|out
operator|.
name|writeVInt
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  writeBlock " + (isFloor ? "(floor) " : "") + "seg=" + segment + " pending.size()=" + pending.size() + " prefixLength=" + prefixLength + " indexPrefix=" + brToString(prefix) + " entCount=" + length + " startFP=" + startFP + (isFloor ? (" floorLeadByte=" + Integer.toHexString(floorLeadByte&0xff)) : "") + " isLastInFloor=" + isLastInFloor);
comment|// }
comment|// 1st pass: pack term suffix bytes into byte[] blob
comment|// TODO: cutover to bulk int codec... simple64?
comment|// We optimize the leaf block case (block has only terms), writing a more
comment|// compact format in this case:
name|boolean
name|isLeafBlock
init|=
name|hasSubBlocks
operator|==
literal|false
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FST
argument_list|<
name|Pair
argument_list|<
name|BytesRef
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|>
name|subIndices
decl_stmt|;
name|boolean
name|absolute
init|=
literal|true
decl_stmt|;
name|long
name|maxVersionInBlock
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|isLeafBlock
condition|)
block|{
comment|// Only terms:
name|subIndices
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|PendingEntry
name|ent
init|=
name|pending
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
assert|assert
name|ent
operator|.
name|isTerm
operator|:
literal|"i="
operator|+
name|i
assert|;
name|PendingTerm
name|term
init|=
operator|(
name|PendingTerm
operator|)
name|ent
decl_stmt|;
assert|assert
name|StringHelper
operator|.
name|startsWith
argument_list|(
name|term
operator|.
name|termBytes
argument_list|,
name|prefix
argument_list|)
operator|:
literal|"term.term="
operator|+
name|term
operator|.
name|termBytes
operator|+
literal|" prefix="
operator|+
name|prefix
assert|;
name|BlockTermState
name|state
init|=
name|term
operator|.
name|state
decl_stmt|;
name|maxVersionInBlock
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxVersionInBlock
argument_list|,
operator|(
operator|(
name|IDVersionTermState
operator|)
name|state
operator|)
operator|.
name|idVersion
argument_list|)
expr_stmt|;
specifier|final
name|int
name|suffix
init|=
name|term
operator|.
name|termBytes
operator|.
name|length
operator|-
name|prefixLength
decl_stmt|;
comment|/*           if (DEBUG) {             BytesRef suffixBytes = new BytesRef(suffix);             System.arraycopy(term.term.bytes, prefixLength, suffixBytes.bytes, 0, suffix);             suffixBytes.length = suffix;             System.out.println("    write term suffix=" + suffixBytes);           }           */
comment|// For leaf block we write suffix straight
name|suffixWriter
operator|.
name|writeVInt
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
name|suffixWriter
operator|.
name|writeBytes
argument_list|(
name|term
operator|.
name|termBytes
argument_list|,
name|prefixLength
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
assert|assert
name|floorLeadLabel
operator|==
operator|-
literal|1
operator|||
operator|(
name|term
operator|.
name|termBytes
index|[
name|prefixLength
index|]
operator|&
literal|0xff
operator|)
operator|>=
name|floorLeadLabel
assert|;
comment|// Write term meta data
name|postingsWriter
operator|.
name|encodeTerm
argument_list|(
name|longs
argument_list|,
name|bytesWriter
argument_list|,
name|fieldInfo
argument_list|,
name|state
argument_list|,
name|absolute
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|longsSize
condition|;
name|pos
operator|++
control|)
block|{
assert|assert
name|longs
index|[
name|pos
index|]
operator|>=
literal|0
assert|;
name|metaWriter
operator|.
name|writeVLong
argument_list|(
name|longs
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
name|bytesWriter
operator|.
name|writeTo
argument_list|(
name|metaWriter
argument_list|)
expr_stmt|;
name|bytesWriter
operator|.
name|reset
argument_list|()
expr_stmt|;
name|absolute
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Mixed terms and sub-blocks:
name|subIndices
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|PendingEntry
name|ent
init|=
name|pending
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ent
operator|.
name|isTerm
condition|)
block|{
name|PendingTerm
name|term
init|=
operator|(
name|PendingTerm
operator|)
name|ent
decl_stmt|;
assert|assert
name|StringHelper
operator|.
name|startsWith
argument_list|(
name|term
operator|.
name|termBytes
argument_list|,
name|prefix
argument_list|)
operator|:
literal|"term.term="
operator|+
name|term
operator|.
name|termBytes
operator|+
literal|" prefix="
operator|+
name|prefix
assert|;
name|BlockTermState
name|state
init|=
name|term
operator|.
name|state
decl_stmt|;
name|maxVersionInBlock
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxVersionInBlock
argument_list|,
operator|(
operator|(
name|IDVersionTermState
operator|)
name|state
operator|)
operator|.
name|idVersion
argument_list|)
expr_stmt|;
specifier|final
name|int
name|suffix
init|=
name|term
operator|.
name|termBytes
operator|.
name|length
operator|-
name|prefixLength
decl_stmt|;
comment|/*             if (DEBUG) {               BytesRef suffixBytes = new BytesRef(suffix);               System.arraycopy(term.term.bytes, prefixLength, suffixBytes.bytes, 0, suffix);               suffixBytes.length = suffix;               System.out.println("    write term suffix=" + suffixBytes);             }             */
comment|// For non-leaf block we borrow 1 bit to record
comment|// if entry is term or sub-block
name|suffixWriter
operator|.
name|writeVInt
argument_list|(
name|suffix
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|suffixWriter
operator|.
name|writeBytes
argument_list|(
name|term
operator|.
name|termBytes
argument_list|,
name|prefixLength
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
assert|assert
name|floorLeadLabel
operator|==
operator|-
literal|1
operator|||
operator|(
name|term
operator|.
name|termBytes
index|[
name|prefixLength
index|]
operator|&
literal|0xff
operator|)
operator|>=
name|floorLeadLabel
assert|;
comment|// TODO: now that terms dict "sees" these longs,
comment|// we can explore better column-stride encodings
comment|// to encode all long[0]s for this block at
comment|// once, all long[1]s, etc., e.g. using
comment|// Simple64.  Alternatively, we could interleave
comment|// stats + meta ... no reason to have them
comment|// separate anymore:
comment|// Write term meta data
name|postingsWriter
operator|.
name|encodeTerm
argument_list|(
name|longs
argument_list|,
name|bytesWriter
argument_list|,
name|fieldInfo
argument_list|,
name|state
argument_list|,
name|absolute
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|longsSize
condition|;
name|pos
operator|++
control|)
block|{
assert|assert
name|longs
index|[
name|pos
index|]
operator|>=
literal|0
assert|;
name|metaWriter
operator|.
name|writeVLong
argument_list|(
name|longs
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
name|bytesWriter
operator|.
name|writeTo
argument_list|(
name|metaWriter
argument_list|)
expr_stmt|;
name|bytesWriter
operator|.
name|reset
argument_list|()
expr_stmt|;
name|absolute
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|PendingBlock
name|block
init|=
operator|(
name|PendingBlock
operator|)
name|ent
decl_stmt|;
name|maxVersionInBlock
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxVersionInBlock
argument_list|,
name|block
operator|.
name|maxVersion
argument_list|)
expr_stmt|;
assert|assert
name|StringHelper
operator|.
name|startsWith
argument_list|(
name|block
operator|.
name|prefix
argument_list|,
name|prefix
argument_list|)
assert|;
specifier|final
name|int
name|suffix
init|=
name|block
operator|.
name|prefix
operator|.
name|length
operator|-
name|prefixLength
decl_stmt|;
assert|assert
name|suffix
operator|>
literal|0
assert|;
comment|// For non-leaf block we borrow 1 bit to record
comment|// if entry is term or sub-block
name|suffixWriter
operator|.
name|writeVInt
argument_list|(
operator|(
name|suffix
operator|<<
literal|1
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|suffixWriter
operator|.
name|writeBytes
argument_list|(
name|block
operator|.
name|prefix
operator|.
name|bytes
argument_list|,
name|prefixLength
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
assert|assert
name|floorLeadLabel
operator|==
operator|-
literal|1
operator|||
operator|(
name|block
operator|.
name|prefix
operator|.
name|bytes
index|[
name|prefixLength
index|]
operator|&
literal|0xff
operator|)
operator|>=
name|floorLeadLabel
assert|;
assert|assert
name|block
operator|.
name|fp
operator|<
name|startFP
assert|;
comment|/*             if (DEBUG) {               BytesRef suffixBytes = new BytesRef(suffix);               System.arraycopy(block.prefix.bytes, prefixLength, suffixBytes.bytes, 0, suffix);               suffixBytes.length = suffix;               System.out.println("    write sub-block suffix=" + brToString(suffixBytes) + " subFP=" + block.fp + " subCode=" + (startFP-block.fp) + " floor=" + block.isFloor);             }             */
name|suffixWriter
operator|.
name|writeVLong
argument_list|(
name|startFP
operator|-
name|block
operator|.
name|fp
argument_list|)
expr_stmt|;
name|subIndices
operator|.
name|add
argument_list|(
name|block
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|subIndices
operator|.
name|size
argument_list|()
operator|!=
literal|0
assert|;
block|}
comment|// TODO: we could block-write the term suffix pointers;
comment|// this would take more space but would enable binary
comment|// search on lookup
comment|// Write suffixes byte[] blob to terms dict output:
name|out
operator|.
name|writeVInt
argument_list|(
call|(
name|int
call|)
argument_list|(
name|suffixWriter
operator|.
name|getFilePointer
argument_list|()
operator|<<
literal|1
argument_list|)
operator||
operator|(
name|isLeafBlock
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|suffixWriter
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|suffixWriter
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Write term meta data byte[] blob
name|out
operator|.
name|writeVInt
argument_list|(
operator|(
name|int
operator|)
name|metaWriter
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
name|metaWriter
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|metaWriter
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("      fpEnd=" + out.getFilePointer());
comment|// }
if|if
condition|(
name|hasFloorLeadLabel
condition|)
block|{
comment|// We already allocated to length+1 above:
name|prefix
operator|.
name|bytes
index|[
name|prefix
operator|.
name|length
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|floorLeadLabel
expr_stmt|;
block|}
return|return
operator|new
name|PendingBlock
argument_list|(
name|prefix
argument_list|,
name|maxVersionInBlock
argument_list|,
name|startFP
argument_list|,
name|hasTerms
argument_list|,
name|isFloor
argument_list|,
name|floorLeadLabel
argument_list|,
name|subIndices
argument_list|)
return|;
block|}
DECL|method|TermsWriter
name|TermsWriter
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
name|this
operator|.
name|fieldInfo
operator|=
name|fieldInfo
expr_stmt|;
name|docsSeen
operator|=
operator|new
name|FixedBitSet
argument_list|(
name|maxDoc
argument_list|)
expr_stmt|;
name|this
operator|.
name|longsSize
operator|=
name|postingsWriter
operator|.
name|setField
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
name|this
operator|.
name|longs
operator|=
operator|new
name|long
index|[
name|longsSize
index|]
expr_stmt|;
block|}
comment|/** Writes one term's worth of postings. */
DECL|method|write
specifier|public
name|void
name|write
parameter_list|(
name|BytesRef
name|text
parameter_list|,
name|TermsEnum
name|termsEnum
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockTermState
name|state
init|=
name|postingsWriter
operator|.
name|writeTerm
argument_list|(
name|text
argument_list|,
name|termsEnum
argument_list|,
name|docsSeen
argument_list|)
decl_stmt|;
comment|// TODO: LUCENE-5693: we don't need this check if we fix IW to not send deleted docs to us on flush:
if|if
condition|(
name|state
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|IDVersionPostingsWriter
operator|)
name|postingsWriter
operator|)
operator|.
name|lastDocID
operator|!=
operator|-
literal|1
condition|)
block|{
assert|assert
name|state
operator|.
name|docFreq
operator|!=
literal|0
assert|;
assert|assert
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|==
name|IndexOptions
operator|.
name|DOCS_ONLY
operator|||
name|state
operator|.
name|totalTermFreq
operator|>=
name|state
operator|.
name|docFreq
operator|:
literal|"postingsWriter="
operator|+
name|postingsWriter
assert|;
name|pushTerm
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|PendingTerm
name|term
init|=
operator|new
name|PendingTerm
argument_list|(
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|text
argument_list|)
argument_list|,
name|state
argument_list|)
decl_stmt|;
name|pending
operator|.
name|add
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|numTerms
operator|++
expr_stmt|;
if|if
condition|(
name|firstPendingTerm
operator|==
literal|null
condition|)
block|{
name|firstPendingTerm
operator|=
name|term
expr_stmt|;
block|}
name|lastPendingTerm
operator|=
name|term
expr_stmt|;
block|}
block|}
comment|/** Pushes the new term to the top of the stack, and writes new blocks. */
DECL|method|pushTerm
specifier|private
name|void
name|pushTerm
parameter_list|(
name|BytesRef
name|text
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|limit
init|=
name|Math
operator|.
name|min
argument_list|(
name|lastTerm
operator|.
name|length
argument_list|()
argument_list|,
name|text
operator|.
name|length
argument_list|)
decl_stmt|;
comment|// Find common prefix between last term and current term:
name|int
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|limit
operator|&&
name|lastTerm
operator|.
name|byteAt
argument_list|(
name|pos
argument_list|)
operator|==
name|text
operator|.
name|bytes
index|[
name|text
operator|.
name|offset
operator|+
name|pos
index|]
condition|)
block|{
name|pos
operator|++
expr_stmt|;
block|}
comment|// if (DEBUG) System.out.println("  shared=" + pos + "  lastTerm.length=" + lastTerm.length);
comment|// Close the "abandoned" suffix now:
for|for
control|(
name|int
name|i
init|=
name|lastTerm
operator|.
name|length
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
name|pos
condition|;
name|i
operator|--
control|)
block|{
comment|// How many items on top of the stack share the current suffix
comment|// we are closing:
name|int
name|prefixTopSize
init|=
name|pending
operator|.
name|size
argument_list|()
operator|-
name|prefixStarts
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|prefixTopSize
operator|>=
name|minItemsInBlock
condition|)
block|{
comment|// if (DEBUG) System.out.println("pushTerm i=" + i + " prefixTopSize=" + prefixTopSize + " minItemsInBlock=" + minItemsInBlock);
name|writeBlocks
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|prefixTopSize
argument_list|)
expr_stmt|;
name|prefixStarts
index|[
name|i
index|]
operator|-=
name|prefixTopSize
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prefixStarts
operator|.
name|length
operator|<
name|text
operator|.
name|length
condition|)
block|{
name|prefixStarts
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|prefixStarts
argument_list|,
name|text
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|// Init new tail:
for|for
control|(
name|int
name|i
init|=
name|pos
init|;
name|i
operator|<
name|text
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|prefixStarts
index|[
name|i
index|]
operator|=
name|pending
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|lastTerm
operator|.
name|copyBytes
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
comment|// Finishes all terms in this field
DECL|method|finish
specifier|public
name|void
name|finish
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|numTerms
operator|>
literal|0
condition|)
block|{
comment|// TODO: if pending.size() is already 1 with a non-zero prefix length
comment|// we can save writing a "degenerate" root block, but we have to
comment|// fix all the places that assume the root block's prefix is the empty string:
name|writeBlocks
argument_list|(
literal|0
argument_list|,
name|pending
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// We better have one final "root" block:
assert|assert
name|pending
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|!
name|pending
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|isTerm
operator|:
literal|"pending.size()="
operator|+
name|pending
operator|.
name|size
argument_list|()
operator|+
literal|" pending="
operator|+
name|pending
assert|;
specifier|final
name|PendingBlock
name|root
init|=
operator|(
name|PendingBlock
operator|)
name|pending
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
name|root
operator|.
name|prefix
operator|.
name|length
operator|==
literal|0
assert|;
assert|assert
name|root
operator|.
name|index
operator|.
name|getEmptyOutput
argument_list|()
operator|!=
literal|null
assert|;
comment|// Write FST to index
name|indexStartFP
operator|=
name|indexOut
operator|.
name|getFilePointer
argument_list|()
expr_stmt|;
name|root
operator|.
name|index
operator|.
name|save
argument_list|(
name|indexOut
argument_list|)
expr_stmt|;
comment|//System.out.println("  write FST " + indexStartFP + " field=" + fieldInfo.name);
comment|// if (SAVE_DOT_FILES || DEBUG) {
comment|//   final String dotFileName = segment + "_" + fieldInfo.name + ".dot";
comment|//   Writer w = new OutputStreamWriter(new FileOutputStream(dotFileName));
comment|//   Util.toDot(root.index, w, false, false);
comment|//   System.out.println("SAVED to " + dotFileName);
comment|//   w.close();
comment|// }
assert|assert
name|firstPendingTerm
operator|!=
literal|null
assert|;
name|BytesRef
name|minTerm
init|=
operator|new
name|BytesRef
argument_list|(
name|firstPendingTerm
operator|.
name|termBytes
argument_list|)
decl_stmt|;
assert|assert
name|lastPendingTerm
operator|!=
literal|null
assert|;
name|BytesRef
name|maxTerm
init|=
operator|new
name|BytesRef
argument_list|(
name|lastPendingTerm
operator|.
name|termBytes
argument_list|)
decl_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|FieldMetaData
argument_list|(
name|fieldInfo
argument_list|,
operator|(
operator|(
name|PendingBlock
operator|)
name|pending
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|index
operator|.
name|getEmptyOutput
argument_list|()
argument_list|,
name|numTerms
argument_list|,
name|indexStartFP
argument_list|,
name|longsSize
argument_list|,
name|minTerm
argument_list|,
name|maxTerm
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// cannot assert this: we skip deleted docIDs in the postings:
comment|// assert docsSeen.cardinality() == 0;
block|}
block|}
DECL|field|suffixWriter
specifier|private
specifier|final
name|RAMOutputStream
name|suffixWriter
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
DECL|field|metaWriter
specifier|private
specifier|final
name|RAMOutputStream
name|metaWriter
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
DECL|field|bytesWriter
specifier|private
specifier|final
name|RAMOutputStream
name|bytesWriter
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
specifier|final
name|long
name|dirStart
init|=
name|out
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
specifier|final
name|long
name|indexDirStart
init|=
name|indexOut
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|fields
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|FieldMetaData
name|field
range|:
name|fields
control|)
block|{
comment|//System.out.println("  field " + field.fieldInfo.name + " " + field.numTerms + " terms");
name|out
operator|.
name|writeVInt
argument_list|(
name|field
operator|.
name|fieldInfo
operator|.
name|number
argument_list|)
expr_stmt|;
assert|assert
name|field
operator|.
name|numTerms
operator|>
literal|0
assert|;
name|out
operator|.
name|writeVLong
argument_list|(
name|field
operator|.
name|numTerms
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|field
operator|.
name|rootCode
operator|.
name|output1
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|field
operator|.
name|rootCode
operator|.
name|output1
operator|.
name|bytes
argument_list|,
name|field
operator|.
name|rootCode
operator|.
name|output1
operator|.
name|offset
argument_list|,
name|field
operator|.
name|rootCode
operator|.
name|output1
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|field
operator|.
name|rootCode
operator|.
name|output2
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|field
operator|.
name|longsSize
argument_list|)
expr_stmt|;
name|indexOut
operator|.
name|writeVLong
argument_list|(
name|field
operator|.
name|indexStartFP
argument_list|)
expr_stmt|;
name|writeBytesRef
argument_list|(
name|out
argument_list|,
name|field
operator|.
name|minTerm
argument_list|)
expr_stmt|;
name|writeBytesRef
argument_list|(
name|out
argument_list|,
name|field
operator|.
name|maxTerm
argument_list|)
expr_stmt|;
block|}
name|writeTrailer
argument_list|(
name|out
argument_list|,
name|dirStart
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|writeFooter
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|writeIndexTrailer
argument_list|(
name|indexOut
argument_list|,
name|indexDirStart
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|writeFooter
argument_list|(
name|indexOut
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|out
argument_list|,
name|indexOut
argument_list|,
name|postingsWriter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|out
argument_list|,
name|indexOut
argument_list|,
name|postingsWriter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|writeBytesRef
specifier|private
specifier|static
name|void
name|writeBytesRef
parameter_list|(
name|IndexOutput
name|out
parameter_list|,
name|BytesRef
name|bytes
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeVInt
argument_list|(
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|bytes
operator|.
name|bytes
argument_list|,
name|bytes
operator|.
name|offset
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
end_class
end_unit
