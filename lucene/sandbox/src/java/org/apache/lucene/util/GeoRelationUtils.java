begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_comment
comment|/**  * Reusable geo-relation utility methods  */
end_comment
begin_class
DECL|class|GeoRelationUtils
specifier|public
class|class
name|GeoRelationUtils
block|{
comment|/**    * Determine if a bbox (defined by minLon, minLat, maxLon, maxLat) contains the provided point (defined by lon, lat)    * NOTE: this is a basic method that does not handle dateline or pole crossing. Unwrapping must be done before    * calling this method.    */
DECL|method|pointInRectPrecise
specifier|public
specifier|static
name|boolean
name|pointInRectPrecise
parameter_list|(
specifier|final
name|double
name|lon
parameter_list|,
specifier|final
name|double
name|lat
parameter_list|,
specifier|final
name|double
name|minLon
parameter_list|,
specifier|final
name|double
name|minLat
parameter_list|,
specifier|final
name|double
name|maxLon
parameter_list|,
specifier|final
name|double
name|maxLat
parameter_list|)
block|{
return|return
name|lon
operator|>=
name|minLon
operator|&&
name|lon
operator|<=
name|maxLon
operator|&&
name|lat
operator|>=
name|minLat
operator|&&
name|lat
operator|<=
name|maxLat
return|;
block|}
comment|/**    * simple even-odd point in polygon computation    *    1.  Determine if point is contained in the longitudinal range    *    2.  Determine whether point crosses the edge by computing the latitudinal delta    *        between the end-point of a parallel vector (originating at the point) and the    *        y-component of the edge sink    *    * NOTE: Requires polygon point (x,y) order either clockwise or counter-clockwise    */
DECL|method|pointInPolygon
specifier|public
specifier|static
name|boolean
name|pointInPolygon
parameter_list|(
name|double
index|[]
name|x
parameter_list|,
name|double
index|[]
name|y
parameter_list|,
name|double
name|lat
parameter_list|,
name|double
name|lon
parameter_list|)
block|{
assert|assert
name|x
operator|.
name|length
operator|==
name|y
operator|.
name|length
assert|;
name|boolean
name|inPoly
init|=
literal|false
decl_stmt|;
comment|/**      * Note: This is using a euclidean coordinate system which could result in      * upwards of 110KM error at the equator.      * TODO convert coordinates to cylindrical projection (e.g. mercator)      */
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|x
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|x
index|[
name|i
index|]
operator|<=
name|lon
operator|&&
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|>=
name|lon
operator|||
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|<=
name|lon
operator|&&
name|x
index|[
name|i
index|]
operator|>=
name|lon
condition|)
block|{
if|if
condition|(
name|y
index|[
name|i
index|]
operator|+
operator|(
name|lon
operator|-
name|x
index|[
name|i
index|]
operator|)
operator|/
operator|(
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|x
index|[
name|i
index|]
operator|)
operator|*
operator|(
name|y
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|y
index|[
name|i
index|]
operator|)
operator|<=
name|lat
condition|)
block|{
name|inPoly
operator|=
operator|!
name|inPoly
expr_stmt|;
block|}
block|}
block|}
return|return
name|inPoly
return|;
block|}
comment|/////////////////////////
comment|// Rectangle relations
comment|/////////////////////////
DECL|method|rectDisjoint
specifier|public
specifier|static
name|boolean
name|rectDisjoint
parameter_list|(
specifier|final
name|double
name|aMinX
parameter_list|,
specifier|final
name|double
name|aMinY
parameter_list|,
specifier|final
name|double
name|aMaxX
parameter_list|,
specifier|final
name|double
name|aMaxY
parameter_list|,
specifier|final
name|double
name|bMinX
parameter_list|,
specifier|final
name|double
name|bMinY
parameter_list|,
specifier|final
name|double
name|bMaxX
parameter_list|,
specifier|final
name|double
name|bMaxY
parameter_list|)
block|{
return|return
operator|(
name|aMaxX
argument_list|<
name|bMinX
operator|||
name|aMinX
argument_list|>
name|bMaxX
operator|||
name|aMaxY
argument_list|<
name|bMinY
operator|||
name|aMinY
argument_list|>
name|bMaxY
operator|)
return|;
block|}
comment|/**    * Computes whether the first (a) rectangle is wholly within another (b) rectangle (shared boundaries allowed)    */
DECL|method|rectWithin
specifier|public
specifier|static
name|boolean
name|rectWithin
parameter_list|(
specifier|final
name|double
name|aMinX
parameter_list|,
specifier|final
name|double
name|aMinY
parameter_list|,
specifier|final
name|double
name|aMaxX
parameter_list|,
specifier|final
name|double
name|aMaxY
parameter_list|,
specifier|final
name|double
name|bMinX
parameter_list|,
specifier|final
name|double
name|bMinY
parameter_list|,
specifier|final
name|double
name|bMaxX
parameter_list|,
specifier|final
name|double
name|bMaxY
parameter_list|)
block|{
return|return
operator|!
operator|(
name|aMinX
argument_list|<
name|bMinX
operator|||
name|aMinY
argument_list|<
name|bMinY
operator|||
name|aMaxX
argument_list|>
name|bMaxX
operator|||
name|aMaxY
argument_list|>
name|bMaxY
operator|)
return|;
block|}
DECL|method|rectCrosses
specifier|public
specifier|static
name|boolean
name|rectCrosses
parameter_list|(
specifier|final
name|double
name|aMinX
parameter_list|,
specifier|final
name|double
name|aMinY
parameter_list|,
specifier|final
name|double
name|aMaxX
parameter_list|,
specifier|final
name|double
name|aMaxY
parameter_list|,
specifier|final
name|double
name|bMinX
parameter_list|,
specifier|final
name|double
name|bMinY
parameter_list|,
specifier|final
name|double
name|bMaxX
parameter_list|,
specifier|final
name|double
name|bMaxY
parameter_list|)
block|{
return|return
operator|!
operator|(
name|rectDisjoint
argument_list|(
name|aMinX
argument_list|,
name|aMinY
argument_list|,
name|aMaxX
argument_list|,
name|aMaxY
argument_list|,
name|bMinX
argument_list|,
name|bMinY
argument_list|,
name|bMaxX
argument_list|,
name|bMaxY
argument_list|)
operator|||
name|rectWithin
argument_list|(
name|aMinX
argument_list|,
name|aMinY
argument_list|,
name|aMaxX
argument_list|,
name|aMaxY
argument_list|,
name|bMinX
argument_list|,
name|bMinY
argument_list|,
name|bMaxX
argument_list|,
name|bMaxY
argument_list|)
operator|)
return|;
block|}
comment|/**    * Computes whether rectangle a contains rectangle b (touching allowed)    */
DECL|method|rectContains
specifier|public
specifier|static
name|boolean
name|rectContains
parameter_list|(
specifier|final
name|double
name|aMinX
parameter_list|,
specifier|final
name|double
name|aMinY
parameter_list|,
specifier|final
name|double
name|aMaxX
parameter_list|,
specifier|final
name|double
name|aMaxY
parameter_list|,
specifier|final
name|double
name|bMinX
parameter_list|,
specifier|final
name|double
name|bMinY
parameter_list|,
specifier|final
name|double
name|bMaxX
parameter_list|,
specifier|final
name|double
name|bMaxY
parameter_list|)
block|{
return|return
operator|!
operator|(
name|bMinX
argument_list|<
name|aMinX
operator|||
name|bMinY
argument_list|<
name|aMinY
operator|||
name|bMaxX
argument_list|>
name|aMaxX
operator|||
name|bMaxY
argument_list|>
name|aMaxY
operator|)
return|;
block|}
comment|/**    * Computes whether a rectangle intersects another rectangle (crosses, within, touching, etc)    */
DECL|method|rectIntersects
specifier|public
specifier|static
name|boolean
name|rectIntersects
parameter_list|(
specifier|final
name|double
name|aMinX
parameter_list|,
specifier|final
name|double
name|aMinY
parameter_list|,
specifier|final
name|double
name|aMaxX
parameter_list|,
specifier|final
name|double
name|aMaxY
parameter_list|,
specifier|final
name|double
name|bMinX
parameter_list|,
specifier|final
name|double
name|bMinY
parameter_list|,
specifier|final
name|double
name|bMaxX
parameter_list|,
specifier|final
name|double
name|bMaxY
parameter_list|)
block|{
return|return
operator|!
operator|(
operator|(
name|aMaxX
argument_list|<
name|bMinX
operator|||
name|aMinX
argument_list|>
name|bMaxX
operator|||
name|aMaxY
argument_list|<
name|bMinY
operator|||
name|aMinY
argument_list|>
name|bMaxY
operator|)
operator|)
return|;
block|}
comment|/////////////////////////
comment|// Polygon relations
comment|/////////////////////////
comment|/**    * Convenience method for accurately computing whether a rectangle crosses a poly    */
DECL|method|rectCrossesPolyPrecise
specifier|public
specifier|static
name|boolean
name|rectCrossesPolyPrecise
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
index|[]
name|shapeX
parameter_list|,
specifier|final
name|double
index|[]
name|shapeY
parameter_list|,
specifier|final
name|double
name|sMinX
parameter_list|,
specifier|final
name|double
name|sMinY
parameter_list|,
specifier|final
name|double
name|sMaxX
parameter_list|,
specifier|final
name|double
name|sMaxY
parameter_list|)
block|{
comment|// short-circuit: if the bounding boxes are disjoint then the shape does not cross
if|if
condition|(
name|rectDisjoint
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|sMinX
argument_list|,
name|sMinY
argument_list|,
name|sMaxX
argument_list|,
name|sMaxY
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|rectCrossesPoly
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|shapeX
argument_list|,
name|shapeY
argument_list|)
return|;
block|}
comment|/**    * Compute whether a rectangle crosses a shape. (touching not allowed) Includes a flag for approximating the    * relation.    */
DECL|method|rectCrossesPolyApprox
specifier|public
specifier|static
name|boolean
name|rectCrossesPolyApprox
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
index|[]
name|shapeX
parameter_list|,
specifier|final
name|double
index|[]
name|shapeY
parameter_list|,
specifier|final
name|double
name|sMinX
parameter_list|,
specifier|final
name|double
name|sMinY
parameter_list|,
specifier|final
name|double
name|sMaxX
parameter_list|,
specifier|final
name|double
name|sMaxY
parameter_list|)
block|{
comment|// short-circuit: if the bounding boxes are disjoint then the shape does not cross
if|if
condition|(
name|rectDisjoint
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|sMinX
argument_list|,
name|sMinY
argument_list|,
name|sMaxX
argument_list|,
name|sMaxY
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|polyLength
init|=
name|shapeX
operator|.
name|length
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|short
name|p
init|=
literal|0
init|;
name|p
operator|<
name|polyLength
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|lineCrossesRect
argument_list|(
name|shapeX
index|[
name|p
index|]
argument_list|,
name|shapeY
index|[
name|p
index|]
argument_list|,
name|shapeX
index|[
name|p
operator|+
literal|1
index|]
argument_list|,
name|shapeY
index|[
name|p
operator|+
literal|1
index|]
argument_list|,
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|)
operator|==
literal|true
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Accurately compute (within restrictions of cartesian decimal degrees) whether a rectangle crosses a polygon    */
DECL|method|rectCrossesPoly
specifier|private
specifier|static
name|boolean
name|rectCrossesPoly
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
index|[]
name|shapeX
parameter_list|,
specifier|final
name|double
index|[]
name|shapeY
parameter_list|)
block|{
specifier|final
name|double
index|[]
index|[]
name|bbox
init|=
operator|new
name|double
index|[]
index|[]
block|{
block|{
name|rMinX
block|,
name|rMinY
block|}
block|,
block|{
name|rMaxX
block|,
name|rMinY
block|}
block|,
block|{
name|rMaxX
block|,
name|rMaxY
block|}
block|,
block|{
name|rMinX
block|,
name|rMaxY
block|}
block|,
block|{
name|rMinX
block|,
name|rMinY
block|}
block|}
decl_stmt|;
specifier|final
name|int
name|polyLength
init|=
name|shapeX
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|double
name|d
decl_stmt|,
name|s
decl_stmt|,
name|t
decl_stmt|,
name|a1
decl_stmt|,
name|b1
decl_stmt|,
name|c1
decl_stmt|,
name|a2
decl_stmt|,
name|b2
decl_stmt|,
name|c2
decl_stmt|;
name|double
name|x00
decl_stmt|,
name|y00
decl_stmt|,
name|x01
decl_stmt|,
name|y01
decl_stmt|,
name|x10
decl_stmt|,
name|y10
decl_stmt|,
name|x11
decl_stmt|,
name|y11
decl_stmt|;
comment|// computes the intersection point between each bbox edge and the polygon edge
for|for
control|(
name|short
name|b
init|=
literal|0
init|;
name|b
operator|<
literal|4
condition|;
operator|++
name|b
control|)
block|{
name|a1
operator|=
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|1
index|]
operator|-
name|bbox
index|[
name|b
index|]
index|[
literal|1
index|]
expr_stmt|;
name|b1
operator|=
name|bbox
index|[
name|b
index|]
index|[
literal|0
index|]
operator|-
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|c1
operator|=
name|a1
operator|*
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|b1
operator|*
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|int
name|p
init|=
literal|0
init|;
name|p
operator|<
name|polyLength
condition|;
operator|++
name|p
control|)
block|{
name|a2
operator|=
name|shapeY
index|[
name|p
operator|+
literal|1
index|]
operator|-
name|shapeY
index|[
name|p
index|]
expr_stmt|;
name|b2
operator|=
name|shapeX
index|[
name|p
index|]
operator|-
name|shapeX
index|[
name|p
operator|+
literal|1
index|]
expr_stmt|;
comment|// compute determinant
name|d
operator|=
name|a1
operator|*
name|b2
operator|-
name|a2
operator|*
name|b1
expr_stmt|;
if|if
condition|(
name|d
operator|!=
literal|0
condition|)
block|{
comment|// lines are not parallel, check intersecting points
name|c2
operator|=
name|a2
operator|*
name|shapeX
index|[
name|p
operator|+
literal|1
index|]
operator|+
name|b2
operator|*
name|shapeY
index|[
name|p
operator|+
literal|1
index|]
expr_stmt|;
name|s
operator|=
operator|(
literal|1
operator|/
name|d
operator|)
operator|*
operator|(
name|b2
operator|*
name|c1
operator|-
name|b1
operator|*
name|c2
operator|)
expr_stmt|;
name|t
operator|=
operator|(
literal|1
operator|/
name|d
operator|)
operator|*
operator|(
name|a1
operator|*
name|c2
operator|-
name|a2
operator|*
name|c1
operator|)
expr_stmt|;
name|x00
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|bbox
index|[
name|b
index|]
index|[
literal|0
index|]
argument_list|,
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|-
name|GeoUtils
operator|.
name|TOLERANCE
expr_stmt|;
name|x01
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|bbox
index|[
name|b
index|]
index|[
literal|0
index|]
argument_list|,
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|+
name|GeoUtils
operator|.
name|TOLERANCE
expr_stmt|;
name|y00
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|bbox
index|[
name|b
index|]
index|[
literal|1
index|]
argument_list|,
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|-
name|GeoUtils
operator|.
name|TOLERANCE
expr_stmt|;
name|y01
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|bbox
index|[
name|b
index|]
index|[
literal|1
index|]
argument_list|,
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|+
name|GeoUtils
operator|.
name|TOLERANCE
expr_stmt|;
name|x10
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|shapeX
index|[
name|p
index|]
argument_list|,
name|shapeX
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
operator|-
name|GeoUtils
operator|.
name|TOLERANCE
expr_stmt|;
name|x11
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|shapeX
index|[
name|p
index|]
argument_list|,
name|shapeX
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
operator|+
name|GeoUtils
operator|.
name|TOLERANCE
expr_stmt|;
name|y10
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|shapeY
index|[
name|p
index|]
argument_list|,
name|shapeY
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
operator|-
name|GeoUtils
operator|.
name|TOLERANCE
expr_stmt|;
name|y11
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|shapeY
index|[
name|p
index|]
argument_list|,
name|shapeY
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
operator|+
name|GeoUtils
operator|.
name|TOLERANCE
expr_stmt|;
comment|// check whether the intersection point is touching one of the line segments
name|boolean
name|touching
init|=
operator|(
operator|(
name|x00
operator|==
name|s
operator|&&
name|y00
operator|==
name|t
operator|)
operator|||
operator|(
name|x01
operator|==
name|s
operator|&&
name|y01
operator|==
name|t
operator|)
operator|)
operator|||
operator|(
operator|(
name|x10
operator|==
name|s
operator|&&
name|y10
operator|==
name|t
operator|)
operator|||
operator|(
name|x11
operator|==
name|s
operator|&&
name|y11
operator|==
name|t
operator|)
operator|)
decl_stmt|;
comment|// if line segments are not touching and the intersection point is within the range of either segment
if|if
condition|(
operator|!
operator|(
name|touching
operator|||
name|x00
operator|>
name|s
operator|||
name|x01
argument_list|<
name|s
operator|||
name|y00
argument_list|>
name|t
operator|||
name|y01
argument_list|<
name|t
operator|||
name|x10
argument_list|>
name|s
operator|||
name|x11
argument_list|<
name|s
operator|||
name|y10
argument_list|>
name|t
operator|||
name|y11
operator|<
name|t
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
comment|// for each poly edge
block|}
comment|// for each bbox edge
return|return
literal|false
return|;
block|}
DECL|method|lineCrossesRect
specifier|private
specifier|static
name|boolean
name|lineCrossesRect
parameter_list|(
name|double
name|aX1
parameter_list|,
name|double
name|aY1
parameter_list|,
name|double
name|aX2
parameter_list|,
name|double
name|aY2
parameter_list|,
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|)
block|{
comment|// short-circuit: if one point inside rect, other outside
if|if
condition|(
name|pointInRectPrecise
argument_list|(
name|aX1
argument_list|,
name|aY1
argument_list|,
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|)
condition|?
operator|!
name|pointInRectPrecise
argument_list|(
name|aX2
argument_list|,
name|aY2
argument_list|,
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|)
else|:
name|pointInRectPrecise
argument_list|(
name|aX2
argument_list|,
name|aY2
argument_list|,
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|lineCrossesLine
argument_list|(
name|aX1
argument_list|,
name|aY1
argument_list|,
name|aX2
argument_list|,
name|aY2
argument_list|,
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|)
operator|||
name|lineCrossesLine
argument_list|(
name|aX1
argument_list|,
name|aY1
argument_list|,
name|aX2
argument_list|,
name|aY2
argument_list|,
name|rMaxX
argument_list|,
name|rMinY
argument_list|,
name|rMinX
argument_list|,
name|rMaxY
argument_list|)
return|;
block|}
DECL|method|lineCrossesLine
specifier|private
specifier|static
name|boolean
name|lineCrossesLine
parameter_list|(
specifier|final
name|double
name|aX1
parameter_list|,
specifier|final
name|double
name|aY1
parameter_list|,
specifier|final
name|double
name|aX2
parameter_list|,
specifier|final
name|double
name|aY2
parameter_list|,
specifier|final
name|double
name|bX1
parameter_list|,
specifier|final
name|double
name|bY1
parameter_list|,
specifier|final
name|double
name|bX2
parameter_list|,
specifier|final
name|double
name|bY2
parameter_list|)
block|{
comment|// determine if three points are ccw (right-hand rule) by computing the determinate
specifier|final
name|double
name|aX2X1d
init|=
name|aX2
operator|-
name|aX1
decl_stmt|;
specifier|final
name|double
name|aY2Y1d
init|=
name|aY2
operator|-
name|aY1
decl_stmt|;
specifier|final
name|double
name|bX2X1d
init|=
name|bX2
operator|-
name|bX1
decl_stmt|;
specifier|final
name|double
name|bY2Y1d
init|=
name|bY2
operator|-
name|bY1
decl_stmt|;
specifier|final
name|double
name|t1B
init|=
name|aX2X1d
operator|*
operator|(
name|bY2
operator|-
name|aY1
operator|)
operator|-
name|aY2Y1d
operator|*
operator|(
name|bX2
operator|-
name|aX1
operator|)
decl_stmt|;
specifier|final
name|double
name|test1
init|=
operator|(
name|aX2X1d
operator|*
operator|(
name|bY1
operator|-
name|aY1
operator|)
operator|-
name|aY2Y1d
operator|*
operator|(
name|bX1
operator|-
name|aX1
operator|)
operator|)
operator|*
name|t1B
decl_stmt|;
specifier|final
name|double
name|t2B
init|=
name|bX2X1d
operator|*
operator|(
name|aY2
operator|-
name|bY1
operator|)
operator|-
name|bY2Y1d
operator|*
operator|(
name|aX2
operator|-
name|bX1
operator|)
decl_stmt|;
specifier|final
name|double
name|test2
init|=
operator|(
name|bX2X1d
operator|*
operator|(
name|aY1
operator|-
name|bY1
operator|)
operator|-
name|bY2Y1d
operator|*
operator|(
name|aX1
operator|-
name|bX1
operator|)
operator|)
operator|*
name|t2B
decl_stmt|;
if|if
condition|(
name|test1
operator|<
literal|0
operator|&&
name|test2
operator|<
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|test1
operator|==
literal|0
operator|||
name|test2
operator|==
literal|0
condition|)
block|{
comment|// vertically collinear
if|if
condition|(
name|aX1
operator|==
name|aX2
operator|||
name|bX1
operator|==
name|bX2
condition|)
block|{
specifier|final
name|double
name|minAy
init|=
name|Math
operator|.
name|min
argument_list|(
name|aY1
argument_list|,
name|aY2
argument_list|)
decl_stmt|;
specifier|final
name|double
name|maxAy
init|=
name|Math
operator|.
name|max
argument_list|(
name|aY1
argument_list|,
name|aY2
argument_list|)
decl_stmt|;
specifier|final
name|double
name|minBy
init|=
name|Math
operator|.
name|min
argument_list|(
name|bY1
argument_list|,
name|bY2
argument_list|)
decl_stmt|;
specifier|final
name|double
name|maxBy
init|=
name|Math
operator|.
name|max
argument_list|(
name|bY1
argument_list|,
name|bY2
argument_list|)
decl_stmt|;
return|return
operator|!
operator|(
name|minBy
operator|>=
name|maxAy
operator|||
name|maxBy
operator|<=
name|minAy
operator|)
return|;
block|}
comment|// horizontally collinear
specifier|final
name|double
name|minAx
init|=
name|Math
operator|.
name|min
argument_list|(
name|aX1
argument_list|,
name|aX2
argument_list|)
decl_stmt|;
specifier|final
name|double
name|maxAx
init|=
name|Math
operator|.
name|max
argument_list|(
name|aX1
argument_list|,
name|aX2
argument_list|)
decl_stmt|;
specifier|final
name|double
name|minBx
init|=
name|Math
operator|.
name|min
argument_list|(
name|bX1
argument_list|,
name|bX2
argument_list|)
decl_stmt|;
specifier|final
name|double
name|maxBx
init|=
name|Math
operator|.
name|max
argument_list|(
name|bX1
argument_list|,
name|bX2
argument_list|)
decl_stmt|;
return|return
operator|!
operator|(
name|minBx
operator|>=
name|maxAx
operator|||
name|maxBx
operator|<=
name|minAx
operator|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|rectWithinPolyPrecise
specifier|public
specifier|static
name|boolean
name|rectWithinPolyPrecise
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
index|[]
name|shapeX
parameter_list|,
specifier|final
name|double
index|[]
name|shapeY
parameter_list|,
specifier|final
name|double
name|sMinX
parameter_list|,
specifier|final
name|double
name|sMinY
parameter_list|,
specifier|final
name|double
name|sMaxX
parameter_list|,
specifier|final
name|double
name|sMaxY
parameter_list|)
block|{
comment|// check if rectangle crosses poly (to handle concave/pacman polys), then check that all 4 corners
comment|// are contained
return|return
operator|!
operator|(
name|rectCrossesPolyPrecise
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|sMinX
argument_list|,
name|sMinY
argument_list|,
name|sMaxX
argument_list|,
name|sMaxY
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|rMinY
argument_list|,
name|rMinX
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|rMaxY
argument_list|,
name|rMaxX
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|rMaxY
argument_list|,
name|rMinX
argument_list|)
operator|)
return|;
block|}
comment|/**    * Computes whether a rectangle is within a given polygon (shared boundaries allowed)    */
DECL|method|rectWithinPolyApprox
specifier|public
specifier|static
name|boolean
name|rectWithinPolyApprox
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
index|[]
name|shapeX
parameter_list|,
specifier|final
name|double
index|[]
name|shapeY
parameter_list|,
specifier|final
name|double
name|sMinX
parameter_list|,
specifier|final
name|double
name|sMinY
parameter_list|,
specifier|final
name|double
name|sMaxX
parameter_list|,
specifier|final
name|double
name|sMaxY
parameter_list|)
block|{
comment|// approximation: check if rectangle crosses poly (to handle concave/pacman polys), then check one of the corners
comment|// are contained
comment|// short-cut: if bounding boxes cross, rect is not within
if|if
condition|(
name|rectCrosses
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|sMinX
argument_list|,
name|sMinY
argument_list|,
name|sMaxX
argument_list|,
name|sMaxY
argument_list|)
operator|==
literal|true
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|!
operator|(
name|rectCrossesPolyApprox
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|sMinX
argument_list|,
name|sMinY
argument_list|,
name|sMaxX
argument_list|,
name|sMaxY
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|rMinY
argument_list|,
name|rMinX
argument_list|)
operator|)
return|;
block|}
comment|/////////////////////////
comment|// Circle relations
comment|/////////////////////////
DECL|method|rectAnyCornersInCircle
specifier|private
specifier|static
name|boolean
name|rectAnyCornersInCircle
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
name|centerLon
parameter_list|,
specifier|final
name|double
name|centerLat
parameter_list|,
specifier|final
name|double
name|radiusMeters
parameter_list|,
specifier|final
name|boolean
name|approx
parameter_list|)
block|{
if|if
condition|(
name|approx
operator|==
literal|true
condition|)
block|{
return|return
name|rectAnyCornersInCircleSloppy
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|radiusMeters
argument_list|)
return|;
block|}
name|double
name|w
init|=
name|Math
operator|.
name|abs
argument_list|(
name|rMaxX
operator|-
name|rMinX
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|<=
literal|90.0
condition|)
block|{
return|return
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|rMinX
argument_list|)
operator|<=
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|rMinX
argument_list|)
operator|<=
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|rMaxX
argument_list|)
operator|<=
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|)
operator|<=
name|radiusMeters
return|;
block|}
comment|// partition
name|w
operator|/=
literal|4
expr_stmt|;
specifier|final
name|double
name|p1
init|=
name|rMinX
operator|+
name|w
decl_stmt|;
specifier|final
name|double
name|p2
init|=
name|p1
operator|+
name|w
decl_stmt|;
specifier|final
name|double
name|p3
init|=
name|p2
operator|+
name|w
decl_stmt|;
return|return
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|rMinX
argument_list|)
operator|<=
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|rMinX
argument_list|)
operator|<=
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|p1
argument_list|)
operator|<=
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|p1
argument_list|)
operator|<=
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|p2
argument_list|)
operator|<=
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|p2
argument_list|)
operator|<=
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|p3
argument_list|)
operator|<=
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|p3
argument_list|)
operator|<=
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|rMaxX
argument_list|)
operator|<=
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|)
operator|<=
name|radiusMeters
return|;
block|}
DECL|method|rectAnyCornersInCircleSloppy
specifier|private
specifier|static
name|boolean
name|rectAnyCornersInCircleSloppy
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
name|centerLon
parameter_list|,
specifier|final
name|double
name|centerLat
parameter_list|,
specifier|final
name|double
name|radiusMeters
parameter_list|)
block|{
return|return
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|rMinX
argument_list|)
operator|*
literal|1000.0
operator|<=
name|radiusMeters
operator|||
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|rMinX
argument_list|)
operator|*
literal|1000.0
operator|<=
name|radiusMeters
operator|||
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|rMaxX
argument_list|)
operator|*
literal|1000.0
operator|<=
name|radiusMeters
operator|||
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|)
operator|*
literal|1000.0
operator|<=
name|radiusMeters
return|;
block|}
comment|/**    * Compute whether any of the 4 corners of the rectangle (defined by min/max X/Y) are outside the circle (defined    * by centerLon, centerLat, radiusMeters)    *    * Note: exotic rectangles at the poles (e.g., those whose lon/lat distance ratios greatly deviate from 1) can not    * be determined by using distance alone. For this reason the approx flag may be set to false, in which case the    * space will be further divided to more accurately compute whether the rectangle crosses the circle    */
DECL|method|rectAnyCornersOutsideCircle
specifier|private
specifier|static
name|boolean
name|rectAnyCornersOutsideCircle
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
name|centerLon
parameter_list|,
specifier|final
name|double
name|centerLat
parameter_list|,
specifier|final
name|double
name|radiusMeters
parameter_list|,
specifier|final
name|boolean
name|approx
parameter_list|)
block|{
if|if
condition|(
name|approx
operator|==
literal|true
condition|)
block|{
return|return
name|rectAnyCornersOutsideCircleSloppy
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|radiusMeters
argument_list|)
return|;
block|}
comment|// if span is less than 70 degrees we can approximate using distance alone
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|rMaxX
operator|-
name|rMinX
argument_list|)
operator|<=
literal|70.0
condition|)
block|{
return|return
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|rMinX
argument_list|)
operator|>
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|rMinX
argument_list|)
operator|>
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|rMaxX
argument_list|)
operator|>
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|)
operator|>
name|radiusMeters
return|;
block|}
return|return
name|rectCrossesOblateCircle
argument_list|(
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|radiusMeters
argument_list|,
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|)
return|;
block|}
comment|/**    * Compute whether the rectangle (defined by min/max Lon/Lat) crosses a potentially oblate circle    *    * TODO benchmark for replacing existing rectCrossesCircle.    */
DECL|method|rectCrossesOblateCircle
specifier|public
specifier|static
name|boolean
name|rectCrossesOblateCircle
parameter_list|(
name|double
name|centerLon
parameter_list|,
name|double
name|centerLat
parameter_list|,
name|double
name|radiusMeters
parameter_list|,
name|double
name|rMinLon
parameter_list|,
name|double
name|rMinLat
parameter_list|,
name|double
name|rMaxLon
parameter_list|,
name|double
name|rMaxLat
parameter_list|)
block|{
name|double
name|w
init|=
name|Math
operator|.
name|abs
argument_list|(
name|rMaxLon
operator|-
name|rMinLon
argument_list|)
decl_stmt|;
specifier|final
name|int
name|segs
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|w
operator|/
literal|45.0
argument_list|)
decl_stmt|;
name|w
operator|/=
name|segs
expr_stmt|;
name|short
name|i
init|=
literal|1
decl_stmt|;
name|double
name|p1
init|=
name|rMinLon
decl_stmt|;
name|double
name|maxLon
decl_stmt|,
name|midLon
decl_stmt|;
name|double
index|[]
name|pt
init|=
operator|new
name|double
index|[
literal|2
index|]
decl_stmt|;
do|do
block|{
name|maxLon
operator|=
operator|(
name|i
operator|==
name|segs
operator|)
condition|?
name|rMaxLon
else|:
name|p1
operator|+
name|w
expr_stmt|;
specifier|final
name|double
name|d1
decl_stmt|,
name|d2
decl_stmt|;
comment|// short-circuit if we find a corner outside the circle
if|if
condition|(
operator|(
name|d1
operator|=
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinLat
argument_list|,
name|p1
argument_list|)
operator|)
operator|>
name|radiusMeters
operator|||
operator|(
name|d2
operator|=
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinLat
argument_list|,
name|maxLon
argument_list|)
operator|)
operator|>
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxLat
argument_list|,
name|p1
argument_list|)
operator|>
name|radiusMeters
operator|||
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxLat
argument_list|,
name|maxLon
argument_list|)
operator|>
name|radiusMeters
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// else we treat as an oblate circle by slicing the longitude space and checking the azimuthal range
comment|// OPTIMIZATION: this is only executed for latitude values "closeTo" the poles (e.g., 88.0> lat< -88.0)
if|if
condition|(
operator|(
name|rMaxLat
operator|>
literal|88.0
operator|||
name|rMinLat
operator|<
operator|-
literal|88.0
operator|)
operator|&&
operator|(
name|pt
operator|=
name|GeoProjectionUtils
operator|.
name|pointFromLonLatBearingGreatCircle
argument_list|(
name|p1
argument_list|,
name|rMinLat
argument_list|,
name|GeoProjectionUtils
operator|.
name|bearingGreatCircle
argument_list|(
name|p1
argument_list|,
name|rMinLat
argument_list|,
name|p1
argument_list|,
name|rMaxLat
argument_list|)
argument_list|,
name|radiusMeters
operator|-
name|d1
argument_list|,
name|pt
argument_list|)
operator|)
index|[
literal|1
index|]
operator|<
name|rMinLat
operator|||
name|pt
index|[
literal|1
index|]
operator|<
name|rMaxLat
operator|||
operator|(
name|pt
operator|=
name|GeoProjectionUtils
operator|.
name|pointFromLonLatBearingGreatCircle
argument_list|(
name|maxLon
argument_list|,
name|rMinLat
argument_list|,
name|GeoProjectionUtils
operator|.
name|bearingGreatCircle
argument_list|(
name|maxLon
argument_list|,
name|rMinLat
argument_list|,
name|maxLon
argument_list|,
name|rMaxLat
argument_list|)
argument_list|,
name|radiusMeters
operator|-
name|d2
argument_list|,
name|pt
argument_list|)
operator|)
index|[
literal|1
index|]
operator|<
name|rMinLat
operator|||
name|pt
index|[
literal|1
index|]
operator|<
name|rMaxLat
operator|||
operator|(
name|pt
operator|=
name|GeoProjectionUtils
operator|.
name|pointFromLonLatBearingGreatCircle
argument_list|(
name|maxLon
argument_list|,
name|rMinLat
argument_list|,
name|GeoProjectionUtils
operator|.
name|bearingGreatCircle
argument_list|(
name|maxLon
argument_list|,
name|rMinLat
argument_list|,
operator|(
name|midLon
operator|=
name|p1
operator|+
literal|0.5
operator|*
operator|(
name|maxLon
operator|-
name|p1
operator|)
operator|)
argument_list|,
name|rMaxLat
argument_list|)
argument_list|,
name|radiusMeters
operator|-
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinLat
argument_list|,
name|midLon
argument_list|)
argument_list|,
name|pt
argument_list|)
operator|)
index|[
literal|1
index|]
operator|<
name|rMinLat
operator|||
name|pt
index|[
literal|1
index|]
operator|<
name|rMaxLat
operator|==
literal|false
condition|)
block|{
return|return
literal|true
return|;
block|}
name|p1
operator|+=
name|w
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<=
name|segs
condition|)
do|;
return|return
literal|false
return|;
block|}
DECL|method|rectAnyCornersOutsideCircleSloppy
specifier|private
specifier|static
name|boolean
name|rectAnyCornersOutsideCircleSloppy
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
name|centerLon
parameter_list|,
specifier|final
name|double
name|centerLat
parameter_list|,
specifier|final
name|double
name|radiusMeters
parameter_list|)
block|{
return|return
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|rMinX
argument_list|)
operator|*
literal|1000.0
operator|>
name|radiusMeters
operator|||
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|rMinX
argument_list|)
operator|*
literal|1000.0
operator|>
name|radiusMeters
operator|||
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|rMaxX
argument_list|)
operator|*
literal|1000.0
operator|>
name|radiusMeters
operator|||
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|)
operator|*
literal|1000.0
operator|>
name|radiusMeters
return|;
block|}
DECL|method|rectWithinCircle
specifier|public
specifier|static
name|boolean
name|rectWithinCircle
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
name|centerLon
parameter_list|,
specifier|final
name|double
name|centerLat
parameter_list|,
specifier|final
name|double
name|radiusMeters
parameter_list|)
block|{
return|return
name|rectWithinCircle
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|radiusMeters
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|rectWithinCircle
specifier|public
specifier|static
name|boolean
name|rectWithinCircle
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
name|centerLon
parameter_list|,
specifier|final
name|double
name|centerLat
parameter_list|,
specifier|final
name|double
name|radiusMeters
parameter_list|,
specifier|final
name|boolean
name|approx
parameter_list|)
block|{
return|return
name|rectAnyCornersOutsideCircle
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|radiusMeters
argument_list|,
name|approx
argument_list|)
operator|==
literal|false
return|;
block|}
comment|/**    * Determine if a bbox (defined by minLon, minLat, maxLon, maxLat) contains the provided point (defined by lon, lat)    * NOTE: this is basic method that does not handle dateline or pole crossing. Unwrapping must be done before    * calling this method.    */
DECL|method|rectCrossesCircle
specifier|public
specifier|static
name|boolean
name|rectCrossesCircle
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
name|centerLon
parameter_list|,
specifier|final
name|double
name|centerLat
parameter_list|,
specifier|final
name|double
name|radiusMeters
parameter_list|)
block|{
return|return
name|rectCrossesCircle
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|radiusMeters
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|rectCrossesCircle
specifier|public
specifier|static
name|boolean
name|rectCrossesCircle
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
name|centerLon
parameter_list|,
specifier|final
name|double
name|centerLat
parameter_list|,
specifier|final
name|double
name|radiusMeters
parameter_list|,
specifier|final
name|boolean
name|approx
parameter_list|)
block|{
if|if
condition|(
name|approx
operator|==
literal|true
condition|)
block|{
return|return
name|rectAnyCornersInCircle
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|radiusMeters
argument_list|,
name|approx
argument_list|)
operator|||
name|isClosestPointOnRectWithinRange
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|radiusMeters
argument_list|,
name|approx
argument_list|)
return|;
block|}
return|return
operator|(
name|rectAnyCornersInCircle
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|radiusMeters
argument_list|,
name|approx
argument_list|)
operator|&&
name|rectAnyCornersOutsideCircle
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|radiusMeters
argument_list|,
name|approx
argument_list|)
operator|)
operator|||
name|isClosestPointOnRectWithinRange
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|radiusMeters
argument_list|,
name|approx
argument_list|)
return|;
block|}
DECL|method|isClosestPointOnRectWithinRange
specifier|private
specifier|static
name|boolean
name|isClosestPointOnRectWithinRange
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
name|centerLon
parameter_list|,
specifier|final
name|double
name|centerLat
parameter_list|,
specifier|final
name|double
name|radiusMeters
parameter_list|,
specifier|final
name|boolean
name|approx
parameter_list|)
block|{
name|double
index|[]
name|closestPt
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|GeoDistanceUtils
operator|.
name|closestPointOnBBox
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|closestPt
argument_list|)
expr_stmt|;
name|boolean
name|haverShortCut
init|=
name|GeoDistanceUtils
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|closestPt
index|[
literal|1
index|]
argument_list|,
name|closestPt
index|[
literal|0
index|]
argument_list|)
operator|<=
name|radiusMeters
decl_stmt|;
if|if
condition|(
name|approx
operator|==
literal|true
operator|||
name|haverShortCut
operator|==
literal|true
condition|)
block|{
return|return
name|haverShortCut
return|;
block|}
name|double
name|lon1
init|=
name|rMinX
decl_stmt|;
name|double
name|lon2
init|=
name|rMaxX
decl_stmt|;
name|double
name|lat1
init|=
name|rMinY
decl_stmt|;
name|double
name|lat2
init|=
name|rMaxY
decl_stmt|;
if|if
condition|(
name|closestPt
index|[
literal|0
index|]
operator|==
name|rMinX
operator|||
name|closestPt
index|[
literal|0
index|]
operator|==
name|rMaxX
condition|)
block|{
name|lon1
operator|=
name|closestPt
index|[
literal|0
index|]
expr_stmt|;
name|lon2
operator|=
name|lon1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|closestPt
index|[
literal|1
index|]
operator|==
name|rMinY
operator|||
name|closestPt
index|[
literal|1
index|]
operator|==
name|rMaxY
condition|)
block|{
name|lat1
operator|=
name|closestPt
index|[
literal|1
index|]
expr_stmt|;
name|lat2
operator|=
name|lat1
expr_stmt|;
block|}
return|return
name|lineCrossesSphere
argument_list|(
name|lon1
argument_list|,
name|lat1
argument_list|,
literal|0
argument_list|,
name|lon2
argument_list|,
name|lat2
argument_list|,
literal|0
argument_list|,
name|centerLon
argument_list|,
name|centerLat
argument_list|,
literal|0
argument_list|,
name|radiusMeters
argument_list|)
return|;
block|}
comment|/**    * Computes whether or a 3dimensional line segment intersects or crosses a sphere    *    * @param lon1 longitudinal location of the line segment start point (in degrees)    * @param lat1 latitudinal location of the line segment start point (in degrees)    * @param alt1 altitude of the line segment start point (in degrees)    * @param lon2 longitudinal location of the line segment end point (in degrees)    * @param lat2 latitudinal location of the line segment end point (in degrees)    * @param alt2 altitude of the line segment end point (in degrees)    * @param centerLon longitudinal location of center search point (in degrees)    * @param centerLat latitudinal location of center search point (in degrees)    * @param centerAlt altitude of the center point (in meters)    * @param radiusMeters search sphere radius (in meters)    * @return whether the provided line segment is a secant of the    */
DECL|method|lineCrossesSphere
specifier|private
specifier|static
name|boolean
name|lineCrossesSphere
parameter_list|(
name|double
name|lon1
parameter_list|,
name|double
name|lat1
parameter_list|,
name|double
name|alt1
parameter_list|,
name|double
name|lon2
parameter_list|,
name|double
name|lat2
parameter_list|,
name|double
name|alt2
parameter_list|,
name|double
name|centerLon
parameter_list|,
name|double
name|centerLat
parameter_list|,
name|double
name|centerAlt
parameter_list|,
name|double
name|radiusMeters
parameter_list|)
block|{
comment|// convert to cartesian 3d (in meters)
name|double
index|[]
name|ecf1
init|=
name|GeoProjectionUtils
operator|.
name|llaToECF
argument_list|(
name|lon1
argument_list|,
name|lat1
argument_list|,
name|alt1
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|double
index|[]
name|ecf2
init|=
name|GeoProjectionUtils
operator|.
name|llaToECF
argument_list|(
name|lon2
argument_list|,
name|lat2
argument_list|,
name|alt2
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|double
index|[]
name|cntr
init|=
name|GeoProjectionUtils
operator|.
name|llaToECF
argument_list|(
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|centerAlt
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// convert radius from arc radius to cartesian radius
name|double
index|[]
name|oneEighty
init|=
name|GeoProjectionUtils
operator|.
name|pointFromLonLatBearingGreatCircle
argument_list|(
name|centerLon
argument_list|,
name|centerLat
argument_list|,
literal|180.0d
argument_list|,
name|radiusMeters
argument_list|,
operator|new
name|double
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|GeoProjectionUtils
operator|.
name|llaToECF
argument_list|(
name|oneEighty
index|[
literal|0
index|]
argument_list|,
name|oneEighty
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|oneEighty
argument_list|)
expr_stmt|;
name|radiusMeters
operator|=
name|GeoDistanceUtils
operator|.
name|linearDistance
argument_list|(
name|oneEighty
argument_list|,
name|cntr
argument_list|)
expr_stmt|;
comment|//   Math.sqrt(oneEighty[0]*cntr[0] + oneEighty[1]*cntr[1] + oneEighty[2]*cntr[2]);
specifier|final
name|double
name|dX
init|=
name|ecf2
index|[
literal|0
index|]
operator|-
name|ecf1
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|double
name|dY
init|=
name|ecf2
index|[
literal|1
index|]
operator|-
name|ecf1
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|double
name|dZ
init|=
name|ecf2
index|[
literal|2
index|]
operator|-
name|ecf1
index|[
literal|2
index|]
decl_stmt|;
specifier|final
name|double
name|fX
init|=
name|ecf1
index|[
literal|0
index|]
operator|-
name|cntr
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|double
name|fY
init|=
name|ecf1
index|[
literal|1
index|]
operator|-
name|cntr
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|double
name|fZ
init|=
name|ecf1
index|[
literal|2
index|]
operator|-
name|cntr
index|[
literal|2
index|]
decl_stmt|;
specifier|final
name|double
name|a
init|=
name|dX
operator|*
name|dX
operator|+
name|dY
operator|*
name|dY
operator|+
name|dZ
operator|*
name|dZ
decl_stmt|;
specifier|final
name|double
name|b
init|=
literal|2
operator|*
operator|(
name|fX
operator|*
name|dX
operator|+
name|fY
operator|*
name|dY
operator|+
name|fZ
operator|*
name|dZ
operator|)
decl_stmt|;
specifier|final
name|double
name|c
init|=
operator|(
name|fX
operator|*
name|fX
operator|+
name|fY
operator|*
name|fY
operator|+
name|fZ
operator|*
name|fZ
operator|)
operator|-
operator|(
name|radiusMeters
operator|*
name|radiusMeters
operator|)
decl_stmt|;
name|double
name|discrim
init|=
operator|(
name|b
operator|*
name|b
operator|)
operator|-
operator|(
literal|4
operator|*
name|a
operator|*
name|c
operator|)
decl_stmt|;
if|if
condition|(
name|discrim
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|discrim
operator|=
name|StrictMath
operator|.
name|sqrt
argument_list|(
name|discrim
argument_list|)
expr_stmt|;
specifier|final
name|double
name|a2
init|=
literal|2
operator|*
name|a
decl_stmt|;
specifier|final
name|double
name|t1
init|=
operator|(
operator|-
name|b
operator|-
name|discrim
operator|)
operator|/
name|a2
decl_stmt|;
specifier|final
name|double
name|t2
init|=
operator|(
operator|-
name|b
operator|+
name|discrim
operator|)
operator|/
name|a2
decl_stmt|;
if|if
condition|(
operator|(
name|t1
argument_list|<
literal|0
operator|||
name|t1
argument_list|>
literal|1
operator|)
condition|)
block|{
return|return
operator|!
operator|(
name|t2
argument_list|<
literal|0
operator|||
name|t2
argument_list|>
literal|1
operator|)
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
end_class
end_unit
