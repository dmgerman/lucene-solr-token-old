begin_unit
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  * Basic reusable geo-spatial utility methods  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|GeoUtils
specifier|public
specifier|final
class|class
name|GeoUtils
block|{
comment|// WGS84 earth-ellipsoid major (a) minor (b) radius, (f) flattening and eccentricity (e)
DECL|field|SEMIMAJOR_AXIS
specifier|private
specifier|static
specifier|final
name|double
name|SEMIMAJOR_AXIS
init|=
literal|6_378_137
decl_stmt|;
comment|// [m]
DECL|field|FLATTENING
specifier|private
specifier|static
specifier|final
name|double
name|FLATTENING
init|=
literal|1.0
operator|/
literal|298.257223563
decl_stmt|;
DECL|field|SEMIMINOR_AXIS
specifier|private
specifier|static
specifier|final
name|double
name|SEMIMINOR_AXIS
init|=
name|SEMIMAJOR_AXIS
operator|*
operator|(
literal|1.0
operator|-
name|FLATTENING
operator|)
decl_stmt|;
comment|//6_356_752.31420; // [m]
DECL|field|ECCENTRICITY
specifier|private
specifier|static
specifier|final
name|double
name|ECCENTRICITY
init|=
name|StrictMath
operator|.
name|sqrt
argument_list|(
operator|(
literal|2.0
operator|-
name|FLATTENING
operator|)
operator|*
name|FLATTENING
argument_list|)
decl_stmt|;
DECL|field|PI_OVER_2
specifier|private
specifier|static
specifier|final
name|double
name|PI_OVER_2
init|=
name|StrictMath
operator|.
name|PI
operator|/
literal|2.0D
decl_stmt|;
DECL|field|SEMIMAJOR_AXIS2
specifier|private
specifier|static
specifier|final
name|double
name|SEMIMAJOR_AXIS2
init|=
name|SEMIMAJOR_AXIS
operator|*
name|SEMIMINOR_AXIS
decl_stmt|;
DECL|field|SEMIMINOR_AXIS2
specifier|private
specifier|static
specifier|final
name|double
name|SEMIMINOR_AXIS2
init|=
name|SEMIMINOR_AXIS
operator|*
name|SEMIMINOR_AXIS
decl_stmt|;
DECL|field|MIN_LON
specifier|private
specifier|static
specifier|final
name|short
name|MIN_LON
init|=
operator|-
literal|180
decl_stmt|;
DECL|field|MIN_LAT
specifier|private
specifier|static
specifier|final
name|short
name|MIN_LAT
init|=
operator|-
literal|90
decl_stmt|;
DECL|field|BITS
specifier|public
specifier|static
specifier|final
name|short
name|BITS
init|=
literal|31
decl_stmt|;
DECL|field|LON_SCALE
specifier|private
specifier|static
specifier|final
name|double
name|LON_SCALE
init|=
operator|(
literal|0x1L
operator|<<
name|BITS
operator|)
operator|/
literal|360.0D
decl_stmt|;
DECL|field|LAT_SCALE
specifier|private
specifier|static
specifier|final
name|double
name|LAT_SCALE
init|=
operator|(
literal|0x1L
operator|<<
name|BITS
operator|)
operator|/
literal|180.0D
decl_stmt|;
DECL|field|TOLERANCE
specifier|public
specifier|static
specifier|final
name|double
name|TOLERANCE
init|=
literal|1E
operator|-
literal|6
decl_stmt|;
comment|/** Minimum longitude value. */
DECL|field|MIN_LON_INCL
specifier|public
specifier|static
specifier|final
name|double
name|MIN_LON_INCL
init|=
operator|-
literal|180.0D
decl_stmt|;
comment|/** Maximum longitude value. */
DECL|field|MAX_LON_INCL
specifier|public
specifier|static
specifier|final
name|double
name|MAX_LON_INCL
init|=
literal|180.0D
decl_stmt|;
comment|/** Minimum latitude value. */
DECL|field|MIN_LAT_INCL
specifier|public
specifier|static
specifier|final
name|double
name|MIN_LAT_INCL
init|=
operator|-
literal|90.0D
decl_stmt|;
comment|/** Maximum latitude value. */
DECL|field|MAX_LAT_INCL
specifier|public
specifier|static
specifier|final
name|double
name|MAX_LAT_INCL
init|=
literal|90.0D
decl_stmt|;
comment|// No instance:
DECL|method|GeoUtils
specifier|private
name|GeoUtils
parameter_list|()
block|{   }
DECL|method|mortonHash
specifier|public
specifier|static
specifier|final
name|Long
name|mortonHash
parameter_list|(
specifier|final
name|double
name|lon
parameter_list|,
specifier|final
name|double
name|lat
parameter_list|)
block|{
return|return
name|BitUtil
operator|.
name|interleave
argument_list|(
name|scaleLon
argument_list|(
name|lon
argument_list|)
argument_list|,
name|scaleLat
argument_list|(
name|lat
argument_list|)
argument_list|)
return|;
block|}
DECL|method|mortonUnhashLon
specifier|public
specifier|static
specifier|final
name|double
name|mortonUnhashLon
parameter_list|(
specifier|final
name|long
name|hash
parameter_list|)
block|{
return|return
name|unscaleLon
argument_list|(
name|BitUtil
operator|.
name|deinterleave
argument_list|(
name|hash
argument_list|)
argument_list|)
return|;
block|}
DECL|method|mortonUnhashLat
specifier|public
specifier|static
specifier|final
name|double
name|mortonUnhashLat
parameter_list|(
specifier|final
name|long
name|hash
parameter_list|)
block|{
return|return
name|unscaleLat
argument_list|(
name|BitUtil
operator|.
name|deinterleave
argument_list|(
name|hash
operator|>>>
literal|1
argument_list|)
argument_list|)
return|;
block|}
DECL|method|scaleLon
specifier|private
specifier|static
name|long
name|scaleLon
parameter_list|(
specifier|final
name|double
name|val
parameter_list|)
block|{
return|return
call|(
name|long
call|)
argument_list|(
operator|(
name|val
operator|-
name|MIN_LON
operator|)
operator|*
name|LON_SCALE
argument_list|)
return|;
block|}
DECL|method|scaleLat
specifier|private
specifier|static
name|long
name|scaleLat
parameter_list|(
specifier|final
name|double
name|val
parameter_list|)
block|{
return|return
call|(
name|long
call|)
argument_list|(
operator|(
name|val
operator|-
name|MIN_LAT
operator|)
operator|*
name|LAT_SCALE
argument_list|)
return|;
block|}
DECL|method|unscaleLon
specifier|private
specifier|static
name|double
name|unscaleLon
parameter_list|(
specifier|final
name|long
name|val
parameter_list|)
block|{
return|return
operator|(
name|val
operator|/
name|LON_SCALE
operator|)
operator|+
name|MIN_LON
return|;
block|}
DECL|method|unscaleLat
specifier|private
specifier|static
name|double
name|unscaleLat
parameter_list|(
specifier|final
name|long
name|val
parameter_list|)
block|{
return|return
operator|(
name|val
operator|/
name|LAT_SCALE
operator|)
operator|+
name|MIN_LAT
return|;
block|}
DECL|method|compare
specifier|public
specifier|static
specifier|final
name|double
name|compare
parameter_list|(
specifier|final
name|double
name|v1
parameter_list|,
specifier|final
name|double
name|v2
parameter_list|)
block|{
specifier|final
name|double
name|compare
init|=
name|v1
operator|-
name|v2
decl_stmt|;
return|return
name|Math
operator|.
name|abs
argument_list|(
name|compare
argument_list|)
operator|<=
name|TOLERANCE
condition|?
literal|0
else|:
name|compare
return|;
block|}
DECL|method|bboxContains
specifier|public
specifier|static
specifier|final
name|boolean
name|bboxContains
parameter_list|(
specifier|final
name|double
name|lon
parameter_list|,
specifier|final
name|double
name|lat
parameter_list|,
specifier|final
name|double
name|minLon
parameter_list|,
specifier|final
name|double
name|minLat
parameter_list|,
specifier|final
name|double
name|maxLon
parameter_list|,
specifier|final
name|double
name|maxLat
parameter_list|)
block|{
return|return
operator|(
name|compare
argument_list|(
name|lon
argument_list|,
name|minLon
argument_list|)
operator|>=
literal|0
operator|&&
name|compare
argument_list|(
name|lon
argument_list|,
name|maxLon
argument_list|)
operator|<=
literal|0
operator|&&
name|compare
argument_list|(
name|lat
argument_list|,
name|minLat
argument_list|)
operator|>=
literal|0
operator|&&
name|compare
argument_list|(
name|lat
argument_list|,
name|maxLat
argument_list|)
operator|<=
literal|0
operator|)
return|;
block|}
comment|/**    * Converts from geodesic lon lat alt to geocentric earth-centered earth-fixed    * @param lon geodesic longitude    * @param lat geodesic latitude    * @param alt geodesic altitude    * @param ecf reusable earth-centered earth-fixed result    * @return either a new ecef array or the reusable ecf parameter    */
DECL|method|llaToECF
specifier|public
specifier|static
specifier|final
name|double
index|[]
name|llaToECF
parameter_list|(
name|double
name|lon
parameter_list|,
name|double
name|lat
parameter_list|,
name|double
name|alt
parameter_list|,
name|double
index|[]
name|ecf
parameter_list|)
block|{
name|lon
operator|=
name|StrictMath
operator|.
name|toRadians
argument_list|(
name|lon
argument_list|)
expr_stmt|;
name|lat
operator|=
name|StrictMath
operator|.
name|toRadians
argument_list|(
name|lat
argument_list|)
expr_stmt|;
specifier|final
name|double
name|sl
init|=
name|StrictMath
operator|.
name|sin
argument_list|(
name|lat
argument_list|)
decl_stmt|;
specifier|final
name|double
name|s2
init|=
name|sl
operator|*
name|sl
decl_stmt|;
specifier|final
name|double
name|cl
init|=
name|StrictMath
operator|.
name|cos
argument_list|(
name|lat
argument_list|)
decl_stmt|;
specifier|final
name|double
name|ge2
init|=
operator|(
name|SEMIMAJOR_AXIS2
operator|-
name|SEMIMINOR_AXIS2
operator|)
operator|/
operator|(
name|SEMIMAJOR_AXIS2
operator|)
decl_stmt|;
if|if
condition|(
name|ecf
operator|==
literal|null
condition|)
name|ecf
operator|=
operator|new
name|double
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|lat
argument_list|<
operator|-
name|PI_OVER_2
operator|&&
name|lat
argument_list|>
operator|-
literal|1.001D
operator|*
name|PI_OVER_2
condition|)
block|{
name|lat
operator|=
operator|-
name|PI_OVER_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lat
operator|>
name|PI_OVER_2
operator|&&
name|lat
operator|<
literal|1.001D
operator|*
name|PI_OVER_2
condition|)
block|{
name|lat
operator|=
name|PI_OVER_2
expr_stmt|;
block|}
assert|assert
operator|(
operator|(
name|lat
operator|>=
operator|-
name|PI_OVER_2
operator|)
operator|||
operator|(
name|lat
operator|<=
name|PI_OVER_2
operator|)
operator|)
assert|;
if|if
condition|(
name|lon
operator|>
name|StrictMath
operator|.
name|PI
condition|)
block|{
name|lon
operator|-=
operator|(
literal|2
operator|*
name|StrictMath
operator|.
name|PI
operator|)
expr_stmt|;
block|}
specifier|final
name|double
name|rn
init|=
name|SEMIMAJOR_AXIS
operator|/
name|StrictMath
operator|.
name|sqrt
argument_list|(
literal|1.0D
operator|-
name|ge2
operator|*
name|s2
argument_list|)
decl_stmt|;
name|ecf
index|[
literal|0
index|]
operator|=
operator|(
name|rn
operator|+
name|alt
operator|)
operator|*
name|cl
operator|*
name|StrictMath
operator|.
name|cos
argument_list|(
name|lon
argument_list|)
expr_stmt|;
name|ecf
index|[
literal|1
index|]
operator|=
operator|(
name|rn
operator|+
name|alt
operator|)
operator|*
name|cl
operator|*
name|StrictMath
operator|.
name|sin
argument_list|(
name|lon
argument_list|)
expr_stmt|;
name|ecf
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|rn
operator|*
operator|(
literal|1.0
operator|-
name|ge2
operator|)
operator|)
operator|+
name|alt
operator|)
operator|*
name|sl
expr_stmt|;
return|return
name|ecf
return|;
block|}
comment|/**    * Converts from geocentric earth-centered earth-fixed to geodesic lat/lon/alt    * @param x Cartesian x coordinate    * @param y Cartesian y coordinate    * @param z Cartesian z coordinate    * @param lla 0: longitude 1: latitude: 2: altitude    * @return double array as 0: longitude 1: latitude 2: altitude    */
DECL|method|ecfToLLA
specifier|public
specifier|static
specifier|final
name|double
index|[]
name|ecfToLLA
parameter_list|(
specifier|final
name|double
name|x
parameter_list|,
specifier|final
name|double
name|y
parameter_list|,
specifier|final
name|double
name|z
parameter_list|,
name|double
index|[]
name|lla
parameter_list|)
block|{
name|boolean
name|atPole
init|=
literal|false
decl_stmt|;
specifier|final
name|double
name|ad_c
init|=
literal|1.0026000D
decl_stmt|;
specifier|final
name|double
name|e2
init|=
operator|(
name|SEMIMAJOR_AXIS2
operator|-
name|SEMIMINOR_AXIS2
operator|)
operator|/
operator|(
name|SEMIMAJOR_AXIS2
operator|)
decl_stmt|;
specifier|final
name|double
name|ep2
init|=
operator|(
name|SEMIMAJOR_AXIS2
operator|-
name|SEMIMINOR_AXIS2
operator|)
operator|/
operator|(
name|SEMIMINOR_AXIS2
operator|)
decl_stmt|;
specifier|final
name|double
name|cos67P5
init|=
literal|0.38268343236508977D
decl_stmt|;
if|if
condition|(
name|lla
operator|==
literal|null
condition|)
name|lla
operator|=
operator|new
name|double
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0.0
condition|)
block|{
name|lla
index|[
literal|0
index|]
operator|=
name|StrictMath
operator|.
name|atan2
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|y
operator|>
literal|0
condition|)
block|{
name|lla
index|[
literal|0
index|]
operator|=
name|PI_OVER_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
name|lla
index|[
literal|0
index|]
operator|=
operator|-
name|PI_OVER_2
expr_stmt|;
block|}
else|else
block|{
name|atPole
operator|=
literal|true
expr_stmt|;
name|lla
index|[
literal|0
index|]
operator|=
literal|0.0D
expr_stmt|;
if|if
condition|(
name|z
operator|>
literal|0.0
condition|)
block|{
name|lla
index|[
literal|1
index|]
operator|=
name|PI_OVER_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
operator|<
literal|0.0
condition|)
block|{
name|lla
index|[
literal|1
index|]
operator|=
operator|-
name|PI_OVER_2
expr_stmt|;
block|}
else|else
block|{
name|lla
index|[
literal|1
index|]
operator|=
name|PI_OVER_2
expr_stmt|;
name|lla
index|[
literal|2
index|]
operator|=
operator|-
name|SEMIMINOR_AXIS
expr_stmt|;
return|return
name|lla
return|;
block|}
block|}
block|}
specifier|final
name|double
name|w2
init|=
name|x
operator|*
name|x
operator|+
name|y
operator|*
name|y
decl_stmt|;
specifier|final
name|double
name|w
init|=
name|StrictMath
operator|.
name|sqrt
argument_list|(
name|w2
argument_list|)
decl_stmt|;
specifier|final
name|double
name|t0
init|=
name|z
operator|*
name|ad_c
decl_stmt|;
specifier|final
name|double
name|s0
init|=
name|StrictMath
operator|.
name|sqrt
argument_list|(
name|t0
operator|*
name|t0
operator|+
name|w2
argument_list|)
decl_stmt|;
specifier|final
name|double
name|sinB0
init|=
name|t0
operator|/
name|s0
decl_stmt|;
specifier|final
name|double
name|cosB0
init|=
name|w
operator|/
name|s0
decl_stmt|;
specifier|final
name|double
name|sin3B0
init|=
name|sinB0
operator|*
name|sinB0
operator|*
name|sinB0
decl_stmt|;
specifier|final
name|double
name|t1
init|=
name|z
operator|+
name|SEMIMINOR_AXIS
operator|*
name|ep2
operator|*
name|sin3B0
decl_stmt|;
specifier|final
name|double
name|sum
init|=
name|w
operator|-
name|SEMIMAJOR_AXIS
operator|*
name|e2
operator|*
name|cosB0
operator|*
name|cosB0
operator|*
name|cosB0
decl_stmt|;
specifier|final
name|double
name|s1
init|=
name|StrictMath
operator|.
name|sqrt
argument_list|(
name|t1
operator|*
name|t1
operator|+
name|sum
operator|*
name|sum
argument_list|)
decl_stmt|;
specifier|final
name|double
name|sinP1
init|=
name|t1
operator|/
name|s1
decl_stmt|;
specifier|final
name|double
name|cosP1
init|=
name|sum
operator|/
name|s1
decl_stmt|;
specifier|final
name|double
name|rn
init|=
name|SEMIMAJOR_AXIS
operator|/
name|StrictMath
operator|.
name|sqrt
argument_list|(
literal|1.0D
operator|-
name|e2
operator|*
name|sinP1
operator|*
name|sinP1
argument_list|)
decl_stmt|;
if|if
condition|(
name|cosP1
operator|>=
name|cos67P5
condition|)
block|{
name|lla
index|[
literal|2
index|]
operator|=
name|w
operator|/
name|cosP1
operator|-
name|rn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cosP1
operator|<=
operator|-
name|cos67P5
condition|)
block|{
name|lla
index|[
literal|2
index|]
operator|=
name|w
operator|/
operator|-
name|cosP1
operator|-
name|rn
expr_stmt|;
block|}
else|else
block|{
name|lla
index|[
literal|2
index|]
operator|=
name|z
operator|/
name|sinP1
operator|+
name|rn
operator|*
operator|(
name|e2
operator|-
literal|1.0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|atPole
condition|)
block|{
name|lla
index|[
literal|1
index|]
operator|=
name|StrictMath
operator|.
name|atan
argument_list|(
name|sinP1
operator|/
name|cosP1
argument_list|)
expr_stmt|;
block|}
name|lla
index|[
literal|0
index|]
operator|=
name|StrictMath
operator|.
name|toDegrees
argument_list|(
name|lla
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|lla
index|[
literal|1
index|]
operator|=
name|StrictMath
operator|.
name|toDegrees
argument_list|(
name|lla
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|lla
return|;
block|}
comment|/**    * simple even-odd point in polygon computation    *    1.  Determine if point is contained in the longitudinal range    *    2.  Determine whether point crosses the edge by computing the latitudinal delta    *        between the end-point of a parallel vector (originating at the point) and the    *        y-component of the edge sink    *    * NOTE: Requires polygon point (x,y) order either clockwise or counter-clockwise    */
DECL|method|pointInPolygon
specifier|public
specifier|static
name|boolean
name|pointInPolygon
parameter_list|(
name|double
index|[]
name|x
parameter_list|,
name|double
index|[]
name|y
parameter_list|,
name|double
name|lat
parameter_list|,
name|double
name|lon
parameter_list|)
block|{
assert|assert
name|x
operator|.
name|length
operator|==
name|y
operator|.
name|length
assert|;
name|boolean
name|inPoly
init|=
literal|false
decl_stmt|;
comment|/**      * Note: This is using a euclidean coordinate system which could result in      * upwards of 110KM error at the equator.      * TODO convert coordinates to cylindrical projection (e.g. mercator)      */
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|x
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|x
index|[
name|i
index|]
operator|<
name|lon
operator|&&
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|>=
name|lon
operator|||
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|<
name|lon
operator|&&
name|x
index|[
name|i
index|]
operator|>=
name|lon
condition|)
block|{
if|if
condition|(
name|y
index|[
name|i
index|]
operator|+
operator|(
name|lon
operator|-
name|x
index|[
name|i
index|]
operator|)
operator|/
operator|(
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|x
index|[
name|i
index|]
operator|)
operator|*
operator|(
name|y
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|y
index|[
name|i
index|]
operator|)
operator|<
name|lat
condition|)
block|{
name|inPoly
operator|=
operator|!
name|inPoly
expr_stmt|;
block|}
block|}
block|}
return|return
name|inPoly
return|;
block|}
DECL|method|geoTermToString
specifier|public
specifier|static
name|String
name|geoTermToString
parameter_list|(
name|long
name|term
parameter_list|)
block|{
name|StringBuilder
name|s
init|=
operator|new
name|StringBuilder
argument_list|(
literal|64
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numberOfLeadingZeros
init|=
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|term
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfLeadingZeros
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|term
operator|!=
literal|0
condition|)
name|s
operator|.
name|append
argument_list|(
name|Long
operator|.
name|toBinaryString
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|rectDisjoint
specifier|public
specifier|static
name|boolean
name|rectDisjoint
parameter_list|(
specifier|final
name|double
name|aMinX
parameter_list|,
specifier|final
name|double
name|aMinY
parameter_list|,
specifier|final
name|double
name|aMaxX
parameter_list|,
specifier|final
name|double
name|aMaxY
parameter_list|,
specifier|final
name|double
name|bMinX
parameter_list|,
specifier|final
name|double
name|bMinY
parameter_list|,
specifier|final
name|double
name|bMaxX
parameter_list|,
specifier|final
name|double
name|bMaxY
parameter_list|)
block|{
return|return
operator|(
name|aMaxX
argument_list|<
name|bMinX
operator|||
name|aMinX
argument_list|>
name|bMaxX
operator|||
name|aMaxY
argument_list|<
name|bMinY
operator|||
name|aMinY
argument_list|>
name|bMaxY
operator|)
return|;
block|}
comment|/**    * Computes whether a rectangle is wholly within another rectangle (shared boundaries allowed)    */
DECL|method|rectWithin
specifier|public
specifier|static
name|boolean
name|rectWithin
parameter_list|(
specifier|final
name|double
name|aMinX
parameter_list|,
specifier|final
name|double
name|aMinY
parameter_list|,
specifier|final
name|double
name|aMaxX
parameter_list|,
specifier|final
name|double
name|aMaxY
parameter_list|,
specifier|final
name|double
name|bMinX
parameter_list|,
specifier|final
name|double
name|bMinY
parameter_list|,
specifier|final
name|double
name|bMaxX
parameter_list|,
specifier|final
name|double
name|bMaxY
parameter_list|)
block|{
return|return
operator|!
operator|(
name|aMinX
argument_list|<
name|bMinX
operator|||
name|aMinY
argument_list|<
name|bMinY
operator|||
name|aMaxX
argument_list|>
name|bMaxX
operator|||
name|aMaxY
argument_list|>
name|bMaxY
operator|)
return|;
block|}
DECL|method|rectCrosses
specifier|public
specifier|static
name|boolean
name|rectCrosses
parameter_list|(
specifier|final
name|double
name|aMinX
parameter_list|,
specifier|final
name|double
name|aMinY
parameter_list|,
specifier|final
name|double
name|aMaxX
parameter_list|,
specifier|final
name|double
name|aMaxY
parameter_list|,
specifier|final
name|double
name|bMinX
parameter_list|,
specifier|final
name|double
name|bMinY
parameter_list|,
specifier|final
name|double
name|bMaxX
parameter_list|,
specifier|final
name|double
name|bMaxY
parameter_list|)
block|{
return|return
operator|!
operator|(
name|rectDisjoint
argument_list|(
name|aMinX
argument_list|,
name|aMinY
argument_list|,
name|aMaxX
argument_list|,
name|aMaxY
argument_list|,
name|bMinX
argument_list|,
name|bMinY
argument_list|,
name|bMaxX
argument_list|,
name|bMaxY
argument_list|)
operator|||
name|rectWithin
argument_list|(
name|aMinX
argument_list|,
name|aMinY
argument_list|,
name|aMaxX
argument_list|,
name|aMaxY
argument_list|,
name|bMinX
argument_list|,
name|bMinY
argument_list|,
name|bMaxX
argument_list|,
name|bMaxY
argument_list|)
operator|)
return|;
block|}
comment|/**    * Computes whether rectangle a contains rectangle b (touching allowed)    */
DECL|method|rectContains
specifier|public
specifier|static
name|boolean
name|rectContains
parameter_list|(
specifier|final
name|double
name|aMinX
parameter_list|,
specifier|final
name|double
name|aMinY
parameter_list|,
specifier|final
name|double
name|aMaxX
parameter_list|,
specifier|final
name|double
name|aMaxY
parameter_list|,
specifier|final
name|double
name|bMinX
parameter_list|,
specifier|final
name|double
name|bMinY
parameter_list|,
specifier|final
name|double
name|bMaxX
parameter_list|,
specifier|final
name|double
name|bMaxY
parameter_list|)
block|{
return|return
operator|!
operator|(
name|bMinX
argument_list|<
name|aMinX
operator|||
name|bMinY
argument_list|<
name|aMinY
operator|||
name|bMaxX
argument_list|>
name|aMaxX
operator|||
name|bMaxY
argument_list|>
name|aMaxY
operator|)
return|;
block|}
comment|/**    * Computes whether a rectangle intersects another rectangle (crosses, within, touching, etc)    */
DECL|method|rectIntersects
specifier|public
specifier|static
name|boolean
name|rectIntersects
parameter_list|(
specifier|final
name|double
name|aMinX
parameter_list|,
specifier|final
name|double
name|aMinY
parameter_list|,
specifier|final
name|double
name|aMaxX
parameter_list|,
specifier|final
name|double
name|aMaxY
parameter_list|,
specifier|final
name|double
name|bMinX
parameter_list|,
specifier|final
name|double
name|bMinY
parameter_list|,
specifier|final
name|double
name|bMaxX
parameter_list|,
specifier|final
name|double
name|bMaxY
parameter_list|)
block|{
return|return
operator|!
operator|(
operator|(
name|aMaxX
argument_list|<
name|bMinX
operator|||
name|aMinX
argument_list|>
name|bMaxX
operator|||
name|aMaxY
argument_list|<
name|bMinY
operator|||
name|aMinY
argument_list|>
name|bMaxY
operator|)
operator|)
return|;
block|}
comment|/**    * Computes whether a rectangle crosses a shape. (touching not allowed)    */
DECL|method|rectCrossesPoly
specifier|public
specifier|static
specifier|final
name|boolean
name|rectCrossesPoly
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
index|[]
name|shapeX
parameter_list|,
specifier|final
name|double
index|[]
name|shapeY
parameter_list|,
specifier|final
name|double
name|sMinX
parameter_list|,
specifier|final
name|double
name|sMinY
parameter_list|,
specifier|final
name|double
name|sMaxX
parameter_list|,
specifier|final
name|double
name|sMaxY
parameter_list|)
block|{
comment|// short-circuit: if the bounding boxes are disjoint then the shape does not cross
if|if
condition|(
name|rectDisjoint
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|sMinX
argument_list|,
name|sMinY
argument_list|,
name|sMaxX
argument_list|,
name|sMaxY
argument_list|)
condition|)
return|return
literal|false
return|;
specifier|final
name|double
index|[]
index|[]
name|bbox
init|=
operator|new
name|double
index|[]
index|[]
block|{
block|{
name|rMinX
block|,
name|rMinY
block|}
block|,
block|{
name|rMaxX
block|,
name|rMinY
block|}
block|,
block|{
name|rMaxX
block|,
name|rMaxY
block|}
block|,
block|{
name|rMinX
block|,
name|rMaxY
block|}
block|,
block|{
name|rMinX
block|,
name|rMinY
block|}
block|}
decl_stmt|;
specifier|final
name|int
name|polyLength
init|=
name|shapeX
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|double
name|d
decl_stmt|,
name|s
decl_stmt|,
name|t
decl_stmt|,
name|a1
decl_stmt|,
name|b1
decl_stmt|,
name|c1
decl_stmt|,
name|a2
decl_stmt|,
name|b2
decl_stmt|,
name|c2
decl_stmt|;
name|double
name|x00
decl_stmt|,
name|y00
decl_stmt|,
name|x01
decl_stmt|,
name|y01
decl_stmt|,
name|x10
decl_stmt|,
name|y10
decl_stmt|,
name|x11
decl_stmt|,
name|y11
decl_stmt|;
comment|// computes the intersection point between each bbox edge and the polygon edge
for|for
control|(
name|short
name|b
init|=
literal|0
init|;
name|b
operator|<
literal|4
condition|;
operator|++
name|b
control|)
block|{
name|a1
operator|=
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|1
index|]
operator|-
name|bbox
index|[
name|b
index|]
index|[
literal|1
index|]
expr_stmt|;
name|b1
operator|=
name|bbox
index|[
name|b
index|]
index|[
literal|0
index|]
operator|-
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|c1
operator|=
name|a1
operator|*
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|b1
operator|*
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|int
name|p
init|=
literal|0
init|;
name|p
operator|<
name|polyLength
condition|;
operator|++
name|p
control|)
block|{
name|a2
operator|=
name|shapeY
index|[
name|p
operator|+
literal|1
index|]
operator|-
name|shapeY
index|[
name|p
index|]
expr_stmt|;
name|b2
operator|=
name|shapeX
index|[
name|p
index|]
operator|-
name|shapeX
index|[
name|p
operator|+
literal|1
index|]
expr_stmt|;
comment|// compute determinant
name|d
operator|=
name|a1
operator|*
name|b2
operator|-
name|a2
operator|*
name|b1
expr_stmt|;
if|if
condition|(
name|d
operator|!=
literal|0
condition|)
block|{
comment|// lines are not parallel, check intersecting points
name|c2
operator|=
name|a2
operator|*
name|shapeX
index|[
name|p
operator|+
literal|1
index|]
operator|+
name|b2
operator|*
name|shapeY
index|[
name|p
operator|+
literal|1
index|]
expr_stmt|;
name|s
operator|=
operator|(
literal|1
operator|/
name|d
operator|)
operator|*
operator|(
name|b2
operator|*
name|c1
operator|-
name|b1
operator|*
name|c2
operator|)
expr_stmt|;
name|t
operator|=
operator|(
literal|1
operator|/
name|d
operator|)
operator|*
operator|(
name|a1
operator|*
name|c2
operator|-
name|a2
operator|*
name|c1
operator|)
expr_stmt|;
name|x00
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|bbox
index|[
name|b
index|]
index|[
literal|0
index|]
argument_list|,
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|-
name|TOLERANCE
expr_stmt|;
name|x01
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|bbox
index|[
name|b
index|]
index|[
literal|0
index|]
argument_list|,
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|+
name|TOLERANCE
expr_stmt|;
name|y00
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|bbox
index|[
name|b
index|]
index|[
literal|1
index|]
argument_list|,
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|-
name|TOLERANCE
expr_stmt|;
name|y01
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|bbox
index|[
name|b
index|]
index|[
literal|1
index|]
argument_list|,
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|+
name|TOLERANCE
expr_stmt|;
name|x10
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|shapeX
index|[
name|p
index|]
argument_list|,
name|shapeX
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
operator|-
name|TOLERANCE
expr_stmt|;
name|x11
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|shapeX
index|[
name|p
index|]
argument_list|,
name|shapeX
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
operator|+
name|TOLERANCE
expr_stmt|;
name|y10
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|shapeY
index|[
name|p
index|]
argument_list|,
name|shapeY
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
operator|-
name|TOLERANCE
expr_stmt|;
name|y11
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|shapeY
index|[
name|p
index|]
argument_list|,
name|shapeY
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
operator|+
name|TOLERANCE
expr_stmt|;
comment|// check whether the intersection point is touching one of the line segments
name|boolean
name|touching
init|=
operator|(
operator|(
name|x00
operator|==
name|s
operator|&&
name|y00
operator|==
name|t
operator|)
operator|||
operator|(
name|x01
operator|==
name|s
operator|&&
name|y01
operator|==
name|t
operator|)
operator|)
operator|||
operator|(
operator|(
name|x10
operator|==
name|s
operator|&&
name|y10
operator|==
name|t
operator|)
operator|||
operator|(
name|x11
operator|==
name|s
operator|&&
name|y11
operator|==
name|t
operator|)
operator|)
decl_stmt|;
comment|// if line segments are not touching and the intersection point is within the range of either segment
if|if
condition|(
operator|!
operator|(
name|touching
operator|||
name|x00
operator|>
name|s
operator|||
name|x01
argument_list|<
name|s
operator|||
name|y00
argument_list|>
name|t
operator|||
name|y01
argument_list|<
name|t
operator|||
name|x10
argument_list|>
name|s
operator|||
name|x11
argument_list|<
name|s
operator|||
name|y10
argument_list|>
name|t
operator|||
name|y11
operator|<
name|t
operator|)
condition|)
return|return
literal|true
return|;
block|}
block|}
comment|// for each poly edge
block|}
comment|// for each bbox edge
return|return
literal|false
return|;
block|}
comment|/**    * Computes whether a rectangle is within a given polygon (shared boundaries allowed)    */
DECL|method|rectWithinPoly
specifier|public
specifier|static
name|boolean
name|rectWithinPoly
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
index|[]
name|shapeX
parameter_list|,
specifier|final
name|double
index|[]
name|shapeY
parameter_list|,
specifier|final
name|double
name|sMinX
parameter_list|,
specifier|final
name|double
name|sMinY
parameter_list|,
specifier|final
name|double
name|sMaxX
parameter_list|,
specifier|final
name|double
name|sMaxY
parameter_list|)
block|{
comment|// check if rectangle crosses poly (to handle concave/pacman polys), then check that all 4 corners
comment|// are contained
return|return
operator|!
operator|(
name|rectCrossesPoly
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|sMinX
argument_list|,
name|sMinY
argument_list|,
name|sMaxX
argument_list|,
name|sMaxY
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|rMinY
argument_list|,
name|rMinX
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|rMaxY
argument_list|,
name|rMaxX
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|rMaxY
argument_list|,
name|rMinX
argument_list|)
operator|)
return|;
block|}
DECL|method|isValidLat
specifier|public
specifier|static
name|boolean
name|isValidLat
parameter_list|(
name|double
name|lat
parameter_list|)
block|{
return|return
name|Double
operator|.
name|isNaN
argument_list|(
name|lat
argument_list|)
operator|==
literal|false
operator|&&
name|lat
operator|>=
name|MIN_LAT_INCL
operator|&&
name|lat
operator|<=
name|MAX_LAT_INCL
return|;
block|}
DECL|method|isValidLon
specifier|public
specifier|static
name|boolean
name|isValidLon
parameter_list|(
name|double
name|lon
parameter_list|)
block|{
return|return
name|Double
operator|.
name|isNaN
argument_list|(
name|lon
argument_list|)
operator|==
literal|false
operator|&&
name|lon
operator|>=
name|MIN_LON_INCL
operator|&&
name|lon
operator|<=
name|MAX_LON_INCL
return|;
block|}
block|}
end_class
end_unit
