begin_unit
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_comment
comment|/**  * Basic reusable geo-spatial utility methods  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|GeoUtils
specifier|public
specifier|final
class|class
name|GeoUtils
block|{
DECL|field|BITS
specifier|public
specifier|static
specifier|final
name|short
name|BITS
init|=
literal|31
decl_stmt|;
DECL|field|LON_SCALE
specifier|private
specifier|static
specifier|final
name|double
name|LON_SCALE
init|=
operator|(
literal|0x1L
operator|<<
name|BITS
operator|)
operator|/
literal|360.0D
decl_stmt|;
DECL|field|LAT_SCALE
specifier|private
specifier|static
specifier|final
name|double
name|LAT_SCALE
init|=
operator|(
literal|0x1L
operator|<<
name|BITS
operator|)
operator|/
literal|180.0D
decl_stmt|;
DECL|field|TOLERANCE
specifier|public
specifier|static
specifier|final
name|double
name|TOLERANCE
init|=
literal|1E
operator|-
literal|6
decl_stmt|;
comment|/** Minimum longitude value. */
DECL|field|MIN_LON_INCL
specifier|public
specifier|static
specifier|final
name|double
name|MIN_LON_INCL
init|=
operator|-
literal|180.0D
decl_stmt|;
comment|/** Maximum longitude value. */
DECL|field|MAX_LON_INCL
specifier|public
specifier|static
specifier|final
name|double
name|MAX_LON_INCL
init|=
literal|180.0D
decl_stmt|;
comment|/** Minimum latitude value. */
DECL|field|MIN_LAT_INCL
specifier|public
specifier|static
specifier|final
name|double
name|MIN_LAT_INCL
init|=
operator|-
literal|90.0D
decl_stmt|;
comment|/** Maximum latitude value. */
DECL|field|MAX_LAT_INCL
specifier|public
specifier|static
specifier|final
name|double
name|MAX_LAT_INCL
init|=
literal|90.0D
decl_stmt|;
comment|// No instance:
DECL|method|GeoUtils
specifier|private
name|GeoUtils
parameter_list|()
block|{   }
DECL|method|mortonHash
specifier|public
specifier|static
name|Long
name|mortonHash
parameter_list|(
specifier|final
name|double
name|lon
parameter_list|,
specifier|final
name|double
name|lat
parameter_list|)
block|{
return|return
name|BitUtil
operator|.
name|interleave
argument_list|(
name|scaleLon
argument_list|(
name|lon
argument_list|)
argument_list|,
name|scaleLat
argument_list|(
name|lat
argument_list|)
argument_list|)
return|;
block|}
DECL|method|mortonUnhashLon
specifier|public
specifier|static
name|double
name|mortonUnhashLon
parameter_list|(
specifier|final
name|long
name|hash
parameter_list|)
block|{
return|return
name|unscaleLon
argument_list|(
name|BitUtil
operator|.
name|deinterleave
argument_list|(
name|hash
argument_list|)
argument_list|)
return|;
block|}
DECL|method|mortonUnhashLat
specifier|public
specifier|static
name|double
name|mortonUnhashLat
parameter_list|(
specifier|final
name|long
name|hash
parameter_list|)
block|{
return|return
name|unscaleLat
argument_list|(
name|BitUtil
operator|.
name|deinterleave
argument_list|(
name|hash
operator|>>>
literal|1
argument_list|)
argument_list|)
return|;
block|}
DECL|method|scaleLon
specifier|private
specifier|static
name|long
name|scaleLon
parameter_list|(
specifier|final
name|double
name|val
parameter_list|)
block|{
return|return
call|(
name|long
call|)
argument_list|(
operator|(
name|val
operator|-
name|MIN_LON_INCL
operator|)
operator|*
name|LON_SCALE
argument_list|)
return|;
block|}
DECL|method|scaleLat
specifier|private
specifier|static
name|long
name|scaleLat
parameter_list|(
specifier|final
name|double
name|val
parameter_list|)
block|{
return|return
call|(
name|long
call|)
argument_list|(
operator|(
name|val
operator|-
name|MIN_LAT_INCL
operator|)
operator|*
name|LAT_SCALE
argument_list|)
return|;
block|}
DECL|method|unscaleLon
specifier|private
specifier|static
name|double
name|unscaleLon
parameter_list|(
specifier|final
name|long
name|val
parameter_list|)
block|{
return|return
operator|(
name|val
operator|/
name|LON_SCALE
operator|)
operator|+
name|MIN_LON_INCL
return|;
block|}
DECL|method|unscaleLat
specifier|private
specifier|static
name|double
name|unscaleLat
parameter_list|(
specifier|final
name|long
name|val
parameter_list|)
block|{
return|return
operator|(
name|val
operator|/
name|LAT_SCALE
operator|)
operator|+
name|MIN_LAT_INCL
return|;
block|}
DECL|method|compare
specifier|public
specifier|static
name|double
name|compare
parameter_list|(
specifier|final
name|double
name|v1
parameter_list|,
specifier|final
name|double
name|v2
parameter_list|)
block|{
specifier|final
name|double
name|delta
init|=
name|v1
operator|-
name|v2
decl_stmt|;
return|return
name|Math
operator|.
name|abs
argument_list|(
name|delta
argument_list|)
operator|<=
name|TOLERANCE
condition|?
literal|0
else|:
name|delta
return|;
block|}
comment|/**    * Puts longitude in range of -180 to +180.    */
DECL|method|normalizeLon
specifier|public
specifier|static
name|double
name|normalizeLon
parameter_list|(
name|double
name|lon_deg
parameter_list|)
block|{
if|if
condition|(
name|lon_deg
operator|>=
operator|-
literal|180
operator|&&
name|lon_deg
operator|<=
literal|180
condition|)
block|{
return|return
name|lon_deg
return|;
comment|//common case, and avoids slight double precision shifting
block|}
name|double
name|off
init|=
operator|(
name|lon_deg
operator|+
literal|180
operator|)
operator|%
literal|360
decl_stmt|;
if|if
condition|(
name|off
operator|<
literal|0
condition|)
block|{
return|return
literal|180
operator|+
name|off
return|;
block|}
elseif|else
if|if
condition|(
name|off
operator|==
literal|0
operator|&&
name|lon_deg
operator|>
literal|0
condition|)
block|{
return|return
literal|180
return|;
block|}
else|else
block|{
return|return
operator|-
literal|180
operator|+
name|off
return|;
block|}
block|}
comment|/**    * Puts latitude in range of -90 to 90.    */
DECL|method|normalizeLat
specifier|public
specifier|static
name|double
name|normalizeLat
parameter_list|(
name|double
name|lat_deg
parameter_list|)
block|{
if|if
condition|(
name|lat_deg
operator|>=
operator|-
literal|90
operator|&&
name|lat_deg
operator|<=
literal|90
condition|)
block|{
return|return
name|lat_deg
return|;
comment|//common case, and avoids slight double precision shifting
block|}
name|double
name|off
init|=
name|Math
operator|.
name|abs
argument_list|(
operator|(
name|lat_deg
operator|+
literal|90
operator|)
operator|%
literal|360
argument_list|)
decl_stmt|;
return|return
operator|(
name|off
operator|<=
literal|180
condition|?
name|off
else|:
literal|360
operator|-
name|off
operator|)
operator|-
literal|90
return|;
block|}
comment|/**    * Determine if a bbox (defined by minLon, minLat, maxLon, maxLat) contains the provided point (defined by lon, lat)    * NOTE: this is a basic method that does not handle dateline or pole crossing. Unwrapping must be done before    * calling this method.    */
DECL|method|bboxContains
specifier|public
specifier|static
name|boolean
name|bboxContains
parameter_list|(
specifier|final
name|double
name|lon
parameter_list|,
specifier|final
name|double
name|lat
parameter_list|,
specifier|final
name|double
name|minLon
parameter_list|,
specifier|final
name|double
name|minLat
parameter_list|,
specifier|final
name|double
name|maxLon
parameter_list|,
specifier|final
name|double
name|maxLat
parameter_list|)
block|{
return|return
operator|(
name|compare
argument_list|(
name|lon
argument_list|,
name|minLon
argument_list|)
operator|>=
literal|0
operator|&&
name|compare
argument_list|(
name|lon
argument_list|,
name|maxLon
argument_list|)
operator|<=
literal|0
operator|&&
name|compare
argument_list|(
name|lat
argument_list|,
name|minLat
argument_list|)
operator|>=
literal|0
operator|&&
name|compare
argument_list|(
name|lat
argument_list|,
name|maxLat
argument_list|)
operator|<=
literal|0
operator|)
return|;
block|}
comment|/**    * simple even-odd point in polygon computation    *    1.  Determine if point is contained in the longitudinal range    *    2.  Determine whether point crosses the edge by computing the latitudinal delta    *        between the end-point of a parallel vector (originating at the point) and the    *        y-component of the edge sink    *    * NOTE: Requires polygon point (x,y) order either clockwise or counter-clockwise    */
DECL|method|pointInPolygon
specifier|public
specifier|static
name|boolean
name|pointInPolygon
parameter_list|(
name|double
index|[]
name|x
parameter_list|,
name|double
index|[]
name|y
parameter_list|,
name|double
name|lat
parameter_list|,
name|double
name|lon
parameter_list|)
block|{
assert|assert
name|x
operator|.
name|length
operator|==
name|y
operator|.
name|length
assert|;
name|boolean
name|inPoly
init|=
literal|false
decl_stmt|;
comment|/**      * Note: This is using a euclidean coordinate system which could result in      * upwards of 110KM error at the equator.      * TODO convert coordinates to cylindrical projection (e.g. mercator)      */
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|x
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|x
index|[
name|i
index|]
operator|<
name|lon
operator|&&
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|>=
name|lon
operator|||
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|<
name|lon
operator|&&
name|x
index|[
name|i
index|]
operator|>=
name|lon
condition|)
block|{
if|if
condition|(
name|y
index|[
name|i
index|]
operator|+
operator|(
name|lon
operator|-
name|x
index|[
name|i
index|]
operator|)
operator|/
operator|(
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|x
index|[
name|i
index|]
operator|)
operator|*
operator|(
name|y
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|y
index|[
name|i
index|]
operator|)
operator|<
name|lat
condition|)
block|{
name|inPoly
operator|=
operator|!
name|inPoly
expr_stmt|;
block|}
block|}
block|}
return|return
name|inPoly
return|;
block|}
DECL|method|geoTermToString
specifier|public
specifier|static
name|String
name|geoTermToString
parameter_list|(
name|long
name|term
parameter_list|)
block|{
name|StringBuilder
name|s
init|=
operator|new
name|StringBuilder
argument_list|(
literal|64
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numberOfLeadingZeros
init|=
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|term
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfLeadingZeros
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|term
operator|!=
literal|0
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
name|Long
operator|.
name|toBinaryString
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|rectDisjoint
specifier|public
specifier|static
name|boolean
name|rectDisjoint
parameter_list|(
specifier|final
name|double
name|aMinX
parameter_list|,
specifier|final
name|double
name|aMinY
parameter_list|,
specifier|final
name|double
name|aMaxX
parameter_list|,
specifier|final
name|double
name|aMaxY
parameter_list|,
specifier|final
name|double
name|bMinX
parameter_list|,
specifier|final
name|double
name|bMinY
parameter_list|,
specifier|final
name|double
name|bMaxX
parameter_list|,
specifier|final
name|double
name|bMaxY
parameter_list|)
block|{
return|return
operator|(
name|aMaxX
argument_list|<
name|bMinX
operator|||
name|aMinX
argument_list|>
name|bMaxX
operator|||
name|aMaxY
argument_list|<
name|bMinY
operator|||
name|aMinY
argument_list|>
name|bMaxY
operator|)
return|;
block|}
comment|/**    * Computes whether the first (a) rectangle is wholly within another (b) rectangle (shared boundaries allowed)    */
DECL|method|rectWithin
specifier|public
specifier|static
name|boolean
name|rectWithin
parameter_list|(
specifier|final
name|double
name|aMinX
parameter_list|,
specifier|final
name|double
name|aMinY
parameter_list|,
specifier|final
name|double
name|aMaxX
parameter_list|,
specifier|final
name|double
name|aMaxY
parameter_list|,
specifier|final
name|double
name|bMinX
parameter_list|,
specifier|final
name|double
name|bMinY
parameter_list|,
specifier|final
name|double
name|bMaxX
parameter_list|,
specifier|final
name|double
name|bMaxY
parameter_list|)
block|{
return|return
operator|!
operator|(
name|aMinX
argument_list|<
name|bMinX
operator|||
name|aMinY
argument_list|<
name|bMinY
operator|||
name|aMaxX
argument_list|>
name|bMaxX
operator|||
name|aMaxY
argument_list|>
name|bMaxY
operator|)
return|;
block|}
DECL|method|rectCrosses
specifier|public
specifier|static
name|boolean
name|rectCrosses
parameter_list|(
specifier|final
name|double
name|aMinX
parameter_list|,
specifier|final
name|double
name|aMinY
parameter_list|,
specifier|final
name|double
name|aMaxX
parameter_list|,
specifier|final
name|double
name|aMaxY
parameter_list|,
specifier|final
name|double
name|bMinX
parameter_list|,
specifier|final
name|double
name|bMinY
parameter_list|,
specifier|final
name|double
name|bMaxX
parameter_list|,
specifier|final
name|double
name|bMaxY
parameter_list|)
block|{
return|return
operator|!
operator|(
name|rectDisjoint
argument_list|(
name|aMinX
argument_list|,
name|aMinY
argument_list|,
name|aMaxX
argument_list|,
name|aMaxY
argument_list|,
name|bMinX
argument_list|,
name|bMinY
argument_list|,
name|bMaxX
argument_list|,
name|bMaxY
argument_list|)
operator|||
name|rectWithin
argument_list|(
name|aMinX
argument_list|,
name|aMinY
argument_list|,
name|aMaxX
argument_list|,
name|aMaxY
argument_list|,
name|bMinX
argument_list|,
name|bMinY
argument_list|,
name|bMaxX
argument_list|,
name|bMaxY
argument_list|)
operator|)
return|;
block|}
comment|/**    * Computes whether rectangle a contains rectangle b (touching allowed)    */
DECL|method|rectContains
specifier|public
specifier|static
name|boolean
name|rectContains
parameter_list|(
specifier|final
name|double
name|aMinX
parameter_list|,
specifier|final
name|double
name|aMinY
parameter_list|,
specifier|final
name|double
name|aMaxX
parameter_list|,
specifier|final
name|double
name|aMaxY
parameter_list|,
specifier|final
name|double
name|bMinX
parameter_list|,
specifier|final
name|double
name|bMinY
parameter_list|,
specifier|final
name|double
name|bMaxX
parameter_list|,
specifier|final
name|double
name|bMaxY
parameter_list|)
block|{
return|return
operator|!
operator|(
name|bMinX
argument_list|<
name|aMinX
operator|||
name|bMinY
argument_list|<
name|aMinY
operator|||
name|bMaxX
argument_list|>
name|aMaxX
operator|||
name|bMaxY
argument_list|>
name|aMaxY
operator|)
return|;
block|}
comment|/**    * Computes whether a rectangle intersects another rectangle (crosses, within, touching, etc)    */
DECL|method|rectIntersects
specifier|public
specifier|static
name|boolean
name|rectIntersects
parameter_list|(
specifier|final
name|double
name|aMinX
parameter_list|,
specifier|final
name|double
name|aMinY
parameter_list|,
specifier|final
name|double
name|aMaxX
parameter_list|,
specifier|final
name|double
name|aMaxY
parameter_list|,
specifier|final
name|double
name|bMinX
parameter_list|,
specifier|final
name|double
name|bMinY
parameter_list|,
specifier|final
name|double
name|bMaxX
parameter_list|,
specifier|final
name|double
name|bMaxY
parameter_list|)
block|{
return|return
operator|!
operator|(
operator|(
name|aMaxX
argument_list|<
name|bMinX
operator|||
name|aMinX
argument_list|>
name|bMaxX
operator|||
name|aMaxY
argument_list|<
name|bMinY
operator|||
name|aMinY
argument_list|>
name|bMaxY
operator|)
operator|)
return|;
block|}
comment|/**    * Computes whether a rectangle crosses a shape. (touching not allowed)    */
DECL|method|rectCrossesPoly
specifier|public
specifier|static
name|boolean
name|rectCrossesPoly
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
index|[]
name|shapeX
parameter_list|,
specifier|final
name|double
index|[]
name|shapeY
parameter_list|,
specifier|final
name|double
name|sMinX
parameter_list|,
specifier|final
name|double
name|sMinY
parameter_list|,
specifier|final
name|double
name|sMaxX
parameter_list|,
specifier|final
name|double
name|sMaxY
parameter_list|)
block|{
comment|// short-circuit: if the bounding boxes are disjoint then the shape does not cross
if|if
condition|(
name|rectDisjoint
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|sMinX
argument_list|,
name|sMinY
argument_list|,
name|sMaxX
argument_list|,
name|sMaxY
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|double
index|[]
index|[]
name|bbox
init|=
operator|new
name|double
index|[]
index|[]
block|{
block|{
name|rMinX
block|,
name|rMinY
block|}
block|,
block|{
name|rMaxX
block|,
name|rMinY
block|}
block|,
block|{
name|rMaxX
block|,
name|rMaxY
block|}
block|,
block|{
name|rMinX
block|,
name|rMaxY
block|}
block|,
block|{
name|rMinX
block|,
name|rMinY
block|}
block|}
decl_stmt|;
specifier|final
name|int
name|polyLength
init|=
name|shapeX
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|double
name|d
decl_stmt|,
name|s
decl_stmt|,
name|t
decl_stmt|,
name|a1
decl_stmt|,
name|b1
decl_stmt|,
name|c1
decl_stmt|,
name|a2
decl_stmt|,
name|b2
decl_stmt|,
name|c2
decl_stmt|;
name|double
name|x00
decl_stmt|,
name|y00
decl_stmt|,
name|x01
decl_stmt|,
name|y01
decl_stmt|,
name|x10
decl_stmt|,
name|y10
decl_stmt|,
name|x11
decl_stmt|,
name|y11
decl_stmt|;
comment|// computes the intersection point between each bbox edge and the polygon edge
for|for
control|(
name|short
name|b
init|=
literal|0
init|;
name|b
operator|<
literal|4
condition|;
operator|++
name|b
control|)
block|{
name|a1
operator|=
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|1
index|]
operator|-
name|bbox
index|[
name|b
index|]
index|[
literal|1
index|]
expr_stmt|;
name|b1
operator|=
name|bbox
index|[
name|b
index|]
index|[
literal|0
index|]
operator|-
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|c1
operator|=
name|a1
operator|*
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|b1
operator|*
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|int
name|p
init|=
literal|0
init|;
name|p
operator|<
name|polyLength
condition|;
operator|++
name|p
control|)
block|{
name|a2
operator|=
name|shapeY
index|[
name|p
operator|+
literal|1
index|]
operator|-
name|shapeY
index|[
name|p
index|]
expr_stmt|;
name|b2
operator|=
name|shapeX
index|[
name|p
index|]
operator|-
name|shapeX
index|[
name|p
operator|+
literal|1
index|]
expr_stmt|;
comment|// compute determinant
name|d
operator|=
name|a1
operator|*
name|b2
operator|-
name|a2
operator|*
name|b1
expr_stmt|;
if|if
condition|(
name|d
operator|!=
literal|0
condition|)
block|{
comment|// lines are not parallel, check intersecting points
name|c2
operator|=
name|a2
operator|*
name|shapeX
index|[
name|p
operator|+
literal|1
index|]
operator|+
name|b2
operator|*
name|shapeY
index|[
name|p
operator|+
literal|1
index|]
expr_stmt|;
name|s
operator|=
operator|(
literal|1
operator|/
name|d
operator|)
operator|*
operator|(
name|b2
operator|*
name|c1
operator|-
name|b1
operator|*
name|c2
operator|)
expr_stmt|;
name|t
operator|=
operator|(
literal|1
operator|/
name|d
operator|)
operator|*
operator|(
name|a1
operator|*
name|c2
operator|-
name|a2
operator|*
name|c1
operator|)
expr_stmt|;
name|x00
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|bbox
index|[
name|b
index|]
index|[
literal|0
index|]
argument_list|,
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|-
name|TOLERANCE
expr_stmt|;
name|x01
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|bbox
index|[
name|b
index|]
index|[
literal|0
index|]
argument_list|,
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|+
name|TOLERANCE
expr_stmt|;
name|y00
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|bbox
index|[
name|b
index|]
index|[
literal|1
index|]
argument_list|,
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|-
name|TOLERANCE
expr_stmt|;
name|y01
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|bbox
index|[
name|b
index|]
index|[
literal|1
index|]
argument_list|,
name|bbox
index|[
name|b
operator|+
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|+
name|TOLERANCE
expr_stmt|;
name|x10
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|shapeX
index|[
name|p
index|]
argument_list|,
name|shapeX
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
operator|-
name|TOLERANCE
expr_stmt|;
name|x11
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|shapeX
index|[
name|p
index|]
argument_list|,
name|shapeX
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
operator|+
name|TOLERANCE
expr_stmt|;
name|y10
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|shapeY
index|[
name|p
index|]
argument_list|,
name|shapeY
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
operator|-
name|TOLERANCE
expr_stmt|;
name|y11
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|shapeY
index|[
name|p
index|]
argument_list|,
name|shapeY
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
operator|+
name|TOLERANCE
expr_stmt|;
comment|// check whether the intersection point is touching one of the line segments
name|boolean
name|touching
init|=
operator|(
operator|(
name|x00
operator|==
name|s
operator|&&
name|y00
operator|==
name|t
operator|)
operator|||
operator|(
name|x01
operator|==
name|s
operator|&&
name|y01
operator|==
name|t
operator|)
operator|)
operator|||
operator|(
operator|(
name|x10
operator|==
name|s
operator|&&
name|y10
operator|==
name|t
operator|)
operator|||
operator|(
name|x11
operator|==
name|s
operator|&&
name|y11
operator|==
name|t
operator|)
operator|)
decl_stmt|;
comment|// if line segments are not touching and the intersection point is within the range of either segment
if|if
condition|(
operator|!
operator|(
name|touching
operator|||
name|x00
operator|>
name|s
operator|||
name|x01
argument_list|<
name|s
operator|||
name|y00
argument_list|>
name|t
operator|||
name|y01
argument_list|<
name|t
operator|||
name|x10
argument_list|>
name|s
operator|||
name|x11
argument_list|<
name|s
operator|||
name|y10
argument_list|>
name|t
operator|||
name|y11
operator|<
name|t
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
comment|// for each poly edge
block|}
comment|// for each bbox edge
return|return
literal|false
return|;
block|}
comment|/**    * Converts a given circle (defined as a point/radius) to an approximated line-segment polygon    *    * @param lon longitudinal center of circle (in degrees)    * @param lat latitudinal center of circle (in degrees)    * @param radiusMeters distance radius of circle (in meters)    * @return a list of lon/lat points representing the circle    */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"rawtypes"
block|}
argument_list|)
DECL|method|circleToPoly
specifier|public
specifier|static
name|ArrayList
argument_list|<
name|double
index|[]
argument_list|>
name|circleToPoly
parameter_list|(
specifier|final
name|double
name|lon
parameter_list|,
specifier|final
name|double
name|lat
parameter_list|,
specifier|final
name|double
name|radiusMeters
parameter_list|)
block|{
name|double
name|angle
decl_stmt|;
comment|// a little under-sampling (to limit the number of polygonal points): using archimedes estimation of pi
specifier|final
name|int
name|sides
init|=
literal|25
decl_stmt|;
name|ArrayList
argument_list|<
name|double
index|[]
argument_list|>
name|geometry
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|double
index|[]
name|lons
init|=
operator|new
name|double
index|[
name|sides
index|]
decl_stmt|;
name|double
index|[]
name|lats
init|=
operator|new
name|double
index|[
name|sides
index|]
decl_stmt|;
name|double
index|[]
name|pt
init|=
operator|new
name|double
index|[
literal|2
index|]
decl_stmt|;
specifier|final
name|int
name|sidesLen
init|=
name|sides
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sidesLen
condition|;
operator|++
name|i
control|)
block|{
name|angle
operator|=
operator|(
name|i
operator|*
literal|360
operator|/
name|sides
operator|)
expr_stmt|;
name|pt
operator|=
name|GeoProjectionUtils
operator|.
name|pointFromLonLatBearing
argument_list|(
name|lon
argument_list|,
name|lat
argument_list|,
name|angle
argument_list|,
name|radiusMeters
argument_list|,
name|pt
argument_list|)
expr_stmt|;
name|lons
index|[
name|i
index|]
operator|=
name|pt
index|[
literal|0
index|]
expr_stmt|;
name|lats
index|[
name|i
index|]
operator|=
name|pt
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|// close the poly
name|lons
index|[
name|sidesLen
index|]
operator|=
name|lons
index|[
literal|0
index|]
expr_stmt|;
name|lats
index|[
name|sidesLen
index|]
operator|=
name|lats
index|[
literal|0
index|]
expr_stmt|;
name|geometry
operator|.
name|add
argument_list|(
name|lons
argument_list|)
expr_stmt|;
name|geometry
operator|.
name|add
argument_list|(
name|lats
argument_list|)
expr_stmt|;
return|return
name|geometry
return|;
block|}
comment|/**    * Computes whether a rectangle is within a given polygon (shared boundaries allowed)    */
DECL|method|rectWithinPoly
specifier|public
specifier|static
name|boolean
name|rectWithinPoly
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
index|[]
name|shapeX
parameter_list|,
specifier|final
name|double
index|[]
name|shapeY
parameter_list|,
specifier|final
name|double
name|sMinX
parameter_list|,
specifier|final
name|double
name|sMinY
parameter_list|,
specifier|final
name|double
name|sMaxX
parameter_list|,
specifier|final
name|double
name|sMaxY
parameter_list|)
block|{
comment|// check if rectangle crosses poly (to handle concave/pacman polys), then check that all 4 corners
comment|// are contained
return|return
operator|!
operator|(
name|rectCrossesPoly
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|sMinX
argument_list|,
name|sMinY
argument_list|,
name|sMaxX
argument_list|,
name|sMaxY
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|rMinY
argument_list|,
name|rMinX
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|rMaxY
argument_list|,
name|rMaxX
argument_list|)
operator|||
operator|!
name|pointInPolygon
argument_list|(
name|shapeX
argument_list|,
name|shapeY
argument_list|,
name|rMaxY
argument_list|,
name|rMinX
argument_list|)
operator|)
return|;
block|}
DECL|method|rectAnyCornersOutsideCircle
specifier|private
specifier|static
name|boolean
name|rectAnyCornersOutsideCircle
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
name|centerLon
parameter_list|,
specifier|final
name|double
name|centerLat
parameter_list|,
specifier|final
name|double
name|radiusMeters
parameter_list|)
block|{
return|return
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|rMinX
argument_list|)
operator|*
literal|1000.0
operator|>
name|radiusMeters
operator|||
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|rMinX
argument_list|)
operator|*
literal|1000.0
operator|>
name|radiusMeters
operator|||
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|rMaxX
argument_list|)
operator|*
literal|1000.0
operator|>
name|radiusMeters
operator|||
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|)
operator|*
literal|1000.0
operator|>
name|radiusMeters
return|;
block|}
DECL|method|rectAnyCornersInCircle
specifier|private
specifier|static
name|boolean
name|rectAnyCornersInCircle
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
name|centerLon
parameter_list|,
specifier|final
name|double
name|centerLat
parameter_list|,
specifier|final
name|double
name|radiusMeters
parameter_list|)
block|{
return|return
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|rMinX
argument_list|)
operator|*
literal|1000.0
operator|<=
name|radiusMeters
operator|||
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|rMinX
argument_list|)
operator|*
literal|1000.0
operator|<=
name|radiusMeters
operator|||
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMaxY
argument_list|,
name|rMaxX
argument_list|)
operator|*
literal|1000.0
operator|<=
name|radiusMeters
operator|||
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|)
operator|*
literal|1000.0
operator|<=
name|radiusMeters
return|;
block|}
DECL|method|rectWithinCircle
specifier|public
specifier|static
name|boolean
name|rectWithinCircle
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
name|centerLon
parameter_list|,
specifier|final
name|double
name|centerLat
parameter_list|,
specifier|final
name|double
name|radiusMeters
parameter_list|)
block|{
return|return
name|rectAnyCornersOutsideCircle
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|radiusMeters
argument_list|)
operator|==
literal|false
return|;
block|}
comment|/**    * Determine if a bbox (defined by minLon, minLat, maxLon, maxLat) contains the provided point (defined by lon, lat)    * NOTE: this is basic method that does not handle dateline or pole crossing. Unwrapping must be done before    * calling this method.    */
DECL|method|rectCrossesCircle
specifier|public
specifier|static
name|boolean
name|rectCrossesCircle
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
name|centerLon
parameter_list|,
specifier|final
name|double
name|centerLat
parameter_list|,
specifier|final
name|double
name|radiusMeters
parameter_list|)
block|{
return|return
name|rectAnyCornersInCircle
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|radiusMeters
argument_list|)
operator|||
name|isClosestPointOnRectWithinRange
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|radiusMeters
argument_list|)
return|;
block|}
DECL|method|isClosestPointOnRectWithinRange
specifier|private
specifier|static
name|boolean
name|isClosestPointOnRectWithinRange
parameter_list|(
specifier|final
name|double
name|rMinX
parameter_list|,
specifier|final
name|double
name|rMinY
parameter_list|,
specifier|final
name|double
name|rMaxX
parameter_list|,
specifier|final
name|double
name|rMaxY
parameter_list|,
specifier|final
name|double
name|centerLon
parameter_list|,
specifier|final
name|double
name|centerLat
parameter_list|,
specifier|final
name|double
name|radiusMeters
parameter_list|)
block|{
name|double
index|[]
name|closestPt
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|GeoDistanceUtils
operator|.
name|closestPointOnBBox
argument_list|(
name|rMinX
argument_list|,
name|rMinY
argument_list|,
name|rMaxX
argument_list|,
name|rMaxY
argument_list|,
name|centerLon
argument_list|,
name|centerLat
argument_list|,
name|closestPt
argument_list|)
expr_stmt|;
return|return
name|SloppyMath
operator|.
name|haversin
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|closestPt
index|[
literal|1
index|]
argument_list|,
name|closestPt
index|[
literal|0
index|]
argument_list|)
operator|*
literal|1000.0
operator|<=
name|radiusMeters
return|;
block|}
comment|/**    * Compute Bounding Box for a circle using WGS-84 parameters    */
DECL|method|circleToBBox
specifier|public
specifier|static
name|GeoRect
name|circleToBBox
parameter_list|(
specifier|final
name|double
name|centerLon
parameter_list|,
specifier|final
name|double
name|centerLat
parameter_list|,
specifier|final
name|double
name|radiusMeters
parameter_list|)
block|{
specifier|final
name|double
name|radLat
init|=
name|StrictMath
operator|.
name|toRadians
argument_list|(
name|centerLat
argument_list|)
decl_stmt|;
specifier|final
name|double
name|radLon
init|=
name|StrictMath
operator|.
name|toRadians
argument_list|(
name|centerLon
argument_list|)
decl_stmt|;
name|double
name|radDistance
init|=
name|radiusMeters
operator|/
name|GeoProjectionUtils
operator|.
name|SEMIMAJOR_AXIS
decl_stmt|;
name|double
name|minLat
init|=
name|radLat
operator|-
name|radDistance
decl_stmt|;
name|double
name|maxLat
init|=
name|radLat
operator|+
name|radDistance
decl_stmt|;
name|double
name|minLon
decl_stmt|;
name|double
name|maxLon
decl_stmt|;
if|if
condition|(
name|minLat
operator|>
name|GeoProjectionUtils
operator|.
name|MIN_LAT_RADIANS
operator|&&
name|maxLat
operator|<
name|GeoProjectionUtils
operator|.
name|MAX_LAT_RADIANS
condition|)
block|{
name|double
name|deltaLon
init|=
name|StrictMath
operator|.
name|asin
argument_list|(
name|StrictMath
operator|.
name|sin
argument_list|(
name|radDistance
argument_list|)
operator|/
name|StrictMath
operator|.
name|cos
argument_list|(
name|radLat
argument_list|)
argument_list|)
decl_stmt|;
name|minLon
operator|=
name|radLon
operator|-
name|deltaLon
expr_stmt|;
if|if
condition|(
name|minLon
operator|<
name|GeoProjectionUtils
operator|.
name|MIN_LON_RADIANS
condition|)
block|{
name|minLon
operator|+=
literal|2d
operator|*
name|StrictMath
operator|.
name|PI
expr_stmt|;
block|}
name|maxLon
operator|=
name|radLon
operator|+
name|deltaLon
expr_stmt|;
if|if
condition|(
name|maxLon
operator|>
name|GeoProjectionUtils
operator|.
name|MAX_LON_RADIANS
condition|)
block|{
name|maxLon
operator|-=
literal|2d
operator|*
name|StrictMath
operator|.
name|PI
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// a pole is within the distance
name|minLat
operator|=
name|StrictMath
operator|.
name|max
argument_list|(
name|minLat
argument_list|,
name|GeoProjectionUtils
operator|.
name|MIN_LAT_RADIANS
argument_list|)
expr_stmt|;
name|maxLat
operator|=
name|StrictMath
operator|.
name|min
argument_list|(
name|maxLat
argument_list|,
name|GeoProjectionUtils
operator|.
name|MAX_LAT_RADIANS
argument_list|)
expr_stmt|;
name|minLon
operator|=
name|GeoProjectionUtils
operator|.
name|MIN_LON_RADIANS
expr_stmt|;
name|maxLon
operator|=
name|GeoProjectionUtils
operator|.
name|MAX_LON_RADIANS
expr_stmt|;
block|}
return|return
operator|new
name|GeoRect
argument_list|(
name|StrictMath
operator|.
name|toDegrees
argument_list|(
name|minLon
argument_list|)
argument_list|,
name|StrictMath
operator|.
name|toDegrees
argument_list|(
name|maxLon
argument_list|)
argument_list|,
name|StrictMath
operator|.
name|toDegrees
argument_list|(
name|minLat
argument_list|)
argument_list|,
name|StrictMath
operator|.
name|toDegrees
argument_list|(
name|maxLat
argument_list|)
argument_list|)
return|;
block|}
comment|/*   /**    * Computes whether or a 3dimensional line segment intersects or crosses a sphere    *    * @param lon1 longitudinal location of the line segment start point (in degrees)    * @param lat1 latitudinal location of the line segment start point (in degrees)    * @param alt1 altitude of the line segment start point (in degrees)    * @param lon2 longitudinal location of the line segment end point (in degrees)    * @param lat2 latitudinal location of the line segment end point (in degrees)    * @param alt2 altitude of the line segment end point (in degrees)    * @param centerLon longitudinal location of center search point (in degrees)    * @param centerLat latitudinal location of center search point (in degrees)    * @param centerAlt altitude of the center point (in meters)    * @param radiusMeters search sphere radius (in meters)    * @return whether the provided line segment is a secant of the    * /   // NOTE: not used for 2d at the moment. used for 3d w/ altitude (we can keep or add back)   private static boolean lineCrossesSphere(double lon1, double lat1, double alt1, double lon2,                                            double lat2, double alt2, double centerLon, double centerLat,                                            double centerAlt, double radiusMeters) {     // convert to cartesian 3d (in meters)     double[] ecf1 = GeoProjectionUtils.llaToECF(lon1, lat1, alt1, null);     double[] ecf2 = GeoProjectionUtils.llaToECF(lon2, lat2, alt2, null);     double[] cntr = GeoProjectionUtils.llaToECF(centerLon, centerLat, centerAlt, null);      final double dX = ecf2[0] - ecf1[0];     final double dY = ecf2[1] - ecf1[1];     final double dZ = ecf2[2] - ecf1[2];     final double fX = ecf1[0] - cntr[0];     final double fY = ecf1[1] - cntr[1];     final double fZ = ecf1[2] - cntr[2];      final double a = dX*dX + dY*dY + dZ*dZ;     final double b = 2 * (fX*dX + fY*dY + fZ*dZ);     final double c = (fX*fX + fY*fY + fZ*fZ) - (radiusMeters*radiusMeters);      double discrim = (b*b)-(4*a*c);     if (discrim< 0) {       return false;     }      discrim = StrictMath.sqrt(discrim);     final double a2 = 2*a;     final double t1 = (-b - discrim)/a2;     final double t2 = (-b + discrim)/a2;      if ( (t1< 0 || t1> 1) ) {       return !(t2< 0 || t2> 1);     }      return true;   }   */
DECL|method|isValidLat
specifier|public
specifier|static
name|boolean
name|isValidLat
parameter_list|(
name|double
name|lat
parameter_list|)
block|{
return|return
name|Double
operator|.
name|isNaN
argument_list|(
name|lat
argument_list|)
operator|==
literal|false
operator|&&
name|lat
operator|>=
name|MIN_LAT_INCL
operator|&&
name|lat
operator|<=
name|MAX_LAT_INCL
return|;
block|}
DECL|method|isValidLon
specifier|public
specifier|static
name|boolean
name|isValidLon
parameter_list|(
name|double
name|lon
parameter_list|)
block|{
return|return
name|Double
operator|.
name|isNaN
argument_list|(
name|lon
argument_list|)
operator|==
literal|false
operator|&&
name|lon
operator|>=
name|MIN_LON_INCL
operator|&&
name|lon
operator|<=
name|MAX_LON_INCL
return|;
block|}
block|}
end_class
end_unit
