begin_unit
begin_package
DECL|package|org.apache.lucene.bkdtree
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|bkdtree
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|DirectoryStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|InPlaceMergeSorter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LongBitSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|OfflineSorter
operator|.
name|ByteSequencesWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|OfflineSorter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_comment
comment|// TODO
end_comment
begin_comment
comment|//   - could we just "use postings" to map leaf -> docIDs?
end_comment
begin_comment
comment|//   - the polygon query really should be 2-phase
end_comment
begin_comment
comment|//   - if we could merge trees, we could drop delegating to wrapped DV?
end_comment
begin_comment
comment|//   - we could also index "auto-prefix terms" here, and use better compression, and maybe only use for the "fully contained" case so we'd
end_comment
begin_comment
comment|//     only index docIDs
end_comment
begin_comment
comment|//   - the index could be efficiently encoded as an FST, so we don't have wasteful
end_comment
begin_comment
comment|//     (monotonic) long[] leafBlockFPs; or we could use MonotonicLongValues ... but then
end_comment
begin_comment
comment|//     the index is already plenty small: 60M OSM points --> 1.1 MB with 128 points
end_comment
begin_comment
comment|//     per leaf, and you can reduce that by putting more points per leaf
end_comment
begin_comment
comment|//   - we can quantize the split values to 2 bytes (short): http://people.csail.mit.edu/tmertens/papers/qkdtree.pdf
end_comment
begin_comment
comment|//   - we could use threads while building; the higher nodes are very parallelizable
end_comment
begin_comment
comment|//   - generalize to N dimenions? i think there are reasonable use cases here, e.g.
end_comment
begin_comment
comment|//     2 dimensional points to store houses, plus e.g. 3rd dimension for "household income"
end_comment
begin_comment
comment|//   - geo3d integration should be straightforward?  better accuracy, faster performance for small-poly-with-bbox cases?  right now the poly
end_comment
begin_comment
comment|//     check is very costly...
end_comment
begin_comment
comment|/** Recursively builds a BKD tree to assign all incoming points to smaller  *  and smaller rectangles until the number of points in a given  *  rectangle is&lt= the<code>maxPointsInLeafNode</code>.  The tree is  *  fully balanced, which means the leaf nodes will have between 50% and 100% of  *  the requested<code>maxPointsInLeafNode</code>, except for the adversarial case  *  of indexing exactly the same point many times.  *  *<p>  *  See<a href="https://www.cs.duke.edu/~pankaj/publications/papers/bkd-sstd.pdf">this paper</a> for details.  *  *<p>This consumes heap during writing: it allocates a<code>LongBitSet(numPoints)</code>,   *  and for any nodes with fewer than<code>maxPointsSortInHeap</code>, it holds  *  the points in memory as simple java arrays.  *  *<p>  *<b>NOTE</b>: This can write at most Integer.MAX_VALUE *<code>maxPointsInLeafNode</code> total points.  *  * @lucene.experimental */
end_comment
begin_class
DECL|class|BKDTreeWriter
class|class
name|BKDTreeWriter
block|{
comment|// latEnc (int) + lonEnc (int) + ord (long) + docID (int)
DECL|field|BYTES_PER_DOC
specifier|static
specifier|final
name|int
name|BYTES_PER_DOC
init|=
name|RamUsageEstimator
operator|.
name|NUM_BYTES_LONG
operator|+
literal|3
operator|*
name|RamUsageEstimator
operator|.
name|NUM_BYTES_INT
decl_stmt|;
comment|//static final boolean DEBUG = false;
DECL|field|DEFAULT_MAX_POINTS_IN_LEAF_NODE
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_POINTS_IN_LEAF_NODE
init|=
literal|1024
decl_stmt|;
comment|/** This works out to max of ~10 MB peak heap tied up during writing: */
DECL|field|DEFAULT_MAX_POINTS_SORT_IN_HEAP
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_POINTS_SORT_IN_HEAP
init|=
literal|128
operator|*
literal|1024
decl_stmt|;
empty_stmt|;
DECL|field|scratchBytes
specifier|private
specifier|final
name|byte
index|[]
name|scratchBytes
init|=
operator|new
name|byte
index|[
name|BYTES_PER_DOC
index|]
decl_stmt|;
DECL|field|scratchBytesOutput
specifier|private
specifier|final
name|ByteArrayDataOutput
name|scratchBytesOutput
init|=
operator|new
name|ByteArrayDataOutput
argument_list|(
name|scratchBytes
argument_list|)
decl_stmt|;
DECL|field|writer
specifier|private
name|OfflineSorter
operator|.
name|ByteSequencesWriter
name|writer
decl_stmt|;
DECL|field|heapWriter
specifier|private
name|GrowingHeapLatLonWriter
name|heapWriter
decl_stmt|;
DECL|field|tempInput
specifier|private
name|Path
name|tempInput
decl_stmt|;
DECL|field|tempDir
specifier|private
name|Path
name|tempDir
decl_stmt|;
DECL|field|maxPointsInLeafNode
specifier|private
specifier|final
name|int
name|maxPointsInLeafNode
decl_stmt|;
DECL|field|maxPointsSortInHeap
specifier|private
specifier|final
name|int
name|maxPointsSortInHeap
decl_stmt|;
DECL|field|pointCount
specifier|private
name|long
name|pointCount
decl_stmt|;
DECL|method|BKDTreeWriter
specifier|public
name|BKDTreeWriter
parameter_list|()
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|DEFAULT_MAX_POINTS_IN_LEAF_NODE
argument_list|,
name|DEFAULT_MAX_POINTS_SORT_IN_HEAP
argument_list|)
expr_stmt|;
block|}
comment|// TODO: instead of maxPointsSortInHeap, change to maxMBHeap ... the mapping is non-obvious:
DECL|method|BKDTreeWriter
specifier|public
name|BKDTreeWriter
parameter_list|(
name|int
name|maxPointsInLeafNode
parameter_list|,
name|int
name|maxPointsSortInHeap
parameter_list|)
throws|throws
name|IOException
block|{
name|verifyParams
argument_list|(
name|maxPointsInLeafNode
argument_list|,
name|maxPointsSortInHeap
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxPointsInLeafNode
operator|=
name|maxPointsInLeafNode
expr_stmt|;
name|this
operator|.
name|maxPointsSortInHeap
operator|=
name|maxPointsSortInHeap
expr_stmt|;
comment|// We write first maxPointsSortInHeap in heap, then cutover to offline for additional points:
name|heapWriter
operator|=
operator|new
name|GrowingHeapLatLonWriter
argument_list|(
name|maxPointsSortInHeap
argument_list|)
expr_stmt|;
block|}
DECL|method|verifyParams
specifier|public
specifier|static
name|void
name|verifyParams
parameter_list|(
name|int
name|maxPointsInLeafNode
parameter_list|,
name|int
name|maxPointsSortInHeap
parameter_list|)
block|{
if|if
condition|(
name|maxPointsInLeafNode
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxPointsInLeafNode must be> 0; got "
operator|+
name|maxPointsInLeafNode
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxPointsInLeafNode
operator|>
name|ArrayUtil
operator|.
name|MAX_ARRAY_LENGTH
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxPointsInLeafNode must be<= ArrayUtil.MAX_ARRAY_LENGTH (= "
operator|+
name|ArrayUtil
operator|.
name|MAX_ARRAY_LENGTH
operator|+
literal|"); got "
operator|+
name|maxPointsInLeafNode
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxPointsSortInHeap
operator|<
name|maxPointsInLeafNode
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxPointsSortInHeap must be>= maxPointsInLeafNode; got "
operator|+
name|maxPointsSortInHeap
operator|+
literal|" vs maxPointsInLeafNode="
operator|+
name|maxPointsInLeafNode
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxPointsSortInHeap
operator|>
name|ArrayUtil
operator|.
name|MAX_ARRAY_LENGTH
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxPointsSortInHeap must be<= ArrayUtil.MAX_ARRAY_LENGTH (= "
operator|+
name|ArrayUtil
operator|.
name|MAX_ARRAY_LENGTH
operator|+
literal|"); got "
operator|+
name|maxPointsSortInHeap
argument_list|)
throw|;
block|}
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|double
name|lat
parameter_list|,
name|double
name|lon
parameter_list|,
name|int
name|docID
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|validLat
argument_list|(
name|lat
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"invalid lat: "
operator|+
name|lat
argument_list|)
throw|;
block|}
if|if
condition|(
name|validLon
argument_list|(
name|lon
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"invalid lon: "
operator|+
name|lon
argument_list|)
throw|;
block|}
comment|// Quantize to 32 bit precision, which is plenty: ~.0093 meter precision (longitude) at the equator
name|add
argument_list|(
name|encodeLat
argument_list|(
name|lat
argument_list|)
argument_list|,
name|encodeLon
argument_list|(
name|lon
argument_list|)
argument_list|,
name|docID
argument_list|)
expr_stmt|;
block|}
comment|/** If the current segment has too many points then we switchover to temp files / offline sort. */
DECL|method|switchToOffline
specifier|private
name|void
name|switchToOffline
parameter_list|()
throws|throws
name|IOException
block|{
comment|// OfflineSorter isn't thread safe, but our own private tempDir works around this:
name|tempDir
operator|=
name|Files
operator|.
name|createTempDirectory
argument_list|(
name|OfflineSorter
operator|.
name|defaultTempDir
argument_list|()
argument_list|,
name|BKDTreeWriter
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
comment|// For each .add we just append to this input file, then in .finish we sort this input and resursively build the tree:
name|tempInput
operator|=
name|tempDir
operator|.
name|resolve
argument_list|(
literal|"in"
argument_list|)
expr_stmt|;
name|writer
operator|=
operator|new
name|OfflineSorter
operator|.
name|ByteSequencesWriter
argument_list|(
name|tempInput
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
name|i
operator|++
control|)
block|{
name|scratchBytesOutput
operator|.
name|reset
argument_list|(
name|scratchBytes
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeInt
argument_list|(
name|heapWriter
operator|.
name|latEncs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeInt
argument_list|(
name|heapWriter
operator|.
name|lonEncs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeVInt
argument_list|(
name|heapWriter
operator|.
name|docIDs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeVLong
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// TODO: can/should OfflineSorter optimize the fixed-width case?
name|writer
operator|.
name|write
argument_list|(
name|scratchBytes
argument_list|,
literal|0
argument_list|,
name|scratchBytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|heapWriter
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|add
name|void
name|add
parameter_list|(
name|int
name|latEnc
parameter_list|,
name|int
name|lonEnc
parameter_list|,
name|int
name|docID
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|latEnc
operator|>
name|Integer
operator|.
name|MIN_VALUE
assert|;
assert|assert
name|latEnc
operator|<
name|Integer
operator|.
name|MAX_VALUE
assert|;
assert|assert
name|lonEnc
operator|>
name|Integer
operator|.
name|MIN_VALUE
assert|;
assert|assert
name|lonEnc
operator|<
name|Integer
operator|.
name|MAX_VALUE
assert|;
if|if
condition|(
name|pointCount
operator|>=
name|maxPointsSortInHeap
condition|)
block|{
if|if
condition|(
name|writer
operator|==
literal|null
condition|)
block|{
name|switchToOffline
argument_list|()
expr_stmt|;
block|}
name|scratchBytesOutput
operator|.
name|reset
argument_list|(
name|scratchBytes
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeInt
argument_list|(
name|latEnc
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeInt
argument_list|(
name|lonEnc
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeVInt
argument_list|(
name|docID
argument_list|)
expr_stmt|;
name|scratchBytesOutput
operator|.
name|writeVLong
argument_list|(
name|pointCount
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|scratchBytes
argument_list|,
literal|0
argument_list|,
name|scratchBytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Not too many points added yet, continue using heap:
name|heapWriter
operator|.
name|append
argument_list|(
name|latEnc
argument_list|,
name|lonEnc
argument_list|,
name|pointCount
argument_list|,
name|docID
argument_list|)
expr_stmt|;
block|}
name|pointCount
operator|++
expr_stmt|;
block|}
comment|/** Changes incoming {@link ByteSequencesWriter} file to to fixed-width-per-entry file, because we need to be able to slice    *  as we recurse in {@link #build}. */
DECL|method|convertToFixedWidth
specifier|private
name|LatLonWriter
name|convertToFixedWidth
parameter_list|(
name|Path
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|BytesRefBuilder
name|scratch
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|scratch
operator|.
name|grow
argument_list|(
name|BYTES_PER_DOC
argument_list|)
expr_stmt|;
name|BytesRef
name|bytes
init|=
name|scratch
operator|.
name|get
argument_list|()
decl_stmt|;
name|ByteArrayDataInput
name|dataReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
name|OfflineSorter
operator|.
name|ByteSequencesReader
name|reader
init|=
literal|null
decl_stmt|;
name|LatLonWriter
name|sortedWriter
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|reader
operator|=
operator|new
name|OfflineSorter
operator|.
name|ByteSequencesReader
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|sortedWriter
operator|=
name|getWriter
argument_list|(
name|pointCount
argument_list|)
expr_stmt|;
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|result
init|=
name|reader
operator|.
name|read
argument_list|(
name|scratch
argument_list|)
decl_stmt|;
assert|assert
name|result
assert|;
name|dataReader
operator|.
name|reset
argument_list|(
name|bytes
operator|.
name|bytes
argument_list|,
name|bytes
operator|.
name|offset
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|latEnc
init|=
name|dataReader
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|int
name|lonEnc
init|=
name|dataReader
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|int
name|docID
init|=
name|dataReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|long
name|ord
init|=
name|dataReader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
assert|assert
name|docID
operator|>=
literal|0
operator|:
literal|"docID="
operator|+
name|docID
assert|;
assert|assert
name|latEnc
operator|>
name|Integer
operator|.
name|MIN_VALUE
assert|;
assert|assert
name|latEnc
operator|<
name|Integer
operator|.
name|MAX_VALUE
assert|;
assert|assert
name|lonEnc
operator|>
name|Integer
operator|.
name|MIN_VALUE
assert|;
assert|assert
name|lonEnc
operator|<
name|Integer
operator|.
name|MAX_VALUE
assert|;
name|sortedWriter
operator|.
name|append
argument_list|(
name|latEnc
argument_list|,
name|lonEnc
argument_list|,
name|ord
argument_list|,
name|docID
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|sortedWriter
argument_list|,
name|reader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|reader
argument_list|)
expr_stmt|;
try|try
block|{
name|sortedWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress to keep throwing original exc
block|}
block|}
block|}
return|return
name|sortedWriter
return|;
block|}
DECL|method|sort
specifier|private
name|LatLonWriter
name|sort
parameter_list|(
name|boolean
name|lon
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|heapWriter
operator|!=
literal|null
condition|)
block|{
assert|assert
name|pointCount
operator|<
name|Integer
operator|.
name|MAX_VALUE
assert|;
comment|// All buffered points are still in heap
operator|new
name|InPlaceMergeSorter
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|docID
init|=
name|heapWriter
operator|.
name|docIDs
index|[
name|i
index|]
decl_stmt|;
name|heapWriter
operator|.
name|docIDs
index|[
name|i
index|]
operator|=
name|heapWriter
operator|.
name|docIDs
index|[
name|j
index|]
expr_stmt|;
name|heapWriter
operator|.
name|docIDs
index|[
name|j
index|]
operator|=
name|docID
expr_stmt|;
name|long
name|ord
init|=
name|heapWriter
operator|.
name|ords
index|[
name|i
index|]
decl_stmt|;
name|heapWriter
operator|.
name|ords
index|[
name|i
index|]
operator|=
name|heapWriter
operator|.
name|ords
index|[
name|j
index|]
expr_stmt|;
name|heapWriter
operator|.
name|ords
index|[
name|j
index|]
operator|=
name|ord
expr_stmt|;
name|int
name|latEnc
init|=
name|heapWriter
operator|.
name|latEncs
index|[
name|i
index|]
decl_stmt|;
name|heapWriter
operator|.
name|latEncs
index|[
name|i
index|]
operator|=
name|heapWriter
operator|.
name|latEncs
index|[
name|j
index|]
expr_stmt|;
name|heapWriter
operator|.
name|latEncs
index|[
name|j
index|]
operator|=
name|latEnc
expr_stmt|;
name|int
name|lonEnc
init|=
name|heapWriter
operator|.
name|lonEncs
index|[
name|i
index|]
decl_stmt|;
name|heapWriter
operator|.
name|lonEncs
index|[
name|i
index|]
operator|=
name|heapWriter
operator|.
name|lonEncs
index|[
name|j
index|]
expr_stmt|;
name|heapWriter
operator|.
name|lonEncs
index|[
name|j
index|]
operator|=
name|lonEnc
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|int
name|cmp
decl_stmt|;
if|if
condition|(
name|lon
condition|)
block|{
name|cmp
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|heapWriter
operator|.
name|lonEncs
index|[
name|i
index|]
argument_list|,
name|heapWriter
operator|.
name|lonEncs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmp
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|heapWriter
operator|.
name|latEncs
index|[
name|i
index|]
argument_list|,
name|heapWriter
operator|.
name|latEncs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
comment|// Tie-break
name|cmp
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|heapWriter
operator|.
name|docIDs
index|[
name|i
index|]
argument_list|,
name|heapWriter
operator|.
name|docIDs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
return|return
name|Long
operator|.
name|compare
argument_list|(
name|heapWriter
operator|.
name|ords
index|[
name|i
index|]
argument_list|,
name|heapWriter
operator|.
name|ords
index|[
name|j
index|]
argument_list|)
return|;
block|}
block|}
operator|.
name|sort
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|pointCount
argument_list|)
expr_stmt|;
name|HeapLatLonWriter
name|sorted
init|=
operator|new
name|HeapLatLonWriter
argument_list|(
operator|(
name|int
operator|)
name|pointCount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
name|i
operator|++
control|)
block|{
name|sorted
operator|.
name|append
argument_list|(
name|heapWriter
operator|.
name|latEncs
index|[
name|i
index|]
argument_list|,
name|heapWriter
operator|.
name|lonEncs
index|[
name|i
index|]
argument_list|,
name|heapWriter
operator|.
name|ords
index|[
name|i
index|]
argument_list|,
name|heapWriter
operator|.
name|docIDs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|sorted
return|;
block|}
else|else
block|{
comment|// Offline sort:
assert|assert
name|tempDir
operator|!=
literal|null
assert|;
specifier|final
name|ByteArrayDataInput
name|reader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|cmp
init|=
operator|new
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
argument_list|()
block|{
specifier|private
specifier|final
name|ByteArrayDataInput
name|readerB
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|BytesRef
name|a
parameter_list|,
name|BytesRef
name|b
parameter_list|)
block|{
name|reader
operator|.
name|reset
argument_list|(
name|a
operator|.
name|bytes
argument_list|,
name|a
operator|.
name|offset
argument_list|,
name|a
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|int
name|latAEnc
init|=
name|reader
operator|.
name|readInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|lonAEnc
init|=
name|reader
operator|.
name|readInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|docIDA
init|=
name|reader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
specifier|final
name|long
name|ordA
init|=
name|reader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
name|reader
operator|.
name|reset
argument_list|(
name|b
operator|.
name|bytes
argument_list|,
name|b
operator|.
name|offset
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|int
name|latBEnc
init|=
name|reader
operator|.
name|readInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|lonBEnc
init|=
name|reader
operator|.
name|readInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|docIDB
init|=
name|reader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
specifier|final
name|long
name|ordB
init|=
name|reader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
name|int
name|cmp
decl_stmt|;
if|if
condition|(
name|lon
condition|)
block|{
name|cmp
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|lonAEnc
argument_list|,
name|lonBEnc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmp
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|latAEnc
argument_list|,
name|latBEnc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
comment|// Tie-break
name|cmp
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|docIDA
argument_list|,
name|docIDB
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
return|return
name|Long
operator|.
name|compare
argument_list|(
name|ordA
argument_list|,
name|ordB
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|Path
name|sorted
init|=
name|tempDir
operator|.
name|resolve
argument_list|(
literal|"sorted"
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|OfflineSorter
name|latSorter
init|=
operator|new
name|OfflineSorter
argument_list|(
name|cmp
argument_list|,
name|OfflineSorter
operator|.
name|BufferSize
operator|.
name|automatic
argument_list|()
argument_list|,
name|tempDir
argument_list|,
name|OfflineSorter
operator|.
name|MAX_TEMPFILES
argument_list|)
decl_stmt|;
name|latSorter
operator|.
name|sort
argument_list|(
name|tempInput
argument_list|,
name|sorted
argument_list|)
expr_stmt|;
name|LatLonWriter
name|writer
init|=
name|convertToFixedWidth
argument_list|(
name|sorted
argument_list|)
decl_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|writer
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|rm
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|deleteFilesIgnoringExceptions
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Writes the BKD tree to the provided {@link IndexOutput} and returns the file offset where index was written. */
DECL|method|finish
specifier|public
name|long
name|finish
parameter_list|(
name|IndexOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("\nBKDTreeWriter.finish pointCount=" + pointCount + " out=" + out + " heapWriter=" + heapWriter);
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|LongBitSet
name|bitSet
init|=
operator|new
name|LongBitSet
argument_list|(
name|pointCount
argument_list|)
decl_stmt|;
name|long
name|countPerLeaf
init|=
name|pointCount
decl_stmt|;
name|long
name|innerNodeCount
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|countPerLeaf
operator|>
name|maxPointsInLeafNode
condition|)
block|{
name|countPerLeaf
operator|/=
literal|2
expr_stmt|;
name|innerNodeCount
operator|*=
literal|2
expr_stmt|;
block|}
comment|//System.out.println("innerNodeCount=" + innerNodeCount);
if|if
condition|(
literal|1
operator|+
literal|2
operator|*
name|innerNodeCount
operator|>=
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"too many nodes; increase maxPointsInLeafNode (currently "
operator|+
name|maxPointsInLeafNode
operator|+
literal|") and reindex"
argument_list|)
throw|;
block|}
name|innerNodeCount
operator|--
expr_stmt|;
name|int
name|numLeaves
init|=
call|(
name|int
call|)
argument_list|(
name|innerNodeCount
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|// Indexed by nodeID, but first (root) nodeID is 1
name|int
index|[]
name|splitValues
init|=
operator|new
name|int
index|[
name|numLeaves
index|]
decl_stmt|;
comment|// +1 because leaf count is power of 2 (e.g. 8), and innerNodeCount is power of 2 minus 1 (e.g. 7)
name|long
index|[]
name|leafBlockFPs
init|=
operator|new
name|long
index|[
name|numLeaves
index|]
decl_stmt|;
comment|// Make sure the math above "worked":
assert|assert
name|pointCount
operator|/
name|splitValues
operator|.
name|length
operator|<=
name|maxPointsInLeafNode
operator|:
literal|"pointCount="
operator|+
name|pointCount
operator|+
literal|" splitValues.length="
operator|+
name|splitValues
operator|.
name|length
operator|+
literal|" maxPointsInLeafNode="
operator|+
name|maxPointsInLeafNode
assert|;
comment|//System.out.println("  avg pointsPerLeaf=" + (pointCount/splitValues.length));
comment|// Sort all docs once by lat, once by lon:
name|LatLonWriter
name|latSortedWriter
init|=
literal|null
decl_stmt|;
name|LatLonWriter
name|lonSortedWriter
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|lonSortedWriter
operator|=
name|sort
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|latSortedWriter
operator|=
name|sort
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|heapWriter
operator|=
literal|null
expr_stmt|;
name|build
argument_list|(
literal|1
argument_list|,
name|numLeaves
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|latSortedWriter
argument_list|,
literal|0
argument_list|,
name|pointCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|lonSortedWriter
argument_list|,
literal|0
argument_list|,
name|pointCount
argument_list|)
argument_list|,
name|bitSet
argument_list|,
name|out
argument_list|,
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
comment|//encodeLat(-90.0), encodeLat(Math.nextAfter(90.0, Double.POSITIVE_INFINITY)),
comment|//encodeLon(-180.0), encodeLon(Math.nextAfter(180.0, Double.POSITIVE_INFINITY)),
name|splitValues
argument_list|,
name|leafBlockFPs
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|latSortedWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|lonSortedWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|IOUtils
operator|.
name|rm
argument_list|(
name|tempInput
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|latSortedWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress to keep throwing original exc
block|}
try|try
block|{
name|lonSortedWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress to keep throwing original exc
block|}
name|IOUtils
operator|.
name|deleteFilesIgnoringExceptions
argument_list|(
name|tempInput
argument_list|)
expr_stmt|;
block|}
block|}
comment|//System.out.println("Total nodes: " + innerNodeCount);
comment|// Write index:
name|long
name|indexFP
init|=
name|out
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|numLeaves
argument_list|)
expr_stmt|;
comment|// NOTE: splitValues[0] is unused, because nodeID is 1-based:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|splitValues
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|splitValues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leafBlockFPs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|writeVLong
argument_list|(
name|leafBlockFPs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tempDir
operator|!=
literal|null
condition|)
block|{
comment|// If we had to go offline, we should have removed all temp files we wrote:
assert|assert
name|directoryIsEmpty
argument_list|(
name|tempDir
argument_list|)
assert|;
name|IOUtils
operator|.
name|rm
argument_list|(
name|tempDir
argument_list|)
expr_stmt|;
block|}
return|return
name|indexFP
return|;
block|}
comment|// Called only from assert
DECL|method|directoryIsEmpty
specifier|private
name|boolean
name|directoryIsEmpty
parameter_list|(
name|Path
name|in
parameter_list|)
block|{
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|dir
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|in
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|path
range|:
name|dir
control|)
block|{
assert|assert
literal|false
operator|:
literal|"dir="
operator|+
name|in
operator|+
literal|" still has file="
operator|+
name|path
assert|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// Just ignore: we are only called from assert
block|}
return|return
literal|true
return|;
block|}
comment|/** Sliced reference to points in an OfflineSorter.ByteSequencesWriter file. */
DECL|class|PathSlice
specifier|private
specifier|static
specifier|final
class|class
name|PathSlice
block|{
DECL|field|writer
specifier|final
name|LatLonWriter
name|writer
decl_stmt|;
DECL|field|start
specifier|final
name|long
name|start
decl_stmt|;
DECL|field|count
specifier|final
name|long
name|count
decl_stmt|;
DECL|method|PathSlice
specifier|public
name|PathSlice
parameter_list|(
name|LatLonWriter
name|writer
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|count
parameter_list|)
block|{
name|this
operator|.
name|writer
operator|=
name|writer
expr_stmt|;
name|this
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"PathSlice(start="
operator|+
name|start
operator|+
literal|" count="
operator|+
name|count
operator|+
literal|" writer="
operator|+
name|writer
operator|+
literal|")"
return|;
block|}
block|}
comment|/** Marks bits for the ords (points) that belong in the left sub tree. */
DECL|method|markLeftTree
specifier|private
name|long
name|markLeftTree
parameter_list|(
name|int
name|splitDim
parameter_list|,
name|PathSlice
name|source
parameter_list|,
name|LongBitSet
name|bitSet
parameter_list|,
name|int
index|[]
name|splitValueRet
parameter_list|,
name|int
name|minLatEnc
parameter_list|,
name|int
name|maxLatEnc
parameter_list|,
name|int
name|minLonEnc
parameter_list|,
name|int
name|maxLonEnc
parameter_list|)
throws|throws
name|IOException
block|{
comment|// This is the initital size of our left tree, but we may lower it below for == case:
name|long
name|leftCount
init|=
name|source
operator|.
name|count
operator|/
literal|2
decl_stmt|;
comment|// Read the split value:
comment|//if (DEBUG) System.out.println("  leftCount=" + leftCount + " vs " + source.count);
name|LatLonReader
name|reader
init|=
name|source
operator|.
name|writer
operator|.
name|getReader
argument_list|(
name|source
operator|.
name|start
operator|+
name|leftCount
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|int
name|splitValue
decl_stmt|;
try|try
block|{
name|boolean
name|result
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
assert|assert
name|result
assert|;
name|int
name|latSplitEnc
init|=
name|reader
operator|.
name|latEnc
argument_list|()
decl_stmt|;
assert|assert
name|latSplitEnc
operator|>=
name|minLatEnc
operator|&&
name|latSplitEnc
operator|<
name|maxLatEnc
operator|:
literal|"latSplitEnc="
operator|+
name|latSplitEnc
operator|+
literal|" minLatEnc="
operator|+
name|minLatEnc
operator|+
literal|" maxLatEnc="
operator|+
name|maxLatEnc
assert|;
name|int
name|lonSplitEnc
init|=
name|reader
operator|.
name|lonEnc
argument_list|()
decl_stmt|;
assert|assert
name|lonSplitEnc
operator|>=
name|minLonEnc
operator|&&
name|lonSplitEnc
operator|<
name|maxLonEnc
operator|:
literal|"lonSplitEnc="
operator|+
name|lonSplitEnc
operator|+
literal|" minLonEnc="
operator|+
name|minLonEnc
operator|+
literal|" maxLonEnc="
operator|+
name|maxLonEnc
assert|;
if|if
condition|(
name|splitDim
operator|==
literal|0
condition|)
block|{
name|splitValue
operator|=
name|latSplitEnc
expr_stmt|;
comment|//if (DEBUG) System.out.println("  splitValue=" + decodeLat(splitValue));
block|}
else|else
block|{
name|splitValue
operator|=
name|lonSplitEnc
expr_stmt|;
comment|//if (DEBUG) System.out.println("  splitValue=" + decodeLon(splitValue));
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
name|splitValueRet
index|[
literal|0
index|]
operator|=
name|splitValue
expr_stmt|;
comment|// Mark ords that fall into the left half, and also handle the == boundary case:
assert|assert
name|bitSet
operator|.
name|cardinality
argument_list|()
operator|==
literal|0
operator|:
literal|"cardinality="
operator|+
name|bitSet
operator|.
name|cardinality
argument_list|()
assert|;
name|success
operator|=
literal|false
expr_stmt|;
name|reader
operator|=
name|source
operator|.
name|writer
operator|.
name|getReader
argument_list|(
name|source
operator|.
name|start
argument_list|)
expr_stmt|;
try|try
block|{
name|int
name|lastValue
init|=
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftCount
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|result
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
assert|assert
name|result
assert|;
name|int
name|latEnc
init|=
name|reader
operator|.
name|latEnc
argument_list|()
decl_stmt|;
name|int
name|lonEnc
init|=
name|reader
operator|.
name|lonEnc
argument_list|()
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
name|splitDim
operator|==
literal|0
condition|)
block|{
name|value
operator|=
name|latEnc
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|lonEnc
expr_stmt|;
block|}
comment|// Our input source is supposed to be sorted on the incoming dimension:
assert|assert
name|value
operator|>=
name|lastValue
assert|;
name|lastValue
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|splitValue
condition|)
block|{
comment|// TODO: we could simplify this, by allowing splitValue to be on either side?
comment|// If we have identical points at the split, we move the count back to before the identical points:
name|leftCount
operator|=
name|i
expr_stmt|;
break|break;
block|}
assert|assert
name|value
operator|<
name|splitValue
operator|:
literal|"i="
operator|+
name|i
operator|+
literal|" value="
operator|+
name|value
operator|+
literal|" vs splitValue="
operator|+
name|splitValue
assert|;
name|long
name|ord
init|=
name|reader
operator|.
name|ord
argument_list|()
decl_stmt|;
name|int
name|docID
init|=
name|reader
operator|.
name|docID
argument_list|()
decl_stmt|;
assert|assert
name|docID
operator|>=
literal|0
operator|:
literal|"docID="
operator|+
name|docID
operator|+
literal|" reader="
operator|+
name|reader
assert|;
comment|// We should never see dup ords:
assert|assert
name|bitSet
operator|.
name|get
argument_list|(
name|ord
argument_list|)
operator|==
literal|false
assert|;
name|bitSet
operator|.
name|set
argument_list|(
name|ord
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|leftCount
operator|==
name|bitSet
operator|.
name|cardinality
argument_list|()
operator|:
literal|"leftCount="
operator|+
name|leftCount
operator|+
literal|" cardinality="
operator|+
name|bitSet
operator|.
name|cardinality
argument_list|()
assert|;
return|return
name|leftCount
return|;
block|}
comment|/** The incoming PathSlice for the dim we will split is already partitioned/sorted. */
DECL|method|build
specifier|private
name|void
name|build
parameter_list|(
name|int
name|nodeID
parameter_list|,
name|int
name|leafNodeOffset
parameter_list|,
name|PathSlice
name|lastLatSorted
parameter_list|,
name|PathSlice
name|lastLonSorted
parameter_list|,
name|LongBitSet
name|bitSet
parameter_list|,
name|IndexOutput
name|out
parameter_list|,
name|int
name|minLatEnc
parameter_list|,
name|int
name|maxLatEnc
parameter_list|,
name|int
name|minLonEnc
parameter_list|,
name|int
name|maxLonEnc
parameter_list|,
name|int
index|[]
name|splitValues
parameter_list|,
name|long
index|[]
name|leafBlockFPs
parameter_list|)
throws|throws
name|IOException
block|{
name|PathSlice
name|source
decl_stmt|;
name|PathSlice
name|nextSource
decl_stmt|;
name|long
name|latRange
init|=
operator|(
name|long
operator|)
name|maxLatEnc
operator|-
operator|(
name|long
operator|)
name|minLatEnc
decl_stmt|;
name|long
name|lonRange
init|=
operator|(
name|long
operator|)
name|maxLonEnc
operator|-
operator|(
name|long
operator|)
name|minLonEnc
decl_stmt|;
comment|// Compute which dim we should split on at this level:
name|int
name|splitDim
decl_stmt|;
if|if
condition|(
name|latRange
operator|>=
name|lonRange
condition|)
block|{
comment|// Split by lat:
name|splitDim
operator|=
literal|0
expr_stmt|;
name|source
operator|=
name|lastLatSorted
expr_stmt|;
name|nextSource
operator|=
name|lastLonSorted
expr_stmt|;
block|}
else|else
block|{
comment|// Split by lon:
name|splitDim
operator|=
literal|1
expr_stmt|;
name|source
operator|=
name|lastLonSorted
expr_stmt|;
name|nextSource
operator|=
name|lastLatSorted
expr_stmt|;
block|}
name|long
name|count
init|=
name|source
operator|.
name|count
decl_stmt|;
comment|//if (DEBUG) System.out.println("\nBUILD: nodeID=" + nodeID + " leafNodeOffset=" + leafNodeOffset + " splitDim=" + splitDim + "\n  lastLatSorted=" + lastLatSorted + "\n  lastLonSorted=" + lastLonSorted + "\n  count=" + count + " lat=" + decodeLat(minLatEnc) + " TO " + decodeLat(maxLatEnc) + " lon=" + decodeLon(minLonEnc) + " TO " + decodeLon(maxLonEnc));
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|// Dead end in the tree, due to adversary cases, e.g. many identical points:
if|if
condition|(
name|nodeID
operator|<
name|splitValues
operator|.
name|length
condition|)
block|{
comment|// Sentinel used to mark that the tree is dead under here:
name|splitValues
index|[
name|nodeID
index|]
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
comment|//if (DEBUG) System.out.println("  dead-end sub-tree");
return|return;
block|}
if|if
condition|(
name|nodeID
operator|>=
name|leafNodeOffset
condition|)
block|{
comment|// Leaf node: write block
comment|//if (DEBUG) System.out.println("  leaf");
assert|assert
name|maxLatEnc
operator|>
name|minLatEnc
assert|;
assert|assert
name|maxLonEnc
operator|>
name|minLonEnc
assert|;
comment|//System.out.println("\nleaf:\n  lat range: " + ((long) maxLatEnc-minLatEnc));
comment|//System.out.println("  lon range: " + ((long) maxLonEnc-minLonEnc));
assert|assert
name|count
operator|==
name|source
operator|.
name|count
operator|:
literal|"count="
operator|+
name|count
operator|+
literal|" vs source.count="
operator|+
name|source
operator|.
name|count
assert|;
comment|// Sort by docID in the leaf so we can .or(DISI) at search time:
name|LatLonReader
name|reader
init|=
name|source
operator|.
name|writer
operator|.
name|getReader
argument_list|(
name|source
operator|.
name|start
argument_list|)
decl_stmt|;
name|int
index|[]
name|docIDs
init|=
operator|new
name|int
index|[
operator|(
name|int
operator|)
name|count
index|]
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|source
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|// NOTE: we discard ord at this point; we only needed it temporarily
comment|// during building to uniquely identify each point to properly handle
comment|// the multi-valued case (one docID having multiple values):
comment|// We also discard lat/lon, since at search time, we reside on the
comment|// wrapped doc values for this:
name|boolean
name|result
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
assert|assert
name|result
assert|;
name|docIDs
index|[
name|i
index|]
operator|=
name|reader
operator|.
name|docID
argument_list|()
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|docIDs
argument_list|)
expr_stmt|;
comment|// Dedup docIDs: for the multi-valued case where more than one value for the doc
comment|// wound up in this leaf cell, we only need to store the docID once:
name|int
name|lastDocID
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|uniqueCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docIDs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|docID
init|=
name|docIDs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|docID
operator|!=
name|lastDocID
condition|)
block|{
name|uniqueCount
operator|++
expr_stmt|;
name|lastDocID
operator|=
name|docID
expr_stmt|;
block|}
block|}
assert|assert
name|uniqueCount
operator|<=
name|count
assert|;
name|long
name|startFP
init|=
name|out
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|uniqueCount
argument_list|)
expr_stmt|;
comment|// Save the block file pointer:
name|leafBlockFPs
index|[
name|nodeID
operator|-
name|leafNodeOffset
index|]
operator|=
name|startFP
expr_stmt|;
comment|//System.out.println("    leafFP=" + startFP);
name|lastDocID
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|docIDs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// Absolute int encode; with "vInt of deltas" encoding, the .kdd size dropped from
comment|// 697 MB -> 539 MB, but query time for 225 queries went from 1.65 sec -> 2.64 sec.
comment|// I think if we also indexed prefix terms here we could do less costly compression
comment|// on those lists:
name|int
name|docID
init|=
name|docIDs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|docID
operator|!=
name|lastDocID
condition|)
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|docID
argument_list|)
expr_stmt|;
name|lastDocID
operator|=
name|docID
expr_stmt|;
block|}
block|}
comment|//long endFP = out.getFilePointer();
comment|//System.out.println("  bytes/doc: " + ((endFP - startFP) / count));
block|}
else|else
block|{
comment|// Inner node: sort, partition/recurse
assert|assert
name|nodeID
operator|<
name|splitValues
operator|.
name|length
operator|:
literal|"nodeID="
operator|+
name|nodeID
operator|+
literal|" splitValues.length="
operator|+
name|splitValues
operator|.
name|length
assert|;
name|int
index|[]
name|splitValueArray
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
assert|assert
name|source
operator|.
name|count
operator|==
name|count
assert|;
name|long
name|leftCount
init|=
name|markLeftTree
argument_list|(
name|splitDim
argument_list|,
name|source
argument_list|,
name|bitSet
argument_list|,
name|splitValueArray
argument_list|,
name|minLatEnc
argument_list|,
name|maxLatEnc
argument_list|,
name|minLonEnc
argument_list|,
name|maxLonEnc
argument_list|)
decl_stmt|;
name|int
name|splitValue
init|=
name|splitValueArray
index|[
literal|0
index|]
decl_stmt|;
comment|// TODO: we could save split value in here so we don't have to re-open file later:
comment|// Partition nextSource into sorted left and right sets, so we can recurse.  This is somewhat hairy: we partition the next lon set
comment|// according to how we had just partitioned the lat set, and vice/versa:
name|LatLonWriter
name|leftWriter
init|=
literal|null
decl_stmt|;
name|LatLonWriter
name|rightWriter
init|=
literal|null
decl_stmt|;
name|LatLonReader
name|reader
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|int
name|nextLeftCount
init|=
literal|0
decl_stmt|;
try|try
block|{
name|leftWriter
operator|=
name|getWriter
argument_list|(
name|leftCount
argument_list|)
expr_stmt|;
name|rightWriter
operator|=
name|getWriter
argument_list|(
name|nextSource
operator|.
name|count
operator|-
name|leftCount
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("  partition:\n    splitValueEnc=" + splitValue + "\n    " + nextSource + "\n      --> leftSorted=" + leftWriter + "\n      --> rightSorted=" + rightWriter + ")");
assert|assert
name|nextSource
operator|.
name|count
operator|==
name|count
assert|;
name|reader
operator|=
name|nextSource
operator|.
name|writer
operator|.
name|getReader
argument_list|(
name|nextSource
operator|.
name|start
argument_list|)
expr_stmt|;
comment|// TODO: we could compute the split value here for each sub-tree and save an O(N) pass on recursion, but makes code hairier and only
comment|// changes the constant factor of building, not the big-oh:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nextSource
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|result
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
assert|assert
name|result
assert|;
name|int
name|latEnc
init|=
name|reader
operator|.
name|latEnc
argument_list|()
decl_stmt|;
name|int
name|lonEnc
init|=
name|reader
operator|.
name|lonEnc
argument_list|()
decl_stmt|;
name|long
name|ord
init|=
name|reader
operator|.
name|ord
argument_list|()
decl_stmt|;
name|int
name|docID
init|=
name|reader
operator|.
name|docID
argument_list|()
decl_stmt|;
assert|assert
name|docID
operator|>=
literal|0
operator|:
literal|"docID="
operator|+
name|docID
operator|+
literal|" reader="
operator|+
name|reader
assert|;
if|if
condition|(
name|bitSet
operator|.
name|get
argument_list|(
name|ord
argument_list|)
condition|)
block|{
if|if
condition|(
name|splitDim
operator|==
literal|0
condition|)
block|{
assert|assert
name|latEnc
operator|<
name|splitValue
operator|:
literal|"latEnc="
operator|+
name|latEnc
operator|+
literal|" splitValue="
operator|+
name|splitValue
assert|;
block|}
else|else
block|{
assert|assert
name|lonEnc
operator|<
name|splitValue
operator|:
literal|"lonEnc="
operator|+
name|lonEnc
operator|+
literal|" splitValue="
operator|+
name|splitValue
assert|;
block|}
name|leftWriter
operator|.
name|append
argument_list|(
name|latEnc
argument_list|,
name|lonEnc
argument_list|,
name|ord
argument_list|,
name|docID
argument_list|)
expr_stmt|;
name|nextLeftCount
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|splitDim
operator|==
literal|0
condition|)
block|{
assert|assert
name|latEnc
operator|>=
name|splitValue
operator|:
literal|"latEnc="
operator|+
name|latEnc
operator|+
literal|" splitValue="
operator|+
name|splitValue
assert|;
block|}
else|else
block|{
assert|assert
name|lonEnc
operator|>=
name|splitValue
operator|:
literal|"lonEnc="
operator|+
name|lonEnc
operator|+
literal|" splitValue="
operator|+
name|splitValue
assert|;
block|}
name|rightWriter
operator|.
name|append
argument_list|(
name|latEnc
argument_list|,
name|lonEnc
argument_list|,
name|ord
argument_list|,
name|docID
argument_list|)
expr_stmt|;
block|}
block|}
name|bitSet
operator|.
name|clear
argument_list|(
literal|0
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|reader
argument_list|,
name|leftWriter
argument_list|,
name|rightWriter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|reader
argument_list|,
name|leftWriter
argument_list|,
name|rightWriter
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|leftCount
operator|==
name|nextLeftCount
operator|:
literal|"leftCount="
operator|+
name|leftCount
operator|+
literal|" nextLeftCount="
operator|+
name|nextLeftCount
assert|;
assert|assert
name|count
operator|==
name|nextSource
operator|.
name|count
operator|:
literal|"count="
operator|+
name|count
operator|+
literal|" nextSource.count="
operator|+
name|count
assert|;
name|success
operator|=
literal|false
expr_stmt|;
try|try
block|{
if|if
condition|(
name|splitDim
operator|==
literal|0
condition|)
block|{
comment|//if (DEBUG) System.out.println("  recurse left");
name|build
argument_list|(
literal|2
operator|*
name|nodeID
argument_list|,
name|leafNodeOffset
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|source
operator|.
name|writer
argument_list|,
name|source
operator|.
name|start
argument_list|,
name|leftCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|leftWriter
argument_list|,
literal|0
argument_list|,
name|leftCount
argument_list|)
argument_list|,
name|bitSet
argument_list|,
name|out
argument_list|,
name|minLatEnc
argument_list|,
name|splitValue
argument_list|,
name|minLonEnc
argument_list|,
name|maxLonEnc
argument_list|,
name|splitValues
argument_list|,
name|leafBlockFPs
argument_list|)
expr_stmt|;
name|leftWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("  recurse right");
name|build
argument_list|(
literal|2
operator|*
name|nodeID
operator|+
literal|1
argument_list|,
name|leafNodeOffset
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|source
operator|.
name|writer
argument_list|,
name|source
operator|.
name|start
operator|+
name|leftCount
argument_list|,
name|count
operator|-
name|leftCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|rightWriter
argument_list|,
literal|0
argument_list|,
name|count
operator|-
name|leftCount
argument_list|)
argument_list|,
name|bitSet
argument_list|,
name|out
argument_list|,
name|splitValue
argument_list|,
name|maxLatEnc
argument_list|,
name|minLonEnc
argument_list|,
name|maxLonEnc
argument_list|,
name|splitValues
argument_list|,
name|leafBlockFPs
argument_list|)
expr_stmt|;
name|rightWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//if (DEBUG) System.out.println("  recurse left");
name|build
argument_list|(
literal|2
operator|*
name|nodeID
argument_list|,
name|leafNodeOffset
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|leftWriter
argument_list|,
literal|0
argument_list|,
name|leftCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|source
operator|.
name|writer
argument_list|,
name|source
operator|.
name|start
argument_list|,
name|leftCount
argument_list|)
argument_list|,
name|bitSet
argument_list|,
name|out
argument_list|,
name|minLatEnc
argument_list|,
name|maxLatEnc
argument_list|,
name|minLonEnc
argument_list|,
name|splitValue
argument_list|,
name|splitValues
argument_list|,
name|leafBlockFPs
argument_list|)
expr_stmt|;
name|leftWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("  recurse right");
name|build
argument_list|(
literal|2
operator|*
name|nodeID
operator|+
literal|1
argument_list|,
name|leafNodeOffset
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|rightWriter
argument_list|,
literal|0
argument_list|,
name|count
operator|-
name|leftCount
argument_list|)
argument_list|,
operator|new
name|PathSlice
argument_list|(
name|source
operator|.
name|writer
argument_list|,
name|source
operator|.
name|start
operator|+
name|leftCount
argument_list|,
name|count
operator|-
name|leftCount
argument_list|)
argument_list|,
name|bitSet
argument_list|,
name|out
argument_list|,
name|minLatEnc
argument_list|,
name|maxLatEnc
argument_list|,
name|splitValue
argument_list|,
name|maxLonEnc
argument_list|,
name|splitValues
argument_list|,
name|leafBlockFPs
argument_list|)
expr_stmt|;
name|rightWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
try|try
block|{
name|leftWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress to keep throwing original exc
block|}
try|try
block|{
name|rightWriter
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress to keep throwing original exc
block|}
block|}
block|}
name|splitValues
index|[
name|nodeID
index|]
operator|=
name|splitValue
expr_stmt|;
block|}
block|}
DECL|method|getWriter
name|LatLonWriter
name|getWriter
parameter_list|(
name|long
name|count
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|count
operator|<
name|maxPointsSortInHeap
condition|)
block|{
return|return
operator|new
name|HeapLatLonWriter
argument_list|(
operator|(
name|int
operator|)
name|count
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|OfflineLatLonWriter
argument_list|(
name|tempDir
argument_list|,
name|count
argument_list|)
return|;
block|}
block|}
comment|// TODO: move/share all this into GeoUtils
comment|// We allow one iota over the true max:
DECL|field|MAX_LAT_INCL
specifier|static
specifier|final
name|double
name|MAX_LAT_INCL
init|=
name|Math
operator|.
name|nextAfter
argument_list|(
literal|90.0D
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
decl_stmt|;
DECL|field|MAX_LON_INCL
specifier|static
specifier|final
name|double
name|MAX_LON_INCL
init|=
name|Math
operator|.
name|nextAfter
argument_list|(
literal|180.0D
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
decl_stmt|;
DECL|field|MIN_LAT_INCL
specifier|static
specifier|final
name|double
name|MIN_LAT_INCL
init|=
operator|-
literal|90.0D
decl_stmt|;
DECL|field|MIN_LON_INCL
specifier|static
specifier|final
name|double
name|MIN_LON_INCL
init|=
operator|-
literal|180.0D
decl_stmt|;
DECL|method|validLat
specifier|static
name|boolean
name|validLat
parameter_list|(
name|double
name|lat
parameter_list|)
block|{
return|return
name|Double
operator|.
name|isNaN
argument_list|(
name|lat
argument_list|)
operator|==
literal|false
operator|&&
name|lat
operator|>=
name|MIN_LAT_INCL
operator|&&
name|lat
operator|<=
name|MAX_LAT_INCL
return|;
block|}
DECL|method|validLon
specifier|static
name|boolean
name|validLon
parameter_list|(
name|double
name|lon
parameter_list|)
block|{
return|return
name|Double
operator|.
name|isNaN
argument_list|(
name|lon
argument_list|)
operator|==
literal|false
operator|&&
name|lon
operator|>=
name|MIN_LON_INCL
operator|&&
name|lon
operator|<=
name|MAX_LON_INCL
return|;
block|}
DECL|field|BITS
specifier|private
specifier|static
specifier|final
name|int
name|BITS
init|=
literal|32
decl_stmt|;
comment|// -3 so valid lat/lon never hit the Integer.MIN_VALUE nor Integer.MAX_VALUE:
DECL|field|LON_SCALE
specifier|private
specifier|static
specifier|final
name|double
name|LON_SCALE
init|=
operator|(
operator|(
literal|0x1L
operator|<<
name|BITS
operator|)
operator|-
literal|3
operator|)
operator|/
literal|360.0D
decl_stmt|;
DECL|field|LAT_SCALE
specifier|private
specifier|static
specifier|final
name|double
name|LAT_SCALE
init|=
operator|(
operator|(
literal|0x1L
operator|<<
name|BITS
operator|)
operator|-
literal|3
operator|)
operator|/
literal|180.0D
decl_stmt|;
comment|/** Max quantization error for both lat and lon when encoding/decoding into 32 bits */
DECL|field|TOLERANCE
specifier|public
specifier|static
specifier|final
name|double
name|TOLERANCE
init|=
literal|1E
operator|-
literal|7
decl_stmt|;
comment|/** Quantizes double (64 bit) latitude into 32 bits */
DECL|method|encodeLat
specifier|static
name|int
name|encodeLat
parameter_list|(
name|double
name|lat
parameter_list|)
block|{
assert|assert
name|validLat
argument_list|(
name|lat
argument_list|)
operator|:
literal|"lat="
operator|+
name|lat
assert|;
name|long
name|x
init|=
call|(
name|long
call|)
argument_list|(
name|lat
operator|*
name|LAT_SCALE
argument_list|)
decl_stmt|;
comment|// We use Integer.MAX_VALUE as a sentinel:
assert|assert
name|x
operator|<
name|Integer
operator|.
name|MAX_VALUE
operator|:
literal|"lat="
operator|+
name|lat
operator|+
literal|" mapped to Integer.MAX_VALUE + "
operator|+
operator|(
name|x
operator|-
name|Integer
operator|.
name|MAX_VALUE
operator|)
assert|;
assert|assert
name|x
operator|>
name|Integer
operator|.
name|MIN_VALUE
operator|:
literal|"lat="
operator|+
name|lat
operator|+
literal|" mapped to Integer.MIN_VALUE"
assert|;
return|return
operator|(
name|int
operator|)
name|x
return|;
block|}
comment|/** Quantizes double (64 bit) longitude into 32 bits */
DECL|method|encodeLon
specifier|static
name|int
name|encodeLon
parameter_list|(
name|double
name|lon
parameter_list|)
block|{
assert|assert
name|validLon
argument_list|(
name|lon
argument_list|)
operator|:
literal|"lon="
operator|+
name|lon
assert|;
name|long
name|x
init|=
call|(
name|long
call|)
argument_list|(
name|lon
operator|*
name|LON_SCALE
argument_list|)
decl_stmt|;
comment|// We use Integer.MAX_VALUE as a sentinel:
assert|assert
name|x
operator|<
name|Integer
operator|.
name|MAX_VALUE
assert|;
assert|assert
name|x
operator|>
name|Integer
operator|.
name|MIN_VALUE
assert|;
return|return
operator|(
name|int
operator|)
name|x
return|;
block|}
comment|/** Turns quantized value from {@link #encodeLat} back into a double. */
DECL|method|decodeLat
specifier|static
name|double
name|decodeLat
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
name|x
operator|/
name|LAT_SCALE
return|;
block|}
comment|/** Turns quantized value from {@link #encodeLon} back into a double. */
DECL|method|decodeLon
specifier|static
name|double
name|decodeLon
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
name|x
operator|/
name|LON_SCALE
return|;
block|}
block|}
end_class
end_unit
