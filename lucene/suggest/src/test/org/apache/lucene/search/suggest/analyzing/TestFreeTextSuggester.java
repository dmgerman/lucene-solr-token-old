begin_unit
begin_package
DECL|package|org.apache.lucene.search.suggest.analyzing
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|analyzing
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockAnalyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockTokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Tokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|core
operator|.
name|StopFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|util
operator|.
name|CharArraySet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|Lookup
operator|.
name|LookupResult
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|Input
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|InputArrayIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|InputIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LineFileDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import
begin_class
DECL|class|TestFreeTextSuggester
specifier|public
class|class
name|TestFreeTextSuggester
extends|extends
name|LuceneTestCase
block|{
DECL|method|testBasic
specifier|public
name|void
name|testBasic
parameter_list|()
throws|throws
name|Exception
block|{
name|Iterable
argument_list|<
name|Input
argument_list|>
name|keys
init|=
name|shuffle
argument_list|(
operator|new
name|Input
argument_list|(
literal|"foo bar baz blah"
argument_list|,
literal|50
argument_list|)
argument_list|,
operator|new
name|Input
argument_list|(
literal|"boo foo bar foo bee"
argument_list|,
literal|20
argument_list|)
argument_list|)
decl_stmt|;
name|Analyzer
name|a
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|FreeTextSuggester
name|sug
init|=
operator|new
name|FreeTextSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
literal|2
argument_list|,
operator|(
name|byte
operator|)
literal|0x20
argument_list|)
decl_stmt|;
name|sug
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|sug
operator|.
name|getCount
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|// Uses bigram model and unigram backoff:
name|assertEquals
argument_list|(
literal|"foo bar/0.67 foo bee/0.33 baz/0.04 blah/0.04 boo/0.04"
argument_list|,
name|toString
argument_list|(
name|sug
operator|.
name|lookup
argument_list|(
literal|"foo b"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Uses only bigram model:
name|assertEquals
argument_list|(
literal|"foo bar/0.67 foo bee/0.33"
argument_list|,
name|toString
argument_list|(
name|sug
operator|.
name|lookup
argument_list|(
literal|"foo "
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Uses only unigram model:
name|assertEquals
argument_list|(
literal|"foo/0.33"
argument_list|,
name|toString
argument_list|(
name|sug
operator|.
name|lookup
argument_list|(
literal|"foo"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Uses only unigram model:
name|assertEquals
argument_list|(
literal|"bar/0.22 baz/0.11 bee/0.11 blah/0.11 boo/0.11"
argument_list|,
name|toString
argument_list|(
name|sug
operator|.
name|lookup
argument_list|(
literal|"b"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Try again after save/load:
name|File
name|tmpDir
init|=
name|TestUtil
operator|.
name|getTempDir
argument_list|(
literal|"FreeTextSuggesterTest"
argument_list|)
decl_stmt|;
name|tmpDir
operator|.
name|mkdir
argument_list|()
expr_stmt|;
name|File
name|path
init|=
operator|new
name|File
argument_list|(
name|tmpDir
argument_list|,
literal|"suggester"
argument_list|)
decl_stmt|;
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|sug
operator|.
name|store
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
name|InputStream
name|is
init|=
operator|new
name|FileInputStream
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|sug
operator|=
operator|new
name|FreeTextSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
literal|2
argument_list|,
operator|(
name|byte
operator|)
literal|0x20
argument_list|)
expr_stmt|;
name|sug
operator|.
name|load
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|sug
operator|.
name|getCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testIllegalByteDuringBuild
specifier|public
name|void
name|testIllegalByteDuringBuild
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Default separator is INFORMATION SEPARATOR TWO
comment|// (0x1e), so no input token is allowed to contain it
name|Iterable
argument_list|<
name|Input
argument_list|>
name|keys
init|=
name|shuffle
argument_list|(
operator|new
name|Input
argument_list|(
literal|"foo\u001ebar baz"
argument_list|,
literal|50
argument_list|)
argument_list|)
decl_stmt|;
name|FreeTextSuggester
name|sug
init|=
operator|new
name|FreeTextSuggester
argument_list|(
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|sug
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"did not hit expected exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// expected
block|}
block|}
DECL|method|testIllegalByteDuringQuery
specifier|public
name|void
name|testIllegalByteDuringQuery
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Default separator is INFORMATION SEPARATOR TWO
comment|// (0x1e), so no input token is allowed to contain it
name|Iterable
argument_list|<
name|Input
argument_list|>
name|keys
init|=
name|shuffle
argument_list|(
operator|new
name|Input
argument_list|(
literal|"foo bar baz"
argument_list|,
literal|50
argument_list|)
argument_list|)
decl_stmt|;
name|FreeTextSuggester
name|sug
init|=
operator|new
name|FreeTextSuggester
argument_list|(
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|sug
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|sug
operator|.
name|lookup
argument_list|(
literal|"foo\u001eb"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"did not hit expected exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// expected
block|}
block|}
annotation|@
name|Ignore
DECL|method|testWiki
specifier|public
name|void
name|testWiki
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|LineFileDocs
name|lfd
init|=
operator|new
name|LineFileDocs
argument_list|(
literal|null
argument_list|,
literal|"/lucenedata/enwiki/enwiki-20120502-lines-1k.txt"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Skip header:
name|lfd
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
name|FreeTextSuggester
name|sug
init|=
operator|new
name|FreeTextSuggester
argument_list|(
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|sug
operator|.
name|build
argument_list|(
operator|new
name|InputIterator
argument_list|()
block|{
specifier|private
name|int
name|count
decl_stmt|;
annotation|@
name|Override
specifier|public
name|long
name|weight
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|BytesRef
name|next
parameter_list|()
block|{
name|Document
name|doc
decl_stmt|;
try|try
block|{
name|doc
operator|=
name|lfd
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|count
operator|++
operator|==
literal|10000
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|BytesRef
argument_list|(
name|doc
operator|.
name|get
argument_list|(
literal|"body"
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|BytesRef
name|payload
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasPayloads
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|BytesRef
argument_list|>
name|contexts
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasContexts
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|sug
operator|.
name|sizeInBytes
argument_list|()
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|sug
operator|.
name|lookup
argument_list|(
literal|"general r"
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"results:"
argument_list|)
expr_stmt|;
for|for
control|(
name|LookupResult
name|result
range|:
name|results
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|result
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Make sure you can suggest based only on unigram model:
DECL|method|testUnigrams
specifier|public
name|void
name|testUnigrams
parameter_list|()
throws|throws
name|Exception
block|{
name|Iterable
argument_list|<
name|Input
argument_list|>
name|keys
init|=
name|shuffle
argument_list|(
operator|new
name|Input
argument_list|(
literal|"foo bar baz blah boo foo bar foo bee"
argument_list|,
literal|50
argument_list|)
argument_list|)
decl_stmt|;
name|Analyzer
name|a
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|FreeTextSuggester
name|sug
init|=
operator|new
name|FreeTextSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
literal|1
argument_list|,
operator|(
name|byte
operator|)
literal|0x20
argument_list|)
decl_stmt|;
name|sug
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
comment|// Sorts first by count, descending, second by term, ascending
name|assertEquals
argument_list|(
literal|"bar/0.22 baz/0.11 bee/0.11 blah/0.11 boo/0.11"
argument_list|,
name|toString
argument_list|(
name|sug
operator|.
name|lookup
argument_list|(
literal|"b"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Make sure the last token is not duplicated
DECL|method|testNoDupsAcrossGrams
specifier|public
name|void
name|testNoDupsAcrossGrams
parameter_list|()
throws|throws
name|Exception
block|{
name|Iterable
argument_list|<
name|Input
argument_list|>
name|keys
init|=
name|shuffle
argument_list|(
operator|new
name|Input
argument_list|(
literal|"foo bar bar bar bar"
argument_list|,
literal|50
argument_list|)
argument_list|)
decl_stmt|;
name|Analyzer
name|a
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|FreeTextSuggester
name|sug
init|=
operator|new
name|FreeTextSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
literal|2
argument_list|,
operator|(
name|byte
operator|)
literal|0x20
argument_list|)
decl_stmt|;
name|sug
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"foo bar/1.00"
argument_list|,
name|toString
argument_list|(
name|sug
operator|.
name|lookup
argument_list|(
literal|"foo b"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Lookup of just empty string produces unicode only matches:
DECL|method|testEmptyString
specifier|public
name|void
name|testEmptyString
parameter_list|()
throws|throws
name|Exception
block|{
name|Iterable
argument_list|<
name|Input
argument_list|>
name|keys
init|=
name|shuffle
argument_list|(
operator|new
name|Input
argument_list|(
literal|"foo bar bar bar bar"
argument_list|,
literal|50
argument_list|)
argument_list|)
decl_stmt|;
name|Analyzer
name|a
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|FreeTextSuggester
name|sug
init|=
operator|new
name|FreeTextSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
literal|2
argument_list|,
operator|(
name|byte
operator|)
literal|0x20
argument_list|)
decl_stmt|;
name|sug
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|sug
operator|.
name|lookup
argument_list|(
literal|""
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"did not hit exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// expected
block|}
block|}
comment|// With one ending hole, ShingleFilter produces "of _" and
comment|// we should properly predict from that:
DECL|method|testEndingHole
specifier|public
name|void
name|testEndingHole
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Just deletes "of"
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|field
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|()
decl_stmt|;
name|CharArraySet
name|stopSet
init|=
name|StopFilter
operator|.
name|makeStopSet
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
literal|"of"
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|StopFilter
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
name|tokenizer
argument_list|,
name|stopSet
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|Iterable
argument_list|<
name|Input
argument_list|>
name|keys
init|=
name|shuffle
argument_list|(
operator|new
name|Input
argument_list|(
literal|"wizard of oz"
argument_list|,
literal|50
argument_list|)
argument_list|)
decl_stmt|;
name|FreeTextSuggester
name|sug
init|=
operator|new
name|FreeTextSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
literal|3
argument_list|,
operator|(
name|byte
operator|)
literal|0x20
argument_list|)
decl_stmt|;
name|sug
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"wizard _ oz/1.00"
argument_list|,
name|toString
argument_list|(
name|sug
operator|.
name|lookup
argument_list|(
literal|"wizard of"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Falls back to unigram model, with backoff 0.4 times
comment|// prop 0.5:
name|assertEquals
argument_list|(
literal|"oz/0.20"
argument_list|,
name|toString
argument_list|(
name|sug
operator|.
name|lookup
argument_list|(
literal|"wizard o"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If the number of ending holes exceeds the ngrams window
comment|// then there are no predictions, because ShingleFilter
comment|// does not produce e.g. a hole only "_ _" token:
DECL|method|testTwoEndingHoles
specifier|public
name|void
name|testTwoEndingHoles
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Just deletes "of"
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|field
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|()
decl_stmt|;
name|CharArraySet
name|stopSet
init|=
name|StopFilter
operator|.
name|makeStopSet
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
literal|"of"
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
operator|new
name|StopFilter
argument_list|(
name|TEST_VERSION_CURRENT
argument_list|,
name|tokenizer
argument_list|,
name|stopSet
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|Iterable
argument_list|<
name|Input
argument_list|>
name|keys
init|=
name|shuffle
argument_list|(
operator|new
name|Input
argument_list|(
literal|"wizard of of oz"
argument_list|,
literal|50
argument_list|)
argument_list|)
decl_stmt|;
name|FreeTextSuggester
name|sug
init|=
operator|new
name|FreeTextSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
literal|3
argument_list|,
operator|(
name|byte
operator|)
literal|0x20
argument_list|)
decl_stmt|;
name|sug
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|toString
argument_list|(
name|sug
operator|.
name|lookup
argument_list|(
literal|"wizard of of"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|field|byScoreThenKey
specifier|private
specifier|static
name|Comparator
argument_list|<
name|LookupResult
argument_list|>
name|byScoreThenKey
init|=
operator|new
name|Comparator
argument_list|<
name|LookupResult
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|LookupResult
name|a
parameter_list|,
name|LookupResult
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|value
operator|>
name|b
operator|.
name|value
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|.
name|value
operator|<
name|b
operator|.
name|value
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
comment|// Tie break by UTF16 sort order:
return|return
operator|(
operator|(
name|String
operator|)
name|a
operator|.
name|key
operator|)
operator|.
name|compareTo
argument_list|(
operator|(
name|String
operator|)
name|b
operator|.
name|key
argument_list|)
return|;
block|}
block|}
block|}
decl_stmt|;
DECL|method|testRandom
specifier|public
name|void
name|testRandom
parameter_list|()
throws|throws
name|IOException
block|{
name|String
index|[]
name|terms
init|=
operator|new
name|String
index|[
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|)
index|]
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|seen
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|seen
operator|.
name|size
argument_list|()
operator|<
name|terms
operator|.
name|length
condition|)
block|{
name|String
name|token
init|=
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|seen
operator|.
name|contains
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|terms
index|[
name|seen
operator|.
name|size
argument_list|()
index|]
operator|=
name|token
expr_stmt|;
name|seen
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
name|Analyzer
name|a
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|numDocs
init|=
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|long
name|totTokens
init|=
literal|0
decl_stmt|;
specifier|final
name|String
index|[]
index|[]
name|docs
init|=
operator|new
name|String
index|[
name|numDocs
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numDocs
condition|;
name|i
operator|++
control|)
block|{
name|docs
index|[
name|i
index|]
operator|=
operator|new
name|String
index|[
name|atLeast
argument_list|(
literal|100
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"  doc "
operator|+
name|i
operator|+
literal|":"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|docs
index|[
name|i
index|]
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|docs
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|getZipfToken
argument_list|(
name|terms
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|" "
operator|+
name|docs
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
name|totTokens
operator|+=
name|docs
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
block|}
name|int
name|grams
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: "
operator|+
name|terms
operator|.
name|length
operator|+
literal|" terms; "
operator|+
name|numDocs
operator|+
literal|" docs; "
operator|+
name|grams
operator|+
literal|" grams"
argument_list|)
expr_stmt|;
block|}
comment|// Build suggester model:
name|FreeTextSuggester
name|sug
init|=
operator|new
name|FreeTextSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|grams
argument_list|,
operator|(
name|byte
operator|)
literal|0x20
argument_list|)
decl_stmt|;
name|sug
operator|.
name|build
argument_list|(
operator|new
name|InputIterator
argument_list|()
block|{
name|int
name|upto
decl_stmt|;
annotation|@
name|Override
specifier|public
name|BytesRef
name|next
parameter_list|()
block|{
if|if
condition|(
name|upto
operator|==
name|docs
operator|.
name|length
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|token
range|:
name|docs
index|[
name|upto
index|]
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
name|upto
operator|++
expr_stmt|;
return|return
operator|new
name|BytesRef
argument_list|(
name|b
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|weight
parameter_list|()
block|{
return|return
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|BytesRef
name|payload
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasPayloads
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|BytesRef
argument_list|>
name|contexts
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasContexts
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Build inefficient but hopefully correct model:
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|gramCounts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|grams
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|gram
init|=
literal|0
init|;
name|gram
operator|<
name|grams
condition|;
name|gram
operator|++
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: build model for gram="
operator|+
name|gram
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|model
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|gramCounts
operator|.
name|add
argument_list|(
name|model
argument_list|)
expr_stmt|;
for|for
control|(
name|String
index|[]
name|doc
range|:
name|docs
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|doc
operator|.
name|length
operator|-
name|gram
condition|;
name|i
operator|++
control|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<=
name|i
operator|+
name|gram
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>
name|i
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
name|doc
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|String
name|token
init|=
name|b
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Integer
name|curCount
init|=
name|model
operator|.
name|get
argument_list|(
name|token
argument_list|)
decl_stmt|;
if|if
condition|(
name|curCount
operator|==
literal|null
condition|)
block|{
name|model
operator|.
name|put
argument_list|(
name|token
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|model
operator|.
name|put
argument_list|(
name|token
argument_list|,
literal|1
operator|+
name|curCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  add '"
operator|+
name|token
operator|+
literal|"' -> count="
operator|+
name|model
operator|.
name|get
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|int
name|lookups
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|lookups
condition|;
name|iter
operator|++
control|)
block|{
name|String
index|[]
name|tokens
init|=
operator|new
name|String
index|[
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|)
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tokens
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|tokens
index|[
name|i
index|]
operator|=
name|getZipfToken
argument_list|(
name|terms
argument_list|)
expr_stmt|;
block|}
comment|// Maybe trim last token; be sure not to create the
comment|// empty string:
name|int
name|trimStart
decl_stmt|;
if|if
condition|(
name|tokens
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|trimStart
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|trimStart
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|trimAt
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
name|trimStart
argument_list|,
name|tokens
index|[
name|tokens
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|tokens
index|[
name|tokens
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|tokens
index|[
name|tokens
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|trimAt
argument_list|)
expr_stmt|;
name|int
name|num
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|token
range|:
name|tokens
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
name|String
name|query
init|=
name|b
operator|.
name|toString
argument_list|()
decl_stmt|;
name|query
operator|=
name|query
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nTEST: iter="
operator|+
name|iter
operator|+
literal|" query='"
operator|+
name|query
operator|+
literal|"' num="
operator|+
name|num
argument_list|)
expr_stmt|;
block|}
comment|// Expected:
name|List
argument_list|<
name|LookupResult
argument_list|>
name|expected
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|double
name|backoff
init|=
literal|1.0
decl_stmt|;
name|seen
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  compute expected"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|grams
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    grams="
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tokens
operator|.
name|length
operator|<
name|i
operator|+
literal|1
condition|)
block|{
comment|// Don't have enough tokens to use this model
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      skip"
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|tokens
index|[
name|tokens
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Never suggest unigrams from empty string:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      skip unigram priors only"
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|// Build up "context" ngram:
name|b
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
name|tokens
operator|.
name|length
operator|-
name|i
operator|-
literal|1
init|;
name|j
operator|<
name|tokens
operator|.
name|length
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|tokens
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|String
name|context
init|=
name|b
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|context
operator|=
name|context
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      context='"
operator|+
name|context
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
name|long
name|contextCount
decl_stmt|;
if|if
condition|(
name|context
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|contextCount
operator|=
name|totTokens
expr_stmt|;
block|}
else|else
block|{
name|Integer
name|count
init|=
name|gramCounts
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|get
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|null
condition|)
block|{
comment|// We never saw this context:
name|backoff
operator|*=
name|FreeTextSuggester
operator|.
name|ALPHA
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      skip: never saw context"
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|contextCount
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      contextCount="
operator|+
name|contextCount
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|model
init|=
name|gramCounts
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// First pass, gather all predictions for this model:
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      find terms w/ prefix="
operator|+
name|tokens
index|[
name|tokens
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|LookupResult
argument_list|>
name|tmp
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|term
range|:
name|terms
control|)
block|{
if|if
condition|(
name|term
operator|.
name|startsWith
argument_list|(
name|tokens
index|[
name|tokens
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"        term="
operator|+
name|term
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seen
operator|.
name|contains
argument_list|(
name|term
argument_list|)
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"          skip seen"
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|String
name|ngram
init|=
operator|(
name|context
operator|+
literal|" "
operator|+
name|term
operator|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|Integer
name|count
init|=
name|model
operator|.
name|get
argument_list|(
name|ngram
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|!=
literal|null
condition|)
block|{
name|LookupResult
name|lr
init|=
operator|new
name|LookupResult
argument_list|(
name|ngram
argument_list|,
call|(
name|long
call|)
argument_list|(
name|Long
operator|.
name|MAX_VALUE
operator|*
operator|(
name|backoff
operator|*
operator|(
name|double
operator|)
name|count
operator|/
name|contextCount
operator|)
argument_list|)
argument_list|)
decl_stmt|;
name|tmp
operator|.
name|add
argument_list|(
name|lr
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      add tmp key='"
operator|+
name|lr
operator|.
name|key
operator|+
literal|"' score="
operator|+
name|lr
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Second pass, trim to only top N, and fold those
comment|// into overall suggestions:
name|Collections
operator|.
name|sort
argument_list|(
name|tmp
argument_list|,
name|byScoreThenKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|size
argument_list|()
operator|>
name|num
condition|)
block|{
name|tmp
operator|.
name|subList
argument_list|(
name|num
argument_list|,
name|tmp
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|LookupResult
name|result
range|:
name|tmp
control|)
block|{
name|String
name|key
init|=
name|result
operator|.
name|key
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
name|key
operator|.
name|lastIndexOf
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|String
name|lastToken
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|lastToken
operator|=
name|key
operator|.
name|substring
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lastToken
operator|=
name|key
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|seen
operator|.
name|contains
argument_list|(
name|lastToken
argument_list|)
condition|)
block|{
name|seen
operator|.
name|add
argument_list|(
name|lastToken
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      keep key='"
operator|+
name|result
operator|.
name|key
operator|+
literal|"' score="
operator|+
name|result
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|backoff
operator|*=
name|FreeTextSuggester
operator|.
name|ALPHA
expr_stmt|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|expected
argument_list|,
name|byScoreThenKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|expected
operator|.
name|size
argument_list|()
operator|>
name|num
condition|)
block|{
name|expected
operator|.
name|subList
argument_list|(
name|num
argument_list|,
name|expected
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// Actual:
name|List
argument_list|<
name|LookupResult
argument_list|>
name|actual
init|=
name|sug
operator|.
name|lookup
argument_list|(
name|query
argument_list|,
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  expected: "
operator|+
name|expected
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    actual: "
operator|+
name|actual
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expected
operator|.
name|toString
argument_list|()
argument_list|,
name|actual
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getZipfToken
specifier|private
specifier|static
name|String
name|getZipfToken
parameter_list|(
name|String
index|[]
name|tokens
parameter_list|)
block|{
comment|// Zipf-like distribution:
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|tokens
operator|.
name|length
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
operator|||
name|k
operator|==
name|tokens
operator|.
name|length
operator|-
literal|1
condition|)
block|{
return|return
name|tokens
index|[
name|k
index|]
return|;
block|}
block|}
assert|assert
literal|false
assert|;
return|return
literal|null
return|;
block|}
DECL|method|toString
specifier|private
specifier|static
name|String
name|toString
parameter_list|(
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
parameter_list|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|LookupResult
name|result
range|:
name|results
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|result
operator|.
name|key
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%.2f"
argument_list|,
operator|(
operator|(
name|double
operator|)
name|result
operator|.
name|value
operator|)
operator|/
name|Long
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
return|;
block|}
annotation|@
name|SafeVarargs
DECL|method|shuffle
specifier|private
specifier|final
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|shuffle
parameter_list|(
name|T
modifier|...
name|values
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|asList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|values
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|T
name|value
range|:
name|values
control|)
block|{
name|asList
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|shuffle
argument_list|(
name|asList
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|asList
return|;
block|}
block|}
end_class
end_unit
