begin_unit
begin_package
DECL|package|org.apache.lucene.search.suggest.analyzing
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|analyzing
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|CannedTokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockAnalyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockTokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockTokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Token
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStreamToAutomaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Tokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|CharTermAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|PositionIncrementAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|Lookup
operator|.
name|LookupResult
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|TermFreq
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|TermFreqArrayIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|_TestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|Automaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|State
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Util
import|;
end_import
begin_class
DECL|class|FuzzySuggesterTest
specifier|public
class|class
name|FuzzySuggesterTest
extends|extends
name|LuceneTestCase
block|{
DECL|method|testRandomEdits
specifier|public
name|void
name|testRandomEdits
parameter_list|()
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|TermFreq
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<
name|TermFreq
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numTerms
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTerms
condition|;
name|i
operator|++
control|)
block|{
name|keys
operator|.
name|add
argument_list|(
operator|new
name|TermFreq
argument_list|(
literal|"boo"
operator|+
name|_TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|,
literal|1
operator|+
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|100
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|keys
operator|.
name|add
argument_list|(
operator|new
name|TermFreq
argument_list|(
literal|"foo bar boo far"
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|FuzzySuggester
name|suggester
init|=
operator|new
name|FuzzySuggester
argument_list|(
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|KEYWORD
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|TermFreqArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|numIters
init|=
name|atLeast
argument_list|(
literal|10
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIters
condition|;
name|i
operator|++
control|)
block|{
name|String
name|addRandomEdit
init|=
name|addRandomEdit
argument_list|(
literal|"foo bar boo"
argument_list|,
name|FuzzySuggester
operator|.
name|DEFAULT_NON_FUZZY_PREFIX
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
name|_TestUtil
operator|.
name|stringToCharSequence
argument_list|(
name|addRandomEdit
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|addRandomEdit
argument_list|,
literal|1
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"foo bar boo far"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|12
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** this is basically the WFST test ported to KeywordAnalyzer. so it acts the same */
DECL|method|testKeyword
specifier|public
name|void
name|testKeyword
parameter_list|()
throws|throws
name|Exception
block|{
name|TermFreq
name|keys
index|[]
init|=
operator|new
name|TermFreq
index|[]
block|{
operator|new
name|TermFreq
argument_list|(
literal|"foo"
argument_list|,
literal|50
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|"bar"
argument_list|,
literal|10
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|"barbar"
argument_list|,
literal|12
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|"barbara"
argument_list|,
literal|6
argument_list|)
block|}
decl_stmt|;
name|FuzzySuggester
name|suggester
init|=
operator|new
name|FuzzySuggester
argument_list|(
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|KEYWORD
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|TermFreqArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
name|_TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"bariar"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"barbar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|12
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|_TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"barbr"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"barbar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|12
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|_TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"barbara"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"barbara"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|_TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"barbar"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"barbar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|12
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"barbara"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|_TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"barbaa"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"barbar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|12
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"barbara"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
comment|// top N of 2, but only foo is available
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|_TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"f"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"foo"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
comment|// top N of 1 for 'bar': we return this even though
comment|// barbar is higher because exactFirst is enabled:
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|_TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"bar"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"bar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
comment|// top N Of 2 for 'b'
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|_TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"b"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"barbar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|12
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"bar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
comment|// top N of 3 for 'ba'
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|_TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"ba"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"barbar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|12
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"bar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"barbara"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
block|}
comment|/**    * basic "standardanalyzer" test with stopword removal    */
DECL|method|testStandard
specifier|public
name|void
name|testStandard
parameter_list|()
throws|throws
name|Exception
block|{
name|TermFreq
name|keys
index|[]
init|=
operator|new
name|TermFreq
index|[]
block|{
operator|new
name|TermFreq
argument_list|(
literal|"the ghost of christmas past"
argument_list|,
literal|50
argument_list|)
block|,     }
decl_stmt|;
name|Analyzer
name|standard
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|true
argument_list|,
name|MockTokenFilter
operator|.
name|ENGLISH_STOPSET
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|FuzzySuggester
name|suggester
init|=
operator|new
name|FuzzySuggester
argument_list|(
name|standard
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|TermFreqArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
name|_TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"the ghost of chris"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"the ghost of christmas past"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
comment|// omit the 'the' since its a stopword, its suggested anyway
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|_TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"ghost of chris"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"the ghost of christmas past"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
comment|// omit the 'the' and 'of' since they are stopwords, its suggested anyway
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|_TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"ghost chris"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"the ghost of christmas past"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
block|}
DECL|method|testNoSeps
specifier|public
name|void
name|testNoSeps
parameter_list|()
throws|throws
name|Exception
block|{
name|TermFreq
index|[]
name|keys
init|=
operator|new
name|TermFreq
index|[]
block|{
operator|new
name|TermFreq
argument_list|(
literal|"ab cd"
argument_list|,
literal|0
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|"abcd"
argument_list|,
literal|1
argument_list|)
block|,     }
decl_stmt|;
name|int
name|options
init|=
literal|0
decl_stmt|;
name|Analyzer
name|a
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|FuzzySuggester
name|suggester
init|=
operator|new
name|FuzzySuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|options
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|TermFreqArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
comment|// TODO: would be nice if "ab " would allow the test to
comment|// pass, and more generally if the analyzer can know
comment|// that the user's current query has ended at a word,
comment|// but, analyzers don't produce SEP tokens!
name|List
argument_list|<
name|LookupResult
argument_list|>
name|r
init|=
name|suggester
operator|.
name|lookup
argument_list|(
name|_TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"ab c"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|r
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// With no PRESERVE_SEPS specified, "ab c" should also
comment|// complete to "abcd", which has higher weight so should
comment|// appear first:
name|assertEquals
argument_list|(
literal|"abcd"
argument_list|,
name|r
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testGraphDups
specifier|public
name|void
name|testGraphDups
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Analyzer
name|analyzer
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|SIMPLE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|)
block|{
name|int
name|tokenStreamCounter
init|=
literal|0
decl_stmt|;
specifier|final
name|TokenStream
index|[]
name|tokenStreams
init|=
operator|new
name|TokenStream
index|[]
block|{
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"wifi"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"hotspot"
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
block|,
name|token
argument_list|(
literal|"network"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"is"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"slow"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|}
argument_list|)
block|,
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"wi"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"hotspot"
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
block|,
name|token
argument_list|(
literal|"fi"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"network"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"is"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"fast"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|}
argument_list|)
block|,
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"wifi"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"hotspot"
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
block|,
name|token
argument_list|(
literal|"network"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|}
argument_list|)
block|,           }
decl_stmt|;
annotation|@
name|Override
specifier|public
name|TokenStream
name|getTokenStream
parameter_list|()
block|{
name|TokenStream
name|result
init|=
name|tokenStreams
index|[
name|tokenStreamCounter
index|]
decl_stmt|;
name|tokenStreamCounter
operator|++
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setReader
parameter_list|(
specifier|final
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{           }
block|}
return|;
block|}
block|}
decl_stmt|;
name|TermFreq
name|keys
index|[]
init|=
operator|new
name|TermFreq
index|[]
block|{
operator|new
name|TermFreq
argument_list|(
literal|"wifi network is slow"
argument_list|,
literal|50
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|"wi fi network is fast"
argument_list|,
literal|10
argument_list|)
block|,     }
decl_stmt|;
name|FuzzySuggester
name|suggester
init|=
operator|new
name|FuzzySuggester
argument_list|(
name|analyzer
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|TermFreqArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"wifi network"
argument_list|,
literal|false
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Results: "
operator|+
name|results
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"wifi network is slow"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"wi fi network is fast"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
DECL|method|testEmpty
specifier|public
name|void
name|testEmpty
parameter_list|()
throws|throws
name|Exception
block|{
name|FuzzySuggester
name|suggester
init|=
operator|new
name|FuzzySuggester
argument_list|(
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|KEYWORD
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|TermFreqArrayIterator
argument_list|(
operator|new
name|TermFreq
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|result
init|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"a"
argument_list|,
literal|false
argument_list|,
literal|20
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testInputPathRequired
specifier|public
name|void
name|testInputPathRequired
parameter_list|()
throws|throws
name|Exception
block|{
comment|//  SynonymMap.Builder b = new SynonymMap.Builder(false);
comment|//  b.add(new CharsRef("ab"), new CharsRef("ba"), true);
comment|//  final SynonymMap map = b.build();
comment|//  The Analyzer below mimics the functionality of the SynonymAnalyzer
comment|//  using the above map, so that the suggest module does not need a dependency on the
comment|//  synonym module
specifier|final
name|Analyzer
name|analyzer
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|SIMPLE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|)
block|{
name|int
name|tokenStreamCounter
init|=
literal|0
decl_stmt|;
specifier|final
name|TokenStream
index|[]
name|tokenStreams
init|=
operator|new
name|TokenStream
index|[]
block|{
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"ab"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"ba"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"xc"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|}
argument_list|)
block|,
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"ba"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"xd"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|}
argument_list|)
block|,
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"ab"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"ba"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"x"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|}
argument_list|)
block|}
decl_stmt|;
annotation|@
name|Override
specifier|public
name|TokenStream
name|getTokenStream
parameter_list|()
block|{
name|TokenStream
name|result
init|=
name|tokenStreams
index|[
name|tokenStreamCounter
index|]
decl_stmt|;
name|tokenStreamCounter
operator|++
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setReader
parameter_list|(
specifier|final
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{           }
block|}
return|;
block|}
block|}
decl_stmt|;
name|TermFreq
name|keys
index|[]
init|=
operator|new
name|TermFreq
index|[]
block|{
operator|new
name|TermFreq
argument_list|(
literal|"ab xc"
argument_list|,
literal|50
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|"ba xd"
argument_list|,
literal|50
argument_list|)
block|,     }
decl_stmt|;
name|FuzzySuggester
name|suggester
init|=
operator|new
name|FuzzySuggester
argument_list|(
name|analyzer
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|TermFreqArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"ab x"
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|results
operator|.
name|size
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|token
specifier|private
specifier|static
name|Token
name|token
parameter_list|(
name|String
name|term
parameter_list|,
name|int
name|posInc
parameter_list|,
name|int
name|posLength
parameter_list|)
block|{
specifier|final
name|Token
name|t
init|=
operator|new
name|Token
argument_list|(
name|term
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|t
operator|.
name|setPositionIncrement
argument_list|(
name|posInc
argument_list|)
expr_stmt|;
name|t
operator|.
name|setPositionLength
argument_list|(
name|posLength
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/*   private void printTokens(final Analyzer analyzer, String input) throws IOException {     System.out.println("Tokens for " + input);     TokenStream ts = analyzer.tokenStream("", new StringReader(input));     ts.reset();     final TermToBytesRefAttribute termBytesAtt = ts.addAttribute(TermToBytesRefAttribute.class);     final PositionIncrementAttribute posIncAtt = ts.addAttribute(PositionIncrementAttribute.class);     final PositionLengthAttribute posLengthAtt = ts.addAttribute(PositionLengthAttribute.class);          while(ts.incrementToken()) {       termBytesAtt.fillBytesRef();       System.out.println(String.format("%s,%s,%s", termBytesAtt.getBytesRef().utf8ToString(), posIncAtt.getPositionIncrement(), posLengthAtt.getPositionLength()));           }     ts.end();     ts.close();   }    */
DECL|method|getUnusualAnalyzer
specifier|private
specifier|final
name|Analyzer
name|getUnusualAnalyzer
parameter_list|()
block|{
return|return
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|SIMPLE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|)
block|{
name|int
name|count
decl_stmt|;
annotation|@
name|Override
specifier|public
name|TokenStream
name|getTokenStream
parameter_list|()
block|{
comment|// 4th time we are called, return tokens a b,
comment|// else just a:
if|if
condition|(
name|count
operator|++
operator|!=
literal|3
condition|)
block|{
return|return
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,                 }
argument_list|)
return|;
block|}
else|else
block|{
comment|// After that "a b":
return|return
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"b"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,                 }
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setReader
parameter_list|(
specifier|final
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{           }
block|}
return|;
block|}
block|}
return|;
block|}
DECL|method|testExactFirst
specifier|public
name|void
name|testExactFirst
parameter_list|()
throws|throws
name|Exception
block|{
name|Analyzer
name|a
init|=
name|getUnusualAnalyzer
argument_list|()
decl_stmt|;
name|FuzzySuggester
name|suggester
init|=
operator|new
name|FuzzySuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|AnalyzingSuggester
operator|.
name|EXACT_FIRST
operator||
name|AnalyzingSuggester
operator|.
name|PRESERVE_SEP
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|TermFreqArrayIterator
argument_list|(
operator|new
name|TermFreq
index|[]
block|{
operator|new
name|TermFreq
argument_list|(
literal|"x y"
argument_list|,
literal|1
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|"x y z"
argument_list|,
literal|3
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|"x"
argument_list|,
literal|2
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|"z z z"
argument_list|,
literal|20
argument_list|)
block|,         }
argument_list|)
argument_list|)
expr_stmt|;
comment|//System.out.println("ALL: " + suggester.lookup("x y", false, 6));
for|for
control|(
name|int
name|topN
init|=
literal|1
init|;
name|topN
operator|<
literal|6
condition|;
name|topN
operator|++
control|)
block|{
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"x y"
argument_list|,
literal|false
argument_list|,
name|topN
argument_list|)
decl_stmt|;
comment|//System.out.println("topN=" + topN + " " + results);
name|assertEquals
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|topN
argument_list|,
literal|4
argument_list|)
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"x y"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|topN
operator|>
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
literal|"z z z"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|20
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|topN
operator|>
literal|2
condition|)
block|{
name|assertEquals
argument_list|(
literal|"x y z"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|topN
operator|>
literal|3
condition|)
block|{
name|assertEquals
argument_list|(
literal|"x"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|testNonExactFirst
specifier|public
name|void
name|testNonExactFirst
parameter_list|()
throws|throws
name|Exception
block|{
name|Analyzer
name|a
init|=
name|getUnusualAnalyzer
argument_list|()
decl_stmt|;
name|FuzzySuggester
name|suggester
init|=
operator|new
name|FuzzySuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|AnalyzingSuggester
operator|.
name|PRESERVE_SEP
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|TermFreqArrayIterator
argument_list|(
operator|new
name|TermFreq
index|[]
block|{
operator|new
name|TermFreq
argument_list|(
literal|"x y"
argument_list|,
literal|1
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|"x y z"
argument_list|,
literal|3
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|"x"
argument_list|,
literal|2
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|"z z z"
argument_list|,
literal|20
argument_list|)
block|,         }
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|topN
init|=
literal|1
init|;
name|topN
operator|<
literal|6
condition|;
name|topN
operator|++
control|)
block|{
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"p"
argument_list|,
literal|false
argument_list|,
name|topN
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|topN
argument_list|,
literal|4
argument_list|)
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"z z z"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|20
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|topN
operator|>
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
literal|"x y z"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|topN
operator|>
literal|2
condition|)
block|{
name|assertEquals
argument_list|(
literal|"x"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|topN
operator|>
literal|3
condition|)
block|{
name|assertEquals
argument_list|(
literal|"x y"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// Holds surface form separately:
DECL|class|TermFreq2
specifier|private
specifier|static
class|class
name|TermFreq2
implements|implements
name|Comparable
argument_list|<
name|TermFreq2
argument_list|>
block|{
DECL|field|surfaceForm
specifier|public
specifier|final
name|String
name|surfaceForm
decl_stmt|;
DECL|field|analyzedForm
specifier|public
specifier|final
name|String
name|analyzedForm
decl_stmt|;
DECL|field|weight
specifier|public
specifier|final
name|long
name|weight
decl_stmt|;
DECL|method|TermFreq2
specifier|public
name|TermFreq2
parameter_list|(
name|String
name|surfaceForm
parameter_list|,
name|String
name|analyzedForm
parameter_list|,
name|long
name|weight
parameter_list|)
block|{
name|this
operator|.
name|surfaceForm
operator|=
name|surfaceForm
expr_stmt|;
name|this
operator|.
name|analyzedForm
operator|=
name|analyzedForm
expr_stmt|;
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|TermFreq2
name|other
parameter_list|)
block|{
name|int
name|cmp
init|=
name|analyzedForm
operator|.
name|compareTo
argument_list|(
name|other
operator|.
name|analyzedForm
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
elseif|else
if|if
condition|(
name|weight
operator|>
name|other
operator|.
name|weight
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|weight
operator|<
name|other
operator|.
name|weight
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
assert|assert
literal|false
assert|;
return|return
literal|0
return|;
block|}
block|}
block|}
DECL|method|isStopChar
specifier|static
name|boolean
name|isStopChar
parameter_list|(
name|char
name|ch
parameter_list|,
name|int
name|numStopChars
parameter_list|)
block|{
comment|//System.out.println("IS? " + ch + ": " + (ch - 'a') + ": " + ((ch - 'a')< numStopChars));
return|return
operator|(
name|ch
operator|-
literal|'a'
operator|)
operator|<
name|numStopChars
return|;
block|}
comment|// Like StopFilter:
DECL|class|TokenEater
specifier|private
specifier|static
class|class
name|TokenEater
extends|extends
name|TokenFilter
block|{
DECL|field|posIncrAtt
specifier|private
specifier|final
name|PositionIncrementAttribute
name|posIncrAtt
init|=
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|termAtt
specifier|private
specifier|final
name|CharTermAttribute
name|termAtt
init|=
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|numStopChars
specifier|private
specifier|final
name|int
name|numStopChars
decl_stmt|;
DECL|field|preserveHoles
specifier|private
specifier|final
name|boolean
name|preserveHoles
decl_stmt|;
DECL|field|first
specifier|private
name|boolean
name|first
decl_stmt|;
DECL|method|TokenEater
specifier|public
name|TokenEater
parameter_list|(
name|boolean
name|preserveHoles
parameter_list|,
name|TokenStream
name|in
parameter_list|,
name|int
name|numStopChars
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|preserveHoles
operator|=
name|preserveHoles
expr_stmt|;
name|this
operator|.
name|numStopChars
operator|=
name|numStopChars
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|reset
argument_list|()
expr_stmt|;
name|first
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|incrementToken
specifier|public
specifier|final
name|boolean
name|incrementToken
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|skippedPositions
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|input
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
if|if
condition|(
name|termAtt
operator|.
name|length
argument_list|()
operator|!=
literal|1
operator|||
operator|!
name|isStopChar
argument_list|(
name|termAtt
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|numStopChars
argument_list|)
condition|)
block|{
name|int
name|posInc
init|=
name|posIncrAtt
operator|.
name|getPositionIncrement
argument_list|()
operator|+
name|skippedPositions
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|posInc
operator|==
literal|0
condition|)
block|{
comment|// first token having posinc=0 is illegal.
name|posInc
operator|=
literal|1
expr_stmt|;
block|}
name|first
operator|=
literal|false
expr_stmt|;
block|}
name|posIncrAtt
operator|.
name|setPositionIncrement
argument_list|(
name|posInc
argument_list|)
expr_stmt|;
comment|//System.out.println("RETURN term=" + termAtt + " numStopChars=" + numStopChars);
return|return
literal|true
return|;
block|}
if|if
condition|(
name|preserveHoles
condition|)
block|{
name|skippedPositions
operator|+=
name|posIncrAtt
operator|.
name|getPositionIncrement
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
DECL|class|MockTokenEatingAnalyzer
specifier|private
specifier|static
class|class
name|MockTokenEatingAnalyzer
extends|extends
name|Analyzer
block|{
DECL|field|numStopChars
specifier|private
name|int
name|numStopChars
decl_stmt|;
DECL|field|preserveHoles
specifier|private
name|boolean
name|preserveHoles
decl_stmt|;
DECL|method|MockTokenEatingAnalyzer
specifier|public
name|MockTokenEatingAnalyzer
parameter_list|(
name|int
name|numStopChars
parameter_list|,
name|boolean
name|preserveHoles
parameter_list|)
block|{
name|this
operator|.
name|preserveHoles
operator|=
name|preserveHoles
expr_stmt|;
name|this
operator|.
name|numStopChars
operator|=
name|numStopChars
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createComponents
specifier|public
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Reader
name|reader
parameter_list|)
block|{
name|MockTokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|reader
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|,
name|MockTokenizer
operator|.
name|DEFAULT_MAX_TOKEN_LENGTH
argument_list|)
decl_stmt|;
name|tokenizer
operator|.
name|setEnableChecks
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|TokenStream
name|next
decl_stmt|;
if|if
condition|(
name|numStopChars
operator|!=
literal|0
condition|)
block|{
name|next
operator|=
operator|new
name|TokenEater
argument_list|(
name|preserveHoles
argument_list|,
name|tokenizer
argument_list|,
name|numStopChars
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|tokenizer
expr_stmt|;
block|}
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
DECL|method|testRandom
specifier|public
name|void
name|testRandom
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|numQueries
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|TermFreq2
argument_list|>
name|slowCompletor
init|=
operator|new
name|ArrayList
argument_list|<
name|TermFreq2
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|TreeSet
argument_list|<
name|String
argument_list|>
name|allPrefixes
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|seen
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|TermFreq
index|[]
name|keys
init|=
operator|new
name|TermFreq
index|[
name|numQueries
index|]
decl_stmt|;
name|boolean
name|preserveSep
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numStopChars
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|preserveHoles
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: "
operator|+
name|numQueries
operator|+
literal|" words; preserveSep="
operator|+
name|preserveSep
operator|+
literal|" numStopChars="
operator|+
name|numStopChars
operator|+
literal|" preserveHoles="
operator|+
name|preserveHoles
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numQueries
condition|;
name|i
operator|++
control|)
block|{
name|int
name|numTokens
init|=
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|String
name|key
decl_stmt|;
name|String
name|analyzedKey
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|key
operator|=
literal|""
expr_stmt|;
name|analyzedKey
operator|=
literal|""
expr_stmt|;
name|boolean
name|lastRemoved
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|token
init|=
literal|0
init|;
name|token
operator|<
name|numTokens
condition|;
name|token
operator|++
control|)
block|{
name|String
name|s
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// TODO: would be nice to fix this slowCompletor/comparator to
comment|// use full range, but we might lose some coverage too...
name|s
operator|=
name|_TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|token
operator|>
literal|0
condition|)
block|{
name|key
operator|+=
literal|" "
expr_stmt|;
block|}
if|if
condition|(
name|preserveSep
operator|&&
name|analyzedKey
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|analyzedKey
operator|.
name|charAt
argument_list|(
name|analyzedKey
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|!=
literal|' '
condition|)
block|{
name|analyzedKey
operator|+=
literal|" "
expr_stmt|;
block|}
name|key
operator|+=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|&&
name|isStopChar
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|numStopChars
argument_list|)
condition|)
block|{
if|if
condition|(
name|preserveSep
operator|&&
name|preserveHoles
condition|)
block|{
name|analyzedKey
operator|+=
literal|'\u0000'
expr_stmt|;
block|}
name|lastRemoved
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|analyzedKey
operator|+=
name|s
expr_stmt|;
name|lastRemoved
operator|=
literal|false
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
name|analyzedKey
operator|=
name|analyzedKey
operator|.
name|replaceAll
argument_list|(
literal|"(^| )\u0000$"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|preserveSep
operator|&&
name|lastRemoved
condition|)
block|{
name|analyzedKey
operator|+=
literal|" "
expr_stmt|;
block|}
comment|// Don't add same surface form more than once:
if|if
condition|(
operator|!
name|seen
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|seen
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|key
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|allPrefixes
operator|.
name|add
argument_list|(
name|key
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// we can probably do Integer.MAX_VALUE here, but why worry.
name|int
name|weight
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|1
operator|<<
literal|24
argument_list|)
decl_stmt|;
name|keys
index|[
name|i
index|]
operator|=
operator|new
name|TermFreq
argument_list|(
name|key
argument_list|,
name|weight
argument_list|)
expr_stmt|;
name|slowCompletor
operator|.
name|add
argument_list|(
operator|new
name|TermFreq2
argument_list|(
name|key
argument_list|,
name|analyzedKey
argument_list|,
name|weight
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
comment|// Don't just sort original list, to avoid VERBOSE
comment|// altering the test:
name|List
argument_list|<
name|TermFreq2
argument_list|>
name|sorted
init|=
operator|new
name|ArrayList
argument_list|<
name|TermFreq2
argument_list|>
argument_list|(
name|slowCompletor
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
for|for
control|(
name|TermFreq2
name|ent
range|:
name|sorted
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  surface='"
operator|+
name|ent
operator|.
name|surfaceForm
operator|+
literal|" analyzed='"
operator|+
name|ent
operator|.
name|analyzedForm
operator|+
literal|"' weight="
operator|+
name|ent
operator|.
name|weight
argument_list|)
expr_stmt|;
block|}
block|}
name|Analyzer
name|a
init|=
operator|new
name|MockTokenEatingAnalyzer
argument_list|(
name|numStopChars
argument_list|,
name|preserveHoles
argument_list|)
decl_stmt|;
name|FuzzySuggester
name|suggester
init|=
operator|new
name|FuzzySuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|preserveSep
condition|?
name|AnalyzingSuggester
operator|.
name|PRESERVE_SEP
else|:
literal|0
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|TermFreqArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|prefix
range|:
name|allPrefixes
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nTEST: prefix="
operator|+
name|prefix
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|topN
init|=
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|r
init|=
name|suggester
operator|.
name|lookup
argument_list|(
name|_TestUtil
operator|.
name|stringToCharSequence
argument_list|(
name|prefix
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
name|topN
argument_list|)
decl_stmt|;
comment|// 2. go thru whole set to find suggestions:
name|List
argument_list|<
name|LookupResult
argument_list|>
name|matches
init|=
operator|new
name|ArrayList
argument_list|<
name|LookupResult
argument_list|>
argument_list|()
decl_stmt|;
comment|// "Analyze" the key:
name|String
index|[]
name|tokens
init|=
name|prefix
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|lastRemoved
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tokens
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|token
init|=
name|tokens
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|preserveSep
operator|&&
name|builder
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|builder
operator|.
name|toString
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|" "
argument_list|)
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|&&
name|isStopChar
argument_list|(
name|token
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|numStopChars
argument_list|)
condition|)
block|{
if|if
condition|(
name|preserveSep
operator|&&
name|preserveHoles
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"\u0000"
argument_list|)
expr_stmt|;
block|}
name|lastRemoved
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|.
name|append
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|lastRemoved
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|String
name|analyzedKey
init|=
name|builder
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|// Remove trailing sep/holes (TokenStream.end() does
comment|// not tell us any trailing holes, yet ... there is an
comment|// issue open for this):
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|s
init|=
name|analyzedKey
operator|.
name|replaceAll
argument_list|(
literal|"(^| )\u0000$"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|s
operator|=
name|s
operator|.
name|replaceAll
argument_list|(
literal|"\\s+$"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
name|analyzedKey
argument_list|)
condition|)
block|{
break|break;
block|}
name|analyzedKey
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|analyzedKey
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Currently suggester can't suggest from the empty
comment|// string!  You get no results, not all results...
continue|continue;
block|}
if|if
condition|(
name|preserveSep
operator|&&
operator|(
name|prefix
operator|.
name|endsWith
argument_list|(
literal|" "
argument_list|)
operator|||
name|lastRemoved
operator|)
condition|)
block|{
name|analyzedKey
operator|+=
literal|" "
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  analyzed: "
operator|+
name|analyzedKey
argument_list|)
expr_stmt|;
block|}
name|TokenStreamToAutomaton
name|tokenStreamToAutomaton
init|=
name|suggester
operator|.
name|getTokenStreamToAutomaton
argument_list|()
decl_stmt|;
comment|// NOTE: not great that we ask the suggester to give
comment|// us the "answer key" (ie maybe we have a bug in
comment|// suggester.toLevA ...) ... but testRandom2() fixes
comment|// this:
name|Automaton
name|automaton
init|=
name|suggester
operator|.
name|toLevenshteinAutomata
argument_list|(
name|suggester
operator|.
name|toLookupAutomaton
argument_list|(
name|analyzedKey
argument_list|)
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|automaton
operator|.
name|isDeterministic
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: could be faster... but its slowCompletor for a reason
name|BytesRef
name|spare
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
for|for
control|(
name|TermFreq2
name|e
range|:
name|slowCompletor
control|)
block|{
name|spare
operator|.
name|copyChars
argument_list|(
name|e
operator|.
name|analyzedForm
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|IntsRef
argument_list|>
name|finiteStrings
init|=
name|suggester
operator|.
name|toFiniteStrings
argument_list|(
name|spare
argument_list|,
name|tokenStreamToAutomaton
argument_list|)
decl_stmt|;
for|for
control|(
name|IntsRef
name|intsRef
range|:
name|finiteStrings
control|)
block|{
name|State
name|p
init|=
name|automaton
operator|.
name|getInitialState
argument_list|()
decl_stmt|;
name|BytesRef
name|ref
init|=
name|Util
operator|.
name|toBytesRef
argument_list|(
name|intsRef
argument_list|,
name|spare
argument_list|)
decl_stmt|;
name|boolean
name|added
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|ref
operator|.
name|offset
init|;
name|i
operator|<
name|ref
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|State
name|q
init|=
name|p
operator|.
name|step
argument_list|(
name|ref
operator|.
name|bytes
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|==
literal|null
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|q
operator|.
name|isAccept
argument_list|()
condition|)
block|{
name|matches
operator|.
name|add
argument_list|(
operator|new
name|LookupResult
argument_list|(
name|e
operator|.
name|surfaceForm
argument_list|,
name|e
operator|.
name|weight
argument_list|)
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|added
operator|&&
name|p
operator|.
name|isAccept
argument_list|()
condition|)
block|{
name|matches
operator|.
name|add
argument_list|(
operator|new
name|LookupResult
argument_list|(
name|e
operator|.
name|surfaceForm
argument_list|,
name|e
operator|.
name|weight
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|assertTrue
argument_list|(
name|numStopChars
operator|>
literal|0
operator|||
name|matches
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|matches
argument_list|,
operator|new
name|Comparator
argument_list|<
name|LookupResult
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|LookupResult
name|left
parameter_list|,
name|LookupResult
name|right
parameter_list|)
block|{
name|int
name|cmp
init|=
name|Float
operator|.
name|compare
argument_list|(
name|right
operator|.
name|value
argument_list|,
name|left
operator|.
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
return|return
name|left
operator|.
name|compareTo
argument_list|(
name|right
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|cmp
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|matches
operator|.
name|size
argument_list|()
operator|>
name|topN
condition|)
block|{
name|matches
operator|=
name|matches
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|topN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  expected:"
argument_list|)
expr_stmt|;
for|for
control|(
name|LookupResult
name|lr
range|:
name|matches
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    key="
operator|+
name|lr
operator|.
name|key
operator|+
literal|" weight="
operator|+
name|lr
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  actual:"
argument_list|)
expr_stmt|;
for|for
control|(
name|LookupResult
name|lr
range|:
name|r
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    key="
operator|+
name|lr
operator|.
name|key
operator|+
literal|" weight="
operator|+
name|lr
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
name|prefix
operator|+
literal|"  "
operator|+
name|topN
argument_list|,
name|matches
operator|.
name|size
argument_list|()
argument_list|,
name|r
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|hit
init|=
literal|0
init|;
name|hit
operator|<
name|r
operator|.
name|size
argument_list|()
condition|;
name|hit
operator|++
control|)
block|{
comment|//System.out.println("  check hit " + hit);
name|assertEquals
argument_list|(
name|prefix
operator|+
literal|"  "
operator|+
name|topN
argument_list|,
name|matches
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|,
name|r
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|matches
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|value
argument_list|,
name|r
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|value
argument_list|,
literal|0f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|testMaxSurfaceFormsPerAnalyzedForm
specifier|public
name|void
name|testMaxSurfaceFormsPerAnalyzedForm
parameter_list|()
throws|throws
name|Exception
block|{
name|Analyzer
name|a
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|FuzzySuggester
name|suggester
init|=
operator|new
name|FuzzySuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|TermFreq
argument_list|>
name|keys
init|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|TermFreq
index|[]
block|{
operator|new
name|TermFreq
argument_list|(
literal|"a"
argument_list|,
literal|40
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|"a "
argument_list|,
literal|50
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|" a"
argument_list|,
literal|60
argument_list|)
block|,       }
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|keys
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|TermFreqArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"a"
argument_list|,
literal|false
argument_list|,
literal|5
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|" a"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|60
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"a "
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
DECL|method|testEditSeps
specifier|public
name|void
name|testEditSeps
parameter_list|()
throws|throws
name|Exception
block|{
name|Analyzer
name|a
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|FuzzySuggester
name|suggester
init|=
operator|new
name|FuzzySuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|FuzzySuggester
operator|.
name|PRESERVE_SEP
argument_list|,
literal|2
argument_list|,
operator|-
literal|1
argument_list|,
literal|2
argument_list|,
literal|true
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|TermFreq
argument_list|>
name|keys
init|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|TermFreq
index|[]
block|{
operator|new
name|TermFreq
argument_list|(
literal|"foo bar"
argument_list|,
literal|40
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|"foo bar baz"
argument_list|,
literal|50
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|"barbaz"
argument_list|,
literal|60
argument_list|)
block|,
operator|new
name|TermFreq
argument_list|(
literal|"barbazfoo"
argument_list|,
literal|10
argument_list|)
block|,       }
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|keys
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|TermFreqArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[foo bar baz/50, foo bar/40]"
argument_list|,
name|suggester
operator|.
name|lookup
argument_list|(
literal|"foobar"
argument_list|,
literal|false
argument_list|,
literal|5
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[foo bar baz/50]"
argument_list|,
name|suggester
operator|.
name|lookup
argument_list|(
literal|"foobarbaz"
argument_list|,
literal|false
argument_list|,
literal|5
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[barbaz/60, barbazfoo/10]"
argument_list|,
name|suggester
operator|.
name|lookup
argument_list|(
literal|"bar baz"
argument_list|,
literal|false
argument_list|,
literal|5
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[barbazfoo/10]"
argument_list|,
name|suggester
operator|.
name|lookup
argument_list|(
literal|"bar baz foo"
argument_list|,
literal|false
argument_list|,
literal|5
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"fallthrough"
argument_list|)
DECL|method|addRandomEdit
specifier|private
specifier|static
name|String
name|addRandomEdit
parameter_list|(
name|String
name|string
parameter_list|,
name|int
name|prefixLength
parameter_list|)
block|{
name|char
index|[]
name|input
init|=
name|string
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|input
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|prefixLength
operator|&&
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
operator|&&
name|i
operator|<
name|input
operator|.
name|length
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|4
argument_list|)
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|i
operator|<
name|input
operator|.
name|length
operator|-
literal|1
condition|)
block|{
comment|// Transpose input[i] and input[1+i]:
name|builder
operator|.
name|append
argument_list|(
name|input
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
operator|+
literal|2
init|;
name|j
operator|<
name|input
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|input
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// NOTE: fall through to delete:
case|case
literal|2
case|:
comment|// Delete input[i]
for|for
control|(
name|int
name|j
init|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|input
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|input
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
case|case
literal|1
case|:
comment|// Insert input[i+1] twice
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|input
operator|.
name|length
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|input
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|input
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<
name|input
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|input
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
case|case
literal|0
case|:
comment|// Insert random byte.
comment|// NOTE: can only use ascii here so that, in
comment|// UTF8 byte space it's still a single
comment|// insertion:
name|int
name|x
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|128
argument_list|)
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<
name|input
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|input
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
name|builder
operator|.
name|append
argument_list|(
name|input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|randomSimpleString
specifier|private
name|String
name|randomSimpleString
parameter_list|(
name|int
name|maxLen
parameter_list|)
block|{
specifier|final
name|int
name|len
init|=
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
name|maxLen
argument_list|)
decl_stmt|;
specifier|final
name|char
index|[]
name|chars
init|=
operator|new
name|char
index|[
name|len
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
name|chars
index|[
name|j
index|]
operator|=
call|(
name|char
call|)
argument_list|(
literal|'a'
operator|+
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|String
argument_list|(
name|chars
argument_list|)
return|;
block|}
DECL|method|testRandom2
specifier|public
name|void
name|testRandom2
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|int
name|NUM
init|=
name|atLeast
argument_list|(
literal|200
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|TermFreq
argument_list|>
name|answers
init|=
operator|new
name|ArrayList
argument_list|<
name|TermFreq
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|seen
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|String
name|s
init|=
name|randomSimpleString
argument_list|(
literal|8
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|seen
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|answers
operator|.
name|add
argument_list|(
operator|new
name|TermFreq
argument_list|(
name|s
argument_list|,
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|1000
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|seen
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|answers
argument_list|,
operator|new
name|Comparator
argument_list|<
name|TermFreq
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|TermFreq
name|a
parameter_list|,
name|TermFreq
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|term
operator|.
name|compareTo
argument_list|(
name|b
operator|.
name|term
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nTEST: targets"
argument_list|)
expr_stmt|;
for|for
control|(
name|TermFreq
name|tf
range|:
name|answers
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|tf
operator|.
name|term
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" freq="
operator|+
name|tf
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
block|}
name|Analyzer
name|a
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|KEYWORD
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|maxEdits
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|1
else|:
literal|2
decl_stmt|;
name|int
name|prefixLen
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|boolean
name|transpositions
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
comment|// TODO: test graph analyzers
comment|// TODO: test exactFirst / preserveSep permutations
name|FuzzySuggester
name|suggest
init|=
operator|new
name|FuzzySuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
name|maxEdits
argument_list|,
name|transpositions
argument_list|,
name|prefixLen
argument_list|,
name|prefixLen
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: maxEdits="
operator|+
name|maxEdits
operator|+
literal|" prefixLen="
operator|+
name|prefixLen
operator|+
literal|" transpositions="
operator|+
name|transpositions
operator|+
literal|" num="
operator|+
name|NUM
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|shuffle
argument_list|(
name|answers
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
name|suggest
operator|.
name|build
argument_list|(
operator|new
name|TermFreqArrayIterator
argument_list|(
name|answers
operator|.
name|toArray
argument_list|(
operator|new
name|TermFreq
index|[
name|answers
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|int
name|ITERS
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|ITERS
condition|;
name|iter
operator|++
control|)
block|{
specifier|final
name|String
name|frag
init|=
name|randomSimpleString
argument_list|(
literal|6
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nTEST: iter frag="
operator|+
name|frag
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|LookupResult
argument_list|>
name|expected
init|=
name|slowFuzzyMatch
argument_list|(
name|prefixLen
argument_list|,
name|maxEdits
argument_list|,
name|transpositions
argument_list|,
name|answers
argument_list|,
name|frag
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  expected: "
operator|+
name|expected
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|LookupResult
name|c
range|:
name|expected
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|c
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|List
argument_list|<
name|LookupResult
argument_list|>
name|actual
init|=
name|suggest
operator|.
name|lookup
argument_list|(
name|frag
argument_list|,
literal|false
argument_list|,
name|NUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  actual: "
operator|+
name|actual
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|LookupResult
name|c
range|:
name|actual
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    "
operator|+
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|actual
argument_list|,
operator|new
name|CompareByCostThenAlpha
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
name|limit
init|=
name|Math
operator|.
name|min
argument_list|(
name|expected
operator|.
name|size
argument_list|()
argument_list|,
name|actual
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|ans
init|=
literal|0
init|;
name|ans
operator|<
name|limit
condition|;
name|ans
operator|++
control|)
block|{
specifier|final
name|LookupResult
name|c0
init|=
name|expected
operator|.
name|get
argument_list|(
name|ans
argument_list|)
decl_stmt|;
specifier|final
name|LookupResult
name|c1
init|=
name|actual
operator|.
name|get
argument_list|(
name|ans
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"expected "
operator|+
name|c0
operator|.
name|key
operator|+
literal|" but got "
operator|+
name|c1
operator|.
name|key
argument_list|,
literal|0
argument_list|,
name|CHARSEQUENCE_COMPARATOR
operator|.
name|compare
argument_list|(
name|c0
operator|.
name|key
argument_list|,
name|c1
operator|.
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|c0
operator|.
name|value
argument_list|,
name|c1
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expected
operator|.
name|size
argument_list|()
argument_list|,
name|actual
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|slowFuzzyMatch
specifier|private
name|List
argument_list|<
name|LookupResult
argument_list|>
name|slowFuzzyMatch
parameter_list|(
name|int
name|prefixLen
parameter_list|,
name|int
name|maxEdits
parameter_list|,
name|boolean
name|allowTransposition
parameter_list|,
name|List
argument_list|<
name|TermFreq
argument_list|>
name|answers
parameter_list|,
name|String
name|frag
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|LookupResult
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fragLen
init|=
name|frag
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|TermFreq
name|tf
range|:
name|answers
control|)
block|{
comment|//System.out.println("  check s=" + tf.term.utf8ToString());
name|boolean
name|prefixMatches
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|prefixLen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|fragLen
condition|)
block|{
comment|// Prefix still matches:
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|tf
operator|.
name|term
operator|.
name|length
operator|||
name|tf
operator|.
name|term
operator|.
name|bytes
index|[
name|i
index|]
operator|!=
operator|(
name|byte
operator|)
name|frag
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|prefixMatches
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
comment|//System.out.println("    prefixMatches=" + prefixMatches);
if|if
condition|(
name|prefixMatches
condition|)
block|{
specifier|final
name|int
name|len
init|=
name|tf
operator|.
name|term
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|len
operator|>=
name|fragLen
operator|-
name|maxEdits
condition|)
block|{
comment|// OK it's possible:
comment|//System.out.println("    possible");
name|int
name|d
decl_stmt|;
specifier|final
name|String
name|s
init|=
name|tf
operator|.
name|term
operator|.
name|utf8ToString
argument_list|()
decl_stmt|;
if|if
condition|(
name|fragLen
operator|==
name|prefixLen
condition|)
block|{
name|d
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|false
operator|&&
name|len
operator|<
name|fragLen
condition|)
block|{
name|d
operator|=
name|getDistance
argument_list|(
name|frag
argument_list|,
name|s
argument_list|,
name|allowTransposition
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//System.out.println("    try loop");
name|d
operator|=
name|maxEdits
operator|+
literal|1
expr_stmt|;
comment|//for(int ed=-maxEdits;ed<=maxEdits;ed++) {
for|for
control|(
name|int
name|ed
init|=
operator|-
name|maxEdits
init|;
name|ed
operator|<=
name|maxEdits
condition|;
name|ed
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|<
name|fragLen
operator|-
name|ed
condition|)
block|{
continue|continue;
block|}
name|String
name|check
init|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|fragLen
operator|-
name|ed
argument_list|)
decl_stmt|;
name|d
operator|=
name|getDistance
argument_list|(
name|frag
argument_list|,
name|check
argument_list|,
name|allowTransposition
argument_list|)
expr_stmt|;
comment|//System.out.println("    sub check s=" + check + " d=" + d);
if|if
condition|(
name|d
operator|<=
name|maxEdits
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
name|d
operator|<=
name|maxEdits
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
operator|new
name|LookupResult
argument_list|(
name|tf
operator|.
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|,
name|tf
operator|.
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|results
argument_list|,
operator|new
name|CompareByCostThenAlpha
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
DECL|class|CharSequenceComparator
specifier|private
specifier|static
class|class
name|CharSequenceComparator
implements|implements
name|Comparator
argument_list|<
name|CharSequence
argument_list|>
block|{
annotation|@
name|Override
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
name|CharSequence
name|o1
parameter_list|,
name|CharSequence
name|o2
parameter_list|)
block|{
specifier|final
name|int
name|l1
init|=
name|o1
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|final
name|int
name|l2
init|=
name|o2
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|final
name|int
name|aStop
init|=
name|Math
operator|.
name|min
argument_list|(
name|l1
argument_list|,
name|l2
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aStop
condition|;
name|i
operator|++
control|)
block|{
name|int
name|diff
init|=
name|o1
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|-
name|o2
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
block|{
return|return
name|diff
return|;
block|}
block|}
comment|// One is a prefix of the other, or, they are equal:
return|return
name|l1
operator|-
name|l2
return|;
block|}
block|}
DECL|field|CHARSEQUENCE_COMPARATOR
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|CharSequence
argument_list|>
name|CHARSEQUENCE_COMPARATOR
init|=
operator|new
name|CharSequenceComparator
argument_list|()
decl_stmt|;
DECL|class|CompareByCostThenAlpha
specifier|public
class|class
name|CompareByCostThenAlpha
implements|implements
name|Comparator
argument_list|<
name|LookupResult
argument_list|>
block|{
annotation|@
name|Override
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
name|LookupResult
name|a
parameter_list|,
name|LookupResult
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|value
operator|>
name|b
operator|.
name|value
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|.
name|value
operator|<
name|b
operator|.
name|value
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
specifier|final
name|int
name|c
init|=
name|CHARSEQUENCE_COMPARATOR
operator|.
name|compare
argument_list|(
name|a
operator|.
name|key
argument_list|,
name|b
operator|.
name|key
argument_list|)
decl_stmt|;
assert|assert
name|c
operator|!=
literal|0
operator|:
literal|"term="
operator|+
name|a
operator|.
name|key
assert|;
return|return
name|c
return|;
block|}
block|}
block|}
comment|// NOTE: copied from
comment|// modules/suggest/src/java/org/apache/lucene/search/spell/LuceneLevenshteinDistance.java
comment|// and tweaked to return the edit distance not the float
comment|// lucene measure
comment|/* Finds unicode (code point) Levenstein (edit) distance    * between two strings, including transpositions. */
DECL|method|getDistance
specifier|public
name|int
name|getDistance
parameter_list|(
name|String
name|target
parameter_list|,
name|String
name|other
parameter_list|,
name|boolean
name|allowTransposition
parameter_list|)
block|{
name|IntsRef
name|targetPoints
decl_stmt|;
name|IntsRef
name|otherPoints
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|d
index|[]
index|[]
decl_stmt|;
comment|// cost array
comment|// NOTE: if we cared, we could 3*m space instead of m*n space, similar to
comment|// what LevenshteinDistance does, except cycling thru a ring of three
comment|// horizontal cost arrays... but this comparator is never actually used by
comment|// DirectSpellChecker, its only used for merging results from multiple shards
comment|// in "distributed spellcheck", and its inefficient in other ways too...
comment|// cheaper to do this up front once
name|targetPoints
operator|=
name|toIntsRef
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|otherPoints
operator|=
name|toIntsRef
argument_list|(
name|other
argument_list|)
expr_stmt|;
name|n
operator|=
name|targetPoints
operator|.
name|length
expr_stmt|;
specifier|final
name|int
name|m
init|=
name|otherPoints
operator|.
name|length
decl_stmt|;
name|d
operator|=
operator|new
name|int
index|[
name|n
operator|+
literal|1
index|]
index|[
name|m
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|m
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|m
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
return|;
block|}
block|}
comment|// indexes into strings s and t
name|int
name|i
decl_stmt|;
comment|// iterates through s
name|int
name|j
decl_stmt|;
comment|// iterates through t
name|int
name|t_j
decl_stmt|;
comment|// jth character of t
name|int
name|cost
decl_stmt|;
comment|// cost
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|d
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|m
condition|;
name|j
operator|++
control|)
block|{
name|d
index|[
literal|0
index|]
index|[
name|j
index|]
operator|=
name|j
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|m
condition|;
name|j
operator|++
control|)
block|{
name|t_j
operator|=
name|otherPoints
operator|.
name|ints
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|cost
operator|=
name|targetPoints
operator|.
name|ints
index|[
name|i
operator|-
literal|1
index|]
operator|==
name|t_j
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|// minimum of cell to the left+1, to the top+1, diagonally left and up +cost
name|d
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|Math
operator|.
name|min
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|d
index|[
name|i
operator|-
literal|1
index|]
index|[
name|j
index|]
operator|+
literal|1
argument_list|,
name|d
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
operator|+
literal|1
argument_list|)
argument_list|,
name|d
index|[
name|i
operator|-
literal|1
index|]
index|[
name|j
operator|-
literal|1
index|]
operator|+
name|cost
argument_list|)
expr_stmt|;
comment|// transposition
if|if
condition|(
name|allowTransposition
operator|&&
name|i
operator|>
literal|1
operator|&&
name|j
operator|>
literal|1
operator|&&
name|targetPoints
operator|.
name|ints
index|[
name|i
operator|-
literal|1
index|]
operator|==
name|otherPoints
operator|.
name|ints
index|[
name|j
operator|-
literal|2
index|]
operator|&&
name|targetPoints
operator|.
name|ints
index|[
name|i
operator|-
literal|2
index|]
operator|==
name|otherPoints
operator|.
name|ints
index|[
name|j
operator|-
literal|1
index|]
condition|)
block|{
name|d
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|Math
operator|.
name|min
argument_list|(
name|d
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|d
index|[
name|i
operator|-
literal|2
index|]
index|[
name|j
operator|-
literal|2
index|]
operator|+
name|cost
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|d
index|[
name|n
index|]
index|[
name|m
index|]
return|;
block|}
DECL|method|toIntsRef
specifier|private
specifier|static
name|IntsRef
name|toIntsRef
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|IntsRef
name|ref
init|=
operator|new
name|IntsRef
argument_list|(
name|s
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
comment|// worst case
name|int
name|utf16Len
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|cp
init|=
literal|0
init|;
name|i
operator|<
name|utf16Len
condition|;
name|i
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|cp
argument_list|)
control|)
block|{
name|cp
operator|=
name|ref
operator|.
name|ints
index|[
name|ref
operator|.
name|length
operator|++
index|]
operator|=
name|Character
operator|.
name|codePointAt
argument_list|(
name|s
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|ref
return|;
block|}
block|}
end_class
end_unit
