begin_unit
begin_package
DECL|package|org.apache.lucene.search.suggest.analyzing
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|analyzing
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|CannedBinaryTokenStream
operator|.
name|BinaryToken
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|CannedBinaryTokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|CannedTokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockAnalyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockBytesAttributeFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockTokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockTokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Token
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Tokenizer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|CharTermAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|PositionIncrementAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|Lookup
operator|.
name|LookupResult
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|Input
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|InputArrayIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LineFileDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_class
DECL|class|AnalyzingSuggesterTest
specifier|public
class|class
name|AnalyzingSuggesterTest
extends|extends
name|LuceneTestCase
block|{
comment|/** this is basically the WFST test ported to KeywordAnalyzer. so it acts the same */
DECL|method|testKeyword
specifier|public
name|void
name|testKeyword
parameter_list|()
throws|throws
name|Exception
block|{
name|Iterable
argument_list|<
name|Input
argument_list|>
name|keys
init|=
name|shuffle
argument_list|(
operator|new
name|Input
argument_list|(
literal|"foo"
argument_list|,
literal|50
argument_list|)
argument_list|,
operator|new
name|Input
argument_list|(
literal|"bar"
argument_list|,
literal|10
argument_list|)
argument_list|,
operator|new
name|Input
argument_list|(
literal|"barbar"
argument_list|,
literal|10
argument_list|)
argument_list|,
operator|new
name|Input
argument_list|(
literal|"barbar"
argument_list|,
literal|12
argument_list|)
argument_list|,
operator|new
name|Input
argument_list|(
literal|"barbara"
argument_list|,
literal|6
argument_list|)
argument_list|,
operator|new
name|Input
argument_list|(
literal|"bar"
argument_list|,
literal|5
argument_list|)
argument_list|,
operator|new
name|Input
argument_list|(
literal|"barbara"
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|KEYWORD
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
comment|// top N of 2, but only foo is available
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
name|TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"f"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"foo"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
comment|// top N of 1 for 'bar': we return this even though
comment|// barbar is higher because exactFirst is enabled:
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"bar"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"bar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
comment|// top N Of 2 for 'b'
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"b"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"barbar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|12
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"bar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
comment|// top N of 3 for 'ba'
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"ba"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"barbar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|12
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"bar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"barbara"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
block|}
DECL|method|testKeywordWithPayloads
specifier|public
name|void
name|testKeywordWithPayloads
parameter_list|()
throws|throws
name|Exception
block|{
name|Iterable
argument_list|<
name|Input
argument_list|>
name|keys
init|=
name|shuffle
argument_list|(
operator|new
name|Input
argument_list|(
literal|"foo"
argument_list|,
literal|50
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"hello"
argument_list|)
argument_list|)
argument_list|,
operator|new
name|Input
argument_list|(
literal|"bar"
argument_list|,
literal|10
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"goodbye"
argument_list|)
argument_list|)
argument_list|,
operator|new
name|Input
argument_list|(
literal|"barbar"
argument_list|,
literal|12
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"thank you"
argument_list|)
argument_list|)
argument_list|,
operator|new
name|Input
argument_list|(
literal|"bar"
argument_list|,
literal|9
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"should be deduplicated"
argument_list|)
argument_list|)
argument_list|,
operator|new
name|Input
argument_list|(
literal|"bar"
argument_list|,
literal|8
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"should also be deduplicated"
argument_list|)
argument_list|)
argument_list|,
operator|new
name|Input
argument_list|(
literal|"barbara"
argument_list|,
literal|6
argument_list|,
operator|new
name|BytesRef
argument_list|(
literal|"for all the fish"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|KEYWORD
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|// top N of 2, but only foo is available
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
name|TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"f"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"foo"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"hello"
argument_list|)
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|payload
argument_list|)
expr_stmt|;
comment|// top N of 1 for 'bar': we return this even though
comment|// barbar is higher because exactFirst is enabled:
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"bar"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"bar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"goodbye"
argument_list|)
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|payload
argument_list|)
expr_stmt|;
comment|// top N Of 2 for 'b'
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"b"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"barbar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|12
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"thank you"
argument_list|)
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|payload
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"bar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"goodbye"
argument_list|)
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|payload
argument_list|)
expr_stmt|;
comment|// top N of 3 for 'ba'
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"ba"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"barbar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|12
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"thank you"
argument_list|)
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|payload
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"bar"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"goodbye"
argument_list|)
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|payload
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"barbara"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|new
name|BytesRef
argument_list|(
literal|"for all the fish"
argument_list|)
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|payload
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testRandomRealisticKeys
specifier|public
name|void
name|testRandomRealisticKeys
parameter_list|()
throws|throws
name|IOException
block|{
name|LineFileDocs
name|lineFile
init|=
operator|new
name|LineFileDocs
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|mapping
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Input
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|howMany
init|=
name|atLeast
argument_list|(
literal|100
argument_list|)
decl_stmt|;
comment|// this might bring up duplicates
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|howMany
condition|;
name|i
operator|++
control|)
block|{
name|Document
name|nextDoc
init|=
name|lineFile
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
name|String
name|title
init|=
name|nextDoc
operator|.
name|getField
argument_list|(
literal|"title"
argument_list|)
operator|.
name|stringValue
argument_list|()
decl_stmt|;
name|int
name|randomWeight
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|keys
operator|.
name|add
argument_list|(
operator|new
name|Input
argument_list|(
name|title
argument_list|,
name|randomWeight
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mapping
operator|.
name|containsKey
argument_list|(
name|title
argument_list|)
operator|||
name|mapping
operator|.
name|get
argument_list|(
name|title
argument_list|)
operator|<
name|randomWeight
condition|)
block|{
name|mapping
operator|.
name|put
argument_list|(
name|title
argument_list|,
name|Long
operator|.
name|valueOf
argument_list|(
name|randomWeight
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|AnalyzingSuggester
name|analyzingSuggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|,
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|,
name|AnalyzingSuggester
operator|.
name|EXACT_FIRST
operator||
name|AnalyzingSuggester
operator|.
name|PRESERVE_SEP
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|doPayloads
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|doPayloads
condition|)
block|{
name|List
argument_list|<
name|Input
argument_list|>
name|keysAndPayloads
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Input
name|termFreq
range|:
name|keys
control|)
block|{
name|keysAndPayloads
operator|.
name|add
argument_list|(
operator|new
name|Input
argument_list|(
name|termFreq
operator|.
name|term
argument_list|,
name|termFreq
operator|.
name|v
argument_list|,
operator|new
name|BytesRef
argument_list|(
name|Long
operator|.
name|toString
argument_list|(
name|termFreq
operator|.
name|v
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|analyzingSuggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|keysAndPayloads
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|analyzingSuggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Input
name|termFreq
range|:
name|keys
control|)
block|{
name|List
argument_list|<
name|LookupResult
argument_list|>
name|lookup
init|=
name|analyzingSuggester
operator|.
name|lookup
argument_list|(
name|termFreq
operator|.
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|,
literal|false
argument_list|,
name|keys
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|LookupResult
name|lookupResult
range|:
name|lookup
control|)
block|{
name|assertEquals
argument_list|(
name|mapping
operator|.
name|get
argument_list|(
name|lookupResult
operator|.
name|key
argument_list|)
argument_list|,
name|Long
operator|.
name|valueOf
argument_list|(
name|lookupResult
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doPayloads
condition|)
block|{
name|assertEquals
argument_list|(
name|lookupResult
operator|.
name|payload
operator|.
name|utf8ToString
argument_list|()
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|lookupResult
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertNull
argument_list|(
name|lookupResult
operator|.
name|payload
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|lineFile
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// TODO: more tests
comment|/**    * basic "standardanalyzer" test with stopword removal    */
DECL|method|testStandard
specifier|public
name|void
name|testStandard
parameter_list|()
throws|throws
name|Exception
block|{
name|Input
name|keys
index|[]
init|=
operator|new
name|Input
index|[]
block|{
operator|new
name|Input
argument_list|(
literal|"the ghost of christmas past"
argument_list|,
literal|50
argument_list|)
block|,     }
decl_stmt|;
name|Analyzer
name|standard
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|true
argument_list|,
name|MockTokenFilter
operator|.
name|ENGLISH_STOPSET
argument_list|)
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|standard
argument_list|,
name|standard
argument_list|,
name|AnalyzingSuggester
operator|.
name|EXACT_FIRST
operator||
name|AnalyzingSuggester
operator|.
name|PRESERVE_SEP
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
name|TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"the ghost of chris"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"the ghost of christmas past"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
comment|// omit the 'the' since its a stopword, its suggested anyway
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"ghost of chris"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"the ghost of christmas past"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
comment|// omit the 'the' and 'of' since they are stopwords, its suggested anyway
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
name|TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"ghost chris"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"the ghost of christmas past"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|,
literal|0.01F
argument_list|)
expr_stmt|;
block|}
DECL|method|testEmpty
specifier|public
name|void
name|testEmpty
parameter_list|()
throws|throws
name|Exception
block|{
name|Analyzer
name|standard
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|true
argument_list|,
name|MockTokenFilter
operator|.
name|ENGLISH_STOPSET
argument_list|)
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|standard
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
operator|new
name|Input
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|result
init|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"a"
argument_list|,
literal|false
argument_list|,
literal|20
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testNoSeps
specifier|public
name|void
name|testNoSeps
parameter_list|()
throws|throws
name|Exception
block|{
name|Input
index|[]
name|keys
init|=
operator|new
name|Input
index|[]
block|{
operator|new
name|Input
argument_list|(
literal|"ab cd"
argument_list|,
literal|0
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"abcd"
argument_list|,
literal|1
argument_list|)
block|,     }
decl_stmt|;
name|int
name|options
init|=
literal|0
decl_stmt|;
name|Analyzer
name|a
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|options
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
comment|// TODO: would be nice if "ab " would allow the test to
comment|// pass, and more generally if the analyzer can know
comment|// that the user's current query has ended at a word,
comment|// but, analyzers don't produce SEP tokens!
name|List
argument_list|<
name|LookupResult
argument_list|>
name|r
init|=
name|suggester
operator|.
name|lookup
argument_list|(
name|TestUtil
operator|.
name|stringToCharSequence
argument_list|(
literal|"ab c"
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|r
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// With no PRESERVE_SEPS specified, "ab c" should also
comment|// complete to "abcd", which has higher weight so should
comment|// appear first:
name|assertEquals
argument_list|(
literal|"abcd"
argument_list|,
name|r
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testGraphDups
specifier|public
name|void
name|testGraphDups
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Analyzer
name|analyzer
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|SIMPLE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|)
block|{
name|int
name|tokenStreamCounter
init|=
literal|0
decl_stmt|;
specifier|final
name|TokenStream
index|[]
name|tokenStreams
init|=
operator|new
name|TokenStream
index|[]
block|{
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"wifi"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"hotspot"
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
block|,
name|token
argument_list|(
literal|"network"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"is"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"slow"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|}
argument_list|)
block|,
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"wi"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"hotspot"
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
block|,
name|token
argument_list|(
literal|"fi"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"network"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"is"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"fast"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|}
argument_list|)
block|,
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"wifi"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"hotspot"
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
block|,
name|token
argument_list|(
literal|"network"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|}
argument_list|)
block|,           }
decl_stmt|;
annotation|@
name|Override
specifier|public
name|TokenStream
name|getTokenStream
parameter_list|()
block|{
name|TokenStream
name|result
init|=
name|tokenStreams
index|[
name|tokenStreamCounter
index|]
decl_stmt|;
name|tokenStreamCounter
operator|++
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setReader
parameter_list|(
specifier|final
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{           }
block|}
return|;
block|}
block|}
decl_stmt|;
name|Input
name|keys
index|[]
init|=
operator|new
name|Input
index|[]
block|{
operator|new
name|Input
argument_list|(
literal|"wifi network is slow"
argument_list|,
literal|50
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"wi fi network is fast"
argument_list|,
literal|10
argument_list|)
block|,     }
decl_stmt|;
comment|//AnalyzingSuggester suggester = new AnalyzingSuggester(analyzer, AnalyzingSuggester.EXACT_FIRST, 256, -1);
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|analyzer
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"wifi network"
argument_list|,
literal|false
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Results: "
operator|+
name|results
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"wifi network is slow"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"wi fi network is fast"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
DECL|method|testInputPathRequired
specifier|public
name|void
name|testInputPathRequired
parameter_list|()
throws|throws
name|Exception
block|{
comment|//  SynonymMap.Builder b = new SynonymMap.Builder(false);
comment|//  b.add(new CharsRef("ab"), new CharsRef("ba"), true);
comment|//  final SynonymMap map = b.build();
comment|//  The Analyzer below mimics the functionality of the SynonymAnalyzer
comment|//  using the above map, so that the suggest module does not need a dependency on the
comment|//  synonym module
specifier|final
name|Analyzer
name|analyzer
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|SIMPLE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|)
block|{
name|int
name|tokenStreamCounter
init|=
literal|0
decl_stmt|;
specifier|final
name|TokenStream
index|[]
name|tokenStreams
init|=
operator|new
name|TokenStream
index|[]
block|{
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"ab"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"ba"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"xc"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|}
argument_list|)
block|,
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"ba"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"xd"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|}
argument_list|)
block|,
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"ab"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"ba"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"x"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|}
argument_list|)
block|}
decl_stmt|;
annotation|@
name|Override
specifier|public
name|TokenStream
name|getTokenStream
parameter_list|()
block|{
name|TokenStream
name|result
init|=
name|tokenStreams
index|[
name|tokenStreamCounter
index|]
decl_stmt|;
name|tokenStreamCounter
operator|++
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setReader
parameter_list|(
specifier|final
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{           }
block|}
return|;
block|}
block|}
decl_stmt|;
name|Input
name|keys
index|[]
init|=
operator|new
name|Input
index|[]
block|{
operator|new
name|Input
argument_list|(
literal|"ab xc"
argument_list|,
literal|50
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"ba xd"
argument_list|,
literal|50
argument_list|)
block|,     }
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|analyzer
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|keys
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"ab x"
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|results
operator|.
name|size
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|token
specifier|private
specifier|static
name|Token
name|token
parameter_list|(
name|String
name|term
parameter_list|,
name|int
name|posInc
parameter_list|,
name|int
name|posLength
parameter_list|)
block|{
specifier|final
name|Token
name|t
init|=
operator|new
name|Token
argument_list|(
name|term
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|t
operator|.
name|setPositionIncrement
argument_list|(
name|posInc
argument_list|)
expr_stmt|;
name|t
operator|.
name|setPositionLength
argument_list|(
name|posLength
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
DECL|method|token
specifier|private
specifier|static
name|BinaryToken
name|token
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
return|return
operator|new
name|BinaryToken
argument_list|(
name|term
argument_list|)
return|;
block|}
comment|/*   private void printTokens(final Analyzer analyzer, String input) throws IOException {     System.out.println("Tokens for " + input);     TokenStream ts = analyzer.tokenStream("", new StringReader(input));     ts.reset();     final TermToBytesRefAttribute termBytesAtt = ts.addAttribute(TermToBytesRefAttribute.class);     final PositionIncrementAttribute posIncAtt = ts.addAttribute(PositionIncrementAttribute.class);     final PositionLengthAttribute posLengthAtt = ts.addAttribute(PositionLengthAttribute.class);          while(ts.incrementToken()) {       termBytesAtt.fillBytesRef();       System.out.println(String.format("%s,%s,%s", termBytesAtt.getBytesRef().utf8ToString(), posIncAtt.getPositionIncrement(), posLengthAtt.getPositionLength()));           }     ts.end();     ts.close();   }    */
DECL|method|getUnusualAnalyzer
specifier|private
specifier|final
name|Analyzer
name|getUnusualAnalyzer
parameter_list|()
block|{
return|return
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|SIMPLE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|)
block|{
name|int
name|count
decl_stmt|;
annotation|@
name|Override
specifier|public
name|TokenStream
name|getTokenStream
parameter_list|()
block|{
comment|// 4th time we are called, return tokens a b,
comment|// else just a:
if|if
condition|(
name|count
operator|++
operator|!=
literal|3
condition|)
block|{
return|return
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,                 }
argument_list|)
return|;
block|}
else|else
block|{
comment|// After that "a b":
return|return
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"b"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,                 }
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setReader
parameter_list|(
specifier|final
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{           }
block|}
return|;
block|}
block|}
return|;
block|}
DECL|method|testExactFirst
specifier|public
name|void
name|testExactFirst
parameter_list|()
throws|throws
name|Exception
block|{
name|Analyzer
name|a
init|=
name|getUnusualAnalyzer
argument_list|()
decl_stmt|;
name|int
name|options
init|=
name|AnalyzingSuggester
operator|.
name|EXACT_FIRST
operator||
name|AnalyzingSuggester
operator|.
name|PRESERVE_SEP
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|options
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
operator|new
name|Input
index|[]
block|{
operator|new
name|Input
argument_list|(
literal|"x y"
argument_list|,
literal|1
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"x y z"
argument_list|,
literal|3
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"x"
argument_list|,
literal|2
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"z z z"
argument_list|,
literal|20
argument_list|)
block|,         }
argument_list|)
argument_list|)
expr_stmt|;
comment|//System.out.println("ALL: " + suggester.lookup("x y", false, 6));
for|for
control|(
name|int
name|topN
init|=
literal|1
init|;
name|topN
operator|<
literal|6
condition|;
name|topN
operator|++
control|)
block|{
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"x y"
argument_list|,
literal|false
argument_list|,
name|topN
argument_list|)
decl_stmt|;
comment|//System.out.println("topN=" + topN + " " + results);
name|assertEquals
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|topN
argument_list|,
literal|4
argument_list|)
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"x y"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|topN
operator|>
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
literal|"z z z"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|20
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|topN
operator|>
literal|2
condition|)
block|{
name|assertEquals
argument_list|(
literal|"x y z"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|topN
operator|>
literal|3
condition|)
block|{
name|assertEquals
argument_list|(
literal|"x"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|testNonExactFirst
specifier|public
name|void
name|testNonExactFirst
parameter_list|()
throws|throws
name|Exception
block|{
name|Analyzer
name|a
init|=
name|getUnusualAnalyzer
argument_list|()
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|AnalyzingSuggester
operator|.
name|PRESERVE_SEP
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
operator|new
name|Input
index|[]
block|{
operator|new
name|Input
argument_list|(
literal|"x y"
argument_list|,
literal|1
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"x y z"
argument_list|,
literal|3
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"x"
argument_list|,
literal|2
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"z z z"
argument_list|,
literal|20
argument_list|)
block|,         }
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|topN
init|=
literal|1
init|;
name|topN
operator|<
literal|6
condition|;
name|topN
operator|++
control|)
block|{
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"p"
argument_list|,
literal|false
argument_list|,
name|topN
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|topN
argument_list|,
literal|4
argument_list|)
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"z z z"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|20
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|topN
operator|>
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
literal|"x y z"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|topN
operator|>
literal|2
condition|)
block|{
name|assertEquals
argument_list|(
literal|"x"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|topN
operator|>
literal|3
condition|)
block|{
name|assertEquals
argument_list|(
literal|"x y"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// Holds surface form separately:
DECL|class|TermFreq2
specifier|private
specifier|static
class|class
name|TermFreq2
implements|implements
name|Comparable
argument_list|<
name|TermFreq2
argument_list|>
block|{
DECL|field|surfaceForm
specifier|public
specifier|final
name|String
name|surfaceForm
decl_stmt|;
DECL|field|analyzedForm
specifier|public
specifier|final
name|String
name|analyzedForm
decl_stmt|;
DECL|field|weight
specifier|public
specifier|final
name|long
name|weight
decl_stmt|;
DECL|field|payload
specifier|public
specifier|final
name|BytesRef
name|payload
decl_stmt|;
DECL|method|TermFreq2
specifier|public
name|TermFreq2
parameter_list|(
name|String
name|surfaceForm
parameter_list|,
name|String
name|analyzedForm
parameter_list|,
name|long
name|weight
parameter_list|,
name|BytesRef
name|payload
parameter_list|)
block|{
name|this
operator|.
name|surfaceForm
operator|=
name|surfaceForm
expr_stmt|;
name|this
operator|.
name|analyzedForm
operator|=
name|analyzedForm
expr_stmt|;
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
name|this
operator|.
name|payload
operator|=
name|payload
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|TermFreq2
name|other
parameter_list|)
block|{
name|int
name|cmp
init|=
name|analyzedForm
operator|.
name|compareTo
argument_list|(
name|other
operator|.
name|analyzedForm
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
elseif|else
if|if
condition|(
name|weight
operator|>
name|other
operator|.
name|weight
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|weight
operator|<
name|other
operator|.
name|weight
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
assert|assert
literal|false
assert|;
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|surfaceForm
operator|+
literal|"/"
operator|+
name|weight
return|;
block|}
block|}
DECL|method|isStopChar
specifier|static
name|boolean
name|isStopChar
parameter_list|(
name|char
name|ch
parameter_list|,
name|int
name|numStopChars
parameter_list|)
block|{
comment|//System.out.println("IS? " + ch + ": " + (ch - 'a') + ": " + ((ch - 'a')< numStopChars));
return|return
operator|(
name|ch
operator|-
literal|'a'
operator|)
operator|<
name|numStopChars
return|;
block|}
comment|// Like StopFilter:
DECL|class|TokenEater
specifier|private
specifier|static
class|class
name|TokenEater
extends|extends
name|TokenFilter
block|{
DECL|field|posIncrAtt
specifier|private
specifier|final
name|PositionIncrementAttribute
name|posIncrAtt
init|=
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|termAtt
specifier|private
specifier|final
name|CharTermAttribute
name|termAtt
init|=
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|numStopChars
specifier|private
specifier|final
name|int
name|numStopChars
decl_stmt|;
DECL|field|preserveHoles
specifier|private
specifier|final
name|boolean
name|preserveHoles
decl_stmt|;
DECL|field|first
specifier|private
name|boolean
name|first
decl_stmt|;
DECL|method|TokenEater
specifier|public
name|TokenEater
parameter_list|(
name|boolean
name|preserveHoles
parameter_list|,
name|TokenStream
name|in
parameter_list|,
name|int
name|numStopChars
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|preserveHoles
operator|=
name|preserveHoles
expr_stmt|;
name|this
operator|.
name|numStopChars
operator|=
name|numStopChars
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|reset
argument_list|()
expr_stmt|;
name|first
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|incrementToken
specifier|public
specifier|final
name|boolean
name|incrementToken
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|skippedPositions
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|input
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
if|if
condition|(
name|termAtt
operator|.
name|length
argument_list|()
operator|!=
literal|1
operator|||
operator|!
name|isStopChar
argument_list|(
name|termAtt
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|numStopChars
argument_list|)
condition|)
block|{
name|int
name|posInc
init|=
name|posIncrAtt
operator|.
name|getPositionIncrement
argument_list|()
operator|+
name|skippedPositions
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|posInc
operator|==
literal|0
condition|)
block|{
comment|// first token having posinc=0 is illegal.
name|posInc
operator|=
literal|1
expr_stmt|;
block|}
name|first
operator|=
literal|false
expr_stmt|;
block|}
name|posIncrAtt
operator|.
name|setPositionIncrement
argument_list|(
name|posInc
argument_list|)
expr_stmt|;
comment|//System.out.println("RETURN term=" + termAtt + " numStopChars=" + numStopChars);
return|return
literal|true
return|;
block|}
if|if
condition|(
name|preserveHoles
condition|)
block|{
name|skippedPositions
operator|+=
name|posIncrAtt
operator|.
name|getPositionIncrement
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
DECL|class|MockTokenEatingAnalyzer
specifier|private
specifier|static
class|class
name|MockTokenEatingAnalyzer
extends|extends
name|Analyzer
block|{
DECL|field|numStopChars
specifier|private
name|int
name|numStopChars
decl_stmt|;
DECL|field|preserveHoles
specifier|private
name|boolean
name|preserveHoles
decl_stmt|;
DECL|field|factory
specifier|private
specifier|final
name|MockBytesAttributeFactory
name|factory
init|=
operator|new
name|MockBytesAttributeFactory
argument_list|()
decl_stmt|;
DECL|method|MockTokenEatingAnalyzer
specifier|public
name|MockTokenEatingAnalyzer
parameter_list|(
name|int
name|numStopChars
parameter_list|,
name|boolean
name|preserveHoles
parameter_list|)
block|{
name|this
operator|.
name|preserveHoles
operator|=
name|preserveHoles
expr_stmt|;
name|this
operator|.
name|numStopChars
operator|=
name|numStopChars
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createComponents
specifier|public
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|MockTokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|factory
argument_list|,
name|MockTokenizer
operator|.
name|WHITESPACE
argument_list|,
literal|false
argument_list|,
name|MockTokenizer
operator|.
name|DEFAULT_MAX_TOKEN_LENGTH
argument_list|)
decl_stmt|;
name|tokenizer
operator|.
name|setEnableChecks
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|TokenStream
name|next
decl_stmt|;
if|if
condition|(
name|numStopChars
operator|!=
literal|0
condition|)
block|{
name|next
operator|=
operator|new
name|TokenEater
argument_list|(
name|preserveHoles
argument_list|,
name|tokenizer
argument_list|,
name|numStopChars
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|tokenizer
expr_stmt|;
block|}
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|,
name|next
argument_list|)
return|;
block|}
block|}
DECL|field|SEP
specifier|private
specifier|static
name|char
name|SEP
init|=
literal|'\u001F'
decl_stmt|;
DECL|method|testRandom
specifier|public
name|void
name|testRandom
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|numQueries
init|=
name|atLeast
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|TermFreq2
argument_list|>
name|slowCompletor
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|TreeSet
argument_list|<
name|String
argument_list|>
name|allPrefixes
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|seen
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|doPayloads
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
name|Input
index|[]
name|keys
init|=
literal|null
decl_stmt|;
name|Input
index|[]
name|payloadKeys
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|doPayloads
condition|)
block|{
name|payloadKeys
operator|=
operator|new
name|Input
index|[
name|numQueries
index|]
expr_stmt|;
block|}
else|else
block|{
name|keys
operator|=
operator|new
name|Input
index|[
name|numQueries
index|]
expr_stmt|;
block|}
name|boolean
name|preserveSep
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numStopChars
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|preserveHoles
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: "
operator|+
name|numQueries
operator|+
literal|" words; preserveSep="
operator|+
name|preserveSep
operator|+
literal|" numStopChars="
operator|+
name|numStopChars
operator|+
literal|" preserveHoles="
operator|+
name|preserveHoles
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numQueries
condition|;
name|i
operator|++
control|)
block|{
name|int
name|numTokens
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|String
name|key
decl_stmt|;
name|String
name|analyzedKey
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|key
operator|=
literal|""
expr_stmt|;
name|analyzedKey
operator|=
literal|""
expr_stmt|;
name|boolean
name|lastRemoved
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|token
init|=
literal|0
init|;
name|token
operator|<
name|numTokens
condition|;
name|token
operator|++
control|)
block|{
name|String
name|s
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// TODO: would be nice to fix this slowCompletor/comparator to
comment|// use full range, but we might lose some coverage too...
name|s
operator|=
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|token
operator|>
literal|0
condition|)
block|{
name|key
operator|+=
literal|" "
expr_stmt|;
block|}
if|if
condition|(
name|preserveSep
operator|&&
name|analyzedKey
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|analyzedKey
operator|.
name|charAt
argument_list|(
name|analyzedKey
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|!=
name|SEP
condition|)
block|{
name|analyzedKey
operator|+=
name|SEP
expr_stmt|;
block|}
name|key
operator|+=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|&&
name|isStopChar
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|numStopChars
argument_list|)
condition|)
block|{
name|lastRemoved
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|preserveSep
operator|&&
name|preserveHoles
condition|)
block|{
name|analyzedKey
operator|+=
name|SEP
expr_stmt|;
block|}
block|}
else|else
block|{
name|lastRemoved
operator|=
literal|false
expr_stmt|;
name|analyzedKey
operator|+=
name|s
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
name|analyzedKey
operator|=
name|analyzedKey
operator|.
name|replaceAll
argument_list|(
literal|"(^|"
operator|+
name|SEP
operator|+
literal|")"
operator|+
name|SEP
operator|+
literal|"$"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|preserveSep
operator|&&
name|lastRemoved
condition|)
block|{
name|analyzedKey
operator|+=
name|SEP
expr_stmt|;
block|}
comment|// Don't add same surface form more than once:
if|if
condition|(
operator|!
name|seen
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|seen
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|key
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|allPrefixes
operator|.
name|add
argument_list|(
name|key
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// we can probably do Integer.MAX_VALUE here, but why worry.
name|int
name|weight
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|1
operator|<<
literal|24
argument_list|)
decl_stmt|;
name|BytesRef
name|payload
decl_stmt|;
if|if
condition|(
name|doPayloads
condition|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
index|]
decl_stmt|;
name|random
argument_list|()
operator|.
name|nextBytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|payload
operator|=
operator|new
name|BytesRef
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|payloadKeys
index|[
name|i
index|]
operator|=
operator|new
name|Input
argument_list|(
name|key
argument_list|,
name|weight
argument_list|,
name|payload
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|keys
index|[
name|i
index|]
operator|=
operator|new
name|Input
argument_list|(
name|key
argument_list|,
name|weight
argument_list|)
expr_stmt|;
name|payload
operator|=
literal|null
expr_stmt|;
block|}
name|slowCompletor
operator|.
name|add
argument_list|(
operator|new
name|TermFreq2
argument_list|(
name|key
argument_list|,
name|analyzedKey
argument_list|,
name|weight
argument_list|,
name|payload
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
comment|// Don't just sort original list, to avoid VERBOSE
comment|// altering the test:
name|List
argument_list|<
name|TermFreq2
argument_list|>
name|sorted
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|slowCompletor
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
for|for
control|(
name|TermFreq2
name|ent
range|:
name|sorted
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  surface='"
operator|+
name|ent
operator|.
name|surfaceForm
operator|+
literal|"' analyzed='"
operator|+
name|ent
operator|.
name|analyzedForm
operator|+
literal|"' weight="
operator|+
name|ent
operator|.
name|weight
argument_list|)
expr_stmt|;
block|}
block|}
name|Analyzer
name|a
init|=
operator|new
name|MockTokenEatingAnalyzer
argument_list|(
name|numStopChars
argument_list|,
name|preserveHoles
argument_list|)
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|preserveSep
condition|?
name|AnalyzingSuggester
operator|.
name|PRESERVE_SEP
else|:
literal|0
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|doPayloads
condition|)
block|{
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|shuffle
argument_list|(
name|payloadKeys
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|shuffle
argument_list|(
name|keys
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|prefix
range|:
name|allPrefixes
control|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nTEST: prefix="
operator|+
name|prefix
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|topN
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|r
init|=
name|suggester
operator|.
name|lookup
argument_list|(
name|TestUtil
operator|.
name|stringToCharSequence
argument_list|(
name|prefix
argument_list|,
name|random
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|,
name|topN
argument_list|)
decl_stmt|;
comment|// 2. go thru whole set to find suggestions:
name|List
argument_list|<
name|TermFreq2
argument_list|>
name|matches
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// "Analyze" the key:
name|String
index|[]
name|tokens
init|=
name|prefix
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|lastRemoved
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tokens
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|token
init|=
name|tokens
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|preserveSep
operator|&&
name|builder
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|builder
operator|.
name|toString
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|""
operator|+
name|SEP
argument_list|)
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|SEP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|&&
name|isStopChar
argument_list|(
name|token
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|numStopChars
argument_list|)
condition|)
block|{
if|if
condition|(
name|preserveSep
operator|&&
name|preserveHoles
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|SEP
argument_list|)
expr_stmt|;
block|}
name|lastRemoved
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|.
name|append
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|lastRemoved
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|String
name|analyzedKey
init|=
name|builder
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|// Remove trailing sep/holes (TokenStream.end() does
comment|// not tell us any trailing holes, yet ... there is an
comment|// issue open for this):
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|s
init|=
name|analyzedKey
operator|.
name|replaceAll
argument_list|(
name|SEP
operator|+
literal|"$"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
name|analyzedKey
argument_list|)
condition|)
block|{
break|break;
block|}
name|analyzedKey
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|analyzedKey
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Currently suggester can't suggest from the empty
comment|// string!  You get no results, not all results...
continue|continue;
block|}
if|if
condition|(
name|preserveSep
operator|&&
operator|(
name|prefix
operator|.
name|endsWith
argument_list|(
literal|" "
argument_list|)
operator|||
name|lastRemoved
operator|)
condition|)
block|{
name|analyzedKey
operator|+=
name|SEP
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  analyzed: "
operator|+
name|analyzedKey
argument_list|)
expr_stmt|;
block|}
comment|// TODO: could be faster... but its slowCompletor for a reason
for|for
control|(
name|TermFreq2
name|e
range|:
name|slowCompletor
control|)
block|{
if|if
condition|(
name|e
operator|.
name|analyzedForm
operator|.
name|startsWith
argument_list|(
name|analyzedKey
argument_list|)
condition|)
block|{
name|matches
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
name|numStopChars
operator|>
literal|0
operator|||
name|matches
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|matches
argument_list|,
operator|new
name|Comparator
argument_list|<
name|TermFreq2
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|TermFreq2
name|left
parameter_list|,
name|TermFreq2
name|right
parameter_list|)
block|{
name|int
name|cmp
init|=
name|Float
operator|.
name|compare
argument_list|(
name|right
operator|.
name|weight
argument_list|,
name|left
operator|.
name|weight
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
return|return
name|left
operator|.
name|analyzedForm
operator|.
name|compareTo
argument_list|(
name|right
operator|.
name|analyzedForm
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|cmp
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|matches
operator|.
name|size
argument_list|()
operator|>
name|topN
condition|)
block|{
name|matches
operator|=
name|matches
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|topN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  expected:"
argument_list|)
expr_stmt|;
for|for
control|(
name|TermFreq2
name|lr
range|:
name|matches
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    key="
operator|+
name|lr
operator|.
name|surfaceForm
operator|+
literal|" weight="
operator|+
name|lr
operator|.
name|weight
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  actual:"
argument_list|)
expr_stmt|;
for|for
control|(
name|LookupResult
name|lr
range|:
name|r
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    key="
operator|+
name|lr
operator|.
name|key
operator|+
literal|" weight="
operator|+
name|lr
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
name|matches
operator|.
name|size
argument_list|()
argument_list|,
name|r
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|hit
init|=
literal|0
init|;
name|hit
operator|<
name|r
operator|.
name|size
argument_list|()
condition|;
name|hit
operator|++
control|)
block|{
comment|//System.out.println("  check hit " + hit);
name|assertEquals
argument_list|(
name|matches
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|surfaceForm
operator|.
name|toString
argument_list|()
argument_list|,
name|r
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|matches
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|weight
argument_list|,
name|r
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|value
argument_list|,
literal|0f
argument_list|)
expr_stmt|;
if|if
condition|(
name|doPayloads
condition|)
block|{
name|assertEquals
argument_list|(
name|matches
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|payload
argument_list|,
name|r
operator|.
name|get
argument_list|(
name|hit
argument_list|)
operator|.
name|payload
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|testMaxSurfaceFormsPerAnalyzedForm
specifier|public
name|void
name|testMaxSurfaceFormsPerAnalyzedForm
parameter_list|()
throws|throws
name|Exception
block|{
name|Analyzer
name|a
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|shuffle
argument_list|(
operator|new
name|Input
argument_list|(
literal|"a"
argument_list|,
literal|40
argument_list|)
argument_list|,
operator|new
name|Input
argument_list|(
literal|"a "
argument_list|,
literal|50
argument_list|)
argument_list|,
operator|new
name|Input
argument_list|(
literal|" a"
argument_list|,
literal|60
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"a"
argument_list|,
literal|false
argument_list|,
literal|5
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|" a"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|60
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"a "
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
DECL|method|testQueueExhaustion
specifier|public
name|void
name|testQueueExhaustion
parameter_list|()
throws|throws
name|Exception
block|{
name|Analyzer
name|a
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|AnalyzingSuggester
operator|.
name|EXACT_FIRST
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
operator|new
name|Input
index|[]
block|{
operator|new
name|Input
argument_list|(
literal|"a"
argument_list|,
literal|2
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"a b c"
argument_list|,
literal|3
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"a c a"
argument_list|,
literal|1
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"a c b"
argument_list|,
literal|1
argument_list|)
block|,         }
argument_list|)
argument_list|)
expr_stmt|;
name|suggester
operator|.
name|lookup
argument_list|(
literal|"a"
argument_list|,
literal|false
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
DECL|method|testExactFirstMissingResult
specifier|public
name|void
name|testExactFirstMissingResult
parameter_list|()
throws|throws
name|Exception
block|{
name|Analyzer
name|a
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|AnalyzingSuggester
operator|.
name|EXACT_FIRST
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
operator|new
name|Input
index|[]
block|{
operator|new
name|Input
argument_list|(
literal|"a"
argument_list|,
literal|5
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"a b"
argument_list|,
literal|3
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"a c"
argument_list|,
literal|4
argument_list|)
block|,         }
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|suggester
operator|.
name|getCount
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"a"
argument_list|,
literal|false
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"a"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"a c"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"a b"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
comment|// Try again after save/load:
name|File
name|tmpDir
init|=
name|TestUtil
operator|.
name|getTempDir
argument_list|(
literal|"AnalyzingSuggesterTest"
argument_list|)
decl_stmt|;
name|tmpDir
operator|.
name|mkdir
argument_list|()
expr_stmt|;
name|File
name|path
init|=
operator|new
name|File
argument_list|(
name|tmpDir
argument_list|,
literal|"suggester"
argument_list|)
decl_stmt|;
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|store
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
name|InputStream
name|is
init|=
operator|new
name|FileInputStream
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|load
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|suggester
operator|.
name|getCount
argument_list|()
argument_list|)
expr_stmt|;
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"a"
argument_list|,
literal|false
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"a"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"a c"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"a b"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
DECL|method|testDupSurfaceFormsMissingResults
specifier|public
name|void
name|testDupSurfaceFormsMissingResults
parameter_list|()
throws|throws
name|Exception
block|{
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|SIMPLE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|TokenStream
name|getTokenStream
parameter_list|()
block|{
return|return
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"hairy"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"smelly"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"dog"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,               }
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setReader
parameter_list|(
specifier|final
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{           }
block|}
return|;
block|}
block|}
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
name|shuffle
argument_list|(
operator|new
name|Input
argument_list|(
literal|"hambone"
argument_list|,
literal|6
argument_list|)
argument_list|,
operator|new
name|Input
argument_list|(
literal|"nellie"
argument_list|,
literal|5
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"nellie"
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"hambone"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"nellie"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
comment|// Try again after save/load:
name|File
name|tmpDir
init|=
name|TestUtil
operator|.
name|getTempDir
argument_list|(
literal|"AnalyzingSuggesterTest"
argument_list|)
decl_stmt|;
name|tmpDir
operator|.
name|mkdir
argument_list|()
expr_stmt|;
name|File
name|path
init|=
operator|new
name|File
argument_list|(
name|tmpDir
argument_list|,
literal|"suggester"
argument_list|)
decl_stmt|;
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|store
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
name|InputStream
name|is
init|=
operator|new
name|FileInputStream
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|load
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"nellie"
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"hambone"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"nellie"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
DECL|method|testDupSurfaceFormsMissingResults2
specifier|public
name|void
name|testDupSurfaceFormsMissingResults2
parameter_list|()
throws|throws
name|Exception
block|{
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|SIMPLE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|)
block|{
name|int
name|count
decl_stmt|;
annotation|@
name|Override
specifier|public
name|TokenStream
name|getTokenStream
parameter_list|()
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|count
operator|++
expr_stmt|;
return|return
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"p"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"q"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"r"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
block|,
name|token
argument_list|(
literal|"s"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
block|,                 }
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|token
argument_list|(
literal|"p"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|,                 }
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setReader
parameter_list|(
specifier|final
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{           }
block|}
return|;
block|}
block|}
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
operator|new
name|Input
index|[]
block|{
operator|new
name|Input
argument_list|(
literal|"a"
argument_list|,
literal|6
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"b"
argument_list|,
literal|5
argument_list|)
block|,         }
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"a"
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"a"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"b"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
comment|// Try again after save/load:
name|File
name|tmpDir
init|=
name|TestUtil
operator|.
name|getTempDir
argument_list|(
literal|"AnalyzingSuggesterTest"
argument_list|)
decl_stmt|;
name|tmpDir
operator|.
name|mkdir
argument_list|()
expr_stmt|;
name|File
name|path
init|=
operator|new
name|File
argument_list|(
name|tmpDir
argument_list|,
literal|"suggester"
argument_list|)
decl_stmt|;
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|store
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
name|InputStream
name|is
init|=
operator|new
name|FileInputStream
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|load
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
name|results
operator|=
name|suggester
operator|.
name|lookup
argument_list|(
literal|"a"
argument_list|,
literal|false
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"a"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"b"
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|key
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
DECL|method|test0ByteKeys
specifier|public
name|void
name|test0ByteKeys
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|SIMPLE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|)
block|{
name|int
name|tokenStreamCounter
init|=
literal|0
decl_stmt|;
specifier|final
name|TokenStream
index|[]
name|tokenStreams
init|=
operator|new
name|TokenStream
index|[]
block|{
operator|new
name|CannedBinaryTokenStream
argument_list|(
operator|new
name|BinaryToken
index|[]
block|{
name|token
argument_list|(
operator|new
name|BytesRef
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|}
argument_list|)
argument_list|)
block|,                 }
argument_list|)
block|,
operator|new
name|CannedBinaryTokenStream
argument_list|(
operator|new
name|BinaryToken
index|[]
block|{
name|token
argument_list|(
operator|new
name|BytesRef
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|0x0
block|,
literal|0x0
block|}
argument_list|)
argument_list|)
block|,                 }
argument_list|)
block|,
operator|new
name|CannedBinaryTokenStream
argument_list|(
operator|new
name|BinaryToken
index|[]
block|{
name|token
argument_list|(
operator|new
name|BytesRef
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|}
argument_list|)
argument_list|)
block|,                 }
argument_list|)
block|,
operator|new
name|CannedBinaryTokenStream
argument_list|(
operator|new
name|BinaryToken
index|[]
block|{
name|token
argument_list|(
operator|new
name|BytesRef
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|0x0
block|,
literal|0x0
block|}
argument_list|)
argument_list|)
block|,                 }
argument_list|)
block|,             }
decl_stmt|;
annotation|@
name|Override
specifier|public
name|TokenStream
name|getTokenStream
parameter_list|()
block|{
name|TokenStream
name|result
init|=
name|tokenStreams
index|[
name|tokenStreamCounter
index|]
decl_stmt|;
name|tokenStreamCounter
operator|++
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setReader
parameter_list|(
specifier|final
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{             }
block|}
return|;
block|}
block|}
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
operator|new
name|Input
index|[]
block|{
operator|new
name|Input
argument_list|(
literal|"a a"
argument_list|,
literal|50
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"a b"
argument_list|,
literal|50
argument_list|)
block|,         }
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testDupSurfaceFormsMissingResults3
specifier|public
name|void
name|testDupSurfaceFormsMissingResults3
parameter_list|()
throws|throws
name|Exception
block|{
name|Analyzer
name|a
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|AnalyzingSuggester
operator|.
name|PRESERVE_SEP
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
operator|new
name|Input
index|[]
block|{
operator|new
name|Input
argument_list|(
literal|"a a"
argument_list|,
literal|7
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"a a"
argument_list|,
literal|7
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"a c"
argument_list|,
literal|6
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"a c"
argument_list|,
literal|3
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"a b"
argument_list|,
literal|5
argument_list|)
block|,         }
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[a a/7, a c/6, a b/5]"
argument_list|,
name|suggester
operator|.
name|lookup
argument_list|(
literal|"a"
argument_list|,
literal|false
argument_list|,
literal|3
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testEndingSpace
specifier|public
name|void
name|testEndingSpace
parameter_list|()
throws|throws
name|Exception
block|{
name|Analyzer
name|a
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|AnalyzingSuggester
operator|.
name|PRESERVE_SEP
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
operator|new
name|Input
index|[]
block|{
operator|new
name|Input
argument_list|(
literal|"i love lucy"
argument_list|,
literal|7
argument_list|)
block|,
operator|new
name|Input
argument_list|(
literal|"isla de muerta"
argument_list|,
literal|8
argument_list|)
block|,         }
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[isla de muerta/8, i love lucy/7]"
argument_list|,
name|suggester
operator|.
name|lookup
argument_list|(
literal|"i"
argument_list|,
literal|false
argument_list|,
literal|3
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[i love lucy/7]"
argument_list|,
name|suggester
operator|.
name|lookup
argument_list|(
literal|"i "
argument_list|,
literal|false
argument_list|,
literal|3
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTooManyExpansions
specifier|public
name|void
name|testTooManyExpansions
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Analyzer
name|a
init|=
operator|new
name|Analyzer
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|createComponents
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|MockTokenizer
argument_list|(
name|MockTokenizer
operator|.
name|SIMPLE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|tokenizer
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|TokenStream
name|getTokenStream
parameter_list|()
block|{
name|Token
name|a
init|=
operator|new
name|Token
argument_list|(
literal|"a"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|a
operator|.
name|setPositionIncrement
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|Token
name|b
init|=
operator|new
name|Token
argument_list|(
literal|"b"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|b
operator|.
name|setPositionIncrement
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|new
name|CannedTokenStream
argument_list|(
operator|new
name|Token
index|[]
block|{
name|a
block|,
name|b
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setReader
parameter_list|(
specifier|final
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{             }
block|}
return|;
block|}
block|}
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
operator|new
name|Input
index|[]
block|{
operator|new
name|Input
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|)
block|}
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[a/1]"
argument_list|,
name|suggester
operator|.
name|lookup
argument_list|(
literal|"a"
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testIllegalLookupArgument
specifier|public
name|void
name|testIllegalLookupArgument
parameter_list|()
throws|throws
name|Exception
block|{
name|Analyzer
name|a
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|AnalyzingSuggester
name|suggester
init|=
operator|new
name|AnalyzingSuggester
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|suggester
operator|.
name|build
argument_list|(
operator|new
name|InputArrayIterator
argument_list|(
operator|new
name|Input
index|[]
block|{
operator|new
name|Input
argument_list|(
literal|"Ð° Ð³Ð´Ðµ ÐÑÑÐ¸?"
argument_list|,
literal|7
argument_list|)
block|,     }
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|suggester
operator|.
name|lookup
argument_list|(
literal|"Ð°\u001E"
argument_list|,
literal|false
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"should throw IllegalArgumentException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// expected
block|}
try|try
block|{
name|suggester
operator|.
name|lookup
argument_list|(
literal|"Ð°\u001F"
argument_list|,
literal|false
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"should throw IllegalArgumentException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// expected
block|}
block|}
DECL|method|shuffle
specifier|static
specifier|final
name|Iterable
argument_list|<
name|Input
argument_list|>
name|shuffle
parameter_list|(
name|Input
modifier|...
name|values
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Input
argument_list|>
name|asList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|values
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|Input
name|value
range|:
name|values
control|)
block|{
name|asList
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|shuffle
argument_list|(
name|asList
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|asList
return|;
block|}
block|}
end_class
end_unit
