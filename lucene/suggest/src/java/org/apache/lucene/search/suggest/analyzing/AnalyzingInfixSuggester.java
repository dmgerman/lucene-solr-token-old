begin_unit
begin_package
DECL|package|org.apache.lucene.search.suggest.analyzing
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|analyzing
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|AnalyzerWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|ngram
operator|.
name|EdgeNGramTokenFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|CharTermAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|OffsetAttribute
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene46
operator|.
name|Lucene46Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|BinaryDocValuesField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|NumericDocValuesField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|TextField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|AtomicReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|AtomicReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|BinaryDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriterConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|NumericDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SlowCompositeReaderWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|sorter
operator|.
name|Sorter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|sorter
operator|.
name|SortingAtomicReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Collector
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|PrefixQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|ScoreDoc
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Scorer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TermQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TopDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|Lookup
operator|.
name|LookupResult
import|;
end_import
begin_comment
comment|// javadocs
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|InputIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|Lookup
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
import|;
end_import
begin_comment
comment|// TODO:
end_comment
begin_comment
comment|//   - a PostingsFormat that stores super-high-freq terms as
end_comment
begin_comment
comment|//     a bitset should be a win for the prefix terms?
end_comment
begin_comment
comment|//     (LUCENE-5052)
end_comment
begin_comment
comment|//   - we could allow NRT here, if we sort index as we go
end_comment
begin_comment
comment|//     (SortingMergePolicy) -- http://svn.apache.org/viewvc?view=revision&revision=1459808
end_comment
begin_comment
comment|/** Analyzes the input text and then suggests matches based  *  on prefix matches to any tokens in the indexed text.  *  This also highlights the tokens that match.  *  *<p>This just uses an ordinary Lucene index.  It  *  supports payloads, and records these as a  *  {@link BinaryDocValues} field.  Matches are sorted only  *  by the suggest weight; it would be nice to support  *  blended score + weight sort in the future.  This means  *  this suggester best applies when there is a strong  *  apriori ranking of all the suggestions. */
end_comment
begin_class
DECL|class|AnalyzingInfixSuggester
specifier|public
class|class
name|AnalyzingInfixSuggester
extends|extends
name|Lookup
implements|implements
name|Closeable
block|{
comment|/** Field name used for the indexed text. */
DECL|field|TEXT_FIELD_NAME
specifier|protected
specifier|final
specifier|static
name|String
name|TEXT_FIELD_NAME
init|=
literal|"text"
decl_stmt|;
comment|/** Analyzer used at search time */
DECL|field|queryAnalyzer
specifier|protected
specifier|final
name|Analyzer
name|queryAnalyzer
decl_stmt|;
comment|/** Analyzer used at index time */
DECL|field|indexAnalyzer
specifier|protected
specifier|final
name|Analyzer
name|indexAnalyzer
decl_stmt|;
DECL|field|matchVersion
specifier|final
name|Version
name|matchVersion
decl_stmt|;
DECL|field|indexPath
specifier|private
specifier|final
name|File
name|indexPath
decl_stmt|;
DECL|field|minPrefixChars
specifier|final
name|int
name|minPrefixChars
decl_stmt|;
DECL|field|dir
specifier|private
name|Directory
name|dir
decl_stmt|;
comment|/** Number of entries the lookup was built with */
DECL|field|count
specifier|private
name|long
name|count
init|=
literal|0
decl_stmt|;
comment|/** {@link IndexSearcher} used for lookups. */
DECL|field|searcher
specifier|protected
name|IndexSearcher
name|searcher
decl_stmt|;
comment|/** DocValuesField holding the payloads; null if payloads were not indexed. */
DECL|field|payloadsDV
specifier|protected
name|BinaryDocValues
name|payloadsDV
decl_stmt|;
comment|/** DocValuesField holding each suggestion's text. */
DECL|field|textDV
specifier|protected
name|BinaryDocValues
name|textDV
decl_stmt|;
comment|/** DocValuesField holding each suggestion's weight. */
DECL|field|weightsDV
specifier|protected
name|NumericDocValues
name|weightsDV
decl_stmt|;
comment|/** Default minimum number of leading characters before    *  PrefixQuery is used (4). */
DECL|field|DEFAULT_MIN_PREFIX_CHARS
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_PREFIX_CHARS
init|=
literal|4
decl_stmt|;
comment|/** Create a new instance, loading from a previously built    *  directory, if it exists. */
DECL|method|AnalyzingInfixSuggester
specifier|public
name|AnalyzingInfixSuggester
parameter_list|(
name|Version
name|matchVersion
parameter_list|,
name|File
name|indexPath
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|matchVersion
argument_list|,
name|indexPath
argument_list|,
name|analyzer
argument_list|,
name|analyzer
argument_list|,
name|DEFAULT_MIN_PREFIX_CHARS
argument_list|)
expr_stmt|;
block|}
comment|/** Create a new instance, loading from a previously built    *  directory, if it exists.    *    *  @param minPrefixChars Minimum number of leading characters    *     before PrefixQuery is used (default 4).    *     Prefixes shorter than this are indexed as character    *     ngrams (increasing index size but making lookups    *     faster).    */
DECL|method|AnalyzingInfixSuggester
specifier|public
name|AnalyzingInfixSuggester
parameter_list|(
name|Version
name|matchVersion
parameter_list|,
name|File
name|indexPath
parameter_list|,
name|Analyzer
name|indexAnalyzer
parameter_list|,
name|Analyzer
name|queryAnalyzer
parameter_list|,
name|int
name|minPrefixChars
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|minPrefixChars
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"minPrefixChars must be>= 0; got: "
operator|+
name|minPrefixChars
argument_list|)
throw|;
block|}
name|this
operator|.
name|queryAnalyzer
operator|=
name|queryAnalyzer
expr_stmt|;
name|this
operator|.
name|indexAnalyzer
operator|=
name|indexAnalyzer
expr_stmt|;
name|this
operator|.
name|matchVersion
operator|=
name|matchVersion
expr_stmt|;
name|this
operator|.
name|indexPath
operator|=
name|indexPath
expr_stmt|;
name|this
operator|.
name|minPrefixChars
operator|=
name|minPrefixChars
expr_stmt|;
name|dir
operator|=
name|getDirectory
argument_list|(
name|indexPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|DirectoryReader
operator|.
name|indexExists
argument_list|(
name|dir
argument_list|)
condition|)
block|{
comment|// Already built; open it:
name|IndexReader
name|reader
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|searcher
operator|=
operator|new
name|IndexSearcher
argument_list|(
name|reader
argument_list|)
expr_stmt|;
comment|// This will just be null if app didn't pass payloads to build():
comment|// TODO: maybe just stored fields?  they compress...
name|payloadsDV
operator|=
name|MultiDocValues
operator|.
name|getBinaryValues
argument_list|(
name|searcher
operator|.
name|getIndexReader
argument_list|()
argument_list|,
literal|"payloads"
argument_list|)
expr_stmt|;
name|weightsDV
operator|=
name|MultiDocValues
operator|.
name|getNumericValues
argument_list|(
name|searcher
operator|.
name|getIndexReader
argument_list|()
argument_list|,
literal|"weight"
argument_list|)
expr_stmt|;
name|textDV
operator|=
name|MultiDocValues
operator|.
name|getBinaryValues
argument_list|(
name|searcher
operator|.
name|getIndexReader
argument_list|()
argument_list|,
name|TEXT_FIELD_NAME
argument_list|)
expr_stmt|;
name|count
operator|=
name|reader
operator|.
name|numDocs
argument_list|()
expr_stmt|;
assert|assert
name|textDV
operator|!=
literal|null
assert|;
block|}
block|}
comment|/** Override this to customize index settings, e.g. which    *  codec to use. */
DECL|method|getIndexWriterConfig
specifier|protected
name|IndexWriterConfig
name|getIndexWriterConfig
parameter_list|(
name|Version
name|matchVersion
parameter_list|,
name|Analyzer
name|indexAnalyzer
parameter_list|)
block|{
name|IndexWriterConfig
name|iwc
init|=
operator|new
name|IndexWriterConfig
argument_list|(
name|matchVersion
argument_list|,
name|indexAnalyzer
argument_list|)
decl_stmt|;
name|iwc
operator|.
name|setCodec
argument_list|(
operator|new
name|Lucene46Codec
argument_list|()
argument_list|)
expr_stmt|;
name|iwc
operator|.
name|setOpenMode
argument_list|(
name|IndexWriterConfig
operator|.
name|OpenMode
operator|.
name|CREATE
argument_list|)
expr_stmt|;
return|return
name|iwc
return|;
block|}
comment|/** Subclass can override to choose a specific {@link    *  Directory} implementation. */
DECL|method|getDirectory
specifier|protected
name|Directory
name|getDirectory
parameter_list|(
name|File
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|FSDirectory
operator|.
name|open
argument_list|(
name|path
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|build
specifier|public
name|void
name|build
parameter_list|(
name|InputIterator
name|iter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|searcher
operator|!=
literal|null
condition|)
block|{
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|searcher
operator|=
literal|null
expr_stmt|;
block|}
name|Directory
name|dirTmp
init|=
name|getDirectory
argument_list|(
operator|new
name|File
argument_list|(
name|indexPath
operator|.
name|toString
argument_list|()
operator|+
literal|".tmp"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexWriter
name|w
init|=
literal|null
decl_stmt|;
name|IndexWriter
name|w2
init|=
literal|null
decl_stmt|;
name|AtomicReader
name|r
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
try|try
block|{
name|Analyzer
name|gramAnalyzer
init|=
operator|new
name|AnalyzerWrapper
argument_list|(
name|Analyzer
operator|.
name|PER_FIELD_REUSE_STRATEGY
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|Analyzer
name|getWrappedAnalyzer
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
name|indexAnalyzer
return|;
block|}
annotation|@
name|Override
specifier|protected
name|TokenStreamComponents
name|wrapComponents
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|TokenStreamComponents
name|components
parameter_list|)
block|{
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
literal|"textgrams"
argument_list|)
operator|&&
name|minPrefixChars
operator|>
literal|0
condition|)
block|{
return|return
operator|new
name|TokenStreamComponents
argument_list|(
name|components
operator|.
name|getTokenizer
argument_list|()
argument_list|,
operator|new
name|EdgeNGramTokenFilter
argument_list|(
name|matchVersion
argument_list|,
name|components
operator|.
name|getTokenStream
argument_list|()
argument_list|,
literal|1
argument_list|,
name|minPrefixChars
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|components
return|;
block|}
block|}
block|}
decl_stmt|;
name|w
operator|=
operator|new
name|IndexWriter
argument_list|(
name|dirTmp
argument_list|,
name|getIndexWriterConfig
argument_list|(
name|matchVersion
argument_list|,
name|gramAnalyzer
argument_list|)
argument_list|)
expr_stmt|;
name|BytesRef
name|text
decl_stmt|;
name|Document
name|doc
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
name|FieldType
name|ft
init|=
name|getTextFieldType
argument_list|()
decl_stmt|;
name|Field
name|textField
init|=
operator|new
name|Field
argument_list|(
name|TEXT_FIELD_NAME
argument_list|,
literal|""
argument_list|,
name|ft
argument_list|)
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|textField
argument_list|)
expr_stmt|;
name|Field
name|textGramField
init|=
operator|new
name|Field
argument_list|(
literal|"textgrams"
argument_list|,
literal|""
argument_list|,
name|ft
argument_list|)
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|textGramField
argument_list|)
expr_stmt|;
name|Field
name|textDVField
init|=
operator|new
name|BinaryDocValuesField
argument_list|(
name|TEXT_FIELD_NAME
argument_list|,
operator|new
name|BytesRef
argument_list|()
argument_list|)
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|textDVField
argument_list|)
expr_stmt|;
comment|// TODO: use threads...?
name|Field
name|weightField
init|=
operator|new
name|NumericDocValuesField
argument_list|(
literal|"weight"
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|weightField
argument_list|)
expr_stmt|;
name|Field
name|payloadField
decl_stmt|;
if|if
condition|(
name|iter
operator|.
name|hasPayloads
argument_list|()
condition|)
block|{
name|payloadField
operator|=
operator|new
name|BinaryDocValuesField
argument_list|(
literal|"payloads"
argument_list|,
operator|new
name|BytesRef
argument_list|()
argument_list|)
expr_stmt|;
name|doc
operator|.
name|add
argument_list|(
name|payloadField
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|payloadField
operator|=
literal|null
expr_stmt|;
block|}
comment|//long t0 = System.nanoTime();
while|while
condition|(
operator|(
name|text
operator|=
name|iter
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|String
name|textString
init|=
name|text
operator|.
name|utf8ToString
argument_list|()
decl_stmt|;
name|textField
operator|.
name|setStringValue
argument_list|(
name|textString
argument_list|)
expr_stmt|;
name|textGramField
operator|.
name|setStringValue
argument_list|(
name|textString
argument_list|)
expr_stmt|;
name|textDVField
operator|.
name|setBytesValue
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|weightField
operator|.
name|setLongValue
argument_list|(
name|iter
operator|.
name|weight
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|.
name|hasPayloads
argument_list|()
condition|)
block|{
name|payloadField
operator|.
name|setBytesValue
argument_list|(
name|iter
operator|.
name|payload
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|w
operator|.
name|addDocument
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|//System.out.println("initial indexing time: " + ((System.nanoTime()-t0)/1000000) + " msec");
name|r
operator|=
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|DirectoryReader
operator|.
name|open
argument_list|(
name|w
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|//long t1 = System.nanoTime();
name|w
operator|.
name|rollback
argument_list|()
expr_stmt|;
specifier|final
name|int
name|maxDoc
init|=
name|r
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
specifier|final
name|NumericDocValues
name|weights
init|=
name|r
operator|.
name|getNumericDocValues
argument_list|(
literal|"weight"
argument_list|)
decl_stmt|;
specifier|final
name|Sorter
operator|.
name|DocComparator
name|comparator
init|=
operator|new
name|Sorter
operator|.
name|DocComparator
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|int
name|docID1
parameter_list|,
name|int
name|docID2
parameter_list|)
block|{
specifier|final
name|long
name|v1
init|=
name|weights
operator|.
name|get
argument_list|(
name|docID1
argument_list|)
decl_stmt|;
specifier|final
name|long
name|v2
init|=
name|weights
operator|.
name|get
argument_list|(
name|docID2
argument_list|)
decl_stmt|;
comment|// Reverse sort (highest weight first);
comment|// java7 only:
comment|//return Long.compare(v2, v1);
if|if
condition|(
name|v1
operator|>
name|v2
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|v1
operator|<
name|v2
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
decl_stmt|;
name|r
operator|=
name|SortingAtomicReader
operator|.
name|wrap
argument_list|(
name|r
argument_list|,
operator|new
name|Sorter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Sorter
operator|.
name|DocMap
name|sort
parameter_list|(
name|AtomicReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|Sorter
operator|.
name|sort
argument_list|(
name|maxDoc
argument_list|,
name|comparator
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getID
parameter_list|()
block|{
return|return
literal|"Weight"
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|w2
operator|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|getIndexWriterConfig
argument_list|(
name|matchVersion
argument_list|,
name|indexAnalyzer
argument_list|)
argument_list|)
expr_stmt|;
name|w2
operator|.
name|addIndexes
argument_list|(
operator|new
name|IndexReader
index|[]
block|{
name|r
block|}
argument_list|)
expr_stmt|;
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
comment|//System.out.println("sort time: " + ((System.nanoTime()-t1)/1000000) + " msec");
name|searcher
operator|=
operator|new
name|IndexSearcher
argument_list|(
name|DirectoryReader
operator|.
name|open
argument_list|(
name|w2
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|w2
operator|.
name|close
argument_list|()
expr_stmt|;
name|payloadsDV
operator|=
name|MultiDocValues
operator|.
name|getBinaryValues
argument_list|(
name|searcher
operator|.
name|getIndexReader
argument_list|()
argument_list|,
literal|"payloads"
argument_list|)
expr_stmt|;
name|weightsDV
operator|=
name|MultiDocValues
operator|.
name|getNumericValues
argument_list|(
name|searcher
operator|.
name|getIndexReader
argument_list|()
argument_list|,
literal|"weight"
argument_list|)
expr_stmt|;
name|textDV
operator|=
name|MultiDocValues
operator|.
name|getBinaryValues
argument_list|(
name|searcher
operator|.
name|getIndexReader
argument_list|()
argument_list|,
name|TEXT_FIELD_NAME
argument_list|)
expr_stmt|;
assert|assert
name|textDV
operator|!=
literal|null
assert|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|w
argument_list|,
name|w2
argument_list|,
name|r
argument_list|,
name|dirTmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|w
argument_list|,
name|w2
argument_list|,
name|r
argument_list|,
name|dirTmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Subclass can override this method to change the field type of the text field    * e.g. to change the index options    */
DECL|method|getTextFieldType
specifier|protected
name|FieldType
name|getTextFieldType
parameter_list|()
block|{
name|FieldType
name|ft
init|=
operator|new
name|FieldType
argument_list|(
name|TextField
operator|.
name|TYPE_NOT_STORED
argument_list|)
decl_stmt|;
name|ft
operator|.
name|setIndexOptions
argument_list|(
name|IndexOptions
operator|.
name|DOCS_ONLY
argument_list|)
expr_stmt|;
name|ft
operator|.
name|setOmitNorms
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|ft
return|;
block|}
annotation|@
name|Override
DECL|method|lookup
specifier|public
name|List
argument_list|<
name|LookupResult
argument_list|>
name|lookup
parameter_list|(
name|CharSequence
name|key
parameter_list|,
name|boolean
name|onlyMorePopular
parameter_list|,
name|int
name|num
parameter_list|)
block|{
return|return
name|lookup
argument_list|(
name|key
argument_list|,
name|num
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** This is called if the last token isn't ended    *  (e.g. user did not type a space after it).  Return an    *  appropriate Query clause to add to the BooleanQuery. */
DECL|method|getLastTokenQuery
specifier|protected
name|Query
name|getLastTokenQuery
parameter_list|(
name|String
name|token
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|token
operator|.
name|length
argument_list|()
operator|<
name|minPrefixChars
condition|)
block|{
comment|// The leading ngram was directly indexed:
return|return
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
literal|"textgrams"
argument_list|,
name|token
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|new
name|PrefixQuery
argument_list|(
operator|new
name|Term
argument_list|(
name|TEXT_FIELD_NAME
argument_list|,
name|token
argument_list|)
argument_list|)
return|;
block|}
comment|/** Retrieve suggestions, specifying whether all terms    *  must match ({@code allTermsRequired}) and whether the hits    *  should be highlighted ({@code doHighlight}). */
DECL|method|lookup
specifier|public
name|List
argument_list|<
name|LookupResult
argument_list|>
name|lookup
parameter_list|(
name|CharSequence
name|key
parameter_list|,
name|int
name|num
parameter_list|,
name|boolean
name|allTermsRequired
parameter_list|,
name|boolean
name|doHighlight
parameter_list|)
block|{
if|if
condition|(
name|searcher
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"suggester was not built"
argument_list|)
throw|;
block|}
specifier|final
name|BooleanClause
operator|.
name|Occur
name|occur
decl_stmt|;
if|if
condition|(
name|allTermsRequired
condition|)
block|{
name|occur
operator|=
name|BooleanClause
operator|.
name|Occur
operator|.
name|MUST
expr_stmt|;
block|}
else|else
block|{
name|occur
operator|=
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
expr_stmt|;
block|}
try|try
init|(
name|TokenStream
name|ts
init|=
name|queryAnalyzer
operator|.
name|tokenStream
argument_list|(
literal|""
argument_list|,
operator|new
name|StringReader
argument_list|(
name|key
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
init|)
block|{
comment|//long t0 = System.currentTimeMillis();
name|ts
operator|.
name|reset
argument_list|()
expr_stmt|;
specifier|final
name|CharTermAttribute
name|termAtt
init|=
name|ts
operator|.
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|OffsetAttribute
name|offsetAtt
init|=
name|ts
operator|.
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|String
name|lastToken
init|=
literal|null
decl_stmt|;
name|BooleanQuery
name|query
init|=
operator|new
name|BooleanQuery
argument_list|()
decl_stmt|;
name|int
name|maxEndOffset
init|=
operator|-
literal|1
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|matchedTokens
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|ts
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
if|if
condition|(
name|lastToken
operator|!=
literal|null
condition|)
block|{
name|matchedTokens
operator|.
name|add
argument_list|(
name|lastToken
argument_list|)
expr_stmt|;
name|query
operator|.
name|add
argument_list|(
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
name|TEXT_FIELD_NAME
argument_list|,
name|lastToken
argument_list|)
argument_list|)
argument_list|,
name|occur
argument_list|)
expr_stmt|;
block|}
name|lastToken
operator|=
name|termAtt
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|lastToken
operator|!=
literal|null
condition|)
block|{
name|maxEndOffset
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxEndOffset
argument_list|,
name|offsetAtt
operator|.
name|endOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|ts
operator|.
name|end
argument_list|()
expr_stmt|;
name|String
name|prefixToken
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|lastToken
operator|!=
literal|null
condition|)
block|{
name|Query
name|lastQuery
decl_stmt|;
if|if
condition|(
name|maxEndOffset
operator|==
name|offsetAtt
operator|.
name|endOffset
argument_list|()
condition|)
block|{
comment|// Use PrefixQuery (or the ngram equivalent) when
comment|// there was no trailing discarded chars in the
comment|// string (e.g. whitespace), so that if query does
comment|// not end with a space we show prefix matches for
comment|// that token:
name|lastQuery
operator|=
name|getLastTokenQuery
argument_list|(
name|lastToken
argument_list|)
expr_stmt|;
name|prefixToken
operator|=
name|lastToken
expr_stmt|;
block|}
else|else
block|{
comment|// Use TermQuery for an exact match if there were
comment|// trailing discarded chars (e.g. whitespace), so
comment|// that if query ends with a space we only show
comment|// exact matches for that term:
name|matchedTokens
operator|.
name|add
argument_list|(
name|lastToken
argument_list|)
expr_stmt|;
name|lastQuery
operator|=
operator|new
name|TermQuery
argument_list|(
operator|new
name|Term
argument_list|(
name|TEXT_FIELD_NAME
argument_list|,
name|lastToken
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastQuery
operator|!=
literal|null
condition|)
block|{
name|query
operator|.
name|add
argument_list|(
name|lastQuery
argument_list|,
name|occur
argument_list|)
expr_stmt|;
block|}
block|}
name|ts
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// TODO: we could allow blended sort here, combining
comment|// weight w/ score.  Now we ignore score and sort only
comment|// by weight:
comment|//System.out.println("INFIX query=" + query);
name|Query
name|finalQuery
init|=
name|finishQuery
argument_list|(
name|query
argument_list|,
name|allTermsRequired
argument_list|)
decl_stmt|;
comment|// We sorted postings by weight during indexing, so we
comment|// only retrieve the first num hits now:
name|FirstNDocsCollector
name|c
init|=
operator|new
name|FirstNDocsCollector
argument_list|(
name|num
argument_list|)
decl_stmt|;
try|try
block|{
name|searcher
operator|.
name|search
argument_list|(
name|finalQuery
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FirstNDocsCollector
operator|.
name|DoneException
name|done
parameter_list|)
block|{       }
name|TopDocs
name|hits
init|=
name|c
operator|.
name|getHits
argument_list|()
decl_stmt|;
comment|// Slower way if postings are not pre-sorted by weight:
comment|// hits = searcher.search(query, null, num, new Sort(new SortField("weight", SortField.Type.LONG, true)));
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
name|createResults
argument_list|(
name|hits
argument_list|,
name|num
argument_list|,
name|key
argument_list|,
name|doHighlight
argument_list|,
name|matchedTokens
argument_list|,
name|prefixToken
argument_list|)
decl_stmt|;
comment|//System.out.println((System.currentTimeMillis() - t0) + " msec for infix suggest");
comment|//System.out.println(results);
return|return
name|results
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create the results based on the search hits.    * Can be overridden by subclass to add particular behavior (e.g. weight transformation)    * @throws IOException If there are problems reading fields from the underlying Lucene index.    */
DECL|method|createResults
specifier|protected
name|List
argument_list|<
name|LookupResult
argument_list|>
name|createResults
parameter_list|(
name|TopDocs
name|hits
parameter_list|,
name|int
name|num
parameter_list|,
name|CharSequence
name|charSequence
parameter_list|,
name|boolean
name|doHighlight
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|matchedTokens
parameter_list|,
name|String
name|prefixToken
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|LookupResult
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|LookupResult
argument_list|>
argument_list|()
decl_stmt|;
name|BytesRef
name|scratch
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hits
operator|.
name|scoreDocs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ScoreDoc
name|sd
init|=
name|hits
operator|.
name|scoreDocs
index|[
name|i
index|]
decl_stmt|;
name|textDV
operator|.
name|get
argument_list|(
name|sd
operator|.
name|doc
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|String
name|text
init|=
name|scratch
operator|.
name|utf8ToString
argument_list|()
decl_stmt|;
name|long
name|score
init|=
name|weightsDV
operator|.
name|get
argument_list|(
name|sd
operator|.
name|doc
argument_list|)
decl_stmt|;
name|BytesRef
name|payload
decl_stmt|;
if|if
condition|(
name|payloadsDV
operator|!=
literal|null
condition|)
block|{
name|payload
operator|=
operator|new
name|BytesRef
argument_list|()
expr_stmt|;
name|payloadsDV
operator|.
name|get
argument_list|(
name|sd
operator|.
name|doc
argument_list|,
name|payload
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|payload
operator|=
literal|null
expr_stmt|;
block|}
name|LookupResult
name|result
decl_stmt|;
if|if
condition|(
name|doHighlight
condition|)
block|{
name|Object
name|highlightKey
init|=
name|highlight
argument_list|(
name|text
argument_list|,
name|matchedTokens
argument_list|,
name|prefixToken
argument_list|)
decl_stmt|;
name|result
operator|=
operator|new
name|LookupResult
argument_list|(
name|highlightKey
operator|.
name|toString
argument_list|()
argument_list|,
name|highlightKey
argument_list|,
name|score
argument_list|,
name|payload
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
operator|new
name|LookupResult
argument_list|(
name|text
argument_list|,
name|score
argument_list|,
name|payload
argument_list|)
expr_stmt|;
block|}
name|results
operator|.
name|add
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
comment|/** Subclass can override this to tweak the Query before    *  searching. */
DECL|method|finishQuery
specifier|protected
name|Query
name|finishQuery
parameter_list|(
name|BooleanQuery
name|in
parameter_list|,
name|boolean
name|allTermsRequired
parameter_list|)
block|{
return|return
name|in
return|;
block|}
comment|/** Override this method to customize the Object    *  representing a single highlighted suggestions; the    *  result is set on each {@link    *  LookupResult#highlightKey} member. */
DECL|method|highlight
specifier|protected
name|Object
name|highlight
parameter_list|(
name|String
name|text
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|matchedTokens
parameter_list|,
name|String
name|prefixToken
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|TokenStream
name|ts
init|=
name|queryAnalyzer
operator|.
name|tokenStream
argument_list|(
literal|"text"
argument_list|,
operator|new
name|StringReader
argument_list|(
name|text
argument_list|)
argument_list|)
init|)
block|{
name|CharTermAttribute
name|termAtt
init|=
name|ts
operator|.
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|OffsetAttribute
name|offsetAtt
init|=
name|ts
operator|.
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|ts
operator|.
name|reset
argument_list|()
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ts
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
name|String
name|token
init|=
name|termAtt
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|startOffset
init|=
name|offsetAtt
operator|.
name|startOffset
argument_list|()
decl_stmt|;
name|int
name|endOffset
init|=
name|offsetAtt
operator|.
name|endOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|upto
operator|<
name|startOffset
condition|)
block|{
name|addNonMatch
argument_list|(
name|sb
argument_list|,
name|text
operator|.
name|substring
argument_list|(
name|upto
argument_list|,
name|startOffset
argument_list|)
argument_list|)
expr_stmt|;
name|upto
operator|=
name|startOffset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|upto
operator|>
name|startOffset
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|matchedTokens
operator|.
name|contains
argument_list|(
name|token
argument_list|)
condition|)
block|{
comment|// Token matches.
name|addWholeMatch
argument_list|(
name|sb
argument_list|,
name|text
operator|.
name|substring
argument_list|(
name|startOffset
argument_list|,
name|endOffset
argument_list|)
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|upto
operator|=
name|endOffset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prefixToken
operator|!=
literal|null
operator|&&
name|token
operator|.
name|startsWith
argument_list|(
name|prefixToken
argument_list|)
condition|)
block|{
name|addPrefixMatch
argument_list|(
name|sb
argument_list|,
name|text
operator|.
name|substring
argument_list|(
name|startOffset
argument_list|,
name|endOffset
argument_list|)
argument_list|,
name|token
argument_list|,
name|prefixToken
argument_list|)
expr_stmt|;
name|upto
operator|=
name|endOffset
expr_stmt|;
block|}
block|}
name|ts
operator|.
name|end
argument_list|()
expr_stmt|;
name|int
name|endOffset
init|=
name|offsetAtt
operator|.
name|endOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|upto
operator|<
name|endOffset
condition|)
block|{
name|addNonMatch
argument_list|(
name|sb
argument_list|,
name|text
operator|.
name|substring
argument_list|(
name|upto
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** Called while highlighting a single result, to append a    *  non-matching chunk of text from the suggestion to the    *  provided fragments list.    *  @param sb The {@code StringBuilder} to append to    *  @param text The text chunk to add    */
DECL|method|addNonMatch
specifier|protected
name|void
name|addNonMatch
parameter_list|(
name|StringBuilder
name|sb
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
comment|/** Called while highlighting a single result, to append    *  the whole matched token to the provided fragments list.    *  @param sb The {@code StringBuilder} to append to    *  @param surface The surface form (original) text    *  @param analyzed The analyzed token corresponding to the surface form text    */
DECL|method|addWholeMatch
specifier|protected
name|void
name|addWholeMatch
parameter_list|(
name|StringBuilder
name|sb
parameter_list|,
name|String
name|surface
parameter_list|,
name|String
name|analyzed
parameter_list|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"<b>"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|surface
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"</b>"
argument_list|)
expr_stmt|;
block|}
comment|/** Called while highlighting a single result, to append a    *  matched prefix token, to the provided fragments list.    *  @param sb The {@code StringBuilder} to append to    *  @param surface The fragment of the surface form    *        (indexed during {@link #build}, corresponding to    *        this match    *  @param analyzed The analyzed token that matched    *  @param prefixToken The prefix of the token that matched    */
DECL|method|addPrefixMatch
specifier|protected
name|void
name|addPrefixMatch
parameter_list|(
name|StringBuilder
name|sb
parameter_list|,
name|String
name|surface
parameter_list|,
name|String
name|analyzed
parameter_list|,
name|String
name|prefixToken
parameter_list|)
block|{
comment|// TODO: apps can try to invert their analysis logic
comment|// here, e.g. downcase the two before checking prefix:
name|sb
operator|.
name|append
argument_list|(
literal|"<b>"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|surface
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|prefixToken
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"</b>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefixToken
operator|.
name|length
argument_list|()
operator|<
name|surface
operator|.
name|length
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|surface
operator|.
name|substring
argument_list|(
name|prefixToken
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|FirstNDocsCollector
specifier|private
specifier|static
class|class
name|FirstNDocsCollector
extends|extends
name|Collector
block|{
DECL|field|docBase
specifier|private
name|int
name|docBase
decl_stmt|;
DECL|field|hits
specifier|private
specifier|final
name|int
index|[]
name|hits
decl_stmt|;
DECL|field|hitCount
specifier|private
name|int
name|hitCount
decl_stmt|;
DECL|class|DoneException
specifier|private
specifier|static
class|class
name|DoneException
extends|extends
name|RuntimeException
block|{     }
DECL|method|getHits
specifier|public
name|TopDocs
name|getHits
parameter_list|()
block|{
name|ScoreDoc
index|[]
name|scoreDocs
init|=
operator|new
name|ScoreDoc
index|[
name|hitCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hitCount
condition|;
name|i
operator|++
control|)
block|{
name|scoreDocs
index|[
name|i
index|]
operator|=
operator|new
name|ScoreDoc
argument_list|(
name|hits
index|[
name|i
index|]
argument_list|,
name|Float
operator|.
name|NaN
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|TopDocs
argument_list|(
name|hitCount
argument_list|,
name|scoreDocs
argument_list|,
name|Float
operator|.
name|NaN
argument_list|)
return|;
block|}
DECL|method|FirstNDocsCollector
specifier|public
name|FirstNDocsCollector
parameter_list|(
name|int
name|topN
parameter_list|)
block|{
name|hits
operator|=
operator|new
name|int
index|[
name|topN
index|]
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|collect
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
comment|//System.out.println("collect doc=" + doc);
name|hits
index|[
name|hitCount
operator|++
index|]
operator|=
name|doc
expr_stmt|;
if|if
condition|(
name|hitCount
operator|==
name|hits
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|DoneException
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|setScorer
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
block|{     }
annotation|@
name|Override
DECL|method|acceptsDocsOutOfOrder
specifier|public
name|boolean
name|acceptsDocsOutOfOrder
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|setNextReader
specifier|public
name|void
name|setNextReader
parameter_list|(
name|AtomicReaderContext
name|cxt
parameter_list|)
block|{
name|docBase
operator|=
name|cxt
operator|.
name|docBase
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|store
specifier|public
name|boolean
name|store
parameter_list|(
name|DataOutput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|load
specifier|public
name|boolean
name|load
parameter_list|(
name|DataInput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|searcher
operator|!=
literal|null
condition|)
block|{
name|searcher
operator|.
name|getIndexReader
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|searcher
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|!=
literal|null
condition|)
block|{
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|sizeInBytes
specifier|public
name|long
name|sizeInBytes
parameter_list|()
block|{
return|return
name|RamUsageEstimator
operator|.
name|sizeOf
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getCount
specifier|public
name|long
name|getCount
parameter_list|()
block|{
return|return
name|count
return|;
block|}
block|}
end_class
begin_empty_stmt
empty_stmt|;
end_empty_stmt
end_unit
