begin_unit
begin_package
DECL|package|org.apache.lucene.search.suggest.jaspell
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|suggest
operator|.
name|jaspell
package|;
end_package
begin_comment
comment|/**   * Copyright (c) 2005 Bruno Martins  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without   * modification, are permitted provided that the following conditions   * are met:  * 1. Redistributions of source code must retain the above copyright   *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the organization nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPInputStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Accountable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_comment
comment|/**  * Implementation of a Ternary Search Trie, a data structure for storing  *<code>String</code> objects that combines the compact size of a binary search  * tree with the speed of a digital search trie, and is therefore ideal for  * practical use in sorting and searching data.</p>  *<p>  *   * This data structure is faster than hashing for many typical search problems,  * and supports a broader range of useful problems and operations. Ternary  * searches are faster than hashing and more powerful, too.  *</p>  *<p>  *   * The theory of ternary search trees was described at a symposium in 1997 (see  * "Fast Algorithms for Sorting and Searching Strings," by J.L. Bentley and R.  * Sedgewick, Proceedings of the 8th Annual ACM-SIAM Symposium on Discrete  * Algorithms, January 1997). Algorithms in C, Third Edition, by Robert  * Sedgewick (Addison-Wesley, 1998) provides yet another view of ternary search  * trees.  *  * @deprecated Migrate to one of the newer suggesters which are much more RAM efficient.  */
end_comment
begin_class
annotation|@
name|Deprecated
DECL|class|JaspellTernarySearchTrie
specifier|public
class|class
name|JaspellTernarySearchTrie
implements|implements
name|Accountable
block|{
comment|/**    * An inner class of Ternary Search Trie that represents a node in the trie.    */
DECL|class|TSTNode
specifier|protected
specifier|final
class|class
name|TSTNode
implements|implements
name|Accountable
block|{
comment|/** Index values for accessing relatives array. */
DECL|field|PARENT
DECL|field|LOKID
DECL|field|EQKID
DECL|field|HIKID
specifier|protected
specifier|final
specifier|static
name|int
name|PARENT
init|=
literal|0
decl_stmt|,
name|LOKID
init|=
literal|1
decl_stmt|,
name|EQKID
init|=
literal|2
decl_stmt|,
name|HIKID
init|=
literal|3
decl_stmt|;
comment|/** The key to the node. */
DECL|field|data
specifier|protected
name|Object
name|data
decl_stmt|;
comment|/** The relative nodes. */
DECL|field|relatives
specifier|protected
specifier|final
name|TSTNode
index|[]
name|relatives
init|=
operator|new
name|TSTNode
index|[
literal|4
index|]
decl_stmt|;
comment|/** The char used in the split. */
DECL|field|splitchar
specifier|protected
name|char
name|splitchar
decl_stmt|;
comment|/**      * Constructor method.      *       *@param splitchar      *          The char used in the split.      *@param parent      *          The parent node.      */
DECL|method|TSTNode
specifier|protected
name|TSTNode
parameter_list|(
name|char
name|splitchar
parameter_list|,
name|TSTNode
name|parent
parameter_list|)
block|{
name|this
operator|.
name|splitchar
operator|=
name|splitchar
expr_stmt|;
name|relatives
index|[
name|PARENT
index|]
operator|=
name|parent
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
name|long
name|mem
init|=
name|RamUsageEstimator
operator|.
name|shallowSizeOf
argument_list|(
name|this
argument_list|)
operator|+
name|RamUsageEstimator
operator|.
name|shallowSizeOf
argument_list|(
name|relatives
argument_list|)
decl_stmt|;
comment|// We don't need to add parent since our parent added itself:
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|TSTNode
name|node
init|=
name|relatives
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|mem
operator|+=
name|node
operator|.
name|ramBytesUsed
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|mem
return|;
block|}
annotation|@
name|Override
DECL|method|getChildResources
specifier|public
name|Iterable
argument_list|<
name|?
extends|extends
name|Accountable
argument_list|>
name|getChildResources
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
block|}
comment|/**    * Compares characters by alfabetical order.    *     *@param cCompare2    *          The first char in the comparison.    *@param cRef    *          The second char in the comparison.    *@return A negative number, 0 or a positive number if the second char is    *         less, equal or greater.    */
DECL|method|compareCharsAlphabetically
specifier|private
specifier|static
name|int
name|compareCharsAlphabetically
parameter_list|(
name|char
name|cCompare2
parameter_list|,
name|char
name|cRef
parameter_list|)
block|{
return|return
name|Character
operator|.
name|toLowerCase
argument_list|(
name|cCompare2
argument_list|)
operator|-
name|Character
operator|.
name|toLowerCase
argument_list|(
name|cRef
argument_list|)
return|;
block|}
comment|/* what follows is the original Jaspell code.    private static int compareCharsAlphabetically(int cCompare2, int cRef) {     int cCompare = 0;     if (cCompare2>= 65) {       if (cCompare2< 89) {         cCompare = (2 * cCompare2) - 65;       } else if (cCompare2< 97) {         cCompare = cCompare2 + 24;       } else if (cCompare2< 121) {         cCompare = (2 * cCompare2) - 128;       } else cCompare = cCompare2;     } else cCompare = cCompare2;     if (cRef< 65) {       return cCompare - cRef;     }     if (cRef< 89) {       return cCompare - ((2 * cRef) - 65);     }     if (cRef< 97) {       return cCompare - (cRef + 24);     }     if (cRef< 121) {       return cCompare - ((2 * cRef) - 128);     }     return cCompare - cRef;   }   */
comment|/**    * The default number of values returned by the<code>matchAlmost</code>    * method.    */
DECL|field|defaultNumReturnValues
specifier|private
name|int
name|defaultNumReturnValues
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * the number of differences allowed in a call to the    *<code>matchAlmostKey</code> method.    */
DECL|field|matchAlmostDiff
specifier|private
name|int
name|matchAlmostDiff
decl_stmt|;
comment|/** The base node in the trie. */
DECL|field|rootNode
specifier|private
name|TSTNode
name|rootNode
decl_stmt|;
DECL|field|locale
specifier|private
specifier|final
name|Locale
name|locale
decl_stmt|;
comment|/**    * Constructs an empty Ternary Search Trie.    */
DECL|method|JaspellTernarySearchTrie
specifier|public
name|JaspellTernarySearchTrie
parameter_list|()
block|{
name|this
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs an empty Ternary Search Trie,    * specifying the Locale used for lowercasing.    */
DECL|method|JaspellTernarySearchTrie
specifier|public
name|JaspellTernarySearchTrie
parameter_list|(
name|Locale
name|locale
parameter_list|)
block|{
name|this
operator|.
name|locale
operator|=
name|locale
expr_stmt|;
block|}
comment|// for loading
DECL|method|setRoot
name|void
name|setRoot
parameter_list|(
name|TSTNode
name|newRoot
parameter_list|)
block|{
name|rootNode
operator|=
name|newRoot
expr_stmt|;
block|}
comment|// for saving
DECL|method|getRoot
name|TSTNode
name|getRoot
parameter_list|()
block|{
return|return
name|rootNode
return|;
block|}
comment|/**    * Constructs a Ternary Search Trie and loads data from a<code>Path</code>    * into the Trie. The file is a normal text document, where each line is of    * the form word TAB float.    *     *@param file    *          The<code>Path</code> with the data to load into the Trie.    *@exception IOException    *              A problem occured while reading the data.    */
DECL|method|JaspellTernarySearchTrie
specifier|public
name|JaspellTernarySearchTrie
parameter_list|(
name|Path
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|file
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs a Ternary Search Trie and loads data from a<code>File</code>    * into the Trie. The file is a normal text document, where each line is of    * the form "word TAB float".    *     *@param file    *          The<code>File</code> with the data to load into the Trie.    *@param compression    *          If true, the file is compressed with the GZIP algorithm, and if    *          false, the file is a normal text document.    *@exception IOException    *              A problem occured while reading the data.    */
DECL|method|JaspellTernarySearchTrie
specifier|public
name|JaspellTernarySearchTrie
parameter_list|(
name|Path
name|file
parameter_list|,
name|boolean
name|compression
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|()
expr_stmt|;
name|BufferedReader
name|in
decl_stmt|;
if|if
condition|(
name|compression
condition|)
name|in
operator|=
operator|new
name|BufferedReader
argument_list|(
name|IOUtils
operator|.
name|getDecodingReader
argument_list|(
operator|new
name|GZIPInputStream
argument_list|(
name|Files
operator|.
name|newInputStream
argument_list|(
name|file
argument_list|)
argument_list|)
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|in
operator|=
name|Files
operator|.
name|newBufferedReader
argument_list|(
name|file
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
expr_stmt|;
name|String
name|word
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|Float
name|occur
decl_stmt|,
name|one
init|=
operator|new
name|Float
argument_list|(
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|word
operator|=
name|in
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|pos
operator|=
name|word
operator|.
name|indexOf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|occur
operator|=
name|one
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
name|occur
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|word
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|word
operator|=
name|word
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
name|String
name|key
init|=
name|word
operator|.
name|toLowerCase
argument_list|(
name|locale
argument_list|)
decl_stmt|;
if|if
condition|(
name|rootNode
operator|==
literal|null
condition|)
block|{
name|rootNode
operator|=
operator|new
name|TSTNode
argument_list|(
name|key
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|TSTNode
name|node
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|rootNode
operator|!=
literal|null
condition|)
block|{
name|TSTNode
name|currentNode
init|=
name|rootNode
decl_stmt|;
name|int
name|charIndex
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|currentNode
operator|==
literal|null
condition|)
break|break;
name|int
name|charComp
init|=
name|compareCharsAlphabetically
argument_list|(
name|key
operator|.
name|charAt
argument_list|(
name|charIndex
argument_list|)
argument_list|,
name|currentNode
operator|.
name|splitchar
argument_list|)
decl_stmt|;
if|if
condition|(
name|charComp
operator|==
literal|0
condition|)
block|{
name|charIndex
operator|++
expr_stmt|;
if|if
condition|(
name|charIndex
operator|==
name|key
operator|.
name|length
argument_list|()
condition|)
block|{
name|node
operator|=
name|currentNode
expr_stmt|;
break|break;
block|}
name|currentNode
operator|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|EQKID
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|charComp
operator|<
literal|0
condition|)
block|{
name|currentNode
operator|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|LOKID
index|]
expr_stmt|;
block|}
else|else
block|{
name|currentNode
operator|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|HIKID
index|]
expr_stmt|;
block|}
block|}
name|Float
name|occur2
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
name|occur2
operator|=
operator|(
call|(
name|Float
call|)
argument_list|(
name|node
operator|.
name|data
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|occur2
operator|!=
literal|null
condition|)
block|{
name|occur
operator|+=
name|occur2
operator|.
name|floatValue
argument_list|()
expr_stmt|;
block|}
name|currentNode
operator|=
name|getOrCreateNode
argument_list|(
name|word
operator|.
name|trim
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|locale
argument_list|)
argument_list|)
expr_stmt|;
name|currentNode
operator|.
name|data
operator|=
name|occur
expr_stmt|;
block|}
block|}
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Deletes the node passed in as an argument. If this node has non-null data,    * then both the node and the data will be deleted. It also deletes any other    * nodes in the trie that are no longer needed after the deletion of the node.    *     *@param nodeToDelete    *          The node to delete.    */
DECL|method|deleteNode
specifier|private
name|void
name|deleteNode
parameter_list|(
name|TSTNode
name|nodeToDelete
parameter_list|)
block|{
if|if
condition|(
name|nodeToDelete
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|nodeToDelete
operator|.
name|data
operator|=
literal|null
expr_stmt|;
while|while
condition|(
name|nodeToDelete
operator|!=
literal|null
condition|)
block|{
name|nodeToDelete
operator|=
name|deleteNodeRecursion
argument_list|(
name|nodeToDelete
argument_list|)
expr_stmt|;
comment|// deleteNodeRecursion(nodeToDelete);
block|}
block|}
comment|/**    * Recursively visits each node to be deleted.    *     * To delete a node, first set its data to null, then pass it into this    * method, then pass the node returned by this method into this method (make    * sure you don't delete the data of any of the nodes returned from this    * method!) and continue in this fashion until the node returned by this    * method is<code>null</code>.    *     * The TSTNode instance returned by this method will be next node to be    * operated on by<code>deleteNodeRecursion</code> (This emulates recursive    * method call while avoiding the JVM overhead normally associated with a    * recursive method.)    *     *@param currentNode    *          The node to delete.    *@return The next node to be called in deleteNodeRecursion.    */
DECL|method|deleteNodeRecursion
specifier|private
name|TSTNode
name|deleteNodeRecursion
parameter_list|(
name|TSTNode
name|currentNode
parameter_list|)
block|{
if|if
condition|(
name|currentNode
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|EQKID
index|]
operator|!=
literal|null
operator|||
name|currentNode
operator|.
name|data
operator|!=
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// can't delete this node if it has a non-null eq kid or data
name|TSTNode
name|currentParent
init|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|PARENT
index|]
decl_stmt|;
name|boolean
name|lokidNull
init|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|LOKID
index|]
operator|==
literal|null
decl_stmt|;
name|boolean
name|hikidNull
init|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|HIKID
index|]
operator|==
literal|null
decl_stmt|;
name|int
name|childType
decl_stmt|;
if|if
condition|(
name|currentParent
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|LOKID
index|]
operator|==
name|currentNode
condition|)
block|{
name|childType
operator|=
name|TSTNode
operator|.
name|LOKID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentParent
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|EQKID
index|]
operator|==
name|currentNode
condition|)
block|{
name|childType
operator|=
name|TSTNode
operator|.
name|EQKID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentParent
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|HIKID
index|]
operator|==
name|currentNode
condition|)
block|{
name|childType
operator|=
name|TSTNode
operator|.
name|HIKID
expr_stmt|;
block|}
else|else
block|{
name|rootNode
operator|=
literal|null
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|lokidNull
operator|&&
name|hikidNull
condition|)
block|{
name|currentParent
operator|.
name|relatives
index|[
name|childType
index|]
operator|=
literal|null
expr_stmt|;
return|return
name|currentParent
return|;
block|}
if|if
condition|(
name|lokidNull
condition|)
block|{
name|currentParent
operator|.
name|relatives
index|[
name|childType
index|]
operator|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|HIKID
index|]
expr_stmt|;
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|HIKID
index|]
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|PARENT
index|]
operator|=
name|currentParent
expr_stmt|;
return|return
name|currentParent
return|;
block|}
if|if
condition|(
name|hikidNull
condition|)
block|{
name|currentParent
operator|.
name|relatives
index|[
name|childType
index|]
operator|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|LOKID
index|]
expr_stmt|;
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|LOKID
index|]
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|PARENT
index|]
operator|=
name|currentParent
expr_stmt|;
return|return
name|currentParent
return|;
block|}
name|int
name|deltaHi
init|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|HIKID
index|]
operator|.
name|splitchar
operator|-
name|currentNode
operator|.
name|splitchar
decl_stmt|;
name|int
name|deltaLo
init|=
name|currentNode
operator|.
name|splitchar
operator|-
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|LOKID
index|]
operator|.
name|splitchar
decl_stmt|;
name|int
name|movingKid
decl_stmt|;
name|TSTNode
name|targetNode
decl_stmt|;
if|if
condition|(
name|deltaHi
operator|==
name|deltaLo
condition|)
block|{
if|if
condition|(
name|Math
operator|.
name|random
argument_list|()
operator|<
literal|0.5
condition|)
block|{
name|deltaHi
operator|++
expr_stmt|;
block|}
else|else
block|{
name|deltaLo
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|deltaHi
operator|>
name|deltaLo
condition|)
block|{
name|movingKid
operator|=
name|TSTNode
operator|.
name|HIKID
expr_stmt|;
name|targetNode
operator|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|LOKID
index|]
expr_stmt|;
block|}
else|else
block|{
name|movingKid
operator|=
name|TSTNode
operator|.
name|LOKID
expr_stmt|;
name|targetNode
operator|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|HIKID
index|]
expr_stmt|;
block|}
while|while
condition|(
name|targetNode
operator|.
name|relatives
index|[
name|movingKid
index|]
operator|!=
literal|null
condition|)
block|{
name|targetNode
operator|=
name|targetNode
operator|.
name|relatives
index|[
name|movingKid
index|]
expr_stmt|;
block|}
name|targetNode
operator|.
name|relatives
index|[
name|movingKid
index|]
operator|=
name|currentNode
operator|.
name|relatives
index|[
name|movingKid
index|]
expr_stmt|;
name|currentParent
operator|.
name|relatives
index|[
name|childType
index|]
operator|=
name|targetNode
expr_stmt|;
name|targetNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|PARENT
index|]
operator|=
name|currentParent
expr_stmt|;
if|if
condition|(
operator|!
name|lokidNull
condition|)
block|{
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|LOKID
index|]
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hikidNull
condition|)
block|{
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|HIKID
index|]
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|currentParent
return|;
block|}
comment|/**    * Retrieve the object indexed by a key.    *     *@param key    *          A<code>String</code> index.    *@return The object retrieved from the Ternary Search Trie.    */
DECL|method|get
specifier|public
name|Object
name|get
parameter_list|(
name|CharSequence
name|key
parameter_list|)
block|{
name|TSTNode
name|node
init|=
name|getNode
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|node
operator|.
name|data
return|;
block|}
comment|/**    * Retrieve the<code>Float</code> indexed by key, increment it by one unit    * and store the new<code>Float</code>.    *     *@param key    *          A<code>String</code> index.    *@return The<code>Float</code> retrieved from the Ternary Search Trie.    */
DECL|method|getAndIncrement
specifier|public
name|Float
name|getAndIncrement
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|String
name|key2
init|=
name|key
operator|.
name|trim
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|locale
argument_list|)
decl_stmt|;
name|TSTNode
name|node
init|=
name|getNode
argument_list|(
name|key2
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Float
name|aux
init|=
call|(
name|Float
call|)
argument_list|(
name|node
operator|.
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|aux
operator|==
literal|null
condition|)
block|{
name|aux
operator|=
operator|new
name|Float
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aux
operator|=
operator|new
name|Float
argument_list|(
name|aux
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|put
argument_list|(
name|key2
argument_list|,
name|aux
argument_list|)
expr_stmt|;
return|return
name|aux
return|;
block|}
comment|/**    * Returns the key that indexes the node argument.    *     *@param node    *          The node whose index is to be calculated.    *@return The<code>String</code> that indexes the node argument.    */
DECL|method|getKey
specifier|protected
name|String
name|getKey
parameter_list|(
name|TSTNode
name|node
parameter_list|)
block|{
name|StringBuilder
name|getKeyBuffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|getKeyBuffer
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|getKeyBuffer
operator|.
name|append
argument_list|(
literal|""
operator|+
name|node
operator|.
name|splitchar
argument_list|)
expr_stmt|;
name|TSTNode
name|currentNode
decl_stmt|;
name|TSTNode
name|lastNode
decl_stmt|;
name|currentNode
operator|=
name|node
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|PARENT
index|]
expr_stmt|;
name|lastNode
operator|=
name|node
expr_stmt|;
while|while
condition|(
name|currentNode
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|EQKID
index|]
operator|==
name|lastNode
condition|)
block|{
name|getKeyBuffer
operator|.
name|append
argument_list|(
literal|""
operator|+
name|currentNode
operator|.
name|splitchar
argument_list|)
expr_stmt|;
block|}
name|lastNode
operator|=
name|currentNode
expr_stmt|;
name|currentNode
operator|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|PARENT
index|]
expr_stmt|;
block|}
name|getKeyBuffer
operator|.
name|reverse
argument_list|()
expr_stmt|;
return|return
name|getKeyBuffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns the node indexed by key, or<code>null</code> if that node doesn't    * exist. Search begins at root node.    *     *@param key    *          A<code>String</code> that indexes the node that is returned.    *@return The node object indexed by key. This object is an instance of an    *         inner class named<code>TernarySearchTrie.TSTNode</code>.    */
DECL|method|getNode
specifier|public
name|TSTNode
name|getNode
parameter_list|(
name|CharSequence
name|key
parameter_list|)
block|{
return|return
name|getNode
argument_list|(
name|key
argument_list|,
name|rootNode
argument_list|)
return|;
block|}
comment|/**    * Returns the node indexed by key, or<code>null</code> if that node doesn't    * exist. The search begins at root node.    *     *@param key    *          A<code>String</code> that indexes the node that is returned.    *@param startNode    *          The top node defining the subtrie to be searched.    *@return The node object indexed by key. This object is an instance of an    *         inner class named<code>TernarySearchTrie.TSTNode</code>.    */
DECL|method|getNode
specifier|protected
name|TSTNode
name|getNode
parameter_list|(
name|CharSequence
name|key
parameter_list|,
name|TSTNode
name|startNode
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|startNode
operator|==
literal|null
operator|||
name|key
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|TSTNode
name|currentNode
init|=
name|startNode
decl_stmt|;
name|int
name|charIndex
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|currentNode
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|charComp
init|=
name|compareCharsAlphabetically
argument_list|(
name|key
operator|.
name|charAt
argument_list|(
name|charIndex
argument_list|)
argument_list|,
name|currentNode
operator|.
name|splitchar
argument_list|)
decl_stmt|;
if|if
condition|(
name|charComp
operator|==
literal|0
condition|)
block|{
name|charIndex
operator|++
expr_stmt|;
if|if
condition|(
name|charIndex
operator|==
name|key
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
name|currentNode
return|;
block|}
name|currentNode
operator|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|EQKID
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|charComp
operator|<
literal|0
condition|)
block|{
name|currentNode
operator|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|LOKID
index|]
expr_stmt|;
block|}
else|else
block|{
name|currentNode
operator|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|HIKID
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the node indexed by key, creating that node if it doesn't exist,    * and creating any required intermediate nodes if they don't exist.    *     *@param key    *          A<code>String</code> that indexes the node that is returned.    *@return The node object indexed by key. This object is an instance of an    *         inner class named<code>TernarySearchTrie.TSTNode</code>.    *@exception NullPointerException    *              If the key is<code>null</code>.    *@exception IllegalArgumentException    *              If the key is an empty<code>String</code>.    */
DECL|method|getOrCreateNode
specifier|protected
name|TSTNode
name|getOrCreateNode
parameter_list|(
name|CharSequence
name|key
parameter_list|)
throws|throws
name|NullPointerException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"attempt to get or create node with null key"
argument_list|)
throw|;
block|}
if|if
condition|(
name|key
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"attempt to get or create node with key of zero length"
argument_list|)
throw|;
block|}
if|if
condition|(
name|rootNode
operator|==
literal|null
condition|)
block|{
name|rootNode
operator|=
operator|new
name|TSTNode
argument_list|(
name|key
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|TSTNode
name|currentNode
init|=
name|rootNode
decl_stmt|;
name|int
name|charIndex
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|charComp
init|=
name|compareCharsAlphabetically
argument_list|(
name|key
operator|.
name|charAt
argument_list|(
name|charIndex
argument_list|)
argument_list|,
name|currentNode
operator|.
name|splitchar
argument_list|)
decl_stmt|;
if|if
condition|(
name|charComp
operator|==
literal|0
condition|)
block|{
name|charIndex
operator|++
expr_stmt|;
if|if
condition|(
name|charIndex
operator|==
name|key
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
name|currentNode
return|;
block|}
if|if
condition|(
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|EQKID
index|]
operator|==
literal|null
condition|)
block|{
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|EQKID
index|]
operator|=
operator|new
name|TSTNode
argument_list|(
name|key
operator|.
name|charAt
argument_list|(
name|charIndex
argument_list|)
argument_list|,
name|currentNode
argument_list|)
expr_stmt|;
block|}
name|currentNode
operator|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|EQKID
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|charComp
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|LOKID
index|]
operator|==
literal|null
condition|)
block|{
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|LOKID
index|]
operator|=
operator|new
name|TSTNode
argument_list|(
name|key
operator|.
name|charAt
argument_list|(
name|charIndex
argument_list|)
argument_list|,
name|currentNode
argument_list|)
expr_stmt|;
block|}
name|currentNode
operator|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|LOKID
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|HIKID
index|]
operator|==
literal|null
condition|)
block|{
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|HIKID
index|]
operator|=
operator|new
name|TSTNode
argument_list|(
name|key
operator|.
name|charAt
argument_list|(
name|charIndex
argument_list|)
argument_list|,
name|currentNode
argument_list|)
expr_stmt|;
block|}
name|currentNode
operator|=
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|HIKID
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns a<code>List</code> of keys that almost match the argument key.    * Keys returned will have exactly diff characters that do not match the    * target key, where diff is equal to the last value passed in as an argument    * to the<code>setMatchAlmostDiff</code> method.    *<p>    * If the<code>matchAlmost</code> method is called before the    *<code>setMatchAlmostDiff</code> method has been called for the first time,    * then diff = 0.    *     *@param key    *          The target key.    *@return A<code>List</code> with the results.    */
DECL|method|matchAlmost
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|matchAlmost
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|matchAlmost
argument_list|(
name|key
argument_list|,
name|defaultNumReturnValues
argument_list|)
return|;
block|}
comment|/**    * Returns a<code>List</code> of keys that almost match the argument key.    * Keys returned will have exactly diff characters that do not match the    * target key, where diff is equal to the last value passed in as an argument    * to the<code>setMatchAlmostDiff</code> method.    *<p>    * If the<code>matchAlmost</code> method is called before the    *<code>setMatchAlmostDiff</code> method has been called for the first time,    * then diff = 0.    *     *@param key    *          The target key.    *@param numReturnValues    *          The maximum number of values returned by this method.    *@return A<code>List</code> with the results    */
DECL|method|matchAlmost
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|matchAlmost
parameter_list|(
name|CharSequence
name|key
parameter_list|,
name|int
name|numReturnValues
parameter_list|)
block|{
return|return
name|matchAlmostRecursion
argument_list|(
name|rootNode
argument_list|,
literal|0
argument_list|,
name|matchAlmostDiff
argument_list|,
name|key
argument_list|,
operator|(
operator|(
name|numReturnValues
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
name|numReturnValues
operator|)
argument_list|,
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Recursivelly vists the nodes in order to find the ones that almost match a    * given key.    *     *@param currentNode    *          The current node.    *@param charIndex    *          The current char.    *@param d    *          The number of differences so far.    *@param matchAlmostNumReturnValues    *          The maximum number of values in the result<code>List</code>.    *@param matchAlmostResult2    *          The results so far.    *@param upTo    *          If true all keys having up to and including matchAlmostDiff    *          mismatched letters will be included in the result (including a key    *          that is exactly the same as the target string) otherwise keys will    *          be included in the result only if they have exactly    *          matchAlmostDiff number of mismatched letters.    *@param matchAlmostKey    *          The key being searched.    *@return A<code>List</code> with the results.    */
DECL|method|matchAlmostRecursion
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|matchAlmostRecursion
parameter_list|(
name|TSTNode
name|currentNode
parameter_list|,
name|int
name|charIndex
parameter_list|,
name|int
name|d
parameter_list|,
name|CharSequence
name|matchAlmostKey
parameter_list|,
name|int
name|matchAlmostNumReturnValues
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|matchAlmostResult2
parameter_list|,
name|boolean
name|upTo
parameter_list|)
block|{
if|if
condition|(
operator|(
name|currentNode
operator|==
literal|null
operator|)
operator|||
operator|(
name|matchAlmostNumReturnValues
operator|!=
operator|-
literal|1
operator|&&
name|matchAlmostResult2
operator|.
name|size
argument_list|()
operator|>=
name|matchAlmostNumReturnValues
operator|)
operator|||
operator|(
name|d
operator|<
literal|0
operator|)
operator|||
operator|(
name|charIndex
operator|>=
name|matchAlmostKey
operator|.
name|length
argument_list|()
operator|)
condition|)
block|{
return|return
name|matchAlmostResult2
return|;
block|}
name|int
name|charComp
init|=
name|compareCharsAlphabetically
argument_list|(
name|matchAlmostKey
operator|.
name|charAt
argument_list|(
name|charIndex
argument_list|)
argument_list|,
name|currentNode
operator|.
name|splitchar
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|matchAlmostResult
init|=
name|matchAlmostResult2
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|>
literal|0
operator|)
operator|||
operator|(
name|charComp
operator|<
literal|0
operator|)
condition|)
block|{
name|matchAlmostResult
operator|=
name|matchAlmostRecursion
argument_list|(
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|LOKID
index|]
argument_list|,
name|charIndex
argument_list|,
name|d
argument_list|,
name|matchAlmostKey
argument_list|,
name|matchAlmostNumReturnValues
argument_list|,
name|matchAlmostResult
argument_list|,
name|upTo
argument_list|)
expr_stmt|;
block|}
name|int
name|nextD
init|=
operator|(
name|charComp
operator|==
literal|0
operator|)
condition|?
name|d
else|:
name|d
operator|-
literal|1
decl_stmt|;
name|boolean
name|cond
init|=
operator|(
name|upTo
operator|)
condition|?
operator|(
name|nextD
operator|>=
literal|0
operator|)
else|:
operator|(
name|nextD
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|matchAlmostKey
operator|.
name|length
argument_list|()
operator|==
name|charIndex
operator|+
literal|1
operator|)
operator|&&
name|cond
operator|&&
operator|(
name|currentNode
operator|.
name|data
operator|!=
literal|null
operator|)
condition|)
block|{
name|matchAlmostResult
operator|.
name|add
argument_list|(
name|getKey
argument_list|(
name|currentNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|matchAlmostResult
operator|=
name|matchAlmostRecursion
argument_list|(
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|EQKID
index|]
argument_list|,
name|charIndex
operator|+
literal|1
argument_list|,
name|nextD
argument_list|,
name|matchAlmostKey
argument_list|,
name|matchAlmostNumReturnValues
argument_list|,
name|matchAlmostResult
argument_list|,
name|upTo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|>
literal|0
operator|)
operator|||
operator|(
name|charComp
operator|>
literal|0
operator|)
condition|)
block|{
name|matchAlmostResult
operator|=
name|matchAlmostRecursion
argument_list|(
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|HIKID
index|]
argument_list|,
name|charIndex
argument_list|,
name|d
argument_list|,
name|matchAlmostKey
argument_list|,
name|matchAlmostNumReturnValues
argument_list|,
name|matchAlmostResult
argument_list|,
name|upTo
argument_list|)
expr_stmt|;
block|}
return|return
name|matchAlmostResult
return|;
block|}
comment|/**    * Returns an alphabetical<code>List</code> of all keys in the trie that    * begin with a given prefix. Only keys for nodes having non-null data are    * included in the<code>List</code>.    *     *@param prefix    *          Each key returned from this method will begin with the characters    *          in prefix.    *@return A<code>List</code> with the results.    */
DECL|method|matchPrefix
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|matchPrefix
parameter_list|(
name|String
name|prefix
parameter_list|)
block|{
return|return
name|matchPrefix
argument_list|(
name|prefix
argument_list|,
name|defaultNumReturnValues
argument_list|)
return|;
block|}
comment|/**    * Returns an alphabetical<code>List</code> of all keys in the trie that    * begin with a given prefix. Only keys for nodes having non-null data are    * included in the<code>List</code>.    *     *@param prefix    *          Each key returned from this method will begin with the characters    *          in prefix.    *@param numReturnValues    *          The maximum number of values returned from this method.    *@return A<code>List</code> with the results    */
DECL|method|matchPrefix
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|matchPrefix
parameter_list|(
name|CharSequence
name|prefix
parameter_list|,
name|int
name|numReturnValues
parameter_list|)
block|{
name|Vector
argument_list|<
name|String
argument_list|>
name|sortKeysResult
init|=
operator|new
name|Vector
argument_list|<>
argument_list|()
decl_stmt|;
name|TSTNode
name|startNode
init|=
name|getNode
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|startNode
operator|==
literal|null
condition|)
block|{
return|return
name|sortKeysResult
return|;
block|}
if|if
condition|(
name|startNode
operator|.
name|data
operator|!=
literal|null
condition|)
block|{
name|sortKeysResult
operator|.
name|addElement
argument_list|(
name|getKey
argument_list|(
name|startNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sortKeysRecursion
argument_list|(
name|startNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|EQKID
index|]
argument_list|,
operator|(
operator|(
name|numReturnValues
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
name|numReturnValues
operator|)
argument_list|,
name|sortKeysResult
argument_list|)
return|;
block|}
comment|/**    * Returns the number of nodes in the trie that have non-null data.    *     *@return The number of nodes in the trie that have non-null data.    */
DECL|method|numDataNodes
specifier|public
name|int
name|numDataNodes
parameter_list|()
block|{
return|return
name|numDataNodes
argument_list|(
name|rootNode
argument_list|)
return|;
block|}
comment|/**    * Returns the number of nodes in the subtrie below and including the starting    * node. The method counts only nodes that have non-null data.    *     *@param startingNode    *          The top node of the subtrie. the node that defines the subtrie.    *@return The total number of nodes in the subtrie.    */
DECL|method|numDataNodes
specifier|protected
name|int
name|numDataNodes
parameter_list|(
name|TSTNode
name|startingNode
parameter_list|)
block|{
return|return
name|recursiveNodeCalculator
argument_list|(
name|startingNode
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Returns the total number of nodes in the trie. The method counts nodes    * whether or not they have data.    *     *@return The total number of nodes in the trie.    */
DECL|method|numNodes
specifier|public
name|int
name|numNodes
parameter_list|()
block|{
return|return
name|numNodes
argument_list|(
name|rootNode
argument_list|)
return|;
block|}
comment|/**    * Returns the total number of nodes in the subtrie below and including the    * starting Node. The method counts nodes whether or not they have data.    *     *@param startingNode    *          The top node of the subtrie. The node that defines the subtrie.    *@return The total number of nodes in the subtrie.    */
DECL|method|numNodes
specifier|protected
name|int
name|numNodes
parameter_list|(
name|TSTNode
name|startingNode
parameter_list|)
block|{
return|return
name|recursiveNodeCalculator
argument_list|(
name|startingNode
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Stores a value in the trie. The value may be retrieved using the key.    *     *@param key    *          A<code>String</code> that indexes the object to be stored.    *@param value    *          The object to be stored in the Trie.    */
DECL|method|put
specifier|public
name|void
name|put
parameter_list|(
name|CharSequence
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|getOrCreateNode
argument_list|(
name|key
argument_list|)
operator|.
name|data
operator|=
name|value
expr_stmt|;
block|}
comment|/**    * Recursivelly visists each node to calculate the number of nodes.    *     *@param currentNode    *          The current node.    *@param checkData    *          If true we check the data to be different of<code>null</code>.    *@param numNodes2    *          The number of nodes so far.    *@return The number of nodes accounted.    */
DECL|method|recursiveNodeCalculator
specifier|private
name|int
name|recursiveNodeCalculator
parameter_list|(
name|TSTNode
name|currentNode
parameter_list|,
name|boolean
name|checkData
parameter_list|,
name|int
name|numNodes2
parameter_list|)
block|{
if|if
condition|(
name|currentNode
operator|==
literal|null
condition|)
block|{
return|return
name|numNodes2
return|;
block|}
name|int
name|numNodes
init|=
name|recursiveNodeCalculator
argument_list|(
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|LOKID
index|]
argument_list|,
name|checkData
argument_list|,
name|numNodes2
argument_list|)
decl_stmt|;
name|numNodes
operator|=
name|recursiveNodeCalculator
argument_list|(
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|EQKID
index|]
argument_list|,
name|checkData
argument_list|,
name|numNodes
argument_list|)
expr_stmt|;
name|numNodes
operator|=
name|recursiveNodeCalculator
argument_list|(
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|HIKID
index|]
argument_list|,
name|checkData
argument_list|,
name|numNodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkData
condition|)
block|{
if|if
condition|(
name|currentNode
operator|.
name|data
operator|!=
literal|null
condition|)
block|{
name|numNodes
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|numNodes
operator|++
expr_stmt|;
block|}
return|return
name|numNodes
return|;
block|}
comment|/**    * Removes the value indexed by key. Also removes all nodes that are rendered    * unnecessary by the removal of this data.    *     *@param key    *          A<code>string</code> that indexes the object to be removed from    *          the Trie.    */
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|deleteNode
argument_list|(
name|getNode
argument_list|(
name|key
operator|.
name|trim
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|locale
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sets the number of characters by which words can differ from target word    * when calling the<code>matchAlmost</code> method.    *<p>    * Arguments less than 0 will set the char difference to 0, and arguments    * greater than 3 will set the char difference to 3.    *     *@param diff    *          The number of characters by which words can differ from target    *          word.    */
DECL|method|setMatchAlmostDiff
specifier|public
name|void
name|setMatchAlmostDiff
parameter_list|(
name|int
name|diff
parameter_list|)
block|{
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
name|matchAlmostDiff
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diff
operator|>
literal|3
condition|)
block|{
name|matchAlmostDiff
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|matchAlmostDiff
operator|=
name|diff
expr_stmt|;
block|}
block|}
comment|/**    * Sets the default maximum number of values returned from the    *<code>matchPrefix</code> and<code>matchAlmost</code> methods.    *<p>    * The value should be set this to -1 to get an unlimited number of return    * values. note that the methods mentioned above provide overloaded versions    * that allow you to specify the maximum number of return values, in which    * case this value is temporarily overridden.    *     **@param num    *          The number of values that will be returned when calling the    *          methods above.    */
DECL|method|setNumReturnValues
specifier|public
name|void
name|setNumReturnValues
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|defaultNumReturnValues
operator|=
operator|(
name|num
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
name|num
expr_stmt|;
block|}
comment|/**    * Returns keys sorted in alphabetical order. This includes the start Node and    * all nodes connected to the start Node.    *<p>    * The number of keys returned is limited to numReturnValues. To get a list    * that isn't limited in size, set numReturnValues to -1.    *     *@param startNode    *          The top node defining the subtrie to be searched.    *@param numReturnValues    *          The maximum number of values returned from this method.    *@return A<code>List</code> with the results.    */
DECL|method|sortKeys
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|sortKeys
parameter_list|(
name|TSTNode
name|startNode
parameter_list|,
name|int
name|numReturnValues
parameter_list|)
block|{
return|return
name|sortKeysRecursion
argument_list|(
name|startNode
argument_list|,
operator|(
operator|(
name|numReturnValues
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
name|numReturnValues
operator|)
argument_list|,
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns keys sorted in alphabetical order. This includes the current Node    * and all nodes connected to the current Node.    *<p>    * Sorted keys will be appended to the end of the resulting<code>List</code>.    * The result may be empty when this method is invoked, but may not be    *<code>null</code>.    *     *@param currentNode    *          The current node.    *@param sortKeysNumReturnValues    *          The maximum number of values in the result.    *@param sortKeysResult2    *          The results so far.    *@return A<code>List</code> with the results.    */
DECL|method|sortKeysRecursion
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|sortKeysRecursion
parameter_list|(
name|TSTNode
name|currentNode
parameter_list|,
name|int
name|sortKeysNumReturnValues
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|sortKeysResult2
parameter_list|)
block|{
if|if
condition|(
name|currentNode
operator|==
literal|null
condition|)
block|{
return|return
name|sortKeysResult2
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|sortKeysResult
init|=
name|sortKeysRecursion
argument_list|(
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|LOKID
index|]
argument_list|,
name|sortKeysNumReturnValues
argument_list|,
name|sortKeysResult2
argument_list|)
decl_stmt|;
if|if
condition|(
name|sortKeysNumReturnValues
operator|!=
operator|-
literal|1
operator|&&
name|sortKeysResult
operator|.
name|size
argument_list|()
operator|>=
name|sortKeysNumReturnValues
condition|)
block|{
return|return
name|sortKeysResult
return|;
block|}
if|if
condition|(
name|currentNode
operator|.
name|data
operator|!=
literal|null
condition|)
block|{
name|sortKeysResult
operator|.
name|add
argument_list|(
name|getKey
argument_list|(
name|currentNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sortKeysResult
operator|=
name|sortKeysRecursion
argument_list|(
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|EQKID
index|]
argument_list|,
name|sortKeysNumReturnValues
argument_list|,
name|sortKeysResult
argument_list|)
expr_stmt|;
return|return
name|sortKeysRecursion
argument_list|(
name|currentNode
operator|.
name|relatives
index|[
name|TSTNode
operator|.
name|HIKID
index|]
argument_list|,
name|sortKeysNumReturnValues
argument_list|,
name|sortKeysResult
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
name|long
name|mem
init|=
name|RamUsageEstimator
operator|.
name|shallowSizeOf
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|final
name|TSTNode
name|root
init|=
name|getRoot
argument_list|()
decl_stmt|;
if|if
condition|(
name|root
operator|!=
literal|null
condition|)
block|{
name|mem
operator|+=
name|root
operator|.
name|ramBytesUsed
argument_list|()
expr_stmt|;
block|}
return|return
name|mem
return|;
block|}
annotation|@
name|Override
DECL|method|getChildResources
specifier|public
name|Iterable
argument_list|<
name|?
extends|extends
name|Accountable
argument_list|>
name|getChildResources
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
block|}
end_class
end_unit
