begin_unit
begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockAnalyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriterConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LineFileDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PrintStreamInfoStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_comment
comment|// TODO
end_comment
begin_comment
comment|//   - doc blocks?  so we can test joins/grouping...
end_comment
begin_comment
comment|//   - controlled consistency (NRTMgr)
end_comment
begin_comment
comment|/**  * Base test class for simulating distributed search across multiple shards.  */
end_comment
begin_class
DECL|class|ShardSearchingTestBase
specifier|public
specifier|abstract
class|class
name|ShardSearchingTestBase
extends|extends
name|LuceneTestCase
block|{
comment|// TODO: maybe SLM should throw this instead of returning null...
comment|/**    * Thrown when the lease for a searcher has expired.    */
DECL|class|SearcherExpiredException
specifier|public
specifier|static
class|class
name|SearcherExpiredException
extends|extends
name|RuntimeException
block|{
DECL|method|SearcherExpiredException
specifier|public
name|SearcherExpiredException
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|super
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|FieldAndShardVersion
specifier|private
specifier|static
class|class
name|FieldAndShardVersion
block|{
DECL|field|version
specifier|private
specifier|final
name|long
name|version
decl_stmt|;
DECL|field|nodeID
specifier|private
specifier|final
name|int
name|nodeID
decl_stmt|;
DECL|field|field
specifier|private
specifier|final
name|String
name|field
decl_stmt|;
DECL|method|FieldAndShardVersion
specifier|public
name|FieldAndShardVersion
parameter_list|(
name|int
name|nodeID
parameter_list|,
name|long
name|version
parameter_list|,
name|String
name|field
parameter_list|)
block|{
name|this
operator|.
name|nodeID
operator|=
name|nodeID
expr_stmt|;
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|version
operator|*
name|nodeID
operator|+
name|field
operator|.
name|hashCode
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|_other
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|_other
operator|instanceof
name|FieldAndShardVersion
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|FieldAndShardVersion
name|other
init|=
operator|(
name|FieldAndShardVersion
operator|)
name|_other
decl_stmt|;
return|return
name|field
operator|.
name|equals
argument_list|(
name|other
operator|.
name|field
argument_list|)
operator|&&
name|version
operator|==
name|other
operator|.
name|version
operator|&&
name|nodeID
operator|==
name|other
operator|.
name|nodeID
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"FieldAndShardVersion(field="
operator|+
name|field
operator|+
literal|" nodeID="
operator|+
name|nodeID
operator|+
literal|" version="
operator|+
name|version
operator|+
literal|")"
return|;
block|}
block|}
DECL|class|TermAndShardVersion
specifier|private
specifier|static
class|class
name|TermAndShardVersion
block|{
DECL|field|version
specifier|private
specifier|final
name|long
name|version
decl_stmt|;
DECL|field|nodeID
specifier|private
specifier|final
name|int
name|nodeID
decl_stmt|;
DECL|field|term
specifier|private
specifier|final
name|Term
name|term
decl_stmt|;
DECL|method|TermAndShardVersion
specifier|public
name|TermAndShardVersion
parameter_list|(
name|int
name|nodeID
parameter_list|,
name|long
name|version
parameter_list|,
name|Term
name|term
parameter_list|)
block|{
name|this
operator|.
name|nodeID
operator|=
name|nodeID
expr_stmt|;
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|this
operator|.
name|term
operator|=
name|term
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|version
operator|*
name|nodeID
operator|+
name|term
operator|.
name|hashCode
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|_other
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|_other
operator|instanceof
name|TermAndShardVersion
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|TermAndShardVersion
name|other
init|=
operator|(
name|TermAndShardVersion
operator|)
name|_other
decl_stmt|;
return|return
name|term
operator|.
name|equals
argument_list|(
name|other
operator|.
name|term
argument_list|)
operator|&&
name|version
operator|==
name|other
operator|.
name|version
operator|&&
name|nodeID
operator|==
name|other
operator|.
name|nodeID
return|;
block|}
block|}
comment|// We share collection stats for these fields on each node
comment|// reopen:
DECL|field|fieldsToShare
specifier|private
specifier|final
name|String
index|[]
name|fieldsToShare
init|=
operator|new
name|String
index|[]
block|{
literal|"body"
block|,
literal|"title"
block|}
decl_stmt|;
comment|// Called by one node once it has reopened, to notify all
comment|// other nodes.  This is just a mock (since it goes and
comment|// directly updates all other nodes, in RAM)... in a real
comment|// env this would hit the wire, sending version&
comment|// collection stats to all other nodes:
DECL|method|broadcastNodeReopen
name|void
name|broadcastNodeReopen
parameter_list|(
name|int
name|nodeID
parameter_list|,
name|long
name|version
parameter_list|,
name|IndexSearcher
name|newSearcher
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"REOPEN: nodeID="
operator|+
name|nodeID
operator|+
literal|" version="
operator|+
name|version
operator|+
literal|" maxDoc="
operator|+
name|newSearcher
operator|.
name|getIndexReader
argument_list|()
operator|.
name|maxDoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Broadcast new collection stats for this node to all
comment|// other nodes:
for|for
control|(
name|String
name|field
range|:
name|fieldsToShare
control|)
block|{
specifier|final
name|CollectionStatistics
name|stats
init|=
name|newSearcher
operator|.
name|collectionStatistics
argument_list|(
name|field
argument_list|)
decl_stmt|;
for|for
control|(
name|NodeState
name|node
range|:
name|nodes
control|)
block|{
comment|// Don't put my own collection stats into the cache;
comment|// we pull locally:
if|if
condition|(
name|node
operator|.
name|myNodeID
operator|!=
name|nodeID
condition|)
block|{
name|node
operator|.
name|collectionStatsCache
operator|.
name|put
argument_list|(
operator|new
name|FieldAndShardVersion
argument_list|(
name|nodeID
argument_list|,
name|version
argument_list|,
name|field
argument_list|)
argument_list|,
name|stats
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|NodeState
name|node
range|:
name|nodes
control|)
block|{
name|node
operator|.
name|updateNodeVersion
argument_list|(
name|nodeID
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: broadcastNodeExpire?  then we can purge the
comment|// known-stale cache entries...
comment|// MOCK: in a real env you have to hit the wire
comment|// (send this query to all remote nodes
comment|// concurrently):
DECL|method|searchNode
name|TopDocs
name|searchNode
parameter_list|(
name|int
name|nodeID
parameter_list|,
name|long
index|[]
name|nodeVersions
parameter_list|,
name|Query
name|q
parameter_list|,
name|Sort
name|sort
parameter_list|,
name|int
name|numHits
parameter_list|,
name|ScoreDoc
name|searchAfter
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|NodeState
operator|.
name|ShardIndexSearcher
name|s
init|=
name|nodes
index|[
name|nodeID
index|]
operator|.
name|acquire
argument_list|(
name|nodeVersions
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|sort
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|searchAfter
operator|!=
literal|null
condition|)
block|{
return|return
name|s
operator|.
name|localSearchAfter
argument_list|(
name|searchAfter
argument_list|,
name|q
argument_list|,
name|numHits
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|s
operator|.
name|localSearch
argument_list|(
name|q
argument_list|,
name|numHits
argument_list|)
return|;
block|}
block|}
else|else
block|{
assert|assert
name|searchAfter
operator|==
literal|null
assert|;
comment|// not supported yet
return|return
name|s
operator|.
name|localSearch
argument_list|(
name|q
argument_list|,
name|numHits
argument_list|,
name|sort
argument_list|)
return|;
block|}
block|}
finally|finally
block|{
name|nodes
index|[
name|nodeID
index|]
operator|.
name|release
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Mock: in a real env, this would hit the wire and get
comment|// term stats from remote node
DECL|method|getNodeTermStats
name|Map
argument_list|<
name|Term
argument_list|,
name|TermStatistics
argument_list|>
name|getNodeTermStats
parameter_list|(
name|Set
argument_list|<
name|Term
argument_list|>
name|terms
parameter_list|,
name|int
name|nodeID
parameter_list|,
name|long
name|version
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|NodeState
name|node
init|=
name|nodes
index|[
name|nodeID
index|]
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Term
argument_list|,
name|TermStatistics
argument_list|>
name|stats
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|IndexSearcher
name|s
init|=
name|node
operator|.
name|searchers
operator|.
name|acquire
argument_list|(
name|version
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SearcherExpiredException
argument_list|(
literal|"node="
operator|+
name|nodeID
operator|+
literal|" version="
operator|+
name|version
argument_list|)
throw|;
block|}
try|try
block|{
for|for
control|(
name|Term
name|term
range|:
name|terms
control|)
block|{
specifier|final
name|TermContext
name|termContext
init|=
name|TermContext
operator|.
name|build
argument_list|(
name|s
operator|.
name|getIndexReader
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|,
name|term
argument_list|)
decl_stmt|;
name|stats
operator|.
name|put
argument_list|(
name|term
argument_list|,
name|s
operator|.
name|termStatistics
argument_list|(
name|term
argument_list|,
name|termContext
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|node
operator|.
name|searchers
operator|.
name|release
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|stats
return|;
block|}
DECL|class|NodeState
specifier|protected
specifier|final
class|class
name|NodeState
implements|implements
name|Closeable
block|{
DECL|field|dir
specifier|public
specifier|final
name|Directory
name|dir
decl_stmt|;
DECL|field|writer
specifier|public
specifier|final
name|IndexWriter
name|writer
decl_stmt|;
DECL|field|searchers
specifier|public
specifier|final
name|SearcherLifetimeManager
name|searchers
decl_stmt|;
DECL|field|mgr
specifier|public
specifier|final
name|SearcherManager
name|mgr
decl_stmt|;
DECL|field|myNodeID
specifier|public
specifier|final
name|int
name|myNodeID
decl_stmt|;
DECL|field|currentNodeVersions
specifier|public
specifier|final
name|long
index|[]
name|currentNodeVersions
decl_stmt|;
comment|// TODO: nothing evicts from here!!!  Somehow, on searcher
comment|// expiration on remote nodes we must evict from our
comment|// local cache...?  And still LRU otherwise (for the
comment|// still-live searchers).
DECL|field|collectionStatsCache
specifier|private
specifier|final
name|Map
argument_list|<
name|FieldAndShardVersion
argument_list|,
name|CollectionStatistics
argument_list|>
name|collectionStatsCache
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|termStatsCache
specifier|private
specifier|final
name|Map
argument_list|<
name|TermAndShardVersion
argument_list|,
name|TermStatistics
argument_list|>
name|termStatsCache
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Matches docs in the local shard but scores based on      *  aggregated stats ("mock distributed scoring") from all      *  nodes. */
DECL|class|ShardIndexSearcher
specifier|public
class|class
name|ShardIndexSearcher
extends|extends
name|IndexSearcher
block|{
comment|// Version for the node searchers we search:
DECL|field|nodeVersions
specifier|public
specifier|final
name|long
index|[]
name|nodeVersions
decl_stmt|;
DECL|field|myNodeID
specifier|public
specifier|final
name|int
name|myNodeID
decl_stmt|;
DECL|method|ShardIndexSearcher
specifier|public
name|ShardIndexSearcher
parameter_list|(
name|long
index|[]
name|nodeVersions
parameter_list|,
name|IndexReader
name|localReader
parameter_list|,
name|int
name|nodeID
parameter_list|)
block|{
name|super
argument_list|(
name|localReader
argument_list|)
expr_stmt|;
name|this
operator|.
name|nodeVersions
operator|=
name|nodeVersions
expr_stmt|;
name|myNodeID
operator|=
name|nodeID
expr_stmt|;
assert|assert
name|myNodeID
operator|==
name|NodeState
operator|.
name|this
operator|.
name|myNodeID
operator|:
literal|"myNodeID="
operator|+
name|nodeID
operator|+
literal|" NodeState.this.myNodeID="
operator|+
name|NodeState
operator|.
name|this
operator|.
name|myNodeID
assert|;
block|}
annotation|@
name|Override
DECL|method|rewrite
specifier|public
name|Query
name|rewrite
parameter_list|(
name|Query
name|original
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Query
name|rewritten
init|=
name|super
operator|.
name|rewrite
argument_list|(
name|original
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Term
argument_list|>
name|terms
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|rewritten
operator|.
name|extractTerms
argument_list|(
name|terms
argument_list|)
expr_stmt|;
comment|// Make a single request to remote nodes for term
comment|// stats:
for|for
control|(
name|int
name|nodeID
init|=
literal|0
init|;
name|nodeID
operator|<
name|nodeVersions
operator|.
name|length
condition|;
name|nodeID
operator|++
control|)
block|{
if|if
condition|(
name|nodeID
operator|==
name|myNodeID
condition|)
block|{
continue|continue;
block|}
specifier|final
name|Set
argument_list|<
name|Term
argument_list|>
name|missing
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Term
name|term
range|:
name|terms
control|)
block|{
specifier|final
name|TermAndShardVersion
name|key
init|=
operator|new
name|TermAndShardVersion
argument_list|(
name|nodeID
argument_list|,
name|nodeVersions
index|[
name|nodeID
index|]
argument_list|,
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|termStatsCache
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|missing
operator|.
name|add
argument_list|(
name|term
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|missing
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Term
argument_list|,
name|TermStatistics
argument_list|>
name|ent
range|:
name|getNodeTermStats
argument_list|(
name|missing
argument_list|,
name|nodeID
argument_list|,
name|nodeVersions
index|[
name|nodeID
index|]
argument_list|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|TermAndShardVersion
name|key
init|=
operator|new
name|TermAndShardVersion
argument_list|(
name|nodeID
argument_list|,
name|nodeVersions
index|[
name|nodeID
index|]
argument_list|,
name|ent
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|termStatsCache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|ent
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|rewritten
return|;
block|}
annotation|@
name|Override
DECL|method|termStatistics
specifier|public
name|TermStatistics
name|termStatistics
parameter_list|(
name|Term
name|term
parameter_list|,
name|TermContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|term
operator|!=
literal|null
assert|;
name|long
name|docFreq
init|=
literal|0
decl_stmt|;
name|long
name|totalTermFreq
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|nodeID
init|=
literal|0
init|;
name|nodeID
operator|<
name|nodeVersions
operator|.
name|length
condition|;
name|nodeID
operator|++
control|)
block|{
specifier|final
name|TermStatistics
name|subStats
decl_stmt|;
if|if
condition|(
name|nodeID
operator|==
name|myNodeID
condition|)
block|{
name|subStats
operator|=
name|super
operator|.
name|termStatistics
argument_list|(
name|term
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|TermAndShardVersion
name|key
init|=
operator|new
name|TermAndShardVersion
argument_list|(
name|nodeID
argument_list|,
name|nodeVersions
index|[
name|nodeID
index|]
argument_list|,
name|term
argument_list|)
decl_stmt|;
name|subStats
operator|=
name|termStatsCache
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|// We pre-cached during rewrite so all terms
comment|// better be here...
assert|assert
name|subStats
operator|!=
literal|null
assert|;
block|}
name|long
name|nodeDocFreq
init|=
name|subStats
operator|.
name|docFreq
argument_list|()
decl_stmt|;
if|if
condition|(
name|docFreq
operator|>=
literal|0
operator|&&
name|nodeDocFreq
operator|>=
literal|0
condition|)
block|{
name|docFreq
operator|+=
name|nodeDocFreq
expr_stmt|;
block|}
else|else
block|{
name|docFreq
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|long
name|nodeTotalTermFreq
init|=
name|subStats
operator|.
name|totalTermFreq
argument_list|()
decl_stmt|;
if|if
condition|(
name|totalTermFreq
operator|>=
literal|0
operator|&&
name|nodeTotalTermFreq
operator|>=
literal|0
condition|)
block|{
name|totalTermFreq
operator|+=
name|nodeTotalTermFreq
expr_stmt|;
block|}
else|else
block|{
name|totalTermFreq
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|new
name|TermStatistics
argument_list|(
name|term
operator|.
name|bytes
argument_list|()
argument_list|,
name|docFreq
argument_list|,
name|totalTermFreq
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|collectionStatistics
specifier|public
name|CollectionStatistics
name|collectionStatistics
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: we could compute this on init and cache,
comment|// since we are re-inited whenever any nodes have a
comment|// new reader
name|long
name|docCount
init|=
literal|0
decl_stmt|;
name|long
name|sumTotalTermFreq
init|=
literal|0
decl_stmt|;
name|long
name|sumDocFreq
init|=
literal|0
decl_stmt|;
name|long
name|maxDoc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|nodeID
init|=
literal|0
init|;
name|nodeID
operator|<
name|nodeVersions
operator|.
name|length
condition|;
name|nodeID
operator|++
control|)
block|{
specifier|final
name|FieldAndShardVersion
name|key
init|=
operator|new
name|FieldAndShardVersion
argument_list|(
name|nodeID
argument_list|,
name|nodeVersions
index|[
name|nodeID
index|]
argument_list|,
name|field
argument_list|)
decl_stmt|;
specifier|final
name|CollectionStatistics
name|nodeStats
decl_stmt|;
if|if
condition|(
name|nodeID
operator|==
name|myNodeID
condition|)
block|{
name|nodeStats
operator|=
name|super
operator|.
name|collectionStatistics
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodeStats
operator|=
name|collectionStatsCache
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nodeStats
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"coll stats myNodeID="
operator|+
name|myNodeID
operator|+
literal|": "
operator|+
name|collectionStatsCache
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Collection stats are pre-shared on reopen, so,
comment|// we better not have a cache miss:
assert|assert
name|nodeStats
operator|!=
literal|null
operator|:
literal|"myNodeID="
operator|+
name|myNodeID
operator|+
literal|" nodeID="
operator|+
name|nodeID
operator|+
literal|" version="
operator|+
name|nodeVersions
index|[
name|nodeID
index|]
operator|+
literal|" field="
operator|+
name|field
assert|;
name|long
name|nodeDocCount
init|=
name|nodeStats
operator|.
name|docCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|docCount
operator|>=
literal|0
operator|&&
name|nodeDocCount
operator|>=
literal|0
condition|)
block|{
name|docCount
operator|+=
name|nodeDocCount
expr_stmt|;
block|}
else|else
block|{
name|docCount
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|long
name|nodeSumTotalTermFreq
init|=
name|nodeStats
operator|.
name|sumTotalTermFreq
argument_list|()
decl_stmt|;
if|if
condition|(
name|sumTotalTermFreq
operator|>=
literal|0
operator|&&
name|nodeSumTotalTermFreq
operator|>=
literal|0
condition|)
block|{
name|sumTotalTermFreq
operator|+=
name|nodeSumTotalTermFreq
expr_stmt|;
block|}
else|else
block|{
name|sumTotalTermFreq
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|long
name|nodeSumDocFreq
init|=
name|nodeStats
operator|.
name|sumDocFreq
argument_list|()
decl_stmt|;
if|if
condition|(
name|sumDocFreq
operator|>=
literal|0
operator|&&
name|nodeSumDocFreq
operator|>=
literal|0
condition|)
block|{
name|sumDocFreq
operator|+=
name|nodeSumDocFreq
expr_stmt|;
block|}
else|else
block|{
name|sumDocFreq
operator|=
operator|-
literal|1
expr_stmt|;
block|}
assert|assert
name|nodeStats
operator|.
name|maxDoc
argument_list|()
operator|>=
literal|0
assert|;
name|maxDoc
operator|+=
name|nodeStats
operator|.
name|maxDoc
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|CollectionStatistics
argument_list|(
name|field
argument_list|,
name|maxDoc
argument_list|,
name|docCount
argument_list|,
name|sumTotalTermFreq
argument_list|,
name|sumDocFreq
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|search
specifier|public
name|TopDocs
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|numHits
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|TopDocs
index|[]
name|shardHits
init|=
operator|new
name|TopDocs
index|[
name|nodeVersions
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|nodeID
init|=
literal|0
init|;
name|nodeID
operator|<
name|nodeVersions
operator|.
name|length
condition|;
name|nodeID
operator|++
control|)
block|{
if|if
condition|(
name|nodeID
operator|==
name|myNodeID
condition|)
block|{
comment|// My node; run using local shard searcher we
comment|// already aquired:
name|shardHits
index|[
name|nodeID
index|]
operator|=
name|localSearch
argument_list|(
name|query
argument_list|,
name|numHits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shardHits
index|[
name|nodeID
index|]
operator|=
name|searchNode
argument_list|(
name|nodeID
argument_list|,
name|nodeVersions
argument_list|,
name|query
argument_list|,
literal|null
argument_list|,
name|numHits
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Merge:
return|return
name|TopDocs
operator|.
name|merge
argument_list|(
name|numHits
argument_list|,
name|shardHits
argument_list|)
return|;
block|}
DECL|method|localSearch
specifier|public
name|TopDocs
name|localSearch
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|numHits
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|super
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|numHits
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|searchAfter
specifier|public
name|TopDocs
name|searchAfter
parameter_list|(
name|ScoreDoc
name|after
parameter_list|,
name|Query
name|query
parameter_list|,
name|int
name|numHits
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|after
operator|==
literal|null
condition|)
block|{
return|return
name|super
operator|.
name|searchAfter
argument_list|(
name|after
argument_list|,
name|query
argument_list|,
name|numHits
argument_list|)
return|;
block|}
specifier|final
name|TopDocs
index|[]
name|shardHits
init|=
operator|new
name|TopDocs
index|[
name|nodeVersions
operator|.
name|length
index|]
decl_stmt|;
comment|// results are merged in that order: score, shardIndex, doc. therefore we set
comment|// after to after.score and depending on the nodeID we set doc to either:
comment|// - not collect any more documents with that score (only with worse score)
comment|// - collect more documents with that score (and worse) following the last collected document
comment|// - collect all documents with that score (and worse)
name|ScoreDoc
name|shardAfter
init|=
operator|new
name|ScoreDoc
argument_list|(
name|after
operator|.
name|doc
argument_list|,
name|after
operator|.
name|score
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|nodeID
init|=
literal|0
init|;
name|nodeID
operator|<
name|nodeVersions
operator|.
name|length
condition|;
name|nodeID
operator|++
control|)
block|{
if|if
condition|(
name|nodeID
operator|<
name|after
operator|.
name|shardIndex
condition|)
block|{
comment|// all documents with after.score were already collected, so collect
comment|// only documents with worse scores.
specifier|final
name|NodeState
operator|.
name|ShardIndexSearcher
name|s
init|=
name|nodes
index|[
name|nodeID
index|]
operator|.
name|acquire
argument_list|(
name|nodeVersions
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Setting after.doc to reader.maxDoc-1 is a way to tell
comment|// TopScoreDocCollector that no more docs with that score should
comment|// be collected. note that in practice the shard which sends the
comment|// request to a remote shard won't have reader.maxDoc at hand, so
comment|// it will send some arbitrary value which will be fixed on the
comment|// other end.
name|shardAfter
operator|.
name|doc
operator|=
name|s
operator|.
name|getIndexReader
argument_list|()
operator|.
name|maxDoc
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
finally|finally
block|{
name|nodes
index|[
name|nodeID
index|]
operator|.
name|release
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nodeID
operator|==
name|after
operator|.
name|shardIndex
condition|)
block|{
comment|// collect all documents following the last collected doc with
comment|// after.score + documents with worse scores.
name|shardAfter
operator|.
name|doc
operator|=
name|after
operator|.
name|doc
expr_stmt|;
block|}
else|else
block|{
comment|// all documents with after.score (and worse) should be collected
comment|// because they didn't make it to top-N in the previous round.
name|shardAfter
operator|.
name|doc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nodeID
operator|==
name|myNodeID
condition|)
block|{
comment|// My node; run using local shard searcher we
comment|// already aquired:
name|shardHits
index|[
name|nodeID
index|]
operator|=
name|localSearchAfter
argument_list|(
name|shardAfter
argument_list|,
name|query
argument_list|,
name|numHits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shardHits
index|[
name|nodeID
index|]
operator|=
name|searchNode
argument_list|(
name|nodeID
argument_list|,
name|nodeVersions
argument_list|,
name|query
argument_list|,
literal|null
argument_list|,
name|numHits
argument_list|,
name|shardAfter
argument_list|)
expr_stmt|;
block|}
comment|//System.out.println("  node=" + nodeID + " totHits=" + shardHits[nodeID].totalHits);
block|}
comment|// Merge:
return|return
name|TopDocs
operator|.
name|merge
argument_list|(
name|numHits
argument_list|,
name|shardHits
argument_list|)
return|;
block|}
DECL|method|localSearchAfter
specifier|public
name|TopDocs
name|localSearchAfter
parameter_list|(
name|ScoreDoc
name|after
parameter_list|,
name|Query
name|query
parameter_list|,
name|int
name|numHits
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|super
operator|.
name|searchAfter
argument_list|(
name|after
argument_list|,
name|query
argument_list|,
name|numHits
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|search
specifier|public
name|TopFieldDocs
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|numHits
parameter_list|,
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|sort
operator|!=
literal|null
assert|;
specifier|final
name|TopFieldDocs
index|[]
name|shardHits
init|=
operator|new
name|TopFieldDocs
index|[
name|nodeVersions
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|nodeID
init|=
literal|0
init|;
name|nodeID
operator|<
name|nodeVersions
operator|.
name|length
condition|;
name|nodeID
operator|++
control|)
block|{
if|if
condition|(
name|nodeID
operator|==
name|myNodeID
condition|)
block|{
comment|// My node; run using local shard searcher we
comment|// already aquired:
name|shardHits
index|[
name|nodeID
index|]
operator|=
name|localSearch
argument_list|(
name|query
argument_list|,
name|numHits
argument_list|,
name|sort
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shardHits
index|[
name|nodeID
index|]
operator|=
operator|(
name|TopFieldDocs
operator|)
name|searchNode
argument_list|(
name|nodeID
argument_list|,
name|nodeVersions
argument_list|,
name|query
argument_list|,
name|sort
argument_list|,
name|numHits
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Merge:
return|return
name|TopDocs
operator|.
name|merge
argument_list|(
name|sort
argument_list|,
name|numHits
argument_list|,
name|shardHits
argument_list|)
return|;
block|}
DECL|method|localSearch
specifier|public
name|TopFieldDocs
name|localSearch
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|numHits
parameter_list|,
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|super
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|numHits
argument_list|,
name|sort
argument_list|)
return|;
block|}
block|}
DECL|field|currentShardSearcher
specifier|private
specifier|volatile
name|ShardIndexSearcher
name|currentShardSearcher
decl_stmt|;
DECL|method|NodeState
specifier|public
name|NodeState
parameter_list|(
name|Random
name|random
parameter_list|,
name|int
name|nodeID
parameter_list|,
name|int
name|numNodes
parameter_list|)
throws|throws
name|IOException
block|{
name|myNodeID
operator|=
name|nodeID
expr_stmt|;
name|dir
operator|=
name|newFSDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"ShardSearchingTestBase"
argument_list|)
argument_list|)
expr_stmt|;
comment|// TODO: set warmer
name|MockAnalyzer
name|analyzer
init|=
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|analyzer
operator|.
name|setMaxTokenLength
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
name|IndexWriter
operator|.
name|MAX_TERM_LENGTH
argument_list|)
argument_list|)
expr_stmt|;
name|IndexWriterConfig
name|iwc
init|=
operator|new
name|IndexWriterConfig
argument_list|(
name|analyzer
argument_list|)
decl_stmt|;
name|iwc
operator|.
name|setOpenMode
argument_list|(
name|IndexWriterConfig
operator|.
name|OpenMode
operator|.
name|CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|iwc
operator|.
name|setInfoStream
argument_list|(
operator|new
name|PrintStreamInfoStream
argument_list|(
name|System
operator|.
name|out
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|writer
operator|=
operator|new
name|IndexWriter
argument_list|(
name|dir
argument_list|,
name|iwc
argument_list|)
expr_stmt|;
name|mgr
operator|=
operator|new
name|SearcherManager
argument_list|(
name|writer
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|searchers
operator|=
operator|new
name|SearcherLifetimeManager
argument_list|()
expr_stmt|;
comment|// Init w/ 0s... caller above will do initial
comment|// "broadcast" by calling initSearcher:
name|currentNodeVersions
operator|=
operator|new
name|long
index|[
name|numNodes
index|]
expr_stmt|;
block|}
DECL|method|initSearcher
specifier|public
name|void
name|initSearcher
parameter_list|(
name|long
index|[]
name|nodeVersions
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|currentShardSearcher
operator|==
literal|null
assert|;
name|System
operator|.
name|arraycopy
argument_list|(
name|nodeVersions
argument_list|,
literal|0
argument_list|,
name|currentNodeVersions
argument_list|,
literal|0
argument_list|,
name|currentNodeVersions
operator|.
name|length
argument_list|)
expr_stmt|;
name|currentShardSearcher
operator|=
operator|new
name|ShardIndexSearcher
argument_list|(
name|currentNodeVersions
operator|.
name|clone
argument_list|()
argument_list|,
name|mgr
operator|.
name|acquire
argument_list|()
operator|.
name|getIndexReader
argument_list|()
argument_list|,
name|myNodeID
argument_list|)
expr_stmt|;
block|}
DECL|method|updateNodeVersion
specifier|public
name|void
name|updateNodeVersion
parameter_list|(
name|int
name|nodeID
parameter_list|,
name|long
name|version
parameter_list|)
throws|throws
name|IOException
block|{
name|currentNodeVersions
index|[
name|nodeID
index|]
operator|=
name|version
expr_stmt|;
if|if
condition|(
name|currentShardSearcher
operator|!=
literal|null
condition|)
block|{
name|currentShardSearcher
operator|.
name|getIndexReader
argument_list|()
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
name|currentShardSearcher
operator|=
operator|new
name|ShardIndexSearcher
argument_list|(
name|currentNodeVersions
operator|.
name|clone
argument_list|()
argument_list|,
name|mgr
operator|.
name|acquire
argument_list|()
operator|.
name|getIndexReader
argument_list|()
argument_list|,
name|myNodeID
argument_list|)
expr_stmt|;
block|}
comment|// Get the current (fresh) searcher for this node
DECL|method|acquire
specifier|public
name|ShardIndexSearcher
name|acquire
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|ShardIndexSearcher
name|s
init|=
name|currentShardSearcher
decl_stmt|;
comment|// In theory the reader could get decRef'd to 0
comment|// before we have a chance to incRef, ie if a reopen
comment|// happens right after the above line, this thread
comment|// gets stalled, and the old IR is closed.  So we
comment|// must try/retry until incRef succeeds:
if|if
condition|(
name|s
operator|.
name|getIndexReader
argument_list|()
operator|.
name|tryIncRef
argument_list|()
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
block|}
DECL|method|release
specifier|public
name|void
name|release
parameter_list|(
name|ShardIndexSearcher
name|s
parameter_list|)
throws|throws
name|IOException
block|{
name|s
operator|.
name|getIndexReader
argument_list|()
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
comment|// Get and old searcher matching the specified versions:
DECL|method|acquire
specifier|public
name|ShardIndexSearcher
name|acquire
parameter_list|(
name|long
index|[]
name|nodeVersions
parameter_list|)
block|{
specifier|final
name|IndexSearcher
name|s
init|=
name|searchers
operator|.
name|acquire
argument_list|(
name|nodeVersions
index|[
name|myNodeID
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SearcherExpiredException
argument_list|(
literal|"nodeID="
operator|+
name|myNodeID
operator|+
literal|" version="
operator|+
name|nodeVersions
index|[
name|myNodeID
index|]
argument_list|)
throw|;
block|}
return|return
operator|new
name|ShardIndexSearcher
argument_list|(
name|nodeVersions
argument_list|,
name|s
operator|.
name|getIndexReader
argument_list|()
argument_list|,
name|myNodeID
argument_list|)
return|;
block|}
comment|// Reopen local reader
DECL|method|reopen
specifier|public
name|void
name|reopen
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|IndexSearcher
name|before
init|=
name|mgr
operator|.
name|acquire
argument_list|()
decl_stmt|;
name|mgr
operator|.
name|release
argument_list|(
name|before
argument_list|)
expr_stmt|;
name|mgr
operator|.
name|maybeRefresh
argument_list|()
expr_stmt|;
specifier|final
name|IndexSearcher
name|after
init|=
name|mgr
operator|.
name|acquire
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|after
operator|!=
name|before
condition|)
block|{
comment|// New searcher was opened
specifier|final
name|long
name|version
init|=
name|searchers
operator|.
name|record
argument_list|(
name|after
argument_list|)
decl_stmt|;
name|searchers
operator|.
name|prune
argument_list|(
operator|new
name|SearcherLifetimeManager
operator|.
name|PruneByAge
argument_list|(
name|maxSearcherAgeSeconds
argument_list|)
argument_list|)
expr_stmt|;
name|broadcastNodeReopen
argument_list|(
name|myNodeID
argument_list|,
name|version
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|mgr
operator|.
name|release
argument_list|(
name|after
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentShardSearcher
operator|!=
literal|null
condition|)
block|{
name|currentShardSearcher
operator|.
name|getIndexReader
argument_list|()
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
name|searchers
operator|.
name|close
argument_list|()
expr_stmt|;
name|mgr
operator|.
name|close
argument_list|()
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|// TODO: make this more realistic, ie, each node should
comment|// have its own thread, so we have true node to node
comment|// concurrency
DECL|class|ChangeIndices
specifier|private
specifier|final
class|class
name|ChangeIndices
extends|extends
name|Thread
block|{
annotation|@
name|Override
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
specifier|final
name|LineFileDocs
name|docs
init|=
operator|new
name|LineFileDocs
argument_list|(
name|random
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|int
name|numDocs
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|<
name|endTimeNanos
condition|)
block|{
specifier|final
name|int
name|what
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|NodeState
name|node
init|=
name|nodes
index|[
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|nodes
operator|.
name|length
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|numDocs
operator|==
literal|0
operator|||
name|what
operator|==
literal|0
condition|)
block|{
name|node
operator|.
name|writer
operator|.
name|addDocument
argument_list|(
name|docs
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
name|numDocs
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|what
operator|==
literal|1
condition|)
block|{
name|node
operator|.
name|writer
operator|.
name|updateDocument
argument_list|(
operator|new
name|Term
argument_list|(
literal|"docid"
argument_list|,
literal|""
operator|+
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|numDocs
argument_list|)
argument_list|)
argument_list|,
name|docs
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
name|numDocs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|node
operator|.
name|writer
operator|.
name|deleteDocuments
argument_list|(
operator|new
name|Term
argument_list|(
literal|"docid"
argument_list|,
literal|""
operator|+
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|numDocs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// TODO: doc blocks too
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|17
argument_list|)
operator|==
literal|12
condition|)
block|{
name|node
operator|.
name|writer
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|17
argument_list|)
operator|==
literal|12
condition|)
block|{
name|nodes
index|[
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|nodes
operator|.
name|length
argument_list|)
index|]
operator|.
name|reopen
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FAILED:"
argument_list|)
expr_stmt|;
name|t
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|t
argument_list|)
throw|;
block|}
block|}
block|}
DECL|field|nodes
specifier|protected
name|NodeState
index|[]
name|nodes
decl_stmt|;
DECL|field|maxSearcherAgeSeconds
name|int
name|maxSearcherAgeSeconds
decl_stmt|;
DECL|field|endTimeNanos
name|long
name|endTimeNanos
decl_stmt|;
DECL|field|changeIndicesThread
specifier|private
name|Thread
name|changeIndicesThread
decl_stmt|;
DECL|method|start
specifier|protected
name|void
name|start
parameter_list|(
name|int
name|numNodes
parameter_list|,
name|double
name|runTimeSec
parameter_list|,
name|int
name|maxSearcherAgeSeconds
parameter_list|)
throws|throws
name|IOException
block|{
name|endTimeNanos
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
call|(
name|long
call|)
argument_list|(
name|runTimeSec
operator|*
literal|1000000000
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxSearcherAgeSeconds
operator|=
name|maxSearcherAgeSeconds
expr_stmt|;
name|nodes
operator|=
operator|new
name|NodeState
index|[
name|numNodes
index|]
expr_stmt|;
for|for
control|(
name|int
name|nodeID
init|=
literal|0
init|;
name|nodeID
operator|<
name|numNodes
condition|;
name|nodeID
operator|++
control|)
block|{
name|nodes
index|[
name|nodeID
index|]
operator|=
operator|new
name|NodeState
argument_list|(
name|random
argument_list|()
argument_list|,
name|nodeID
argument_list|,
name|numNodes
argument_list|)
expr_stmt|;
block|}
name|long
index|[]
name|nodeVersions
init|=
operator|new
name|long
index|[
name|nodes
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|nodeID
init|=
literal|0
init|;
name|nodeID
operator|<
name|numNodes
condition|;
name|nodeID
operator|++
control|)
block|{
specifier|final
name|IndexSearcher
name|s
init|=
name|nodes
index|[
name|nodeID
index|]
operator|.
name|mgr
operator|.
name|acquire
argument_list|()
decl_stmt|;
try|try
block|{
name|nodeVersions
index|[
name|nodeID
index|]
operator|=
name|nodes
index|[
name|nodeID
index|]
operator|.
name|searchers
operator|.
name|record
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|nodes
index|[
name|nodeID
index|]
operator|.
name|mgr
operator|.
name|release
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|nodeID
init|=
literal|0
init|;
name|nodeID
operator|<
name|numNodes
condition|;
name|nodeID
operator|++
control|)
block|{
specifier|final
name|IndexSearcher
name|s
init|=
name|nodes
index|[
name|nodeID
index|]
operator|.
name|mgr
operator|.
name|acquire
argument_list|()
decl_stmt|;
assert|assert
name|nodeVersions
index|[
name|nodeID
index|]
operator|==
name|nodes
index|[
name|nodeID
index|]
operator|.
name|searchers
operator|.
name|record
argument_list|(
name|s
argument_list|)
assert|;
assert|assert
name|s
operator|!=
literal|null
assert|;
try|try
block|{
name|broadcastNodeReopen
argument_list|(
name|nodeID
argument_list|,
name|nodeVersions
index|[
name|nodeID
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|nodes
index|[
name|nodeID
index|]
operator|.
name|mgr
operator|.
name|release
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|changeIndicesThread
operator|=
operator|new
name|ChangeIndices
argument_list|()
expr_stmt|;
name|changeIndicesThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|finish
specifier|protected
name|void
name|finish
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
name|changeIndicesThread
operator|.
name|join
argument_list|()
expr_stmt|;
for|for
control|(
name|NodeState
name|node
range|:
name|nodes
control|)
block|{
name|node
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * An IndexSearcher and associated version (lease)    */
DECL|class|SearcherAndVersion
specifier|protected
specifier|static
class|class
name|SearcherAndVersion
block|{
DECL|field|searcher
specifier|public
specifier|final
name|IndexSearcher
name|searcher
decl_stmt|;
DECL|field|version
specifier|public
specifier|final
name|long
name|version
decl_stmt|;
DECL|method|SearcherAndVersion
specifier|public
name|SearcherAndVersion
parameter_list|(
name|IndexSearcher
name|searcher
parameter_list|,
name|long
name|version
parameter_list|)
block|{
name|this
operator|.
name|searcher
operator|=
name|searcher
expr_stmt|;
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
