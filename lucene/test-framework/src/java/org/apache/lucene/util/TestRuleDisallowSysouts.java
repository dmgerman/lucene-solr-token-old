begin_unit
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
operator|.
name|SuppressSysoutChecks
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|RandomizedTest
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|rules
operator|.
name|TestRuleAdapter
import|;
end_import
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_comment
comment|/**  * Fails the suite if it prints anything to {@link System#out} or {@link System#err},  * unless the condition is not enforced (see {@link #isEnforced()}).  */
end_comment
begin_class
DECL|class|TestRuleDisallowSysouts
specifier|public
class|class
name|TestRuleDisallowSysouts
extends|extends
name|TestRuleAdapter
block|{
comment|/**     * Stack trace of any thread that wrote something to sysout or syserr.     */
DECL|field|firstWriteStack
specifier|private
specifier|final
specifier|static
name|AtomicReference
argument_list|<
name|StackTraceElement
index|[]
argument_list|>
name|firstWriteStack
init|=
operator|new
name|AtomicReference
argument_list|<
name|StackTraceElement
index|[]
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|capturedSystemOut
specifier|private
specifier|final
specifier|static
name|DelegateStream
name|capturedSystemOut
decl_stmt|;
DECL|field|capturedSystemErr
specifier|private
specifier|final
specifier|static
name|DelegateStream
name|capturedSystemErr
decl_stmt|;
static|static
block|{
name|System
operator|.
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|flush
argument_list|()
expr_stmt|;
specifier|final
name|String
name|csn
init|=
name|Charset
operator|.
name|defaultCharset
argument_list|()
operator|.
name|name
argument_list|()
decl_stmt|;
name|capturedSystemOut
operator|=
operator|new
name|DelegateStream
argument_list|(
name|System
operator|.
name|out
argument_list|,
name|csn
argument_list|,
name|firstWriteStack
argument_list|)
expr_stmt|;
name|capturedSystemErr
operator|=
operator|new
name|DelegateStream
argument_list|(
name|System
operator|.
name|err
argument_list|,
name|csn
argument_list|,
name|firstWriteStack
argument_list|)
expr_stmt|;
name|System
operator|.
name|setOut
argument_list|(
name|capturedSystemOut
operator|.
name|printStream
argument_list|)
expr_stmt|;
name|System
operator|.
name|setErr
argument_list|(
name|capturedSystemErr
operator|.
name|printStream
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test failures from any tests or rules before.    */
DECL|field|failureMarker
specifier|private
specifier|final
name|TestRuleMarkFailure
name|failureMarker
decl_stmt|;
comment|/**    * Sets {@link #firstWriteStack} to the current stack trace upon the first actual write    * to an underlying stream.    */
DECL|class|DelegateStream
specifier|static
class|class
name|DelegateStream
extends|extends
name|FilterOutputStream
block|{
DECL|field|firstWriteStack
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|StackTraceElement
index|[]
argument_list|>
name|firstWriteStack
decl_stmt|;
DECL|field|printStream
specifier|final
name|PrintStream
name|printStream
decl_stmt|;
DECL|method|DelegateStream
specifier|public
name|DelegateStream
parameter_list|(
name|OutputStream
name|delegate
parameter_list|,
name|String
name|charset
parameter_list|,
name|AtomicReference
argument_list|<
name|StackTraceElement
index|[]
argument_list|>
name|firstWriteStack
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|firstWriteStack
operator|=
name|firstWriteStack
expr_stmt|;
name|this
operator|.
name|printStream
operator|=
operator|new
name|PrintStream
argument_list|(
name|this
argument_list|,
literal|true
argument_list|,
name|charset
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|// Do override all three write() methods to make sure nothing slips through.
annotation|@
name|Override
DECL|method|write
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|b
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|bytesWritten
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|write
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|bytesWritten
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|write
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|bytesWritten
argument_list|()
expr_stmt|;
name|super
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
DECL|method|bytesWritten
specifier|private
name|void
name|bytesWritten
parameter_list|()
block|{
comment|// This check isn't really needed, but getting the stack is expensive and may involve
comment|// jit deopts, so we'll do it anyway.
if|if
condition|(
name|firstWriteStack
operator|.
name|get
argument_list|()
operator|==
literal|null
condition|)
block|{
name|firstWriteStack
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getStackTrace
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|TestRuleDisallowSysouts
specifier|public
name|TestRuleDisallowSysouts
parameter_list|(
name|TestRuleMarkFailure
name|failureMarker
parameter_list|)
block|{
name|this
operator|.
name|failureMarker
operator|=
name|failureMarker
expr_stmt|;
block|}
comment|/** */
annotation|@
name|Override
DECL|method|before
specifier|protected
name|void
name|before
parameter_list|()
throws|throws
name|Throwable
block|{
if|if
condition|(
name|isEnforced
argument_list|()
condition|)
block|{
name|checkCaptureStreams
argument_list|()
expr_stmt|;
block|}
name|resetCaptureState
argument_list|()
expr_stmt|;
block|}
comment|/**    * Ensures {@link System#out} and {@link System#err} point to delegate streams.    */
DECL|method|checkCaptureStreams
specifier|public
specifier|static
name|void
name|checkCaptureStreams
parameter_list|()
block|{
comment|// Make sure we still hold the right references to wrapper streams.
if|if
condition|(
name|System
operator|.
name|out
operator|!=
name|capturedSystemOut
operator|.
name|printStream
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Something has changed System.out to: "
operator|+
name|System
operator|.
name|out
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|System
operator|.
name|err
operator|!=
name|capturedSystemErr
operator|.
name|printStream
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Something has changed System.err to: "
operator|+
name|System
operator|.
name|err
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
DECL|method|isEnforced
specifier|protected
name|boolean
name|isEnforced
parameter_list|()
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
operator|||
name|LuceneTestCase
operator|.
name|INFOSTREAM
operator|||
name|RandomizedTest
operator|.
name|getContext
argument_list|()
operator|.
name|getTargetClass
argument_list|()
operator|.
name|isAnnotationPresent
argument_list|(
name|SuppressSysoutChecks
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|!
name|RandomizedTest
operator|.
name|systemPropertyAsBoolean
argument_list|(
name|LuceneTestCase
operator|.
name|SYSPROP_SYSOUTS
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * We're only interested in failing the suite if it was successful. Otherwise    * just propagate the original problem and don't bother.    */
annotation|@
name|Override
DECL|method|afterIfSuccessful
specifier|protected
name|void
name|afterIfSuccessful
parameter_list|()
throws|throws
name|Throwable
block|{
if|if
condition|(
name|isEnforced
argument_list|()
condition|)
block|{
name|checkCaptureStreams
argument_list|()
expr_stmt|;
comment|// Flush any buffers.
name|capturedSystemOut
operator|.
name|printStream
operator|.
name|flush
argument_list|()
expr_stmt|;
name|capturedSystemErr
operator|.
name|printStream
operator|.
name|flush
argument_list|()
expr_stmt|;
comment|// And check for offenders, but only if everything was successful so far.
name|StackTraceElement
index|[]
name|offenderStack
init|=
name|firstWriteStack
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|offenderStack
operator|!=
literal|null
operator|&&
name|failureMarker
operator|.
name|wasSuccessful
argument_list|()
condition|)
block|{
name|AssertionError
name|e
init|=
operator|new
name|AssertionError
argument_list|(
literal|"The test or suite printed information to stdout or stderr,"
operator|+
literal|" even though verbose mode is turned off and it's not annotated with @"
operator|+
name|SuppressSysoutChecks
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|". This exception contains the stack"
operator|+
literal|" trace of the first offending call."
argument_list|)
decl_stmt|;
name|e
operator|.
name|setStackTrace
argument_list|(
name|offenderStack
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**    * Restore original streams.    */
annotation|@
name|Override
DECL|method|afterAlways
specifier|protected
name|void
name|afterAlways
parameter_list|(
name|List
argument_list|<
name|Throwable
argument_list|>
name|errors
parameter_list|)
throws|throws
name|Throwable
block|{
name|resetCaptureState
argument_list|()
expr_stmt|;
block|}
DECL|method|resetCaptureState
specifier|private
name|void
name|resetCaptureState
parameter_list|()
block|{
name|capturedSystemOut
operator|.
name|printStream
operator|.
name|flush
argument_list|()
expr_stmt|;
name|capturedSystemErr
operator|.
name|printStream
operator|.
name|flush
argument_list|()
expr_stmt|;
name|firstWriteStack
operator|.
name|set
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
end_class
end_unit
