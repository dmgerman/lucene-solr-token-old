begin_unit
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import
begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|CharBuffer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|FileSystem
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|PatternSyntaxException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|ZipEntry
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|ZipInputStream
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|generators
operator|.
name|RandomInts
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|generators
operator|.
name|RandomPicks
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|DocValuesFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|PostingsFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|asserting
operator|.
name|AssertingCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|blockterms
operator|.
name|LuceneFixedGap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|blocktreeords
operator|.
name|BlockTreeOrdsPostingsFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene50
operator|.
name|Lucene50Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene50
operator|.
name|Lucene50DocValuesFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene50
operator|.
name|Lucene50PostingsFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|perfield
operator|.
name|PerFieldDocValuesFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|perfield
operator|.
name|PerFieldPostingsFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|BinaryDocValuesField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|DoubleField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
operator|.
name|NumericType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FloatField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|IntField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|LongField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|NumericDocValuesField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|SortedDocValuesField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CheckIndex
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|ConcurrentMergeScheduler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValuesType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|PostingsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FilterLeafReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexableField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LogMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MergeScheduler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CodecReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiFields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SlowCodecReaderWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TieredMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|mockfile
operator|.
name|FilterFileSystem
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|mockfile
operator|.
name|WindowsFS
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FieldDoc
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FilteredQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FilteredQuery
operator|.
name|FilterStrategy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|ScoreDoc
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TopDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FilterDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|NoLockFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import
begin_comment
comment|/**  * General utility methods for Lucene unit tests.   */
end_comment
begin_class
DECL|class|TestUtil
specifier|public
specifier|final
class|class
name|TestUtil
block|{
DECL|method|TestUtil
specifier|private
name|TestUtil
parameter_list|()
block|{
comment|//
block|}
comment|/**     * Convenience method unzipping zipName into destDir, cleaning up     * destDir first.    * Closes the given InputStream after extracting!     */
DECL|method|unzip
specifier|public
specifier|static
name|void
name|unzip
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|Path
name|destDir
parameter_list|)
throws|throws
name|IOException
block|{
name|in
operator|=
operator|new
name|BufferedInputStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|rm
argument_list|(
name|destDir
argument_list|)
expr_stmt|;
name|Files
operator|.
name|createDirectory
argument_list|(
name|destDir
argument_list|)
expr_stmt|;
try|try
init|(
name|ZipInputStream
name|zipInput
init|=
operator|new
name|ZipInputStream
argument_list|(
name|in
argument_list|)
init|)
block|{
name|ZipEntry
name|entry
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|8192
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|zipInput
operator|.
name|getNextEntry
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|Path
name|targetFile
init|=
name|destDir
operator|.
name|resolve
argument_list|(
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|// be on the safe side: do not rely on that directories are always extracted
comment|// before their children (although this makes sense, but is it guaranteed?)
name|Files
operator|.
name|createDirectories
argument_list|(
name|targetFile
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|OutputStream
name|out
init|=
name|Files
operator|.
name|newOutputStream
argument_list|(
name|targetFile
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|zipInput
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|zipInput
operator|.
name|closeEntry
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**     * Checks that the provided iterator is well-formed.    *<ul>    *<li>is read-only: does not allow {@code remove}    *<li>returns {@code expectedSize} number of elements    *<li>does not return null elements, unless {@code allowNull} is true.    *<li>throws NoSuchElementException if {@code next} is called    *       after {@code hasNext} returns false.     *</ul>    */
DECL|method|checkIterator
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|checkIterator
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|,
name|long
name|expectedSize
parameter_list|,
name|boolean
name|allowNull
parameter_list|)
block|{
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expectedSize
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|hasNext
init|=
name|iterator
operator|.
name|hasNext
argument_list|()
decl_stmt|;
assert|assert
name|hasNext
assert|;
name|T
name|v
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
assert|assert
name|allowNull
operator|||
name|v
operator|!=
literal|null
assert|;
try|try
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"broken iterator (supports remove): "
operator|+
name|iterator
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{
comment|// ok
block|}
block|}
assert|assert
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
assert|;
try|try
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"broken iterator (allows next() when hasNext==false) "
operator|+
name|iterator
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|expected
parameter_list|)
block|{
comment|// ok
block|}
block|}
comment|/**     * Checks that the provided iterator is well-formed.    *<ul>    *<li>is read-only: does not allow {@code remove}    *<li>does not return null elements.    *<li>throws NoSuchElementException if {@code next} is called    *       after {@code hasNext} returns false.     *</ul>    */
DECL|method|checkIterator
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|checkIterator
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|)
block|{
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|v
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
assert|assert
name|v
operator|!=
literal|null
assert|;
try|try
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"broken iterator (supports remove): "
operator|+
name|iterator
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|expected
parameter_list|)
block|{
comment|// ok
block|}
block|}
try|try
block|{
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"broken iterator (allows next() when hasNext==false) "
operator|+
name|iterator
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|expected
parameter_list|)
block|{
comment|// ok
block|}
block|}
comment|/**    * Checks that the provided collection is read-only.    * @see #checkIterator(Iterator)    */
DECL|method|checkReadOnly
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|checkReadOnly
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|coll
parameter_list|)
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|coll
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|size
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|!=
name|coll
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"broken collection, reported size is "
operator|+
name|coll
operator|.
name|size
argument_list|()
operator|+
literal|" but iterator has "
operator|+
name|size
operator|+
literal|" elements: "
operator|+
name|coll
argument_list|)
throw|;
block|}
if|if
condition|(
name|coll
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
try|try
block|{
name|coll
operator|.
name|remove
argument_list|(
name|coll
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"broken collection (supports remove): "
operator|+
name|coll
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// ok
block|}
block|}
try|try
block|{
name|coll
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"broken collection (supports add): "
operator|+
name|coll
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// ok
block|}
try|try
block|{
name|coll
operator|.
name|addAll
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"broken collection (supports addAll): "
operator|+
name|coll
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// ok
block|}
name|checkIterator
argument_list|(
name|coll
operator|.
name|iterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|syncConcurrentMerges
specifier|public
specifier|static
name|void
name|syncConcurrentMerges
parameter_list|(
name|IndexWriter
name|writer
parameter_list|)
block|{
name|syncConcurrentMerges
argument_list|(
name|writer
operator|.
name|getConfig
argument_list|()
operator|.
name|getMergeScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|syncConcurrentMerges
specifier|public
specifier|static
name|void
name|syncConcurrentMerges
parameter_list|(
name|MergeScheduler
name|ms
parameter_list|)
block|{
if|if
condition|(
name|ms
operator|instanceof
name|ConcurrentMergeScheduler
condition|)
operator|(
operator|(
name|ConcurrentMergeScheduler
operator|)
name|ms
operator|)
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
comment|/** This runs the CheckIndex tool on the index in.  If any    *  issues are hit, a RuntimeException is thrown; else,    *  true is returned. */
DECL|method|checkIndex
specifier|public
specifier|static
name|CheckIndex
operator|.
name|Status
name|checkIndex
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|checkIndex
argument_list|(
name|dir
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|checkIndex
specifier|public
specifier|static
name|CheckIndex
operator|.
name|Status
name|checkIndex
parameter_list|(
name|Directory
name|dir
parameter_list|,
name|boolean
name|crossCheckTermVectors
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|checkIndex
argument_list|(
name|dir
argument_list|,
name|crossCheckTermVectors
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** If failFast is true, then throw the first exception when index corruption is hit, instead of moving on to other fields/segments to    *  look for any other corruption.  */
DECL|method|checkIndex
specifier|public
specifier|static
name|CheckIndex
operator|.
name|Status
name|checkIndex
parameter_list|(
name|Directory
name|dir
parameter_list|,
name|boolean
name|crossCheckTermVectors
parameter_list|,
name|boolean
name|failFast
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|bos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
literal|1024
argument_list|)
decl_stmt|;
comment|// TODO: actually use the dir's locking, unless test uses a special method?
comment|// some tests e.g. exception tests become much more complicated if they have to close the writer
try|try
init|(
name|CheckIndex
name|checker
init|=
operator|new
name|CheckIndex
argument_list|(
name|dir
argument_list|,
name|NoLockFactory
operator|.
name|INSTANCE
operator|.
name|makeLock
argument_list|(
name|dir
argument_list|,
literal|"bogus"
argument_list|)
argument_list|)
init|)
block|{
name|checker
operator|.
name|setCrossCheckTermVectors
argument_list|(
name|crossCheckTermVectors
argument_list|)
expr_stmt|;
name|checker
operator|.
name|setFailFast
argument_list|(
name|failFast
argument_list|)
expr_stmt|;
name|checker
operator|.
name|setInfoStream
argument_list|(
operator|new
name|PrintStream
argument_list|(
name|bos
argument_list|,
literal|false
argument_list|,
name|IOUtils
operator|.
name|UTF_8
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|CheckIndex
operator|.
name|Status
name|indexStatus
init|=
name|checker
operator|.
name|checkIndex
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexStatus
operator|==
literal|null
operator|||
name|indexStatus
operator|.
name|clean
operator|==
literal|false
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"CheckIndex failed"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|bos
operator|.
name|toString
argument_list|(
name|IOUtils
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"CheckIndex failed"
argument_list|)
throw|;
block|}
else|else
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|INFOSTREAM
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|bos
operator|.
name|toString
argument_list|(
name|IOUtils
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|indexStatus
return|;
block|}
block|}
block|}
comment|/** This runs the CheckIndex tool on the Reader.  If any    *  issues are hit, a RuntimeException is thrown */
DECL|method|checkReader
specifier|public
specifier|static
name|void
name|checkReader
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|LeafReaderContext
name|context
range|:
name|reader
operator|.
name|leaves
argument_list|()
control|)
block|{
name|checkReader
argument_list|(
name|context
operator|.
name|reader
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|checkReader
specifier|public
specifier|static
name|void
name|checkReader
parameter_list|(
name|LeafReader
name|reader
parameter_list|,
name|boolean
name|crossCheckTermVectors
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|bos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
literal|1024
argument_list|)
decl_stmt|;
name|PrintStream
name|infoStream
init|=
operator|new
name|PrintStream
argument_list|(
name|bos
argument_list|,
literal|false
argument_list|,
name|IOUtils
operator|.
name|UTF_8
argument_list|)
decl_stmt|;
name|reader
operator|.
name|checkIntegrity
argument_list|()
expr_stmt|;
name|CheckIndex
operator|.
name|testLiveDocs
argument_list|(
name|reader
argument_list|,
name|infoStream
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|CheckIndex
operator|.
name|testFieldInfos
argument_list|(
name|reader
argument_list|,
name|infoStream
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|CheckIndex
operator|.
name|testFieldNorms
argument_list|(
name|reader
argument_list|,
name|infoStream
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|CheckIndex
operator|.
name|testPostings
argument_list|(
name|reader
argument_list|,
name|infoStream
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|CheckIndex
operator|.
name|testStoredFields
argument_list|(
name|reader
argument_list|,
name|infoStream
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|CheckIndex
operator|.
name|testTermVectors
argument_list|(
name|reader
argument_list|,
name|infoStream
argument_list|,
literal|false
argument_list|,
name|crossCheckTermVectors
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|CheckIndex
operator|.
name|testDocValues
argument_list|(
name|reader
argument_list|,
name|infoStream
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|LuceneTestCase
operator|.
name|INFOSTREAM
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|bos
operator|.
name|toString
argument_list|(
name|IOUtils
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LeafReader
name|unwrapped
init|=
name|FilterLeafReader
operator|.
name|unwrap
argument_list|(
name|reader
argument_list|)
decl_stmt|;
if|if
condition|(
name|unwrapped
operator|instanceof
name|SegmentReader
condition|)
block|{
name|SegmentReader
name|sr
init|=
operator|(
name|SegmentReader
operator|)
name|unwrapped
decl_stmt|;
name|long
name|bytesUsed
init|=
name|sr
operator|.
name|ramBytesUsed
argument_list|()
decl_stmt|;
if|if
condition|(
name|sr
operator|.
name|ramBytesUsed
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"invalid ramBytesUsed for reader: "
operator|+
name|bytesUsed
argument_list|)
throw|;
block|}
assert|assert
name|Accountables
operator|.
name|toString
argument_list|(
name|sr
argument_list|)
operator|!=
literal|null
assert|;
block|}
block|}
comment|/** start and end are BOTH inclusive */
DECL|method|nextInt
specifier|public
specifier|static
name|int
name|nextInt
parameter_list|(
name|Random
name|r
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
return|return
name|RandomInts
operator|.
name|randomIntBetween
argument_list|(
name|r
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
return|;
block|}
comment|/** start and end are BOTH inclusive */
DECL|method|nextLong
specifier|public
specifier|static
name|long
name|nextLong
parameter_list|(
name|Random
name|r
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|)
block|{
assert|assert
name|end
operator|>=
name|start
assert|;
specifier|final
name|BigInteger
name|range
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|end
argument_list|)
operator|.
name|add
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|subtract
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|start
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|compareTo
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
return|return
name|start
operator|+
name|r
operator|.
name|nextInt
argument_list|(
name|range
operator|.
name|intValue
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// probably not evenly distributed when range is large, but OK for tests
specifier|final
name|BigInteger
name|augend
init|=
operator|new
name|BigDecimal
argument_list|(
name|range
argument_list|)
operator|.
name|multiply
argument_list|(
operator|new
name|BigDecimal
argument_list|(
name|r
operator|.
name|nextDouble
argument_list|()
argument_list|)
argument_list|)
operator|.
name|toBigInteger
argument_list|()
decl_stmt|;
specifier|final
name|long
name|result
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|start
argument_list|)
operator|.
name|add
argument_list|(
name|augend
argument_list|)
operator|.
name|longValue
argument_list|()
decl_stmt|;
assert|assert
name|result
operator|>=
name|start
assert|;
assert|assert
name|result
operator|<=
name|end
assert|;
return|return
name|result
return|;
block|}
block|}
DECL|method|randomSimpleString
specifier|public
specifier|static
name|String
name|randomSimpleString
parameter_list|(
name|Random
name|r
parameter_list|,
name|int
name|maxLength
parameter_list|)
block|{
return|return
name|randomSimpleString
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|maxLength
argument_list|)
return|;
block|}
DECL|method|randomSimpleString
specifier|public
specifier|static
name|String
name|randomSimpleString
parameter_list|(
name|Random
name|r
parameter_list|,
name|int
name|minLength
parameter_list|,
name|int
name|maxLength
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|nextInt
argument_list|(
name|r
argument_list|,
name|minLength
argument_list|,
name|maxLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
literal|0
condition|)
block|{
comment|// allow 0 length
return|return
literal|""
return|;
block|}
specifier|final
name|char
index|[]
name|buffer
init|=
operator|new
name|char
index|[
name|end
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|'a'
argument_list|,
literal|'z'
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|end
argument_list|)
return|;
block|}
DECL|method|randomSimpleStringRange
specifier|public
specifier|static
name|String
name|randomSimpleStringRange
parameter_list|(
name|Random
name|r
parameter_list|,
name|char
name|minChar
parameter_list|,
name|char
name|maxChar
parameter_list|,
name|int
name|maxLength
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|nextInt
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|maxLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
literal|0
condition|)
block|{
comment|// allow 0 length
return|return
literal|""
return|;
block|}
specifier|final
name|char
index|[]
name|buffer
init|=
operator|new
name|char
index|[
name|end
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
name|minChar
argument_list|,
name|maxChar
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|end
argument_list|)
return|;
block|}
DECL|method|randomSimpleString
specifier|public
specifier|static
name|String
name|randomSimpleString
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
return|return
name|randomSimpleString
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
return|;
block|}
comment|/** Returns random string, including full unicode range. */
DECL|method|randomUnicodeString
specifier|public
specifier|static
name|String
name|randomUnicodeString
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
return|return
name|randomUnicodeString
argument_list|(
name|r
argument_list|,
literal|20
argument_list|)
return|;
block|}
comment|/**    * Returns a random string up to a certain length.    */
DECL|method|randomUnicodeString
specifier|public
specifier|static
name|String
name|randomUnicodeString
parameter_list|(
name|Random
name|r
parameter_list|,
name|int
name|maxLength
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|nextInt
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|maxLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
literal|0
condition|)
block|{
comment|// allow 0 length
return|return
literal|""
return|;
block|}
specifier|final
name|char
index|[]
name|buffer
init|=
operator|new
name|char
index|[
name|end
index|]
decl_stmt|;
name|randomFixedLengthUnicodeString
argument_list|(
name|r
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|end
argument_list|)
return|;
block|}
comment|/**    * Fills provided char[] with valid random unicode code    * unit sequence.    */
DECL|method|randomFixedLengthUnicodeString
specifier|public
specifier|static
name|void
name|randomFixedLengthUnicodeString
parameter_list|(
name|Random
name|random
parameter_list|,
name|char
index|[]
name|chars
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|i
init|=
name|offset
decl_stmt|;
specifier|final
name|int
name|end
init|=
name|offset
operator|+
name|length
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|end
condition|)
block|{
specifier|final
name|int
name|t
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|t
operator|&&
name|i
operator|<
name|length
operator|-
literal|1
condition|)
block|{
comment|// Make a surrogate pair
comment|// High surrogate
name|chars
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0xd800
argument_list|,
literal|0xdbff
argument_list|)
expr_stmt|;
comment|// Low surrogate
name|chars
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0xdc00
argument_list|,
literal|0xdfff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|<=
literal|1
condition|)
block|{
name|chars
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|random
operator|.
name|nextInt
argument_list|(
literal|0x80
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|2
operator|==
name|t
condition|)
block|{
name|chars
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0x80
argument_list|,
literal|0x7ff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|3
operator|==
name|t
condition|)
block|{
name|chars
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0x800
argument_list|,
literal|0xd7ff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|4
operator|==
name|t
condition|)
block|{
name|chars
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0xe000
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns a String thats "regexpish" (contains lots of operators typically found in regular expressions)    * If you call this enough times, you might get a valid regex!    */
DECL|method|randomRegexpishString
specifier|public
specifier|static
name|String
name|randomRegexpishString
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
return|return
name|randomRegexpishString
argument_list|(
name|r
argument_list|,
literal|20
argument_list|)
return|;
block|}
comment|/**    * Maximum recursion bound for '+' and '*' replacements in    * {@link #randomRegexpishString(Random, int)}.    */
DECL|field|maxRecursionBound
specifier|private
specifier|final
specifier|static
name|int
name|maxRecursionBound
init|=
literal|5
decl_stmt|;
comment|/**    * Operators for {@link #randomRegexpishString(Random, int)}.    */
DECL|field|ops
specifier|private
specifier|final
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|ops
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"."
argument_list|,
literal|"?"
argument_list|,
literal|"{0,"
operator|+
name|maxRecursionBound
operator|+
literal|"}"
argument_list|,
comment|// bounded replacement for '*'
literal|"{1,"
operator|+
name|maxRecursionBound
operator|+
literal|"}"
argument_list|,
comment|// bounded replacement for '+'
literal|"("
argument_list|,
literal|")"
argument_list|,
literal|"-"
argument_list|,
literal|"["
argument_list|,
literal|"]"
argument_list|,
literal|"|"
argument_list|)
decl_stmt|;
comment|/**    * Returns a String thats "regexpish" (contains lots of operators typically found in regular expressions)    * If you call this enough times, you might get a valid regex!    *     *<P>Note: to avoid practically endless backtracking patterns we replace asterisk and plus    * operators with bounded repetitions. See LUCENE-4111 for more info.    *     * @param maxLength A hint about maximum length of the regexpish string. It may be exceeded by a few characters.    */
DECL|method|randomRegexpishString
specifier|public
specifier|static
name|String
name|randomRegexpishString
parameter_list|(
name|Random
name|r
parameter_list|,
name|int
name|maxLength
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|regexp
init|=
operator|new
name|StringBuilder
argument_list|(
name|maxLength
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|nextInt
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|maxLength
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|regexp
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|RandomInts
operator|.
name|randomIntBetween
argument_list|(
name|r
argument_list|,
literal|'a'
argument_list|,
literal|'z'
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|regexp
operator|.
name|append
argument_list|(
name|RandomPicks
operator|.
name|randomFrom
argument_list|(
name|r
argument_list|,
name|ops
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|regexp
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|field|HTML_CHAR_ENTITIES
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|HTML_CHAR_ENTITIES
init|=
block|{
literal|"AElig"
block|,
literal|"Aacute"
block|,
literal|"Acirc"
block|,
literal|"Agrave"
block|,
literal|"Alpha"
block|,
literal|"AMP"
block|,
literal|"Aring"
block|,
literal|"Atilde"
block|,
literal|"Auml"
block|,
literal|"Beta"
block|,
literal|"COPY"
block|,
literal|"Ccedil"
block|,
literal|"Chi"
block|,
literal|"Dagger"
block|,
literal|"Delta"
block|,
literal|"ETH"
block|,
literal|"Eacute"
block|,
literal|"Ecirc"
block|,
literal|"Egrave"
block|,
literal|"Epsilon"
block|,
literal|"Eta"
block|,
literal|"Euml"
block|,
literal|"Gamma"
block|,
literal|"GT"
block|,
literal|"Iacute"
block|,
literal|"Icirc"
block|,
literal|"Igrave"
block|,
literal|"Iota"
block|,
literal|"Iuml"
block|,
literal|"Kappa"
block|,
literal|"Lambda"
block|,
literal|"LT"
block|,
literal|"Mu"
block|,
literal|"Ntilde"
block|,
literal|"Nu"
block|,
literal|"OElig"
block|,
literal|"Oacute"
block|,
literal|"Ocirc"
block|,
literal|"Ograve"
block|,
literal|"Omega"
block|,
literal|"Omicron"
block|,
literal|"Oslash"
block|,
literal|"Otilde"
block|,
literal|"Ouml"
block|,
literal|"Phi"
block|,
literal|"Pi"
block|,
literal|"Prime"
block|,
literal|"Psi"
block|,
literal|"QUOT"
block|,
literal|"REG"
block|,
literal|"Rho"
block|,
literal|"Scaron"
block|,
literal|"Sigma"
block|,
literal|"THORN"
block|,
literal|"Tau"
block|,
literal|"Theta"
block|,
literal|"Uacute"
block|,
literal|"Ucirc"
block|,
literal|"Ugrave"
block|,
literal|"Upsilon"
block|,
literal|"Uuml"
block|,
literal|"Xi"
block|,
literal|"Yacute"
block|,
literal|"Yuml"
block|,
literal|"Zeta"
block|,
literal|"aacute"
block|,
literal|"acirc"
block|,
literal|"acute"
block|,
literal|"aelig"
block|,
literal|"agrave"
block|,
literal|"alefsym"
block|,
literal|"alpha"
block|,
literal|"amp"
block|,
literal|"and"
block|,
literal|"ang"
block|,
literal|"apos"
block|,
literal|"aring"
block|,
literal|"asymp"
block|,
literal|"atilde"
block|,
literal|"auml"
block|,
literal|"bdquo"
block|,
literal|"beta"
block|,
literal|"brvbar"
block|,
literal|"bull"
block|,
literal|"cap"
block|,
literal|"ccedil"
block|,
literal|"cedil"
block|,
literal|"cent"
block|,
literal|"chi"
block|,
literal|"circ"
block|,
literal|"clubs"
block|,
literal|"cong"
block|,
literal|"copy"
block|,
literal|"crarr"
block|,
literal|"cup"
block|,
literal|"curren"
block|,
literal|"dArr"
block|,
literal|"dagger"
block|,
literal|"darr"
block|,
literal|"deg"
block|,
literal|"delta"
block|,
literal|"diams"
block|,
literal|"divide"
block|,
literal|"eacute"
block|,
literal|"ecirc"
block|,
literal|"egrave"
block|,
literal|"empty"
block|,
literal|"emsp"
block|,
literal|"ensp"
block|,
literal|"epsilon"
block|,
literal|"equiv"
block|,
literal|"eta"
block|,
literal|"eth"
block|,
literal|"euml"
block|,
literal|"euro"
block|,
literal|"exist"
block|,
literal|"fnof"
block|,
literal|"forall"
block|,
literal|"frac12"
block|,
literal|"frac14"
block|,
literal|"frac34"
block|,
literal|"frasl"
block|,
literal|"gamma"
block|,
literal|"ge"
block|,
literal|"gt"
block|,
literal|"hArr"
block|,
literal|"harr"
block|,
literal|"hearts"
block|,
literal|"hellip"
block|,
literal|"iacute"
block|,
literal|"icirc"
block|,
literal|"iexcl"
block|,
literal|"igrave"
block|,
literal|"image"
block|,
literal|"infin"
block|,
literal|"int"
block|,
literal|"iota"
block|,
literal|"iquest"
block|,
literal|"isin"
block|,
literal|"iuml"
block|,
literal|"kappa"
block|,
literal|"lArr"
block|,
literal|"lambda"
block|,
literal|"lang"
block|,
literal|"laquo"
block|,
literal|"larr"
block|,
literal|"lceil"
block|,
literal|"ldquo"
block|,
literal|"le"
block|,
literal|"lfloor"
block|,
literal|"lowast"
block|,
literal|"loz"
block|,
literal|"lrm"
block|,
literal|"lsaquo"
block|,
literal|"lsquo"
block|,
literal|"lt"
block|,
literal|"macr"
block|,
literal|"mdash"
block|,
literal|"micro"
block|,
literal|"middot"
block|,
literal|"minus"
block|,
literal|"mu"
block|,
literal|"nabla"
block|,
literal|"nbsp"
block|,
literal|"ndash"
block|,
literal|"ne"
block|,
literal|"ni"
block|,
literal|"not"
block|,
literal|"notin"
block|,
literal|"nsub"
block|,
literal|"ntilde"
block|,
literal|"nu"
block|,
literal|"oacute"
block|,
literal|"ocirc"
block|,
literal|"oelig"
block|,
literal|"ograve"
block|,
literal|"oline"
block|,
literal|"omega"
block|,
literal|"omicron"
block|,
literal|"oplus"
block|,
literal|"or"
block|,
literal|"ordf"
block|,
literal|"ordm"
block|,
literal|"oslash"
block|,
literal|"otilde"
block|,
literal|"otimes"
block|,
literal|"ouml"
block|,
literal|"para"
block|,
literal|"part"
block|,
literal|"permil"
block|,
literal|"perp"
block|,
literal|"phi"
block|,
literal|"pi"
block|,
literal|"piv"
block|,
literal|"plusmn"
block|,
literal|"pound"
block|,
literal|"prime"
block|,
literal|"prod"
block|,
literal|"prop"
block|,
literal|"psi"
block|,
literal|"quot"
block|,
literal|"rArr"
block|,
literal|"radic"
block|,
literal|"rang"
block|,
literal|"raquo"
block|,
literal|"rarr"
block|,
literal|"rceil"
block|,
literal|"rdquo"
block|,
literal|"real"
block|,
literal|"reg"
block|,
literal|"rfloor"
block|,
literal|"rho"
block|,
literal|"rlm"
block|,
literal|"rsaquo"
block|,
literal|"rsquo"
block|,
literal|"sbquo"
block|,
literal|"scaron"
block|,
literal|"sdot"
block|,
literal|"sect"
block|,
literal|"shy"
block|,
literal|"sigma"
block|,
literal|"sigmaf"
block|,
literal|"sim"
block|,
literal|"spades"
block|,
literal|"sub"
block|,
literal|"sube"
block|,
literal|"sum"
block|,
literal|"sup"
block|,
literal|"sup1"
block|,
literal|"sup2"
block|,
literal|"sup3"
block|,
literal|"supe"
block|,
literal|"szlig"
block|,
literal|"tau"
block|,
literal|"there4"
block|,
literal|"theta"
block|,
literal|"thetasym"
block|,
literal|"thinsp"
block|,
literal|"thorn"
block|,
literal|"tilde"
block|,
literal|"times"
block|,
literal|"trade"
block|,
literal|"uArr"
block|,
literal|"uacute"
block|,
literal|"uarr"
block|,
literal|"ucirc"
block|,
literal|"ugrave"
block|,
literal|"uml"
block|,
literal|"upsih"
block|,
literal|"upsilon"
block|,
literal|"uuml"
block|,
literal|"weierp"
block|,
literal|"xi"
block|,
literal|"yacute"
block|,
literal|"yen"
block|,
literal|"yuml"
block|,
literal|"zeta"
block|,
literal|"zwj"
block|,
literal|"zwnj"
block|}
decl_stmt|;
DECL|method|randomHtmlishString
specifier|public
specifier|static
name|String
name|randomHtmlishString
parameter_list|(
name|Random
name|random
parameter_list|,
name|int
name|numElements
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
name|numElements
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
literal|0
condition|)
block|{
comment|// allow 0 length
return|return
literal|""
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|int
name|val
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|25
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
literal|0
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"<p>"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"<"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"    "
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|randomSimpleString
argument_list|(
name|random
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|randomSimpleString
argument_list|(
name|random
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" "
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" "
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\""
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|randomSimpleString
argument_list|(
name|random
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\""
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"    "
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"/"
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|">"
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|2
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"</"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"    "
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|randomSimpleString
argument_list|(
name|random
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"    "
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|">"
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|3
case|:
name|sb
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"</p>"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"<!--"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"<!--#"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"<script><!-- f('"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"</script>"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"<?"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"?>"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\\'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"-->"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"&"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|sb
operator|.
name|append
argument_list|(
name|randomSimpleString
argument_list|(
name|random
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sb
operator|.
name|append
argument_list|(
name|HTML_CHAR_ENTITIES
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|HTML_CHAR_ENTITIES
operator|.
name|length
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|";"
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|17
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"&#"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|";"
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|18
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"&#x"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|1
argument_list|)
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|";"
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|19
case|:
name|sb
operator|.
name|append
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|20
case|:
name|sb
operator|.
name|append
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|21
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|22
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"          "
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|23
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"<"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"          "
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"          "
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|sb
operator|.
name|append
argument_list|(
name|randomlyRecaseCodePoints
argument_list|(
name|random
argument_list|,
literal|"script"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sb
operator|.
name|append
argument_list|(
name|randomlyRecaseCodePoints
argument_list|(
name|random
argument_list|,
literal|"style"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sb
operator|.
name|append
argument_list|(
name|randomlyRecaseCodePoints
argument_list|(
name|random
argument_list|,
literal|"br"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// default: append nothing
block|}
name|sb
operator|.
name|append
argument_list|(
literal|">"
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|sb
operator|.
name|append
argument_list|(
name|randomSimpleString
argument_list|(
name|random
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Randomly upcases, downcases, or leaves intact each code point in the given string    */
DECL|method|randomlyRecaseCodePoints
specifier|public
specifier|static
name|String
name|randomlyRecaseCodePoints
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|str
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|str
operator|.
name|length
argument_list|()
condition|)
block|{
name|int
name|codePoint
init|=
name|str
operator|.
name|codePointAt
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|codePoint
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|builder
operator|.
name|appendCodePoint
argument_list|(
name|Character
operator|.
name|toUpperCase
argument_list|(
name|codePoint
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|builder
operator|.
name|appendCodePoint
argument_list|(
name|Character
operator|.
name|toLowerCase
argument_list|(
name|codePoint
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|builder
operator|.
name|appendCodePoint
argument_list|(
name|codePoint
argument_list|)
expr_stmt|;
comment|// leave intact
block|}
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|field|blockStarts
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|blockStarts
init|=
block|{
literal|0x0000
block|,
literal|0x0080
block|,
literal|0x0100
block|,
literal|0x0180
block|,
literal|0x0250
block|,
literal|0x02B0
block|,
literal|0x0300
block|,
literal|0x0370
block|,
literal|0x0400
block|,
literal|0x0500
block|,
literal|0x0530
block|,
literal|0x0590
block|,
literal|0x0600
block|,
literal|0x0700
block|,
literal|0x0750
block|,
literal|0x0780
block|,
literal|0x07C0
block|,
literal|0x0800
block|,
literal|0x0900
block|,
literal|0x0980
block|,
literal|0x0A00
block|,
literal|0x0A80
block|,
literal|0x0B00
block|,
literal|0x0B80
block|,
literal|0x0C00
block|,
literal|0x0C80
block|,
literal|0x0D00
block|,
literal|0x0D80
block|,
literal|0x0E00
block|,
literal|0x0E80
block|,
literal|0x0F00
block|,
literal|0x1000
block|,
literal|0x10A0
block|,
literal|0x1100
block|,
literal|0x1200
block|,
literal|0x1380
block|,
literal|0x13A0
block|,
literal|0x1400
block|,
literal|0x1680
block|,
literal|0x16A0
block|,
literal|0x1700
block|,
literal|0x1720
block|,
literal|0x1740
block|,
literal|0x1760
block|,
literal|0x1780
block|,
literal|0x1800
block|,
literal|0x18B0
block|,
literal|0x1900
block|,
literal|0x1950
block|,
literal|0x1980
block|,
literal|0x19E0
block|,
literal|0x1A00
block|,
literal|0x1A20
block|,
literal|0x1B00
block|,
literal|0x1B80
block|,
literal|0x1C00
block|,
literal|0x1C50
block|,
literal|0x1CD0
block|,
literal|0x1D00
block|,
literal|0x1D80
block|,
literal|0x1DC0
block|,
literal|0x1E00
block|,
literal|0x1F00
block|,
literal|0x2000
block|,
literal|0x2070
block|,
literal|0x20A0
block|,
literal|0x20D0
block|,
literal|0x2100
block|,
literal|0x2150
block|,
literal|0x2190
block|,
literal|0x2200
block|,
literal|0x2300
block|,
literal|0x2400
block|,
literal|0x2440
block|,
literal|0x2460
block|,
literal|0x2500
block|,
literal|0x2580
block|,
literal|0x25A0
block|,
literal|0x2600
block|,
literal|0x2700
block|,
literal|0x27C0
block|,
literal|0x27F0
block|,
literal|0x2800
block|,
literal|0x2900
block|,
literal|0x2980
block|,
literal|0x2A00
block|,
literal|0x2B00
block|,
literal|0x2C00
block|,
literal|0x2C60
block|,
literal|0x2C80
block|,
literal|0x2D00
block|,
literal|0x2D30
block|,
literal|0x2D80
block|,
literal|0x2DE0
block|,
literal|0x2E00
block|,
literal|0x2E80
block|,
literal|0x2F00
block|,
literal|0x2FF0
block|,
literal|0x3000
block|,
literal|0x3040
block|,
literal|0x30A0
block|,
literal|0x3100
block|,
literal|0x3130
block|,
literal|0x3190
block|,
literal|0x31A0
block|,
literal|0x31C0
block|,
literal|0x31F0
block|,
literal|0x3200
block|,
literal|0x3300
block|,
literal|0x3400
block|,
literal|0x4DC0
block|,
literal|0x4E00
block|,
literal|0xA000
block|,
literal|0xA490
block|,
literal|0xA4D0
block|,
literal|0xA500
block|,
literal|0xA640
block|,
literal|0xA6A0
block|,
literal|0xA700
block|,
literal|0xA720
block|,
literal|0xA800
block|,
literal|0xA830
block|,
literal|0xA840
block|,
literal|0xA880
block|,
literal|0xA8E0
block|,
literal|0xA900
block|,
literal|0xA930
block|,
literal|0xA960
block|,
literal|0xA980
block|,
literal|0xAA00
block|,
literal|0xAA60
block|,
literal|0xAA80
block|,
literal|0xABC0
block|,
literal|0xAC00
block|,
literal|0xD7B0
block|,
literal|0xE000
block|,
literal|0xF900
block|,
literal|0xFB00
block|,
literal|0xFB50
block|,
literal|0xFE00
block|,
literal|0xFE10
block|,
literal|0xFE20
block|,
literal|0xFE30
block|,
literal|0xFE50
block|,
literal|0xFE70
block|,
literal|0xFF00
block|,
literal|0xFFF0
block|,
literal|0x10000
block|,
literal|0x10080
block|,
literal|0x10100
block|,
literal|0x10140
block|,
literal|0x10190
block|,
literal|0x101D0
block|,
literal|0x10280
block|,
literal|0x102A0
block|,
literal|0x10300
block|,
literal|0x10330
block|,
literal|0x10380
block|,
literal|0x103A0
block|,
literal|0x10400
block|,
literal|0x10450
block|,
literal|0x10480
block|,
literal|0x10800
block|,
literal|0x10840
block|,
literal|0x10900
block|,
literal|0x10920
block|,
literal|0x10A00
block|,
literal|0x10A60
block|,
literal|0x10B00
block|,
literal|0x10B40
block|,
literal|0x10B60
block|,
literal|0x10C00
block|,
literal|0x10E60
block|,
literal|0x11080
block|,
literal|0x12000
block|,
literal|0x12400
block|,
literal|0x13000
block|,
literal|0x1D000
block|,
literal|0x1D100
block|,
literal|0x1D200
block|,
literal|0x1D300
block|,
literal|0x1D360
block|,
literal|0x1D400
block|,
literal|0x1F000
block|,
literal|0x1F030
block|,
literal|0x1F100
block|,
literal|0x1F200
block|,
literal|0x20000
block|,
literal|0x2A700
block|,
literal|0x2F800
block|,
literal|0xE0000
block|,
literal|0xE0100
block|,
literal|0xF0000
block|,
literal|0x100000
block|}
decl_stmt|;
DECL|field|blockEnds
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|blockEnds
init|=
block|{
literal|0x007F
block|,
literal|0x00FF
block|,
literal|0x017F
block|,
literal|0x024F
block|,
literal|0x02AF
block|,
literal|0x02FF
block|,
literal|0x036F
block|,
literal|0x03FF
block|,
literal|0x04FF
block|,
literal|0x052F
block|,
literal|0x058F
block|,
literal|0x05FF
block|,
literal|0x06FF
block|,
literal|0x074F
block|,
literal|0x077F
block|,
literal|0x07BF
block|,
literal|0x07FF
block|,
literal|0x083F
block|,
literal|0x097F
block|,
literal|0x09FF
block|,
literal|0x0A7F
block|,
literal|0x0AFF
block|,
literal|0x0B7F
block|,
literal|0x0BFF
block|,
literal|0x0C7F
block|,
literal|0x0CFF
block|,
literal|0x0D7F
block|,
literal|0x0DFF
block|,
literal|0x0E7F
block|,
literal|0x0EFF
block|,
literal|0x0FFF
block|,
literal|0x109F
block|,
literal|0x10FF
block|,
literal|0x11FF
block|,
literal|0x137F
block|,
literal|0x139F
block|,
literal|0x13FF
block|,
literal|0x167F
block|,
literal|0x169F
block|,
literal|0x16FF
block|,
literal|0x171F
block|,
literal|0x173F
block|,
literal|0x175F
block|,
literal|0x177F
block|,
literal|0x17FF
block|,
literal|0x18AF
block|,
literal|0x18FF
block|,
literal|0x194F
block|,
literal|0x197F
block|,
literal|0x19DF
block|,
literal|0x19FF
block|,
literal|0x1A1F
block|,
literal|0x1AAF
block|,
literal|0x1B7F
block|,
literal|0x1BBF
block|,
literal|0x1C4F
block|,
literal|0x1C7F
block|,
literal|0x1CFF
block|,
literal|0x1D7F
block|,
literal|0x1DBF
block|,
literal|0x1DFF
block|,
literal|0x1EFF
block|,
literal|0x1FFF
block|,
literal|0x206F
block|,
literal|0x209F
block|,
literal|0x20CF
block|,
literal|0x20FF
block|,
literal|0x214F
block|,
literal|0x218F
block|,
literal|0x21FF
block|,
literal|0x22FF
block|,
literal|0x23FF
block|,
literal|0x243F
block|,
literal|0x245F
block|,
literal|0x24FF
block|,
literal|0x257F
block|,
literal|0x259F
block|,
literal|0x25FF
block|,
literal|0x26FF
block|,
literal|0x27BF
block|,
literal|0x27EF
block|,
literal|0x27FF
block|,
literal|0x28FF
block|,
literal|0x297F
block|,
literal|0x29FF
block|,
literal|0x2AFF
block|,
literal|0x2BFF
block|,
literal|0x2C5F
block|,
literal|0x2C7F
block|,
literal|0x2CFF
block|,
literal|0x2D2F
block|,
literal|0x2D7F
block|,
literal|0x2DDF
block|,
literal|0x2DFF
block|,
literal|0x2E7F
block|,
literal|0x2EFF
block|,
literal|0x2FDF
block|,
literal|0x2FFF
block|,
literal|0x303F
block|,
literal|0x309F
block|,
literal|0x30FF
block|,
literal|0x312F
block|,
literal|0x318F
block|,
literal|0x319F
block|,
literal|0x31BF
block|,
literal|0x31EF
block|,
literal|0x31FF
block|,
literal|0x32FF
block|,
literal|0x33FF
block|,
literal|0x4DBF
block|,
literal|0x4DFF
block|,
literal|0x9FFF
block|,
literal|0xA48F
block|,
literal|0xA4CF
block|,
literal|0xA4FF
block|,
literal|0xA63F
block|,
literal|0xA69F
block|,
literal|0xA6FF
block|,
literal|0xA71F
block|,
literal|0xA7FF
block|,
literal|0xA82F
block|,
literal|0xA83F
block|,
literal|0xA87F
block|,
literal|0xA8DF
block|,
literal|0xA8FF
block|,
literal|0xA92F
block|,
literal|0xA95F
block|,
literal|0xA97F
block|,
literal|0xA9DF
block|,
literal|0xAA5F
block|,
literal|0xAA7F
block|,
literal|0xAADF
block|,
literal|0xABFF
block|,
literal|0xD7AF
block|,
literal|0xD7FF
block|,
literal|0xF8FF
block|,
literal|0xFAFF
block|,
literal|0xFB4F
block|,
literal|0xFDFF
block|,
literal|0xFE0F
block|,
literal|0xFE1F
block|,
literal|0xFE2F
block|,
literal|0xFE4F
block|,
literal|0xFE6F
block|,
literal|0xFEFF
block|,
literal|0xFFEF
block|,
literal|0xFFFF
block|,
literal|0x1007F
block|,
literal|0x100FF
block|,
literal|0x1013F
block|,
literal|0x1018F
block|,
literal|0x101CF
block|,
literal|0x101FF
block|,
literal|0x1029F
block|,
literal|0x102DF
block|,
literal|0x1032F
block|,
literal|0x1034F
block|,
literal|0x1039F
block|,
literal|0x103DF
block|,
literal|0x1044F
block|,
literal|0x1047F
block|,
literal|0x104AF
block|,
literal|0x1083F
block|,
literal|0x1085F
block|,
literal|0x1091F
block|,
literal|0x1093F
block|,
literal|0x10A5F
block|,
literal|0x10A7F
block|,
literal|0x10B3F
block|,
literal|0x10B5F
block|,
literal|0x10B7F
block|,
literal|0x10C4F
block|,
literal|0x10E7F
block|,
literal|0x110CF
block|,
literal|0x123FF
block|,
literal|0x1247F
block|,
literal|0x1342F
block|,
literal|0x1D0FF
block|,
literal|0x1D1FF
block|,
literal|0x1D24F
block|,
literal|0x1D35F
block|,
literal|0x1D37F
block|,
literal|0x1D7FF
block|,
literal|0x1F02F
block|,
literal|0x1F09F
block|,
literal|0x1F1FF
block|,
literal|0x1F2FF
block|,
literal|0x2A6DF
block|,
literal|0x2B73F
block|,
literal|0x2FA1F
block|,
literal|0xE007F
block|,
literal|0xE01EF
block|,
literal|0xFFFFF
block|,
literal|0x10FFFF
block|}
decl_stmt|;
comment|/** Returns random string of length between 0-20 codepoints, all codepoints within the same unicode block. */
DECL|method|randomRealisticUnicodeString
specifier|public
specifier|static
name|String
name|randomRealisticUnicodeString
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
return|return
name|randomRealisticUnicodeString
argument_list|(
name|r
argument_list|,
literal|20
argument_list|)
return|;
block|}
comment|/** Returns random string of length up to maxLength codepoints , all codepoints within the same unicode block. */
DECL|method|randomRealisticUnicodeString
specifier|public
specifier|static
name|String
name|randomRealisticUnicodeString
parameter_list|(
name|Random
name|r
parameter_list|,
name|int
name|maxLength
parameter_list|)
block|{
return|return
name|randomRealisticUnicodeString
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|maxLength
argument_list|)
return|;
block|}
comment|/** Returns random string of length between min and max codepoints, all codepoints within the same unicode block. */
DECL|method|randomRealisticUnicodeString
specifier|public
specifier|static
name|String
name|randomRealisticUnicodeString
parameter_list|(
name|Random
name|r
parameter_list|,
name|int
name|minLength
parameter_list|,
name|int
name|maxLength
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|nextInt
argument_list|(
name|r
argument_list|,
name|minLength
argument_list|,
name|maxLength
argument_list|)
decl_stmt|;
specifier|final
name|int
name|block
init|=
name|r
operator|.
name|nextInt
argument_list|(
name|blockStarts
operator|.
name|length
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
name|sb
operator|.
name|appendCodePoint
argument_list|(
name|nextInt
argument_list|(
name|r
argument_list|,
name|blockStarts
index|[
name|block
index|]
argument_list|,
name|blockEnds
index|[
name|block
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Returns random string, with a given UTF-8 byte length*/
DECL|method|randomFixedByteLengthUnicodeString
specifier|public
specifier|static
name|String
name|randomFixedByteLengthUnicodeString
parameter_list|(
name|Random
name|r
parameter_list|,
name|int
name|length
parameter_list|)
block|{
specifier|final
name|char
index|[]
name|buffer
init|=
operator|new
name|char
index|[
name|length
operator|*
literal|3
index|]
decl_stmt|;
name|int
name|bytes
init|=
name|length
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|buffer
operator|.
name|length
operator|&&
name|bytes
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|int
name|t
decl_stmt|;
if|if
condition|(
name|bytes
operator|>=
literal|4
condition|)
block|{
name|t
operator|=
name|r
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|3
condition|)
block|{
name|t
operator|=
name|r
operator|.
name|nextInt
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|2
condition|)
block|{
name|t
operator|=
name|r
operator|.
name|nextInt
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|r
operator|.
name|nextInt
argument_list|(
literal|0x80
argument_list|)
expr_stmt|;
name|bytes
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|1
operator|==
name|t
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|r
argument_list|,
literal|0x80
argument_list|,
literal|0x7ff
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|2
operator|==
name|t
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|r
argument_list|,
literal|0x800
argument_list|,
literal|0xd7ff
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|3
operator|==
name|t
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|r
argument_list|,
literal|0xe000
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|4
operator|==
name|t
condition|)
block|{
comment|// Make a surrogate pair
comment|// High surrogate
name|buffer
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|r
argument_list|,
literal|0xd800
argument_list|,
literal|0xdbff
argument_list|)
expr_stmt|;
comment|// Low surrogate
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|r
argument_list|,
literal|0xdc00
argument_list|,
literal|0xdfff
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|4
expr_stmt|;
block|}
block|}
return|return
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
return|;
block|}
comment|/** Return a Codec that can read any of the    *  default codecs and formats, but always writes in the specified    *  format. */
DECL|method|alwaysPostingsFormat
specifier|public
specifier|static
name|Codec
name|alwaysPostingsFormat
parameter_list|(
specifier|final
name|PostingsFormat
name|format
parameter_list|)
block|{
comment|// TODO: we really need for postings impls etc to announce themselves
comment|// (and maybe their params, too) to infostream on flush and merge.
comment|// otherwise in a real debugging situation we won't know whats going on!
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"forcing postings format to:"
operator|+
name|format
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|AssertingCodec
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|PostingsFormat
name|getPostingsFormatForField
parameter_list|(
name|String
name|field
parameter_list|)
block|{
return|return
name|format
return|;
block|}
block|}
return|;
block|}
comment|/** Return a Codec that can read any of the    *  default codecs and formats, but always writes in the specified    *  format. */
DECL|method|alwaysDocValuesFormat
specifier|public
specifier|static
name|Codec
name|alwaysDocValuesFormat
parameter_list|(
specifier|final
name|DocValuesFormat
name|format
parameter_list|)
block|{
comment|// TODO: we really need for docvalues impls etc to announce themselves
comment|// (and maybe their params, too) to infostream on flush and merge.
comment|// otherwise in a real debugging situation we won't know whats going on!
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"forcing docvalues format to:"
operator|+
name|format
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|AssertingCodec
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|DocValuesFormat
name|getDocValuesFormatForField
parameter_list|(
name|String
name|field
parameter_list|)
block|{
return|return
name|format
return|;
block|}
block|}
return|;
block|}
comment|/**     * Returns the actual default codec (e.g. LuceneMNCodec) for this version of Lucene.    * This may be different than {@link Codec#getDefault()} because that is randomized.     */
DECL|method|getDefaultCodec
specifier|public
specifier|static
name|Codec
name|getDefaultCodec
parameter_list|()
block|{
return|return
operator|new
name|Lucene50Codec
argument_list|()
return|;
block|}
comment|/**     * Returns the actual default postings format (e.g. LuceneMNPostingsFormat for this version of Lucene.    */
DECL|method|getDefaultPostingsFormat
specifier|public
specifier|static
name|PostingsFormat
name|getDefaultPostingsFormat
parameter_list|()
block|{
return|return
operator|new
name|Lucene50PostingsFormat
argument_list|()
return|;
block|}
comment|/**     * Returns the actual default postings format (e.g. LuceneMNPostingsFormat for this version of Lucene.    * @lucene.internal this may disappear at any time    */
DECL|method|getDefaultPostingsFormat
specifier|public
specifier|static
name|PostingsFormat
name|getDefaultPostingsFormat
parameter_list|(
name|int
name|minItemsPerBlock
parameter_list|,
name|int
name|maxItemsPerBlock
parameter_list|)
block|{
return|return
operator|new
name|Lucene50PostingsFormat
argument_list|(
name|minItemsPerBlock
argument_list|,
name|maxItemsPerBlock
argument_list|)
return|;
block|}
comment|/** Returns a random postings format that supports term ordinals */
DECL|method|getPostingsFormatWithOrds
specifier|public
specifier|static
name|PostingsFormat
name|getPostingsFormatWithOrds
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
switch|switch
condition|(
name|r
operator|.
name|nextInt
argument_list|(
literal|2
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|new
name|LuceneFixedGap
argument_list|()
return|;
case|case
literal|1
case|:
return|return
operator|new
name|BlockTreeOrdsPostingsFormat
argument_list|()
return|;
comment|// TODO: these don't actually support ords!
comment|//case 2: return new FSTOrdPostingsFormat();
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
comment|/**     * Returns the actual default docvalues format (e.g. LuceneMNDocValuesFormat for this version of Lucene.    */
DECL|method|getDefaultDocValuesFormat
specifier|public
specifier|static
name|DocValuesFormat
name|getDefaultDocValuesFormat
parameter_list|()
block|{
return|return
operator|new
name|Lucene50DocValuesFormat
argument_list|()
return|;
block|}
comment|// TODO: generalize all 'test-checks-for-crazy-codecs' to
comment|// annotations (LUCENE-3489)
DECL|method|getPostingsFormat
specifier|public
specifier|static
name|String
name|getPostingsFormat
parameter_list|(
name|String
name|field
parameter_list|)
block|{
return|return
name|getPostingsFormat
argument_list|(
name|Codec
operator|.
name|getDefault
argument_list|()
argument_list|,
name|field
argument_list|)
return|;
block|}
DECL|method|getPostingsFormat
specifier|public
specifier|static
name|String
name|getPostingsFormat
parameter_list|(
name|Codec
name|codec
parameter_list|,
name|String
name|field
parameter_list|)
block|{
name|PostingsFormat
name|p
init|=
name|codec
operator|.
name|postingsFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|instanceof
name|PerFieldPostingsFormat
condition|)
block|{
return|return
operator|(
operator|(
name|PerFieldPostingsFormat
operator|)
name|p
operator|)
operator|.
name|getPostingsFormatForField
argument_list|(
name|field
argument_list|)
operator|.
name|getName
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|p
operator|.
name|getName
argument_list|()
return|;
block|}
block|}
DECL|method|getDocValuesFormat
specifier|public
specifier|static
name|String
name|getDocValuesFormat
parameter_list|(
name|String
name|field
parameter_list|)
block|{
return|return
name|getDocValuesFormat
argument_list|(
name|Codec
operator|.
name|getDefault
argument_list|()
argument_list|,
name|field
argument_list|)
return|;
block|}
DECL|method|getDocValuesFormat
specifier|public
specifier|static
name|String
name|getDocValuesFormat
parameter_list|(
name|Codec
name|codec
parameter_list|,
name|String
name|field
parameter_list|)
block|{
name|DocValuesFormat
name|f
init|=
name|codec
operator|.
name|docValuesFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|instanceof
name|PerFieldDocValuesFormat
condition|)
block|{
return|return
operator|(
operator|(
name|PerFieldDocValuesFormat
operator|)
name|f
operator|)
operator|.
name|getDocValuesFormatForField
argument_list|(
name|field
argument_list|)
operator|.
name|getName
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|f
operator|.
name|getName
argument_list|()
return|;
block|}
block|}
comment|// TODO: remove this, push this test to Lucene40/Lucene42 codec tests
DECL|method|fieldSupportsHugeBinaryDocValues
specifier|public
specifier|static
name|boolean
name|fieldSupportsHugeBinaryDocValues
parameter_list|(
name|String
name|field
parameter_list|)
block|{
name|String
name|dvFormat
init|=
name|getDocValuesFormat
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|dvFormat
operator|.
name|equals
argument_list|(
literal|"Lucene40"
argument_list|)
operator|||
name|dvFormat
operator|.
name|equals
argument_list|(
literal|"Lucene42"
argument_list|)
operator|||
name|dvFormat
operator|.
name|equals
argument_list|(
literal|"Memory"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|anyFilesExceptWriteLock
specifier|public
specifier|static
name|boolean
name|anyFilesExceptWriteLock
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
name|String
index|[]
name|files
init|=
name|dir
operator|.
name|listAll
argument_list|()
decl_stmt|;
if|if
condition|(
name|files
operator|.
name|length
operator|>
literal|1
operator|||
operator|(
name|files
operator|.
name|length
operator|==
literal|1
operator|&&
operator|!
name|files
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"write.lock"
argument_list|)
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|method|addIndexesSlowly
specifier|public
specifier|static
name|void
name|addIndexesSlowly
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|DirectoryReader
modifier|...
name|readers
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|CodecReader
argument_list|>
name|leaves
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|DirectoryReader
name|reader
range|:
name|readers
control|)
block|{
for|for
control|(
name|LeafReaderContext
name|context
range|:
name|reader
operator|.
name|leaves
argument_list|()
control|)
block|{
name|leaves
operator|.
name|add
argument_list|(
name|SlowCodecReaderWrapper
operator|.
name|wrap
argument_list|(
name|context
operator|.
name|reader
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|writer
operator|.
name|addIndexes
argument_list|(
name|leaves
operator|.
name|toArray
argument_list|(
operator|new
name|CodecReader
index|[
name|leaves
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** just tries to configure things to keep the open file    * count lowish */
DECL|method|reduceOpenFiles
specifier|public
specifier|static
name|void
name|reduceOpenFiles
parameter_list|(
name|IndexWriter
name|w
parameter_list|)
block|{
comment|// keep number of open files lowish
name|MergePolicy
name|mp
init|=
name|w
operator|.
name|getConfig
argument_list|()
operator|.
name|getMergePolicy
argument_list|()
decl_stmt|;
if|if
condition|(
name|mp
operator|instanceof
name|LogMergePolicy
condition|)
block|{
name|LogMergePolicy
name|lmp
init|=
operator|(
name|LogMergePolicy
operator|)
name|mp
decl_stmt|;
name|lmp
operator|.
name|setMergeFactor
argument_list|(
name|Math
operator|.
name|min
argument_list|(
literal|5
argument_list|,
name|lmp
operator|.
name|getMergeFactor
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|lmp
operator|.
name|setNoCFSRatio
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|instanceof
name|TieredMergePolicy
condition|)
block|{
name|TieredMergePolicy
name|tmp
init|=
operator|(
name|TieredMergePolicy
operator|)
name|mp
decl_stmt|;
name|tmp
operator|.
name|setMaxMergeAtOnce
argument_list|(
name|Math
operator|.
name|min
argument_list|(
literal|5
argument_list|,
name|tmp
operator|.
name|getMaxMergeAtOnce
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setSegmentsPerTier
argument_list|(
name|Math
operator|.
name|min
argument_list|(
literal|5
argument_list|,
name|tmp
operator|.
name|getSegmentsPerTier
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setNoCFSRatio
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
block|}
name|MergeScheduler
name|ms
init|=
name|w
operator|.
name|getConfig
argument_list|()
operator|.
name|getMergeScheduler
argument_list|()
decl_stmt|;
if|if
condition|(
name|ms
operator|instanceof
name|ConcurrentMergeScheduler
condition|)
block|{
comment|// wtf... shouldnt it be even lower since it's 1 by default?!?!
operator|(
operator|(
name|ConcurrentMergeScheduler
operator|)
name|ms
operator|)
operator|.
name|setMaxMergesAndThreads
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Checks some basic behaviour of an AttributeImpl    * @param reflectedValues contains a map with "AttributeClass#key" as values    */
DECL|method|assertAttributeReflection
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|assertAttributeReflection
parameter_list|(
specifier|final
name|AttributeImpl
name|att
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|reflectedValues
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|att
operator|.
name|reflectWith
argument_list|(
operator|new
name|AttributeReflector
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|reflect
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Attribute
argument_list|>
name|attClass
parameter_list|,
name|String
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|map
operator|.
name|put
argument_list|(
name|attClass
operator|.
name|getName
argument_list|()
operator|+
literal|'#'
operator|+
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Reflection does not produce same map"
argument_list|,
name|reflectedValues
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|assertEquals
specifier|public
specifier|static
name|void
name|assertEquals
parameter_list|(
name|TopDocs
name|expected
parameter_list|,
name|TopDocs
name|actual
parameter_list|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"wrong total hits"
argument_list|,
name|expected
operator|.
name|totalHits
argument_list|,
name|actual
operator|.
name|totalHits
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"wrong maxScore"
argument_list|,
name|expected
operator|.
name|getMaxScore
argument_list|()
argument_list|,
name|actual
operator|.
name|getMaxScore
argument_list|()
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"wrong hit count"
argument_list|,
name|expected
operator|.
name|scoreDocs
operator|.
name|length
argument_list|,
name|actual
operator|.
name|scoreDocs
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|hitIDX
init|=
literal|0
init|;
name|hitIDX
operator|<
name|expected
operator|.
name|scoreDocs
operator|.
name|length
condition|;
name|hitIDX
operator|++
control|)
block|{
specifier|final
name|ScoreDoc
name|expectedSD
init|=
name|expected
operator|.
name|scoreDocs
index|[
name|hitIDX
index|]
decl_stmt|;
specifier|final
name|ScoreDoc
name|actualSD
init|=
name|actual
operator|.
name|scoreDocs
index|[
name|hitIDX
index|]
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"wrong hit docID"
argument_list|,
name|expectedSD
operator|.
name|doc
argument_list|,
name|actualSD
operator|.
name|doc
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"wrong hit score"
argument_list|,
name|expectedSD
operator|.
name|score
argument_list|,
name|actualSD
operator|.
name|score
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedSD
operator|instanceof
name|FieldDoc
condition|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|actualSD
operator|instanceof
name|FieldDoc
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertArrayEquals
argument_list|(
literal|"wrong sort field values"
argument_list|,
operator|(
operator|(
name|FieldDoc
operator|)
name|expectedSD
operator|)
operator|.
name|fields
argument_list|,
operator|(
operator|(
name|FieldDoc
operator|)
name|actualSD
operator|)
operator|.
name|fields
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Assert
operator|.
name|assertFalse
argument_list|(
name|actualSD
operator|instanceof
name|FieldDoc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// NOTE: this is likely buggy, and cannot clone fields
comment|// with tokenStreamValues, etc.  Use at your own risk!!
comment|// TODO: is there a pre-existing way to do this!!!
DECL|method|cloneDocument
specifier|public
specifier|static
name|Document
name|cloneDocument
parameter_list|(
name|Document
name|doc1
parameter_list|)
block|{
specifier|final
name|Document
name|doc2
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
for|for
control|(
name|IndexableField
name|f
range|:
name|doc1
operator|.
name|getFields
argument_list|()
control|)
block|{
specifier|final
name|Field
name|field1
init|=
operator|(
name|Field
operator|)
name|f
decl_stmt|;
specifier|final
name|Field
name|field2
decl_stmt|;
specifier|final
name|DocValuesType
name|dvType
init|=
name|field1
operator|.
name|fieldType
argument_list|()
operator|.
name|docValuesType
argument_list|()
decl_stmt|;
specifier|final
name|NumericType
name|numType
init|=
name|field1
operator|.
name|fieldType
argument_list|()
operator|.
name|numericType
argument_list|()
decl_stmt|;
if|if
condition|(
name|dvType
operator|!=
name|DocValuesType
operator|.
name|NONE
condition|)
block|{
switch|switch
condition|(
name|dvType
condition|)
block|{
case|case
name|NUMERIC
case|:
name|field2
operator|=
operator|new
name|NumericDocValuesField
argument_list|(
name|field1
operator|.
name|name
argument_list|()
argument_list|,
name|field1
operator|.
name|numericValue
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINARY
case|:
name|field2
operator|=
operator|new
name|BinaryDocValuesField
argument_list|(
name|field1
operator|.
name|name
argument_list|()
argument_list|,
name|field1
operator|.
name|binaryValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|SORTED
case|:
name|field2
operator|=
operator|new
name|SortedDocValuesField
argument_list|(
name|field1
operator|.
name|name
argument_list|()
argument_list|,
name|field1
operator|.
name|binaryValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"unknown Type: "
operator|+
name|dvType
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|numType
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|numType
condition|)
block|{
case|case
name|INT
case|:
name|field2
operator|=
operator|new
name|IntField
argument_list|(
name|field1
operator|.
name|name
argument_list|()
argument_list|,
name|field1
operator|.
name|numericValue
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|field1
operator|.
name|fieldType
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|field2
operator|=
operator|new
name|FloatField
argument_list|(
name|field1
operator|.
name|name
argument_list|()
argument_list|,
name|field1
operator|.
name|numericValue
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|field1
operator|.
name|fieldType
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|field2
operator|=
operator|new
name|LongField
argument_list|(
name|field1
operator|.
name|name
argument_list|()
argument_list|,
name|field1
operator|.
name|numericValue
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|field1
operator|.
name|fieldType
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|field2
operator|=
operator|new
name|DoubleField
argument_list|(
name|field1
operator|.
name|name
argument_list|()
argument_list|,
name|field1
operator|.
name|numericValue
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|field1
operator|.
name|fieldType
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"unknown Type: "
operator|+
name|numType
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|field2
operator|=
operator|new
name|Field
argument_list|(
name|field1
operator|.
name|name
argument_list|()
argument_list|,
name|field1
operator|.
name|stringValue
argument_list|()
argument_list|,
name|field1
operator|.
name|fieldType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|doc2
operator|.
name|add
argument_list|(
name|field2
argument_list|)
expr_stmt|;
block|}
return|return
name|doc2
return|;
block|}
comment|// Returns a DocsEnum, but randomly sometimes uses a
comment|// DocsAndFreqsEnum, DocsAndPositionsEnum.  Returns null
comment|// if field/term doesn't exist:
DECL|method|docs
specifier|public
specifier|static
name|PostingsEnum
name|docs
parameter_list|(
name|Random
name|random
parameter_list|,
name|IndexReader
name|r
parameter_list|,
name|String
name|field
parameter_list|,
name|BytesRef
name|term
parameter_list|,
name|Bits
name|liveDocs
parameter_list|,
name|PostingsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Terms
name|terms
init|=
name|MultiFields
operator|.
name|getTerms
argument_list|(
name|r
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|TermsEnum
name|termsEnum
init|=
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|termsEnum
operator|.
name|seekExact
argument_list|(
name|term
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|docs
argument_list|(
name|random
argument_list|,
name|termsEnum
argument_list|,
name|liveDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
comment|// Returns a DocsEnum from a positioned TermsEnum, but
comment|// randomly sometimes uses a DocsAndFreqsEnum, DocsAndPositionsEnum.
DECL|method|docs
specifier|public
specifier|static
name|PostingsEnum
name|docs
parameter_list|(
name|Random
name|random
parameter_list|,
name|TermsEnum
name|termsEnum
parameter_list|,
name|Bits
name|liveDocs
parameter_list|,
name|PostingsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
specifier|final
name|int
name|posFlags
decl_stmt|;
switch|switch
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|4
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|posFlags
operator|=
name|PostingsEnum
operator|.
name|FLAG_POSITIONS
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|posFlags
operator|=
name|PostingsEnum
operator|.
name|FLAG_OFFSETS
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|posFlags
operator|=
name|PostingsEnum
operator|.
name|FLAG_PAYLOADS
expr_stmt|;
break|break;
default|default:
name|posFlags
operator|=
name|PostingsEnum
operator|.
name|FLAG_OFFSETS
operator||
name|PostingsEnum
operator|.
name|FLAG_PAYLOADS
expr_stmt|;
break|break;
block|}
name|PostingsEnum
name|docsAndPositions
init|=
name|termsEnum
operator|.
name|postings
argument_list|(
name|liveDocs
argument_list|,
literal|null
argument_list|,
name|posFlags
argument_list|)
decl_stmt|;
if|if
condition|(
name|docsAndPositions
operator|!=
literal|null
condition|)
block|{
return|return
name|docsAndPositions
return|;
block|}
block|}
name|flags
operator||=
name|PostingsEnum
operator|.
name|FLAG_FREQS
expr_stmt|;
block|}
return|return
name|termsEnum
operator|.
name|postings
argument_list|(
name|liveDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
DECL|method|stringToCharSequence
specifier|public
specifier|static
name|CharSequence
name|stringToCharSequence
parameter_list|(
name|String
name|string
parameter_list|,
name|Random
name|random
parameter_list|)
block|{
return|return
name|bytesToCharSequence
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|string
argument_list|)
argument_list|,
name|random
argument_list|)
return|;
block|}
DECL|method|bytesToCharSequence
specifier|public
specifier|static
name|CharSequence
name|bytesToCharSequence
parameter_list|(
name|BytesRef
name|ref
parameter_list|,
name|Random
name|random
parameter_list|)
block|{
switch|switch
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
specifier|final
name|char
index|[]
name|chars
init|=
operator|new
name|char
index|[
name|ref
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|int
name|len
init|=
name|UnicodeUtil
operator|.
name|UTF8toUTF16
argument_list|(
name|ref
operator|.
name|bytes
argument_list|,
name|ref
operator|.
name|offset
argument_list|,
name|ref
operator|.
name|length
argument_list|,
name|chars
argument_list|)
decl_stmt|;
return|return
operator|new
name|CharsRef
argument_list|(
name|chars
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
return|;
case|case
literal|3
case|:
return|return
name|CharBuffer
operator|.
name|wrap
argument_list|(
name|ref
operator|.
name|utf8ToString
argument_list|()
argument_list|)
return|;
default|default:
return|return
name|ref
operator|.
name|utf8ToString
argument_list|()
return|;
block|}
block|}
comment|/**    * Shutdown {@link ExecutorService} and wait for its.    */
DECL|method|shutdownExecutorService
specifier|public
specifier|static
name|void
name|shutdownExecutorService
parameter_list|(
name|ExecutorService
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|ex
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|ex
operator|.
name|awaitTermination
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Just report it on the syserr.
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Could not properly close executor service."
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns a valid (compiling) Pattern instance with random stuff inside. Be careful    * when applying random patterns to longer strings as certain types of patterns    * may explode into exponential times in backtracking implementations (such as Java's).    */
DECL|method|randomPattern
specifier|public
specifier|static
name|Pattern
name|randomPattern
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
specifier|final
name|String
name|nonBmpString
init|=
literal|"AB\uD840\uDC00C"
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|Pattern
name|p
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|TestUtil
operator|.
name|randomRegexpishString
argument_list|(
name|random
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|replacement
init|=
literal|null
decl_stmt|;
comment|// ignore bugs in Sun's regex impl
try|try
block|{
name|replacement
operator|=
name|p
operator|.
name|matcher
argument_list|(
name|nonBmpString
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StringIndexOutOfBoundsException
name|jdkBug
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"WARNING: your jdk is buggy!"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Pattern.compile(\""
operator|+
name|p
operator|.
name|pattern
argument_list|()
operator|+
literal|"\").matcher(\"AB\\uD840\\uDC00C\").replaceAll(\"_\"); should not throw IndexOutOfBounds!"
argument_list|)
expr_stmt|;
block|}
comment|// Make sure the result of applying the pattern to a string with extended
comment|// unicode characters is a valid utf16 string. See LUCENE-4078 for discussion.
if|if
condition|(
name|replacement
operator|!=
literal|null
operator|&&
name|UnicodeUtil
operator|.
name|validUTF16String
argument_list|(
name|replacement
argument_list|)
condition|)
block|{
return|return
name|p
return|;
block|}
block|}
catch|catch
parameter_list|(
name|PatternSyntaxException
name|ignored
parameter_list|)
block|{
comment|// Loop trying until we hit something that compiles.
block|}
block|}
block|}
DECL|method|randomFilterStrategy
specifier|public
specifier|static
specifier|final
name|FilterStrategy
name|randomFilterStrategy
parameter_list|(
specifier|final
name|Random
name|random
parameter_list|)
block|{
switch|switch
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|6
argument_list|)
condition|)
block|{
case|case
literal|5
case|:
case|case
literal|4
case|:
return|return
operator|new
name|FilteredQuery
operator|.
name|RandomAccessFilterStrategy
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|useRandomAccess
parameter_list|(
name|Bits
name|bits
parameter_list|,
name|long
name|filterCost
parameter_list|)
block|{
return|return
name|LuceneTestCase
operator|.
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
return|;
block|}
block|}
return|;
case|case
literal|3
case|:
return|return
name|FilteredQuery
operator|.
name|RANDOM_ACCESS_FILTER_STRATEGY
return|;
case|case
literal|2
case|:
return|return
name|FilteredQuery
operator|.
name|LEAP_FROG_FILTER_FIRST_STRATEGY
return|;
case|case
literal|1
case|:
return|return
name|FilteredQuery
operator|.
name|LEAP_FROG_QUERY_FIRST_STRATEGY
return|;
case|case
literal|0
case|:
return|return
name|FilteredQuery
operator|.
name|QUERY_FIRST_FILTER_STRATEGY
return|;
default|default:
return|return
name|FilteredQuery
operator|.
name|RANDOM_ACCESS_FILTER_STRATEGY
return|;
block|}
block|}
comment|/**    * Returns a random string in the specified length range consisting     * entirely of whitespace characters     * @see #WHITESPACE_CHARACTERS    */
DECL|method|randomWhitespace
specifier|public
specifier|static
name|String
name|randomWhitespace
parameter_list|(
name|Random
name|r
parameter_list|,
name|int
name|minLength
parameter_list|,
name|int
name|maxLength
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|nextInt
argument_list|(
name|r
argument_list|,
name|minLength
argument_list|,
name|maxLength
argument_list|)
decl_stmt|;
name|StringBuilder
name|out
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|int
name|offset
init|=
name|nextInt
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|WHITESPACE_CHARACTERS
operator|.
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
name|char
name|c
init|=
name|WHITESPACE_CHARACTERS
index|[
name|offset
index|]
decl_stmt|;
comment|// sanity check
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Not really whitespace? (@"
operator|+
name|offset
operator|+
literal|"): "
operator|+
name|c
argument_list|,
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|out
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|randomAnalysisString
specifier|public
specifier|static
name|String
name|randomAnalysisString
parameter_list|(
name|Random
name|random
parameter_list|,
name|int
name|maxLength
parameter_list|,
name|boolean
name|simple
parameter_list|)
block|{
assert|assert
name|maxLength
operator|>=
literal|0
assert|;
comment|// sometimes just a purely random string
if|if
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|31
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|randomSubString
argument_list|(
name|random
argument_list|,
name|random
operator|.
name|nextInt
argument_list|(
name|maxLength
argument_list|)
argument_list|,
name|simple
argument_list|)
return|;
block|}
comment|// otherwise, try to make it more realistic with 'words' since most tests use MockTokenizer
comment|// first decide how big the string will really be: 0..n
name|maxLength
operator|=
name|random
operator|.
name|nextInt
argument_list|(
name|maxLength
argument_list|)
expr_stmt|;
name|int
name|avgWordLength
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|3
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|<
name|maxLength
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|int
name|wordLength
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|wordLength
operator|<
literal|0
condition|)
block|{
name|wordLength
operator|=
call|(
name|int
call|)
argument_list|(
name|random
operator|.
name|nextGaussian
argument_list|()
operator|*
literal|3
operator|+
name|avgWordLength
argument_list|)
expr_stmt|;
block|}
name|wordLength
operator|=
name|Math
operator|.
name|min
argument_list|(
name|wordLength
argument_list|,
name|maxLength
operator|-
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|randomSubString
argument_list|(
name|random
argument_list|,
name|wordLength
argument_list|,
name|simple
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|randomSubString
specifier|public
specifier|static
name|String
name|randomSubString
parameter_list|(
name|Random
name|random
parameter_list|,
name|int
name|wordLength
parameter_list|,
name|boolean
name|simple
parameter_list|)
block|{
if|if
condition|(
name|wordLength
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
name|int
name|evilness
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|<
name|wordLength
condition|)
block|{
empty_stmt|;
if|if
condition|(
name|simple
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|?
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|,
name|wordLength
argument_list|)
else|:
name|TestUtil
operator|.
name|randomHtmlishString
argument_list|(
name|random
argument_list|,
name|wordLength
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|evilness
operator|<
literal|10
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|,
name|wordLength
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|evilness
operator|<
literal|15
condition|)
block|{
assert|assert
name|sb
operator|.
name|length
argument_list|()
operator|==
literal|0
assert|;
comment|// we should always get wordLength back!
name|sb
operator|.
name|append
argument_list|(
name|TestUtil
operator|.
name|randomRealisticUnicodeString
argument_list|(
name|random
argument_list|,
name|wordLength
argument_list|,
name|wordLength
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|evilness
operator|==
literal|16
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|TestUtil
operator|.
name|randomHtmlishString
argument_list|(
name|random
argument_list|,
name|wordLength
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|evilness
operator|==
literal|17
condition|)
block|{
comment|// gives a lot of punctuation
name|sb
operator|.
name|append
argument_list|(
name|TestUtil
operator|.
name|randomRegexpishString
argument_list|(
name|random
argument_list|,
name|wordLength
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|TestUtil
operator|.
name|randomUnicodeString
argument_list|(
name|random
argument_list|,
name|wordLength
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
name|wordLength
condition|)
block|{
name|sb
operator|.
name|setLength
argument_list|(
name|wordLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|Character
operator|.
name|isHighSurrogate
argument_list|(
name|sb
operator|.
name|charAt
argument_list|(
name|wordLength
operator|-
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|sb
operator|.
name|setLength
argument_list|(
name|wordLength
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|17
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// mix up case
name|String
name|mixedUp
init|=
name|TestUtil
operator|.
name|randomlyRecaseCodePoints
argument_list|(
name|random
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|mixedUp
operator|.
name|length
argument_list|()
operator|==
name|sb
operator|.
name|length
argument_list|()
assert|;
return|return
name|mixedUp
return|;
block|}
else|else
block|{
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** Returns true if this is an FSDirectory backed by {@link WindowsFS}. */
DECL|method|isWindowsFS
specifier|public
specifier|static
name|boolean
name|isWindowsFS
parameter_list|(
name|Directory
name|dir
parameter_list|)
block|{
comment|// First unwrap directory to see if there is an FSDir:
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|dir
operator|instanceof
name|FSDirectory
condition|)
block|{
return|return
name|isWindowsFS
argument_list|(
operator|(
operator|(
name|FSDirectory
operator|)
name|dir
operator|)
operator|.
name|getDirectory
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|dir
operator|instanceof
name|FilterDirectory
condition|)
block|{
name|dir
operator|=
operator|(
operator|(
name|FilterDirectory
operator|)
name|dir
operator|)
operator|.
name|getDelegate
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
comment|/** Returns true if this Path is backed by {@link WindowsFS}. */
DECL|method|isWindowsFS
specifier|public
specifier|static
name|boolean
name|isWindowsFS
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|FileSystem
name|fs
init|=
name|path
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|fs
operator|instanceof
name|FilterFileSystem
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|FilterFileSystem
operator|)
name|fs
operator|)
operator|.
name|getParent
argument_list|()
operator|instanceof
name|WindowsFS
condition|)
block|{
return|return
literal|true
return|;
block|}
name|fs
operator|=
operator|(
operator|(
name|FilterFileSystem
operator|)
name|fs
operator|)
operator|.
name|getDelegate
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
comment|/** List of characters that match {@link Character#isWhitespace} */
DECL|field|WHITESPACE_CHARACTERS
specifier|public
specifier|static
specifier|final
name|char
index|[]
name|WHITESPACE_CHARACTERS
init|=
operator|new
name|char
index|[]
block|{
comment|// :TODO: is this list exhaustive?
literal|'\u0009'
block|,
literal|'\n'
block|,
literal|'\u000B'
block|,
literal|'\u000C'
block|,
literal|'\r'
block|,
literal|'\u001C'
block|,
literal|'\u001D'
block|,
literal|'\u001E'
block|,
literal|'\u001F'
block|,
literal|'\u0020'
block|,
comment|// '\u0085', faild sanity check?
literal|'\u1680'
block|,
literal|'\u180E'
block|,
literal|'\u2000'
block|,
literal|'\u2001'
block|,
literal|'\u2002'
block|,
literal|'\u2003'
block|,
literal|'\u2004'
block|,
literal|'\u2005'
block|,
literal|'\u2006'
block|,
literal|'\u2008'
block|,
literal|'\u2009'
block|,
literal|'\u200A'
block|,
literal|'\u2028'
block|,
literal|'\u2029'
block|,
literal|'\u205F'
block|,
literal|'\u3000'
block|,   }
decl_stmt|;
block|}
end_class
end_unit
