begin_unit
begin_package
DECL|package|org.apache.lucene.util.fst
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *<p/>  * http://www.apache.org/licenses/LICENSE-2.0  *<p/>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRefBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|UnicodeUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|PackedInts
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNull
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import
begin_comment
comment|/** Helper class to test FSTs. */
end_comment
begin_class
DECL|class|FSTTester
specifier|public
class|class
name|FSTTester
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|random
specifier|final
name|Random
name|random
decl_stmt|;
DECL|field|pairs
specifier|final
name|List
argument_list|<
name|InputOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|pairs
decl_stmt|;
DECL|field|inputMode
specifier|final
name|int
name|inputMode
decl_stmt|;
DECL|field|outputs
specifier|final
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
decl_stmt|;
DECL|field|dir
specifier|final
name|Directory
name|dir
decl_stmt|;
DECL|field|doReverseLookup
specifier|final
name|boolean
name|doReverseLookup
decl_stmt|;
DECL|method|FSTTester
specifier|public
name|FSTTester
parameter_list|(
name|Random
name|random
parameter_list|,
name|Directory
name|dir
parameter_list|,
name|int
name|inputMode
parameter_list|,
name|List
argument_list|<
name|InputOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|pairs
parameter_list|,
name|Outputs
argument_list|<
name|T
argument_list|>
name|outputs
parameter_list|,
name|boolean
name|doReverseLookup
parameter_list|)
block|{
name|this
operator|.
name|random
operator|=
name|random
expr_stmt|;
name|this
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
name|this
operator|.
name|inputMode
operator|=
name|inputMode
expr_stmt|;
name|this
operator|.
name|pairs
operator|=
name|pairs
expr_stmt|;
name|this
operator|.
name|outputs
operator|=
name|outputs
expr_stmt|;
name|this
operator|.
name|doReverseLookup
operator|=
name|doReverseLookup
expr_stmt|;
block|}
DECL|method|inputToString
specifier|static
name|String
name|inputToString
parameter_list|(
name|int
name|inputMode
parameter_list|,
name|IntsRef
name|term
parameter_list|)
block|{
return|return
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|inputToString
specifier|static
name|String
name|inputToString
parameter_list|(
name|int
name|inputMode
parameter_list|,
name|IntsRef
name|term
parameter_list|,
name|boolean
name|isValidUnicode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isValidUnicode
condition|)
block|{
return|return
name|term
operator|.
name|toString
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|inputMode
operator|==
literal|0
condition|)
block|{
comment|// utf8
return|return
name|toBytesRef
argument_list|(
name|term
argument_list|)
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" "
operator|+
name|term
return|;
block|}
else|else
block|{
comment|// utf32
return|return
name|UnicodeUtil
operator|.
name|newString
argument_list|(
name|term
operator|.
name|ints
argument_list|,
name|term
operator|.
name|offset
argument_list|,
name|term
operator|.
name|length
argument_list|)
operator|+
literal|" "
operator|+
name|term
return|;
block|}
block|}
DECL|method|toBytesRef
specifier|private
specifier|static
name|BytesRef
name|toBytesRef
parameter_list|(
name|IntsRef
name|ir
parameter_list|)
block|{
name|BytesRef
name|br
init|=
operator|new
name|BytesRef
argument_list|(
name|ir
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ir
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|x
init|=
name|ir
operator|.
name|ints
index|[
name|ir
operator|.
name|offset
operator|+
name|i
index|]
decl_stmt|;
assert|assert
name|x
operator|>=
literal|0
operator|&&
name|x
operator|<=
literal|255
assert|;
name|br
operator|.
name|bytes
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|x
expr_stmt|;
block|}
name|br
operator|.
name|length
operator|=
name|ir
operator|.
name|length
expr_stmt|;
return|return
name|br
return|;
block|}
DECL|method|getRandomString
specifier|static
name|String
name|getRandomString
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
specifier|final
name|String
name|term
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|term
operator|=
name|TestUtil
operator|.
name|randomRealisticUnicodeString
argument_list|(
name|random
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we want to mix in limited-alphabet symbols so
comment|// we get more sharing of the nodes given how few
comment|// terms we are testing...
name|term
operator|=
name|simpleRandomString
argument_list|(
name|random
argument_list|)
expr_stmt|;
block|}
return|return
name|term
return|;
block|}
DECL|method|simpleRandomString
specifier|static
name|String
name|simpleRandomString
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|r
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
literal|0
condition|)
block|{
comment|// allow 0 length
return|return
literal|""
return|;
block|}
specifier|final
name|char
index|[]
name|buffer
init|=
operator|new
name|char
index|[
name|end
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|97
argument_list|,
literal|102
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|end
argument_list|)
return|;
block|}
DECL|method|toIntsRef
specifier|static
name|IntsRef
name|toIntsRef
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|inputMode
parameter_list|)
block|{
return|return
name|toIntsRef
argument_list|(
name|s
argument_list|,
name|inputMode
argument_list|,
operator|new
name|IntsRefBuilder
argument_list|()
argument_list|)
return|;
block|}
DECL|method|toIntsRef
specifier|static
name|IntsRef
name|toIntsRef
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|inputMode
parameter_list|,
name|IntsRefBuilder
name|ir
parameter_list|)
block|{
if|if
condition|(
name|inputMode
operator|==
literal|0
condition|)
block|{
comment|// utf8
return|return
name|toIntsRef
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|s
argument_list|)
argument_list|,
name|ir
argument_list|)
return|;
block|}
else|else
block|{
comment|// utf32
return|return
name|toIntsRefUTF32
argument_list|(
name|s
argument_list|,
name|ir
argument_list|)
return|;
block|}
block|}
DECL|method|toIntsRefUTF32
specifier|static
name|IntsRef
name|toIntsRefUTF32
parameter_list|(
name|String
name|s
parameter_list|,
name|IntsRefBuilder
name|ir
parameter_list|)
block|{
specifier|final
name|int
name|charLength
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|charIdx
init|=
literal|0
decl_stmt|;
name|int
name|intIdx
init|=
literal|0
decl_stmt|;
name|ir
operator|.
name|clear
argument_list|()
expr_stmt|;
while|while
condition|(
name|charIdx
operator|<
name|charLength
condition|)
block|{
name|ir
operator|.
name|grow
argument_list|(
name|intIdx
operator|+
literal|1
argument_list|)
expr_stmt|;
specifier|final
name|int
name|utf32
init|=
name|s
operator|.
name|codePointAt
argument_list|(
name|charIdx
argument_list|)
decl_stmt|;
name|ir
operator|.
name|append
argument_list|(
name|utf32
argument_list|)
expr_stmt|;
name|charIdx
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|utf32
argument_list|)
expr_stmt|;
name|intIdx
operator|++
expr_stmt|;
block|}
return|return
name|ir
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|toIntsRef
specifier|static
name|IntsRef
name|toIntsRef
parameter_list|(
name|BytesRef
name|br
parameter_list|,
name|IntsRefBuilder
name|ir
parameter_list|)
block|{
name|ir
operator|.
name|grow
argument_list|(
name|br
operator|.
name|length
argument_list|)
expr_stmt|;
name|ir
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|br
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ir
operator|.
name|append
argument_list|(
name|br
operator|.
name|bytes
index|[
name|br
operator|.
name|offset
operator|+
name|i
index|]
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
return|return
name|ir
operator|.
name|get
argument_list|()
return|;
block|}
comment|/** Holds one input/output pair. */
DECL|class|InputOutput
specifier|public
specifier|static
class|class
name|InputOutput
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Comparable
argument_list|<
name|InputOutput
argument_list|<
name|T
argument_list|>
argument_list|>
block|{
DECL|field|input
specifier|public
specifier|final
name|IntsRef
name|input
decl_stmt|;
DECL|field|output
specifier|public
specifier|final
name|T
name|output
decl_stmt|;
DECL|method|InputOutput
specifier|public
name|InputOutput
parameter_list|(
name|IntsRef
name|input
parameter_list|,
name|T
name|output
parameter_list|)
block|{
name|this
operator|.
name|input
operator|=
name|input
expr_stmt|;
name|this
operator|.
name|output
operator|=
name|output
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|instanceof
name|InputOutput
condition|)
block|{
return|return
name|input
operator|.
name|compareTo
argument_list|(
operator|(
name|other
operator|)
operator|.
name|input
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
block|}
block|}
DECL|method|doTest
specifier|public
name|void
name|doTest
parameter_list|(
name|boolean
name|testPruning
parameter_list|)
throws|throws
name|IOException
block|{
comment|// no pruning
name|doTest
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|testPruning
condition|)
block|{
comment|// simple pruning
name|doTest
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|1
operator|+
name|pairs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// leafy pruning
name|doTest
argument_list|(
literal|0
argument_list|,
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|1
operator|+
name|pairs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|// runs the term, returning the output, or null if term
comment|// isn't accepted.  if prefixLength is non-null it must be
comment|// length 1 int array; prefixLength[0] is set to the length
comment|// of the term prefix that matches
DECL|method|run
specifier|private
name|T
name|run
parameter_list|(
name|FST
argument_list|<
name|T
argument_list|>
name|fst
parameter_list|,
name|IntsRef
name|term
parameter_list|,
name|int
index|[]
name|prefixLength
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|prefixLength
operator|==
literal|null
operator|||
name|prefixLength
operator|.
name|length
operator|==
literal|1
assert|;
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
name|fst
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|T
name|NO_OUTPUT
init|=
name|fst
operator|.
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
name|T
name|output
init|=
name|NO_OUTPUT
decl_stmt|;
specifier|final
name|FST
operator|.
name|BytesReader
name|fstReader
init|=
name|fst
operator|.
name|getBytesReader
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|term
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|label
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|term
operator|.
name|length
condition|)
block|{
name|label
operator|=
name|FST
operator|.
name|END_LABEL
expr_stmt|;
block|}
else|else
block|{
name|label
operator|=
name|term
operator|.
name|ints
index|[
name|term
operator|.
name|offset
operator|+
name|i
index|]
expr_stmt|;
block|}
comment|// System.out.println("   loop i=" + i + " label=" + label + " output=" + fst.outputs.outputToString(output) + " curArc: target=" + arc.target + " isFinal?=" + arc.isFinal());
if|if
condition|(
name|fst
operator|.
name|findTargetArc
argument_list|(
name|label
argument_list|,
name|arc
argument_list|,
name|arc
argument_list|,
name|fstReader
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// System.out.println("    not found");
if|if
condition|(
name|prefixLength
operator|!=
literal|null
condition|)
block|{
name|prefixLength
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
return|return
name|output
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
name|output
operator|=
name|fst
operator|.
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prefixLength
operator|!=
literal|null
condition|)
block|{
name|prefixLength
index|[
literal|0
index|]
operator|=
name|term
operator|.
name|length
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
DECL|method|randomAcceptedWord
specifier|private
name|T
name|randomAcceptedWord
parameter_list|(
name|FST
argument_list|<
name|T
argument_list|>
name|fst
parameter_list|,
name|IntsRefBuilder
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
name|arc
init|=
name|fst
operator|.
name|getFirstArc
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|>
name|arcs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|in
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|final
name|T
name|NO_OUTPUT
init|=
name|fst
operator|.
name|outputs
operator|.
name|getNoOutput
argument_list|()
decl_stmt|;
name|T
name|output
init|=
name|NO_OUTPUT
decl_stmt|;
specifier|final
name|FST
operator|.
name|BytesReader
name|fstReader
init|=
name|fst
operator|.
name|getBytesReader
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// read all arcs:
name|fst
operator|.
name|readFirstTargetArc
argument_list|(
name|arc
argument_list|,
name|arc
argument_list|,
name|fstReader
argument_list|)
expr_stmt|;
name|arcs
operator|.
name|add
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|arc
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|arc
operator|.
name|isLast
argument_list|()
condition|)
block|{
name|fst
operator|.
name|readNextArc
argument_list|(
name|arc
argument_list|,
name|fstReader
argument_list|)
expr_stmt|;
name|arcs
operator|.
name|add
argument_list|(
operator|new
name|FST
operator|.
name|Arc
argument_list|<
name|T
argument_list|>
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|arc
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// pick one
name|arc
operator|=
name|arcs
operator|.
name|get
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
name|arcs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|arcs
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// accumulate output
name|output
operator|=
name|fst
operator|.
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
comment|// append label
if|if
condition|(
name|arc
operator|.
name|label
operator|==
name|FST
operator|.
name|END_LABEL
condition|)
block|{
break|break;
block|}
name|in
operator|.
name|append
argument_list|(
name|arc
operator|.
name|label
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
DECL|method|doTest
name|FST
argument_list|<
name|T
argument_list|>
name|doTest
parameter_list|(
name|int
name|prune1
parameter_list|,
name|int
name|prune2
parameter_list|,
name|boolean
name|allowRandomSuffixSharing
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nTEST: prune1="
operator|+
name|prune1
operator|+
literal|" prune2="
operator|+
name|prune2
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|willRewrite
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|T
argument_list|>
name|builder
init|=
operator|new
name|Builder
argument_list|<>
argument_list|(
name|inputMode
operator|==
literal|0
condition|?
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
else|:
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE4
argument_list|,
name|prune1
argument_list|,
name|prune2
argument_list|,
name|prune1
operator|==
literal|0
operator|&&
name|prune2
operator|==
literal|0
argument_list|,
name|allowRandomSuffixSharing
condition|?
name|random
operator|.
name|nextBoolean
argument_list|()
else|:
literal|true
argument_list|,
name|allowRandomSuffixSharing
condition|?
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|)
else|:
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|outputs
argument_list|,
name|willRewrite
argument_list|,
name|PackedInts
operator|.
name|DEFAULT
argument_list|,
literal|true
argument_list|,
literal|15
argument_list|)
decl_stmt|;
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
if|if
condition|(
name|willRewrite
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: packed FST"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: non-packed FST"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
if|if
condition|(
name|pair
operator|.
name|output
operator|instanceof
name|List
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|Long
argument_list|>
name|longValues
init|=
operator|(
name|List
argument_list|<
name|Long
argument_list|>
operator|)
name|pair
operator|.
name|output
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|Builder
argument_list|<
name|Object
argument_list|>
name|builderObject
init|=
operator|(
name|Builder
argument_list|<
name|Object
argument_list|>
operator|)
name|builder
decl_stmt|;
for|for
control|(
name|Long
name|value
range|:
name|longValues
control|)
block|{
name|builderObject
operator|.
name|add
argument_list|(
name|pair
operator|.
name|input
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|builder
operator|.
name|add
argument_list|(
name|pair
operator|.
name|input
argument_list|,
name|pair
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
name|FST
argument_list|<
name|T
argument_list|>
name|fst
init|=
name|builder
operator|.
name|finish
argument_list|()
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
operator|&&
name|fst
operator|!=
literal|null
operator|&&
operator|!
name|willRewrite
condition|)
block|{
name|IOContext
name|context
init|=
name|LuceneTestCase
operator|.
name|newIOContext
argument_list|(
name|random
argument_list|)
decl_stmt|;
name|IndexOutput
name|out
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"fst.bin"
argument_list|,
name|context
argument_list|)
decl_stmt|;
name|fst
operator|.
name|save
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|in
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"fst.bin"
argument_list|,
name|context
argument_list|)
decl_stmt|;
try|try
block|{
name|fst
operator|=
operator|new
name|FST
argument_list|<>
argument_list|(
name|in
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|deleteFile
argument_list|(
literal|"fst.bin"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
operator|&&
name|pairs
operator|.
name|size
argument_list|()
operator|<=
literal|20
operator|&&
name|fst
operator|!=
literal|null
condition|)
block|{
name|Writer
name|w
init|=
operator|new
name|OutputStreamWriter
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
literal|"out.dot"
argument_list|)
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
decl_stmt|;
name|Util
operator|.
name|toDot
argument_list|(
name|fst
argument_list|,
name|w
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"SAVED out.dot"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
if|if
condition|(
name|fst
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  fst has 0 nodes (fully pruned)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  fst has "
operator|+
name|fst
operator|.
name|getNodeCount
argument_list|()
operator|+
literal|" nodes and "
operator|+
name|fst
operator|.
name|getArcCount
argument_list|()
operator|+
literal|" arcs"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prune1
operator|==
literal|0
operator|&&
name|prune2
operator|==
literal|0
condition|)
block|{
name|verifyUnPruned
argument_list|(
name|inputMode
argument_list|,
name|fst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verifyPruned
argument_list|(
name|inputMode
argument_list|,
name|fst
argument_list|,
name|prune1
argument_list|,
name|prune2
argument_list|)
expr_stmt|;
block|}
return|return
name|fst
return|;
block|}
DECL|method|outputsEqual
specifier|protected
name|boolean
name|outputsEqual
parameter_list|(
name|T
name|a
parameter_list|,
name|T
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|equals
argument_list|(
name|b
argument_list|)
return|;
block|}
comment|// FST is complete
DECL|method|verifyUnPruned
specifier|private
name|void
name|verifyUnPruned
parameter_list|(
name|int
name|inputMode
parameter_list|,
name|FST
argument_list|<
name|T
argument_list|>
name|fst
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FST
argument_list|<
name|Long
argument_list|>
name|fstLong
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|validOutputs
decl_stmt|;
name|long
name|minLong
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
name|long
name|maxLong
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
if|if
condition|(
name|doReverseLookup
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|FST
argument_list|<
name|Long
argument_list|>
name|fstLong0
init|=
operator|(
name|FST
argument_list|<
name|Long
argument_list|>
operator|)
name|fst
decl_stmt|;
name|fstLong
operator|=
name|fstLong0
expr_stmt|;
name|validOutputs
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|Long
name|output
init|=
operator|(
name|Long
operator|)
name|pair
operator|.
name|output
decl_stmt|;
name|maxLong
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxLong
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|minLong
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minLong
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|validOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fstLong
operator|=
literal|null
expr_stmt|;
name|validOutputs
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|pairs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|assertNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now verify "
operator|+
name|pairs
operator|.
name|size
argument_list|()
operator|+
literal|" terms"
argument_list|)
expr_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|assertNotNull
argument_list|(
name|pair
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|pair
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|pair
operator|.
name|output
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pair
operator|.
name|input
argument_list|)
operator|+
literal|": "
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|pair
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assertNotNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
comment|// visit valid pairs in order -- make sure all words
comment|// are accepted, and FSTEnum's next() steps through
comment|// them correctly
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: check valid terms/next()"
argument_list|)
expr_stmt|;
block|}
block|{
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
name|fstEnum
init|=
operator|new
name|IntsRefFSTEnum
argument_list|<>
argument_list|(
name|fst
argument_list|)
decl_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|IntsRef
name|term
init|=
name|pair
operator|.
name|input
decl_stmt|;
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: check term="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
operator|+
literal|" output="
operator|+
name|fst
operator|.
name|outputs
operator|.
name|outputToString
argument_list|(
name|pair
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|T
name|output
init|=
name|run
argument_list|(
name|fst
argument_list|,
name|term
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"term "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
operator|+
literal|" is not accepted"
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|outputsEqual
argument_list|(
name|pair
operator|.
name|output
argument_list|,
name|output
argument_list|)
argument_list|)
expr_stmt|;
comment|// verify enum's next
name|IntsRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|T
argument_list|>
name|t
init|=
name|fstEnum
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"expected input="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
operator|+
literal|" but fstEnum returned "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|t
operator|.
name|input
argument_list|)
argument_list|,
name|term
argument_list|,
name|t
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|outputsEqual
argument_list|(
name|pair
operator|.
name|output
argument_list|,
name|t
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertNull
argument_list|(
name|fstEnum
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Map
argument_list|<
name|IntsRef
argument_list|,
name|T
argument_list|>
name|termsMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|termsMap
operator|.
name|put
argument_list|(
name|pair
operator|.
name|input
argument_list|,
name|pair
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doReverseLookup
operator|&&
name|maxLong
operator|>
name|minLong
condition|)
block|{
comment|// Do random lookups so we test null (output doesn't
comment|// exist) case:
name|assertNull
argument_list|(
name|Util
operator|.
name|getByOutput
argument_list|(
name|fstLong
argument_list|,
name|minLong
operator|-
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|Util
operator|.
name|getByOutput
argument_list|(
name|fstLong
argument_list|,
name|maxLong
operator|+
literal|7
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|int
name|num
init|=
name|LuceneTestCase
operator|.
name|atLeast
argument_list|(
name|random
argument_list|,
literal|100
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|num
condition|;
name|iter
operator|++
control|)
block|{
name|Long
name|v
init|=
name|TestUtil
operator|.
name|nextLong
argument_list|(
name|random
argument_list|,
name|minLong
argument_list|,
name|maxLong
argument_list|)
decl_stmt|;
name|IntsRef
name|input
init|=
name|Util
operator|.
name|getByOutput
argument_list|(
name|fstLong
argument_list|,
name|v
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|validOutputs
operator|.
name|contains
argument_list|(
name|v
argument_list|)
operator|||
name|input
operator|==
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|// find random matching word and make sure it's valid
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: verify random accepted terms"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|IntsRefBuilder
name|scratch
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
name|int
name|num
init|=
name|LuceneTestCase
operator|.
name|atLeast
argument_list|(
name|random
argument_list|,
literal|500
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|num
condition|;
name|iter
operator|++
control|)
block|{
name|T
name|output
init|=
name|randomAcceptedWord
argument_list|(
name|fst
argument_list|,
name|scratch
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"accepted word "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|scratch
operator|.
name|get
argument_list|()
argument_list|)
operator|+
literal|" is not valid"
argument_list|,
name|termsMap
operator|.
name|containsKey
argument_list|(
name|scratch
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|outputsEqual
argument_list|(
name|termsMap
operator|.
name|get
argument_list|(
name|scratch
operator|.
name|get
argument_list|()
argument_list|)
argument_list|,
name|output
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doReverseLookup
condition|)
block|{
comment|//System.out.println("lookup output=" + output + " outs=" + fst.outputs);
name|IntsRef
name|input
init|=
name|Util
operator|.
name|getByOutput
argument_list|(
name|fstLong
argument_list|,
operator|(
name|Long
operator|)
name|output
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|input
argument_list|)
expr_stmt|;
comment|//System.out.println("  got " + Util.toBytesRef(input, new BytesRef()).utf8ToString());
name|assertEquals
argument_list|(
name|scratch
operator|.
name|get
argument_list|()
argument_list|,
name|input
argument_list|)
expr_stmt|;
block|}
block|}
comment|// test IntsRefFSTEnum.seek:
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: verify seek"
argument_list|)
expr_stmt|;
block|}
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
name|fstEnum
init|=
operator|new
name|IntsRefFSTEnum
argument_list|<>
argument_list|(
name|fst
argument_list|)
decl_stmt|;
name|num
operator|=
name|LuceneTestCase
operator|.
name|atLeast
argument_list|(
name|random
argument_list|,
literal|100
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|num
condition|;
name|iter
operator|++
control|)
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  iter="
operator|+
name|iter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// seek to term that doesn't exist:
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|IntsRef
name|term
init|=
name|toIntsRef
argument_list|(
name|getRandomString
argument_list|(
name|random
argument_list|)
argument_list|,
name|inputMode
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|Collections
operator|.
name|binarySearch
argument_list|(
name|pairs
argument_list|,
operator|new
name|InputOutput
argument_list|<
name|T
argument_list|>
argument_list|(
name|term
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|pos
operator|=
operator|-
operator|(
name|pos
operator|+
literal|1
operator|)
expr_stmt|;
comment|// ok doesn't exist
comment|//System.out.println("  seek " + inputToString(inputMode, term));
specifier|final
name|IntsRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|T
argument_list|>
name|seekResult
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do non-exist seekExact term="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekExact
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do non-exist seekFloor term="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekFloor
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|pos
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do non-exist seekCeil term="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekCeil
argument_list|(
name|term
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
operator|&&
name|pos
operator|<
name|pairs
operator|.
name|size
argument_list|()
condition|)
block|{
comment|//System.out.println("    got " + inputToString(inputMode,seekResult.input) + " output=" + fst.outputs.outputToString(seekResult.output));
name|assertNotNull
argument_list|(
literal|"got null but expected term="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pairs
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|input
argument_list|)
argument_list|,
name|seekResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    got "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"expected "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pairs
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|input
argument_list|)
operator|+
literal|" but got "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
argument_list|,
name|pairs
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|input
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|outputsEqual
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|output
argument_list|,
name|seekResult
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// seeked before start or beyond end
comment|//System.out.println("seek=" + seekTerm);
name|assertNull
argument_list|(
literal|"expected null but got "
operator|+
operator|(
name|seekResult
operator|==
literal|null
condition|?
literal|"null"
else|:
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
operator|)
argument_list|,
name|seekResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    got null"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
else|else
block|{
comment|// seek to term that does exist:
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
init|=
name|pairs
operator|.
name|get
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
name|pairs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|IntsRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|T
argument_list|>
name|seekResult
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do exists seekExact term="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pair
operator|.
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekExact
argument_list|(
name|pair
operator|.
name|input
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do exists seekFloor "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pair
operator|.
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekFloor
argument_list|(
name|pair
operator|.
name|input
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do exists seekCeil "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pair
operator|.
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seekResult
operator|=
name|fstEnum
operator|.
name|seekCeil
argument_list|(
name|pair
operator|.
name|input
argument_list|)
expr_stmt|;
block|}
name|assertNotNull
argument_list|(
name|seekResult
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"got "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
operator|+
literal|" but expected "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pair
operator|.
name|input
argument_list|)
argument_list|,
name|pair
operator|.
name|input
argument_list|,
name|seekResult
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|outputsEqual
argument_list|(
name|pair
operator|.
name|output
argument_list|,
name|seekResult
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: mixed next/seek"
argument_list|)
expr_stmt|;
block|}
comment|// test mixed next/seek
name|num
operator|=
name|LuceneTestCase
operator|.
name|atLeast
argument_list|(
name|random
argument_list|,
literal|100
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|num
condition|;
name|iter
operator|++
control|)
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: iter "
operator|+
name|iter
argument_list|)
expr_stmt|;
block|}
comment|// reset:
name|fstEnum
operator|=
operator|new
name|IntsRefFSTEnum
argument_list|<>
argument_list|(
name|fst
argument_list|)
expr_stmt|;
name|int
name|upto
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|boolean
name|isDone
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|upto
operator|==
name|pairs
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|||
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// next
name|upto
operator|++
expr_stmt|;
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do next"
argument_list|)
expr_stmt|;
block|}
name|isDone
operator|=
name|fstEnum
operator|.
name|next
argument_list|()
operator|==
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|upto
operator|!=
operator|-
literal|1
operator|&&
name|upto
operator|<
literal|0.75
operator|*
name|pairs
operator|.
name|size
argument_list|()
operator|&&
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|int
name|attempt
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|attempt
operator|<
literal|10
condition|;
name|attempt
operator|++
control|)
block|{
name|IntsRef
name|term
init|=
name|toIntsRef
argument_list|(
name|getRandomString
argument_list|(
name|random
argument_list|)
argument_list|,
name|inputMode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|termsMap
operator|.
name|containsKey
argument_list|(
name|term
argument_list|)
operator|&&
name|term
operator|.
name|compareTo
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|input
argument_list|)
operator|>
literal|0
condition|)
block|{
name|int
name|pos
init|=
name|Collections
operator|.
name|binarySearch
argument_list|(
name|pairs
argument_list|,
operator|new
name|InputOutput
argument_list|<
name|T
argument_list|>
argument_list|(
name|term
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
assert|assert
name|pos
operator|<
literal|0
assert|;
name|upto
operator|=
operator|-
operator|(
name|pos
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|upto
operator|--
expr_stmt|;
name|assertTrue
argument_list|(
name|upto
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do non-exist seekFloor("
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|isDone
operator|=
name|fstEnum
operator|.
name|seekFloor
argument_list|(
name|term
argument_list|)
operator|==
literal|null
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do non-exist seekCeil("
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|term
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|isDone
operator|=
name|fstEnum
operator|.
name|seekCeil
argument_list|(
name|term
argument_list|)
operator|==
literal|null
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|attempt
operator|==
literal|10
condition|)
block|{
continue|continue;
block|}
block|}
else|else
block|{
specifier|final
name|int
name|inc
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|pairs
operator|.
name|size
argument_list|()
operator|-
name|upto
operator|-
literal|1
argument_list|)
decl_stmt|;
name|upto
operator|+=
name|inc
expr_stmt|;
if|if
condition|(
name|upto
operator|==
operator|-
literal|1
condition|)
block|{
name|upto
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do seekCeil("
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|input
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|isDone
operator|=
name|fstEnum
operator|.
name|seekCeil
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|input
argument_list|)
operator|==
literal|null
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  do seekFloor("
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|input
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|isDone
operator|=
name|fstEnum
operator|.
name|seekFloor
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|input
argument_list|)
operator|==
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
if|if
condition|(
operator|!
name|isDone
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    got "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    got null"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|upto
operator|==
name|pairs
operator|.
name|size
argument_list|()
condition|)
block|{
name|assertTrue
argument_list|(
name|isDone
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|assertFalse
argument_list|(
name|isDone
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|input
argument_list|,
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|input
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|outputsEqual
argument_list|(
name|pairs
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|output
argument_list|,
name|fstEnum
operator|.
name|current
argument_list|()
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
comment|/*             if (upto< pairs.size()-1) {             int tryCount = 0;             while(tryCount< 10) {             final IntsRef t = toIntsRef(getRandomString(), inputMode);             if (pairs.get(upto).input.compareTo(t)< 0) {             final boolean expected = t.compareTo(pairs.get(upto+1).input)< 0;             if (LuceneTestCase.VERBOSE) {             System.out.println("TEST: call beforeNext(" + inputToString(inputMode, t) + "); current=" + inputToString(inputMode, pairs.get(upto).input) + " next=" + inputToString(inputMode, pairs.get(upto+1).input) + " expected=" + expected);             }             assertEquals(expected, fstEnum.beforeNext(t));             break;             }             tryCount++;             }             }           */
block|}
block|}
block|}
block|}
DECL|class|CountMinOutput
specifier|private
specifier|static
class|class
name|CountMinOutput
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|count
name|int
name|count
decl_stmt|;
DECL|field|output
name|T
name|output
decl_stmt|;
DECL|field|finalOutput
name|T
name|finalOutput
decl_stmt|;
DECL|field|isLeaf
name|boolean
name|isLeaf
init|=
literal|true
decl_stmt|;
DECL|field|isFinal
name|boolean
name|isFinal
decl_stmt|;
block|}
comment|// FST is pruned
DECL|method|verifyPruned
specifier|private
name|void
name|verifyPruned
parameter_list|(
name|int
name|inputMode
parameter_list|,
name|FST
argument_list|<
name|T
argument_list|>
name|fst
parameter_list|,
name|int
name|prune1
parameter_list|,
name|int
name|prune2
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now verify pruned "
operator|+
name|pairs
operator|.
name|size
argument_list|()
operator|+
literal|" terms; outputs="
operator|+
name|outputs
argument_list|)
expr_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|pair
operator|.
name|input
argument_list|)
operator|+
literal|": "
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|pair
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// To validate the FST, we brute-force compute all prefixes
comment|// in the terms, matched to their "common" outputs, prune that
comment|// set according to the prune thresholds, then assert the FST
comment|// matches that same set.
comment|// NOTE: Crazy RAM intensive!!
comment|//System.out.println("TEST: tally prefixes");
comment|// build all prefixes
specifier|final
name|Map
argument_list|<
name|IntsRef
argument_list|,
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|prefixes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|IntsRefBuilder
name|scratch
init|=
operator|new
name|IntsRefBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|InputOutput
argument_list|<
name|T
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
name|scratch
operator|.
name|copyInts
argument_list|(
name|pair
operator|.
name|input
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<=
name|pair
operator|.
name|input
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|scratch
operator|.
name|setLength
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|CountMinOutput
argument_list|<
name|T
argument_list|>
name|cmo
init|=
name|prefixes
operator|.
name|get
argument_list|(
name|scratch
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmo
operator|==
literal|null
condition|)
block|{
name|cmo
operator|=
operator|new
name|CountMinOutput
argument_list|<>
argument_list|()
expr_stmt|;
name|cmo
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|cmo
operator|.
name|output
operator|=
name|pair
operator|.
name|output
expr_stmt|;
name|prefixes
operator|.
name|put
argument_list|(
name|scratch
operator|.
name|toIntsRef
argument_list|()
argument_list|,
name|cmo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmo
operator|.
name|count
operator|++
expr_stmt|;
name|T
name|output1
init|=
name|cmo
operator|.
name|output
decl_stmt|;
if|if
condition|(
name|output1
operator|.
name|equals
argument_list|(
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|)
condition|)
block|{
name|output1
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
block|}
name|T
name|output2
init|=
name|pair
operator|.
name|output
decl_stmt|;
if|if
condition|(
name|output2
operator|.
name|equals
argument_list|(
name|outputs
operator|.
name|getNoOutput
argument_list|()
argument_list|)
condition|)
block|{
name|output2
operator|=
name|outputs
operator|.
name|getNoOutput
argument_list|()
expr_stmt|;
block|}
name|cmo
operator|.
name|output
operator|=
name|outputs
operator|.
name|common
argument_list|(
name|output1
argument_list|,
name|output2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|==
name|pair
operator|.
name|input
operator|.
name|length
condition|)
block|{
name|cmo
operator|.
name|isFinal
operator|=
literal|true
expr_stmt|;
name|cmo
operator|.
name|finalOutput
operator|=
name|cmo
operator|.
name|output
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: now prune"
argument_list|)
expr_stmt|;
block|}
comment|// prune 'em
specifier|final
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|IntsRef
argument_list|,
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|>
name|it
init|=
name|prefixes
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|IntsRef
argument_list|,
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|ent
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|IntsRef
name|prefix
init|=
name|ent
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|CountMinOutput
argument_list|<
name|T
argument_list|>
name|cmo
init|=
name|ent
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  term prefix="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|prefix
argument_list|,
literal|false
argument_list|)
operator|+
literal|" count="
operator|+
name|cmo
operator|.
name|count
operator|+
literal|" isLeaf="
operator|+
name|cmo
operator|.
name|isLeaf
operator|+
literal|" output="
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|cmo
operator|.
name|output
argument_list|)
operator|+
literal|" isFinal="
operator|+
name|cmo
operator|.
name|isFinal
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|keep
decl_stmt|;
if|if
condition|(
name|prune1
operator|>
literal|0
condition|)
block|{
name|keep
operator|=
name|cmo
operator|.
name|count
operator|>=
name|prune1
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|prune2
operator|>
literal|0
assert|;
if|if
condition|(
name|prune2
operator|>
literal|1
operator|&&
name|cmo
operator|.
name|count
operator|>=
name|prune2
condition|)
block|{
name|keep
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prefix
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// consult our parent
name|scratch
operator|.
name|setLength
argument_list|(
name|prefix
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|prefix
operator|.
name|ints
argument_list|,
name|prefix
operator|.
name|offset
argument_list|,
name|scratch
operator|.
name|ints
argument_list|()
argument_list|,
literal|0
argument_list|,
name|scratch
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|CountMinOutput
argument_list|<
name|T
argument_list|>
name|cmo2
init|=
name|prefixes
operator|.
name|get
argument_list|(
name|scratch
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
comment|//System.out.println("    parent count = " + (cmo2 == null ? -1 : cmo2.count));
name|keep
operator|=
name|cmo2
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|prune2
operator|>
literal|1
operator|&&
name|cmo2
operator|.
name|count
operator|>=
name|prune2
operator|)
operator|||
operator|(
name|prune2
operator|==
literal|1
operator|&&
operator|(
name|cmo2
operator|.
name|count
operator|>=
literal|2
operator|||
name|prefix
operator|.
name|length
operator|<=
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmo
operator|.
name|count
operator|>=
name|prune2
condition|)
block|{
name|keep
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|keep
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|keep
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|//System.out.println("    remove");
block|}
else|else
block|{
comment|// clear isLeaf for all ancestors
comment|//System.out.println("    keep");
name|scratch
operator|.
name|copyInts
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|scratch
operator|.
name|setLength
argument_list|(
name|scratch
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|scratch
operator|.
name|length
argument_list|()
operator|>=
literal|0
condition|)
block|{
specifier|final
name|CountMinOutput
argument_list|<
name|T
argument_list|>
name|cmo2
init|=
name|prefixes
operator|.
name|get
argument_list|(
name|scratch
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmo2
operator|!=
literal|null
condition|)
block|{
comment|//System.out.println("    clear isLeaf " + inputToString(inputMode, scratch));
name|cmo2
operator|.
name|isLeaf
operator|=
literal|false
expr_stmt|;
block|}
name|scratch
operator|.
name|setLength
argument_list|(
name|scratch
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: after prune"
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|IntsRef
argument_list|,
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|ent
range|:
name|prefixes
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|ent
operator|.
name|getKey
argument_list|()
argument_list|,
literal|false
argument_list|)
operator|+
literal|": isLeaf="
operator|+
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|isLeaf
operator|+
literal|" isFinal="
operator|+
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|isFinal
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|isFinal
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    finalOutput="
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|finalOutput
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|prefixes
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
name|assertNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertNotNull
argument_list|(
name|fst
argument_list|)
expr_stmt|;
comment|// make sure FST only enums valid prefixes
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: check pruned enum"
argument_list|)
expr_stmt|;
block|}
name|IntsRefFSTEnum
argument_list|<
name|T
argument_list|>
name|fstEnum
init|=
operator|new
name|IntsRefFSTEnum
argument_list|<>
argument_list|(
name|fst
argument_list|)
decl_stmt|;
name|IntsRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|T
argument_list|>
name|current
decl_stmt|;
while|while
condition|(
operator|(
name|current
operator|=
name|fstEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  fstEnum.next prefix="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|current
operator|.
name|input
argument_list|,
literal|false
argument_list|)
operator|+
literal|" output="
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|current
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|CountMinOutput
argument_list|<
name|T
argument_list|>
name|cmo
init|=
name|prefixes
operator|.
name|get
argument_list|(
name|current
operator|.
name|input
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|cmo
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|cmo
operator|.
name|isLeaf
operator|||
name|cmo
operator|.
name|isFinal
argument_list|)
expr_stmt|;
comment|//if (cmo.isFinal&& !cmo.isLeaf) {
if|if
condition|(
name|cmo
operator|.
name|isFinal
condition|)
block|{
name|assertEquals
argument_list|(
name|cmo
operator|.
name|finalOutput
argument_list|,
name|current
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
name|cmo
operator|.
name|output
argument_list|,
name|current
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
comment|// make sure all non-pruned prefixes are present in the FST
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: verify all prefixes"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
index|[]
name|stopNode
init|=
operator|new
name|int
index|[
literal|1
index|]
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|IntsRef
argument_list|,
name|CountMinOutput
argument_list|<
name|T
argument_list|>
argument_list|>
name|ent
range|:
name|prefixes
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|ent
operator|.
name|getKey
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|)
block|{
specifier|final
name|CountMinOutput
argument_list|<
name|T
argument_list|>
name|cmo
init|=
name|ent
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|T
name|output
init|=
name|run
argument_list|(
name|fst
argument_list|,
name|ent
operator|.
name|getKey
argument_list|()
argument_list|,
name|stopNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"TEST: verify prefix="
operator|+
name|inputToString
argument_list|(
name|inputMode
argument_list|,
name|ent
operator|.
name|getKey
argument_list|()
argument_list|,
literal|false
argument_list|)
operator|+
literal|" output="
operator|+
name|outputs
operator|.
name|outputToString
argument_list|(
name|cmo
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// if (cmo.isFinal&& !cmo.isLeaf) {
if|if
condition|(
name|cmo
operator|.
name|isFinal
condition|)
block|{
name|assertEquals
argument_list|(
name|cmo
operator|.
name|finalOutput
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
name|cmo
operator|.
name|output
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|ent
operator|.
name|getKey
argument_list|()
operator|.
name|length
argument_list|,
name|stopNode
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class
end_unit
