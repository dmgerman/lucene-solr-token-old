begin_unit
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|NoSuchFileException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
operator|.
name|Store
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|StringField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|TextField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
operator|.
name|ReaderClosedListener
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
operator|.
name|SeekStatus
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FieldCache
operator|.
name|CacheEntry
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|QueryUtils
operator|.
name|FCInvisibleMultiReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
operator|.
name|Context
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MockDirectoryWrapper
operator|.
name|Throttling
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|FieldCacheSanityChecker
operator|.
name|Insanity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|AutomatonTestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|CompiledAutomaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|RegExp
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|RuleChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|TestRule
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|RunWith
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|*
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|*
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|ThreadLeakAction
operator|.
name|Action
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|ThreadLeakGroup
operator|.
name|Group
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|ThreadLeakScope
operator|.
name|Scope
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|ThreadLeakZombies
operator|.
name|Consequence
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|generators
operator|.
name|RandomPicks
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|rules
operator|.
name|NoClassHooksShadowingRule
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|rules
operator|.
name|NoInstanceHooksOverridesRule
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|rules
operator|.
name|StaticFieldsInvariantRule
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|rules
operator|.
name|SystemPropertiesInvariantRule
import|;
end_import
begin_import
import|import static
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|RandomizedTest
operator|.
name|systemPropertyAsBoolean
import|;
end_import
begin_import
import|import static
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|RandomizedTest
operator|.
name|systemPropertyAsInt
import|;
end_import
begin_comment
comment|/**  * Base class for all Lucene unit tests, Junit3 or Junit4 variant.  *   *<h3>Class and instance setup.</h3>  *   *<p>  * The preferred way to specify class (suite-level) setup/cleanup is to use  * static methods annotated with {@link BeforeClass} and {@link AfterClass}. Any  * code in these methods is executed within the test framework's control and  * ensure proper setup has been made.<b>Try not to use static initializers  * (including complex final field initializers).</b> Static initializers are  * executed before any setup rules are fired and may cause you (or somebody   * else) headaches.  *   *<p>  * For instance-level setup, use {@link Before} and {@link After} annotated  * methods. If you override either {@link #setUp()} or {@link #tearDown()} in  * your subclass, make sure you call<code>super.setUp()</code> and  *<code>super.tearDown()</code>. This is detected and enforced.  *   *<h3>Specifying test cases</h3>  *   *<p>  * Any test method with a<code>testXXX</code> prefix is considered a test case.  * Any test method annotated with {@link Test} is considered a test case.  *   *<h3>Randomized execution and test facilities</h3>  *   *<p>  * {@link LuceneTestCase} uses {@link RandomizedRunner} to execute test cases.  * {@link RandomizedRunner} has built-in support for tests randomization  * including access to a repeatable {@link Random} instance. See  * {@link #random()} method. Any test using {@link Random} acquired from  * {@link #random()} should be fully reproducible (assuming no race conditions  * between threads etc.). The initial seed for a test case is reported in many  * ways:  *<ul>  *<li>as part of any exception thrown from its body (inserted as a dummy stack  *   trace entry),</li>  *<li>as part of the main thread executing the test case (if your test hangs,  *   just dump the stack trace of all threads and you'll see the seed),</li>  *<li>the master seed can also be accessed manually by getting the current  *   context ({@link RandomizedContext#current()}) and then calling  *   {@link RandomizedContext#getRunnerSeedAsString()}.</li>  *</ul>  *   *<p>There is a number of other facilities tests can use, like:  *<ul>  *<li>{@link #closeAfterTest(Closeable)} and {@link #closeAfterSuite(Closeable)} to  *   register resources to be closed after each scope (if close fails, the scope  *   will fail too).</li>  *</ul>   */
end_comment
begin_class
annotation|@
name|RunWith
argument_list|(
name|RandomizedRunner
operator|.
name|class
argument_list|)
annotation|@
name|TestMethodProviders
argument_list|(
block|{
name|LuceneJUnit3MethodProvider
operator|.
name|class
block|,
name|JUnit4MethodProvider
operator|.
name|class
block|}
argument_list|)
annotation|@
name|Listeners
argument_list|(
block|{
name|RunListenerPrintReproduceInfo
operator|.
name|class
block|}
argument_list|)
annotation|@
name|SeedDecorators
argument_list|(
block|{
name|MixWithSuiteName
operator|.
name|class
block|}
argument_list|)
comment|// See LUCENE-3995 for rationale.
annotation|@
name|ThreadLeakScope
argument_list|(
name|Scope
operator|.
name|SUITE
argument_list|)
annotation|@
name|ThreadLeakGroup
argument_list|(
name|Group
operator|.
name|MAIN
argument_list|)
annotation|@
name|ThreadLeakAction
argument_list|(
block|{
name|Action
operator|.
name|WARN
block|,
name|Action
operator|.
name|INTERRUPT
block|}
argument_list|)
annotation|@
name|ThreadLeakLingering
argument_list|(
name|linger
operator|=
literal|20000
argument_list|)
comment|// Wait long for leaked threads to complete before failure. zk needs this.
annotation|@
name|ThreadLeakZombies
argument_list|(
name|Consequence
operator|.
name|IGNORE_REMAINING_TESTS
argument_list|)
annotation|@
name|TimeoutSuite
argument_list|(
name|millis
operator|=
literal|2
operator|*
name|TimeUnits
operator|.
name|HOUR
argument_list|)
annotation|@
name|ThreadLeakFilters
argument_list|(
name|defaultFilters
operator|=
literal|true
argument_list|,
name|filters
operator|=
block|{
name|QuickPatchThreadsFilter
operator|.
name|class
block|}
argument_list|)
DECL|class|LuceneTestCase
specifier|public
specifier|abstract
class|class
name|LuceneTestCase
extends|extends
name|Assert
block|{
comment|// --------------------------------------------------------------------
comment|// Test groups, system properties and other annotations modifying tests
comment|// --------------------------------------------------------------------
DECL|field|SYSPROP_NIGHTLY
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_NIGHTLY
init|=
literal|"tests.nightly"
decl_stmt|;
DECL|field|SYSPROP_WEEKLY
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_WEEKLY
init|=
literal|"tests.weekly"
decl_stmt|;
DECL|field|SYSPROP_AWAITSFIX
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_AWAITSFIX
init|=
literal|"tests.awaitsfix"
decl_stmt|;
DECL|field|SYSPROP_SLOW
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_SLOW
init|=
literal|"tests.slow"
decl_stmt|;
DECL|field|SYSPROP_BADAPPLES
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_BADAPPLES
init|=
literal|"tests.badapples"
decl_stmt|;
comment|/** @see #ignoreAfterMaxFailures*/
DECL|field|SYSPROP_MAXFAILURES
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_MAXFAILURES
init|=
literal|"tests.maxfailures"
decl_stmt|;
comment|/** @see #ignoreAfterMaxFailures*/
DECL|field|SYSPROP_FAILFAST
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_FAILFAST
init|=
literal|"tests.failfast"
decl_stmt|;
comment|/**    * Annotation for tests that should only be run during nightly builds.    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|false
argument_list|,
name|sysProperty
operator|=
name|SYSPROP_NIGHTLY
argument_list|)
DECL|interface|Nightly
specifier|public
annotation_defn|@interface
name|Nightly
block|{}
comment|/**    * Annotation for tests that should only be run during weekly builds    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|false
argument_list|,
name|sysProperty
operator|=
name|SYSPROP_WEEKLY
argument_list|)
DECL|interface|Weekly
specifier|public
annotation_defn|@interface
name|Weekly
block|{}
comment|/**    * Annotation for tests which exhibit a known issue and are temporarily disabled.    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|false
argument_list|,
name|sysProperty
operator|=
name|SYSPROP_AWAITSFIX
argument_list|)
DECL|interface|AwaitsFix
specifier|public
annotation_defn|@interface
name|AwaitsFix
block|{
comment|/** Point to JIRA entry. */
DECL|method|bugUrl
specifier|public
name|String
name|bugUrl
parameter_list|()
function_decl|;
block|}
comment|/**    * Annotation for tests that are slow. Slow tests do run by default but can be    * disabled if a quick run is needed.    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|true
argument_list|,
name|sysProperty
operator|=
name|SYSPROP_SLOW
argument_list|)
DECL|interface|Slow
specifier|public
annotation_defn|@interface
name|Slow
block|{}
comment|/**    * Annotation for tests that fail frequently and should    * be moved to a<a href="https://builds.apache.org/job/Lucene-BadApples-trunk-java7/">"vault" plan in Jenkins</a>.    *    * Tests annotated with this will be turned off by default. If you want to enable    * them, set:    *<pre>    * -Dtests.badapples=true    *</pre>    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|false
argument_list|,
name|sysProperty
operator|=
name|SYSPROP_BADAPPLES
argument_list|)
DECL|interface|BadApple
specifier|public
annotation_defn|@interface
name|BadApple
block|{
comment|/** Point to JIRA entry. */
DECL|method|bugUrl
specifier|public
name|String
name|bugUrl
parameter_list|()
function_decl|;
block|}
comment|/**    * Annotation for test classes that should avoid certain codec types    * (because they are expensive, for example).    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|Target
argument_list|(
name|ElementType
operator|.
name|TYPE
argument_list|)
DECL|interface|SuppressCodecs
specifier|public
annotation_defn|@interface
name|SuppressCodecs
block|{
DECL|method|value
name|String
index|[]
name|value
parameter_list|()
function_decl|;
block|}
comment|// -----------------------------------------------------------------
comment|// Truly immutable fields and constants, initialized once and valid
comment|// for all suites ever since.
comment|// -----------------------------------------------------------------
comment|// :Post-Release-Update-Version.LUCENE_XY:
comment|/**     * Use this constant when creating Analyzers and any other version-dependent stuff.    *<p><b>NOTE:</b> Change this when development starts for new Lucene version:    */
DECL|field|TEST_VERSION_CURRENT
specifier|public
specifier|static
specifier|final
name|Version
name|TEST_VERSION_CURRENT
init|=
name|Version
operator|.
name|LUCENE_50
decl_stmt|;
comment|/**    * True if and only if tests are run in verbose mode. If this flag is false    * tests are not expected to print any messages.    */
DECL|field|VERBOSE
specifier|public
specifier|static
specifier|final
name|boolean
name|VERBOSE
init|=
name|systemPropertyAsBoolean
argument_list|(
literal|"tests.verbose"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** TODO: javadoc? */
DECL|field|INFOSTREAM
specifier|public
specifier|static
specifier|final
name|boolean
name|INFOSTREAM
init|=
name|systemPropertyAsBoolean
argument_list|(
literal|"tests.infostream"
argument_list|,
name|VERBOSE
argument_list|)
decl_stmt|;
comment|/**    * A random multiplier which you should use when writing random tests:    * multiply it by the number of iterations to scale your tests (for nightly builds).    */
DECL|field|RANDOM_MULTIPLIER
specifier|public
specifier|static
specifier|final
name|int
name|RANDOM_MULTIPLIER
init|=
name|systemPropertyAsInt
argument_list|(
literal|"tests.multiplier"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/** TODO: javadoc? */
DECL|field|DEFAULT_LINE_DOCS_FILE
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_LINE_DOCS_FILE
init|=
literal|"europarl.lines.txt.gz"
decl_stmt|;
comment|/** TODO: javadoc? */
DECL|field|JENKINS_LARGE_LINE_DOCS_FILE
specifier|public
specifier|static
specifier|final
name|String
name|JENKINS_LARGE_LINE_DOCS_FILE
init|=
literal|"enwiki.random.lines.txt"
decl_stmt|;
comment|/** Gets the codec to run tests with. */
DECL|field|TEST_CODEC
specifier|public
specifier|static
specifier|final
name|String
name|TEST_CODEC
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.codec"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** Gets the postingsFormat to run tests with. */
DECL|field|TEST_POSTINGSFORMAT
specifier|public
specifier|static
specifier|final
name|String
name|TEST_POSTINGSFORMAT
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.postingsformat"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** Gets the docValuesFormat to run tests with */
DECL|field|TEST_DOCVALUESFORMAT
specifier|public
specifier|static
specifier|final
name|String
name|TEST_DOCVALUESFORMAT
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.docvaluesformat"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** Gets the directory to run tests with */
DECL|field|TEST_DIRECTORY
specifier|public
specifier|static
specifier|final
name|String
name|TEST_DIRECTORY
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.directory"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** the line file used by LineFileDocs */
DECL|field|TEST_LINE_DOCS_FILE
specifier|public
specifier|static
specifier|final
name|String
name|TEST_LINE_DOCS_FILE
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.linedocsfile"
argument_list|,
name|DEFAULT_LINE_DOCS_FILE
argument_list|)
decl_stmt|;
comment|/** Whether or not {@link Nightly} tests should run. */
DECL|field|TEST_NIGHTLY
specifier|public
specifier|static
specifier|final
name|boolean
name|TEST_NIGHTLY
init|=
name|systemPropertyAsBoolean
argument_list|(
name|SYSPROP_NIGHTLY
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** Whether or not {@link Weekly} tests should run. */
DECL|field|TEST_WEEKLY
specifier|public
specifier|static
specifier|final
name|boolean
name|TEST_WEEKLY
init|=
name|systemPropertyAsBoolean
argument_list|(
name|SYSPROP_WEEKLY
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** Whether or not {@link AwaitsFix} tests should run. */
DECL|field|TEST_AWAITSFIX
specifier|public
specifier|static
specifier|final
name|boolean
name|TEST_AWAITSFIX
init|=
name|systemPropertyAsBoolean
argument_list|(
name|SYSPROP_AWAITSFIX
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** Whether or not {@link Slow} tests should run. */
DECL|field|TEST_SLOW
specifier|public
specifier|static
specifier|final
name|boolean
name|TEST_SLOW
init|=
name|systemPropertyAsBoolean
argument_list|(
name|SYSPROP_SLOW
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** Throttling, see {@link MockDirectoryWrapper#setThrottling(Throttling)}. */
DECL|field|TEST_THROTTLING
specifier|public
specifier|static
specifier|final
name|Throttling
name|TEST_THROTTLING
init|=
name|TEST_NIGHTLY
condition|?
name|Throttling
operator|.
name|SOMETIMES
else|:
name|Throttling
operator|.
name|NEVER
decl_stmt|;
comment|/** Create indexes in this directory, optimally use a subdir, named after the test */
DECL|field|TEMP_DIR
specifier|public
specifier|static
specifier|final
name|File
name|TEMP_DIR
decl_stmt|;
static|static
block|{
name|String
name|s
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tempDir"
argument_list|,
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.io.tmpdir"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"To run tests, you need to define system property 'tempDir' or 'java.io.tmpdir'."
argument_list|)
throw|;
name|TEMP_DIR
operator|=
operator|new
name|File
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|TEMP_DIR
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
block|}
comment|/**    * These property keys will be ignored in verification of altered properties.    * @see SystemPropertiesInvariantRule    * @see #ruleChain    * @see #classRules    */
DECL|field|IGNORED_INVARIANT_PROPERTIES
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|IGNORED_INVARIANT_PROPERTIES
init|=
block|{
literal|"user.timezone"
block|,
literal|"java.rmi.server.randomIDs"
block|}
decl_stmt|;
comment|/** Filesystem-based {@link Directory} implementations. */
DECL|field|FS_DIRECTORIES
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|FS_DIRECTORIES
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"SimpleFSDirectory"
argument_list|,
literal|"NIOFSDirectory"
argument_list|,
literal|"MMapDirectory"
argument_list|)
decl_stmt|;
comment|/** All {@link Directory} implementations. */
DECL|field|CORE_DIRECTORIES
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|CORE_DIRECTORIES
decl_stmt|;
static|static
block|{
name|CORE_DIRECTORIES
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|FS_DIRECTORIES
argument_list|)
expr_stmt|;
name|CORE_DIRECTORIES
operator|.
name|add
argument_list|(
literal|"RAMDirectory"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
DECL|field|doesntSupportOffsets
specifier|protected
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|doesntSupportOffsets
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"Lucene3x"
argument_list|,
literal|"MockFixedIntBlock"
argument_list|,
literal|"MockVariableIntBlock"
argument_list|,
literal|"MockSep"
argument_list|,
literal|"MockRandom"
argument_list|)
argument_list|)
decl_stmt|;
comment|// -----------------------------------------------------------------
comment|// Fields initialized in class or instance rules.
comment|// -----------------------------------------------------------------
comment|/**    * When {@code true}, Codecs for old Lucene version will support writing    * indexes in that format. Defaults to {@code false}, can be disabled by    * specific tests on demand.    *     * @lucene.internal    */
DECL|field|OLD_FORMAT_IMPERSONATION_IS_ACTIVE
specifier|public
specifier|static
name|boolean
name|OLD_FORMAT_IMPERSONATION_IS_ACTIVE
init|=
literal|false
decl_stmt|;
comment|// -----------------------------------------------------------------
comment|// Class level (suite) rules.
comment|// -----------------------------------------------------------------
comment|/**    * Stores the currently class under test.    */
DECL|field|classNameRule
specifier|private
specifier|static
specifier|final
name|TestRuleStoreClassName
name|classNameRule
decl_stmt|;
comment|/**    * Class environment setup rule.    */
DECL|field|classEnvRule
specifier|static
specifier|final
name|TestRuleSetupAndRestoreClassEnv
name|classEnvRule
decl_stmt|;
comment|/**    * Suite failure marker (any error in the test or suite scope).    */
DECL|field|suiteFailureMarker
specifier|public
specifier|final
specifier|static
name|TestRuleMarkFailure
name|suiteFailureMarker
init|=
operator|new
name|TestRuleMarkFailure
argument_list|()
decl_stmt|;
comment|/**    * Ignore tests after hitting a designated number of initial failures. This    * is truly a "static" global singleton since it needs to span the lifetime of all    * test classes running inside this JVM (it cannot be part of a class rule).    *     *<p>This poses some problems for the test framework's tests because these sometimes    * trigger intentional failures which add up to the global count. This field contains    * a (possibly) changing reference to {@link TestRuleIgnoreAfterMaxFailures} and we    * dispatch to its current value from the {@link #classRules} chain using {@link TestRuleDelegate}.      */
DECL|field|ignoreAfterMaxFailuresDelegate
specifier|private
specifier|static
specifier|final
name|AtomicReference
argument_list|<
name|TestRuleIgnoreAfterMaxFailures
argument_list|>
name|ignoreAfterMaxFailuresDelegate
decl_stmt|;
DECL|field|ignoreAfterMaxFailures
specifier|private
specifier|static
specifier|final
name|TestRule
name|ignoreAfterMaxFailures
decl_stmt|;
static|static
block|{
name|int
name|maxFailures
init|=
name|systemPropertyAsInt
argument_list|(
name|SYSPROP_MAXFAILURES
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
name|boolean
name|failFast
init|=
name|systemPropertyAsBoolean
argument_list|(
name|SYSPROP_FAILFAST
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|failFast
condition|)
block|{
if|if
condition|(
name|maxFailures
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|maxFailures
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|Logger
operator|.
name|getLogger
argument_list|(
name|LuceneTestCase
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|)
operator|.
name|warning
argument_list|(
literal|"Property '"
operator|+
name|SYSPROP_MAXFAILURES
operator|+
literal|"'="
operator|+
name|maxFailures
operator|+
literal|", 'failfast' is"
operator|+
literal|" ignored."
argument_list|)
expr_stmt|;
block|}
block|}
name|ignoreAfterMaxFailuresDelegate
operator|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|(
operator|new
name|TestRuleIgnoreAfterMaxFailures
argument_list|(
name|maxFailures
argument_list|)
argument_list|)
expr_stmt|;
name|ignoreAfterMaxFailures
operator|=
name|TestRuleDelegate
operator|.
name|of
argument_list|(
name|ignoreAfterMaxFailuresDelegate
argument_list|)
expr_stmt|;
block|}
comment|/**    * Temporarily substitute the global {@link TestRuleIgnoreAfterMaxFailures}. See    * {@link #ignoreAfterMaxFailuresDelegate} for some explanation why this method     * is needed.    */
DECL|method|replaceMaxFailureRule
specifier|public
specifier|static
name|TestRuleIgnoreAfterMaxFailures
name|replaceMaxFailureRule
parameter_list|(
name|TestRuleIgnoreAfterMaxFailures
name|newValue
parameter_list|)
block|{
return|return
name|ignoreAfterMaxFailuresDelegate
operator|.
name|getAndSet
argument_list|(
name|newValue
argument_list|)
return|;
block|}
comment|/**    * Max 10mb of static data stored in a test suite class after the suite is complete.    * Prevents static data structures leaking and causing OOMs in subsequent tests.    */
DECL|field|STATIC_LEAK_THRESHOLD
specifier|private
specifier|final
specifier|static
name|long
name|STATIC_LEAK_THRESHOLD
init|=
literal|10
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
comment|/** By-name list of ignored types like loggers etc. */
DECL|field|STATIC_LEAK_IGNORED_TYPES
specifier|private
specifier|final
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|STATIC_LEAK_IGNORED_TYPES
init|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"org.slf4j.Logger"
argument_list|,
literal|"org.apache.solr.SolrLogFormatter"
argument_list|,
name|EnumSet
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/**    * This controls how suite-level rules are nested. It is important that _all_ rules declared    * in {@link LuceneTestCase} are executed in proper order if they depend on each     * other.    */
annotation|@
name|ClassRule
DECL|field|classRules
specifier|public
specifier|static
name|TestRule
name|classRules
init|=
name|RuleChain
operator|.
name|outerRule
argument_list|(
operator|new
name|TestRuleIgnoreTestSuites
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
name|ignoreAfterMaxFailures
argument_list|)
operator|.
name|around
argument_list|(
name|suiteFailureMarker
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|TestRuleAssertionsRequired
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|StaticFieldsInvariantRule
argument_list|(
name|STATIC_LEAK_THRESHOLD
argument_list|,
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|accept
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|field
parameter_list|)
block|{
comment|// Don't count known classes that consume memory once.
if|if
condition|(
name|STATIC_LEAK_IGNORED_TYPES
operator|.
name|contains
argument_list|(
name|field
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Don't count references from ourselves, we're top-level.
if|if
condition|(
name|field
operator|.
name|getDeclaringClass
argument_list|()
operator|==
name|LuceneTestCase
operator|.
name|class
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|super
operator|.
name|accept
argument_list|(
name|field
argument_list|)
return|;
block|}
block|}
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|NoClassHooksShadowingRule
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|NoInstanceHooksOverridesRule
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|verify
parameter_list|(
name|Method
name|key
parameter_list|)
block|{
name|String
name|name
init|=
name|key
operator|.
name|getName
argument_list|()
decl_stmt|;
return|return
operator|!
operator|(
name|name
operator|.
name|equals
argument_list|(
literal|"setUp"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"tearDown"
argument_list|)
operator|)
return|;
block|}
block|}
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|SystemPropertiesInvariantRule
argument_list|(
name|IGNORED_INVARIANT_PROPERTIES
argument_list|)
argument_list|)
operator|.
name|around
argument_list|(
name|classNameRule
operator|=
operator|new
name|TestRuleStoreClassName
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
name|classEnvRule
operator|=
operator|new
name|TestRuleSetupAndRestoreClassEnv
argument_list|()
argument_list|)
decl_stmt|;
comment|// -----------------------------------------------------------------
comment|// Test level rules.
comment|// -----------------------------------------------------------------
comment|/** Enforces {@link #setUp()} and {@link #tearDown()} calls are chained. */
DECL|field|parentChainCallRule
specifier|private
name|TestRuleSetupTeardownChained
name|parentChainCallRule
init|=
operator|new
name|TestRuleSetupTeardownChained
argument_list|()
decl_stmt|;
comment|/** Save test thread and name. */
DECL|field|threadAndTestNameRule
specifier|private
name|TestRuleThreadAndTestName
name|threadAndTestNameRule
init|=
operator|new
name|TestRuleThreadAndTestName
argument_list|()
decl_stmt|;
comment|/** Taint suite result with individual test failures. */
DECL|field|testFailureMarker
specifier|private
name|TestRuleMarkFailure
name|testFailureMarker
init|=
operator|new
name|TestRuleMarkFailure
argument_list|(
name|suiteFailureMarker
argument_list|)
decl_stmt|;
comment|/**    * This controls how individual test rules are nested. It is important that    * _all_ rules declared in {@link LuceneTestCase} are executed in proper order    * if they depend on each other.    */
annotation|@
name|Rule
DECL|field|ruleChain
specifier|public
specifier|final
name|TestRule
name|ruleChain
init|=
name|RuleChain
operator|.
name|outerRule
argument_list|(
name|testFailureMarker
argument_list|)
operator|.
name|around
argument_list|(
name|ignoreAfterMaxFailures
argument_list|)
operator|.
name|around
argument_list|(
name|threadAndTestNameRule
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|SystemPropertiesInvariantRule
argument_list|(
name|IGNORED_INVARIANT_PROPERTIES
argument_list|)
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|TestRuleSetupAndRestoreInstanceEnv
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|TestRuleFieldCacheSanity
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
name|parentChainCallRule
argument_list|)
decl_stmt|;
comment|// -----------------------------------------------------------------
comment|// Suite and test case setup/ cleanup.
comment|// -----------------------------------------------------------------
comment|/**    * For subclasses to override. Overrides must call {@code super.setUp()}.    */
annotation|@
name|Before
DECL|method|setUp
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|parentChainCallRule
operator|.
name|setupCalled
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * For subclasses to override. Overrides must call {@code super.tearDown()}.    */
annotation|@
name|After
DECL|method|tearDown
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
name|parentChainCallRule
operator|.
name|teardownCalled
operator|=
literal|true
expr_stmt|;
block|}
comment|// -----------------------------------------------------------------
comment|// Test facilities and facades for subclasses.
comment|// -----------------------------------------------------------------
comment|/**    * Access to the current {@link RandomizedContext}'s Random instance. It is safe to use    * this method from multiple threads, etc., but it should be called while within a runner's    * scope (so no static initializers). The returned {@link Random} instance will be     *<b>different</b> when this method is called inside a {@link BeforeClass} hook (static     * suite scope) and within {@link Before}/ {@link After} hooks or test methods.     *     *<p>The returned instance must not be shared with other threads or cross a single scope's     * boundary. For example, a {@link Random} acquired within a test method shouldn't be reused    * for another test case.    *     *<p>There is an overhead connected with getting the {@link Random} for a particular context    * and thread. It is better to cache the {@link Random} locally if tight loops with multiple    * invocations are present or create a derivative local {@link Random} for millions of calls     * like this:    *<pre>    * Random random = new Random(random().nextLong());    * // tight loop with many invocations.     *</pre>    */
DECL|method|random
specifier|public
specifier|static
name|Random
name|random
parameter_list|()
block|{
return|return
name|RandomizedContext
operator|.
name|current
argument_list|()
operator|.
name|getRandom
argument_list|()
return|;
block|}
comment|/**    * Registers a {@link Closeable} resource that should be closed after the test    * completes.    *     * @return<code>resource</code> (for call chaining).    */
DECL|method|closeAfterTest
specifier|public
parameter_list|<
name|T
extends|extends
name|Closeable
parameter_list|>
name|T
name|closeAfterTest
parameter_list|(
name|T
name|resource
parameter_list|)
block|{
return|return
name|RandomizedContext
operator|.
name|current
argument_list|()
operator|.
name|closeAtEnd
argument_list|(
name|resource
argument_list|,
name|LifecycleScope
operator|.
name|TEST
argument_list|)
return|;
block|}
comment|/**    * Registers a {@link Closeable} resource that should be closed after the suite    * completes.    *     * @return<code>resource</code> (for call chaining).    */
DECL|method|closeAfterSuite
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|Closeable
parameter_list|>
name|T
name|closeAfterSuite
parameter_list|(
name|T
name|resource
parameter_list|)
block|{
return|return
name|RandomizedContext
operator|.
name|current
argument_list|()
operator|.
name|closeAtEnd
argument_list|(
name|resource
argument_list|,
name|LifecycleScope
operator|.
name|SUITE
argument_list|)
return|;
block|}
comment|/**    * Return the current class being tested.    */
DECL|method|getTestClass
specifier|public
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|getTestClass
parameter_list|()
block|{
return|return
name|classNameRule
operator|.
name|getTestClass
argument_list|()
return|;
block|}
comment|/**    * Return the name of the currently executing test case.    */
DECL|method|getTestName
specifier|public
name|String
name|getTestName
parameter_list|()
block|{
return|return
name|threadAndTestNameRule
operator|.
name|testMethodName
return|;
block|}
comment|/**    * Some tests expect the directory to contain a single segment, and want to     * do tests on that segment's reader. This is an utility method to help them.    */
DECL|method|getOnlySegmentReader
specifier|public
specifier|static
name|SegmentReader
name|getOnlySegmentReader
parameter_list|(
name|DirectoryReader
name|reader
parameter_list|)
block|{
name|List
argument_list|<
name|AtomicReaderContext
argument_list|>
name|subReaders
init|=
name|reader
operator|.
name|leaves
argument_list|()
decl_stmt|;
if|if
condition|(
name|subReaders
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|reader
operator|+
literal|" has "
operator|+
name|subReaders
operator|.
name|size
argument_list|()
operator|+
literal|" segments instead of exactly one"
argument_list|)
throw|;
specifier|final
name|AtomicReader
name|r
init|=
name|subReaders
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|reader
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|r
operator|instanceof
name|SegmentReader
argument_list|)
expr_stmt|;
return|return
operator|(
name|SegmentReader
operator|)
name|r
return|;
block|}
comment|/**    * Returns true if and only if the calling thread is the primary thread     * executing the test case.     */
DECL|method|isTestThread
specifier|protected
name|boolean
name|isTestThread
parameter_list|()
block|{
name|assertNotNull
argument_list|(
literal|"Test case thread not set?"
argument_list|,
name|threadAndTestNameRule
operator|.
name|testCaseThread
argument_list|)
expr_stmt|;
return|return
name|Thread
operator|.
name|currentThread
argument_list|()
operator|==
name|threadAndTestNameRule
operator|.
name|testCaseThread
return|;
block|}
comment|/**    * Asserts that FieldCacheSanityChecker does not detect any    * problems with FieldCache.DEFAULT.    *<p>    * If any problems are found, they are logged to System.err    * (allong with the msg) when the Assertion is thrown.    *</p>    *<p>    * This method is called by tearDown after every test method,    * however IndexReaders scoped inside test methods may be garbage    * collected prior to this method being called, causing errors to    * be overlooked. Tests are encouraged to keep their IndexReaders    * scoped at the class level, or to explicitly call this method    * directly in the same scope as the IndexReader.    *</p>    *    * @see org.apache.lucene.util.FieldCacheSanityChecker    */
DECL|method|assertSaneFieldCaches
specifier|protected
specifier|static
name|void
name|assertSaneFieldCaches
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|)
block|{
specifier|final
name|CacheEntry
index|[]
name|entries
init|=
name|FieldCache
operator|.
name|DEFAULT
operator|.
name|getCacheEntries
argument_list|()
decl_stmt|;
name|Insanity
index|[]
name|insanity
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|insanity
operator|=
name|FieldCacheSanityChecker
operator|.
name|checkSanity
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|dumpArray
argument_list|(
name|msg
operator|+
literal|": FieldCache"
argument_list|,
name|entries
argument_list|,
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|assertEquals
argument_list|(
name|msg
operator|+
literal|": Insane FieldCache usage(s) found"
argument_list|,
literal|0
argument_list|,
name|insanity
operator|.
name|length
argument_list|)
expr_stmt|;
name|insanity
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
comment|// report this in the event of any exception/failure
comment|// if no failure, then insanity will be null anyway
if|if
condition|(
literal|null
operator|!=
name|insanity
condition|)
block|{
name|dumpArray
argument_list|(
name|msg
operator|+
literal|": Insane FieldCache usage(s)"
argument_list|,
name|insanity
argument_list|,
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns a number of at least<code>i</code>    *<p>    * The actual number returned will be influenced by whether {@link #TEST_NIGHTLY}    * is active and {@link #RANDOM_MULTIPLIER}, but also with some random fudge.    */
DECL|method|atLeast
specifier|public
specifier|static
name|int
name|atLeast
parameter_list|(
name|Random
name|random
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|int
name|min
init|=
operator|(
name|TEST_NIGHTLY
condition|?
literal|2
operator|*
name|i
else|:
name|i
operator|)
operator|*
name|RANDOM_MULTIPLIER
decl_stmt|;
name|int
name|max
init|=
name|min
operator|+
operator|(
name|min
operator|/
literal|2
operator|)
decl_stmt|;
return|return
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
return|;
block|}
DECL|method|atLeast
specifier|public
specifier|static
name|int
name|atLeast
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|atLeast
argument_list|(
name|random
argument_list|()
argument_list|,
name|i
argument_list|)
return|;
block|}
comment|/**    * Returns true if something should happen rarely,    *<p>    * The actual number returned will be influenced by whether {@link #TEST_NIGHTLY}    * is active and {@link #RANDOM_MULTIPLIER}.    */
DECL|method|rarely
specifier|public
specifier|static
name|boolean
name|rarely
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|int
name|p
init|=
name|TEST_NIGHTLY
condition|?
literal|10
else|:
literal|1
decl_stmt|;
name|p
operator|+=
operator|(
name|p
operator|*
name|Math
operator|.
name|log
argument_list|(
name|RANDOM_MULTIPLIER
argument_list|)
operator|)
expr_stmt|;
name|int
name|min
init|=
literal|100
operator|-
name|Math
operator|.
name|min
argument_list|(
name|p
argument_list|,
literal|50
argument_list|)
decl_stmt|;
comment|// never more than 50
return|return
name|random
operator|.
name|nextInt
argument_list|(
literal|100
argument_list|)
operator|>=
name|min
return|;
block|}
DECL|method|rarely
specifier|public
specifier|static
name|boolean
name|rarely
parameter_list|()
block|{
return|return
name|rarely
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|usually
specifier|public
specifier|static
name|boolean
name|usually
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
return|return
operator|!
name|rarely
argument_list|(
name|random
argument_list|)
return|;
block|}
DECL|method|usually
specifier|public
specifier|static
name|boolean
name|usually
parameter_list|()
block|{
return|return
name|usually
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|assumeTrue
specifier|public
specifier|static
name|void
name|assumeTrue
parameter_list|(
name|String
name|msg
parameter_list|,
name|boolean
name|condition
parameter_list|)
block|{
name|RandomizedTest
operator|.
name|assumeTrue
argument_list|(
name|msg
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
DECL|method|assumeFalse
specifier|public
specifier|static
name|void
name|assumeFalse
parameter_list|(
name|String
name|msg
parameter_list|,
name|boolean
name|condition
parameter_list|)
block|{
name|RandomizedTest
operator|.
name|assumeFalse
argument_list|(
name|msg
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
DECL|method|assumeNoException
specifier|public
specifier|static
name|void
name|assumeNoException
parameter_list|(
name|String
name|msg
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|RandomizedTest
operator|.
name|assumeNoException
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return<code>args</code> as a {@link Set} instance. The order of elements is not    * preserved in iterators.    */
annotation|@
name|SafeVarargs
annotation|@
name|SuppressWarnings
argument_list|(
literal|"varargs"
argument_list|)
DECL|method|asSet
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Set
argument_list|<
name|T
argument_list|>
name|asSet
parameter_list|(
name|T
modifier|...
name|args
parameter_list|)
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|args
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Convenience method for logging an iterator.    *    * @param label  String logged before/after the items in the iterator    * @param iter   Each next() is toString()ed and logged on it's own line. If iter is null this is logged differnetly then an empty iterator.    * @param stream Stream to log messages to.    */
DECL|method|dumpIterator
specifier|public
specifier|static
name|void
name|dumpIterator
parameter_list|(
name|String
name|label
parameter_list|,
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
parameter_list|,
name|PrintStream
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|println
argument_list|(
literal|"*** BEGIN "
operator|+
name|label
operator|+
literal|" ***"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|iter
condition|)
block|{
name|stream
operator|.
name|println
argument_list|(
literal|" ... NULL ..."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|stream
operator|.
name|println
argument_list|(
name|iter
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|stream
operator|.
name|println
argument_list|(
literal|"*** END "
operator|+
name|label
operator|+
literal|" ***"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Convenience method for logging an array.  Wraps the array in an iterator and delegates    *    * @see #dumpIterator(String,Iterator,PrintStream)    */
DECL|method|dumpArray
specifier|public
specifier|static
name|void
name|dumpArray
parameter_list|(
name|String
name|label
parameter_list|,
name|Object
index|[]
name|objs
parameter_list|,
name|PrintStream
name|stream
parameter_list|)
block|{
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
init|=
operator|(
literal|null
operator|==
name|objs
operator|)
condition|?
literal|null
else|:
name|Arrays
operator|.
name|asList
argument_list|(
name|objs
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|dumpIterator
argument_list|(
name|label
argument_list|,
name|iter
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/** create a new index writer config with random defaults */
DECL|method|newIndexWriterConfig
specifier|public
specifier|static
name|IndexWriterConfig
name|newIndexWriterConfig
parameter_list|(
name|Version
name|v
parameter_list|,
name|Analyzer
name|a
parameter_list|)
block|{
return|return
name|newIndexWriterConfig
argument_list|(
name|random
argument_list|()
argument_list|,
name|v
argument_list|,
name|a
argument_list|)
return|;
block|}
comment|/** create a new index writer config with random defaults using the specified random */
DECL|method|newIndexWriterConfig
specifier|public
specifier|static
name|IndexWriterConfig
name|newIndexWriterConfig
parameter_list|(
name|Random
name|r
parameter_list|,
name|Version
name|v
parameter_list|,
name|Analyzer
name|a
parameter_list|)
block|{
name|IndexWriterConfig
name|c
init|=
operator|new
name|IndexWriterConfig
argument_list|(
name|v
argument_list|,
name|a
argument_list|)
decl_stmt|;
name|c
operator|.
name|setSimilarity
argument_list|(
name|classEnvRule
operator|.
name|similarity
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
comment|// Even though TestRuleSetupAndRestoreClassEnv calls
comment|// InfoStream.setDefault, we do it again here so that
comment|// the PrintStreamInfoStream.messageID increments so
comment|// that when there are separate instances of
comment|// IndexWriter created we see "IW 0", "IW 1", "IW 2",
comment|// ... instead of just always "IW 0":
name|c
operator|.
name|setInfoStream
argument_list|(
operator|new
name|TestRuleSetupAndRestoreClassEnv
operator|.
name|ThreadNameFixingPrintStreamInfoStream
argument_list|(
name|System
operator|.
name|out
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|c
operator|.
name|setMergeScheduler
argument_list|(
operator|new
name|SerialMergeScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|int
name|maxThreadCount
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|int
name|maxMergeCount
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
name|maxThreadCount
argument_list|,
name|maxThreadCount
operator|+
literal|4
argument_list|)
decl_stmt|;
name|ConcurrentMergeScheduler
name|cms
init|=
operator|new
name|ConcurrentMergeScheduler
argument_list|()
decl_stmt|;
name|cms
operator|.
name|setMaxMergesAndThreads
argument_list|(
name|maxMergeCount
argument_list|,
name|maxThreadCount
argument_list|)
expr_stmt|;
name|c
operator|.
name|setMergeScheduler
argument_list|(
name|cms
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// crazy value
name|c
operator|.
name|setMaxBufferedDocs
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|15
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// reasonable value
name|c
operator|.
name|setMaxBufferedDocs
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|16
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|int
name|maxNumThreadStates
init|=
name|rarely
argument_list|(
name|r
argument_list|)
condition|?
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|5
argument_list|,
literal|20
argument_list|)
comment|// crazy value
else|:
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|)
decl_stmt|;
comment|// reasonable value
name|Method
name|setIndexerThreadPoolMethod
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Retrieve the package-private setIndexerThreadPool
comment|// method:
for|for
control|(
name|Method
name|m
range|:
name|IndexWriterConfig
operator|.
name|class
operator|.
name|getDeclaredMethods
argument_list|()
control|)
block|{
if|if
condition|(
name|m
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"setIndexerThreadPool"
argument_list|)
condition|)
block|{
name|m
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setIndexerThreadPoolMethod
operator|=
name|m
expr_stmt|;
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Should not happen?
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|setIndexerThreadPoolMethod
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"failed to lookup IndexWriterConfig.setIndexerThreadPool method"
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|Class
operator|.
name|forName
argument_list|(
literal|"org.apache.lucene.index.RandomDocumentsWriterPerThreadPool"
argument_list|)
decl_stmt|;
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
init|=
name|clazz
operator|.
name|getConstructor
argument_list|(
name|int
operator|.
name|class
argument_list|,
name|Random
operator|.
name|class
argument_list|)
decl_stmt|;
name|ctor
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// random thread pool
name|setIndexerThreadPoolMethod
operator|.
name|invoke
argument_list|(
name|c
argument_list|,
name|ctor
operator|.
name|newInstance
argument_list|(
name|maxNumThreadStates
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// random thread pool
name|c
operator|.
name|setMaxThreadStates
argument_list|(
name|maxNumThreadStates
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
name|c
operator|.
name|setMergePolicy
argument_list|(
name|newMergePolicy
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|c
operator|.
name|setMergedSegmentWarmer
argument_list|(
operator|new
name|SimpleMergedSegmentWarmer
argument_list|(
name|c
operator|.
name|getInfoStream
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|.
name|setUseCompoundFile
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|c
operator|.
name|setReaderPooling
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
DECL|method|newMergePolicy
specifier|public
specifier|static
name|MergePolicy
name|newMergePolicy
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
return|return
operator|new
name|MockRandomMergePolicy
argument_list|(
name|r
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
return|return
name|newTieredMergePolicy
argument_list|(
name|r
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|newAlcoholicMergePolicy
argument_list|(
name|r
argument_list|,
name|classEnvRule
operator|.
name|timeZone
argument_list|)
return|;
block|}
return|return
name|newLogMergePolicy
argument_list|(
name|r
argument_list|)
return|;
block|}
DECL|method|newMergePolicy
specifier|public
specifier|static
name|MergePolicy
name|newMergePolicy
parameter_list|()
block|{
return|return
name|newMergePolicy
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|()
block|{
return|return
name|newLogMergePolicy
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newTieredMergePolicy
specifier|public
specifier|static
name|TieredMergePolicy
name|newTieredMergePolicy
parameter_list|()
block|{
return|return
name|newTieredMergePolicy
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newAlcoholicMergePolicy
specifier|public
specifier|static
name|AlcoholicMergePolicy
name|newAlcoholicMergePolicy
parameter_list|()
block|{
return|return
name|newAlcoholicMergePolicy
argument_list|(
name|random
argument_list|()
argument_list|,
name|classEnvRule
operator|.
name|timeZone
argument_list|)
return|;
block|}
DECL|method|newAlcoholicMergePolicy
specifier|public
specifier|static
name|AlcoholicMergePolicy
name|newAlcoholicMergePolicy
parameter_list|(
name|Random
name|r
parameter_list|,
name|TimeZone
name|tz
parameter_list|)
block|{
return|return
operator|new
name|AlcoholicMergePolicy
argument_list|(
name|tz
argument_list|,
operator|new
name|Random
argument_list|(
name|r
operator|.
name|nextLong
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|r
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|LogDocMergePolicy
argument_list|()
else|:
operator|new
name|LogByteSizeMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setCalibrateSizeByDeletes
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|configureRandom
argument_list|(
name|r
argument_list|,
name|logmp
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
DECL|method|configureRandom
specifier|private
specifier|static
name|void
name|configureRandom
parameter_list|(
name|Random
name|r
parameter_list|,
name|MergePolicy
name|mergePolicy
parameter_list|)
block|{
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|mergePolicy
operator|.
name|setNoCFSRatio
argument_list|(
literal|0.1
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|0.8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mergePolicy
operator|.
name|setNoCFSRatio
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|1.0
else|:
literal|0.0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rarely
argument_list|()
condition|)
block|{
name|mergePolicy
operator|.
name|setMaxCFSSegmentSizeMB
argument_list|(
literal|0.2
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|2.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mergePolicy
operator|.
name|setMaxCFSSegmentSizeMB
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|newTieredMergePolicy
specifier|public
specifier|static
name|TieredMergePolicy
name|newTieredMergePolicy
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
name|TieredMergePolicy
name|tmp
init|=
operator|new
name|TieredMergePolicy
argument_list|()
decl_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|setMaxMergeAtOnce
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setMaxMergeAtOnceExplicit
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|setMaxMergeAtOnce
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setMaxMergeAtOnceExplicit
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|setMaxMergedSegmentMB
argument_list|(
literal|0.2
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|2.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|setMaxMergedSegmentMB
argument_list|(
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|100
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|.
name|setFloorSegmentMB
argument_list|(
literal|0.2
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|2.0
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setForceMergeDeletesPctAllowed
argument_list|(
literal|0.0
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|30.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|setSegmentsPerTier
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|20
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|setSegmentsPerTier
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|configureRandom
argument_list|(
name|r
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setReclaimDeletesWeight
argument_list|(
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|MergePolicy
name|newLogMergePolicy
parameter_list|(
name|boolean
name|useCFS
parameter_list|)
block|{
name|MergePolicy
name|logmp
init|=
name|newLogMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setNoCFSRatio
argument_list|(
name|useCFS
condition|?
literal|1.0
else|:
literal|0.0
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|MergePolicy
name|newLogMergePolicy
parameter_list|(
name|boolean
name|useCFS
parameter_list|,
name|int
name|mergeFactor
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|newLogMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setNoCFSRatio
argument_list|(
name|useCFS
condition|?
literal|1.0
else|:
literal|0.0
argument_list|)
expr_stmt|;
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|mergeFactor
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|MergePolicy
name|newLogMergePolicy
parameter_list|(
name|int
name|mergeFactor
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|newLogMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|mergeFactor
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
comment|/**    * Returns a new Directory instance. Use this when the test does not    * care about the specific Directory implementation (most tests).    *<p>    * The Directory is wrapped with {@link BaseDirectoryWrapper}.    * this means usually it will be picky, such as ensuring that you    * properly close it and all open files in your test. It will emulate    * some features of Windows, such as not allowing open files to be    * overwritten.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newDirectory
parameter_list|()
block|{
return|return
name|newDirectory
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a new Directory instance, using the specified random.    * See {@link #newDirectory()} for more information.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newDirectory
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
return|return
name|wrapDirectory
argument_list|(
name|r
argument_list|,
name|newDirectoryImpl
argument_list|(
name|r
argument_list|,
name|TEST_DIRECTORY
argument_list|)
argument_list|,
name|rarely
argument_list|(
name|r
argument_list|)
argument_list|)
return|;
block|}
DECL|method|newMockDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newMockDirectory
parameter_list|()
block|{
return|return
name|newMockDirectory
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newMockDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newMockDirectory
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
return|return
operator|(
name|MockDirectoryWrapper
operator|)
name|wrapDirectory
argument_list|(
name|r
argument_list|,
name|newDirectoryImpl
argument_list|(
name|r
argument_list|,
name|TEST_DIRECTORY
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|newMockFSDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newMockFSDirectory
parameter_list|(
name|File
name|f
parameter_list|)
block|{
return|return
operator|(
name|MockDirectoryWrapper
operator|)
name|newFSDirectory
argument_list|(
name|f
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Returns a new Directory instance, with contents copied from the    * provided directory. See {@link #newDirectory()} for more    * information.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newDirectory
parameter_list|(
name|Directory
name|d
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|newDirectory
argument_list|(
name|random
argument_list|()
argument_list|,
name|d
argument_list|)
return|;
block|}
comment|/** Returns a new FSDirectory instance over the given file, which must be a folder. */
DECL|method|newFSDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newFSDirectory
parameter_list|(
name|File
name|f
parameter_list|)
block|{
return|return
name|newFSDirectory
argument_list|(
name|f
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Returns a new FSDirectory instance over the given file, which must be a folder. */
DECL|method|newFSDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newFSDirectory
parameter_list|(
name|File
name|f
parameter_list|,
name|LockFactory
name|lf
parameter_list|)
block|{
return|return
name|newFSDirectory
argument_list|(
name|f
argument_list|,
name|lf
argument_list|,
name|rarely
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newFSDirectory
specifier|private
specifier|static
name|BaseDirectoryWrapper
name|newFSDirectory
parameter_list|(
name|File
name|f
parameter_list|,
name|LockFactory
name|lf
parameter_list|,
name|boolean
name|bare
parameter_list|)
block|{
name|String
name|fsdirClass
init|=
name|TEST_DIRECTORY
decl_stmt|;
if|if
condition|(
name|fsdirClass
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
block|{
name|fsdirClass
operator|=
name|RandomPicks
operator|.
name|randomFrom
argument_list|(
name|random
argument_list|()
argument_list|,
name|FS_DIRECTORIES
argument_list|)
expr_stmt|;
block|}
name|Class
argument_list|<
name|?
extends|extends
name|FSDirectory
argument_list|>
name|clazz
decl_stmt|;
try|try
block|{
try|try
block|{
name|clazz
operator|=
name|CommandLineUtil
operator|.
name|loadFSDirectoryClass
argument_list|(
name|fsdirClass
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
comment|// TEST_DIRECTORY is not a sub-class of FSDirectory, so draw one at random
name|fsdirClass
operator|=
name|RandomPicks
operator|.
name|randomFrom
argument_list|(
name|random
argument_list|()
argument_list|,
name|FS_DIRECTORIES
argument_list|)
expr_stmt|;
name|clazz
operator|=
name|CommandLineUtil
operator|.
name|loadFSDirectoryClass
argument_list|(
name|fsdirClass
argument_list|)
expr_stmt|;
block|}
name|Directory
name|fsdir
init|=
name|newFSDirectoryImpl
argument_list|(
name|clazz
argument_list|,
name|f
argument_list|)
decl_stmt|;
name|BaseDirectoryWrapper
name|wrapped
init|=
name|wrapDirectory
argument_list|(
name|random
argument_list|()
argument_list|,
name|fsdir
argument_list|,
name|bare
argument_list|)
decl_stmt|;
if|if
condition|(
name|lf
operator|!=
literal|null
condition|)
block|{
name|wrapped
operator|.
name|setLockFactory
argument_list|(
name|lf
argument_list|)
expr_stmt|;
block|}
return|return
name|wrapped
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns a new Directory instance, using the specified random    * with contents copied from the provided directory. See     * {@link #newDirectory()} for more information.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newDirectory
parameter_list|(
name|Random
name|r
parameter_list|,
name|Directory
name|d
parameter_list|)
throws|throws
name|IOException
block|{
name|Directory
name|impl
init|=
name|newDirectoryImpl
argument_list|(
name|r
argument_list|,
name|TEST_DIRECTORY
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|d
operator|.
name|listAll
argument_list|()
control|)
block|{
name|d
operator|.
name|copy
argument_list|(
name|impl
argument_list|,
name|file
argument_list|,
name|file
argument_list|,
name|newIOContext
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|wrapDirectory
argument_list|(
name|r
argument_list|,
name|impl
argument_list|,
name|rarely
argument_list|(
name|r
argument_list|)
argument_list|)
return|;
block|}
DECL|method|wrapDirectory
specifier|private
specifier|static
name|BaseDirectoryWrapper
name|wrapDirectory
parameter_list|(
name|Random
name|random
parameter_list|,
name|Directory
name|directory
parameter_list|,
name|boolean
name|bare
parameter_list|)
block|{
if|if
condition|(
name|rarely
argument_list|(
name|random
argument_list|)
condition|)
block|{
name|directory
operator|=
operator|new
name|NRTCachingDirectory
argument_list|(
name|directory
argument_list|,
name|random
operator|.
name|nextDouble
argument_list|()
argument_list|,
name|random
operator|.
name|nextDouble
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rarely
argument_list|(
name|random
argument_list|)
condition|)
block|{
specifier|final
name|double
name|maxMBPerSec
init|=
literal|10
operator|+
literal|5
operator|*
operator|(
name|random
operator|.
name|nextDouble
argument_list|()
operator|-
literal|0.5
operator|)
decl_stmt|;
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"LuceneTestCase: will rate limit output IndexOutput to "
operator|+
name|maxMBPerSec
operator|+
literal|" MB/sec"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RateLimitedDirectoryWrapper
name|rateLimitedDirectoryWrapper
init|=
operator|new
name|RateLimitedDirectoryWrapper
argument_list|(
name|directory
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
condition|)
block|{
case|case
literal|3
case|:
comment|// sometimes rate limit on flush
name|rateLimitedDirectoryWrapper
operator|.
name|setMaxWriteMBPerSec
argument_list|(
name|maxMBPerSec
argument_list|,
name|Context
operator|.
name|FLUSH
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|// sometimes rate limit flush& merge
name|rateLimitedDirectoryWrapper
operator|.
name|setMaxWriteMBPerSec
argument_list|(
name|maxMBPerSec
argument_list|,
name|Context
operator|.
name|FLUSH
argument_list|)
expr_stmt|;
name|rateLimitedDirectoryWrapper
operator|.
name|setMaxWriteMBPerSec
argument_list|(
name|maxMBPerSec
argument_list|,
name|Context
operator|.
name|MERGE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rateLimitedDirectoryWrapper
operator|.
name|setMaxWriteMBPerSec
argument_list|(
name|maxMBPerSec
argument_list|,
name|Context
operator|.
name|MERGE
argument_list|)
expr_stmt|;
block|}
name|directory
operator|=
name|rateLimitedDirectoryWrapper
expr_stmt|;
block|}
if|if
condition|(
name|bare
condition|)
block|{
name|BaseDirectoryWrapper
name|base
init|=
operator|new
name|BaseDirectoryWrapper
argument_list|(
name|directory
argument_list|)
decl_stmt|;
name|closeAfterSuite
argument_list|(
operator|new
name|CloseableDirectory
argument_list|(
name|base
argument_list|,
name|suiteFailureMarker
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|base
return|;
block|}
else|else
block|{
name|MockDirectoryWrapper
name|mock
init|=
operator|new
name|MockDirectoryWrapper
argument_list|(
name|random
argument_list|,
name|directory
argument_list|)
decl_stmt|;
name|mock
operator|.
name|setThrottling
argument_list|(
name|TEST_THROTTLING
argument_list|)
expr_stmt|;
name|closeAfterSuite
argument_list|(
operator|new
name|CloseableDirectory
argument_list|(
name|mock
argument_list|,
name|suiteFailureMarker
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mock
return|;
block|}
block|}
DECL|method|newStringField
specifier|public
specifier|static
name|Field
name|newStringField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Store
name|stored
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|()
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|stored
operator|==
name|Store
operator|.
name|YES
condition|?
name|StringField
operator|.
name|TYPE_STORED
else|:
name|StringField
operator|.
name|TYPE_NOT_STORED
argument_list|)
return|;
block|}
DECL|method|newTextField
specifier|public
specifier|static
name|Field
name|newTextField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Store
name|stored
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|()
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|stored
operator|==
name|Store
operator|.
name|YES
condition|?
name|TextField
operator|.
name|TYPE_STORED
else|:
name|TextField
operator|.
name|TYPE_NOT_STORED
argument_list|)
return|;
block|}
DECL|method|newStringField
specifier|public
specifier|static
name|Field
name|newStringField
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Store
name|stored
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|stored
operator|==
name|Store
operator|.
name|YES
condition|?
name|StringField
operator|.
name|TYPE_STORED
else|:
name|StringField
operator|.
name|TYPE_NOT_STORED
argument_list|)
return|;
block|}
DECL|method|newTextField
specifier|public
specifier|static
name|Field
name|newTextField
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Store
name|stored
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|stored
operator|==
name|Store
operator|.
name|YES
condition|?
name|TextField
operator|.
name|TYPE_STORED
else|:
name|TextField
operator|.
name|TYPE_NOT_STORED
argument_list|)
return|;
block|}
DECL|method|newField
specifier|public
specifier|static
name|Field
name|newField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|FieldType
name|type
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|()
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|method|newField
specifier|public
specifier|static
name|Field
name|newField
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|FieldType
name|type
parameter_list|)
block|{
name|name
operator|=
operator|new
name|String
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|usually
argument_list|(
name|random
argument_list|)
operator|||
operator|!
name|type
operator|.
name|indexed
argument_list|()
condition|)
block|{
comment|// most of the time, don't modify the params
return|return
operator|new
name|Field
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|// TODO: once all core& test codecs can index
comment|// offsets, sometimes randomly turn on offsets if we are
comment|// already indexing positions...
name|FieldType
name|newType
init|=
operator|new
name|FieldType
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newType
operator|.
name|stored
argument_list|()
operator|&&
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStored
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// randomly store it
block|}
if|if
condition|(
operator|!
name|newType
operator|.
name|storeTermVectors
argument_list|()
operator|&&
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStoreTermVectors
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newType
operator|.
name|storeTermVectorOffsets
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStoreTermVectorOffsets
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newType
operator|.
name|storeTermVectorPositions
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStoreTermVectorPositions
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|newType
operator|.
name|storeTermVectorPositions
argument_list|()
operator|&&
operator|!
name|newType
operator|.
name|storeTermVectorPayloads
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStoreTermVectorPayloads
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// TODO: we need to do this, but smarter, ie, most of
comment|// the time we set the same value for a given field but
comment|// sometimes (rarely) we change it up:
comment|/*     if (newType.omitNorms()) {       newType.setOmitNorms(random.nextBoolean());     }     */
return|return
operator|new
name|Field
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|newType
argument_list|)
return|;
block|}
comment|/**     * Return a random Locale from the available locales on the system.    * @see "https://issues.apache.org/jira/browse/LUCENE-4020"    */
DECL|method|randomLocale
specifier|public
specifier|static
name|Locale
name|randomLocale
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|Locale
name|locales
index|[]
init|=
name|Locale
operator|.
name|getAvailableLocales
argument_list|()
decl_stmt|;
return|return
name|locales
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|locales
operator|.
name|length
argument_list|)
index|]
return|;
block|}
comment|/**     * Return a random TimeZone from the available timezones on the system    * @see "https://issues.apache.org/jira/browse/LUCENE-4020"     */
DECL|method|randomTimeZone
specifier|public
specifier|static
name|TimeZone
name|randomTimeZone
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|String
name|tzIds
index|[]
init|=
name|TimeZone
operator|.
name|getAvailableIDs
argument_list|()
decl_stmt|;
return|return
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
name|tzIds
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|tzIds
operator|.
name|length
argument_list|)
index|]
argument_list|)
return|;
block|}
comment|/** return a Locale object equivalent to its programmatic name */
DECL|method|localeForName
specifier|public
specifier|static
name|Locale
name|localeForName
parameter_list|(
name|String
name|localeName
parameter_list|)
block|{
name|String
name|elements
index|[]
init|=
name|localeName
operator|.
name|split
argument_list|(
literal|"\\_"
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|elements
operator|.
name|length
condition|)
block|{
case|case
literal|4
case|:
comment|/* fallthrough for special cases */
case|case
literal|3
case|:
return|return
operator|new
name|Locale
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|,
name|elements
index|[
literal|1
index|]
argument_list|,
name|elements
index|[
literal|2
index|]
argument_list|)
return|;
case|case
literal|2
case|:
return|return
operator|new
name|Locale
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|,
name|elements
index|[
literal|1
index|]
argument_list|)
return|;
case|case
literal|1
case|:
return|return
operator|new
name|Locale
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid Locale: "
operator|+
name|localeName
argument_list|)
throw|;
block|}
block|}
DECL|method|newFSDirectoryImpl
specifier|private
specifier|static
name|Directory
name|newFSDirectoryImpl
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|FSDirectory
argument_list|>
name|clazz
parameter_list|,
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDirectory
name|d
init|=
literal|null
decl_stmt|;
try|try
block|{
name|d
operator|=
name|CommandLineUtil
operator|.
name|newFSDirectory
argument_list|(
name|clazz
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
decl||
name|InstantiationException
decl||
name|IllegalAccessException
decl||
name|InvocationTargetException
name|e
parameter_list|)
block|{
name|Rethrow
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
DECL|method|newDirectoryImpl
specifier|static
name|Directory
name|newDirectoryImpl
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|clazzName
parameter_list|)
block|{
if|if
condition|(
name|clazzName
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
block|{
if|if
condition|(
name|rarely
argument_list|(
name|random
argument_list|)
condition|)
block|{
name|clazzName
operator|=
name|RandomPicks
operator|.
name|randomFrom
argument_list|(
name|random
argument_list|,
name|CORE_DIRECTORIES
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clazzName
operator|=
literal|"RAMDirectory"
expr_stmt|;
block|}
block|}
try|try
block|{
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Directory
argument_list|>
name|clazz
init|=
name|CommandLineUtil
operator|.
name|loadDirectoryClass
argument_list|(
name|clazzName
argument_list|)
decl_stmt|;
comment|// If it is a FSDirectory type, try its ctor(File)
if|if
condition|(
name|FSDirectory
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|clazz
argument_list|)
condition|)
block|{
specifier|final
name|File
name|dir
init|=
name|TestUtil
operator|.
name|getTempDir
argument_list|(
literal|"index"
argument_list|)
decl_stmt|;
name|dir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
comment|// ensure it's created so we 'have' it.
return|return
name|newFSDirectoryImpl
argument_list|(
name|clazz
operator|.
name|asSubclass
argument_list|(
name|FSDirectory
operator|.
name|class
argument_list|)
argument_list|,
name|dir
argument_list|)
return|;
block|}
comment|// try empty ctor
return|return
name|clazz
operator|.
name|newInstance
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Sometimes wrap the IndexReader as slow, parallel or filter reader (or    * combinations of that)    */
DECL|method|maybeWrapReader
specifier|public
specifier|static
name|IndexReader
name|maybeWrapReader
parameter_list|(
name|IndexReader
name|r
parameter_list|)
throws|throws
name|IOException
block|{
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
if|if
condition|(
name|rarely
argument_list|()
condition|)
block|{
comment|// TODO: remove this, and fix those tests to wrap before putting slow around:
specifier|final
name|boolean
name|wasOriginallyAtomic
init|=
name|r
operator|instanceof
name|AtomicReader
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|c
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|6
argument_list|)
operator|+
literal|1
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|r
operator|=
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|// will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:
name|r
operator|=
operator|(
name|r
operator|instanceof
name|AtomicReader
operator|)
condition|?
operator|new
name|ParallelAtomicReader
argument_list|(
operator|(
name|AtomicReader
operator|)
name|r
argument_list|)
else|:
operator|new
name|ParallelCompositeReader
argument_list|(
operator|(
name|CompositeReader
operator|)
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|// HÃ¤ckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use
comment|// QueryUtils' reader with a fake cache key, so insanity checker cannot walk
comment|// along our reader:
name|r
operator|=
operator|new
name|FCInvisibleMultiReader
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
specifier|final
name|AtomicReader
name|ar
init|=
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|r
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|allFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldInfo
name|fi
range|:
name|ar
operator|.
name|getFieldInfos
argument_list|()
control|)
block|{
name|allFields
operator|.
name|add
argument_list|(
name|fi
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|shuffle
argument_list|(
name|allFields
argument_list|,
name|random
argument_list|)
expr_stmt|;
specifier|final
name|int
name|end
init|=
name|allFields
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|random
operator|.
name|nextInt
argument_list|(
name|allFields
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|fields
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|allFields
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|end
argument_list|)
argument_list|)
decl_stmt|;
comment|// will create no FC insanity as ParallelAtomicReader has own cache key:
name|r
operator|=
operator|new
name|ParallelAtomicReader
argument_list|(
operator|new
name|FieldFilterAtomicReader
argument_list|(
name|ar
argument_list|,
name|fields
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|FieldFilterAtomicReader
argument_list|(
name|ar
argument_list|,
name|fields
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|// HÃ¤ckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use
comment|// QueryUtils' reader with a fake cache key, so insanity checker cannot walk
comment|// along our reader:
if|if
condition|(
name|r
operator|instanceof
name|AtomicReader
condition|)
block|{
name|r
operator|=
operator|new
name|AssertingAtomicReader
argument_list|(
operator|(
name|AtomicReader
operator|)
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|instanceof
name|DirectoryReader
condition|)
block|{
name|r
operator|=
operator|new
name|AssertingDirectoryReader
argument_list|(
operator|(
name|DirectoryReader
operator|)
name|r
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fail
argument_list|(
literal|"should not get here"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wasOriginallyAtomic
condition|)
block|{
name|r
operator|=
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|r
operator|instanceof
name|CompositeReader
operator|)
operator|&&
operator|!
operator|(
name|r
operator|instanceof
name|FCInvisibleMultiReader
operator|)
condition|)
block|{
comment|// prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:
name|r
operator|=
operator|new
name|FCInvisibleMultiReader
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"maybeWrapReader wrapped: "
operator|+
name|r
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|r
return|;
block|}
comment|/** TODO: javadoc */
DECL|method|newIOContext
specifier|public
specifier|static
name|IOContext
name|newIOContext
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
return|return
name|newIOContext
argument_list|(
name|random
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
return|;
block|}
comment|/** TODO: javadoc */
DECL|method|newIOContext
specifier|public
specifier|static
name|IOContext
name|newIOContext
parameter_list|(
name|Random
name|random
parameter_list|,
name|IOContext
name|oldContext
parameter_list|)
block|{
specifier|final
name|int
name|randomNumDocs
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|4192
argument_list|)
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|512
argument_list|)
operator|*
name|randomNumDocs
decl_stmt|;
if|if
condition|(
name|oldContext
operator|.
name|flushInfo
operator|!=
literal|null
condition|)
block|{
comment|// Always return at least the estimatedSegmentSize of
comment|// the incoming IOContext:
return|return
operator|new
name|IOContext
argument_list|(
operator|new
name|FlushInfo
argument_list|(
name|randomNumDocs
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|oldContext
operator|.
name|flushInfo
operator|.
name|estimatedSegmentSize
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|oldContext
operator|.
name|mergeInfo
operator|!=
literal|null
condition|)
block|{
comment|// Always return at least the estimatedMergeBytes of
comment|// the incoming IOContext:
return|return
operator|new
name|IOContext
argument_list|(
operator|new
name|MergeInfo
argument_list|(
name|randomNumDocs
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|oldContext
operator|.
name|mergeInfo
operator|.
name|estimatedMergeBytes
argument_list|,
name|size
argument_list|)
argument_list|,
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|,
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|// Make a totally random IOContext:
specifier|final
name|IOContext
name|context
decl_stmt|;
switch|switch
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|context
operator|=
name|IOContext
operator|.
name|DEFAULT
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|context
operator|=
name|IOContext
operator|.
name|READ
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|context
operator|=
name|IOContext
operator|.
name|READONCE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|context
operator|=
operator|new
name|IOContext
argument_list|(
operator|new
name|MergeInfo
argument_list|(
name|randomNumDocs
argument_list|,
name|size
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|context
operator|=
operator|new
name|IOContext
argument_list|(
operator|new
name|FlushInfo
argument_list|(
name|randomNumDocs
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|context
operator|=
name|IOContext
operator|.
name|DEFAULT
expr_stmt|;
block|}
return|return
name|context
return|;
block|}
block|}
comment|/**    * Create a new searcher over the reader. This searcher might randomly use    * threads.    */
DECL|method|newSearcher
specifier|public
specifier|static
name|IndexSearcher
name|newSearcher
parameter_list|(
name|IndexReader
name|r
parameter_list|)
block|{
return|return
name|newSearcher
argument_list|(
name|r
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Create a new searcher over the reader. This searcher might randomly use    * threads. if<code>maybeWrap</code> is true, this searcher might wrap the    * reader with one that returns null for getSequentialSubReaders.    */
DECL|method|newSearcher
specifier|public
specifier|static
name|IndexSearcher
name|newSearcher
parameter_list|(
name|IndexReader
name|r
parameter_list|,
name|boolean
name|maybeWrap
parameter_list|)
block|{
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
if|if
condition|(
name|usually
argument_list|()
condition|)
block|{
if|if
condition|(
name|maybeWrap
condition|)
block|{
try|try
block|{
name|r
operator|=
name|maybeWrapReader
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|// TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.
comment|// ultimately whatever you do will be checkIndex'd at the end anyway.
if|if
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|500
argument_list|)
operator|==
literal|0
operator|&&
name|r
operator|instanceof
name|AtomicReader
condition|)
block|{
comment|// TODO: not useful to check DirectoryReader (redundant with checkindex)
comment|// but maybe sometimes run this on the other crazy readers maybeWrapReader creates?
try|try
block|{
name|TestUtil
operator|.
name|checkReader
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
name|IndexSearcher
name|ret
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|AssertingIndexSearcher
argument_list|(
name|random
argument_list|,
name|r
argument_list|)
else|:
operator|new
name|AssertingIndexSearcher
argument_list|(
name|random
argument_list|,
name|r
operator|.
name|getContext
argument_list|()
argument_list|)
decl_stmt|;
name|ret
operator|.
name|setSimilarity
argument_list|(
name|classEnvRule
operator|.
name|similarity
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|int
name|threads
init|=
literal|0
decl_stmt|;
specifier|final
name|ThreadPoolExecutor
name|ex
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|ex
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|threads
operator|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ex
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
name|threads
argument_list|,
name|threads
argument_list|,
literal|0L
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|,
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
operator|new
name|NamedThreadFactory
argument_list|(
literal|"LuceneTestCase"
argument_list|)
argument_list|)
expr_stmt|;
comment|// uncomment to intensify LUCENE-3840
comment|// ex.prestartAllCoreThreads();
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"NOTE: newSearcher using ExecutorService with "
operator|+
name|threads
operator|+
literal|" threads"
argument_list|)
expr_stmt|;
block|}
name|r
operator|.
name|addReaderClosedListener
argument_list|(
operator|new
name|ReaderClosedListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onClose
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
block|{
name|TestUtil
operator|.
name|shutdownExecutorService
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|IndexSearcher
name|ret
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|AssertingIndexSearcher
argument_list|(
name|random
argument_list|,
name|r
argument_list|,
name|ex
argument_list|)
else|:
operator|new
name|AssertingIndexSearcher
argument_list|(
name|random
argument_list|,
name|r
operator|.
name|getContext
argument_list|()
argument_list|,
name|ex
argument_list|)
decl_stmt|;
name|ret
operator|.
name|setSimilarity
argument_list|(
name|classEnvRule
operator|.
name|similarity
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
comment|/**    * Gets a resource from the classpath as {@link File}. This method should only    * be used, if a real file is needed. To get a stream, code should prefer    * {@link Class#getResourceAsStream} using {@code this.getClass()}.    */
DECL|method|getDataFile
specifier|protected
name|File
name|getDataFile
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
operator|new
name|File
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getResource
argument_list|(
name|name
argument_list|)
operator|.
name|toURI
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot find resource: "
operator|+
name|name
argument_list|)
throw|;
block|}
block|}
comment|/** Returns true if the default codec supports single valued docvalues with missing values */
DECL|method|defaultCodecSupportsMissingDocValues
specifier|public
specifier|static
name|boolean
name|defaultCodecSupportsMissingDocValues
parameter_list|()
block|{
name|String
name|name
init|=
name|Codec
operator|.
name|getDefault
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"Lucene3x"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"Lucene40"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"Appending"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"Lucene41"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"Lucene42"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Returns true if the default codec supports SORTED_SET docvalues */
DECL|method|defaultCodecSupportsSortedSet
specifier|public
specifier|static
name|boolean
name|defaultCodecSupportsSortedSet
parameter_list|()
block|{
name|String
name|name
init|=
name|Codec
operator|.
name|getDefault
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"Lucene40"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"Lucene41"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Returns true if the codec "supports" docsWithField     * (other codecs return MatchAllBits, because you couldnt write missing values before) */
DECL|method|defaultCodecSupportsDocsWithField
specifier|public
specifier|static
name|boolean
name|defaultCodecSupportsDocsWithField
parameter_list|()
block|{
name|String
name|name
init|=
name|Codec
operator|.
name|getDefault
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"Lucene40"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"Lucene41"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"Lucene42"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Returns true if the codec "supports" field updates. */
DECL|method|defaultCodecSupportsFieldUpdates
specifier|public
specifier|static
name|boolean
name|defaultCodecSupportsFieldUpdates
parameter_list|()
block|{
name|String
name|name
init|=
name|Codec
operator|.
name|getDefault
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"Lucene40"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"Lucene41"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"Lucene42"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"Lucene45"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|assertReaderEquals
specifier|public
name|void
name|assertReaderEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|IndexReader
name|rightReader
parameter_list|)
throws|throws
name|IOException
block|{
name|assertReaderStatisticsEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|rightReader
argument_list|)
expr_stmt|;
name|assertFieldsEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|MultiFields
operator|.
name|getFields
argument_list|(
name|leftReader
argument_list|)
argument_list|,
name|MultiFields
operator|.
name|getFields
argument_list|(
name|rightReader
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertNormsEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|rightReader
argument_list|)
expr_stmt|;
name|assertStoredFieldsEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|rightReader
argument_list|)
expr_stmt|;
name|assertTermVectorsEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|rightReader
argument_list|)
expr_stmt|;
name|assertDocValuesEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|rightReader
argument_list|)
expr_stmt|;
name|assertDeletedDocsEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|rightReader
argument_list|)
expr_stmt|;
name|assertFieldInfosEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|rightReader
argument_list|)
expr_stmt|;
block|}
comment|/**     * checks that reader-level statistics are the same     */
DECL|method|assertReaderStatisticsEquals
specifier|public
name|void
name|assertReaderStatisticsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|IndexReader
name|rightReader
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Somewhat redundant: we never delete docs
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftReader
operator|.
name|maxDoc
argument_list|()
argument_list|,
name|rightReader
operator|.
name|maxDoc
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftReader
operator|.
name|numDocs
argument_list|()
argument_list|,
name|rightReader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftReader
operator|.
name|numDeletedDocs
argument_list|()
argument_list|,
name|rightReader
operator|.
name|numDeletedDocs
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftReader
operator|.
name|hasDeletions
argument_list|()
argument_list|,
name|rightReader
operator|.
name|hasDeletions
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**     * Fields api equivalency     */
DECL|method|assertFieldsEquals
specifier|public
name|void
name|assertFieldsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|Fields
name|leftFields
parameter_list|,
name|Fields
name|rightFields
parameter_list|,
name|boolean
name|deep
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Fields could be null if there are no postings,
comment|// but then it must be null for both
if|if
condition|(
name|leftFields
operator|==
literal|null
operator|||
name|rightFields
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftFields
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightFields
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertFieldStatisticsEquals
argument_list|(
name|info
argument_list|,
name|leftFields
argument_list|,
name|rightFields
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|leftEnum
init|=
name|leftFields
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|rightEnum
init|=
name|rightFields
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|leftEnum
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|field
init|=
name|leftEnum
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|field
argument_list|,
name|rightEnum
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertTermsEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftFields
operator|.
name|terms
argument_list|(
name|field
argument_list|)
argument_list|,
name|rightFields
operator|.
name|terms
argument_list|(
name|field
argument_list|)
argument_list|,
name|deep
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|rightEnum
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**     * checks that top-level statistics on Fields are the same     */
DECL|method|assertFieldStatisticsEquals
specifier|public
name|void
name|assertFieldStatisticsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|Fields
name|leftFields
parameter_list|,
name|Fields
name|rightFields
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|leftFields
operator|.
name|size
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|rightFields
operator|.
name|size
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftFields
operator|.
name|size
argument_list|()
argument_list|,
name|rightFields
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Terms api equivalency     */
DECL|method|assertTermsEquals
specifier|public
name|void
name|assertTermsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|Terms
name|leftTerms
parameter_list|,
name|Terms
name|rightTerms
parameter_list|,
name|boolean
name|deep
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|leftTerms
operator|==
literal|null
operator|||
name|rightTerms
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftTerms
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightTerms
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertTermsStatisticsEquals
argument_list|(
name|info
argument_list|,
name|leftTerms
argument_list|,
name|rightTerms
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|leftTerms
operator|.
name|hasOffsets
argument_list|()
argument_list|,
name|rightTerms
operator|.
name|hasOffsets
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|leftTerms
operator|.
name|hasPositions
argument_list|()
argument_list|,
name|rightTerms
operator|.
name|hasPositions
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|leftTerms
operator|.
name|hasPayloads
argument_list|()
argument_list|,
name|rightTerms
operator|.
name|hasPayloads
argument_list|()
argument_list|)
expr_stmt|;
name|TermsEnum
name|leftTermsEnum
init|=
name|leftTerms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|TermsEnum
name|rightTermsEnum
init|=
name|rightTerms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|assertTermsEnumEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftTermsEnum
argument_list|,
name|rightTermsEnum
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertTermsSeekingEquals
argument_list|(
name|info
argument_list|,
name|leftTerms
argument_list|,
name|rightTerms
argument_list|)
expr_stmt|;
if|if
condition|(
name|deep
condition|)
block|{
name|int
name|numIntersections
init|=
name|atLeast
argument_list|(
literal|3
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIntersections
condition|;
name|i
operator|++
control|)
block|{
name|String
name|re
init|=
name|AutomatonTestUtil
operator|.
name|randomRegexp
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|CompiledAutomaton
name|automaton
init|=
operator|new
name|CompiledAutomaton
argument_list|(
operator|new
name|RegExp
argument_list|(
name|re
argument_list|,
name|RegExp
operator|.
name|NONE
argument_list|)
operator|.
name|toAutomaton
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|automaton
operator|.
name|type
operator|==
name|CompiledAutomaton
operator|.
name|AUTOMATON_TYPE
operator|.
name|NORMAL
condition|)
block|{
comment|// TODO: test start term too
name|TermsEnum
name|leftIntersection
init|=
name|leftTerms
operator|.
name|intersect
argument_list|(
name|automaton
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|TermsEnum
name|rightIntersection
init|=
name|rightTerms
operator|.
name|intersect
argument_list|(
name|automaton
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTermsEnumEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftIntersection
argument_list|,
name|rightIntersection
argument_list|,
name|rarely
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**     * checks collection-level statistics on Terms     */
DECL|method|assertTermsStatisticsEquals
specifier|public
name|void
name|assertTermsStatisticsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|Terms
name|leftTerms
parameter_list|,
name|Terms
name|rightTerms
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|leftTerms
operator|.
name|getDocCount
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|rightTerms
operator|.
name|getDocCount
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftTerms
operator|.
name|getDocCount
argument_list|()
argument_list|,
name|rightTerms
operator|.
name|getDocCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|leftTerms
operator|.
name|getSumDocFreq
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|rightTerms
operator|.
name|getSumDocFreq
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftTerms
operator|.
name|getSumDocFreq
argument_list|()
argument_list|,
name|rightTerms
operator|.
name|getSumDocFreq
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|leftTerms
operator|.
name|getSumTotalTermFreq
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|rightTerms
operator|.
name|getSumTotalTermFreq
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftTerms
operator|.
name|getSumTotalTermFreq
argument_list|()
argument_list|,
name|rightTerms
operator|.
name|getSumTotalTermFreq
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|leftTerms
operator|.
name|size
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|rightTerms
operator|.
name|size
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftTerms
operator|.
name|size
argument_list|()
argument_list|,
name|rightTerms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|RandomBits
specifier|private
specifier|static
class|class
name|RandomBits
implements|implements
name|Bits
block|{
DECL|field|bits
name|FixedBitSet
name|bits
decl_stmt|;
DECL|method|RandomBits
name|RandomBits
parameter_list|(
name|int
name|maxDoc
parameter_list|,
name|double
name|pctLive
parameter_list|,
name|Random
name|random
parameter_list|)
block|{
name|bits
operator|=
operator|new
name|FixedBitSet
argument_list|(
name|maxDoc
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxDoc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|random
operator|.
name|nextDouble
argument_list|()
operator|<=
name|pctLive
condition|)
block|{
name|bits
operator|.
name|set
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|get
specifier|public
name|boolean
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|bits
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|length
specifier|public
name|int
name|length
parameter_list|()
block|{
return|return
name|bits
operator|.
name|length
argument_list|()
return|;
block|}
block|}
comment|/**     * checks the terms enum sequentially    * if deep is false, it does a 'shallow' test that doesnt go down to the docsenums    */
DECL|method|assertTermsEnumEquals
specifier|public
name|void
name|assertTermsEnumEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|TermsEnum
name|leftTermsEnum
parameter_list|,
name|TermsEnum
name|rightTermsEnum
parameter_list|,
name|boolean
name|deep
parameter_list|)
throws|throws
name|IOException
block|{
name|BytesRef
name|term
decl_stmt|;
name|Bits
name|randomBits
init|=
operator|new
name|RandomBits
argument_list|(
name|leftReader
operator|.
name|maxDoc
argument_list|()
argument_list|,
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
argument_list|,
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|DocsAndPositionsEnum
name|leftPositions
init|=
literal|null
decl_stmt|;
name|DocsAndPositionsEnum
name|rightPositions
init|=
literal|null
decl_stmt|;
name|DocsEnum
name|leftDocs
init|=
literal|null
decl_stmt|;
name|DocsEnum
name|rightDocs
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|term
operator|=
name|leftTermsEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|term
argument_list|,
name|rightTermsEnum
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertTermStatsEquals
argument_list|(
name|info
argument_list|,
name|leftTermsEnum
argument_list|,
name|rightTermsEnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|deep
condition|)
block|{
name|assertDocsAndPositionsEnumEquals
argument_list|(
name|info
argument_list|,
name|leftPositions
operator|=
name|leftTermsEnum
operator|.
name|docsAndPositions
argument_list|(
literal|null
argument_list|,
name|leftPositions
argument_list|)
argument_list|,
name|rightPositions
operator|=
name|rightTermsEnum
operator|.
name|docsAndPositions
argument_list|(
literal|null
argument_list|,
name|rightPositions
argument_list|)
argument_list|)
expr_stmt|;
name|assertDocsAndPositionsEnumEquals
argument_list|(
name|info
argument_list|,
name|leftPositions
operator|=
name|leftTermsEnum
operator|.
name|docsAndPositions
argument_list|(
name|randomBits
argument_list|,
name|leftPositions
argument_list|)
argument_list|,
name|rightPositions
operator|=
name|rightTermsEnum
operator|.
name|docsAndPositions
argument_list|(
name|randomBits
argument_list|,
name|rightPositions
argument_list|)
argument_list|)
expr_stmt|;
name|assertPositionsSkippingEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftTermsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|leftPositions
operator|=
name|leftTermsEnum
operator|.
name|docsAndPositions
argument_list|(
literal|null
argument_list|,
name|leftPositions
argument_list|)
argument_list|,
name|rightPositions
operator|=
name|rightTermsEnum
operator|.
name|docsAndPositions
argument_list|(
literal|null
argument_list|,
name|rightPositions
argument_list|)
argument_list|)
expr_stmt|;
name|assertPositionsSkippingEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftTermsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|leftPositions
operator|=
name|leftTermsEnum
operator|.
name|docsAndPositions
argument_list|(
name|randomBits
argument_list|,
name|leftPositions
argument_list|)
argument_list|,
name|rightPositions
operator|=
name|rightTermsEnum
operator|.
name|docsAndPositions
argument_list|(
name|randomBits
argument_list|,
name|rightPositions
argument_list|)
argument_list|)
expr_stmt|;
comment|// with freqs:
name|assertDocsEnumEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|=
name|leftTermsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|leftDocs
argument_list|)
argument_list|,
name|rightDocs
operator|=
name|rightTermsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|rightDocs
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertDocsEnumEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|=
name|leftTermsEnum
operator|.
name|docs
argument_list|(
name|randomBits
argument_list|,
name|leftDocs
argument_list|)
argument_list|,
name|rightDocs
operator|=
name|rightTermsEnum
operator|.
name|docs
argument_list|(
name|randomBits
argument_list|,
name|rightDocs
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// w/o freqs:
name|assertDocsEnumEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|=
name|leftTermsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|leftDocs
argument_list|,
name|DocsEnum
operator|.
name|FLAG_NONE
argument_list|)
argument_list|,
name|rightDocs
operator|=
name|rightTermsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|rightDocs
argument_list|,
name|DocsEnum
operator|.
name|FLAG_NONE
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertDocsEnumEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|=
name|leftTermsEnum
operator|.
name|docs
argument_list|(
name|randomBits
argument_list|,
name|leftDocs
argument_list|,
name|DocsEnum
operator|.
name|FLAG_NONE
argument_list|)
argument_list|,
name|rightDocs
operator|=
name|rightTermsEnum
operator|.
name|docs
argument_list|(
name|randomBits
argument_list|,
name|rightDocs
argument_list|,
name|DocsEnum
operator|.
name|FLAG_NONE
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// with freqs:
name|assertDocsSkippingEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftTermsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|leftDocs
operator|=
name|leftTermsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|leftDocs
argument_list|)
argument_list|,
name|rightDocs
operator|=
name|rightTermsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|rightDocs
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertDocsSkippingEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftTermsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|leftDocs
operator|=
name|leftTermsEnum
operator|.
name|docs
argument_list|(
name|randomBits
argument_list|,
name|leftDocs
argument_list|)
argument_list|,
name|rightDocs
operator|=
name|rightTermsEnum
operator|.
name|docs
argument_list|(
name|randomBits
argument_list|,
name|rightDocs
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// w/o freqs:
name|assertDocsSkippingEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftTermsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|leftDocs
operator|=
name|leftTermsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|leftDocs
argument_list|,
name|DocsEnum
operator|.
name|FLAG_NONE
argument_list|)
argument_list|,
name|rightDocs
operator|=
name|rightTermsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|rightDocs
argument_list|,
name|DocsEnum
operator|.
name|FLAG_NONE
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertDocsSkippingEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftTermsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|leftDocs
operator|=
name|leftTermsEnum
operator|.
name|docs
argument_list|(
name|randomBits
argument_list|,
name|leftDocs
argument_list|,
name|DocsEnum
operator|.
name|FLAG_NONE
argument_list|)
argument_list|,
name|rightDocs
operator|=
name|rightTermsEnum
operator|.
name|docs
argument_list|(
name|randomBits
argument_list|,
name|rightDocs
argument_list|,
name|DocsEnum
operator|.
name|FLAG_NONE
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightTermsEnum
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * checks docs + freqs + positions + payloads, sequentially    */
DECL|method|assertDocsAndPositionsEnumEquals
specifier|public
name|void
name|assertDocsAndPositionsEnumEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|DocsAndPositionsEnum
name|leftDocs
parameter_list|,
name|DocsAndPositionsEnum
name|rightDocs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|leftDocs
operator|==
literal|null
operator|||
name|rightDocs
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|leftDocs
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|rightDocs
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertEquals
argument_list|(
name|info
argument_list|,
operator|-
literal|1
argument_list|,
name|leftDocs
operator|.
name|docID
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
operator|-
literal|1
argument_list|,
name|rightDocs
operator|.
name|docID
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|docid
decl_stmt|;
while|while
condition|(
operator|(
name|docid
operator|=
name|leftDocs
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|docid
argument_list|,
name|rightDocs
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|freq
init|=
name|leftDocs
operator|.
name|freq
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|freq
argument_list|,
name|rightDocs
operator|.
name|freq
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|freq
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|.
name|nextPosition
argument_list|()
argument_list|,
name|rightDocs
operator|.
name|nextPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|.
name|getPayload
argument_list|()
argument_list|,
name|rightDocs
operator|.
name|getPayload
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|.
name|startOffset
argument_list|()
argument_list|,
name|rightDocs
operator|.
name|startOffset
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|.
name|endOffset
argument_list|()
argument_list|,
name|rightDocs
operator|.
name|endOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
name|info
argument_list|,
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
argument_list|,
name|rightDocs
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * checks docs + freqs, sequentially    */
DECL|method|assertDocsEnumEquals
specifier|public
name|void
name|assertDocsEnumEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|DocsEnum
name|leftDocs
parameter_list|,
name|DocsEnum
name|rightDocs
parameter_list|,
name|boolean
name|hasFreqs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|leftDocs
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|rightDocs
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertEquals
argument_list|(
name|info
argument_list|,
operator|-
literal|1
argument_list|,
name|leftDocs
operator|.
name|docID
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
operator|-
literal|1
argument_list|,
name|rightDocs
operator|.
name|docID
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|docid
decl_stmt|;
while|while
condition|(
operator|(
name|docid
operator|=
name|leftDocs
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|docid
argument_list|,
name|rightDocs
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasFreqs
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|.
name|freq
argument_list|()
argument_list|,
name|rightDocs
operator|.
name|freq
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
name|info
argument_list|,
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
argument_list|,
name|rightDocs
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * checks advancing docs    */
DECL|method|assertDocsSkippingEquals
specifier|public
name|void
name|assertDocsSkippingEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|int
name|docFreq
parameter_list|,
name|DocsEnum
name|leftDocs
parameter_list|,
name|DocsEnum
name|rightDocs
parameter_list|,
name|boolean
name|hasFreqs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|leftDocs
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|rightDocs
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|docid
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|averageGap
init|=
name|leftReader
operator|.
name|maxDoc
argument_list|()
operator|/
operator|(
literal|1
operator|+
name|docFreq
operator|)
decl_stmt|;
name|int
name|skipInterval
init|=
literal|16
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// nextDoc()
name|docid
operator|=
name|leftDocs
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|docid
argument_list|,
name|rightDocs
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// advance()
name|int
name|skip
init|=
name|docid
operator|+
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|skipInterval
operator|+
name|random
argument_list|()
operator|.
name|nextGaussian
argument_list|()
operator|*
name|averageGap
argument_list|)
argument_list|)
decl_stmt|;
name|docid
operator|=
name|leftDocs
operator|.
name|advance
argument_list|(
name|skip
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|docid
argument_list|,
name|rightDocs
operator|.
name|advance
argument_list|(
name|skip
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|docid
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|hasFreqs
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|.
name|freq
argument_list|()
argument_list|,
name|rightDocs
operator|.
name|freq
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * checks advancing docs + positions    */
DECL|method|assertPositionsSkippingEquals
specifier|public
name|void
name|assertPositionsSkippingEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|int
name|docFreq
parameter_list|,
name|DocsAndPositionsEnum
name|leftDocs
parameter_list|,
name|DocsAndPositionsEnum
name|rightDocs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|leftDocs
operator|==
literal|null
operator|||
name|rightDocs
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|leftDocs
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|rightDocs
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|docid
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|averageGap
init|=
name|leftReader
operator|.
name|maxDoc
argument_list|()
operator|/
operator|(
literal|1
operator|+
name|docFreq
operator|)
decl_stmt|;
name|int
name|skipInterval
init|=
literal|16
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// nextDoc()
name|docid
operator|=
name|leftDocs
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|docid
argument_list|,
name|rightDocs
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// advance()
name|int
name|skip
init|=
name|docid
operator|+
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|skipInterval
operator|+
name|random
argument_list|()
operator|.
name|nextGaussian
argument_list|()
operator|*
name|averageGap
argument_list|)
argument_list|)
decl_stmt|;
name|docid
operator|=
name|leftDocs
operator|.
name|advance
argument_list|(
name|skip
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|docid
argument_list|,
name|rightDocs
operator|.
name|advance
argument_list|(
name|skip
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|docid
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
return|return;
block|}
name|int
name|freq
init|=
name|leftDocs
operator|.
name|freq
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|freq
argument_list|,
name|rightDocs
operator|.
name|freq
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|freq
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|.
name|nextPosition
argument_list|()
argument_list|,
name|rightDocs
operator|.
name|nextPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|.
name|getPayload
argument_list|()
argument_list|,
name|rightDocs
operator|.
name|getPayload
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|assertTermsSeekingEquals
specifier|private
name|void
name|assertTermsSeekingEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|Terms
name|leftTerms
parameter_list|,
name|Terms
name|rightTerms
parameter_list|)
throws|throws
name|IOException
block|{
name|TermsEnum
name|leftEnum
init|=
literal|null
decl_stmt|;
name|TermsEnum
name|rightEnum
init|=
literal|null
decl_stmt|;
comment|// just an upper bound
name|int
name|numTests
init|=
name|atLeast
argument_list|(
literal|20
argument_list|)
decl_stmt|;
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
comment|// collect this number of terms from the left side
name|HashSet
argument_list|<
name|BytesRef
argument_list|>
name|tests
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|numPasses
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|numPasses
operator|<
literal|10
operator|&&
name|tests
operator|.
name|size
argument_list|()
operator|<
name|numTests
condition|)
block|{
name|leftEnum
operator|=
name|leftTerms
operator|.
name|iterator
argument_list|(
name|leftEnum
argument_list|)
expr_stmt|;
name|BytesRef
name|term
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|term
operator|=
name|leftEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|code
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
block|{
comment|// the term
name|tests
operator|.
name|add
argument_list|(
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|1
condition|)
block|{
comment|// truncated subsequence of term
name|term
operator|=
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// truncate it
name|term
operator|.
name|length
operator|=
name|random
operator|.
name|nextInt
argument_list|(
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|2
condition|)
block|{
comment|// term, but ensure a non-zero offset
name|byte
name|newbytes
index|[]
init|=
operator|new
name|byte
index|[
name|term
operator|.
name|length
operator|+
literal|5
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|term
operator|.
name|offset
argument_list|,
name|newbytes
argument_list|,
literal|5
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
name|tests
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|newbytes
argument_list|,
literal|5
argument_list|,
name|term
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|3
condition|)
block|{
switch|switch
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|tests
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|()
argument_list|)
expr_stmt|;
comment|// before the first term
break|break;
case|case
literal|1
case|:
name|tests
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|(
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
literal|0xFF
block|,
operator|(
name|byte
operator|)
literal|0xFF
block|}
argument_list|)
argument_list|)
expr_stmt|;
comment|// past the last term
break|break;
case|case
literal|2
case|:
name|tests
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// random term
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
block|}
name|numPasses
operator|++
expr_stmt|;
block|}
name|rightEnum
operator|=
name|rightTerms
operator|.
name|iterator
argument_list|(
name|rightEnum
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|BytesRef
argument_list|>
name|shuffledTests
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|tests
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|shuffledTests
argument_list|,
name|random
argument_list|)
expr_stmt|;
for|for
control|(
name|BytesRef
name|b
range|:
name|shuffledTests
control|)
block|{
if|if
condition|(
name|rarely
argument_list|()
condition|)
block|{
comment|// reuse the enums
name|leftEnum
operator|=
name|leftTerms
operator|.
name|iterator
argument_list|(
name|leftEnum
argument_list|)
expr_stmt|;
name|rightEnum
operator|=
name|rightTerms
operator|.
name|iterator
argument_list|(
name|rightEnum
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|seekExact
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|seekExact
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftEnum
operator|.
name|seekExact
argument_list|(
name|b
argument_list|)
argument_list|,
name|rightEnum
operator|.
name|seekExact
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SeekStatus
name|leftStatus
init|=
name|leftEnum
operator|.
name|seekCeil
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|SeekStatus
name|rightStatus
init|=
name|rightEnum
operator|.
name|seekCeil
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftStatus
argument_list|,
name|rightStatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftStatus
operator|!=
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftEnum
operator|.
name|term
argument_list|()
argument_list|,
name|rightEnum
operator|.
name|term
argument_list|()
argument_list|)
expr_stmt|;
name|assertTermStatsEquals
argument_list|(
name|info
argument_list|,
name|leftEnum
argument_list|,
name|rightEnum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * checks term-level statistics    */
DECL|method|assertTermStatsEquals
specifier|public
name|void
name|assertTermStatsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|TermsEnum
name|leftTermsEnum
parameter_list|,
name|TermsEnum
name|rightTermsEnum
parameter_list|)
throws|throws
name|IOException
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftTermsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|rightTermsEnum
operator|.
name|docFreq
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftTermsEnum
operator|.
name|totalTermFreq
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|rightTermsEnum
operator|.
name|totalTermFreq
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftTermsEnum
operator|.
name|totalTermFreq
argument_list|()
argument_list|,
name|rightTermsEnum
operator|.
name|totalTermFreq
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * checks that norms are the same across all fields     */
DECL|method|assertNormsEquals
specifier|public
name|void
name|assertNormsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|IndexReader
name|rightReader
parameter_list|)
throws|throws
name|IOException
block|{
name|Fields
name|leftFields
init|=
name|MultiFields
operator|.
name|getFields
argument_list|(
name|leftReader
argument_list|)
decl_stmt|;
name|Fields
name|rightFields
init|=
name|MultiFields
operator|.
name|getFields
argument_list|(
name|rightReader
argument_list|)
decl_stmt|;
comment|// Fields could be null if there are no postings,
comment|// but then it must be null for both
if|if
condition|(
name|leftFields
operator|==
literal|null
operator|||
name|rightFields
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftFields
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightFields
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|String
name|field
range|:
name|leftFields
control|)
block|{
name|NumericDocValues
name|leftNorms
init|=
name|MultiDocValues
operator|.
name|getNormValues
argument_list|(
name|leftReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|NumericDocValues
name|rightNorms
init|=
name|MultiDocValues
operator|.
name|getNormValues
argument_list|(
name|rightReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftNorms
operator|!=
literal|null
operator|&&
name|rightNorms
operator|!=
literal|null
condition|)
block|{
name|assertDocValuesEquals
argument_list|(
name|info
argument_list|,
name|leftReader
operator|.
name|maxDoc
argument_list|()
argument_list|,
name|leftNorms
argument_list|,
name|rightNorms
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftNorms
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightNorms
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**     * checks that stored fields of all documents are the same     */
DECL|method|assertStoredFieldsEquals
specifier|public
name|void
name|assertStoredFieldsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|IndexReader
name|rightReader
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|leftReader
operator|.
name|maxDoc
argument_list|()
operator|==
name|rightReader
operator|.
name|maxDoc
argument_list|()
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftReader
operator|.
name|maxDoc
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|StoredDocument
name|leftDoc
init|=
name|leftReader
operator|.
name|document
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|StoredDocument
name|rightDoc
init|=
name|rightReader
operator|.
name|document
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// TODO: I think this is bogus because we don't document what the order should be
comment|// from these iterators, etc. I think the codec/IndexReader should be free to order this stuff
comment|// in whatever way it wants (e.g. maybe it packs related fields together or something)
comment|// To fix this, we sort the fields in both documents by name, but
comment|// we still assume that all instances with same name are in order:
name|Comparator
argument_list|<
name|StorableField
argument_list|>
name|comp
init|=
operator|new
name|Comparator
argument_list|<
name|StorableField
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|StorableField
name|arg0
parameter_list|,
name|StorableField
name|arg1
parameter_list|)
block|{
return|return
name|arg0
operator|.
name|name
argument_list|()
operator|.
name|compareTo
argument_list|(
name|arg1
operator|.
name|name
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|leftDoc
operator|.
name|getFields
argument_list|()
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|rightDoc
operator|.
name|getFields
argument_list|()
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|StorableField
argument_list|>
name|leftIterator
init|=
name|leftDoc
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|StorableField
argument_list|>
name|rightIterator
init|=
name|rightDoc
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|leftIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|assertTrue
argument_list|(
name|info
argument_list|,
name|rightIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertStoredFieldEquals
argument_list|(
name|info
argument_list|,
name|leftIterator
operator|.
name|next
argument_list|()
argument_list|,
name|rightIterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|info
argument_list|,
name|rightIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * checks that two stored fields are equivalent     */
DECL|method|assertStoredFieldEquals
specifier|public
name|void
name|assertStoredFieldEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|StorableField
name|leftField
parameter_list|,
name|StorableField
name|rightField
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftField
operator|.
name|name
argument_list|()
argument_list|,
name|rightField
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftField
operator|.
name|binaryValue
argument_list|()
argument_list|,
name|rightField
operator|.
name|binaryValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftField
operator|.
name|stringValue
argument_list|()
argument_list|,
name|rightField
operator|.
name|stringValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftField
operator|.
name|numericValue
argument_list|()
argument_list|,
name|rightField
operator|.
name|numericValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: should we check the FT at all?
block|}
comment|/**     * checks that term vectors across all fields are equivalent     */
DECL|method|assertTermVectorsEquals
specifier|public
name|void
name|assertTermVectorsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|IndexReader
name|rightReader
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|leftReader
operator|.
name|maxDoc
argument_list|()
operator|==
name|rightReader
operator|.
name|maxDoc
argument_list|()
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftReader
operator|.
name|maxDoc
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Fields
name|leftFields
init|=
name|leftReader
operator|.
name|getTermVectors
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Fields
name|rightFields
init|=
name|rightReader
operator|.
name|getTermVectors
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|assertFieldsEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftFields
argument_list|,
name|rightFields
argument_list|,
name|rarely
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getDVFields
specifier|private
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|getDVFields
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|fields
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldInfo
name|fi
range|:
name|MultiFields
operator|.
name|getMergedFieldInfos
argument_list|(
name|reader
argument_list|)
control|)
block|{
if|if
condition|(
name|fi
operator|.
name|hasDocValues
argument_list|()
condition|)
block|{
name|fields
operator|.
name|add
argument_list|(
name|fi
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fields
return|;
block|}
comment|/**    * checks that docvalues across all fields are equivalent    */
DECL|method|assertDocValuesEquals
specifier|public
name|void
name|assertDocValuesEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|IndexReader
name|rightReader
parameter_list|)
throws|throws
name|IOException
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|leftFields
init|=
name|getDVFields
argument_list|(
name|leftReader
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|rightFields
init|=
name|getDVFields
argument_list|(
name|rightReader
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftFields
argument_list|,
name|rightFields
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|field
range|:
name|leftFields
control|)
block|{
comment|// TODO: clean this up... very messy
block|{
name|NumericDocValues
name|leftValues
init|=
name|MultiDocValues
operator|.
name|getNumericValues
argument_list|(
name|leftReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|NumericDocValues
name|rightValues
init|=
name|MultiDocValues
operator|.
name|getNumericValues
argument_list|(
name|rightReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftValues
operator|!=
literal|null
operator|&&
name|rightValues
operator|!=
literal|null
condition|)
block|{
name|assertDocValuesEquals
argument_list|(
name|info
argument_list|,
name|leftReader
operator|.
name|maxDoc
argument_list|()
argument_list|,
name|leftValues
argument_list|,
name|rightValues
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftValues
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightValues
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|BinaryDocValues
name|leftValues
init|=
name|MultiDocValues
operator|.
name|getBinaryValues
argument_list|(
name|leftReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|BinaryDocValues
name|rightValues
init|=
name|MultiDocValues
operator|.
name|getBinaryValues
argument_list|(
name|rightReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftValues
operator|!=
literal|null
operator|&&
name|rightValues
operator|!=
literal|null
condition|)
block|{
name|BytesRef
name|scratchLeft
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|BytesRef
name|scratchRight
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|docID
init|=
literal|0
init|;
name|docID
operator|<
name|leftReader
operator|.
name|maxDoc
argument_list|()
condition|;
name|docID
operator|++
control|)
block|{
name|leftValues
operator|.
name|get
argument_list|(
name|docID
argument_list|,
name|scratchLeft
argument_list|)
expr_stmt|;
name|rightValues
operator|.
name|get
argument_list|(
name|docID
argument_list|,
name|scratchRight
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|scratchLeft
argument_list|,
name|scratchRight
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftValues
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightValues
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|SortedDocValues
name|leftValues
init|=
name|MultiDocValues
operator|.
name|getSortedValues
argument_list|(
name|leftReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|SortedDocValues
name|rightValues
init|=
name|MultiDocValues
operator|.
name|getSortedValues
argument_list|(
name|rightReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftValues
operator|!=
literal|null
operator|&&
name|rightValues
operator|!=
literal|null
condition|)
block|{
comment|// numOrds
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftValues
operator|.
name|getValueCount
argument_list|()
argument_list|,
name|rightValues
operator|.
name|getValueCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// ords
name|BytesRef
name|scratchLeft
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|BytesRef
name|scratchRight
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftValues
operator|.
name|getValueCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|leftValues
operator|.
name|lookupOrd
argument_list|(
name|i
argument_list|,
name|scratchLeft
argument_list|)
expr_stmt|;
name|rightValues
operator|.
name|lookupOrd
argument_list|(
name|i
argument_list|,
name|scratchRight
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|scratchLeft
argument_list|,
name|scratchRight
argument_list|)
expr_stmt|;
block|}
comment|// bytes
for|for
control|(
name|int
name|docID
init|=
literal|0
init|;
name|docID
operator|<
name|leftReader
operator|.
name|maxDoc
argument_list|()
condition|;
name|docID
operator|++
control|)
block|{
name|leftValues
operator|.
name|get
argument_list|(
name|docID
argument_list|,
name|scratchLeft
argument_list|)
expr_stmt|;
name|rightValues
operator|.
name|get
argument_list|(
name|docID
argument_list|,
name|scratchRight
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|scratchLeft
argument_list|,
name|scratchRight
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftValues
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightValues
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|SortedSetDocValues
name|leftValues
init|=
name|MultiDocValues
operator|.
name|getSortedSetValues
argument_list|(
name|leftReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|SortedSetDocValues
name|rightValues
init|=
name|MultiDocValues
operator|.
name|getSortedSetValues
argument_list|(
name|rightReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftValues
operator|!=
literal|null
operator|&&
name|rightValues
operator|!=
literal|null
condition|)
block|{
comment|// numOrds
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftValues
operator|.
name|getValueCount
argument_list|()
argument_list|,
name|rightValues
operator|.
name|getValueCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// ords
name|BytesRef
name|scratchLeft
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|BytesRef
name|scratchRight
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftValues
operator|.
name|getValueCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|leftValues
operator|.
name|lookupOrd
argument_list|(
name|i
argument_list|,
name|scratchLeft
argument_list|)
expr_stmt|;
name|rightValues
operator|.
name|lookupOrd
argument_list|(
name|i
argument_list|,
name|scratchRight
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|scratchLeft
argument_list|,
name|scratchRight
argument_list|)
expr_stmt|;
block|}
comment|// ord lists
for|for
control|(
name|int
name|docID
init|=
literal|0
init|;
name|docID
operator|<
name|leftReader
operator|.
name|maxDoc
argument_list|()
condition|;
name|docID
operator|++
control|)
block|{
name|leftValues
operator|.
name|setDocument
argument_list|(
name|docID
argument_list|)
expr_stmt|;
name|rightValues
operator|.
name|setDocument
argument_list|(
name|docID
argument_list|)
expr_stmt|;
name|long
name|ord
decl_stmt|;
while|while
condition|(
operator|(
name|ord
operator|=
name|leftValues
operator|.
name|nextOrd
argument_list|()
operator|)
operator|!=
name|SortedSetDocValues
operator|.
name|NO_MORE_ORDS
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|ord
argument_list|,
name|rightValues
operator|.
name|nextOrd
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|info
argument_list|,
name|SortedSetDocValues
operator|.
name|NO_MORE_ORDS
argument_list|,
name|rightValues
operator|.
name|nextOrd
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftValues
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightValues
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|Bits
name|leftBits
init|=
name|MultiDocValues
operator|.
name|getDocsWithField
argument_list|(
name|leftReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|Bits
name|rightBits
init|=
name|MultiDocValues
operator|.
name|getDocsWithField
argument_list|(
name|rightReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftBits
operator|!=
literal|null
operator|&&
name|rightBits
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftBits
operator|.
name|length
argument_list|()
argument_list|,
name|rightBits
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftBits
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftBits
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|rightBits
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftBits
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightBits
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|assertDocValuesEquals
specifier|public
name|void
name|assertDocValuesEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|int
name|num
parameter_list|,
name|NumericDocValues
name|leftDocValues
parameter_list|,
name|NumericDocValues
name|rightDocValues
parameter_list|)
throws|throws
name|IOException
block|{
name|assertNotNull
argument_list|(
name|info
argument_list|,
name|leftDocValues
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|info
argument_list|,
name|rightDocValues
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|docID
init|=
literal|0
init|;
name|docID
operator|<
name|num
condition|;
name|docID
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|leftDocValues
operator|.
name|get
argument_list|(
name|docID
argument_list|)
argument_list|,
name|rightDocValues
operator|.
name|get
argument_list|(
name|docID
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: this is kinda stupid, we don't delete documents in the test.
DECL|method|assertDeletedDocsEquals
specifier|public
name|void
name|assertDeletedDocsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|IndexReader
name|rightReader
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|leftReader
operator|.
name|numDeletedDocs
argument_list|()
operator|==
name|rightReader
operator|.
name|numDeletedDocs
argument_list|()
assert|;
name|Bits
name|leftBits
init|=
name|MultiFields
operator|.
name|getLiveDocs
argument_list|(
name|leftReader
argument_list|)
decl_stmt|;
name|Bits
name|rightBits
init|=
name|MultiFields
operator|.
name|getLiveDocs
argument_list|(
name|rightReader
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftBits
operator|==
literal|null
operator|||
name|rightBits
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftBits
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightBits
argument_list|)
expr_stmt|;
return|return;
block|}
assert|assert
name|leftReader
operator|.
name|maxDoc
argument_list|()
operator|==
name|rightReader
operator|.
name|maxDoc
argument_list|()
assert|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftBits
operator|.
name|length
argument_list|()
argument_list|,
name|rightBits
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftReader
operator|.
name|maxDoc
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftBits
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|rightBits
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|assertFieldInfosEquals
specifier|public
name|void
name|assertFieldInfosEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|IndexReader
name|rightReader
parameter_list|)
throws|throws
name|IOException
block|{
name|FieldInfos
name|leftInfos
init|=
name|MultiFields
operator|.
name|getMergedFieldInfos
argument_list|(
name|leftReader
argument_list|)
decl_stmt|;
name|FieldInfos
name|rightInfos
init|=
name|MultiFields
operator|.
name|getMergedFieldInfos
argument_list|(
name|rightReader
argument_list|)
decl_stmt|;
comment|// TODO: would be great to verify more than just the names of the fields!
name|TreeSet
argument_list|<
name|String
argument_list|>
name|left
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|right
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldInfo
name|fi
range|:
name|leftInfos
control|)
block|{
name|left
operator|.
name|add
argument_list|(
name|fi
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|FieldInfo
name|fi
range|:
name|rightInfos
control|)
block|{
name|right
operator|.
name|add
argument_list|(
name|fi
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|info
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
comment|/** Returns true if the file exists (can be opened), false    *  if it cannot be opened, and (unlike Java's    *  File.exists) throws IOException if there's some    *  unexpected error. */
DECL|method|slowFileExists
specifier|public
specifier|static
name|boolean
name|slowFileExists
parameter_list|(
name|Directory
name|dir
parameter_list|,
name|String
name|fileName
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|dir
operator|.
name|openInput
argument_list|(
name|fileName
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFileException
decl||
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
end_class
end_unit
