begin_unit
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Documented
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|ElementType
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Inherited
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Retention
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|RetentionPolicy
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Target
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|NoSuchFileException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|MockAnalyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
operator|.
name|Store
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|StringField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|TextField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|AlcoholicMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|AssertingDirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|AssertingLeafReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|BinaryDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CompositeReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|ConcurrentMergeScheduler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValuesType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldFilterLeafReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Fields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
operator|.
name|ReaderClosedListener
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriterConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LiveIndexWriterConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LogByteSizeMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LogDocMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LogMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MergeScheduler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MismatchedDirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MismatchedLeafReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MockRandomMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiFields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|NumericDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|ParallelCompositeReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|ParallelLeafReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SerialMergeScheduler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SimpleMergedSegmentWarmer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SlowCompositeReaderWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedNumericDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedSetDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StorableField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StoredDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
operator|.
name|SeekStatus
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TieredMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|AssertingIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Filter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FilterCachingPolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|QueryUtils
operator|.
name|FCInvisibleMultiReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|BaseDirectoryWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSLockFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FlushInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|LockFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MergeInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MockDirectoryWrapper
operator|.
name|Throttling
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MockDirectoryWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|NRTCachingDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|AutomatonTestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|CompiledAutomaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|RegExp
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|AfterClass
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|ClassRule
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Rule
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|RuleChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|TestRule
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|RunWith
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|JUnit4MethodProvider
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|LifecycleScope
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|MixWithSuiteName
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|RandomizedContext
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|RandomizedRunner
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|RandomizedTest
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|Listeners
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|SeedDecorators
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|TestGroup
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|TestMethodProviders
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|ThreadLeakAction
operator|.
name|Action
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|ThreadLeakAction
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|ThreadLeakFilters
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|ThreadLeakGroup
operator|.
name|Group
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|ThreadLeakGroup
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|ThreadLeakLingering
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|ThreadLeakScope
operator|.
name|Scope
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|ThreadLeakScope
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|ThreadLeakZombies
operator|.
name|Consequence
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|ThreadLeakZombies
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|TimeoutSuite
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|generators
operator|.
name|RandomPicks
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|rules
operator|.
name|NoClassHooksShadowingRule
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|rules
operator|.
name|NoInstanceHooksOverridesRule
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|rules
operator|.
name|StaticFieldsInvariantRule
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|rules
operator|.
name|SystemPropertiesInvariantRule
import|;
end_import
begin_import
import|import static
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|RandomizedTest
operator|.
name|systemPropertyAsBoolean
import|;
end_import
begin_import
import|import static
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|RandomizedTest
operator|.
name|systemPropertyAsInt
import|;
end_import
begin_comment
comment|/**  * Base class for all Lucene unit tests, Junit3 or Junit4 variant.  *   *<h3>Class and instance setup.</h3>  *   *<p>  * The preferred way to specify class (suite-level) setup/cleanup is to use  * static methods annotated with {@link BeforeClass} and {@link AfterClass}. Any  * code in these methods is executed within the test framework's control and  * ensure proper setup has been made.<b>Try not to use static initializers  * (including complex final field initializers).</b> Static initializers are  * executed before any setup rules are fired and may cause you (or somebody   * else) headaches.  *   *<p>  * For instance-level setup, use {@link Before} and {@link After} annotated  * methods. If you override either {@link #setUp()} or {@link #tearDown()} in  * your subclass, make sure you call<code>super.setUp()</code> and  *<code>super.tearDown()</code>. This is detected and enforced.  *   *<h3>Specifying test cases</h3>  *   *<p>  * Any test method with a<code>testXXX</code> prefix is considered a test case.  * Any test method annotated with {@link Test} is considered a test case.  *   *<h3>Randomized execution and test facilities</h3>  *   *<p>  * {@link LuceneTestCase} uses {@link RandomizedRunner} to execute test cases.  * {@link RandomizedRunner} has built-in support for tests randomization  * including access to a repeatable {@link Random} instance. See  * {@link #random()} method. Any test using {@link Random} acquired from  * {@link #random()} should be fully reproducible (assuming no race conditions  * between threads etc.). The initial seed for a test case is reported in many  * ways:  *<ul>  *<li>as part of any exception thrown from its body (inserted as a dummy stack  *   trace entry),</li>  *<li>as part of the main thread executing the test case (if your test hangs,  *   just dump the stack trace of all threads and you'll see the seed),</li>  *<li>the master seed can also be accessed manually by getting the current  *   context ({@link RandomizedContext#current()}) and then calling  *   {@link RandomizedContext#getRunnerSeedAsString()}.</li>  *</ul>  */
end_comment
begin_class
annotation|@
name|RunWith
argument_list|(
name|RandomizedRunner
operator|.
name|class
argument_list|)
annotation|@
name|TestMethodProviders
argument_list|(
block|{
name|LuceneJUnit3MethodProvider
operator|.
name|class
block|,
name|JUnit4MethodProvider
operator|.
name|class
block|}
argument_list|)
annotation|@
name|Listeners
argument_list|(
block|{
name|RunListenerPrintReproduceInfo
operator|.
name|class
block|,
name|FailureMarker
operator|.
name|class
block|}
argument_list|)
annotation|@
name|SeedDecorators
argument_list|(
block|{
name|MixWithSuiteName
operator|.
name|class
block|}
argument_list|)
comment|// See LUCENE-3995 for rationale.
annotation|@
name|ThreadLeakScope
argument_list|(
name|Scope
operator|.
name|SUITE
argument_list|)
annotation|@
name|ThreadLeakGroup
argument_list|(
name|Group
operator|.
name|MAIN
argument_list|)
annotation|@
name|ThreadLeakAction
argument_list|(
block|{
name|Action
operator|.
name|WARN
block|,
name|Action
operator|.
name|INTERRUPT
block|}
argument_list|)
annotation|@
name|ThreadLeakLingering
argument_list|(
name|linger
operator|=
literal|20000
argument_list|)
comment|// Wait long for leaked threads to complete before failure. zk needs this.
annotation|@
name|ThreadLeakZombies
argument_list|(
name|Consequence
operator|.
name|IGNORE_REMAINING_TESTS
argument_list|)
annotation|@
name|TimeoutSuite
argument_list|(
name|millis
operator|=
literal|2
operator|*
name|TimeUnits
operator|.
name|HOUR
argument_list|)
annotation|@
name|ThreadLeakFilters
argument_list|(
name|defaultFilters
operator|=
literal|true
argument_list|,
name|filters
operator|=
block|{
name|QuickPatchThreadsFilter
operator|.
name|class
block|}
argument_list|)
annotation|@
name|TestRuleLimitSysouts
operator|.
name|Limit
argument_list|(
name|bytes
operator|=
name|TestRuleLimitSysouts
operator|.
name|DEFAULT_SYSOUT_BYTES_THRESHOLD
argument_list|)
DECL|class|LuceneTestCase
specifier|public
specifier|abstract
class|class
name|LuceneTestCase
extends|extends
name|Assert
block|{
comment|// --------------------------------------------------------------------
comment|// Test groups, system properties and other annotations modifying tests
comment|// --------------------------------------------------------------------
DECL|field|SYSPROP_NIGHTLY
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_NIGHTLY
init|=
literal|"tests.nightly"
decl_stmt|;
DECL|field|SYSPROP_WEEKLY
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_WEEKLY
init|=
literal|"tests.weekly"
decl_stmt|;
DECL|field|SYSPROP_MONSTER
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_MONSTER
init|=
literal|"tests.monster"
decl_stmt|;
DECL|field|SYSPROP_AWAITSFIX
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_AWAITSFIX
init|=
literal|"tests.awaitsfix"
decl_stmt|;
DECL|field|SYSPROP_SLOW
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_SLOW
init|=
literal|"tests.slow"
decl_stmt|;
DECL|field|SYSPROP_BADAPPLES
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_BADAPPLES
init|=
literal|"tests.badapples"
decl_stmt|;
comment|/** @see #ignoreAfterMaxFailures*/
DECL|field|SYSPROP_MAXFAILURES
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_MAXFAILURES
init|=
literal|"tests.maxfailures"
decl_stmt|;
comment|/** @see #ignoreAfterMaxFailures*/
DECL|field|SYSPROP_FAILFAST
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_FAILFAST
init|=
literal|"tests.failfast"
decl_stmt|;
comment|/**    * Annotation for tests that should only be run during nightly builds.    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|false
argument_list|,
name|sysProperty
operator|=
name|SYSPROP_NIGHTLY
argument_list|)
DECL|interface|Nightly
specifier|public
annotation_defn|@interface
name|Nightly
block|{}
comment|/**    * Annotation for tests that should only be run during weekly builds    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|false
argument_list|,
name|sysProperty
operator|=
name|SYSPROP_WEEKLY
argument_list|)
DECL|interface|Weekly
specifier|public
annotation_defn|@interface
name|Weekly
block|{}
comment|/**    * Annotation for monster tests that require special setup (e.g. use tons of disk and RAM)    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|false
argument_list|,
name|sysProperty
operator|=
name|SYSPROP_MONSTER
argument_list|)
DECL|interface|Monster
specifier|public
annotation_defn|@interface
name|Monster
block|{
DECL|method|value
name|String
name|value
parameter_list|()
function_decl|;
block|}
comment|/**    * Annotation for tests which exhibit a known issue and are temporarily disabled.    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|false
argument_list|,
name|sysProperty
operator|=
name|SYSPROP_AWAITSFIX
argument_list|)
DECL|interface|AwaitsFix
specifier|public
annotation_defn|@interface
name|AwaitsFix
block|{
comment|/** Point to JIRA entry. */
DECL|method|bugUrl
specifier|public
name|String
name|bugUrl
parameter_list|()
function_decl|;
block|}
comment|/**    * Annotation for tests that are slow. Slow tests do run by default but can be    * disabled if a quick run is needed.    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|true
argument_list|,
name|sysProperty
operator|=
name|SYSPROP_SLOW
argument_list|)
DECL|interface|Slow
specifier|public
annotation_defn|@interface
name|Slow
block|{}
comment|/**    * Annotation for tests that fail frequently and should    * be moved to a<a href="https://builds.apache.org/job/Lucene-BadApples-trunk-java7/">"vault" plan in Jenkins</a>.    *    * Tests annotated with this will be turned off by default. If you want to enable    * them, set:    *<pre>    * -Dtests.badapples=true    *</pre>    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|false
argument_list|,
name|sysProperty
operator|=
name|SYSPROP_BADAPPLES
argument_list|)
DECL|interface|BadApple
specifier|public
annotation_defn|@interface
name|BadApple
block|{
comment|/** Point to JIRA entry. */
DECL|method|bugUrl
specifier|public
name|String
name|bugUrl
parameter_list|()
function_decl|;
block|}
comment|/**    * Annotation for test classes that should avoid certain codec types    * (because they are expensive, for example).    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|Target
argument_list|(
name|ElementType
operator|.
name|TYPE
argument_list|)
DECL|interface|SuppressCodecs
specifier|public
annotation_defn|@interface
name|SuppressCodecs
block|{
DECL|method|value
name|String
index|[]
name|value
parameter_list|()
function_decl|;
block|}
comment|/**    * Marks any suites which are known not to close all the temporary    * files. This may prevent temp. files and folders from being cleaned    * up after the suite is completed.    *     * @see LuceneTestCase#createTempDir()    * @see LuceneTestCase#createTempFile(String, String)    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|Target
argument_list|(
name|ElementType
operator|.
name|TYPE
argument_list|)
DECL|interface|SuppressTempFileChecks
specifier|public
annotation_defn|@interface
name|SuppressTempFileChecks
block|{
comment|/** Point to JIRA entry. */
DECL|field|Ó
specifier|public
name|String
name|bugUrl
parameter_list|()
default|default
literal|"None"
function_decl|;
block|}
comment|/**    * Ignore {@link TestRuleLimitSysouts} for any suite which is known to print     * over the default limit of bytes to {@link System#out} or {@link System#err}.    *     * @see TestRuleLimitSysouts    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|Target
argument_list|(
name|ElementType
operator|.
name|TYPE
argument_list|)
DECL|interface|SuppressSysoutChecks
specifier|public
annotation_defn|@interface
name|SuppressSysoutChecks
block|{
comment|/** Point to JIRA entry. */
DECL|method|bugUrl
specifier|public
name|String
name|bugUrl
parameter_list|()
function_decl|;
block|}
comment|// -----------------------------------------------------------------
comment|// Truly immutable fields and constants, initialized once and valid
comment|// for all suites ever since.
comment|// -----------------------------------------------------------------
comment|/**    * True if and only if tests are run in verbose mode. If this flag is false    * tests are not expected to print any messages. Enforced with {@link TestRuleLimitSysouts}.    */
DECL|field|VERBOSE
specifier|public
specifier|static
specifier|final
name|boolean
name|VERBOSE
init|=
name|systemPropertyAsBoolean
argument_list|(
literal|"tests.verbose"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/**    * Enables or disables dumping of {@link InfoStream} messages.     */
DECL|field|INFOSTREAM
specifier|public
specifier|static
specifier|final
name|boolean
name|INFOSTREAM
init|=
name|systemPropertyAsBoolean
argument_list|(
literal|"tests.infostream"
argument_list|,
name|VERBOSE
argument_list|)
decl_stmt|;
comment|/**    * A random multiplier which you should use when writing random tests:    * multiply it by the number of iterations to scale your tests (for nightly builds).    */
DECL|field|RANDOM_MULTIPLIER
specifier|public
specifier|static
specifier|final
name|int
name|RANDOM_MULTIPLIER
init|=
name|systemPropertyAsInt
argument_list|(
literal|"tests.multiplier"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
DECL|field|TEST_ASSERTS_ENABLED
specifier|public
specifier|static
specifier|final
name|boolean
name|TEST_ASSERTS_ENABLED
init|=
name|systemPropertyAsBoolean
argument_list|(
literal|"tests.asserts"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|/** TODO: javadoc? */
DECL|field|DEFAULT_LINE_DOCS_FILE
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_LINE_DOCS_FILE
init|=
literal|"europarl.lines.txt.gz"
decl_stmt|;
comment|/** TODO: javadoc? */
DECL|field|JENKINS_LARGE_LINE_DOCS_FILE
specifier|public
specifier|static
specifier|final
name|String
name|JENKINS_LARGE_LINE_DOCS_FILE
init|=
literal|"enwiki.random.lines.txt"
decl_stmt|;
comment|/** Gets the codec to run tests with. */
DECL|field|TEST_CODEC
specifier|public
specifier|static
specifier|final
name|String
name|TEST_CODEC
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.codec"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** Gets the postingsFormat to run tests with. */
DECL|field|TEST_POSTINGSFORMAT
specifier|public
specifier|static
specifier|final
name|String
name|TEST_POSTINGSFORMAT
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.postingsformat"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** Gets the docValuesFormat to run tests with */
DECL|field|TEST_DOCVALUESFORMAT
specifier|public
specifier|static
specifier|final
name|String
name|TEST_DOCVALUESFORMAT
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.docvaluesformat"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** Gets the directory to run tests with */
DECL|field|TEST_DIRECTORY
specifier|public
specifier|static
specifier|final
name|String
name|TEST_DIRECTORY
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.directory"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** the line file used by LineFileDocs */
DECL|field|TEST_LINE_DOCS_FILE
specifier|public
specifier|static
specifier|final
name|String
name|TEST_LINE_DOCS_FILE
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.linedocsfile"
argument_list|,
name|DEFAULT_LINE_DOCS_FILE
argument_list|)
decl_stmt|;
comment|/** Whether or not {@link Nightly} tests should run. */
DECL|field|TEST_NIGHTLY
specifier|public
specifier|static
specifier|final
name|boolean
name|TEST_NIGHTLY
init|=
name|systemPropertyAsBoolean
argument_list|(
name|SYSPROP_NIGHTLY
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** Whether or not {@link Weekly} tests should run. */
DECL|field|TEST_WEEKLY
specifier|public
specifier|static
specifier|final
name|boolean
name|TEST_WEEKLY
init|=
name|systemPropertyAsBoolean
argument_list|(
name|SYSPROP_WEEKLY
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** Whether or not {@link AwaitsFix} tests should run. */
DECL|field|TEST_AWAITSFIX
specifier|public
specifier|static
specifier|final
name|boolean
name|TEST_AWAITSFIX
init|=
name|systemPropertyAsBoolean
argument_list|(
name|SYSPROP_AWAITSFIX
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** Whether or not {@link Slow} tests should run. */
DECL|field|TEST_SLOW
specifier|public
specifier|static
specifier|final
name|boolean
name|TEST_SLOW
init|=
name|systemPropertyAsBoolean
argument_list|(
name|SYSPROP_SLOW
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** Throttling, see {@link MockDirectoryWrapper#setThrottling(Throttling)}. */
DECL|field|TEST_THROTTLING
specifier|public
specifier|static
specifier|final
name|Throttling
name|TEST_THROTTLING
init|=
name|TEST_NIGHTLY
condition|?
name|Throttling
operator|.
name|SOMETIMES
else|:
name|Throttling
operator|.
name|NEVER
decl_stmt|;
comment|/** Leave temporary files on disk, even on successful runs. */
DECL|field|LEAVE_TEMPORARY
specifier|public
specifier|static
specifier|final
name|boolean
name|LEAVE_TEMPORARY
decl_stmt|;
static|static
block|{
name|boolean
name|defaultValue
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|property
range|:
name|Arrays
operator|.
name|asList
argument_list|(
literal|"tests.leaveTemporary"
comment|/* ANT tasks's (junit4) flag. */
argument_list|,
literal|"tests.leavetemporary"
comment|/* lowercase */
argument_list|,
literal|"tests.leavetmpdir"
comment|/* default */
argument_list|,
literal|"solr.test.leavetmpdir"
comment|/* Solr's legacy */
argument_list|)
control|)
block|{
name|defaultValue
operator||=
name|systemPropertyAsBoolean
argument_list|(
name|property
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|LEAVE_TEMPORARY
operator|=
name|defaultValue
expr_stmt|;
block|}
comment|/**    * These property keys will be ignored in verification of altered properties.    * @see SystemPropertiesInvariantRule    * @see #ruleChain    * @see #classRules    */
DECL|field|IGNORED_INVARIANT_PROPERTIES
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|IGNORED_INVARIANT_PROPERTIES
init|=
block|{
literal|"user.timezone"
block|,
literal|"java.rmi.server.randomIDs"
block|}
decl_stmt|;
comment|/** Filesystem-based {@link Directory} implementations. */
DECL|field|FS_DIRECTORIES
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|FS_DIRECTORIES
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"SimpleFSDirectory"
argument_list|,
literal|"NIOFSDirectory"
argument_list|,
literal|"MMapDirectory"
argument_list|)
decl_stmt|;
comment|/** All {@link Directory} implementations. */
DECL|field|CORE_DIRECTORIES
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|CORE_DIRECTORIES
decl_stmt|;
static|static
block|{
name|CORE_DIRECTORIES
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|FS_DIRECTORIES
argument_list|)
expr_stmt|;
name|CORE_DIRECTORIES
operator|.
name|add
argument_list|(
literal|"RAMDirectory"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/** A {@link FilterCachingPolicy} that randomly caches. */
DECL|field|MAYBE_CACHE_POLICY
specifier|public
specifier|static
specifier|final
name|FilterCachingPolicy
name|MAYBE_CACHE_POLICY
init|=
operator|new
name|FilterCachingPolicy
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onUse
parameter_list|(
name|Filter
name|filter
parameter_list|)
block|{}
annotation|@
name|Override
specifier|public
name|boolean
name|shouldCache
parameter_list|(
name|Filter
name|filter
parameter_list|,
name|LeafReaderContext
name|context
parameter_list|,
name|DocIdSet
name|set
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|// -----------------------------------------------------------------
comment|// Fields initialized in class or instance rules.
comment|// -----------------------------------------------------------------
comment|// -----------------------------------------------------------------
comment|// Class level (suite) rules.
comment|// -----------------------------------------------------------------
comment|/**    * Stores the currently class under test.    */
DECL|field|classNameRule
specifier|private
specifier|static
specifier|final
name|TestRuleStoreClassName
name|classNameRule
decl_stmt|;
comment|/**    * Class environment setup rule.    */
DECL|field|classEnvRule
specifier|static
specifier|final
name|TestRuleSetupAndRestoreClassEnv
name|classEnvRule
decl_stmt|;
comment|/**    * Suite failure marker (any error in the test or suite scope).    */
DECL|field|suiteFailureMarker
specifier|private
specifier|static
name|TestRuleMarkFailure
name|suiteFailureMarker
decl_stmt|;
comment|/**    * Temporary files cleanup rule.    */
DECL|field|tempFilesCleanupRule
specifier|private
specifier|static
name|TestRuleTemporaryFilesCleanup
name|tempFilesCleanupRule
decl_stmt|;
comment|/**    * Ignore tests after hitting a designated number of initial failures. This    * is truly a "static" global singleton since it needs to span the lifetime of all    * test classes running inside this JVM (it cannot be part of a class rule).    *     *<p>This poses some problems for the test framework's tests because these sometimes    * trigger intentional failures which add up to the global count. This field contains    * a (possibly) changing reference to {@link TestRuleIgnoreAfterMaxFailures} and we    * dispatch to its current value from the {@link #classRules} chain using {@link TestRuleDelegate}.      */
DECL|field|ignoreAfterMaxFailuresDelegate
specifier|private
specifier|static
specifier|final
name|AtomicReference
argument_list|<
name|TestRuleIgnoreAfterMaxFailures
argument_list|>
name|ignoreAfterMaxFailuresDelegate
decl_stmt|;
DECL|field|ignoreAfterMaxFailures
specifier|private
specifier|static
specifier|final
name|TestRule
name|ignoreAfterMaxFailures
decl_stmt|;
static|static
block|{
name|int
name|maxFailures
init|=
name|systemPropertyAsInt
argument_list|(
name|SYSPROP_MAXFAILURES
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
name|boolean
name|failFast
init|=
name|systemPropertyAsBoolean
argument_list|(
name|SYSPROP_FAILFAST
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|failFast
condition|)
block|{
if|if
condition|(
name|maxFailures
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|maxFailures
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|Logger
operator|.
name|getLogger
argument_list|(
name|LuceneTestCase
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|)
operator|.
name|warning
argument_list|(
literal|"Property '"
operator|+
name|SYSPROP_MAXFAILURES
operator|+
literal|"'="
operator|+
name|maxFailures
operator|+
literal|", 'failfast' is"
operator|+
literal|" ignored."
argument_list|)
expr_stmt|;
block|}
block|}
name|ignoreAfterMaxFailuresDelegate
operator|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|(
operator|new
name|TestRuleIgnoreAfterMaxFailures
argument_list|(
name|maxFailures
argument_list|)
argument_list|)
expr_stmt|;
name|ignoreAfterMaxFailures
operator|=
name|TestRuleDelegate
operator|.
name|of
argument_list|(
name|ignoreAfterMaxFailuresDelegate
argument_list|)
expr_stmt|;
block|}
comment|/**    * Try to capture streams early so that other classes don't have a chance to steal references    * to them (as is the case with ju.logging handlers).    */
static|static
block|{
name|TestRuleLimitSysouts
operator|.
name|checkCaptureStreams
argument_list|()
expr_stmt|;
name|Logger
operator|.
name|getGlobal
argument_list|()
operator|.
name|getHandlers
argument_list|()
expr_stmt|;
block|}
comment|/**    * Temporarily substitute the global {@link TestRuleIgnoreAfterMaxFailures}. See    * {@link #ignoreAfterMaxFailuresDelegate} for some explanation why this method     * is needed.    */
DECL|method|replaceMaxFailureRule
specifier|public
specifier|static
name|TestRuleIgnoreAfterMaxFailures
name|replaceMaxFailureRule
parameter_list|(
name|TestRuleIgnoreAfterMaxFailures
name|newValue
parameter_list|)
block|{
return|return
name|ignoreAfterMaxFailuresDelegate
operator|.
name|getAndSet
argument_list|(
name|newValue
argument_list|)
return|;
block|}
comment|/**    * Max 10mb of static data stored in a test suite class after the suite is complete.    * Prevents static data structures leaking and causing OOMs in subsequent tests.    */
DECL|field|STATIC_LEAK_THRESHOLD
specifier|private
specifier|final
specifier|static
name|long
name|STATIC_LEAK_THRESHOLD
init|=
literal|10
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
comment|/** By-name list of ignored types like loggers etc. */
DECL|field|STATIC_LEAK_IGNORED_TYPES
specifier|private
specifier|final
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|STATIC_LEAK_IGNORED_TYPES
init|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"org.slf4j.Logger"
argument_list|,
literal|"org.apache.solr.SolrLogFormatter"
argument_list|,
name|EnumSet
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/**    * This controls how suite-level rules are nested. It is important that _all_ rules declared    * in {@link LuceneTestCase} are executed in proper order if they depend on each     * other.    */
annotation|@
name|ClassRule
DECL|field|classRules
specifier|public
specifier|static
name|TestRule
name|classRules
init|=
name|RuleChain
operator|.
name|outerRule
argument_list|(
operator|new
name|TestRuleIgnoreTestSuites
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
name|ignoreAfterMaxFailures
argument_list|)
operator|.
name|around
argument_list|(
name|suiteFailureMarker
operator|=
operator|new
name|TestRuleMarkFailure
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|TestRuleAssertionsRequired
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|TestRuleLimitSysouts
argument_list|(
name|suiteFailureMarker
argument_list|)
argument_list|)
operator|.
name|around
argument_list|(
name|tempFilesCleanupRule
operator|=
operator|new
name|TestRuleTemporaryFilesCleanup
argument_list|(
name|suiteFailureMarker
argument_list|)
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|StaticFieldsInvariantRule
argument_list|(
name|STATIC_LEAK_THRESHOLD
argument_list|,
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|accept
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|field
parameter_list|)
block|{
comment|// Don't count known classes that consume memory once.
if|if
condition|(
name|STATIC_LEAK_IGNORED_TYPES
operator|.
name|contains
argument_list|(
name|field
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Don't count references from ourselves, we're top-level.
if|if
condition|(
name|field
operator|.
name|getDeclaringClass
argument_list|()
operator|==
name|LuceneTestCase
operator|.
name|class
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|super
operator|.
name|accept
argument_list|(
name|field
argument_list|)
return|;
block|}
block|}
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|NoClassHooksShadowingRule
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|NoInstanceHooksOverridesRule
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|verify
parameter_list|(
name|Method
name|key
parameter_list|)
block|{
name|String
name|name
init|=
name|key
operator|.
name|getName
argument_list|()
decl_stmt|;
return|return
operator|!
operator|(
name|name
operator|.
name|equals
argument_list|(
literal|"setUp"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"tearDown"
argument_list|)
operator|)
return|;
block|}
block|}
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|SystemPropertiesInvariantRule
argument_list|(
name|IGNORED_INVARIANT_PROPERTIES
argument_list|)
argument_list|)
operator|.
name|around
argument_list|(
name|classNameRule
operator|=
operator|new
name|TestRuleStoreClassName
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
name|classEnvRule
operator|=
operator|new
name|TestRuleSetupAndRestoreClassEnv
argument_list|()
argument_list|)
decl_stmt|;
comment|// -----------------------------------------------------------------
comment|// Test level rules.
comment|// -----------------------------------------------------------------
comment|/** Enforces {@link #setUp()} and {@link #tearDown()} calls are chained. */
DECL|field|parentChainCallRule
specifier|private
name|TestRuleSetupTeardownChained
name|parentChainCallRule
init|=
operator|new
name|TestRuleSetupTeardownChained
argument_list|()
decl_stmt|;
comment|/** Save test thread and name. */
DECL|field|threadAndTestNameRule
specifier|private
name|TestRuleThreadAndTestName
name|threadAndTestNameRule
init|=
operator|new
name|TestRuleThreadAndTestName
argument_list|()
decl_stmt|;
comment|/** Taint suite result with individual test failures. */
DECL|field|testFailureMarker
specifier|private
name|TestRuleMarkFailure
name|testFailureMarker
init|=
operator|new
name|TestRuleMarkFailure
argument_list|(
name|suiteFailureMarker
argument_list|)
decl_stmt|;
comment|/**    * This controls how individual test rules are nested. It is important that    * _all_ rules declared in {@link LuceneTestCase} are executed in proper order    * if they depend on each other.    */
annotation|@
name|Rule
DECL|field|ruleChain
specifier|public
specifier|final
name|TestRule
name|ruleChain
init|=
name|RuleChain
operator|.
name|outerRule
argument_list|(
name|testFailureMarker
argument_list|)
operator|.
name|around
argument_list|(
name|ignoreAfterMaxFailures
argument_list|)
operator|.
name|around
argument_list|(
name|threadAndTestNameRule
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|SystemPropertiesInvariantRule
argument_list|(
name|IGNORED_INVARIANT_PROPERTIES
argument_list|)
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|TestRuleSetupAndRestoreInstanceEnv
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
name|parentChainCallRule
argument_list|)
decl_stmt|;
DECL|field|fieldToType
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
name|fieldToType
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|FieldType
argument_list|>
argument_list|()
decl_stmt|;
DECL|enum|LiveIWCFlushMode
DECL|enum constant|BY_RAM
DECL|enum constant|BY_DOCS
DECL|enum constant|EITHER
enum|enum
name|LiveIWCFlushMode
block|{
name|BY_RAM
block|,
name|BY_DOCS
block|,
name|EITHER
block|}
empty_stmt|;
comment|/** Set by TestRuleSetupAndRestoreClassEnv */
DECL|field|liveIWCFlushMode
specifier|static
name|LiveIWCFlushMode
name|liveIWCFlushMode
decl_stmt|;
DECL|method|setLiveIWCFlushMode
specifier|static
name|void
name|setLiveIWCFlushMode
parameter_list|(
name|LiveIWCFlushMode
name|flushMode
parameter_list|)
block|{
name|liveIWCFlushMode
operator|=
name|flushMode
expr_stmt|;
block|}
comment|// -----------------------------------------------------------------
comment|// Suite and test case setup/ cleanup.
comment|// -----------------------------------------------------------------
comment|/**    * For subclasses to override. Overrides must call {@code super.setUp()}.    */
annotation|@
name|Before
DECL|method|setUp
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|parentChainCallRule
operator|.
name|setupCalled
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * For subclasses to override. Overrides must call {@code super.tearDown()}.    */
annotation|@
name|After
DECL|method|tearDown
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
name|parentChainCallRule
operator|.
name|teardownCalled
operator|=
literal|true
expr_stmt|;
name|fieldToType
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Test is supposed to call this itself, but we do this defensively in case it forgot:
name|restoreIndexWriterMaxDocs
argument_list|()
expr_stmt|;
block|}
comment|/** Tells {@link IndexWriter} to enforce the specified limit as the maximum number of documents in one index; call    *  {@link #restoreIndexWriterMaxDocs} once your test is done. */
DECL|method|setIndexWriterMaxDocs
specifier|public
name|void
name|setIndexWriterMaxDocs
parameter_list|(
name|int
name|limit
parameter_list|)
block|{
name|Method
name|m
decl_stmt|;
try|try
block|{
name|m
operator|=
name|IndexWriter
operator|.
name|class
operator|.
name|getDeclaredMethod
argument_list|(
literal|"setMaxDocs"
argument_list|,
name|int
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|nsme
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|nsme
argument_list|)
throw|;
block|}
name|m
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|m
operator|.
name|invoke
argument_list|(
name|IndexWriter
operator|.
name|class
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
decl||
name|InvocationTargetException
name|iae
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|iae
argument_list|)
throw|;
block|}
block|}
comment|/** Returns the default {@link IndexWriter#MAX_DOCS} limit. */
DECL|method|restoreIndexWriterMaxDocs
specifier|public
name|void
name|restoreIndexWriterMaxDocs
parameter_list|()
block|{
name|setIndexWriterMaxDocs
argument_list|(
name|IndexWriter
operator|.
name|MAX_DOCS
argument_list|)
expr_stmt|;
block|}
comment|// -----------------------------------------------------------------
comment|// Test facilities and facades for subclasses.
comment|// -----------------------------------------------------------------
comment|/**    * Access to the current {@link RandomizedContext}'s Random instance. It is safe to use    * this method from multiple threads, etc., but it should be called while within a runner's    * scope (so no static initializers). The returned {@link Random} instance will be     *<b>different</b> when this method is called inside a {@link BeforeClass} hook (static     * suite scope) and within {@link Before}/ {@link After} hooks or test methods.     *     *<p>The returned instance must not be shared with other threads or cross a single scope's     * boundary. For example, a {@link Random} acquired within a test method shouldn't be reused    * for another test case.    *     *<p>There is an overhead connected with getting the {@link Random} for a particular context    * and thread. It is better to cache the {@link Random} locally if tight loops with multiple    * invocations are present or create a derivative local {@link Random} for millions of calls     * like this:    *<pre>    * Random random = new Random(random().nextLong());    * // tight loop with many invocations.     *</pre>    */
DECL|method|random
specifier|public
specifier|static
name|Random
name|random
parameter_list|()
block|{
return|return
name|RandomizedContext
operator|.
name|current
argument_list|()
operator|.
name|getRandom
argument_list|()
return|;
block|}
comment|/**    * Registers a {@link Closeable} resource that should be closed after the test    * completes.    *     * @return<code>resource</code> (for call chaining).    */
DECL|method|closeAfterTest
specifier|public
parameter_list|<
name|T
extends|extends
name|Closeable
parameter_list|>
name|T
name|closeAfterTest
parameter_list|(
name|T
name|resource
parameter_list|)
block|{
return|return
name|RandomizedContext
operator|.
name|current
argument_list|()
operator|.
name|closeAtEnd
argument_list|(
name|resource
argument_list|,
name|LifecycleScope
operator|.
name|TEST
argument_list|)
return|;
block|}
comment|/**    * Registers a {@link Closeable} resource that should be closed after the suite    * completes.    *     * @return<code>resource</code> (for call chaining).    */
DECL|method|closeAfterSuite
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|Closeable
parameter_list|>
name|T
name|closeAfterSuite
parameter_list|(
name|T
name|resource
parameter_list|)
block|{
return|return
name|RandomizedContext
operator|.
name|current
argument_list|()
operator|.
name|closeAtEnd
argument_list|(
name|resource
argument_list|,
name|LifecycleScope
operator|.
name|SUITE
argument_list|)
return|;
block|}
comment|/**    * Return the current class being tested.    */
DECL|method|getTestClass
specifier|public
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|getTestClass
parameter_list|()
block|{
return|return
name|classNameRule
operator|.
name|getTestClass
argument_list|()
return|;
block|}
comment|/**    * Return the name of the currently executing test case.    */
DECL|method|getTestName
specifier|public
name|String
name|getTestName
parameter_list|()
block|{
return|return
name|threadAndTestNameRule
operator|.
name|testMethodName
return|;
block|}
comment|/**    * Some tests expect the directory to contain a single segment, and want to     * do tests on that segment's reader. This is an utility method to help them.    */
DECL|method|getOnlySegmentReader
specifier|public
specifier|static
name|SegmentReader
name|getOnlySegmentReader
parameter_list|(
name|DirectoryReader
name|reader
parameter_list|)
block|{
name|List
argument_list|<
name|LeafReaderContext
argument_list|>
name|subReaders
init|=
name|reader
operator|.
name|leaves
argument_list|()
decl_stmt|;
if|if
condition|(
name|subReaders
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|reader
operator|+
literal|" has "
operator|+
name|subReaders
operator|.
name|size
argument_list|()
operator|+
literal|" segments instead of exactly one"
argument_list|)
throw|;
block|}
specifier|final
name|LeafReader
name|r
init|=
name|subReaders
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|reader
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|r
operator|instanceof
name|SegmentReader
argument_list|)
expr_stmt|;
return|return
operator|(
name|SegmentReader
operator|)
name|r
return|;
block|}
comment|/**    * Returns true if and only if the calling thread is the primary thread     * executing the test case.     */
DECL|method|isTestThread
specifier|protected
name|boolean
name|isTestThread
parameter_list|()
block|{
name|assertNotNull
argument_list|(
literal|"Test case thread not set?"
argument_list|,
name|threadAndTestNameRule
operator|.
name|testCaseThread
argument_list|)
expr_stmt|;
return|return
name|Thread
operator|.
name|currentThread
argument_list|()
operator|==
name|threadAndTestNameRule
operator|.
name|testCaseThread
return|;
block|}
comment|/**    * Returns a number of at least<code>i</code>    *<p>    * The actual number returned will be influenced by whether {@link #TEST_NIGHTLY}    * is active and {@link #RANDOM_MULTIPLIER}, but also with some random fudge.    */
DECL|method|atLeast
specifier|public
specifier|static
name|int
name|atLeast
parameter_list|(
name|Random
name|random
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|int
name|min
init|=
operator|(
name|TEST_NIGHTLY
condition|?
literal|2
operator|*
name|i
else|:
name|i
operator|)
operator|*
name|RANDOM_MULTIPLIER
decl_stmt|;
name|int
name|max
init|=
name|min
operator|+
operator|(
name|min
operator|/
literal|2
operator|)
decl_stmt|;
return|return
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
return|;
block|}
DECL|method|atLeast
specifier|public
specifier|static
name|int
name|atLeast
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|atLeast
argument_list|(
name|random
argument_list|()
argument_list|,
name|i
argument_list|)
return|;
block|}
comment|/**    * Returns true if something should happen rarely,    *<p>    * The actual number returned will be influenced by whether {@link #TEST_NIGHTLY}    * is active and {@link #RANDOM_MULTIPLIER}.    */
DECL|method|rarely
specifier|public
specifier|static
name|boolean
name|rarely
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|int
name|p
init|=
name|TEST_NIGHTLY
condition|?
literal|10
else|:
literal|1
decl_stmt|;
name|p
operator|+=
operator|(
name|p
operator|*
name|Math
operator|.
name|log
argument_list|(
name|RANDOM_MULTIPLIER
argument_list|)
operator|)
expr_stmt|;
name|int
name|min
init|=
literal|100
operator|-
name|Math
operator|.
name|min
argument_list|(
name|p
argument_list|,
literal|50
argument_list|)
decl_stmt|;
comment|// never more than 50
return|return
name|random
operator|.
name|nextInt
argument_list|(
literal|100
argument_list|)
operator|>=
name|min
return|;
block|}
DECL|method|rarely
specifier|public
specifier|static
name|boolean
name|rarely
parameter_list|()
block|{
return|return
name|rarely
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|usually
specifier|public
specifier|static
name|boolean
name|usually
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
return|return
operator|!
name|rarely
argument_list|(
name|random
argument_list|)
return|;
block|}
DECL|method|usually
specifier|public
specifier|static
name|boolean
name|usually
parameter_list|()
block|{
return|return
name|usually
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|assumeTrue
specifier|public
specifier|static
name|void
name|assumeTrue
parameter_list|(
name|String
name|msg
parameter_list|,
name|boolean
name|condition
parameter_list|)
block|{
name|RandomizedTest
operator|.
name|assumeTrue
argument_list|(
name|msg
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
DECL|method|assumeFalse
specifier|public
specifier|static
name|void
name|assumeFalse
parameter_list|(
name|String
name|msg
parameter_list|,
name|boolean
name|condition
parameter_list|)
block|{
name|RandomizedTest
operator|.
name|assumeFalse
argument_list|(
name|msg
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
DECL|method|assumeNoException
specifier|public
specifier|static
name|void
name|assumeNoException
parameter_list|(
name|String
name|msg
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|RandomizedTest
operator|.
name|assumeNoException
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return<code>args</code> as a {@link Set} instance. The order of elements is not    * preserved in iterators.    */
annotation|@
name|SafeVarargs
annotation|@
name|SuppressWarnings
argument_list|(
literal|"varargs"
argument_list|)
DECL|method|asSet
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Set
argument_list|<
name|T
argument_list|>
name|asSet
parameter_list|(
name|T
modifier|...
name|args
parameter_list|)
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|args
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Convenience method for logging an iterator.    *    * @param label  String logged before/after the items in the iterator    * @param iter   Each next() is toString()ed and logged on it's own line. If iter is null this is logged differnetly then an empty iterator.    * @param stream Stream to log messages to.    */
DECL|method|dumpIterator
specifier|public
specifier|static
name|void
name|dumpIterator
parameter_list|(
name|String
name|label
parameter_list|,
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
parameter_list|,
name|PrintStream
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|println
argument_list|(
literal|"*** BEGIN "
operator|+
name|label
operator|+
literal|" ***"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|iter
condition|)
block|{
name|stream
operator|.
name|println
argument_list|(
literal|" ... NULL ..."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|stream
operator|.
name|println
argument_list|(
name|iter
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|stream
operator|.
name|println
argument_list|(
literal|"*** END "
operator|+
name|label
operator|+
literal|" ***"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Convenience method for logging an array.  Wraps the array in an iterator and delegates    *    * @see #dumpIterator(String,Iterator,PrintStream)    */
DECL|method|dumpArray
specifier|public
specifier|static
name|void
name|dumpArray
parameter_list|(
name|String
name|label
parameter_list|,
name|Object
index|[]
name|objs
parameter_list|,
name|PrintStream
name|stream
parameter_list|)
block|{
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
init|=
operator|(
literal|null
operator|==
name|objs
operator|)
condition|?
literal|null
else|:
name|Arrays
operator|.
name|asList
argument_list|(
name|objs
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|dumpIterator
argument_list|(
name|label
argument_list|,
name|iter
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/** create a new index writer config with random defaults */
DECL|method|newIndexWriterConfig
specifier|public
specifier|static
name|IndexWriterConfig
name|newIndexWriterConfig
parameter_list|()
block|{
return|return
name|newIndexWriterConfig
argument_list|(
operator|new
name|MockAnalyzer
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/** create a new index writer config with random defaults */
DECL|method|newIndexWriterConfig
specifier|public
specifier|static
name|IndexWriterConfig
name|newIndexWriterConfig
parameter_list|(
name|Analyzer
name|a
parameter_list|)
block|{
return|return
name|newIndexWriterConfig
argument_list|(
name|random
argument_list|()
argument_list|,
name|a
argument_list|)
return|;
block|}
comment|/** create a new index writer config with random defaults using the specified random */
DECL|method|newIndexWriterConfig
specifier|public
specifier|static
name|IndexWriterConfig
name|newIndexWriterConfig
parameter_list|(
name|Random
name|r
parameter_list|,
name|Analyzer
name|a
parameter_list|)
block|{
name|IndexWriterConfig
name|c
init|=
operator|new
name|IndexWriterConfig
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|c
operator|.
name|setSimilarity
argument_list|(
name|classEnvRule
operator|.
name|similarity
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
comment|// Even though TestRuleSetupAndRestoreClassEnv calls
comment|// InfoStream.setDefault, we do it again here so that
comment|// the PrintStreamInfoStream.messageID increments so
comment|// that when there are separate instances of
comment|// IndexWriter created we see "IW 0", "IW 1", "IW 2",
comment|// ... instead of just always "IW 0":
name|c
operator|.
name|setInfoStream
argument_list|(
operator|new
name|TestRuleSetupAndRestoreClassEnv
operator|.
name|ThreadNameFixingPrintStreamInfoStream
argument_list|(
name|System
operator|.
name|out
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|c
operator|.
name|setMergeScheduler
argument_list|(
operator|new
name|SerialMergeScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|ConcurrentMergeScheduler
name|cms
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|cms
operator|=
operator|new
name|ConcurrentMergeScheduler
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|cms
operator|=
operator|new
name|ConcurrentMergeScheduler
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
specifier|synchronized
name|boolean
name|maybeStall
parameter_list|(
name|IndexWriter
name|writer
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
expr_stmt|;
block|}
name|int
name|maxThreadCount
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|int
name|maxMergeCount
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
name|maxThreadCount
argument_list|,
name|maxThreadCount
operator|+
literal|4
argument_list|)
decl_stmt|;
name|cms
operator|.
name|setMaxMergesAndThreads
argument_list|(
name|maxMergeCount
argument_list|,
name|maxThreadCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|cms
operator|.
name|disableAutoIOThrottle
argument_list|()
expr_stmt|;
block|}
name|cms
operator|.
name|setForceMergeMBPerSec
argument_list|(
literal|10
operator|+
literal|10
operator|*
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
argument_list|)
expr_stmt|;
name|c
operator|.
name|setMergeScheduler
argument_list|(
name|cms
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Always use consistent settings, else CMS's dynamic (SSD or not)
comment|// defaults can change, hurting reproducibility:
name|ConcurrentMergeScheduler
name|cms
init|=
operator|new
name|ConcurrentMergeScheduler
argument_list|()
decl_stmt|;
comment|// Only 1 thread can run at once (should maybe help reproducibility),
comment|// with up to 3 pending merges before segment-producing threads are
comment|// stalled:
name|cms
operator|.
name|setMaxMergesAndThreads
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|.
name|setMergeScheduler
argument_list|(
name|cms
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// crazy value
name|c
operator|.
name|setMaxBufferedDocs
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|15
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// reasonable value
name|c
operator|.
name|setMaxBufferedDocs
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|16
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|int
name|maxNumThreadStates
init|=
name|rarely
argument_list|(
name|r
argument_list|)
condition|?
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|5
argument_list|,
literal|20
argument_list|)
comment|// crazy value
else|:
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|)
decl_stmt|;
comment|// reasonable value
name|c
operator|.
name|setMaxThreadStates
argument_list|(
name|maxNumThreadStates
argument_list|)
expr_stmt|;
block|}
name|c
operator|.
name|setMergePolicy
argument_list|(
name|newMergePolicy
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|avoidPathologicalMerging
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|c
operator|.
name|setMergedSegmentWarmer
argument_list|(
operator|new
name|SimpleMergedSegmentWarmer
argument_list|(
name|c
operator|.
name|getInfoStream
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|.
name|setUseCompoundFile
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|c
operator|.
name|setReaderPooling
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
DECL|method|avoidPathologicalMerging
specifier|private
specifier|static
name|void
name|avoidPathologicalMerging
parameter_list|(
name|IndexWriterConfig
name|iwc
parameter_list|)
block|{
comment|// Don't allow "tiny" flushed segments with "big" merge
comment|// floor: this leads to pathological O(N^2) merge costs:
name|long
name|estFlushSizeBytes
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
if|if
condition|(
name|iwc
operator|.
name|getMaxBufferedDocs
argument_list|()
operator|!=
name|IndexWriterConfig
operator|.
name|DISABLE_AUTO_FLUSH
condition|)
block|{
comment|// Gross estimation of 1 KB segment bytes for each doc indexed:
name|estFlushSizeBytes
operator|=
name|Math
operator|.
name|min
argument_list|(
name|estFlushSizeBytes
argument_list|,
name|iwc
operator|.
name|getMaxBufferedDocs
argument_list|()
operator|*
literal|1024
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iwc
operator|.
name|getRAMBufferSizeMB
argument_list|()
operator|!=
name|IndexWriterConfig
operator|.
name|DISABLE_AUTO_FLUSH
condition|)
block|{
name|estFlushSizeBytes
operator|=
name|Math
operator|.
name|min
argument_list|(
name|estFlushSizeBytes
argument_list|,
call|(
name|long
call|)
argument_list|(
name|iwc
operator|.
name|getRAMBufferSizeMB
argument_list|()
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
block|}
assert|assert
name|estFlushSizeBytes
operator|>
literal|0
assert|;
name|MergePolicy
name|mp
init|=
name|iwc
operator|.
name|getMergePolicy
argument_list|()
decl_stmt|;
if|if
condition|(
name|mp
operator|instanceof
name|TieredMergePolicy
condition|)
block|{
name|TieredMergePolicy
name|tmp
init|=
operator|(
name|TieredMergePolicy
operator|)
name|mp
decl_stmt|;
name|long
name|floorSegBytes
init|=
call|(
name|long
call|)
argument_list|(
name|tmp
operator|.
name|getFloorSegmentMB
argument_list|()
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
decl_stmt|;
if|if
condition|(
name|floorSegBytes
operator|/
name|estFlushSizeBytes
operator|>
literal|10
condition|)
block|{
name|double
name|newValue
init|=
name|estFlushSizeBytes
operator|*
literal|10.0
operator|/
literal|1024
operator|/
literal|1024
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"NOTE: LuceneTestCase: changing TieredMergePolicy.floorSegmentMB from "
operator|+
name|tmp
operator|.
name|getFloorSegmentMB
argument_list|()
operator|+
literal|" to "
operator|+
name|newValue
operator|+
literal|" to avoid pathological merging"
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|.
name|setFloorSegmentMB
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mp
operator|instanceof
name|LogByteSizeMergePolicy
condition|)
block|{
name|LogByteSizeMergePolicy
name|lmp
init|=
operator|(
name|LogByteSizeMergePolicy
operator|)
name|mp
decl_stmt|;
if|if
condition|(
operator|(
name|lmp
operator|.
name|getMinMergeMB
argument_list|()
operator|*
literal|1024
operator|*
literal|1024
operator|)
operator|/
name|estFlushSizeBytes
operator|>
literal|10
condition|)
block|{
name|double
name|newValue
init|=
name|estFlushSizeBytes
operator|*
literal|10.0
operator|/
literal|1024
operator|/
literal|1024
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"NOTE: LuceneTestCase: changing LogByteSizeMergePolicy.minMergeMB from "
operator|+
name|lmp
operator|.
name|getMinMergeMB
argument_list|()
operator|+
literal|" to "
operator|+
name|newValue
operator|+
literal|" to avoid pathological merging"
argument_list|)
expr_stmt|;
block|}
name|lmp
operator|.
name|setMinMergeMB
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mp
operator|instanceof
name|LogDocMergePolicy
condition|)
block|{
name|LogDocMergePolicy
name|lmp
init|=
operator|(
name|LogDocMergePolicy
operator|)
name|mp
decl_stmt|;
assert|assert
name|estFlushSizeBytes
operator|/
literal|1024
operator|<
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|10
assert|;
name|int
name|estFlushDocs
init|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|estFlushSizeBytes
operator|/
literal|1024
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lmp
operator|.
name|getMinMergeDocs
argument_list|()
operator|/
name|estFlushDocs
operator|>
literal|10
condition|)
block|{
name|int
name|newValue
init|=
name|estFlushDocs
operator|*
literal|10
decl_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"NOTE: LuceneTestCase: changing LogDocMergePolicy.minMergeDocs from "
operator|+
name|lmp
operator|.
name|getMinMergeDocs
argument_list|()
operator|+
literal|" to "
operator|+
name|newValue
operator|+
literal|" to avoid pathological merging"
argument_list|)
expr_stmt|;
block|}
name|lmp
operator|.
name|setMinMergeDocs
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|newMergePolicy
specifier|public
specifier|static
name|MergePolicy
name|newMergePolicy
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
return|return
operator|new
name|MockRandomMergePolicy
argument_list|(
name|r
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
return|return
name|newTieredMergePolicy
argument_list|(
name|r
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|newAlcoholicMergePolicy
argument_list|(
name|r
argument_list|,
name|classEnvRule
operator|.
name|timeZone
argument_list|)
return|;
block|}
return|return
name|newLogMergePolicy
argument_list|(
name|r
argument_list|)
return|;
block|}
DECL|method|newMergePolicy
specifier|public
specifier|static
name|MergePolicy
name|newMergePolicy
parameter_list|()
block|{
return|return
name|newMergePolicy
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|()
block|{
return|return
name|newLogMergePolicy
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newTieredMergePolicy
specifier|public
specifier|static
name|TieredMergePolicy
name|newTieredMergePolicy
parameter_list|()
block|{
return|return
name|newTieredMergePolicy
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newAlcoholicMergePolicy
specifier|public
specifier|static
name|AlcoholicMergePolicy
name|newAlcoholicMergePolicy
parameter_list|()
block|{
return|return
name|newAlcoholicMergePolicy
argument_list|(
name|random
argument_list|()
argument_list|,
name|classEnvRule
operator|.
name|timeZone
argument_list|)
return|;
block|}
DECL|method|newAlcoholicMergePolicy
specifier|public
specifier|static
name|AlcoholicMergePolicy
name|newAlcoholicMergePolicy
parameter_list|(
name|Random
name|r
parameter_list|,
name|TimeZone
name|tz
parameter_list|)
block|{
return|return
operator|new
name|AlcoholicMergePolicy
argument_list|(
name|tz
argument_list|,
operator|new
name|Random
argument_list|(
name|r
operator|.
name|nextLong
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|r
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|LogDocMergePolicy
argument_list|()
else|:
operator|new
name|LogByteSizeMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setCalibrateSizeByDeletes
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|configureRandom
argument_list|(
name|r
argument_list|,
name|logmp
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
DECL|method|configureRandom
specifier|private
specifier|static
name|void
name|configureRandom
parameter_list|(
name|Random
name|r
parameter_list|,
name|MergePolicy
name|mergePolicy
parameter_list|)
block|{
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|mergePolicy
operator|.
name|setNoCFSRatio
argument_list|(
literal|0.1
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|0.8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mergePolicy
operator|.
name|setNoCFSRatio
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|?
literal|1.0
else|:
literal|0.0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|mergePolicy
operator|.
name|setMaxCFSSegmentSizeMB
argument_list|(
literal|0.2
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|2.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mergePolicy
operator|.
name|setMaxCFSSegmentSizeMB
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|newTieredMergePolicy
specifier|public
specifier|static
name|TieredMergePolicy
name|newTieredMergePolicy
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
name|TieredMergePolicy
name|tmp
init|=
operator|new
name|TieredMergePolicy
argument_list|()
decl_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|setMaxMergeAtOnce
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setMaxMergeAtOnceExplicit
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|setMaxMergeAtOnce
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setMaxMergeAtOnceExplicit
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|setMaxMergedSegmentMB
argument_list|(
literal|0.2
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|2.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|setMaxMergedSegmentMB
argument_list|(
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|100
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|.
name|setFloorSegmentMB
argument_list|(
literal|0.2
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|2.0
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setForceMergeDeletesPctAllowed
argument_list|(
literal|0.0
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|30.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|setSegmentsPerTier
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|20
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|setSegmentsPerTier
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|configureRandom
argument_list|(
name|r
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setReclaimDeletesWeight
argument_list|(
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|MergePolicy
name|newLogMergePolicy
parameter_list|(
name|boolean
name|useCFS
parameter_list|)
block|{
name|MergePolicy
name|logmp
init|=
name|newLogMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setNoCFSRatio
argument_list|(
name|useCFS
condition|?
literal|1.0
else|:
literal|0.0
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|MergePolicy
name|newLogMergePolicy
parameter_list|(
name|boolean
name|useCFS
parameter_list|,
name|int
name|mergeFactor
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|newLogMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setNoCFSRatio
argument_list|(
name|useCFS
condition|?
literal|1.0
else|:
literal|0.0
argument_list|)
expr_stmt|;
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|mergeFactor
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|MergePolicy
name|newLogMergePolicy
parameter_list|(
name|int
name|mergeFactor
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|newLogMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|mergeFactor
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
comment|// if you want it in LiveIndexWriterConfig: it must and will be tested here.
DECL|method|maybeChangeLiveIndexWriterConfig
specifier|public
specifier|static
name|void
name|maybeChangeLiveIndexWriterConfig
parameter_list|(
name|Random
name|r
parameter_list|,
name|LiveIndexWriterConfig
name|c
parameter_list|)
block|{
name|boolean
name|didChange
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// change flush parameters:
comment|// this is complicated because the api requires you "invoke setters in a magical order!"
comment|// LUCENE-5661: workaround for race conditions in the API
synchronized|synchronized
init|(
name|c
init|)
block|{
name|boolean
name|flushByRAM
decl_stmt|;
switch|switch
condition|(
name|liveIWCFlushMode
condition|)
block|{
case|case
name|BY_RAM
case|:
name|flushByRAM
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|BY_DOCS
case|:
name|flushByRAM
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|EITHER
case|:
name|flushByRAM
operator|=
name|r
operator|.
name|nextBoolean
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
if|if
condition|(
name|flushByRAM
condition|)
block|{
name|c
operator|.
name|setRAMBufferSizeMB
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|setMaxBufferedDocs
argument_list|(
name|IndexWriterConfig
operator|.
name|DISABLE_AUTO_FLUSH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// crazy value
name|c
operator|.
name|setMaxBufferedDocs
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|15
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// reasonable value
name|c
operator|.
name|setMaxBufferedDocs
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|16
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|.
name|setRAMBufferSizeMB
argument_list|(
name|IndexWriterConfig
operator|.
name|DISABLE_AUTO_FLUSH
argument_list|)
expr_stmt|;
block|}
block|}
name|didChange
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// change buffered deletes parameters
name|boolean
name|limitBufferedDeletes
init|=
name|r
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|limitBufferedDeletes
condition|)
block|{
name|c
operator|.
name|setMaxBufferedDeleteTerms
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|.
name|setMaxBufferedDeleteTerms
argument_list|(
name|IndexWriterConfig
operator|.
name|DISABLE_AUTO_FLUSH
argument_list|)
expr_stmt|;
block|}
name|didChange
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// change warmer parameters
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|c
operator|.
name|setMergedSegmentWarmer
argument_list|(
operator|new
name|SimpleMergedSegmentWarmer
argument_list|(
name|c
operator|.
name|getInfoStream
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|.
name|setMergedSegmentWarmer
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|didChange
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// change CFS flush parameters
name|c
operator|.
name|setUseCompoundFile
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|didChange
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// change CMS merge parameters
name|MergeScheduler
name|ms
init|=
name|c
operator|.
name|getMergeScheduler
argument_list|()
decl_stmt|;
if|if
condition|(
name|ms
operator|instanceof
name|ConcurrentMergeScheduler
condition|)
block|{
name|int
name|maxThreadCount
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|int
name|maxMergeCount
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
name|maxThreadCount
argument_list|,
name|maxThreadCount
operator|+
literal|4
argument_list|)
decl_stmt|;
operator|(
operator|(
name|ConcurrentMergeScheduler
operator|)
name|ms
operator|)
operator|.
name|setMaxMergesAndThreads
argument_list|(
name|maxMergeCount
argument_list|,
name|maxThreadCount
argument_list|)
expr_stmt|;
block|}
name|didChange
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|MergePolicy
name|mp
init|=
name|c
operator|.
name|getMergePolicy
argument_list|()
decl_stmt|;
name|configureRandom
argument_list|(
name|r
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|instanceof
name|LogMergePolicy
condition|)
block|{
name|LogMergePolicy
name|logmp
init|=
operator|(
name|LogMergePolicy
operator|)
name|mp
decl_stmt|;
name|logmp
operator|.
name|setCalibrateSizeByDeletes
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mp
operator|instanceof
name|TieredMergePolicy
condition|)
block|{
name|TieredMergePolicy
name|tmp
init|=
operator|(
name|TieredMergePolicy
operator|)
name|mp
decl_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|setMaxMergeAtOnce
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setMaxMergeAtOnceExplicit
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|setMaxMergeAtOnce
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setMaxMergeAtOnceExplicit
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|setMaxMergedSegmentMB
argument_list|(
literal|0.2
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|2.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|setMaxMergedSegmentMB
argument_list|(
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|100
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|.
name|setFloorSegmentMB
argument_list|(
literal|0.2
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|2.0
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setForceMergeDeletesPctAllowed
argument_list|(
literal|0.0
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|30.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|setSegmentsPerTier
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|20
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|setSegmentsPerTier
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|configureRandom
argument_list|(
name|r
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setReclaimDeletesWeight
argument_list|(
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
name|didChange
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
operator|&&
name|didChange
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\n"
operator|+
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns a new Directory instance. Use this when the test does not    * care about the specific Directory implementation (most tests).    *<p>    * The Directory is wrapped with {@link BaseDirectoryWrapper}.    * this means usually it will be picky, such as ensuring that you    * properly close it and all open files in your test. It will emulate    * some features of Windows, such as not allowing open files to be    * overwritten.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newDirectory
parameter_list|()
block|{
return|return
name|newDirectory
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a new Directory instance, using the specified random.    * See {@link #newDirectory()} for more information.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newDirectory
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
return|return
name|wrapDirectory
argument_list|(
name|r
argument_list|,
name|newDirectoryImpl
argument_list|(
name|r
argument_list|,
name|TEST_DIRECTORY
argument_list|)
argument_list|,
name|rarely
argument_list|(
name|r
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a new Directory instance, using the specified random.    * See {@link #newDirectory()} for more information.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newDirectory
parameter_list|(
name|Random
name|r
parameter_list|,
name|LockFactory
name|lf
parameter_list|)
block|{
return|return
name|wrapDirectory
argument_list|(
name|r
argument_list|,
name|newDirectoryImpl
argument_list|(
name|r
argument_list|,
name|TEST_DIRECTORY
argument_list|,
name|lf
argument_list|)
argument_list|,
name|rarely
argument_list|(
name|r
argument_list|)
argument_list|)
return|;
block|}
DECL|method|newMockDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newMockDirectory
parameter_list|()
block|{
return|return
name|newMockDirectory
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newMockDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newMockDirectory
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
return|return
operator|(
name|MockDirectoryWrapper
operator|)
name|wrapDirectory
argument_list|(
name|r
argument_list|,
name|newDirectoryImpl
argument_list|(
name|r
argument_list|,
name|TEST_DIRECTORY
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|newMockDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newMockDirectory
parameter_list|(
name|Random
name|r
parameter_list|,
name|LockFactory
name|lf
parameter_list|)
block|{
return|return
operator|(
name|MockDirectoryWrapper
operator|)
name|wrapDirectory
argument_list|(
name|r
argument_list|,
name|newDirectoryImpl
argument_list|(
name|r
argument_list|,
name|TEST_DIRECTORY
argument_list|,
name|lf
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|newMockFSDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newMockFSDirectory
parameter_list|(
name|Path
name|f
parameter_list|)
block|{
return|return
operator|(
name|MockDirectoryWrapper
operator|)
name|newFSDirectory
argument_list|(
name|f
argument_list|,
name|FSLockFactory
operator|.
name|getDefault
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|newMockFSDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newMockFSDirectory
parameter_list|(
name|Path
name|f
parameter_list|,
name|LockFactory
name|lf
parameter_list|)
block|{
return|return
operator|(
name|MockDirectoryWrapper
operator|)
name|newFSDirectory
argument_list|(
name|f
argument_list|,
name|lf
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Returns a new Directory instance, with contents copied from the    * provided directory. See {@link #newDirectory()} for more    * information.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newDirectory
parameter_list|(
name|Directory
name|d
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|newDirectory
argument_list|(
name|random
argument_list|()
argument_list|,
name|d
argument_list|)
return|;
block|}
comment|/** Returns a new FSDirectory instance over the given file, which must be a folder. */
DECL|method|newFSDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newFSDirectory
parameter_list|(
name|Path
name|f
parameter_list|)
block|{
return|return
name|newFSDirectory
argument_list|(
name|f
argument_list|,
name|FSLockFactory
operator|.
name|getDefault
argument_list|()
argument_list|)
return|;
block|}
comment|/** Returns a new FSDirectory instance over the given file, which must be a folder. */
DECL|method|newFSDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newFSDirectory
parameter_list|(
name|Path
name|f
parameter_list|,
name|LockFactory
name|lf
parameter_list|)
block|{
return|return
name|newFSDirectory
argument_list|(
name|f
argument_list|,
name|lf
argument_list|,
name|rarely
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newFSDirectory
specifier|private
specifier|static
name|BaseDirectoryWrapper
name|newFSDirectory
parameter_list|(
name|Path
name|f
parameter_list|,
name|LockFactory
name|lf
parameter_list|,
name|boolean
name|bare
parameter_list|)
block|{
name|String
name|fsdirClass
init|=
name|TEST_DIRECTORY
decl_stmt|;
if|if
condition|(
name|fsdirClass
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
block|{
name|fsdirClass
operator|=
name|RandomPicks
operator|.
name|randomFrom
argument_list|(
name|random
argument_list|()
argument_list|,
name|FS_DIRECTORIES
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsdirClass
operator|.
name|equals
argument_list|(
literal|"SimpleFSDirectory"
argument_list|)
condition|)
block|{
comment|// pick again
name|fsdirClass
operator|=
name|RandomPicks
operator|.
name|randomFrom
argument_list|(
name|random
argument_list|()
argument_list|,
name|FS_DIRECTORIES
argument_list|)
expr_stmt|;
block|}
block|}
name|Class
argument_list|<
name|?
extends|extends
name|FSDirectory
argument_list|>
name|clazz
decl_stmt|;
try|try
block|{
try|try
block|{
name|clazz
operator|=
name|CommandLineUtil
operator|.
name|loadFSDirectoryClass
argument_list|(
name|fsdirClass
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
comment|// TEST_DIRECTORY is not a sub-class of FSDirectory, so draw one at random
name|fsdirClass
operator|=
name|RandomPicks
operator|.
name|randomFrom
argument_list|(
name|random
argument_list|()
argument_list|,
name|FS_DIRECTORIES
argument_list|)
expr_stmt|;
name|clazz
operator|=
name|CommandLineUtil
operator|.
name|loadFSDirectoryClass
argument_list|(
name|fsdirClass
argument_list|)
expr_stmt|;
block|}
name|Directory
name|fsdir
init|=
name|newFSDirectoryImpl
argument_list|(
name|clazz
argument_list|,
name|f
argument_list|,
name|lf
argument_list|)
decl_stmt|;
name|BaseDirectoryWrapper
name|wrapped
init|=
name|wrapDirectory
argument_list|(
name|random
argument_list|()
argument_list|,
name|fsdir
argument_list|,
name|bare
argument_list|)
decl_stmt|;
return|return
name|wrapped
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Rethrow
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
literal|null
throw|;
comment|// dummy to prevent compiler failure
block|}
block|}
comment|/**    * Returns a new Directory instance, using the specified random    * with contents copied from the provided directory. See     * {@link #newDirectory()} for more information.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newDirectory
parameter_list|(
name|Random
name|r
parameter_list|,
name|Directory
name|d
parameter_list|)
throws|throws
name|IOException
block|{
name|Directory
name|impl
init|=
name|newDirectoryImpl
argument_list|(
name|r
argument_list|,
name|TEST_DIRECTORY
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|d
operator|.
name|listAll
argument_list|()
control|)
block|{
name|impl
operator|.
name|copyFrom
argument_list|(
name|d
argument_list|,
name|file
argument_list|,
name|file
argument_list|,
name|newIOContext
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|wrapDirectory
argument_list|(
name|r
argument_list|,
name|impl
argument_list|,
name|rarely
argument_list|(
name|r
argument_list|)
argument_list|)
return|;
block|}
DECL|method|wrapDirectory
specifier|private
specifier|static
name|BaseDirectoryWrapper
name|wrapDirectory
parameter_list|(
name|Random
name|random
parameter_list|,
name|Directory
name|directory
parameter_list|,
name|boolean
name|bare
parameter_list|)
block|{
if|if
condition|(
name|rarely
argument_list|(
name|random
argument_list|)
operator|&&
operator|!
name|bare
condition|)
block|{
name|directory
operator|=
operator|new
name|NRTCachingDirectory
argument_list|(
name|directory
argument_list|,
name|random
operator|.
name|nextDouble
argument_list|()
argument_list|,
name|random
operator|.
name|nextDouble
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bare
condition|)
block|{
name|BaseDirectoryWrapper
name|base
init|=
operator|new
name|BaseDirectoryWrapper
argument_list|(
name|directory
argument_list|)
decl_stmt|;
name|closeAfterSuite
argument_list|(
operator|new
name|CloseableDirectory
argument_list|(
name|base
argument_list|,
name|suiteFailureMarker
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|base
return|;
block|}
else|else
block|{
name|MockDirectoryWrapper
name|mock
init|=
operator|new
name|MockDirectoryWrapper
argument_list|(
name|random
argument_list|,
name|directory
argument_list|)
decl_stmt|;
name|mock
operator|.
name|setThrottling
argument_list|(
name|TEST_THROTTLING
argument_list|)
expr_stmt|;
name|closeAfterSuite
argument_list|(
operator|new
name|CloseableDirectory
argument_list|(
name|mock
argument_list|,
name|suiteFailureMarker
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mock
return|;
block|}
block|}
DECL|method|newStringField
specifier|public
specifier|static
name|Field
name|newStringField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Store
name|stored
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|()
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|stored
operator|==
name|Store
operator|.
name|YES
condition|?
name|StringField
operator|.
name|TYPE_STORED
else|:
name|StringField
operator|.
name|TYPE_NOT_STORED
argument_list|)
return|;
block|}
DECL|method|newTextField
specifier|public
specifier|static
name|Field
name|newTextField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Store
name|stored
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|()
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|stored
operator|==
name|Store
operator|.
name|YES
condition|?
name|TextField
operator|.
name|TYPE_STORED
else|:
name|TextField
operator|.
name|TYPE_NOT_STORED
argument_list|)
return|;
block|}
DECL|method|newStringField
specifier|public
specifier|static
name|Field
name|newStringField
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Store
name|stored
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|stored
operator|==
name|Store
operator|.
name|YES
condition|?
name|StringField
operator|.
name|TYPE_STORED
else|:
name|StringField
operator|.
name|TYPE_NOT_STORED
argument_list|)
return|;
block|}
DECL|method|newTextField
specifier|public
specifier|static
name|Field
name|newTextField
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Store
name|stored
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|stored
operator|==
name|Store
operator|.
name|YES
condition|?
name|TextField
operator|.
name|TYPE_STORED
else|:
name|TextField
operator|.
name|TYPE_NOT_STORED
argument_list|)
return|;
block|}
DECL|method|newField
specifier|public
specifier|static
name|Field
name|newField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|FieldType
name|type
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|()
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/** Returns a FieldType derived from newType but whose    *  term vector options match the old type */
DECL|method|mergeTermVectorOptions
specifier|private
specifier|static
name|FieldType
name|mergeTermVectorOptions
parameter_list|(
name|FieldType
name|newType
parameter_list|,
name|FieldType
name|oldType
parameter_list|)
block|{
if|if
condition|(
name|newType
operator|.
name|indexOptions
argument_list|()
operator|!=
name|IndexOptions
operator|.
name|NONE
operator|&&
name|oldType
operator|.
name|storeTermVectors
argument_list|()
operator|==
literal|true
operator|&&
name|newType
operator|.
name|storeTermVectors
argument_list|()
operator|==
literal|false
condition|)
block|{
name|newType
operator|=
operator|new
name|FieldType
argument_list|(
name|newType
argument_list|)
expr_stmt|;
name|newType
operator|.
name|setStoreTermVectors
argument_list|(
name|oldType
operator|.
name|storeTermVectors
argument_list|()
argument_list|)
expr_stmt|;
name|newType
operator|.
name|setStoreTermVectorPositions
argument_list|(
name|oldType
operator|.
name|storeTermVectorPositions
argument_list|()
argument_list|)
expr_stmt|;
name|newType
operator|.
name|setStoreTermVectorOffsets
argument_list|(
name|oldType
operator|.
name|storeTermVectorOffsets
argument_list|()
argument_list|)
expr_stmt|;
name|newType
operator|.
name|setStoreTermVectorPayloads
argument_list|(
name|oldType
operator|.
name|storeTermVectorPayloads
argument_list|()
argument_list|)
expr_stmt|;
name|newType
operator|.
name|freeze
argument_list|()
expr_stmt|;
block|}
return|return
name|newType
return|;
block|}
comment|// TODO: if we can pull out the "make term vector options
comment|// consistent across all instances of the same field name"
comment|// write-once schema sort of helper class then we can
comment|// remove the sync here.  We can also fold the random
comment|// "enable norms" (now commented out, below) into that:
DECL|method|newField
specifier|public
specifier|synchronized
specifier|static
name|Field
name|newField
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|FieldType
name|type
parameter_list|)
block|{
comment|// Defeat any consumers that illegally rely on intern'd
comment|// strings (we removed this from Lucene a while back):
name|name
operator|=
operator|new
name|String
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|FieldType
name|prevType
init|=
name|fieldToType
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|usually
argument_list|(
name|random
argument_list|)
operator|||
name|type
operator|.
name|indexOptions
argument_list|()
operator|==
name|IndexOptions
operator|.
name|NONE
operator|||
name|prevType
operator|!=
literal|null
condition|)
block|{
comment|// most of the time, don't modify the params
if|if
condition|(
name|prevType
operator|==
literal|null
condition|)
block|{
name|fieldToType
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|new
name|FieldType
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|mergeTermVectorOptions
argument_list|(
name|type
argument_list|,
name|prevType
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Field
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|// TODO: once all core& test codecs can index
comment|// offsets, sometimes randomly turn on offsets if we are
comment|// already indexing positions...
name|FieldType
name|newType
init|=
operator|new
name|FieldType
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newType
operator|.
name|stored
argument_list|()
operator|&&
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStored
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// randomly store it
block|}
comment|// Randomly turn on term vector options, but always do
comment|// so consistently for the same field name:
if|if
condition|(
operator|!
name|newType
operator|.
name|storeTermVectors
argument_list|()
operator|&&
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStoreTermVectors
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newType
operator|.
name|storeTermVectorPositions
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStoreTermVectorPositions
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|newType
operator|.
name|storeTermVectorPositions
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|newType
operator|.
name|storeTermVectorPayloads
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStoreTermVectorPayloads
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|newType
operator|.
name|storeTermVectorOffsets
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStoreTermVectorOffsets
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"NOTE: LuceneTestCase: upgrade name="
operator|+
name|name
operator|+
literal|" type="
operator|+
name|newType
argument_list|)
expr_stmt|;
block|}
block|}
name|newType
operator|.
name|freeze
argument_list|()
expr_stmt|;
name|fieldToType
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|newType
argument_list|)
expr_stmt|;
comment|// TODO: we need to do this, but smarter, ie, most of
comment|// the time we set the same value for a given field but
comment|// sometimes (rarely) we change it up:
comment|/*     if (newType.omitNorms()) {       newType.setOmitNorms(random.nextBoolean());     }     */
return|return
operator|new
name|Field
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|newType
argument_list|)
return|;
block|}
comment|/**     * Return a random Locale from the available locales on the system.    * @see<a href="https://issues.apache.org/jira/browse/LUCENE-4020">LUCENE-4020</a>    */
DECL|method|randomLocale
specifier|public
specifier|static
name|Locale
name|randomLocale
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|Locale
name|locales
index|[]
init|=
name|Locale
operator|.
name|getAvailableLocales
argument_list|()
decl_stmt|;
return|return
name|locales
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|locales
operator|.
name|length
argument_list|)
index|]
return|;
block|}
comment|/**     * Return a random TimeZone from the available timezones on the system    * @see<a href="https://issues.apache.org/jira/browse/LUCENE-4020">LUCENE-4020</a>    */
DECL|method|randomTimeZone
specifier|public
specifier|static
name|TimeZone
name|randomTimeZone
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|String
name|tzIds
index|[]
init|=
name|TimeZone
operator|.
name|getAvailableIDs
argument_list|()
decl_stmt|;
return|return
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
name|tzIds
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|tzIds
operator|.
name|length
argument_list|)
index|]
argument_list|)
return|;
block|}
comment|/** return a Locale object equivalent to its programmatic name */
DECL|method|localeForName
specifier|public
specifier|static
name|Locale
name|localeForName
parameter_list|(
name|String
name|localeName
parameter_list|)
block|{
name|String
name|elements
index|[]
init|=
name|localeName
operator|.
name|split
argument_list|(
literal|"\\_"
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|elements
operator|.
name|length
condition|)
block|{
case|case
literal|4
case|:
comment|/* fallthrough for special cases */
case|case
literal|3
case|:
return|return
operator|new
name|Locale
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|,
name|elements
index|[
literal|1
index|]
argument_list|,
name|elements
index|[
literal|2
index|]
argument_list|)
return|;
case|case
literal|2
case|:
return|return
operator|new
name|Locale
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|,
name|elements
index|[
literal|1
index|]
argument_list|)
return|;
case|case
literal|1
case|:
return|return
operator|new
name|Locale
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid Locale: "
operator|+
name|localeName
argument_list|)
throw|;
block|}
block|}
DECL|method|newFSDirectoryImpl
specifier|private
specifier|static
name|Directory
name|newFSDirectoryImpl
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|FSDirectory
argument_list|>
name|clazz
parameter_list|,
name|Path
name|path
parameter_list|,
name|LockFactory
name|lf
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDirectory
name|d
init|=
literal|null
decl_stmt|;
try|try
block|{
name|d
operator|=
name|CommandLineUtil
operator|.
name|newFSDirectory
argument_list|(
name|clazz
argument_list|,
name|path
argument_list|,
name|lf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReflectiveOperationException
name|e
parameter_list|)
block|{
name|Rethrow
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
DECL|method|newDirectoryImpl
specifier|static
name|Directory
name|newDirectoryImpl
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|clazzName
parameter_list|)
block|{
return|return
name|newDirectoryImpl
argument_list|(
name|random
argument_list|,
name|clazzName
argument_list|,
name|FSLockFactory
operator|.
name|getDefault
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newDirectoryImpl
specifier|static
name|Directory
name|newDirectoryImpl
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|clazzName
parameter_list|,
name|LockFactory
name|lf
parameter_list|)
block|{
if|if
condition|(
name|clazzName
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
block|{
if|if
condition|(
name|rarely
argument_list|(
name|random
argument_list|)
condition|)
block|{
name|clazzName
operator|=
name|RandomPicks
operator|.
name|randomFrom
argument_list|(
name|random
argument_list|,
name|CORE_DIRECTORIES
argument_list|)
expr_stmt|;
if|if
condition|(
name|clazzName
operator|.
name|equals
argument_list|(
literal|"SimpleFSDirectory"
argument_list|)
condition|)
block|{
comment|// pick again
name|clazzName
operator|=
name|RandomPicks
operator|.
name|randomFrom
argument_list|(
name|random
argument_list|,
name|CORE_DIRECTORIES
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|clazzName
operator|=
literal|"RAMDirectory"
expr_stmt|;
block|}
block|}
try|try
block|{
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Directory
argument_list|>
name|clazz
init|=
name|CommandLineUtil
operator|.
name|loadDirectoryClass
argument_list|(
name|clazzName
argument_list|)
decl_stmt|;
comment|// If it is a FSDirectory type, try its ctor(Path)
if|if
condition|(
name|FSDirectory
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|clazz
argument_list|)
condition|)
block|{
specifier|final
name|Path
name|dir
init|=
name|createTempDir
argument_list|(
literal|"index-"
operator|+
name|clazzName
argument_list|)
decl_stmt|;
return|return
name|newFSDirectoryImpl
argument_list|(
name|clazz
operator|.
name|asSubclass
argument_list|(
name|FSDirectory
operator|.
name|class
argument_list|)
argument_list|,
name|dir
argument_list|,
name|lf
argument_list|)
return|;
block|}
comment|// See if it has a Path/LockFactory ctor even though it's not an
comment|// FSDir subclass:
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|Directory
argument_list|>
name|pathCtor
init|=
name|clazz
operator|.
name|getConstructor
argument_list|(
name|Path
operator|.
name|class
argument_list|,
name|LockFactory
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|dir
init|=
name|createTempDir
argument_list|(
literal|"index"
argument_list|)
decl_stmt|;
return|return
name|pathCtor
operator|.
name|newInstance
argument_list|(
name|dir
argument_list|,
name|lf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|nsme
parameter_list|)
block|{
comment|// Ignore
block|}
comment|// the remaining dirs are no longer filesystem based, so we must check that the passedLockFactory is not file based:
if|if
condition|(
operator|!
operator|(
name|lf
operator|instanceof
name|FSLockFactory
operator|)
condition|)
block|{
comment|// try ctor with only LockFactory (e.g. RAMDirectory)
try|try
block|{
return|return
name|clazz
operator|.
name|getConstructor
argument_list|(
name|LockFactory
operator|.
name|class
argument_list|)
operator|.
name|newInstance
argument_list|(
name|lf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|nsme
parameter_list|)
block|{
comment|// Ignore
block|}
block|}
comment|// try empty ctor
return|return
name|clazz
operator|.
name|newInstance
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Rethrow
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
literal|null
throw|;
comment|// dummy to prevent compiler failure
block|}
block|}
comment|/**    * Sometimes wrap the IndexReader as slow, parallel or filter reader (or    * combinations of that)    */
DECL|method|maybeWrapReader
specifier|public
specifier|static
name|IndexReader
name|maybeWrapReader
parameter_list|(
name|IndexReader
name|r
parameter_list|)
throws|throws
name|IOException
block|{
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
if|if
condition|(
name|rarely
argument_list|()
condition|)
block|{
comment|// TODO: remove this, and fix those tests to wrap before putting slow around:
specifier|final
name|boolean
name|wasOriginallyAtomic
init|=
name|r
operator|instanceof
name|LeafReader
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|c
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|6
argument_list|)
operator|+
literal|1
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|6
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|r
operator|=
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|// will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:
name|r
operator|=
operator|(
name|r
operator|instanceof
name|LeafReader
operator|)
condition|?
operator|new
name|ParallelLeafReader
argument_list|(
operator|(
name|LeafReader
operator|)
name|r
argument_list|)
else|:
operator|new
name|ParallelCompositeReader
argument_list|(
operator|(
name|CompositeReader
operator|)
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|// HÃÂ¤ckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use
comment|// QueryUtils' reader with a fake cache key, so insanity checker cannot walk
comment|// along our reader:
name|r
operator|=
operator|new
name|FCInvisibleMultiReader
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
specifier|final
name|LeafReader
name|ar
init|=
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|r
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|allFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldInfo
name|fi
range|:
name|ar
operator|.
name|getFieldInfos
argument_list|()
control|)
block|{
name|allFields
operator|.
name|add
argument_list|(
name|fi
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|shuffle
argument_list|(
name|allFields
argument_list|,
name|random
argument_list|)
expr_stmt|;
specifier|final
name|int
name|end
init|=
name|allFields
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|random
operator|.
name|nextInt
argument_list|(
name|allFields
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|fields
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|allFields
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|end
argument_list|)
argument_list|)
decl_stmt|;
comment|// will create no FC insanity as ParallelLeafReader has own cache key:
name|r
operator|=
operator|new
name|ParallelLeafReader
argument_list|(
operator|new
name|FieldFilterLeafReader
argument_list|(
name|ar
argument_list|,
name|fields
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|FieldFilterLeafReader
argument_list|(
name|ar
argument_list|,
name|fields
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|// HÃÂ¤ckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use
comment|// QueryUtils' reader with a fake cache key, so insanity checker cannot walk
comment|// along our reader:
if|if
condition|(
name|r
operator|instanceof
name|LeafReader
condition|)
block|{
name|r
operator|=
operator|new
name|AssertingLeafReader
argument_list|(
operator|(
name|LeafReader
operator|)
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|instanceof
name|DirectoryReader
condition|)
block|{
name|r
operator|=
operator|new
name|AssertingDirectoryReader
argument_list|(
operator|(
name|DirectoryReader
operator|)
name|r
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|r
operator|instanceof
name|LeafReader
condition|)
block|{
name|r
operator|=
operator|new
name|MismatchedLeafReader
argument_list|(
operator|(
name|LeafReader
operator|)
name|r
argument_list|,
name|random
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|instanceof
name|DirectoryReader
condition|)
block|{
name|r
operator|=
operator|new
name|MismatchedDirectoryReader
argument_list|(
operator|(
name|DirectoryReader
operator|)
name|r
argument_list|,
name|random
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fail
argument_list|(
literal|"should not get here"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wasOriginallyAtomic
condition|)
block|{
name|r
operator|=
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|r
operator|instanceof
name|CompositeReader
operator|)
operator|&&
operator|!
operator|(
name|r
operator|instanceof
name|FCInvisibleMultiReader
operator|)
condition|)
block|{
comment|// prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:
name|r
operator|=
operator|new
name|FCInvisibleMultiReader
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"maybeWrapReader wrapped: "
operator|+
name|r
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|r
return|;
block|}
comment|/** TODO: javadoc */
DECL|method|newIOContext
specifier|public
specifier|static
name|IOContext
name|newIOContext
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
return|return
name|newIOContext
argument_list|(
name|random
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
return|;
block|}
comment|/** TODO: javadoc */
DECL|method|newIOContext
specifier|public
specifier|static
name|IOContext
name|newIOContext
parameter_list|(
name|Random
name|random
parameter_list|,
name|IOContext
name|oldContext
parameter_list|)
block|{
specifier|final
name|int
name|randomNumDocs
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|4192
argument_list|)
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|512
argument_list|)
operator|*
name|randomNumDocs
decl_stmt|;
if|if
condition|(
name|oldContext
operator|.
name|flushInfo
operator|!=
literal|null
condition|)
block|{
comment|// Always return at least the estimatedSegmentSize of
comment|// the incoming IOContext:
return|return
operator|new
name|IOContext
argument_list|(
operator|new
name|FlushInfo
argument_list|(
name|randomNumDocs
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|oldContext
operator|.
name|flushInfo
operator|.
name|estimatedSegmentSize
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|oldContext
operator|.
name|mergeInfo
operator|!=
literal|null
condition|)
block|{
comment|// Always return at least the estimatedMergeBytes of
comment|// the incoming IOContext:
return|return
operator|new
name|IOContext
argument_list|(
operator|new
name|MergeInfo
argument_list|(
name|randomNumDocs
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|oldContext
operator|.
name|mergeInfo
operator|.
name|estimatedMergeBytes
argument_list|,
name|size
argument_list|)
argument_list|,
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|,
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|// Make a totally random IOContext:
specifier|final
name|IOContext
name|context
decl_stmt|;
switch|switch
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|context
operator|=
name|IOContext
operator|.
name|DEFAULT
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|context
operator|=
name|IOContext
operator|.
name|READ
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|context
operator|=
name|IOContext
operator|.
name|READONCE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|context
operator|=
operator|new
name|IOContext
argument_list|(
operator|new
name|MergeInfo
argument_list|(
name|randomNumDocs
argument_list|,
name|size
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|context
operator|=
operator|new
name|IOContext
argument_list|(
operator|new
name|FlushInfo
argument_list|(
name|randomNumDocs
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|context
operator|=
name|IOContext
operator|.
name|DEFAULT
expr_stmt|;
block|}
return|return
name|context
return|;
block|}
block|}
comment|/**    * Create a new searcher over the reader. This searcher might randomly use    * threads.    */
DECL|method|newSearcher
specifier|public
specifier|static
name|IndexSearcher
name|newSearcher
parameter_list|(
name|IndexReader
name|r
parameter_list|)
block|{
return|return
name|newSearcher
argument_list|(
name|r
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Create a new searcher over the reader. This searcher might randomly use    * threads.    */
DECL|method|newSearcher
specifier|public
specifier|static
name|IndexSearcher
name|newSearcher
parameter_list|(
name|IndexReader
name|r
parameter_list|,
name|boolean
name|maybeWrap
parameter_list|)
block|{
return|return
name|newSearcher
argument_list|(
name|r
argument_list|,
name|maybeWrap
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Create a new searcher over the reader. This searcher might randomly use    * threads. if<code>maybeWrap</code> is true, this searcher might wrap the    * reader with one that returns null for getSequentialSubReaders. If    *<code>wrapWithAssertions</code> is true, this searcher might be an    * {@link AssertingIndexSearcher} instance.    */
DECL|method|newSearcher
specifier|public
specifier|static
name|IndexSearcher
name|newSearcher
parameter_list|(
name|IndexReader
name|r
parameter_list|,
name|boolean
name|maybeWrap
parameter_list|,
name|boolean
name|wrapWithAssertions
parameter_list|)
block|{
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
if|if
condition|(
name|usually
argument_list|()
condition|)
block|{
if|if
condition|(
name|maybeWrap
condition|)
block|{
try|try
block|{
name|r
operator|=
name|maybeWrapReader
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|Rethrow
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.
comment|// ultimately whatever you do will be checkIndex'd at the end anyway.
if|if
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|500
argument_list|)
operator|==
literal|0
operator|&&
name|r
operator|instanceof
name|LeafReader
condition|)
block|{
comment|// TODO: not useful to check DirectoryReader (redundant with checkindex)
comment|// but maybe sometimes run this on the other crazy readers maybeWrapReader creates?
try|try
block|{
name|TestUtil
operator|.
name|checkReader
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|Rethrow
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|IndexSearcher
name|ret
decl_stmt|;
if|if
condition|(
name|wrapWithAssertions
condition|)
block|{
name|ret
operator|=
name|random
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|AssertingIndexSearcher
argument_list|(
name|random
argument_list|,
name|r
argument_list|)
else|:
operator|new
name|AssertingIndexSearcher
argument_list|(
name|random
argument_list|,
name|r
operator|.
name|getContext
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|random
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|IndexSearcher
argument_list|(
name|r
argument_list|)
else|:
operator|new
name|IndexSearcher
argument_list|(
name|r
operator|.
name|getContext
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ret
operator|.
name|setSimilarity
argument_list|(
name|classEnvRule
operator|.
name|similarity
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|int
name|threads
init|=
literal|0
decl_stmt|;
specifier|final
name|ThreadPoolExecutor
name|ex
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|ex
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|threads
operator|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ex
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
name|threads
argument_list|,
name|threads
argument_list|,
literal|0L
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|,
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
operator|new
name|NamedThreadFactory
argument_list|(
literal|"LuceneTestCase"
argument_list|)
argument_list|)
expr_stmt|;
comment|// uncomment to intensify LUCENE-3840
comment|// ex.prestartAllCoreThreads();
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"NOTE: newSearcher using ExecutorService with "
operator|+
name|threads
operator|+
literal|" threads"
argument_list|)
expr_stmt|;
block|}
name|r
operator|.
name|addReaderClosedListener
argument_list|(
operator|new
name|ReaderClosedListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onClose
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
block|{
name|TestUtil
operator|.
name|shutdownExecutorService
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|IndexSearcher
name|ret
decl_stmt|;
if|if
condition|(
name|wrapWithAssertions
condition|)
block|{
name|ret
operator|=
name|random
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|AssertingIndexSearcher
argument_list|(
name|random
argument_list|,
name|r
argument_list|,
name|ex
argument_list|)
else|:
operator|new
name|AssertingIndexSearcher
argument_list|(
name|random
argument_list|,
name|r
operator|.
name|getContext
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|random
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|IndexSearcher
argument_list|(
name|r
argument_list|,
name|ex
argument_list|)
else|:
operator|new
name|IndexSearcher
argument_list|(
name|r
operator|.
name|getContext
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|ret
operator|.
name|setSimilarity
argument_list|(
name|classEnvRule
operator|.
name|similarity
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
comment|/**    * Gets a resource from the test's classpath as {@link Path}. This method should only    * be used, if a real file is needed. To get a stream, code should prefer    * {@link #getDataInputStream(String)}.    */
DECL|method|getDataPath
specifier|protected
name|Path
name|getDataPath
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|Paths
operator|.
name|get
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getResource
argument_list|(
name|name
argument_list|)
operator|.
name|toURI
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot find resource: "
operator|+
name|name
argument_list|)
throw|;
block|}
block|}
comment|/**    * Gets a resource from the test's classpath as {@link InputStream}.    */
DECL|method|getDataInputStream
specifier|protected
name|InputStream
name|getDataInputStream
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStream
name|in
init|=
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot find resource: "
operator|+
name|name
argument_list|)
throw|;
block|}
return|return
name|in
return|;
block|}
DECL|method|assertReaderEquals
specifier|public
name|void
name|assertReaderEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|IndexReader
name|rightReader
parameter_list|)
throws|throws
name|IOException
block|{
name|assertReaderStatisticsEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|rightReader
argument_list|)
expr_stmt|;
name|assertFieldsEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|MultiFields
operator|.
name|getFields
argument_list|(
name|leftReader
argument_list|)
argument_list|,
name|MultiFields
operator|.
name|getFields
argument_list|(
name|rightReader
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertNormsEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|rightReader
argument_list|)
expr_stmt|;
name|assertStoredFieldsEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|rightReader
argument_list|)
expr_stmt|;
name|assertTermVectorsEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|rightReader
argument_list|)
expr_stmt|;
name|assertDocValuesEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|rightReader
argument_list|)
expr_stmt|;
name|assertDeletedDocsEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|rightReader
argument_list|)
expr_stmt|;
name|assertFieldInfosEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|rightReader
argument_list|)
expr_stmt|;
block|}
comment|/**     * checks that reader-level statistics are the same     */
DECL|method|assertReaderStatisticsEquals
specifier|public
name|void
name|assertReaderStatisticsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|IndexReader
name|rightReader
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Somewhat redundant: we never delete docs
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftReader
operator|.
name|maxDoc
argument_list|()
argument_list|,
name|rightReader
operator|.
name|maxDoc
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftReader
operator|.
name|numDocs
argument_list|()
argument_list|,
name|rightReader
operator|.
name|numDocs
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftReader
operator|.
name|numDeletedDocs
argument_list|()
argument_list|,
name|rightReader
operator|.
name|numDeletedDocs
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftReader
operator|.
name|hasDeletions
argument_list|()
argument_list|,
name|rightReader
operator|.
name|hasDeletions
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**     * Fields api equivalency     */
DECL|method|assertFieldsEquals
specifier|public
name|void
name|assertFieldsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|Fields
name|leftFields
parameter_list|,
name|Fields
name|rightFields
parameter_list|,
name|boolean
name|deep
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Fields could be null if there are no postings,
comment|// but then it must be null for both
if|if
condition|(
name|leftFields
operator|==
literal|null
operator|||
name|rightFields
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftFields
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightFields
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertFieldStatisticsEquals
argument_list|(
name|info
argument_list|,
name|leftFields
argument_list|,
name|rightFields
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|leftEnum
init|=
name|leftFields
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|rightEnum
init|=
name|rightFields
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|leftEnum
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|field
init|=
name|leftEnum
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|field
argument_list|,
name|rightEnum
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertTermsEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftFields
operator|.
name|terms
argument_list|(
name|field
argument_list|)
argument_list|,
name|rightFields
operator|.
name|terms
argument_list|(
name|field
argument_list|)
argument_list|,
name|deep
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|rightEnum
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**     * checks that top-level statistics on Fields are the same     */
DECL|method|assertFieldStatisticsEquals
specifier|public
name|void
name|assertFieldStatisticsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|Fields
name|leftFields
parameter_list|,
name|Fields
name|rightFields
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|leftFields
operator|.
name|size
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|rightFields
operator|.
name|size
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftFields
operator|.
name|size
argument_list|()
argument_list|,
name|rightFields
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Terms api equivalency     */
DECL|method|assertTermsEquals
specifier|public
name|void
name|assertTermsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|Terms
name|leftTerms
parameter_list|,
name|Terms
name|rightTerms
parameter_list|,
name|boolean
name|deep
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|leftTerms
operator|==
literal|null
operator|||
name|rightTerms
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftTerms
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightTerms
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertTermsStatisticsEquals
argument_list|(
name|info
argument_list|,
name|leftTerms
argument_list|,
name|rightTerms
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|leftTerms
operator|.
name|hasOffsets
argument_list|()
argument_list|,
name|rightTerms
operator|.
name|hasOffsets
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|leftTerms
operator|.
name|hasPositions
argument_list|()
argument_list|,
name|rightTerms
operator|.
name|hasPositions
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|leftTerms
operator|.
name|hasPayloads
argument_list|()
argument_list|,
name|rightTerms
operator|.
name|hasPayloads
argument_list|()
argument_list|)
expr_stmt|;
name|TermsEnum
name|leftTermsEnum
init|=
name|leftTerms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|TermsEnum
name|rightTermsEnum
init|=
name|rightTerms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|assertTermsEnumEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftTermsEnum
argument_list|,
name|rightTermsEnum
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertTermsSeekingEquals
argument_list|(
name|info
argument_list|,
name|leftTerms
argument_list|,
name|rightTerms
argument_list|)
expr_stmt|;
if|if
condition|(
name|deep
condition|)
block|{
name|int
name|numIntersections
init|=
name|atLeast
argument_list|(
literal|3
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIntersections
condition|;
name|i
operator|++
control|)
block|{
name|String
name|re
init|=
name|AutomatonTestUtil
operator|.
name|randomRegexp
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|CompiledAutomaton
name|automaton
init|=
operator|new
name|CompiledAutomaton
argument_list|(
operator|new
name|RegExp
argument_list|(
name|re
argument_list|,
name|RegExp
operator|.
name|NONE
argument_list|)
operator|.
name|toAutomaton
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|automaton
operator|.
name|type
operator|==
name|CompiledAutomaton
operator|.
name|AUTOMATON_TYPE
operator|.
name|NORMAL
condition|)
block|{
comment|// TODO: test start term too
name|TermsEnum
name|leftIntersection
init|=
name|leftTerms
operator|.
name|intersect
argument_list|(
name|automaton
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|TermsEnum
name|rightIntersection
init|=
name|rightTerms
operator|.
name|intersect
argument_list|(
name|automaton
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTermsEnumEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftIntersection
argument_list|,
name|rightIntersection
argument_list|,
name|rarely
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**     * checks collection-level statistics on Terms     */
DECL|method|assertTermsStatisticsEquals
specifier|public
name|void
name|assertTermsStatisticsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|Terms
name|leftTerms
parameter_list|,
name|Terms
name|rightTerms
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|leftTerms
operator|.
name|getDocCount
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|rightTerms
operator|.
name|getDocCount
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftTerms
operator|.
name|getDocCount
argument_list|()
argument_list|,
name|rightTerms
operator|.
name|getDocCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|leftTerms
operator|.
name|getSumDocFreq
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|rightTerms
operator|.
name|getSumDocFreq
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftTerms
operator|.
name|getSumDocFreq
argument_list|()
argument_list|,
name|rightTerms
operator|.
name|getSumDocFreq
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|leftTerms
operator|.
name|getSumTotalTermFreq
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|rightTerms
operator|.
name|getSumTotalTermFreq
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftTerms
operator|.
name|getSumTotalTermFreq
argument_list|()
argument_list|,
name|rightTerms
operator|.
name|getSumTotalTermFreq
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|leftTerms
operator|.
name|size
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|rightTerms
operator|.
name|size
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftTerms
operator|.
name|size
argument_list|()
argument_list|,
name|rightTerms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|RandomBits
specifier|private
specifier|static
class|class
name|RandomBits
implements|implements
name|Bits
block|{
DECL|field|bits
name|FixedBitSet
name|bits
decl_stmt|;
DECL|method|RandomBits
name|RandomBits
parameter_list|(
name|int
name|maxDoc
parameter_list|,
name|double
name|pctLive
parameter_list|,
name|Random
name|random
parameter_list|)
block|{
name|bits
operator|=
operator|new
name|FixedBitSet
argument_list|(
name|maxDoc
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxDoc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|random
operator|.
name|nextDouble
argument_list|()
operator|<=
name|pctLive
condition|)
block|{
name|bits
operator|.
name|set
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|get
specifier|public
name|boolean
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|bits
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|length
specifier|public
name|int
name|length
parameter_list|()
block|{
return|return
name|bits
operator|.
name|length
argument_list|()
return|;
block|}
block|}
comment|/**     * checks the terms enum sequentially    * if deep is false, it does a 'shallow' test that doesnt go down to the docsenums    */
DECL|method|assertTermsEnumEquals
specifier|public
name|void
name|assertTermsEnumEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|TermsEnum
name|leftTermsEnum
parameter_list|,
name|TermsEnum
name|rightTermsEnum
parameter_list|,
name|boolean
name|deep
parameter_list|)
throws|throws
name|IOException
block|{
name|BytesRef
name|term
decl_stmt|;
name|Bits
name|randomBits
init|=
operator|new
name|RandomBits
argument_list|(
name|leftReader
operator|.
name|maxDoc
argument_list|()
argument_list|,
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
argument_list|,
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|DocsAndPositionsEnum
name|leftPositions
init|=
literal|null
decl_stmt|;
name|DocsAndPositionsEnum
name|rightPositions
init|=
literal|null
decl_stmt|;
name|DocsEnum
name|leftDocs
init|=
literal|null
decl_stmt|;
name|DocsEnum
name|rightDocs
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|term
operator|=
name|leftTermsEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|term
argument_list|,
name|rightTermsEnum
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertTermStatsEquals
argument_list|(
name|info
argument_list|,
name|leftTermsEnum
argument_list|,
name|rightTermsEnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|deep
condition|)
block|{
name|assertDocsAndPositionsEnumEquals
argument_list|(
name|info
argument_list|,
name|leftPositions
operator|=
name|leftTermsEnum
operator|.
name|docsAndPositions
argument_list|(
literal|null
argument_list|,
name|leftPositions
argument_list|)
argument_list|,
name|rightPositions
operator|=
name|rightTermsEnum
operator|.
name|docsAndPositions
argument_list|(
literal|null
argument_list|,
name|rightPositions
argument_list|)
argument_list|)
expr_stmt|;
name|assertDocsAndPositionsEnumEquals
argument_list|(
name|info
argument_list|,
name|leftPositions
operator|=
name|leftTermsEnum
operator|.
name|docsAndPositions
argument_list|(
name|randomBits
argument_list|,
name|leftPositions
argument_list|)
argument_list|,
name|rightPositions
operator|=
name|rightTermsEnum
operator|.
name|docsAndPositions
argument_list|(
name|randomBits
argument_list|,
name|rightPositions
argument_list|)
argument_list|)
expr_stmt|;
name|assertPositionsSkippingEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftTermsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|leftPositions
operator|=
name|leftTermsEnum
operator|.
name|docsAndPositions
argument_list|(
literal|null
argument_list|,
name|leftPositions
argument_list|)
argument_list|,
name|rightPositions
operator|=
name|rightTermsEnum
operator|.
name|docsAndPositions
argument_list|(
literal|null
argument_list|,
name|rightPositions
argument_list|)
argument_list|)
expr_stmt|;
name|assertPositionsSkippingEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftTermsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|leftPositions
operator|=
name|leftTermsEnum
operator|.
name|docsAndPositions
argument_list|(
name|randomBits
argument_list|,
name|leftPositions
argument_list|)
argument_list|,
name|rightPositions
operator|=
name|rightTermsEnum
operator|.
name|docsAndPositions
argument_list|(
name|randomBits
argument_list|,
name|rightPositions
argument_list|)
argument_list|)
expr_stmt|;
comment|// with freqs:
name|assertDocsEnumEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|=
name|leftTermsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|leftDocs
argument_list|)
argument_list|,
name|rightDocs
operator|=
name|rightTermsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|rightDocs
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertDocsEnumEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|=
name|leftTermsEnum
operator|.
name|docs
argument_list|(
name|randomBits
argument_list|,
name|leftDocs
argument_list|)
argument_list|,
name|rightDocs
operator|=
name|rightTermsEnum
operator|.
name|docs
argument_list|(
name|randomBits
argument_list|,
name|rightDocs
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// w/o freqs:
name|assertDocsEnumEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|=
name|leftTermsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|leftDocs
argument_list|,
name|DocsEnum
operator|.
name|FLAG_NONE
argument_list|)
argument_list|,
name|rightDocs
operator|=
name|rightTermsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|rightDocs
argument_list|,
name|DocsEnum
operator|.
name|FLAG_NONE
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertDocsEnumEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|=
name|leftTermsEnum
operator|.
name|docs
argument_list|(
name|randomBits
argument_list|,
name|leftDocs
argument_list|,
name|DocsEnum
operator|.
name|FLAG_NONE
argument_list|)
argument_list|,
name|rightDocs
operator|=
name|rightTermsEnum
operator|.
name|docs
argument_list|(
name|randomBits
argument_list|,
name|rightDocs
argument_list|,
name|DocsEnum
operator|.
name|FLAG_NONE
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// with freqs:
name|assertDocsSkippingEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftTermsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|leftDocs
operator|=
name|leftTermsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|leftDocs
argument_list|)
argument_list|,
name|rightDocs
operator|=
name|rightTermsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|rightDocs
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertDocsSkippingEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftTermsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|leftDocs
operator|=
name|leftTermsEnum
operator|.
name|docs
argument_list|(
name|randomBits
argument_list|,
name|leftDocs
argument_list|)
argument_list|,
name|rightDocs
operator|=
name|rightTermsEnum
operator|.
name|docs
argument_list|(
name|randomBits
argument_list|,
name|rightDocs
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// w/o freqs:
name|assertDocsSkippingEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftTermsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|leftDocs
operator|=
name|leftTermsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|leftDocs
argument_list|,
name|DocsEnum
operator|.
name|FLAG_NONE
argument_list|)
argument_list|,
name|rightDocs
operator|=
name|rightTermsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|rightDocs
argument_list|,
name|DocsEnum
operator|.
name|FLAG_NONE
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertDocsSkippingEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftTermsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|leftDocs
operator|=
name|leftTermsEnum
operator|.
name|docs
argument_list|(
name|randomBits
argument_list|,
name|leftDocs
argument_list|,
name|DocsEnum
operator|.
name|FLAG_NONE
argument_list|)
argument_list|,
name|rightDocs
operator|=
name|rightTermsEnum
operator|.
name|docs
argument_list|(
name|randomBits
argument_list|,
name|rightDocs
argument_list|,
name|DocsEnum
operator|.
name|FLAG_NONE
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightTermsEnum
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * checks docs + freqs + positions + payloads, sequentially    */
DECL|method|assertDocsAndPositionsEnumEquals
specifier|public
name|void
name|assertDocsAndPositionsEnumEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|DocsAndPositionsEnum
name|leftDocs
parameter_list|,
name|DocsAndPositionsEnum
name|rightDocs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|leftDocs
operator|==
literal|null
operator|||
name|rightDocs
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|leftDocs
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|rightDocs
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertEquals
argument_list|(
name|info
argument_list|,
operator|-
literal|1
argument_list|,
name|leftDocs
operator|.
name|docID
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
operator|-
literal|1
argument_list|,
name|rightDocs
operator|.
name|docID
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|docid
decl_stmt|;
while|while
condition|(
operator|(
name|docid
operator|=
name|leftDocs
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|docid
argument_list|,
name|rightDocs
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|freq
init|=
name|leftDocs
operator|.
name|freq
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|freq
argument_list|,
name|rightDocs
operator|.
name|freq
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|freq
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|.
name|nextPosition
argument_list|()
argument_list|,
name|rightDocs
operator|.
name|nextPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|.
name|getPayload
argument_list|()
argument_list|,
name|rightDocs
operator|.
name|getPayload
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|.
name|startOffset
argument_list|()
argument_list|,
name|rightDocs
operator|.
name|startOffset
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|.
name|endOffset
argument_list|()
argument_list|,
name|rightDocs
operator|.
name|endOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
name|info
argument_list|,
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
argument_list|,
name|rightDocs
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * checks docs + freqs, sequentially    */
DECL|method|assertDocsEnumEquals
specifier|public
name|void
name|assertDocsEnumEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|DocsEnum
name|leftDocs
parameter_list|,
name|DocsEnum
name|rightDocs
parameter_list|,
name|boolean
name|hasFreqs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|leftDocs
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|rightDocs
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertEquals
argument_list|(
name|info
argument_list|,
operator|-
literal|1
argument_list|,
name|leftDocs
operator|.
name|docID
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
operator|-
literal|1
argument_list|,
name|rightDocs
operator|.
name|docID
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|docid
decl_stmt|;
while|while
condition|(
operator|(
name|docid
operator|=
name|leftDocs
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|docid
argument_list|,
name|rightDocs
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasFreqs
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|.
name|freq
argument_list|()
argument_list|,
name|rightDocs
operator|.
name|freq
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
name|info
argument_list|,
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
argument_list|,
name|rightDocs
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * checks advancing docs    */
DECL|method|assertDocsSkippingEquals
specifier|public
name|void
name|assertDocsSkippingEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|int
name|docFreq
parameter_list|,
name|DocsEnum
name|leftDocs
parameter_list|,
name|DocsEnum
name|rightDocs
parameter_list|,
name|boolean
name|hasFreqs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|leftDocs
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|rightDocs
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|docid
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|averageGap
init|=
name|leftReader
operator|.
name|maxDoc
argument_list|()
operator|/
operator|(
literal|1
operator|+
name|docFreq
operator|)
decl_stmt|;
name|int
name|skipInterval
init|=
literal|16
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// nextDoc()
name|docid
operator|=
name|leftDocs
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|docid
argument_list|,
name|rightDocs
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// advance()
name|int
name|skip
init|=
name|docid
operator|+
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|skipInterval
operator|+
name|random
argument_list|()
operator|.
name|nextGaussian
argument_list|()
operator|*
name|averageGap
argument_list|)
argument_list|)
decl_stmt|;
name|docid
operator|=
name|leftDocs
operator|.
name|advance
argument_list|(
name|skip
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|docid
argument_list|,
name|rightDocs
operator|.
name|advance
argument_list|(
name|skip
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|docid
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|hasFreqs
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|.
name|freq
argument_list|()
argument_list|,
name|rightDocs
operator|.
name|freq
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * checks advancing docs + positions    */
DECL|method|assertPositionsSkippingEquals
specifier|public
name|void
name|assertPositionsSkippingEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|int
name|docFreq
parameter_list|,
name|DocsAndPositionsEnum
name|leftDocs
parameter_list|,
name|DocsAndPositionsEnum
name|rightDocs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|leftDocs
operator|==
literal|null
operator|||
name|rightDocs
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|leftDocs
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|rightDocs
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|docid
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|averageGap
init|=
name|leftReader
operator|.
name|maxDoc
argument_list|()
operator|/
operator|(
literal|1
operator|+
name|docFreq
operator|)
decl_stmt|;
name|int
name|skipInterval
init|=
literal|16
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// nextDoc()
name|docid
operator|=
name|leftDocs
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|docid
argument_list|,
name|rightDocs
operator|.
name|nextDoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// advance()
name|int
name|skip
init|=
name|docid
operator|+
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|skipInterval
operator|+
name|random
argument_list|()
operator|.
name|nextGaussian
argument_list|()
operator|*
name|averageGap
argument_list|)
argument_list|)
decl_stmt|;
name|docid
operator|=
name|leftDocs
operator|.
name|advance
argument_list|(
name|skip
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|docid
argument_list|,
name|rightDocs
operator|.
name|advance
argument_list|(
name|skip
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|docid
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
return|return;
block|}
name|int
name|freq
init|=
name|leftDocs
operator|.
name|freq
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|freq
argument_list|,
name|rightDocs
operator|.
name|freq
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|freq
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|.
name|nextPosition
argument_list|()
argument_list|,
name|rightDocs
operator|.
name|nextPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftDocs
operator|.
name|getPayload
argument_list|()
argument_list|,
name|rightDocs
operator|.
name|getPayload
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|assertTermsSeekingEquals
specifier|private
name|void
name|assertTermsSeekingEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|Terms
name|leftTerms
parameter_list|,
name|Terms
name|rightTerms
parameter_list|)
throws|throws
name|IOException
block|{
name|TermsEnum
name|leftEnum
init|=
literal|null
decl_stmt|;
name|TermsEnum
name|rightEnum
init|=
literal|null
decl_stmt|;
comment|// just an upper bound
name|int
name|numTests
init|=
name|atLeast
argument_list|(
literal|20
argument_list|)
decl_stmt|;
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
comment|// collect this number of terms from the left side
name|HashSet
argument_list|<
name|BytesRef
argument_list|>
name|tests
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|numPasses
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|numPasses
operator|<
literal|10
operator|&&
name|tests
operator|.
name|size
argument_list|()
operator|<
name|numTests
condition|)
block|{
name|leftEnum
operator|=
name|leftTerms
operator|.
name|iterator
argument_list|(
name|leftEnum
argument_list|)
expr_stmt|;
name|BytesRef
name|term
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|term
operator|=
name|leftEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|code
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
block|{
comment|// the term
name|tests
operator|.
name|add
argument_list|(
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|1
condition|)
block|{
comment|// truncated subsequence of term
name|term
operator|=
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// truncate it
name|term
operator|.
name|length
operator|=
name|random
operator|.
name|nextInt
argument_list|(
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|2
condition|)
block|{
comment|// term, but ensure a non-zero offset
name|byte
name|newbytes
index|[]
init|=
operator|new
name|byte
index|[
name|term
operator|.
name|length
operator|+
literal|5
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|term
operator|.
name|offset
argument_list|,
name|newbytes
argument_list|,
literal|5
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
name|tests
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|newbytes
argument_list|,
literal|5
argument_list|,
name|term
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|3
condition|)
block|{
switch|switch
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|tests
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|()
argument_list|)
expr_stmt|;
comment|// before the first term
break|break;
case|case
literal|1
case|:
name|tests
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|(
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
literal|0xFF
block|,
operator|(
name|byte
operator|)
literal|0xFF
block|}
argument_list|)
argument_list|)
expr_stmt|;
comment|// past the last term
break|break;
case|case
literal|2
case|:
name|tests
operator|.
name|add
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|TestUtil
operator|.
name|randomSimpleString
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// random term
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
block|}
name|numPasses
operator|++
expr_stmt|;
block|}
name|rightEnum
operator|=
name|rightTerms
operator|.
name|iterator
argument_list|(
name|rightEnum
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|BytesRef
argument_list|>
name|shuffledTests
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|tests
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|shuffledTests
argument_list|,
name|random
argument_list|)
expr_stmt|;
for|for
control|(
name|BytesRef
name|b
range|:
name|shuffledTests
control|)
block|{
if|if
condition|(
name|rarely
argument_list|()
condition|)
block|{
comment|// reuse the enums
name|leftEnum
operator|=
name|leftTerms
operator|.
name|iterator
argument_list|(
name|leftEnum
argument_list|)
expr_stmt|;
name|rightEnum
operator|=
name|rightTerms
operator|.
name|iterator
argument_list|(
name|rightEnum
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|seekExact
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|seekExact
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftEnum
operator|.
name|seekExact
argument_list|(
name|b
argument_list|)
argument_list|,
name|rightEnum
operator|.
name|seekExact
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SeekStatus
name|leftStatus
init|=
name|leftEnum
operator|.
name|seekCeil
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|SeekStatus
name|rightStatus
init|=
name|rightEnum
operator|.
name|seekCeil
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftStatus
argument_list|,
name|rightStatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftStatus
operator|!=
name|SeekStatus
operator|.
name|END
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftEnum
operator|.
name|term
argument_list|()
argument_list|,
name|rightEnum
operator|.
name|term
argument_list|()
argument_list|)
expr_stmt|;
name|assertTermStatsEquals
argument_list|(
name|info
argument_list|,
name|leftEnum
argument_list|,
name|rightEnum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * checks term-level statistics    */
DECL|method|assertTermStatsEquals
specifier|public
name|void
name|assertTermStatsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|TermsEnum
name|leftTermsEnum
parameter_list|,
name|TermsEnum
name|rightTermsEnum
parameter_list|)
throws|throws
name|IOException
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftTermsEnum
operator|.
name|docFreq
argument_list|()
argument_list|,
name|rightTermsEnum
operator|.
name|docFreq
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftTermsEnum
operator|.
name|totalTermFreq
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|rightTermsEnum
operator|.
name|totalTermFreq
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftTermsEnum
operator|.
name|totalTermFreq
argument_list|()
argument_list|,
name|rightTermsEnum
operator|.
name|totalTermFreq
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * checks that norms are the same across all fields     */
DECL|method|assertNormsEquals
specifier|public
name|void
name|assertNormsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|IndexReader
name|rightReader
parameter_list|)
throws|throws
name|IOException
block|{
name|Fields
name|leftFields
init|=
name|MultiFields
operator|.
name|getFields
argument_list|(
name|leftReader
argument_list|)
decl_stmt|;
name|Fields
name|rightFields
init|=
name|MultiFields
operator|.
name|getFields
argument_list|(
name|rightReader
argument_list|)
decl_stmt|;
comment|// Fields could be null if there are no postings,
comment|// but then it must be null for both
if|if
condition|(
name|leftFields
operator|==
literal|null
operator|||
name|rightFields
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftFields
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightFields
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|String
name|field
range|:
name|leftFields
control|)
block|{
name|NumericDocValues
name|leftNorms
init|=
name|MultiDocValues
operator|.
name|getNormValues
argument_list|(
name|leftReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|NumericDocValues
name|rightNorms
init|=
name|MultiDocValues
operator|.
name|getNormValues
argument_list|(
name|rightReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftNorms
operator|!=
literal|null
operator|&&
name|rightNorms
operator|!=
literal|null
condition|)
block|{
name|assertDocValuesEquals
argument_list|(
name|info
argument_list|,
name|leftReader
operator|.
name|maxDoc
argument_list|()
argument_list|,
name|leftNorms
argument_list|,
name|rightNorms
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftNorms
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightNorms
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**     * checks that stored fields of all documents are the same     */
DECL|method|assertStoredFieldsEquals
specifier|public
name|void
name|assertStoredFieldsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|IndexReader
name|rightReader
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|leftReader
operator|.
name|maxDoc
argument_list|()
operator|==
name|rightReader
operator|.
name|maxDoc
argument_list|()
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftReader
operator|.
name|maxDoc
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|StoredDocument
name|leftDoc
init|=
name|leftReader
operator|.
name|document
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|StoredDocument
name|rightDoc
init|=
name|rightReader
operator|.
name|document
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// TODO: I think this is bogus because we don't document what the order should be
comment|// from these iterators, etc. I think the codec/IndexReader should be free to order this stuff
comment|// in whatever way it wants (e.g. maybe it packs related fields together or something)
comment|// To fix this, we sort the fields in both documents by name, but
comment|// we still assume that all instances with same name are in order:
name|Comparator
argument_list|<
name|StorableField
argument_list|>
name|comp
init|=
operator|new
name|Comparator
argument_list|<
name|StorableField
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|StorableField
name|arg0
parameter_list|,
name|StorableField
name|arg1
parameter_list|)
block|{
return|return
name|arg0
operator|.
name|name
argument_list|()
operator|.
name|compareTo
argument_list|(
name|arg1
operator|.
name|name
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|leftDoc
operator|.
name|getFields
argument_list|()
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|rightDoc
operator|.
name|getFields
argument_list|()
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|StorableField
argument_list|>
name|leftIterator
init|=
name|leftDoc
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|StorableField
argument_list|>
name|rightIterator
init|=
name|rightDoc
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|leftIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|assertTrue
argument_list|(
name|info
argument_list|,
name|rightIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertStoredFieldEquals
argument_list|(
name|info
argument_list|,
name|leftIterator
operator|.
name|next
argument_list|()
argument_list|,
name|rightIterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|info
argument_list|,
name|rightIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * checks that two stored fields are equivalent     */
DECL|method|assertStoredFieldEquals
specifier|public
name|void
name|assertStoredFieldEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|StorableField
name|leftField
parameter_list|,
name|StorableField
name|rightField
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftField
operator|.
name|name
argument_list|()
argument_list|,
name|rightField
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftField
operator|.
name|binaryValue
argument_list|()
argument_list|,
name|rightField
operator|.
name|binaryValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftField
operator|.
name|stringValue
argument_list|()
argument_list|,
name|rightField
operator|.
name|stringValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftField
operator|.
name|numericValue
argument_list|()
argument_list|,
name|rightField
operator|.
name|numericValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: should we check the FT at all?
block|}
comment|/**     * checks that term vectors across all fields are equivalent     */
DECL|method|assertTermVectorsEquals
specifier|public
name|void
name|assertTermVectorsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|IndexReader
name|rightReader
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|leftReader
operator|.
name|maxDoc
argument_list|()
operator|==
name|rightReader
operator|.
name|maxDoc
argument_list|()
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftReader
operator|.
name|maxDoc
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Fields
name|leftFields
init|=
name|leftReader
operator|.
name|getTermVectors
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Fields
name|rightFields
init|=
name|rightReader
operator|.
name|getTermVectors
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|assertFieldsEquals
argument_list|(
name|info
argument_list|,
name|leftReader
argument_list|,
name|leftFields
argument_list|,
name|rightFields
argument_list|,
name|rarely
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getDVFields
specifier|private
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|getDVFields
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|fields
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldInfo
name|fi
range|:
name|MultiFields
operator|.
name|getMergedFieldInfos
argument_list|(
name|reader
argument_list|)
control|)
block|{
if|if
condition|(
name|fi
operator|.
name|getDocValuesType
argument_list|()
operator|!=
name|DocValuesType
operator|.
name|NONE
condition|)
block|{
name|fields
operator|.
name|add
argument_list|(
name|fi
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fields
return|;
block|}
comment|/**    * checks that docvalues across all fields are equivalent    */
DECL|method|assertDocValuesEquals
specifier|public
name|void
name|assertDocValuesEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|IndexReader
name|rightReader
parameter_list|)
throws|throws
name|IOException
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|leftFields
init|=
name|getDVFields
argument_list|(
name|leftReader
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|rightFields
init|=
name|getDVFields
argument_list|(
name|rightReader
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftFields
argument_list|,
name|rightFields
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|field
range|:
name|leftFields
control|)
block|{
comment|// TODO: clean this up... very messy
block|{
name|NumericDocValues
name|leftValues
init|=
name|MultiDocValues
operator|.
name|getNumericValues
argument_list|(
name|leftReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|NumericDocValues
name|rightValues
init|=
name|MultiDocValues
operator|.
name|getNumericValues
argument_list|(
name|rightReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftValues
operator|!=
literal|null
operator|&&
name|rightValues
operator|!=
literal|null
condition|)
block|{
name|assertDocValuesEquals
argument_list|(
name|info
argument_list|,
name|leftReader
operator|.
name|maxDoc
argument_list|()
argument_list|,
name|leftValues
argument_list|,
name|rightValues
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftValues
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightValues
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|BinaryDocValues
name|leftValues
init|=
name|MultiDocValues
operator|.
name|getBinaryValues
argument_list|(
name|leftReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|BinaryDocValues
name|rightValues
init|=
name|MultiDocValues
operator|.
name|getBinaryValues
argument_list|(
name|rightReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftValues
operator|!=
literal|null
operator|&&
name|rightValues
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|docID
init|=
literal|0
init|;
name|docID
operator|<
name|leftReader
operator|.
name|maxDoc
argument_list|()
condition|;
name|docID
operator|++
control|)
block|{
specifier|final
name|BytesRef
name|left
init|=
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|leftValues
operator|.
name|get
argument_list|(
name|docID
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|BytesRef
name|right
init|=
name|rightValues
operator|.
name|get
argument_list|(
name|docID
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftValues
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightValues
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|SortedDocValues
name|leftValues
init|=
name|MultiDocValues
operator|.
name|getSortedValues
argument_list|(
name|leftReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|SortedDocValues
name|rightValues
init|=
name|MultiDocValues
operator|.
name|getSortedValues
argument_list|(
name|rightReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftValues
operator|!=
literal|null
operator|&&
name|rightValues
operator|!=
literal|null
condition|)
block|{
comment|// numOrds
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftValues
operator|.
name|getValueCount
argument_list|()
argument_list|,
name|rightValues
operator|.
name|getValueCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// ords
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftValues
operator|.
name|getValueCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|BytesRef
name|left
init|=
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|leftValues
operator|.
name|lookupOrd
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|BytesRef
name|right
init|=
name|rightValues
operator|.
name|lookupOrd
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
comment|// bytes
for|for
control|(
name|int
name|docID
init|=
literal|0
init|;
name|docID
operator|<
name|leftReader
operator|.
name|maxDoc
argument_list|()
condition|;
name|docID
operator|++
control|)
block|{
specifier|final
name|BytesRef
name|left
init|=
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|leftValues
operator|.
name|get
argument_list|(
name|docID
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|BytesRef
name|right
init|=
name|rightValues
operator|.
name|get
argument_list|(
name|docID
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftValues
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightValues
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|SortedSetDocValues
name|leftValues
init|=
name|MultiDocValues
operator|.
name|getSortedSetValues
argument_list|(
name|leftReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|SortedSetDocValues
name|rightValues
init|=
name|MultiDocValues
operator|.
name|getSortedSetValues
argument_list|(
name|rightReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftValues
operator|!=
literal|null
operator|&&
name|rightValues
operator|!=
literal|null
condition|)
block|{
comment|// numOrds
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftValues
operator|.
name|getValueCount
argument_list|()
argument_list|,
name|rightValues
operator|.
name|getValueCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// ords
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftValues
operator|.
name|getValueCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|BytesRef
name|left
init|=
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|leftValues
operator|.
name|lookupOrd
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|BytesRef
name|right
init|=
name|rightValues
operator|.
name|lookupOrd
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
comment|// ord lists
for|for
control|(
name|int
name|docID
init|=
literal|0
init|;
name|docID
operator|<
name|leftReader
operator|.
name|maxDoc
argument_list|()
condition|;
name|docID
operator|++
control|)
block|{
name|leftValues
operator|.
name|setDocument
argument_list|(
name|docID
argument_list|)
expr_stmt|;
name|rightValues
operator|.
name|setDocument
argument_list|(
name|docID
argument_list|)
expr_stmt|;
name|long
name|ord
decl_stmt|;
while|while
condition|(
operator|(
name|ord
operator|=
name|leftValues
operator|.
name|nextOrd
argument_list|()
operator|)
operator|!=
name|SortedSetDocValues
operator|.
name|NO_MORE_ORDS
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|ord
argument_list|,
name|rightValues
operator|.
name|nextOrd
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|info
argument_list|,
name|SortedSetDocValues
operator|.
name|NO_MORE_ORDS
argument_list|,
name|rightValues
operator|.
name|nextOrd
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftValues
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightValues
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|SortedNumericDocValues
name|leftValues
init|=
name|MultiDocValues
operator|.
name|getSortedNumericValues
argument_list|(
name|leftReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|SortedNumericDocValues
name|rightValues
init|=
name|MultiDocValues
operator|.
name|getSortedNumericValues
argument_list|(
name|rightReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftValues
operator|!=
literal|null
operator|&&
name|rightValues
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftReader
operator|.
name|maxDoc
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|leftValues
operator|.
name|setDocument
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|long
name|expected
index|[]
init|=
operator|new
name|long
index|[
name|leftValues
operator|.
name|count
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|expected
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|expected
index|[
name|j
index|]
operator|=
name|leftValues
operator|.
name|valueAt
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
name|rightValues
operator|.
name|setDocument
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|expected
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|expected
index|[
name|j
index|]
argument_list|,
name|rightValues
operator|.
name|valueAt
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|info
argument_list|,
name|expected
operator|.
name|length
argument_list|,
name|rightValues
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftValues
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightValues
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|Bits
name|leftBits
init|=
name|MultiDocValues
operator|.
name|getDocsWithField
argument_list|(
name|leftReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|Bits
name|rightBits
init|=
name|MultiDocValues
operator|.
name|getDocsWithField
argument_list|(
name|rightReader
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftBits
operator|!=
literal|null
operator|&&
name|rightBits
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftBits
operator|.
name|length
argument_list|()
argument_list|,
name|rightBits
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftBits
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftBits
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|rightBits
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftBits
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightBits
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|assertDocValuesEquals
specifier|public
name|void
name|assertDocValuesEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|int
name|num
parameter_list|,
name|NumericDocValues
name|leftDocValues
parameter_list|,
name|NumericDocValues
name|rightDocValues
parameter_list|)
throws|throws
name|IOException
block|{
name|assertNotNull
argument_list|(
name|info
argument_list|,
name|leftDocValues
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|info
argument_list|,
name|rightDocValues
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|docID
init|=
literal|0
init|;
name|docID
operator|<
name|num
condition|;
name|docID
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|leftDocValues
operator|.
name|get
argument_list|(
name|docID
argument_list|)
argument_list|,
name|rightDocValues
operator|.
name|get
argument_list|(
name|docID
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: this is kinda stupid, we don't delete documents in the test.
DECL|method|assertDeletedDocsEquals
specifier|public
name|void
name|assertDeletedDocsEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|IndexReader
name|rightReader
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|leftReader
operator|.
name|numDeletedDocs
argument_list|()
operator|==
name|rightReader
operator|.
name|numDeletedDocs
argument_list|()
assert|;
name|Bits
name|leftBits
init|=
name|MultiFields
operator|.
name|getLiveDocs
argument_list|(
name|leftReader
argument_list|)
decl_stmt|;
name|Bits
name|rightBits
init|=
name|MultiFields
operator|.
name|getLiveDocs
argument_list|(
name|rightReader
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftBits
operator|==
literal|null
operator|||
name|rightBits
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
name|info
argument_list|,
name|leftBits
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|info
argument_list|,
name|rightBits
argument_list|)
expr_stmt|;
return|return;
block|}
assert|assert
name|leftReader
operator|.
name|maxDoc
argument_list|()
operator|==
name|rightReader
operator|.
name|maxDoc
argument_list|()
assert|;
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftBits
operator|.
name|length
argument_list|()
argument_list|,
name|rightBits
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftReader
operator|.
name|maxDoc
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|info
argument_list|,
name|leftBits
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|rightBits
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|assertFieldInfosEquals
specifier|public
name|void
name|assertFieldInfosEquals
parameter_list|(
name|String
name|info
parameter_list|,
name|IndexReader
name|leftReader
parameter_list|,
name|IndexReader
name|rightReader
parameter_list|)
throws|throws
name|IOException
block|{
name|FieldInfos
name|leftInfos
init|=
name|MultiFields
operator|.
name|getMergedFieldInfos
argument_list|(
name|leftReader
argument_list|)
decl_stmt|;
name|FieldInfos
name|rightInfos
init|=
name|MultiFields
operator|.
name|getMergedFieldInfos
argument_list|(
name|rightReader
argument_list|)
decl_stmt|;
comment|// TODO: would be great to verify more than just the names of the fields!
name|TreeSet
argument_list|<
name|String
argument_list|>
name|left
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|right
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldInfo
name|fi
range|:
name|leftInfos
control|)
block|{
name|left
operator|.
name|add
argument_list|(
name|fi
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|FieldInfo
name|fi
range|:
name|rightInfos
control|)
block|{
name|right
operator|.
name|add
argument_list|(
name|fi
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|info
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
comment|/** Returns true if the file exists (can be opened), false    *  if it cannot be opened, and (unlike Java's    *  File.exists) throws IOException if there's some    *  unexpected error. */
DECL|method|slowFileExists
specifier|public
specifier|static
name|boolean
name|slowFileExists
parameter_list|(
name|Directory
name|dir
parameter_list|,
name|String
name|fileName
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|dir
operator|.
name|openInput
argument_list|(
name|fileName
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFileException
decl||
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * This method is deprecated for a reason. Do not use it. Call {@link #createTempDir()}    * or {@link #createTempDir(String)} or {@link #createTempFile(String, String)}.    */
annotation|@
name|Deprecated
DECL|method|getBaseTempDirForTestClass
specifier|public
specifier|static
name|Path
name|getBaseTempDirForTestClass
parameter_list|()
block|{
return|return
name|tempFilesCleanupRule
operator|.
name|getPerTestClassTempDir
argument_list|()
return|;
block|}
comment|/**    * Creates an empty, temporary folder (when the name of the folder is of no importance).    *     * @see #createTempDir(String)    */
DECL|method|createTempDir
specifier|public
specifier|static
name|Path
name|createTempDir
parameter_list|()
block|{
return|return
name|createTempDir
argument_list|(
literal|"tempDir"
argument_list|)
return|;
block|}
comment|/**    * Creates an empty, temporary folder with the given name prefix under the     * test class's {@link #getBaseTempDirForTestClass()}.    *      *<p>The folder will be automatically removed after the    * test class completes successfully. The test should close any file handles that would prevent    * the folder from being removed.     */
DECL|method|createTempDir
specifier|public
specifier|static
name|Path
name|createTempDir
parameter_list|(
name|String
name|prefix
parameter_list|)
block|{
return|return
name|tempFilesCleanupRule
operator|.
name|createTempDir
argument_list|(
name|prefix
argument_list|)
return|;
block|}
comment|/**    * Creates an empty file with the given prefix and suffix under the     * test class's {@link #getBaseTempDirForTestClass()}.    *     *<p>The file will be automatically removed after the    * test class completes successfully. The test should close any file handles that would prevent    * the folder from being removed.     */
DECL|method|createTempFile
specifier|public
specifier|static
name|Path
name|createTempFile
parameter_list|(
name|String
name|prefix
parameter_list|,
name|String
name|suffix
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|tempFilesCleanupRule
operator|.
name|createTempFile
argument_list|(
name|prefix
argument_list|,
name|suffix
argument_list|)
return|;
block|}
comment|/**    * Creates an empty temporary file.    *     * @see #createTempFile(String, String)     */
DECL|method|createTempFile
specifier|public
specifier|static
name|Path
name|createTempFile
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|createTempFile
argument_list|(
literal|"tempFile"
argument_list|,
literal|".tmp"
argument_list|)
return|;
block|}
comment|/** True if assertions (-ea) are enabled (at least for this class). */
DECL|field|assertsAreEnabled
specifier|public
specifier|static
specifier|final
name|boolean
name|assertsAreEnabled
decl_stmt|;
static|static
block|{
name|boolean
name|enabled
init|=
literal|false
decl_stmt|;
assert|assert
name|enabled
operator|=
literal|true
assert|;
comment|// Intentional side-effect!!!
name|assertsAreEnabled
operator|=
name|enabled
expr_stmt|;
block|}
block|}
end_class
end_unit
