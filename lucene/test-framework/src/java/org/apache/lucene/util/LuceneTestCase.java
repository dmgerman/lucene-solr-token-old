begin_unit
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Documented
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|ElementType
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Inherited
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Retention
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|RetentionPolicy
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Target
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|PostingsFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|appending
operator|.
name|AppendingCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene3x
operator|.
name|PreFlexRWCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene40
operator|.
name|Lucene40Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|simpletext
operator|.
name|SimpleTextCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|AtomicReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CompositeReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldFilterAtomicReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
operator|.
name|ReaderClosedListener
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriterConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LogByteSizeMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LogDocMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LogMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MockRandomMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|ParallelAtomicReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|ParallelCompositeReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|RandomCodec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|RandomDocumentsWriterPerThreadPool
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SerialMergeScheduler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SlowCompositeReaderWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TieredMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|AssertingIndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FieldCache
operator|.
name|CacheEntry
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FieldCache
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|QueryUtils
operator|.
name|FCInvisibleMultiReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|RandomSimilarityProvider
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|DefaultSimilarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FlushInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|LockFactory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MergeInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MockDirectoryWrapper
operator|.
name|Throttling
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MockDirectoryWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|NRTCachingDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|FieldCacheSanityChecker
operator|.
name|Insanity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|AfterClass
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assume
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|ClassRule
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Rule
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|internal
operator|.
name|AssumptionViolatedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|RuleChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|TestRule
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|Description
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|RunWith
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|Runner
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|notification
operator|.
name|RunListener
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|model
operator|.
name|MultipleFailureException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|model
operator|.
name|Statement
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|JUnit4MethodProvider
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|MixWithSuiteName
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|RandomizedContext
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|RandomizedRunner
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|*
import|;
end_import
begin_comment
comment|/**  * Base class for all Lucene unit tests, Junit3 or Junit4 variant.  *<p>  *</p>  *<p>  * If you  * override either<code>setUp()</code> or  *<code>tearDown()</code> in your unit test, make sure you  * call<code>super.setUp()</code> and  *<code>super.tearDown()</code>  *</p>  *  *<code>@After</code> - replaces setup  *<code>@Before</code> - replaces teardown  *<code>@Test</code> - any public method with this annotation is a test case, regardless  * of its name  *<p>  *<p>  * See Junit4<a href="http://junit.org/junit/javadoc/4.7/">documentation</a> for a complete list of features.  *<p>  * Import from org.junit rather than junit.framework.  *<p>  * You should be able to use this class anywhere you used LuceneTestCase  * if you annotate your derived class correctly with the annotations above  * @see #assertSaneFieldCaches(String)  */
end_comment
begin_class
annotation|@
name|RunWith
argument_list|(
name|RandomizedRunner
operator|.
name|class
argument_list|)
annotation|@
name|TestMethodProviders
argument_list|(
block|{
name|LuceneJUnit3MethodProvider
operator|.
name|class
block|,
name|JUnit4MethodProvider
operator|.
name|class
block|}
argument_list|)
annotation|@
name|Validators
argument_list|(
block|{
name|RequireAssertions
operator|.
name|class
block|,
name|NoStaticHooksShadowing
operator|.
name|class
block|}
argument_list|)
annotation|@
name|SeedDecorators
argument_list|(
block|{
name|MixWithSuiteName
operator|.
name|class
block|}
argument_list|)
comment|// See LUCENE-3995 for rationale.
annotation|@
name|ThreadLeaks
argument_list|(
name|failTestIfLeaking
operator|=
literal|false
argument_list|)
DECL|class|LuceneTestCase
specifier|public
specifier|abstract
class|class
name|LuceneTestCase
extends|extends
name|Assert
block|{
comment|/**    * true if and only if tests are run in verbose mode. Note: if it is false, tests are not    * expected to print any messages.    */
DECL|field|VERBOSE
specifier|public
specifier|static
specifier|final
name|boolean
name|VERBOSE
init|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"tests.verbose"
argument_list|)
decl_stmt|;
DECL|field|INFOSTREAM
specifier|public
specifier|static
specifier|final
name|boolean
name|INFOSTREAM
init|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.infostream"
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|VERBOSE
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/** Use this constant when creating Analyzers and any other version-dependent stuff.    *<p><b>NOTE:</b> Change this when development starts for new Lucene version:    */
DECL|field|TEST_VERSION_CURRENT
specifier|public
specifier|static
specifier|final
name|Version
name|TEST_VERSION_CURRENT
init|=
name|Version
operator|.
name|LUCENE_40
decl_stmt|;
comment|/** Create indexes in this directory, optimally use a subdir, named after the test */
DECL|field|TEMP_DIR
specifier|public
specifier|static
specifier|final
name|File
name|TEMP_DIR
decl_stmt|;
static|static
block|{
name|String
name|s
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tempDir"
argument_list|,
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.io.tmpdir"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"To run tests, you need to define system property 'tempDir' or 'java.io.tmpdir'."
argument_list|)
throw|;
name|TEMP_DIR
operator|=
operator|new
name|File
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|TEMP_DIR
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
block|}
comment|/** set of directories we created, in afterclass we try to clean these up */
DECL|field|tempDirs
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|File
argument_list|,
name|StackTraceElement
index|[]
argument_list|>
name|tempDirs
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|File
argument_list|,
name|StackTraceElement
index|[]
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|// TODO: the fact these are static final means they're initialized on class load and they should
comment|// be reinitialized on before suite hooks (to allow proper tests).
comment|// by default we randomly pick a different codec for
comment|// each test case (non-J4 tests) and each test class (J4
comment|// tests)
comment|/** Gets the codec to run tests with. */
DECL|field|TEST_CODEC
specifier|public
specifier|static
specifier|final
name|String
name|TEST_CODEC
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.codec"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** Gets the postingsFormat to run tests with. */
DECL|field|TEST_POSTINGSFORMAT
specifier|public
specifier|static
specifier|final
name|String
name|TEST_POSTINGSFORMAT
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.postingsformat"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** Gets the directory to run tests with */
DECL|field|TEST_DIRECTORY
specifier|public
specifier|static
specifier|final
name|String
name|TEST_DIRECTORY
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.directory"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** Get the number of times to run tests */
DECL|field|TEST_ITER
specifier|public
specifier|static
specifier|final
name|int
name|TEST_ITER
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.iter"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
decl_stmt|;
comment|/** Get the minimum number of times to run tests until a failure happens */
DECL|field|TEST_ITER_MIN
specifier|public
specifier|static
specifier|final
name|int
name|TEST_ITER_MIN
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.iter.min"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|TEST_ITER
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/** whether or not @nightly tests should run */
DECL|field|TEST_NIGHTLY
specifier|public
specifier|static
specifier|final
name|boolean
name|TEST_NIGHTLY
init|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.nightly"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
comment|/** the line file used by LineFileDocs */
DECL|field|TEST_LINE_DOCS_FILE
specifier|public
specifier|static
specifier|final
name|String
name|TEST_LINE_DOCS_FILE
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.linedocsfile"
argument_list|,
literal|"europarl.lines.txt.gz"
argument_list|)
decl_stmt|;
comment|/** whether or not to clean threads between test invocations: "false", "perMethod", "perClass" */
DECL|field|TEST_CLEAN_THREADS
specifier|public
specifier|static
specifier|final
name|String
name|TEST_CLEAN_THREADS
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.cleanthreads"
argument_list|,
literal|"perClass"
argument_list|)
decl_stmt|;
comment|/** whether or not to clean threads between test invocations: "false", "perMethod", "perClass" */
DECL|field|TEST_THROTTLING
specifier|public
specifier|static
specifier|final
name|Throttling
name|TEST_THROTTLING
init|=
name|TEST_NIGHTLY
condition|?
name|Throttling
operator|.
name|SOMETIMES
else|:
name|Throttling
operator|.
name|NEVER
decl_stmt|;
comment|/** Gets the locale to run tests with */
DECL|field|TEST_LOCALE
specifier|public
specifier|static
name|String
name|TEST_LOCALE
decl_stmt|;
comment|/** Gets the timezone to run tests with */
DECL|field|TEST_TIMEZONE
specifier|public
specifier|static
name|String
name|TEST_TIMEZONE
decl_stmt|;
comment|/**    * A random multiplier which you should use when writing random tests:    * multiply it by the number of iterations    */
DECL|field|RANDOM_MULTIPLIER
specifier|public
specifier|static
specifier|final
name|int
name|RANDOM_MULTIPLIER
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.multiplier"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
decl_stmt|;
comment|/** @lucene.internal */
DECL|field|PREFLEX_IMPERSONATION_IS_ACTIVE
specifier|public
specifier|static
name|boolean
name|PREFLEX_IMPERSONATION_IS_ACTIVE
decl_stmt|;
comment|/**    * @see SubclassSetupTeardownRule      */
DECL|field|setupCalled
specifier|private
name|boolean
name|setupCalled
decl_stmt|;
comment|/**    * @see SubclassSetupTeardownRule    */
DECL|field|teardownCalled
specifier|private
name|boolean
name|teardownCalled
decl_stmt|;
DECL|field|savedBoolMaxClauseCount
specifier|private
name|int
name|savedBoolMaxClauseCount
init|=
name|BooleanQuery
operator|.
name|getMaxClauseCount
argument_list|()
decl_stmt|;
comment|/**    * Some tests expect the directory to contain a single segment, and want to do tests on that segment's reader.    * This is an utility method to help them.    */
DECL|method|getOnlySegmentReader
specifier|public
specifier|static
name|SegmentReader
name|getOnlySegmentReader
parameter_list|(
name|DirectoryReader
name|reader
parameter_list|)
block|{
name|IndexReader
index|[]
name|subReaders
init|=
name|reader
operator|.
name|getSequentialSubReaders
argument_list|()
decl_stmt|;
if|if
condition|(
name|subReaders
operator|.
name|length
operator|!=
literal|1
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|reader
operator|+
literal|" has "
operator|+
name|subReaders
operator|.
name|length
operator|+
literal|" segments instead of exactly one"
argument_list|)
throw|;
name|assertTrue
argument_list|(
name|subReaders
index|[
literal|0
index|]
operator|instanceof
name|SegmentReader
argument_list|)
expr_stmt|;
return|return
operator|(
name|SegmentReader
operator|)
name|subReaders
index|[
literal|0
index|]
return|;
block|}
comment|// default codec
DECL|field|savedCodec
specifier|private
specifier|static
name|Codec
name|savedCodec
decl_stmt|;
DECL|field|savedInfoStream
specifier|private
specifier|static
name|InfoStream
name|savedInfoStream
decl_stmt|;
DECL|field|similarity
specifier|private
specifier|static
name|Similarity
name|similarity
decl_stmt|;
DECL|field|locale
specifier|private
specifier|static
name|Locale
name|locale
decl_stmt|;
DECL|field|savedLocale
specifier|private
specifier|static
name|Locale
name|savedLocale
decl_stmt|;
DECL|field|timeZone
specifier|private
specifier|static
name|TimeZone
name|timeZone
decl_stmt|;
DECL|field|savedTimeZone
specifier|private
specifier|static
name|TimeZone
name|savedTimeZone
decl_stmt|;
comment|/**    * Restore these system property values in {@link #afterClassLuceneTestCaseJ4()}.    */
DECL|field|restoreProperties
specifier|private
specifier|static
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|restoreProperties
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|stores
specifier|protected
specifier|static
name|Map
argument_list|<
name|MockDirectoryWrapper
argument_list|,
name|StackTraceElement
index|[]
argument_list|>
name|stores
decl_stmt|;
DECL|field|testClassesRun
specifier|private
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|testClassesRun
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Access to the current {@link RandomizedContext}'s Random instance. It is safe to use    * this method from multiple threads, etc., but it should be called while within a runner's    * scope (so no static initializers). The returned {@link Random} instance will be     *<b>different</b> when this method is called inside a {@link BeforeClass} hook (static     * suite scope) and within {@link Before}/ {@link After} hooks or test methods.     *     *<p>The returned instance must not be shared with other threads or cross a single scope's     * boundary. For example, a {@link Random} acquired within a test method shouldn't be reused    * for another test case.    *     *<p>There is an overhead connected with getting the {@link Random} for a particular context    * and thread. It is better to cache the {@link Random} locally if tight loops with multiple    * invocations are present or create a derivative local {@link Random} for millions of calls     * like this:    *<pre>    * Random random = random();    * // tight loop with many invocations.     *</pre>    */
DECL|method|random
specifier|public
specifier|static
name|Random
name|random
parameter_list|()
block|{
return|return
name|RandomizedContext
operator|.
name|current
argument_list|()
operator|.
name|getRandom
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
DECL|field|icuTested
specifier|private
specifier|static
name|boolean
name|icuTested
init|=
literal|false
decl_stmt|;
comment|/**    * Stores the currently class under test.    */
DECL|field|classNameRule
specifier|private
specifier|static
specifier|final
name|StoreClassNameRule
name|classNameRule
init|=
operator|new
name|StoreClassNameRule
argument_list|()
decl_stmt|;
comment|/**    * Catch any uncaught exceptions on threads within the suite scope and fail the test/    * suite if they happen.    */
DECL|field|uncaughtExceptionsRule
specifier|private
specifier|static
specifier|final
name|UncaughtExceptionsRule
name|uncaughtExceptionsRule
init|=
operator|new
name|UncaughtExceptionsRule
argument_list|(
literal|null
argument_list|)
decl_stmt|;
comment|/**    * These property keys will be ignored in verification of altered properties.    * @see SystemPropertiesInvariantRule    * @see #ruleChain    * @see #classRules    */
DECL|field|ignoredInvariantProperties
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|ignoredInvariantProperties
init|=
block|{
literal|"user.timezone"
block|}
decl_stmt|;
comment|/**    * This controls how suite-level rules are nested. It is important that _all_ rules declared    * in {@link LuceneTestCase} are executed in proper order if they depend on each     * other.    */
annotation|@
name|ClassRule
DECL|field|classRules
specifier|public
specifier|static
name|TestRule
name|classRules
init|=
name|RuleChain
operator|.
name|outerRule
argument_list|(
operator|new
name|SystemPropertiesInvariantRule
argument_list|(
name|ignoredInvariantProperties
argument_list|)
argument_list|)
operator|.
name|around
argument_list|(
name|classNameRule
argument_list|)
operator|.
name|around
argument_list|(
name|uncaughtExceptionsRule
argument_list|)
decl_stmt|;
comment|/**    * This controls how individual test rules are nested. It is important that _all_ rules declared    * in {@link LuceneTestCase} are executed in proper order if they depend on each     * other.    */
annotation|@
name|Rule
DECL|field|ruleChain
specifier|public
specifier|final
name|TestRule
name|ruleChain
init|=
name|RuleChain
operator|.
name|outerRule
argument_list|(
operator|new
name|SaveThreadAndTestNameRule
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|UncaughtExceptionsRule
argument_list|(
name|this
argument_list|)
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|TestResultInterceptorRule
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|SystemPropertiesInvariantRule
argument_list|(
name|ignoredInvariantProperties
argument_list|)
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|InternalSetupTeardownRule
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|SubclassSetupTeardownRule
argument_list|()
argument_list|)
decl_stmt|;
annotation|@
name|BeforeClass
DECL|method|beforeClassLuceneTestCaseJ4
specifier|static
name|void
name|beforeClassLuceneTestCaseJ4
parameter_list|()
block|{
name|testClassesRun
operator|.
name|add
argument_list|(
name|getTestClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|tempDirs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|stores
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|IdentityHashMap
argument_list|<
name|MockDirectoryWrapper
argument_list|,
name|StackTraceElement
index|[]
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
comment|// enable this by default, for IDE consistency with ant tests (as its the default from ant)
comment|// TODO: really should be in solr base classes, but some extend LTC directly.
comment|// we do this in beforeClass, because some tests currently disable it
name|restoreProperties
operator|.
name|put
argument_list|(
literal|"solr.directoryFactory"
argument_list|,
name|System
operator|.
name|getProperty
argument_list|(
literal|"solr.directoryFactory"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"solr.directoryFactory"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|setProperty
argument_list|(
literal|"solr.directoryFactory"
argument_list|,
literal|"org.apache.solr.core.MockDirectoryFactory"
argument_list|)
expr_stmt|;
block|}
comment|// enable the Lucene 3.x PreflexRW codec explicitly, to work around bugs in IBM J9 / Harmony ServiceLoader:
try|try
block|{
specifier|final
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|spiLoaderField
init|=
name|Codec
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"loader"
argument_list|)
decl_stmt|;
name|spiLoaderField
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|Object
name|spiLoader
init|=
name|spiLoaderField
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|modifiableServicesField
init|=
name|NamedSPILoader
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"modifiableServices"
argument_list|)
decl_stmt|;
name|modifiableServicesField
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"rawtypes"
block|}
argument_list|)
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Codec
argument_list|>
name|serviceMap
init|=
operator|(
name|Map
operator|)
name|modifiableServicesField
operator|.
name|get
argument_list|(
name|spiLoader
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|Codec
operator|.
name|forName
argument_list|(
literal|"Lucene3x"
argument_list|)
operator|instanceof
name|PreFlexRWCodec
operator|)
condition|)
block|{
if|if
condition|(
name|Constants
operator|.
name|JAVA_VENDOR
operator|.
name|startsWith
argument_list|(
literal|"IBM"
argument_list|)
condition|)
block|{
comment|// definitely a buggy version
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"ERROR: Your VM's java.util.ServiceLoader implementation is buggy"
operator|+
literal|" and does not respect classpath order, please report this to the vendor."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// could just be a classpath issue
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"ERROR: fix your classpath to have tests-framework.jar before lucene-core.jar!"
operator|+
literal|" If you have already done this, then your VM's java.util.ServiceLoader implementation is buggy"
operator|+
literal|" and does not respect classpath order, please report this to the vendor."
argument_list|)
expr_stmt|;
block|}
name|serviceMap
operator|.
name|put
argument_list|(
literal|"Lucene3x"
argument_list|,
operator|new
name|PreFlexRWCodec
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot access internals of Codec and NamedSPILoader classes"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// if verbose: print some debugging stuff about which codecs are loaded
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|codecs
init|=
name|Codec
operator|.
name|availableCodecs
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|codec
range|:
name|codecs
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Loaded codec: '"
operator|+
name|codec
operator|+
literal|"': "
operator|+
name|Codec
operator|.
name|forName
argument_list|(
name|codec
argument_list|)
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|postingsFormats
init|=
name|PostingsFormat
operator|.
name|availablePostingsFormats
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|postingsFormat
range|:
name|postingsFormats
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Loaded postingsFormat: '"
operator|+
name|postingsFormat
operator|+
literal|"': "
operator|+
name|PostingsFormat
operator|.
name|forName
argument_list|(
name|postingsFormat
argument_list|)
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|savedInfoStream
operator|=
name|InfoStream
operator|.
name|getDefault
argument_list|()
expr_stmt|;
specifier|final
name|boolean
name|v
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|INFOSTREAM
condition|)
block|{
name|InfoStream
operator|.
name|setDefault
argument_list|(
operator|new
name|PrintStreamInfoStream
argument_list|(
name|System
operator|.
name|out
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|v
condition|)
block|{
name|InfoStream
operator|.
name|setDefault
argument_list|(
operator|new
name|NullInfoStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Class
argument_list|<
name|?
argument_list|>
name|targetClass
init|=
name|RandomizedContext
operator|.
name|current
argument_list|()
operator|.
name|getTargetClass
argument_list|()
decl_stmt|;
name|LuceneTestCase
operator|.
name|useNoMemoryExpensiveCodec
operator|=
name|targetClass
operator|.
name|isAnnotationPresent
argument_list|(
name|UseNoMemoryExpensiveCodec
operator|.
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|useNoMemoryExpensiveCodec
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"NOTE: Using no memory expensive codecs (Memory, SimpleText) for "
operator|+
name|targetClass
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
name|PREFLEX_IMPERSONATION_IS_ACTIVE
operator|=
literal|false
expr_stmt|;
name|savedCodec
operator|=
name|Codec
operator|.
name|getDefault
argument_list|()
expr_stmt|;
specifier|final
name|Codec
name|codec
decl_stmt|;
name|int
name|randomVal
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"Lucene3x"
operator|.
name|equals
argument_list|(
name|TEST_CODEC
argument_list|)
operator|||
operator|(
literal|"random"
operator|.
name|equals
argument_list|(
name|TEST_CODEC
argument_list|)
operator|&&
name|randomVal
operator|<
literal|2
operator|)
condition|)
block|{
comment|// preflex-only setup
name|codec
operator|=
name|Codec
operator|.
name|forName
argument_list|(
literal|"Lucene3x"
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|codec
operator|instanceof
name|PreFlexRWCodec
operator|)
operator|:
literal|"fix your classpath to have tests-framework.jar before lucene-core.jar"
assert|;
name|PREFLEX_IMPERSONATION_IS_ACTIVE
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"SimpleText"
operator|.
name|equals
argument_list|(
name|TEST_CODEC
argument_list|)
operator|||
operator|(
literal|"random"
operator|.
name|equals
argument_list|(
name|TEST_CODEC
argument_list|)
operator|&&
name|randomVal
operator|==
literal|9
operator|)
condition|)
block|{
name|codec
operator|=
operator|new
name|SimpleTextCodec
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"Appending"
operator|.
name|equals
argument_list|(
name|TEST_CODEC
argument_list|)
operator|||
operator|(
literal|"random"
operator|.
name|equals
argument_list|(
name|TEST_CODEC
argument_list|)
operator|&&
name|randomVal
operator|==
literal|8
operator|)
condition|)
block|{
name|codec
operator|=
operator|new
name|AppendingCodec
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
literal|"random"
operator|.
name|equals
argument_list|(
name|TEST_CODEC
argument_list|)
condition|)
block|{
name|codec
operator|=
name|Codec
operator|.
name|forName
argument_list|(
name|TEST_CODEC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"random"
operator|.
name|equals
argument_list|(
name|TEST_POSTINGSFORMAT
argument_list|)
condition|)
block|{
name|codec
operator|=
operator|new
name|RandomCodec
argument_list|(
name|random
argument_list|()
argument_list|,
name|useNoMemoryExpensiveCodec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|codec
operator|=
operator|new
name|Lucene40Codec
argument_list|()
block|{
specifier|private
specifier|final
name|PostingsFormat
name|format
init|=
name|PostingsFormat
operator|.
name|forName
argument_list|(
name|TEST_POSTINGSFORMAT
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|PostingsFormat
name|getPostingsFormatForField
parameter_list|(
name|String
name|field
parameter_list|)
block|{
return|return
name|format
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|format
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
expr_stmt|;
block|}
name|Codec
operator|.
name|setDefault
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|savedLocale
operator|=
name|Locale
operator|.
name|getDefault
argument_list|()
expr_stmt|;
comment|// START hack to init ICU safely before we randomize locales.
comment|// ICU fails during classloading when a special Java7-only locale is the default
comment|// see: http://bugs.icu-project.org/trac/ticket/8734
if|if
condition|(
operator|!
name|icuTested
condition|)
block|{
name|icuTested
operator|=
literal|true
expr_stmt|;
try|try
block|{
name|Locale
operator|.
name|setDefault
argument_list|(
name|Locale
operator|.
name|US
argument_list|)
expr_stmt|;
name|Class
operator|.
name|forName
argument_list|(
literal|"com.ibm.icu.util.ULocale"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnfe
parameter_list|)
block|{
comment|// ignore if no ICU is in classpath
block|}
block|}
comment|// END hack
comment|// Initialize locale/ timezone.
name|TEST_LOCALE
operator|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.locale"
argument_list|,
literal|"random"
argument_list|)
expr_stmt|;
name|TEST_TIMEZONE
operator|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.timezone"
argument_list|,
literal|"random"
argument_list|)
expr_stmt|;
comment|// Always pick a random one for consistency (whether TEST_LOCALE was specified or not).
name|Locale
name|randomLocale
init|=
name|randomLocale
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|locale
operator|=
name|TEST_LOCALE
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|?
name|randomLocale
else|:
name|localeForName
argument_list|(
name|TEST_LOCALE
argument_list|)
expr_stmt|;
name|Locale
operator|.
name|setDefault
argument_list|(
name|locale
argument_list|)
expr_stmt|;
comment|// TimeZone.getDefault will set user.timezone to the default timezone of the user's locale.
comment|// So store the original property value and restore it at end.
name|restoreProperties
operator|.
name|put
argument_list|(
literal|"user.timezone"
argument_list|,
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.timezone"
argument_list|)
argument_list|)
expr_stmt|;
name|savedTimeZone
operator|=
name|TimeZone
operator|.
name|getDefault
argument_list|()
expr_stmt|;
name|TimeZone
name|randomTimeZone
init|=
name|randomTimeZone
argument_list|(
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|timeZone
operator|=
name|TEST_TIMEZONE
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|?
name|randomTimeZone
else|:
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
name|TEST_TIMEZONE
argument_list|)
expr_stmt|;
name|TimeZone
operator|.
name|setDefault
argument_list|(
name|timeZone
argument_list|)
expr_stmt|;
name|similarity
operator|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|DefaultSimilarity
argument_list|()
else|:
operator|new
name|RandomSimilarityProvider
argument_list|(
name|random
argument_list|()
argument_list|)
expr_stmt|;
name|testsFailed
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|AfterClass
DECL|method|afterClassLuceneTestCaseJ4
specifier|static
name|void
name|afterClassLuceneTestCaseJ4
parameter_list|()
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|e
range|:
name|restoreProperties
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|clearProperty
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|setProperty
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|restoreProperties
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Throwable
name|problem
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
literal|"false"
operator|.
name|equals
argument_list|(
name|TEST_CLEAN_THREADS
argument_list|)
condition|)
block|{
name|int
name|rogueThreads
init|=
name|threadCleanup
argument_list|(
literal|"test class"
argument_list|)
decl_stmt|;
if|if
condition|(
name|rogueThreads
operator|>
literal|0
condition|)
block|{
comment|// TODO: fail here once the leaks are fixed.
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"RESOURCE LEAK: test class left "
operator|+
name|rogueThreads
operator|+
literal|" thread(s) running"
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|codecDescription
init|=
name|Codec
operator|.
name|getDefault
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Codec
operator|.
name|setDefault
argument_list|(
name|savedCodec
argument_list|)
expr_stmt|;
name|InfoStream
operator|.
name|setDefault
argument_list|(
name|savedInfoStream
argument_list|)
expr_stmt|;
name|Locale
operator|.
name|setDefault
argument_list|(
name|savedLocale
argument_list|)
expr_stmt|;
name|TimeZone
operator|.
name|setDefault
argument_list|(
name|savedTimeZone
argument_list|)
expr_stmt|;
name|System
operator|.
name|clearProperty
argument_list|(
literal|"solr.solr.home"
argument_list|)
expr_stmt|;
name|System
operator|.
name|clearProperty
argument_list|(
literal|"solr.data.dir"
argument_list|)
expr_stmt|;
try|try
block|{
comment|// now look for unclosed resources
if|if
condition|(
operator|!
name|testsFailed
condition|)
block|{
name|checkResourcesAfterClass
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|problem
operator|==
literal|null
condition|)
name|problem
operator|=
name|t
expr_stmt|;
block|}
name|stores
operator|=
literal|null
expr_stmt|;
try|try
block|{
comment|// clear out any temp directories if we can
if|if
condition|(
operator|!
name|testsFailed
condition|)
block|{
name|clearTempDirectoriesAfterClass
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|problem
operator|==
literal|null
condition|)
name|problem
operator|=
name|t
expr_stmt|;
block|}
comment|// if we had afterClass failures, get some debugging information
if|if
condition|(
name|problem
operator|!=
literal|null
condition|)
block|{
name|reportPartialFailureInfo
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|uncaughtExceptionsRule
operator|.
name|hasUncaughtExceptions
argument_list|()
condition|)
block|{
name|testsFailed
operator|=
literal|true
expr_stmt|;
block|}
comment|// if verbose or tests failed, report some information back
if|if
condition|(
name|VERBOSE
operator|||
name|testsFailed
operator|||
name|problem
operator|!=
literal|null
condition|)
block|{
name|printDebuggingInformation
argument_list|(
name|codecDescription
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|problem
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|problem
argument_list|)
throw|;
block|}
block|}
comment|/** print some useful debugging information about the environment */
DECL|method|printDebuggingInformation
specifier|private
specifier|static
name|void
name|printDebuggingInformation
parameter_list|(
name|String
name|codecDescription
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"NOTE: test params are: codec="
operator|+
name|codecDescription
operator|+
literal|", sim="
operator|+
name|similarity
operator|+
literal|", locale="
operator|+
name|locale
operator|+
literal|", timezone="
operator|+
operator|(
name|timeZone
operator|==
literal|null
condition|?
literal|"(null)"
else|:
name|timeZone
operator|.
name|getID
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"NOTE: all tests run in this JVM:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|Arrays
operator|.
name|toString
argument_list|(
name|testClassesRun
operator|.
name|toArray
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"NOTE: "
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.name"
argument_list|)
operator|+
literal|" "
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.version"
argument_list|)
operator|+
literal|" "
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.arch"
argument_list|)
operator|+
literal|"/"
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.vendor"
argument_list|)
operator|+
literal|" "
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.version"
argument_list|)
operator|+
literal|" "
operator|+
operator|(
name|Constants
operator|.
name|JRE_IS_64BIT
condition|?
literal|"(64-bit)"
else|:
literal|"(32-bit)"
operator|)
operator|+
literal|"/"
operator|+
literal|"cpus="
operator|+
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
operator|+
literal|","
operator|+
literal|"threads="
operator|+
name|Thread
operator|.
name|activeCount
argument_list|()
operator|+
literal|","
operator|+
literal|"free="
operator|+
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|freeMemory
argument_list|()
operator|+
literal|","
operator|+
literal|"total="
operator|+
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|totalMemory
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** check that directories and their resources were closed */
DECL|method|checkResourcesAfterClass
specifier|private
specifier|static
name|void
name|checkResourcesAfterClass
parameter_list|()
block|{
for|for
control|(
name|MockDirectoryWrapper
name|d
range|:
name|stores
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|d
operator|.
name|isOpen
argument_list|()
condition|)
block|{
name|StackTraceElement
name|elements
index|[]
init|=
name|stores
operator|.
name|get
argument_list|(
name|d
argument_list|)
decl_stmt|;
comment|// Look for the first class that is not LuceneTestCase that requested
comment|// a Directory. The first two items are of Thread's, so skipping over
comment|// them.
name|StackTraceElement
name|element
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|elements
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|StackTraceElement
name|ste
init|=
name|elements
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ste
operator|.
name|getClassName
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"LuceneTestCase"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|element
operator|=
name|ste
expr_stmt|;
break|break;
block|}
block|}
name|fail
argument_list|(
literal|"directory of test was not closed, opened from: "
operator|+
name|element
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** clear temp directories: this will fail if its not successful */
DECL|method|clearTempDirectoriesAfterClass
specifier|private
specifier|static
name|void
name|clearTempDirectoriesAfterClass
parameter_list|()
block|{
for|for
control|(
name|Entry
argument_list|<
name|File
argument_list|,
name|StackTraceElement
index|[]
argument_list|>
name|entry
range|:
name|tempDirs
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
name|_TestUtil
operator|.
name|rmDir
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"path "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|" allocated from"
argument_list|)
expr_stmt|;
comment|// first two STE's are Java's
name|StackTraceElement
index|[]
name|elements
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|elements
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|StackTraceElement
name|ste
init|=
name|elements
index|[
name|i
index|]
decl_stmt|;
comment|// print only our code's stack information
if|if
condition|(
name|ste
operator|.
name|getClassName
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"org.apache.lucene"
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"\t"
operator|+
name|ste
argument_list|)
expr_stmt|;
block|}
name|fail
argument_list|(
literal|"could not remove temp dir: "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|field|testsFailed
specifier|protected
specifier|static
name|boolean
name|testsFailed
decl_stmt|;
comment|/* true if any tests failed */
comment|/**    * Control the outcome of each test's output status (failure, assumption-failure). This    * would ideally be handled by attaching a {@link RunListener} to a {@link Runner} (because    * then we would be notified about static block failures).    * TODO: make this a test listener.    */
DECL|class|TestResultInterceptorRule
specifier|private
class|class
name|TestResultInterceptorRule
implements|implements
name|TestRule
block|{
annotation|@
name|Override
DECL|method|apply
specifier|public
name|Statement
name|apply
parameter_list|(
specifier|final
name|Statement
name|base
parameter_list|,
specifier|final
name|Description
name|description
parameter_list|)
block|{
return|return
operator|new
name|Statement
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|evaluate
parameter_list|()
throws|throws
name|Throwable
block|{
try|try
block|{
name|base
operator|.
name|evaluate
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssumptionViolatedException
name|t
parameter_list|)
block|{
throw|throw
name|t
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|failed
argument_list|(
name|t
argument_list|,
name|description
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
block|}
return|;
block|}
DECL|method|failed
specifier|private
name|void
name|failed
parameter_list|(
name|Throwable
name|e
parameter_list|,
name|Description
name|description
parameter_list|)
block|{
name|testsFailed
operator|=
literal|true
expr_stmt|;
name|reportAdditionalFailureInfo
argument_list|()
expr_stmt|;
assert|assert
operator|!
operator|(
name|e
operator|instanceof
name|AssumptionViolatedException
operator|)
assert|;
block|}
block|}
empty_stmt|;
comment|/**     * The thread executing the current test case.    * @see #isTestThread()    */
DECL|field|testCaseThread
specifier|volatile
name|Thread
name|testCaseThread
decl_stmt|;
comment|/**     * @see LuceneTestCase#testCaseThread     */
DECL|class|SaveThreadAndTestNameRule
specifier|private
class|class
name|SaveThreadAndTestNameRule
implements|implements
name|TestRule
block|{
DECL|field|previousName
specifier|private
name|String
name|previousName
decl_stmt|;
annotation|@
name|Override
DECL|method|apply
specifier|public
name|Statement
name|apply
parameter_list|(
specifier|final
name|Statement
name|base
parameter_list|,
specifier|final
name|Description
name|description
parameter_list|)
block|{
return|return
operator|new
name|Statement
argument_list|()
block|{
specifier|public
name|void
name|evaluate
parameter_list|()
throws|throws
name|Throwable
block|{
try|try
block|{
name|Thread
name|current
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
name|previousName
operator|=
name|current
operator|.
name|getName
argument_list|()
expr_stmt|;
name|LuceneTestCase
operator|.
name|this
operator|.
name|testCaseThread
operator|=
name|current
expr_stmt|;
name|LuceneTestCase
operator|.
name|this
operator|.
name|name
operator|=
name|description
operator|.
name|getMethodName
argument_list|()
expr_stmt|;
name|base
operator|.
name|evaluate
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|LuceneTestCase
operator|.
name|this
operator|.
name|testCaseThread
operator|.
name|setName
argument_list|(
name|previousName
argument_list|)
expr_stmt|;
name|LuceneTestCase
operator|.
name|this
operator|.
name|testCaseThread
operator|=
literal|null
expr_stmt|;
name|LuceneTestCase
operator|.
name|this
operator|.
name|name
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
block|}
comment|/**    * Internal {@link LuceneTestCase} setup before/after each test.    */
DECL|class|InternalSetupTeardownRule
specifier|private
class|class
name|InternalSetupTeardownRule
implements|implements
name|TestRule
block|{
annotation|@
name|Override
DECL|method|apply
specifier|public
name|Statement
name|apply
parameter_list|(
specifier|final
name|Statement
name|base
parameter_list|,
name|Description
name|description
parameter_list|)
block|{
return|return
operator|new
name|Statement
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|evaluate
parameter_list|()
throws|throws
name|Throwable
block|{
comment|// We simulate the previous behavior of @Before in that
comment|// if any statement below us fails, we just propagate the original
comment|// exception and do not call tearDownInternal.
name|setUpInternal
argument_list|()
expr_stmt|;
specifier|final
name|ArrayList
argument_list|<
name|Throwable
argument_list|>
name|errors
init|=
operator|new
name|ArrayList
argument_list|<
name|Throwable
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
comment|// But we will collect errors from statements below and wrap them
comment|// into a multiple so that tearDownInternal is called.
name|base
operator|.
name|evaluate
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|errors
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|tearDownInternal
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|errors
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|MultipleFailureException
operator|.
name|assertEmpty
argument_list|(
name|errors
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
comment|/**    * Setup before the tests.    */
DECL|method|setUpInternal
specifier|private
specifier|final
name|void
name|setUpInternal
parameter_list|()
throws|throws
name|Exception
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
literal|"LTC-main#seed="
operator|+
name|RandomizedContext
operator|.
name|current
argument_list|()
operator|.
name|getRunnerSeedAsString
argument_list|()
argument_list|)
expr_stmt|;
name|savedBoolMaxClauseCount
operator|=
name|BooleanQuery
operator|.
name|getMaxClauseCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|useNoMemoryExpensiveCodec
condition|)
block|{
name|String
name|defFormat
init|=
name|_TestUtil
operator|.
name|getPostingsFormat
argument_list|(
literal|"thisCodeMakesAbsolutelyNoSenseCanWeDeleteIt"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"SimpleText"
operator|.
name|equals
argument_list|(
name|defFormat
argument_list|)
operator|||
literal|"Memory"
operator|.
name|equals
argument_list|(
name|defFormat
argument_list|)
condition|)
block|{
name|assumeTrue
argument_list|(
literal|"NOTE: A test method in "
operator|+
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" was ignored, as it uses too much memory with "
operator|+
name|defFormat
operator|+
literal|"."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Forcible purges all cache entries from the FieldCache.    *<p>    * This method will be called by tearDown to clean up FieldCache.DEFAULT.    * If a (poorly written) test has some expectation that the FieldCache    * will persist across test methods (ie: a static IndexReader) this    * method can be overridden to do nothing.    *</p>    *    * @see FieldCache#purgeAllCaches()    */
DECL|method|purgeFieldCache
specifier|protected
name|void
name|purgeFieldCache
parameter_list|(
specifier|final
name|FieldCache
name|fc
parameter_list|)
block|{
name|fc
operator|.
name|purgeAllCaches
argument_list|()
expr_stmt|;
block|}
DECL|method|getTestLabel
specifier|protected
name|String
name|getTestLabel
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"."
operator|+
name|getName
argument_list|()
return|;
block|}
comment|/**    * Returns true if and only if the calling thread is the primary thread     * executing the test case.     */
DECL|method|isTestThread
specifier|protected
name|boolean
name|isTestThread
parameter_list|()
block|{
name|assertNotNull
argument_list|(
literal|"Test case thread not set?"
argument_list|,
name|testCaseThread
argument_list|)
expr_stmt|;
return|return
name|Thread
operator|.
name|currentThread
argument_list|()
operator|==
name|testCaseThread
return|;
block|}
comment|/**    * Make sure {@link #setUp()} and {@link #tearDown()} were invoked even if they    * have been overriden. We assume nobody will call these out of non-overriden    * methods (they have to be public by contract, unfortunately). The top-level    * methods just set a flag that is checked upon successful execution of each test    * case.    */
DECL|class|SubclassSetupTeardownRule
specifier|private
class|class
name|SubclassSetupTeardownRule
implements|implements
name|TestRule
block|{
annotation|@
name|Override
DECL|method|apply
specifier|public
name|Statement
name|apply
parameter_list|(
specifier|final
name|Statement
name|base
parameter_list|,
name|Description
name|description
parameter_list|)
block|{
return|return
operator|new
name|Statement
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|evaluate
parameter_list|()
throws|throws
name|Throwable
block|{
name|setupCalled
operator|=
literal|false
expr_stmt|;
name|teardownCalled
operator|=
literal|false
expr_stmt|;
name|base
operator|.
name|evaluate
argument_list|()
expr_stmt|;
comment|// I assume we don't want to check teardown chaining if something happens in the
comment|// test because this would obscure the original exception?
if|if
condition|(
operator|!
name|setupCalled
condition|)
block|{
name|Assert
operator|.
name|fail
argument_list|(
literal|"One of the overrides of setUp does not propagate the call."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|teardownCalled
condition|)
block|{
name|Assert
operator|.
name|fail
argument_list|(
literal|"One of the overrides of tearDown does not propagate the call."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
block|}
comment|/**    * For subclassing only. Overrides must call {@code super.setUp()}.    */
annotation|@
name|Before
DECL|method|setUp
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|setupCalled
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * For subclassing only. Overrides must call {@code super.tearDown()}.    */
annotation|@
name|After
DECL|method|tearDown
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
name|teardownCalled
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Clean up after tests.    */
DECL|method|tearDownInternal
specifier|private
specifier|final
name|void
name|tearDownInternal
parameter_list|()
throws|throws
name|Exception
block|{
name|Throwable
name|problem
init|=
literal|null
decl_stmt|;
name|BooleanQuery
operator|.
name|setMaxClauseCount
argument_list|(
name|savedBoolMaxClauseCount
argument_list|)
expr_stmt|;
comment|// this won't throw any exceptions or fail the test
comment|// if we change this, then change this logic
name|checkRogueThreadsAfter
argument_list|()
expr_stmt|;
try|try
block|{
comment|// calling assertSaneFieldCaches here isn't as useful as having test
comment|// classes call it directly from the scope where the index readers
comment|// are used, because they could be gc'ed just before this tearDown
comment|// method is called.
comment|//
comment|// But it's better then nothing.
comment|//
comment|// If you are testing functionality that you know for a fact
comment|// "violates" FieldCache sanity, then you should either explicitly
comment|// call purgeFieldCache at the end of your test method, or refactor
comment|// your Test class so that the inconsistant FieldCache usages are
comment|// isolated in distinct test methods
name|assertSaneFieldCaches
argument_list|(
name|getTestLabel
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|problem
operator|==
literal|null
condition|)
name|problem
operator|=
name|t
expr_stmt|;
block|}
name|purgeFieldCache
argument_list|(
name|FieldCache
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|problem
operator|!=
literal|null
condition|)
block|{
name|reportAdditionalFailureInfo
argument_list|()
expr_stmt|;
comment|// TODO: simply rethrow problem, without wrapping?
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|problem
argument_list|)
throw|;
block|}
block|}
comment|/** check if the test still has threads running, we don't want them to     *  fail in a subsequent test and pass the blame to the wrong test */
DECL|method|checkRogueThreadsAfter
specifier|private
name|void
name|checkRogueThreadsAfter
parameter_list|()
block|{
if|if
condition|(
literal|"perMethod"
operator|.
name|equals
argument_list|(
name|TEST_CLEAN_THREADS
argument_list|)
condition|)
block|{
name|int
name|rogueThreads
init|=
name|threadCleanup
argument_list|(
literal|"test method: '"
operator|+
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|testsFailed
operator|&&
name|rogueThreads
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"RESOURCE LEAK: test method: '"
operator|+
name|getName
argument_list|()
operator|+
literal|"' left "
operator|+
name|rogueThreads
operator|+
literal|" thread(s) running"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|field|THREAD_STOP_GRACE_MSEC
specifier|private
specifier|final
specifier|static
name|int
name|THREAD_STOP_GRACE_MSEC
init|=
literal|10
decl_stmt|;
comment|// jvm-wide list of 'rogue threads' we found, so they only get reported once.
DECL|field|rogueThreads
specifier|private
specifier|final
specifier|static
name|IdentityHashMap
argument_list|<
name|Thread
argument_list|,
name|Boolean
argument_list|>
name|rogueThreads
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|Thread
argument_list|,
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
comment|// just a hack for things like eclipse test-runner threads
for|for
control|(
name|Thread
name|t
range|:
name|Thread
operator|.
name|getAllStackTraces
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
name|rogueThreads
operator|.
name|put
argument_list|(
name|t
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TEST_ITER
operator|>
literal|1
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"WARNING: you are using -Dtests.iter=n where n> 1, not all tests support this option."
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Some may crash or fail: this is not a bug."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Looks for leftover running threads, trying to kill them off,    * so they don't fail future tests.    * returns the number of rogue threads that it found.    */
DECL|method|threadCleanup
specifier|private
specifier|static
name|int
name|threadCleanup
parameter_list|(
name|String
name|context
parameter_list|)
block|{
comment|// educated guess
name|Thread
index|[]
name|stillRunning
init|=
operator|new
name|Thread
index|[
name|Thread
operator|.
name|activeCount
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|threadCount
init|=
literal|0
decl_stmt|;
name|int
name|rogueCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|threadCount
operator|=
name|Thread
operator|.
name|enumerate
argument_list|(
name|stillRunning
argument_list|)
operator|)
operator|>
literal|1
condition|)
block|{
while|while
condition|(
name|threadCount
operator|==
name|stillRunning
operator|.
name|length
condition|)
block|{
comment|// truncated response
name|stillRunning
operator|=
operator|new
name|Thread
index|[
name|stillRunning
operator|.
name|length
operator|*
literal|2
index|]
expr_stmt|;
name|threadCount
operator|=
name|Thread
operator|.
name|enumerate
argument_list|(
name|stillRunning
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadCount
condition|;
name|i
operator|++
control|)
block|{
name|Thread
name|t
init|=
name|stillRunning
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|isAlive
argument_list|()
operator|&&
operator|!
name|rogueThreads
operator|.
name|containsKey
argument_list|(
name|t
argument_list|)
operator|&&
name|t
operator|!=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|&&
comment|/* its ok to keep your searcher across test cases */
operator|(
name|t
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"LuceneTestCase"
argument_list|)
operator|&&
name|context
operator|.
name|startsWith
argument_list|(
literal|"test method"
argument_list|)
operator|)
operator|==
literal|false
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"WARNING: "
operator|+
name|context
operator|+
literal|" left thread running: "
operator|+
name|t
argument_list|)
expr_stmt|;
name|rogueThreads
operator|.
name|put
argument_list|(
name|t
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|rogueCount
operator|++
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"LuceneTestCase"
argument_list|)
condition|)
block|{
comment|// TODO: should we fail here now? really test should be failing?
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"PLEASE CLOSE YOUR INDEXREADERS IN YOUR TEST!!!!"
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|// wait on the thread to die of natural causes
try|try
block|{
name|t
operator|.
name|join
argument_list|(
name|THREAD_STOP_GRACE_MSEC
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|// try to stop the thread:
name|t
operator|.
name|setUncaughtExceptionHandler
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|setDefaultUncaughtExceptionHandler
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"SyncThread"
argument_list|)
condition|)
comment|// avoid zookeeper jre crash
name|t
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|rogueCount
return|;
block|}
comment|/**    * Asserts that FieldCacheSanityChecker does not detect any    * problems with FieldCache.DEFAULT.    *<p>    * If any problems are found, they are logged to System.err    * (allong with the msg) when the Assertion is thrown.    *</p>    *<p>    * This method is called by tearDown after every test method,    * however IndexReaders scoped inside test methods may be garbage    * collected prior to this method being called, causing errors to    * be overlooked. Tests are encouraged to keep their IndexReaders    * scoped at the class level, or to explicitly call this method    * directly in the same scope as the IndexReader.    *</p>    *    * @see org.apache.lucene.util.FieldCacheSanityChecker    */
DECL|method|assertSaneFieldCaches
specifier|protected
name|void
name|assertSaneFieldCaches
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|)
block|{
specifier|final
name|CacheEntry
index|[]
name|entries
init|=
name|FieldCache
operator|.
name|DEFAULT
operator|.
name|getCacheEntries
argument_list|()
decl_stmt|;
name|Insanity
index|[]
name|insanity
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|insanity
operator|=
name|FieldCacheSanityChecker
operator|.
name|checkSanity
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|dumpArray
argument_list|(
name|msg
operator|+
literal|": FieldCache"
argument_list|,
name|entries
argument_list|,
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|assertEquals
argument_list|(
name|msg
operator|+
literal|": Insane FieldCache usage(s) found"
argument_list|,
literal|0
argument_list|,
name|insanity
operator|.
name|length
argument_list|)
expr_stmt|;
name|insanity
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
comment|// report this in the event of any exception/failure
comment|// if no failure, then insanity will be null anyway
if|if
condition|(
literal|null
operator|!=
name|insanity
condition|)
block|{
name|dumpArray
argument_list|(
name|msg
operator|+
literal|": Insane FieldCache usage(s)"
argument_list|,
name|insanity
argument_list|,
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns a number of at least<code>i</code>    *<p>    * The actual number returned will be influenced by whether {@link #TEST_NIGHTLY}    * is active and {@link #RANDOM_MULTIPLIER}, but also with some random fudge.    */
DECL|method|atLeast
specifier|public
specifier|static
name|int
name|atLeast
parameter_list|(
name|Random
name|random
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|int
name|min
init|=
operator|(
name|TEST_NIGHTLY
condition|?
literal|2
operator|*
name|i
else|:
name|i
operator|)
operator|*
name|RANDOM_MULTIPLIER
decl_stmt|;
name|int
name|max
init|=
name|min
operator|+
operator|(
name|min
operator|/
literal|2
operator|)
decl_stmt|;
return|return
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
return|;
block|}
DECL|method|atLeast
specifier|public
specifier|static
name|int
name|atLeast
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|atLeast
argument_list|(
name|random
argument_list|()
argument_list|,
name|i
argument_list|)
return|;
block|}
comment|/**    * Returns true if something should happen rarely,    *<p>    * The actual number returned will be influenced by whether {@link #TEST_NIGHTLY}    * is active and {@link #RANDOM_MULTIPLIER}.    */
DECL|method|rarely
specifier|public
specifier|static
name|boolean
name|rarely
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|int
name|p
init|=
name|TEST_NIGHTLY
condition|?
literal|10
else|:
literal|5
decl_stmt|;
name|p
operator|+=
operator|(
name|p
operator|*
name|Math
operator|.
name|log
argument_list|(
name|RANDOM_MULTIPLIER
argument_list|)
operator|)
expr_stmt|;
name|int
name|min
init|=
literal|100
operator|-
name|Math
operator|.
name|min
argument_list|(
name|p
argument_list|,
literal|50
argument_list|)
decl_stmt|;
comment|// never more than 50
return|return
name|random
operator|.
name|nextInt
argument_list|(
literal|100
argument_list|)
operator|>=
name|min
return|;
block|}
DECL|method|rarely
specifier|public
specifier|static
name|boolean
name|rarely
parameter_list|()
block|{
return|return
name|rarely
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|usually
specifier|public
specifier|static
name|boolean
name|usually
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
return|return
operator|!
name|rarely
argument_list|(
name|random
argument_list|)
return|;
block|}
DECL|method|usually
specifier|public
specifier|static
name|boolean
name|usually
parameter_list|()
block|{
return|return
name|usually
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|assumeTrue
specifier|public
specifier|static
name|void
name|assumeTrue
parameter_list|(
name|String
name|msg
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
name|Assume
operator|.
name|assumeNoException
argument_list|(
name|b
condition|?
literal|null
else|:
operator|new
name|InternalAssumptionViolatedException
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|assumeFalse
specifier|public
specifier|static
name|void
name|assumeFalse
parameter_list|(
name|String
name|msg
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
name|assumeTrue
argument_list|(
name|msg
argument_list|,
operator|!
name|b
argument_list|)
expr_stmt|;
block|}
DECL|method|assumeNoException
specifier|public
specifier|static
name|void
name|assumeNoException
parameter_list|(
name|String
name|msg
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|Assume
operator|.
name|assumeNoException
argument_list|(
name|e
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|InternalAssumptionViolatedException
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|asSet
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Set
argument_list|<
name|T
argument_list|>
name|asSet
parameter_list|(
name|T
modifier|...
name|args
parameter_list|)
block|{
return|return
operator|new
name|HashSet
argument_list|<
name|T
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|args
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Convenience method for logging an iterator.    *    * @param label  String logged before/after the items in the iterator    * @param iter   Each next() is toString()ed and logged on it's own line. If iter is null this is logged differnetly then an empty iterator.    * @param stream Stream to log messages to.    */
DECL|method|dumpIterator
specifier|public
specifier|static
name|void
name|dumpIterator
parameter_list|(
name|String
name|label
parameter_list|,
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
parameter_list|,
name|PrintStream
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|println
argument_list|(
literal|"*** BEGIN "
operator|+
name|label
operator|+
literal|" ***"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|iter
condition|)
block|{
name|stream
operator|.
name|println
argument_list|(
literal|" ... NULL ..."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|stream
operator|.
name|println
argument_list|(
name|iter
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|stream
operator|.
name|println
argument_list|(
literal|"*** END "
operator|+
name|label
operator|+
literal|" ***"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Convenience method for logging an array.  Wraps the array in an iterator and delegates    *    * @see #dumpIterator(String,Iterator,PrintStream)    */
DECL|method|dumpArray
specifier|public
specifier|static
name|void
name|dumpArray
parameter_list|(
name|String
name|label
parameter_list|,
name|Object
index|[]
name|objs
parameter_list|,
name|PrintStream
name|stream
parameter_list|)
block|{
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
init|=
operator|(
literal|null
operator|==
name|objs
operator|)
condition|?
literal|null
else|:
name|Arrays
operator|.
name|asList
argument_list|(
name|objs
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|dumpIterator
argument_list|(
name|label
argument_list|,
name|iter
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/** create a new index writer config with random defaults */
DECL|method|newIndexWriterConfig
specifier|public
specifier|static
name|IndexWriterConfig
name|newIndexWriterConfig
parameter_list|(
name|Version
name|v
parameter_list|,
name|Analyzer
name|a
parameter_list|)
block|{
return|return
name|newIndexWriterConfig
argument_list|(
name|random
argument_list|()
argument_list|,
name|v
argument_list|,
name|a
argument_list|)
return|;
block|}
comment|/** create a new index writer config with random defaults using the specified random */
DECL|method|newIndexWriterConfig
specifier|public
specifier|static
name|IndexWriterConfig
name|newIndexWriterConfig
parameter_list|(
name|Random
name|r
parameter_list|,
name|Version
name|v
parameter_list|,
name|Analyzer
name|a
parameter_list|)
block|{
name|IndexWriterConfig
name|c
init|=
operator|new
name|IndexWriterConfig
argument_list|(
name|v
argument_list|,
name|a
argument_list|)
decl_stmt|;
name|c
operator|.
name|setSimilarity
argument_list|(
name|similarity
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|c
operator|.
name|setMergeScheduler
argument_list|(
operator|new
name|SerialMergeScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// crazy value
name|c
operator|.
name|setMaxBufferedDocs
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|15
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// reasonable value
name|c
operator|.
name|setMaxBufferedDocs
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|16
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// crazy value
name|c
operator|.
name|setTermIndexInterval
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|?
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
literal|31
argument_list|)
else|:
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|129
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// reasonable value
name|c
operator|.
name|setTermIndexInterval
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|32
argument_list|,
literal|128
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|int
name|maxNumThreadStates
init|=
name|rarely
argument_list|(
name|r
argument_list|)
condition|?
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|5
argument_list|,
literal|20
argument_list|)
comment|// crazy value
else|:
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|)
decl_stmt|;
comment|// reasonable value
name|Method
name|setIndexerThreadPoolMethod
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Retrieve the package-private setIndexerThreadPool
comment|// method:
for|for
control|(
name|Method
name|m
range|:
name|IndexWriterConfig
operator|.
name|class
operator|.
name|getDeclaredMethods
argument_list|()
control|)
block|{
if|if
condition|(
name|m
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"setIndexerThreadPool"
argument_list|)
condition|)
block|{
name|m
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setIndexerThreadPoolMethod
operator|=
name|m
expr_stmt|;
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Should not happen?
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|setIndexerThreadPoolMethod
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"failed to lookup IndexWriterConfig.setIndexerThreadPool method"
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// random thread pool
name|setIndexerThreadPoolMethod
operator|.
name|invoke
argument_list|(
name|c
argument_list|,
operator|new
name|RandomDocumentsWriterPerThreadPool
argument_list|(
name|maxNumThreadStates
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// random thread pool
name|c
operator|.
name|setMaxThreadStates
argument_list|(
name|maxNumThreadStates
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|c
operator|.
name|setMergePolicy
argument_list|(
operator|new
name|MockRandomMergePolicy
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|c
operator|.
name|setMergePolicy
argument_list|(
name|newTieredMergePolicy
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|.
name|setMergePolicy
argument_list|(
name|newLogMergePolicy
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|c
operator|.
name|setReaderPooling
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|c
operator|.
name|setReaderTermsIndexDivisor
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|()
block|{
return|return
name|newLogMergePolicy
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newTieredMergePolicy
specifier|public
specifier|static
name|TieredMergePolicy
name|newTieredMergePolicy
parameter_list|()
block|{
return|return
name|newTieredMergePolicy
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|r
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|LogDocMergePolicy
argument_list|()
else|:
operator|new
name|LogByteSizeMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setUseCompoundFile
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|logmp
operator|.
name|setCalibrateSizeByDeletes
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|logmp
return|;
block|}
DECL|method|newTieredMergePolicy
specifier|public
specifier|static
name|TieredMergePolicy
name|newTieredMergePolicy
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
name|TieredMergePolicy
name|tmp
init|=
operator|new
name|TieredMergePolicy
argument_list|()
decl_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|setMaxMergeAtOnce
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setMaxMergeAtOnceExplicit
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|setMaxMergeAtOnce
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setMaxMergeAtOnceExplicit
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|setMaxMergedSegmentMB
argument_list|(
literal|0.2
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|2.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|setMaxMergedSegmentMB
argument_list|(
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|100
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|.
name|setFloorSegmentMB
argument_list|(
literal|0.2
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|2.0
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setForceMergeDeletesPctAllowed
argument_list|(
literal|0.0
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|30.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|setSegmentsPerTier
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|20
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|setSegmentsPerTier
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|.
name|setUseCompoundFile
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setNoCFSRatio
argument_list|(
literal|0.1
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|0.8
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setReclaimDeletesWeight
argument_list|(
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|(
name|boolean
name|useCFS
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|newLogMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setUseCompoundFile
argument_list|(
name|useCFS
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|(
name|boolean
name|useCFS
parameter_list|,
name|int
name|mergeFactor
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|newLogMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setUseCompoundFile
argument_list|(
name|useCFS
argument_list|)
expr_stmt|;
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|mergeFactor
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|(
name|int
name|mergeFactor
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|newLogMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|mergeFactor
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
comment|/**    * Returns a new Directory instance. Use this when the test does not    * care about the specific Directory implementation (most tests).    *<p>    * The Directory is wrapped with {@link MockDirectoryWrapper}.    * By default this means it will be picky, such as ensuring that you    * properly close it and all open files in your test. It will emulate    * some features of Windows, such as not allowing open files to be    * overwritten.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newDirectory
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|newDirectory
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a new Directory instance, using the specified random.    * See {@link #newDirectory()} for more information.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newDirectory
parameter_list|(
name|Random
name|r
parameter_list|)
throws|throws
name|IOException
block|{
name|Directory
name|impl
init|=
name|newDirectoryImpl
argument_list|(
name|r
argument_list|,
name|TEST_DIRECTORY
argument_list|)
decl_stmt|;
name|MockDirectoryWrapper
name|dir
init|=
operator|new
name|MockDirectoryWrapper
argument_list|(
name|r
argument_list|,
name|maybeNRTWrap
argument_list|(
name|r
argument_list|,
name|impl
argument_list|)
argument_list|)
decl_stmt|;
name|stores
operator|.
name|put
argument_list|(
name|dir
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getStackTrace
argument_list|()
argument_list|)
expr_stmt|;
name|dir
operator|.
name|setThrottling
argument_list|(
name|TEST_THROTTLING
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"NOTE: LuceneTestCase.newDirectory: returning "
operator|+
name|dir
argument_list|)
expr_stmt|;
block|}
return|return
name|dir
return|;
block|}
comment|/**    * Returns a new Directory instance, with contents copied from the    * provided directory. See {@link #newDirectory()} for more    * information.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newDirectory
parameter_list|(
name|Directory
name|d
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|newDirectory
argument_list|(
name|random
argument_list|()
argument_list|,
name|d
argument_list|)
return|;
block|}
comment|/** Returns a new FSDirectory instance over the given file, which must be a folder. */
DECL|method|newFSDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newFSDirectory
parameter_list|(
name|File
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|newFSDirectory
argument_list|(
name|f
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Returns a new FSDirectory instance over the given file, which must be a folder. */
DECL|method|newFSDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newFSDirectory
parameter_list|(
name|File
name|f
parameter_list|,
name|LockFactory
name|lf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|fsdirClass
init|=
name|TEST_DIRECTORY
decl_stmt|;
if|if
condition|(
name|fsdirClass
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
block|{
name|fsdirClass
operator|=
name|FS_DIRECTORIES
index|[
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|FS_DIRECTORIES
operator|.
name|length
argument_list|)
index|]
expr_stmt|;
block|}
name|Class
argument_list|<
name|?
extends|extends
name|FSDirectory
argument_list|>
name|clazz
decl_stmt|;
try|try
block|{
try|try
block|{
name|clazz
operator|=
name|CommandLineUtil
operator|.
name|loadFSDirectoryClass
argument_list|(
name|fsdirClass
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
comment|// TEST_DIRECTORY is not a sub-class of FSDirectory, so draw one at random
name|fsdirClass
operator|=
name|FS_DIRECTORIES
index|[
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|FS_DIRECTORIES
operator|.
name|length
argument_list|)
index|]
expr_stmt|;
name|clazz
operator|=
name|CommandLineUtil
operator|.
name|loadFSDirectoryClass
argument_list|(
name|fsdirClass
argument_list|)
expr_stmt|;
block|}
name|Directory
name|fsdir
init|=
name|newFSDirectoryImpl
argument_list|(
name|clazz
argument_list|,
name|f
argument_list|)
decl_stmt|;
name|MockDirectoryWrapper
name|dir
init|=
operator|new
name|MockDirectoryWrapper
argument_list|(
name|random
argument_list|()
argument_list|,
name|maybeNRTWrap
argument_list|(
name|random
argument_list|()
argument_list|,
name|fsdir
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lf
operator|!=
literal|null
condition|)
block|{
name|dir
operator|.
name|setLockFactory
argument_list|(
name|lf
argument_list|)
expr_stmt|;
block|}
name|stores
operator|.
name|put
argument_list|(
name|dir
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getStackTrace
argument_list|()
argument_list|)
expr_stmt|;
name|dir
operator|.
name|setThrottling
argument_list|(
name|TEST_THROTTLING
argument_list|)
expr_stmt|;
return|return
name|dir
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns a new Directory instance, using the specified random    * with contents copied from the provided directory. See     * {@link #newDirectory()} for more information.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newDirectory
parameter_list|(
name|Random
name|r
parameter_list|,
name|Directory
name|d
parameter_list|)
throws|throws
name|IOException
block|{
name|Directory
name|impl
init|=
name|newDirectoryImpl
argument_list|(
name|r
argument_list|,
name|TEST_DIRECTORY
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|d
operator|.
name|listAll
argument_list|()
control|)
block|{
name|d
operator|.
name|copy
argument_list|(
name|impl
argument_list|,
name|file
argument_list|,
name|file
argument_list|,
name|newIOContext
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MockDirectoryWrapper
name|dir
init|=
operator|new
name|MockDirectoryWrapper
argument_list|(
name|r
argument_list|,
name|maybeNRTWrap
argument_list|(
name|r
argument_list|,
name|impl
argument_list|)
argument_list|)
decl_stmt|;
name|stores
operator|.
name|put
argument_list|(
name|dir
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getStackTrace
argument_list|()
argument_list|)
expr_stmt|;
name|dir
operator|.
name|setThrottling
argument_list|(
name|TEST_THROTTLING
argument_list|)
expr_stmt|;
return|return
name|dir
return|;
block|}
DECL|method|maybeNRTWrap
specifier|private
specifier|static
name|Directory
name|maybeNRTWrap
parameter_list|(
name|Random
name|random
parameter_list|,
name|Directory
name|directory
parameter_list|)
block|{
if|if
condition|(
name|rarely
argument_list|(
name|random
argument_list|)
condition|)
block|{
return|return
operator|new
name|NRTCachingDirectory
argument_list|(
name|directory
argument_list|,
name|random
operator|.
name|nextDouble
argument_list|()
argument_list|,
name|random
operator|.
name|nextDouble
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|directory
return|;
block|}
block|}
DECL|method|newField
specifier|public
specifier|static
name|Field
name|newField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|FieldType
name|type
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|()
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|method|newField
specifier|public
specifier|static
name|Field
name|newField
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|FieldType
name|type
parameter_list|)
block|{
if|if
condition|(
name|usually
argument_list|(
name|random
argument_list|)
operator|||
operator|!
name|type
operator|.
name|indexed
argument_list|()
condition|)
block|{
comment|// most of the time, don't modify the params
return|return
operator|new
name|Field
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|// TODO: once all core& test codecs can index
comment|// offsets, sometimes randomly turn on offsets if we are
comment|// already indexing positions...
name|FieldType
name|newType
init|=
operator|new
name|FieldType
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newType
operator|.
name|stored
argument_list|()
operator|&&
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStored
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// randomly store it
block|}
if|if
condition|(
operator|!
name|newType
operator|.
name|storeTermVectors
argument_list|()
operator|&&
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStoreTermVectors
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newType
operator|.
name|storeTermVectorOffsets
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStoreTermVectorOffsets
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newType
operator|.
name|storeTermVectorPositions
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStoreTermVectorPositions
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: we need to do this, but smarter, ie, most of
comment|// the time we set the same value for a given field but
comment|// sometimes (rarely) we change it up:
comment|/*     if (newType.omitNorms()) {       newType.setOmitNorms(random.nextBoolean());     }     */
return|return
operator|new
name|Field
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|newType
argument_list|)
return|;
block|}
comment|/**     * Return a random Locale from the available locales on the system.    * @see "https://issues.apache.org/jira/browse/LUCENE-4020"    */
DECL|method|randomLocale
specifier|public
specifier|static
name|Locale
name|randomLocale
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|Locale
name|locales
index|[]
init|=
name|Locale
operator|.
name|getAvailableLocales
argument_list|()
decl_stmt|;
return|return
name|locales
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|locales
operator|.
name|length
argument_list|)
index|]
return|;
block|}
comment|/**     * Return a random TimeZone from the available timezones on the system    * @see "https://issues.apache.org/jira/browse/LUCENE-4020"     */
DECL|method|randomTimeZone
specifier|public
specifier|static
name|TimeZone
name|randomTimeZone
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|String
name|tzIds
index|[]
init|=
name|TimeZone
operator|.
name|getAvailableIDs
argument_list|()
decl_stmt|;
return|return
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
name|tzIds
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|tzIds
operator|.
name|length
argument_list|)
index|]
argument_list|)
return|;
block|}
comment|/** return a Locale object equivalent to its programmatic name */
DECL|method|localeForName
specifier|public
specifier|static
name|Locale
name|localeForName
parameter_list|(
name|String
name|localeName
parameter_list|)
block|{
name|String
name|elements
index|[]
init|=
name|localeName
operator|.
name|split
argument_list|(
literal|"\\_"
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|elements
operator|.
name|length
condition|)
block|{
case|case
literal|4
case|:
comment|/* fallthrough for special cases */
case|case
literal|3
case|:
return|return
operator|new
name|Locale
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|,
name|elements
index|[
literal|1
index|]
argument_list|,
name|elements
index|[
literal|2
index|]
argument_list|)
return|;
case|case
literal|2
case|:
return|return
operator|new
name|Locale
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|,
name|elements
index|[
literal|1
index|]
argument_list|)
return|;
case|case
literal|1
case|:
return|return
operator|new
name|Locale
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid Locale: "
operator|+
name|localeName
argument_list|)
throw|;
block|}
block|}
DECL|field|FS_DIRECTORIES
specifier|private
specifier|static
specifier|final
name|String
name|FS_DIRECTORIES
index|[]
init|=
block|{
literal|"SimpleFSDirectory"
block|,
literal|"NIOFSDirectory"
block|,
literal|"MMapDirectory"
block|}
decl_stmt|;
DECL|field|CORE_DIRECTORIES
specifier|private
specifier|static
specifier|final
name|String
name|CORE_DIRECTORIES
index|[]
init|=
block|{
literal|"RAMDirectory"
block|,
name|FS_DIRECTORIES
index|[
literal|0
index|]
block|,
name|FS_DIRECTORIES
index|[
literal|1
index|]
block|,
name|FS_DIRECTORIES
index|[
literal|2
index|]
block|}
decl_stmt|;
DECL|method|randomDirectory
specifier|public
specifier|static
name|String
name|randomDirectory
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
if|if
condition|(
name|rarely
argument_list|(
name|random
argument_list|)
condition|)
block|{
return|return
name|CORE_DIRECTORIES
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|CORE_DIRECTORIES
operator|.
name|length
argument_list|)
index|]
return|;
block|}
else|else
block|{
return|return
literal|"RAMDirectory"
return|;
block|}
block|}
DECL|method|newFSDirectoryImpl
specifier|private
specifier|static
name|Directory
name|newFSDirectoryImpl
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|FSDirectory
argument_list|>
name|clazz
parameter_list|,
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDirectory
name|d
init|=
literal|null
decl_stmt|;
try|try
block|{
name|d
operator|=
name|CommandLineUtil
operator|.
name|newFSDirectory
argument_list|(
name|clazz
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|d
operator|=
name|FSDirectory
operator|.
name|open
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
comment|/**    * Registers a temp directory that will be deleted when tests are done. This    * is used by {@link _TestUtil#getTempDir(String)} and    * {@link _TestUtil#unzip(File, File)}, so you should call these methods when    * possible.    */
DECL|method|registerTempDir
specifier|static
name|void
name|registerTempDir
parameter_list|(
name|File
name|tmpFile
parameter_list|)
block|{
name|tempDirs
operator|.
name|put
argument_list|(
name|tmpFile
operator|.
name|getAbsoluteFile
argument_list|()
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getStackTrace
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|newDirectoryImpl
specifier|static
name|Directory
name|newDirectoryImpl
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|clazzName
parameter_list|)
block|{
if|if
condition|(
name|clazzName
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
block|{
name|clazzName
operator|=
name|randomDirectory
argument_list|(
name|random
argument_list|)
expr_stmt|;
block|}
try|try
block|{
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Directory
argument_list|>
name|clazz
init|=
name|CommandLineUtil
operator|.
name|loadDirectoryClass
argument_list|(
name|clazzName
argument_list|)
decl_stmt|;
comment|// If it is a FSDirectory type, try its ctor(File)
if|if
condition|(
name|FSDirectory
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|clazz
argument_list|)
condition|)
block|{
specifier|final
name|File
name|dir
init|=
name|_TestUtil
operator|.
name|getTempDir
argument_list|(
literal|"index"
argument_list|)
decl_stmt|;
name|dir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
comment|// ensure it's created so we 'have' it.
return|return
name|newFSDirectoryImpl
argument_list|(
name|clazz
operator|.
name|asSubclass
argument_list|(
name|FSDirectory
operator|.
name|class
argument_list|)
argument_list|,
name|dir
argument_list|)
return|;
block|}
comment|// try empty ctor
return|return
name|clazz
operator|.
name|newInstance
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */
DECL|method|maybeWrapReader
specifier|public
specifier|static
name|IndexReader
name|maybeWrapReader
parameter_list|(
name|IndexReader
name|r
parameter_list|)
throws|throws
name|IOException
block|{
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
if|if
condition|(
name|rarely
argument_list|()
condition|)
block|{
comment|// TODO: remove this, and fix those tests to wrap before putting slow around:
specifier|final
name|boolean
name|wasOriginallyAtomic
init|=
name|r
operator|instanceof
name|AtomicReader
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|c
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|6
argument_list|)
operator|+
literal|1
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|4
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|r
operator|=
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|// will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:
name|r
operator|=
operator|(
name|r
operator|instanceof
name|AtomicReader
operator|)
condition|?
operator|new
name|ParallelAtomicReader
argument_list|(
operator|(
name|AtomicReader
operator|)
name|r
argument_list|)
else|:
operator|new
name|ParallelCompositeReader
argument_list|(
operator|(
name|CompositeReader
operator|)
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|// Hckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use
comment|// QueryUtils' reader with a fake cache key, so insanity checker cannot walk
comment|// along our reader:
name|r
operator|=
operator|new
name|FCInvisibleMultiReader
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
specifier|final
name|AtomicReader
name|ar
init|=
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|r
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|allFields
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldInfo
name|fi
range|:
name|ar
operator|.
name|getFieldInfos
argument_list|()
control|)
block|{
name|allFields
operator|.
name|add
argument_list|(
name|fi
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|shuffle
argument_list|(
name|allFields
argument_list|,
name|random
argument_list|)
expr_stmt|;
specifier|final
name|int
name|end
init|=
name|allFields
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|random
operator|.
name|nextInt
argument_list|(
name|allFields
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|fields
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|allFields
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|end
argument_list|)
argument_list|)
decl_stmt|;
comment|// will create no FC insanity as ParallelAtomicReader has own cache key:
name|r
operator|=
operator|new
name|ParallelAtomicReader
argument_list|(
operator|new
name|FieldFilterAtomicReader
argument_list|(
name|ar
argument_list|,
name|fields
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|FieldFilterAtomicReader
argument_list|(
name|ar
argument_list|,
name|fields
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fail
argument_list|(
literal|"should not get here"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wasOriginallyAtomic
condition|)
block|{
name|r
operator|=
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|r
operator|instanceof
name|CompositeReader
operator|)
operator|&&
operator|!
operator|(
name|r
operator|instanceof
name|FCInvisibleMultiReader
operator|)
condition|)
block|{
comment|// prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:
name|r
operator|=
operator|new
name|FCInvisibleMultiReader
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"maybeWrapReader wrapped: "
operator|+
name|r
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|r
return|;
block|}
comment|/** create a new searcher over the reader.    * This searcher might randomly use threads. */
DECL|method|newSearcher
specifier|public
specifier|static
name|IndexSearcher
name|newSearcher
parameter_list|(
name|IndexReader
name|r
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|newSearcher
argument_list|(
name|r
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** create a new searcher over the reader.    * This searcher might randomly use threads.    * if<code>maybeWrap</code> is true, this searcher might wrap the reader    * with one that returns null for getSequentialSubReaders.    */
DECL|method|newSearcher
specifier|public
specifier|static
name|IndexSearcher
name|newSearcher
parameter_list|(
name|IndexReader
name|r
parameter_list|,
name|boolean
name|maybeWrap
parameter_list|)
throws|throws
name|IOException
block|{
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
if|if
condition|(
name|usually
argument_list|()
condition|)
block|{
if|if
condition|(
name|maybeWrap
condition|)
block|{
name|r
operator|=
name|maybeWrapReader
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|IndexSearcher
name|ret
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|AssertingIndexSearcher
argument_list|(
name|random
argument_list|,
name|r
argument_list|)
else|:
operator|new
name|AssertingIndexSearcher
argument_list|(
name|random
argument_list|,
name|r
operator|.
name|getTopReaderContext
argument_list|()
argument_list|)
decl_stmt|;
name|ret
operator|.
name|setSimilarity
argument_list|(
name|similarity
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|int
name|threads
init|=
literal|0
decl_stmt|;
specifier|final
name|ThreadPoolExecutor
name|ex
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|ex
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|threads
operator|=
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ex
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
name|threads
argument_list|,
name|threads
argument_list|,
literal|0L
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|,
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
operator|new
name|NamedThreadFactory
argument_list|(
literal|"LuceneTestCase"
argument_list|)
argument_list|)
expr_stmt|;
comment|// uncomment to intensify LUCENE-3840
comment|// ex.prestartAllCoreThreads();
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"NOTE: newSearcher using ExecutorService with "
operator|+
name|threads
operator|+
literal|" threads"
argument_list|)
expr_stmt|;
block|}
name|r
operator|.
name|addReaderClosedListener
argument_list|(
operator|new
name|ReaderClosedListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onClose
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
block|{
name|shutdownExecutorService
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|IndexSearcher
name|ret
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|AssertingIndexSearcher
argument_list|(
name|random
argument_list|,
name|r
argument_list|,
name|ex
argument_list|)
else|:
operator|new
name|AssertingIndexSearcher
argument_list|(
name|random
argument_list|,
name|r
operator|.
name|getTopReaderContext
argument_list|()
argument_list|,
name|ex
argument_list|)
decl_stmt|;
name|ret
operator|.
name|setSimilarity
argument_list|(
name|similarity
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
DECL|method|shutdownExecutorService
specifier|static
name|void
name|shutdownExecutorService
parameter_list|(
name|ExecutorService
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
block|{
name|ex
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
name|ex
operator|.
name|awaitTermination
argument_list|(
literal|1000
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|this
operator|.
name|name
return|;
block|}
comment|/** Gets a resource from the classpath as {@link File}. This method should only be used,    * if a real file is needed. To get a stream, code should prefer    * {@link Class#getResourceAsStream} using {@code this.getClass()}.    */
DECL|method|getDataFile
specifier|protected
name|File
name|getDataFile
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
operator|new
name|File
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getResource
argument_list|(
name|name
argument_list|)
operator|.
name|toURI
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot find resource: "
operator|+
name|name
argument_list|)
throw|;
block|}
block|}
comment|// We get here from InterceptTestCaseEvents on the 'failed' event....
DECL|method|reportPartialFailureInfo
specifier|public
specifier|static
name|void
name|reportPartialFailureInfo
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"NOTE: reproduce with (hopefully): ant test "
operator|+
literal|"-Dtestcase"
operator|+
name|getTestClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" -Dtests.seed="
operator|+
name|RandomizedContext
operator|.
name|current
argument_list|()
operator|.
name|getRunnerSeedAsString
argument_list|()
operator|+
name|reproduceWithExtraParams
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// We get here from InterceptTestCaseEvents on the 'failed' event....
DECL|method|reportAdditionalFailureInfo
specifier|public
name|void
name|reportAdditionalFailureInfo
parameter_list|()
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"NOTE: reproduce with: ant test "
argument_list|)
operator|.
name|append
argument_list|(
literal|"-Dtestcase"
argument_list|)
operator|.
name|append
argument_list|(
name|getTestClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|getName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" -Dtests.method="
argument_list|)
operator|.
name|append
argument_list|(
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|" -Dtests.seed="
argument_list|)
operator|.
name|append
argument_list|(
name|RandomizedContext
operator|.
name|current
argument_list|()
operator|.
name|getRunnerSeedAsString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
name|reproduceWithExtraParams
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|b
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// extra params that were overridden needed to reproduce the command
DECL|method|reproduceWithExtraParams
specifier|private
specifier|static
name|String
name|reproduceWithExtraParams
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|locale
operator|!=
literal|null
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" -Dtests.locale="
argument_list|)
operator|.
name|append
argument_list|(
name|locale
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeZone
operator|!=
literal|null
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" -Dtests.timezone="
argument_list|)
operator|.
name|append
argument_list|(
name|timeZone
operator|.
name|getID
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_CODEC
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" -Dtests.codec="
argument_list|)
operator|.
name|append
argument_list|(
name|TEST_CODEC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_POSTINGSFORMAT
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" -Dtests.postingsformat="
argument_list|)
operator|.
name|append
argument_list|(
name|TEST_POSTINGSFORMAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_DIRECTORY
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" -Dtests.directory="
argument_list|)
operator|.
name|append
argument_list|(
name|TEST_DIRECTORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|RANDOM_MULTIPLIER
operator|>
literal|1
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" -Dtests.multiplier="
argument_list|)
operator|.
name|append
argument_list|(
name|RANDOM_MULTIPLIER
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEST_NIGHTLY
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|" -Dtests.nightly=true"
argument_list|)
expr_stmt|;
comment|// TODO we can't randomize this yet (it drives ant crazy) but this makes tests reproduceable
comment|// in case machines have different default charsets...
name|sb
operator|.
name|append
argument_list|(
literal|" -Dargs=\"-Dfile.encoding="
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.encoding"
argument_list|)
operator|+
literal|"\""
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|newIOContext
specifier|public
specifier|static
name|IOContext
name|newIOContext
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
specifier|final
name|int
name|randomNumDocs
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|4192
argument_list|)
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|512
argument_list|)
operator|*
name|randomNumDocs
decl_stmt|;
specifier|final
name|IOContext
name|context
decl_stmt|;
switch|switch
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|context
operator|=
name|IOContext
operator|.
name|DEFAULT
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|context
operator|=
name|IOContext
operator|.
name|READ
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|context
operator|=
name|IOContext
operator|.
name|READONCE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|context
operator|=
operator|new
name|IOContext
argument_list|(
operator|new
name|MergeInfo
argument_list|(
name|randomNumDocs
argument_list|,
name|size
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|context
operator|=
operator|new
name|IOContext
argument_list|(
operator|new
name|FlushInfo
argument_list|(
name|randomNumDocs
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|context
operator|=
name|IOContext
operator|.
name|DEFAULT
expr_stmt|;
block|}
return|return
name|context
return|;
block|}
comment|/**    * Return the current class being tested.    */
DECL|method|getTestClass
specifier|public
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|getTestClass
parameter_list|()
block|{
return|return
name|classNameRule
operator|.
name|getTestClass
argument_list|()
return|;
block|}
comment|// initialized by the TestRunner
DECL|field|useNoMemoryExpensiveCodec
specifier|static
name|boolean
name|useNoMemoryExpensiveCodec
decl_stmt|;
DECL|field|name
specifier|private
name|String
name|name
init|=
literal|"<unknown>"
decl_stmt|;
comment|/**    * Annotation for tests that should only be run during nightly builds.    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|false
argument_list|,
name|sysProperty
operator|=
literal|"tests.nightly"
argument_list|)
DECL|interface|Nightly
specifier|public
annotation_defn|@interface
name|Nightly
block|{}
comment|/**    * Annotation for tests that should only be run during weekly builds    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|false
argument_list|,
name|sysProperty
operator|=
literal|"tests.weekly"
argument_list|)
DECL|interface|Weekly
specifier|public
annotation_defn|@interface
name|Weekly
block|{}
comment|/**    * Annotation for tests which exhibit a known issue and are temporarily disabled.    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|false
argument_list|,
name|sysProperty
operator|=
literal|"tests.awaitsfix"
argument_list|)
DECL|interface|AwaitsFix
specifier|public
annotation_defn|@interface
name|AwaitsFix
block|{
comment|/** Point to JIRA entry. */
DECL|method|bugUrl
specifier|public
name|String
name|bugUrl
parameter_list|()
function_decl|;
block|}
comment|/**    * Annotation for tests that are slow and should be run only when specifically asked to run    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|false
argument_list|,
name|sysProperty
operator|=
literal|"tests.slow"
argument_list|)
DECL|interface|Slow
specifier|public
annotation_defn|@interface
name|Slow
block|{}
comment|/**    * Annotation for test classes that should only use codecs that are not memory expensive (avoid SimpleText, MemoryCodec).    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|Target
argument_list|(
name|ElementType
operator|.
name|TYPE
argument_list|)
DECL|interface|UseNoMemoryExpensiveCodec
specifier|public
annotation_defn|@interface
name|UseNoMemoryExpensiveCodec
block|{}
DECL|method|defaultCodecSupportsDocValues
specifier|protected
specifier|static
name|boolean
name|defaultCodecSupportsDocValues
parameter_list|()
block|{
return|return
operator|!
name|Codec
operator|.
name|getDefault
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"Lucene3x"
argument_list|)
return|;
block|}
block|}
end_class
end_unit
