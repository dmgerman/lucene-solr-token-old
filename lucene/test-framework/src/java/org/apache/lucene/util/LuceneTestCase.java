begin_unit
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|*
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
operator|.
name|Store
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FieldType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|StringField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|TextField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
operator|.
name|ReaderClosedListener
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FieldCache
operator|.
name|CacheEntry
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|QueryUtils
operator|.
name|FCInvisibleMultiReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MockDirectoryWrapper
operator|.
name|Throttling
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|FieldCacheSanityChecker
operator|.
name|Insanity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|RuleChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|TestRule
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|RunWith
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|*
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|annotations
operator|.
name|*
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|generators
operator|.
name|RandomPicks
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|rules
operator|.
name|SystemPropertiesInvariantRule
import|;
end_import
begin_import
import|import static
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|RandomizedTest
operator|.
name|systemPropertyAsBoolean
import|;
end_import
begin_import
import|import static
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|RandomizedTest
operator|.
name|systemPropertyAsInt
import|;
end_import
begin_comment
comment|/**  * Base class for all Lucene unit tests, Junit3 or Junit4 variant.  *   *<h3>Class and instance setup.</h3>  *   *<p>  * The preferred way to specify class (suite-level) setup/cleanup is to use  * static methods annotated with {@link BeforeClass} and {@link AfterClass}. Any  * code in these methods is executed within the test framework's control and  * ensure proper setup has been made.<b>Try not to use static initializers  * (including complex final field initializers).</b> Static initializers are  * executed before any setup rules are fired and may cause you (or somebody   * else) headaches.  *   *<p>  * For instance-level setup, use {@link Before} and {@link After} annotated  * methods. If you override either {@link #setUp()} or {@link #tearDown()} in  * your subclass, make sure you call<code>super.setUp()</code> and  *<code>super.tearDown()</code>. This is detected and enforced.  *   *<h3>Specifying test cases</h3>  *   *<p>  * Any test method with a<code>testXXX</code> prefix is considered a test case.  * Any test method annotated with {@link Test} is considered a test case.  *   *<h3>Randomized execution and test facilities</h3>  *   *<p>  * {@link LuceneTestCase} uses {@link RandomizedRunner} to execute test cases.  * {@link RandomizedRunner} has built-in support for tests randomization  * including access to a repeatable {@link Random} instance. See  * {@link #random()} method. Any test using {@link Random} acquired from  * {@link #random()} should be fully reproducible (assuming no race conditions  * between threads etc.). The initial seed for a test case is reported in many  * ways:  *<ul>  *<li>as part of any exception thrown from its body (inserted as a dummy stack  *   trace entry),</li>  *<li>as part of the main thread executing the test case (if your test hangs,  *   just dump the stack trace of all threads and you'll see the seed),</li>  *<li>the master seed can also be accessed manually by getting the current  *   context ({@link RandomizedContext#current()}) and then calling  *   {@link RandomizedContext#getRunnerSeedAsString()}.</li>  *</ul>  *   *<p>There is a number of other facilities tests can use, like:  *<ul>  *<li>{@link #closeAfterTest(Closeable)} and {@link #closeAfterSuite(Closeable)} to  *   register resources to be closed after each scope (if close fails, the scope  *   will fail too).</li>  *</ul>   */
end_comment
begin_class
annotation|@
name|RunWith
argument_list|(
name|RandomizedRunner
operator|.
name|class
argument_list|)
annotation|@
name|TestMethodProviders
argument_list|(
block|{
name|LuceneJUnit3MethodProvider
operator|.
name|class
block|,
name|JUnit4MethodProvider
operator|.
name|class
block|}
argument_list|)
annotation|@
name|Listeners
argument_list|(
block|{
name|RunListenerPrintReproduceInfo
operator|.
name|class
block|}
argument_list|)
annotation|@
name|SeedDecorators
argument_list|(
block|{
name|MixWithSuiteName
operator|.
name|class
block|}
argument_list|)
comment|// See LUCENE-3995 for rationale.
annotation|@
name|ThreadLeaks
argument_list|(
name|failTestIfLeaking
operator|=
literal|false
argument_list|)
DECL|class|LuceneTestCase
specifier|public
specifier|abstract
class|class
name|LuceneTestCase
extends|extends
name|Assert
block|{
comment|// --------------------------------------------------------------------
comment|// Test groups, system properties and other annotations modifying tests
comment|// --------------------------------------------------------------------
DECL|field|SYSPROP_NIGHTLY
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_NIGHTLY
init|=
literal|"tests.nightly"
decl_stmt|;
DECL|field|SYSPROP_WEEKLY
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_WEEKLY
init|=
literal|"tests.weekly"
decl_stmt|;
DECL|field|SYSPROP_AWAITSFIX
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_AWAITSFIX
init|=
literal|"tests.awaitsfix"
decl_stmt|;
DECL|field|SYSPROP_SLOW
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_SLOW
init|=
literal|"tests.slow"
decl_stmt|;
comment|/** @see #ignoreAfterMaxFailures*/
DECL|field|SYSPROP_MAXFAILURES
specifier|private
specifier|static
specifier|final
name|String
name|SYSPROP_MAXFAILURES
init|=
literal|"tests.maxfailures"
decl_stmt|;
comment|/** @see #ignoreAfterMaxFailures*/
DECL|field|SYSPROP_FAILFAST
specifier|private
specifier|static
specifier|final
name|String
name|SYSPROP_FAILFAST
init|=
literal|"tests.failfast"
decl_stmt|;
comment|/**    * Annotation for tests that should only be run during nightly builds.    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|false
argument_list|,
name|sysProperty
operator|=
name|SYSPROP_NIGHTLY
argument_list|)
DECL|interface|Nightly
specifier|public
annotation_defn|@interface
name|Nightly
block|{}
comment|/**    * Annotation for tests that should only be run during weekly builds    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|false
argument_list|,
name|sysProperty
operator|=
name|SYSPROP_WEEKLY
argument_list|)
DECL|interface|Weekly
specifier|public
annotation_defn|@interface
name|Weekly
block|{}
comment|/**    * Annotation for tests which exhibit a known issue and are temporarily disabled.    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|false
argument_list|,
name|sysProperty
operator|=
name|SYSPROP_AWAITSFIX
argument_list|)
DECL|interface|AwaitsFix
specifier|public
annotation_defn|@interface
name|AwaitsFix
block|{
comment|/** Point to JIRA entry. */
DECL|method|bugUrl
specifier|public
name|String
name|bugUrl
parameter_list|()
function_decl|;
block|}
comment|/**    * Annotation for tests that are slow. Slow tests do run by default but can be    * disabled if a quick run is needed.    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|TestGroup
argument_list|(
name|enabled
operator|=
literal|true
argument_list|,
name|sysProperty
operator|=
name|SYSPROP_SLOW
argument_list|)
DECL|interface|Slow
specifier|public
annotation_defn|@interface
name|Slow
block|{}
comment|/**    * Annotation for test classes that should avoid certain codec types    * (because they are expensive, for example).    */
annotation|@
name|Documented
annotation|@
name|Inherited
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
annotation|@
name|Target
argument_list|(
name|ElementType
operator|.
name|TYPE
argument_list|)
DECL|interface|SuppressCodecs
specifier|public
annotation_defn|@interface
name|SuppressCodecs
block|{
DECL|method|value
name|String
index|[]
name|value
parameter_list|()
function_decl|;
block|}
comment|// -----------------------------------------------------------------
comment|// Truly immutable fields and constants, initialized once and valid
comment|// for all suites ever since.
comment|// -----------------------------------------------------------------
comment|/**     * Use this constant when creating Analyzers and any other version-dependent stuff.    *<p><b>NOTE:</b> Change this when development starts for new Lucene version:    */
DECL|field|TEST_VERSION_CURRENT
specifier|public
specifier|static
specifier|final
name|Version
name|TEST_VERSION_CURRENT
init|=
name|Version
operator|.
name|LUCENE_50
decl_stmt|;
comment|/**    * True if and only if tests are run in verbose mode. If this flag is false    * tests are not expected to print any messages.    */
DECL|field|VERBOSE
specifier|public
specifier|static
specifier|final
name|boolean
name|VERBOSE
init|=
name|systemPropertyAsBoolean
argument_list|(
literal|"tests.verbose"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** TODO: javadoc? */
DECL|field|INFOSTREAM
specifier|public
specifier|static
specifier|final
name|boolean
name|INFOSTREAM
init|=
name|systemPropertyAsBoolean
argument_list|(
literal|"tests.infostream"
argument_list|,
name|VERBOSE
argument_list|)
decl_stmt|;
comment|/**    * A random multiplier which you should use when writing random tests:    * multiply it by the number of iterations to scale your tests (for nightly builds).    */
DECL|field|RANDOM_MULTIPLIER
specifier|public
specifier|static
specifier|final
name|int
name|RANDOM_MULTIPLIER
init|=
name|systemPropertyAsInt
argument_list|(
literal|"tests.multiplier"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/** TODO: javadoc? */
DECL|field|DEFAULT_LINE_DOCS_FILE
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_LINE_DOCS_FILE
init|=
literal|"europarl.lines.txt.gz"
decl_stmt|;
comment|/** TODO: javadoc? */
DECL|field|JENKINS_LARGE_LINE_DOCS_FILE
specifier|public
specifier|static
specifier|final
name|String
name|JENKINS_LARGE_LINE_DOCS_FILE
init|=
literal|"enwiki.random.lines.txt"
decl_stmt|;
comment|/** Gets the codec to run tests with. */
DECL|field|TEST_CODEC
specifier|public
specifier|static
specifier|final
name|String
name|TEST_CODEC
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.codec"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** Gets the postingsFormat to run tests with. */
DECL|field|TEST_POSTINGSFORMAT
specifier|public
specifier|static
specifier|final
name|String
name|TEST_POSTINGSFORMAT
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.postingsformat"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** Gets the directory to run tests with */
DECL|field|TEST_DIRECTORY
specifier|public
specifier|static
specifier|final
name|String
name|TEST_DIRECTORY
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.directory"
argument_list|,
literal|"random"
argument_list|)
decl_stmt|;
comment|/** the line file used by LineFileDocs */
DECL|field|TEST_LINE_DOCS_FILE
specifier|public
specifier|static
specifier|final
name|String
name|TEST_LINE_DOCS_FILE
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tests.linedocsfile"
argument_list|,
name|DEFAULT_LINE_DOCS_FILE
argument_list|)
decl_stmt|;
comment|/** Whether or not {@link Nightly} tests should run. */
DECL|field|TEST_NIGHTLY
specifier|public
specifier|static
specifier|final
name|boolean
name|TEST_NIGHTLY
init|=
name|systemPropertyAsBoolean
argument_list|(
name|SYSPROP_NIGHTLY
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** Whether or not {@link Weekly} tests should run. */
DECL|field|TEST_WEEKLY
specifier|public
specifier|static
specifier|final
name|boolean
name|TEST_WEEKLY
init|=
name|systemPropertyAsBoolean
argument_list|(
name|SYSPROP_WEEKLY
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** Whether or not {@link AwaitsFix} tests should run. */
DECL|field|TEST_AWAITSFIX
specifier|public
specifier|static
specifier|final
name|boolean
name|TEST_AWAITSFIX
init|=
name|systemPropertyAsBoolean
argument_list|(
name|SYSPROP_AWAITSFIX
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** Whether or not {@link Slow} tests should run. */
DECL|field|TEST_SLOW
specifier|public
specifier|static
specifier|final
name|boolean
name|TEST_SLOW
init|=
name|systemPropertyAsBoolean
argument_list|(
name|SYSPROP_SLOW
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** Throttling, see {@link MockDirectoryWrapper#setThrottling(Throttling)}. */
DECL|field|TEST_THROTTLING
specifier|public
specifier|static
specifier|final
name|Throttling
name|TEST_THROTTLING
init|=
name|TEST_NIGHTLY
condition|?
name|Throttling
operator|.
name|SOMETIMES
else|:
name|Throttling
operator|.
name|NEVER
decl_stmt|;
comment|/** Create indexes in this directory, optimally use a subdir, named after the test */
DECL|field|TEMP_DIR
specifier|public
specifier|static
specifier|final
name|File
name|TEMP_DIR
decl_stmt|;
static|static
block|{
name|String
name|s
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"tempDir"
argument_list|,
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.io.tmpdir"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"To run tests, you need to define system property 'tempDir' or 'java.io.tmpdir'."
argument_list|)
throw|;
name|TEMP_DIR
operator|=
operator|new
name|File
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|TEMP_DIR
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
block|}
comment|/**    * These property keys will be ignored in verification of altered properties.    * @see SystemPropertiesInvariantRule    * @see #ruleChain    * @see #classRules    */
DECL|field|IGNORED_INVARIANT_PROPERTIES
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|IGNORED_INVARIANT_PROPERTIES
init|=
block|{
literal|"user.timezone"
block|}
decl_stmt|;
comment|/** Filesystem-based {@link Directory} implementations. */
DECL|field|FS_DIRECTORIES
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|FS_DIRECTORIES
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"SimpleFSDirectory"
argument_list|,
literal|"NIOFSDirectory"
argument_list|,
literal|"MMapDirectory"
argument_list|)
decl_stmt|;
comment|/** All {@link Directory} implementations. */
DECL|field|CORE_DIRECTORIES
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|CORE_DIRECTORIES
decl_stmt|;
static|static
block|{
name|CORE_DIRECTORIES
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|FS_DIRECTORIES
argument_list|)
expr_stmt|;
name|CORE_DIRECTORIES
operator|.
name|add
argument_list|(
literal|"RAMDirectory"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
DECL|field|doesntSupportOffsets
specifier|protected
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|doesntSupportOffsets
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"Lucene3x"
argument_list|,
literal|"MockFixedIntBlock"
argument_list|,
literal|"MockVariableIntBlock"
argument_list|,
literal|"MockSep"
argument_list|,
literal|"MockRandom"
argument_list|,
literal|"For"
argument_list|,
literal|"PFor"
argument_list|)
argument_list|)
decl_stmt|;
comment|// -----------------------------------------------------------------
comment|// Fields initialized in class or instance rules.
comment|// -----------------------------------------------------------------
comment|/**    * @lucene.internal     */
DECL|field|PREFLEX_IMPERSONATION_IS_ACTIVE
specifier|public
specifier|static
name|boolean
name|PREFLEX_IMPERSONATION_IS_ACTIVE
decl_stmt|;
comment|// -----------------------------------------------------------------
comment|// Class level (suite) rules.
comment|// -----------------------------------------------------------------
comment|/**    * Stores the currently class under test.    */
DECL|field|classNameRule
specifier|private
specifier|static
specifier|final
name|TestRuleStoreClassName
name|classNameRule
decl_stmt|;
comment|/**    * Class environment setup rule.    */
DECL|field|classEnvRule
specifier|static
specifier|final
name|TestRuleSetupAndRestoreClassEnv
name|classEnvRule
decl_stmt|;
comment|/**    * Suite failure marker (any error in the test or suite scope).    */
DECL|field|suiteFailureMarker
specifier|public
specifier|final
specifier|static
name|TestRuleMarkFailure
name|suiteFailureMarker
init|=
operator|new
name|TestRuleMarkFailure
argument_list|()
decl_stmt|;
comment|/**    * Ignore tests after hitting a designated number of initial failures.    */
DECL|field|ignoreAfterMaxFailures
specifier|final
specifier|static
name|TestRuleIgnoreAfterMaxFailures
name|ignoreAfterMaxFailures
decl_stmt|;
static|static
block|{
name|int
name|maxFailures
init|=
name|systemPropertyAsInt
argument_list|(
name|SYSPROP_MAXFAILURES
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
name|boolean
name|failFast
init|=
name|systemPropertyAsBoolean
argument_list|(
name|SYSPROP_FAILFAST
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|failFast
condition|)
block|{
if|if
condition|(
name|maxFailures
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|maxFailures
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|Logger
operator|.
name|getLogger
argument_list|(
name|LuceneTestCase
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|)
operator|.
name|warning
argument_list|(
literal|"Property '"
operator|+
name|SYSPROP_MAXFAILURES
operator|+
literal|"'="
operator|+
name|maxFailures
operator|+
literal|", 'failfast' is"
operator|+
literal|" ignored."
argument_list|)
expr_stmt|;
block|}
block|}
name|ignoreAfterMaxFailures
operator|=
operator|new
name|TestRuleIgnoreAfterMaxFailures
argument_list|(
name|maxFailures
argument_list|)
expr_stmt|;
block|}
comment|/**    * This controls how suite-level rules are nested. It is important that _all_ rules declared    * in {@link LuceneTestCase} are executed in proper order if they depend on each     * other.    */
annotation|@
name|ClassRule
DECL|field|classRules
specifier|public
specifier|static
name|TestRule
name|classRules
init|=
name|RuleChain
operator|.
name|outerRule
argument_list|(
operator|new
name|TestRuleIgnoreTestSuites
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
name|ignoreAfterMaxFailures
argument_list|)
operator|.
name|around
argument_list|(
name|suiteFailureMarker
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|TestRuleAssertionsRequired
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|TestRuleNoStaticHooksShadowing
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|TestRuleNoInstanceHooksOverrides
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|SystemPropertiesInvariantRule
argument_list|(
name|IGNORED_INVARIANT_PROPERTIES
argument_list|)
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|TestRuleIcuHack
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
name|classNameRule
operator|=
operator|new
name|TestRuleStoreClassName
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|TestRuleReportUncaughtExceptions
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
name|classEnvRule
operator|=
operator|new
name|TestRuleSetupAndRestoreClassEnv
argument_list|()
argument_list|)
decl_stmt|;
comment|// -----------------------------------------------------------------
comment|// Test level rules.
comment|// -----------------------------------------------------------------
comment|/** Enforces {@link #setUp()} and {@link #tearDown()} calls are chained. */
DECL|field|parentChainCallRule
specifier|private
name|TestRuleSetupTeardownChained
name|parentChainCallRule
init|=
operator|new
name|TestRuleSetupTeardownChained
argument_list|()
decl_stmt|;
comment|/** Save test thread and name. */
DECL|field|threadAndTestNameRule
specifier|private
name|TestRuleThreadAndTestName
name|threadAndTestNameRule
init|=
operator|new
name|TestRuleThreadAndTestName
argument_list|()
decl_stmt|;
comment|/** Taint suite result with individual test failures. */
DECL|field|testFailureMarker
specifier|private
name|TestRuleMarkFailure
name|testFailureMarker
init|=
operator|new
name|TestRuleMarkFailure
argument_list|(
name|suiteFailureMarker
argument_list|)
decl_stmt|;
comment|/**    * This controls how individual test rules are nested. It is important that    * _all_ rules declared in {@link LuceneTestCase} are executed in proper order    * if they depend on each other.    */
annotation|@
name|Rule
DECL|field|ruleChain
specifier|public
specifier|final
name|TestRule
name|ruleChain
init|=
name|RuleChain
operator|.
name|outerRule
argument_list|(
name|testFailureMarker
argument_list|)
operator|.
name|around
argument_list|(
name|ignoreAfterMaxFailures
argument_list|)
operator|.
name|around
argument_list|(
name|threadAndTestNameRule
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|TestRuleReportUncaughtExceptions
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|SystemPropertiesInvariantRule
argument_list|(
name|IGNORED_INVARIANT_PROPERTIES
argument_list|)
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|TestRuleSetupAndRestoreInstanceEnv
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
operator|new
name|TestRuleFieldCacheSanity
argument_list|()
argument_list|)
operator|.
name|around
argument_list|(
name|parentChainCallRule
argument_list|)
decl_stmt|;
comment|// -----------------------------------------------------------------
comment|// Suite and test case setup/ cleanup.
comment|// -----------------------------------------------------------------
comment|/**    * For subclasses to override. Overrides must call {@code super.setUp()}.    */
annotation|@
name|Before
DECL|method|setUp
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|parentChainCallRule
operator|.
name|setupCalled
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * For subclasses to override. Overrides must call {@code super.tearDown()}.    */
annotation|@
name|After
DECL|method|tearDown
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
name|parentChainCallRule
operator|.
name|teardownCalled
operator|=
literal|true
expr_stmt|;
block|}
comment|// -----------------------------------------------------------------
comment|// Test facilities and facades for subclasses.
comment|// -----------------------------------------------------------------
comment|/**    * Access to the current {@link RandomizedContext}'s Random instance. It is safe to use    * this method from multiple threads, etc., but it should be called while within a runner's    * scope (so no static initializers). The returned {@link Random} instance will be     *<b>different</b> when this method is called inside a {@link BeforeClass} hook (static     * suite scope) and within {@link Before}/ {@link After} hooks or test methods.     *     *<p>The returned instance must not be shared with other threads or cross a single scope's     * boundary. For example, a {@link Random} acquired within a test method shouldn't be reused    * for another test case.    *     *<p>There is an overhead connected with getting the {@link Random} for a particular context    * and thread. It is better to cache the {@link Random} locally if tight loops with multiple    * invocations are present or create a derivative local {@link Random} for millions of calls     * like this:    *<pre>    * Random random = new Random(random().nextLong());    * // tight loop with many invocations.     *</pre>    */
DECL|method|random
specifier|public
specifier|static
name|Random
name|random
parameter_list|()
block|{
return|return
name|RandomizedContext
operator|.
name|current
argument_list|()
operator|.
name|getRandom
argument_list|()
return|;
block|}
comment|/**    * Registers a {@link Closeable} resource that should be closed after the test    * completes.    *     * @return<code>resource</code> (for call chaining).    */
DECL|method|closeAfterTest
specifier|public
parameter_list|<
name|T
extends|extends
name|Closeable
parameter_list|>
name|T
name|closeAfterTest
parameter_list|(
name|T
name|resource
parameter_list|)
block|{
return|return
name|RandomizedContext
operator|.
name|current
argument_list|()
operator|.
name|closeAtEnd
argument_list|(
name|resource
argument_list|,
name|LifecycleScope
operator|.
name|TEST
argument_list|)
return|;
block|}
comment|/**    * Registers a {@link Closeable} resource that should be closed after the suite    * completes.    *     * @return<code>resource</code> (for call chaining).    */
DECL|method|closeAfterSuite
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|Closeable
parameter_list|>
name|T
name|closeAfterSuite
parameter_list|(
name|T
name|resource
parameter_list|)
block|{
return|return
name|RandomizedContext
operator|.
name|current
argument_list|()
operator|.
name|closeAtEnd
argument_list|(
name|resource
argument_list|,
name|LifecycleScope
operator|.
name|SUITE
argument_list|)
return|;
block|}
comment|/**    * Return the current class being tested.    */
DECL|method|getTestClass
specifier|public
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|getTestClass
parameter_list|()
block|{
return|return
name|classNameRule
operator|.
name|getTestClass
argument_list|()
return|;
block|}
comment|/**    * Return the name of the currently executing test case.    */
DECL|method|getTestName
specifier|public
name|String
name|getTestName
parameter_list|()
block|{
return|return
name|threadAndTestNameRule
operator|.
name|testMethodName
return|;
block|}
comment|/**    * Some tests expect the directory to contain a single segment, and want to     * do tests on that segment's reader. This is an utility method to help them.    */
DECL|method|getOnlySegmentReader
specifier|public
specifier|static
name|SegmentReader
name|getOnlySegmentReader
parameter_list|(
name|DirectoryReader
name|reader
parameter_list|)
block|{
name|List
argument_list|<
name|?
extends|extends
name|IndexReader
argument_list|>
name|subReaders
init|=
name|reader
operator|.
name|getSequentialSubReaders
argument_list|()
decl_stmt|;
if|if
condition|(
name|subReaders
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|reader
operator|+
literal|" has "
operator|+
name|subReaders
operator|.
name|size
argument_list|()
operator|+
literal|" segments instead of exactly one"
argument_list|)
throw|;
specifier|final
name|IndexReader
name|r
init|=
name|subReaders
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|r
operator|instanceof
name|SegmentReader
argument_list|)
expr_stmt|;
return|return
operator|(
name|SegmentReader
operator|)
name|r
return|;
block|}
comment|/**    * Returns true if and only if the calling thread is the primary thread     * executing the test case.     */
DECL|method|isTestThread
specifier|protected
name|boolean
name|isTestThread
parameter_list|()
block|{
name|assertNotNull
argument_list|(
literal|"Test case thread not set?"
argument_list|,
name|threadAndTestNameRule
operator|.
name|testCaseThread
argument_list|)
expr_stmt|;
return|return
name|Thread
operator|.
name|currentThread
argument_list|()
operator|==
name|threadAndTestNameRule
operator|.
name|testCaseThread
return|;
block|}
comment|/**    * Asserts that FieldCacheSanityChecker does not detect any    * problems with FieldCache.DEFAULT.    *<p>    * If any problems are found, they are logged to System.err    * (allong with the msg) when the Assertion is thrown.    *</p>    *<p>    * This method is called by tearDown after every test method,    * however IndexReaders scoped inside test methods may be garbage    * collected prior to this method being called, causing errors to    * be overlooked. Tests are encouraged to keep their IndexReaders    * scoped at the class level, or to explicitly call this method    * directly in the same scope as the IndexReader.    *</p>    *    * @see org.apache.lucene.util.FieldCacheSanityChecker    */
DECL|method|assertSaneFieldCaches
specifier|protected
specifier|static
name|void
name|assertSaneFieldCaches
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|)
block|{
specifier|final
name|CacheEntry
index|[]
name|entries
init|=
name|FieldCache
operator|.
name|DEFAULT
operator|.
name|getCacheEntries
argument_list|()
decl_stmt|;
name|Insanity
index|[]
name|insanity
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|insanity
operator|=
name|FieldCacheSanityChecker
operator|.
name|checkSanity
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|dumpArray
argument_list|(
name|msg
operator|+
literal|": FieldCache"
argument_list|,
name|entries
argument_list|,
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|assertEquals
argument_list|(
name|msg
operator|+
literal|": Insane FieldCache usage(s) found"
argument_list|,
literal|0
argument_list|,
name|insanity
operator|.
name|length
argument_list|)
expr_stmt|;
name|insanity
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
comment|// report this in the event of any exception/failure
comment|// if no failure, then insanity will be null anyway
if|if
condition|(
literal|null
operator|!=
name|insanity
condition|)
block|{
name|dumpArray
argument_list|(
name|msg
operator|+
literal|": Insane FieldCache usage(s)"
argument_list|,
name|insanity
argument_list|,
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns a number of at least<code>i</code>    *<p>    * The actual number returned will be influenced by whether {@link #TEST_NIGHTLY}    * is active and {@link #RANDOM_MULTIPLIER}, but also with some random fudge.    */
DECL|method|atLeast
specifier|public
specifier|static
name|int
name|atLeast
parameter_list|(
name|Random
name|random
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|int
name|min
init|=
operator|(
name|TEST_NIGHTLY
condition|?
literal|2
operator|*
name|i
else|:
name|i
operator|)
operator|*
name|RANDOM_MULTIPLIER
decl_stmt|;
name|int
name|max
init|=
name|min
operator|+
operator|(
name|min
operator|/
literal|2
operator|)
decl_stmt|;
return|return
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
return|;
block|}
DECL|method|atLeast
specifier|public
specifier|static
name|int
name|atLeast
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|atLeast
argument_list|(
name|random
argument_list|()
argument_list|,
name|i
argument_list|)
return|;
block|}
comment|/**    * Returns true if something should happen rarely,    *<p>    * The actual number returned will be influenced by whether {@link #TEST_NIGHTLY}    * is active and {@link #RANDOM_MULTIPLIER}.    */
DECL|method|rarely
specifier|public
specifier|static
name|boolean
name|rarely
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|int
name|p
init|=
name|TEST_NIGHTLY
condition|?
literal|10
else|:
literal|5
decl_stmt|;
name|p
operator|+=
operator|(
name|p
operator|*
name|Math
operator|.
name|log
argument_list|(
name|RANDOM_MULTIPLIER
argument_list|)
operator|)
expr_stmt|;
name|int
name|min
init|=
literal|100
operator|-
name|Math
operator|.
name|min
argument_list|(
name|p
argument_list|,
literal|50
argument_list|)
decl_stmt|;
comment|// never more than 50
return|return
name|random
operator|.
name|nextInt
argument_list|(
literal|100
argument_list|)
operator|>=
name|min
return|;
block|}
DECL|method|rarely
specifier|public
specifier|static
name|boolean
name|rarely
parameter_list|()
block|{
return|return
name|rarely
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|usually
specifier|public
specifier|static
name|boolean
name|usually
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
return|return
operator|!
name|rarely
argument_list|(
name|random
argument_list|)
return|;
block|}
DECL|method|usually
specifier|public
specifier|static
name|boolean
name|usually
parameter_list|()
block|{
return|return
name|usually
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|assumeTrue
specifier|public
specifier|static
name|void
name|assumeTrue
parameter_list|(
name|String
name|msg
parameter_list|,
name|boolean
name|condition
parameter_list|)
block|{
name|RandomizedTest
operator|.
name|assumeTrue
argument_list|(
name|msg
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
DECL|method|assumeFalse
specifier|public
specifier|static
name|void
name|assumeFalse
parameter_list|(
name|String
name|msg
parameter_list|,
name|boolean
name|condition
parameter_list|)
block|{
name|RandomizedTest
operator|.
name|assumeFalse
argument_list|(
name|msg
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
DECL|method|assumeNoException
specifier|public
specifier|static
name|void
name|assumeNoException
parameter_list|(
name|String
name|msg
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|RandomizedTest
operator|.
name|assumeNoException
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return<code>args</code> as a {@link Set} instance. The order of elements is not    * preserved in iterators.    */
DECL|method|asSet
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Set
argument_list|<
name|T
argument_list|>
name|asSet
parameter_list|(
name|T
modifier|...
name|args
parameter_list|)
block|{
return|return
operator|new
name|HashSet
argument_list|<
name|T
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|args
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Convenience method for logging an iterator.    *    * @param label  String logged before/after the items in the iterator    * @param iter   Each next() is toString()ed and logged on it's own line. If iter is null this is logged differnetly then an empty iterator.    * @param stream Stream to log messages to.    */
DECL|method|dumpIterator
specifier|public
specifier|static
name|void
name|dumpIterator
parameter_list|(
name|String
name|label
parameter_list|,
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
parameter_list|,
name|PrintStream
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|println
argument_list|(
literal|"*** BEGIN "
operator|+
name|label
operator|+
literal|" ***"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|iter
condition|)
block|{
name|stream
operator|.
name|println
argument_list|(
literal|" ... NULL ..."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|stream
operator|.
name|println
argument_list|(
name|iter
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|stream
operator|.
name|println
argument_list|(
literal|"*** END "
operator|+
name|label
operator|+
literal|" ***"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Convenience method for logging an array.  Wraps the array in an iterator and delegates    *    * @see #dumpIterator(String,Iterator,PrintStream)    */
DECL|method|dumpArray
specifier|public
specifier|static
name|void
name|dumpArray
parameter_list|(
name|String
name|label
parameter_list|,
name|Object
index|[]
name|objs
parameter_list|,
name|PrintStream
name|stream
parameter_list|)
block|{
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
init|=
operator|(
literal|null
operator|==
name|objs
operator|)
condition|?
literal|null
else|:
name|Arrays
operator|.
name|asList
argument_list|(
name|objs
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|dumpIterator
argument_list|(
name|label
argument_list|,
name|iter
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/** create a new index writer config with random defaults */
DECL|method|newIndexWriterConfig
specifier|public
specifier|static
name|IndexWriterConfig
name|newIndexWriterConfig
parameter_list|(
name|Version
name|v
parameter_list|,
name|Analyzer
name|a
parameter_list|)
block|{
return|return
name|newIndexWriterConfig
argument_list|(
name|random
argument_list|()
argument_list|,
name|v
argument_list|,
name|a
argument_list|)
return|;
block|}
comment|/** create a new index writer config with random defaults using the specified random */
DECL|method|newIndexWriterConfig
specifier|public
specifier|static
name|IndexWriterConfig
name|newIndexWriterConfig
parameter_list|(
name|Random
name|r
parameter_list|,
name|Version
name|v
parameter_list|,
name|Analyzer
name|a
parameter_list|)
block|{
name|IndexWriterConfig
name|c
init|=
operator|new
name|IndexWriterConfig
argument_list|(
name|v
argument_list|,
name|a
argument_list|)
decl_stmt|;
name|c
operator|.
name|setSimilarity
argument_list|(
name|classEnvRule
operator|.
name|similarity
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|c
operator|.
name|setMergeScheduler
argument_list|(
operator|new
name|SerialMergeScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// crazy value
name|c
operator|.
name|setMaxBufferedDocs
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|15
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// reasonable value
name|c
operator|.
name|setMaxBufferedDocs
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|16
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// crazy value
name|c
operator|.
name|setTermIndexInterval
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|?
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
literal|31
argument_list|)
else|:
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|129
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// reasonable value
name|c
operator|.
name|setTermIndexInterval
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|32
argument_list|,
literal|128
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|int
name|maxNumThreadStates
init|=
name|rarely
argument_list|(
name|r
argument_list|)
condition|?
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|5
argument_list|,
literal|20
argument_list|)
comment|// crazy value
else|:
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|)
decl_stmt|;
comment|// reasonable value
name|Method
name|setIndexerThreadPoolMethod
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Retrieve the package-private setIndexerThreadPool
comment|// method:
for|for
control|(
name|Method
name|m
range|:
name|IndexWriterConfig
operator|.
name|class
operator|.
name|getDeclaredMethods
argument_list|()
control|)
block|{
if|if
condition|(
name|m
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"setIndexerThreadPool"
argument_list|)
condition|)
block|{
name|m
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setIndexerThreadPoolMethod
operator|=
name|m
expr_stmt|;
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Should not happen?
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|setIndexerThreadPoolMethod
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"failed to lookup IndexWriterConfig.setIndexerThreadPool method"
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|Class
operator|.
name|forName
argument_list|(
literal|"org.apache.lucene.index.RandomDocumentsWriterPerThreadPool"
argument_list|)
decl_stmt|;
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
init|=
name|clazz
operator|.
name|getConstructor
argument_list|(
name|int
operator|.
name|class
argument_list|,
name|Random
operator|.
name|class
argument_list|)
decl_stmt|;
name|ctor
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// random thread pool
name|setIndexerThreadPoolMethod
operator|.
name|invoke
argument_list|(
name|c
argument_list|,
name|ctor
operator|.
name|newInstance
argument_list|(
name|maxNumThreadStates
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// random thread pool
name|c
operator|.
name|setMaxThreadStates
argument_list|(
name|maxNumThreadStates
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|c
operator|.
name|setMergePolicy
argument_list|(
operator|new
name|MockRandomMergePolicy
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|c
operator|.
name|setMergePolicy
argument_list|(
name|newTieredMergePolicy
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|.
name|setMergePolicy
argument_list|(
name|newAlcoholicMergePolicy
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|.
name|setMergePolicy
argument_list|(
name|newLogMergePolicy
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|c
operator|.
name|setReaderPooling
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|c
operator|.
name|setReaderTermsIndexDivisor
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|()
block|{
return|return
name|newLogMergePolicy
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newTieredMergePolicy
specifier|public
specifier|static
name|TieredMergePolicy
name|newTieredMergePolicy
parameter_list|()
block|{
return|return
name|newTieredMergePolicy
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newAlcoholicMergePolicy
specifier|public
specifier|static
name|AlcoholicMergePolicy
name|newAlcoholicMergePolicy
parameter_list|()
block|{
return|return
name|newAlcoholicMergePolicy
argument_list|(
name|random
argument_list|()
argument_list|,
name|classEnvRule
operator|.
name|timeZone
argument_list|)
return|;
block|}
DECL|method|newAlcoholicMergePolicy
specifier|public
specifier|static
name|AlcoholicMergePolicy
name|newAlcoholicMergePolicy
parameter_list|(
name|Random
name|r
parameter_list|,
name|TimeZone
name|tz
parameter_list|)
block|{
return|return
operator|new
name|AlcoholicMergePolicy
argument_list|(
name|tz
argument_list|,
operator|new
name|Random
argument_list|(
name|r
operator|.
name|nextLong
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|r
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|LogDocMergePolicy
argument_list|()
else|:
operator|new
name|LogByteSizeMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setUseCompoundFile
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|logmp
operator|.
name|setCalibrateSizeByDeletes
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|logmp
return|;
block|}
DECL|method|newTieredMergePolicy
specifier|public
specifier|static
name|TieredMergePolicy
name|newTieredMergePolicy
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
name|TieredMergePolicy
name|tmp
init|=
operator|new
name|TieredMergePolicy
argument_list|()
decl_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|setMaxMergeAtOnce
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setMaxMergeAtOnceExplicit
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|setMaxMergeAtOnce
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setMaxMergeAtOnceExplicit
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|setMaxMergedSegmentMB
argument_list|(
literal|0.2
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|2.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|setMaxMergedSegmentMB
argument_list|(
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|100
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|.
name|setFloorSegmentMB
argument_list|(
literal|0.2
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|2.0
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setForceMergeDeletesPctAllowed
argument_list|(
literal|0.0
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|30.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rarely
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|setSegmentsPerTier
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|2
argument_list|,
literal|20
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|setSegmentsPerTier
argument_list|(
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|.
name|setUseCompoundFile
argument_list|(
name|r
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setNoCFSRatio
argument_list|(
literal|0.1
operator|+
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|0.8
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setReclaimDeletesWeight
argument_list|(
name|r
operator|.
name|nextDouble
argument_list|()
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|(
name|boolean
name|useCFS
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|newLogMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setUseCompoundFile
argument_list|(
name|useCFS
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|(
name|boolean
name|useCFS
parameter_list|,
name|int
name|mergeFactor
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|newLogMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setUseCompoundFile
argument_list|(
name|useCFS
argument_list|)
expr_stmt|;
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|mergeFactor
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
DECL|method|newLogMergePolicy
specifier|public
specifier|static
name|LogMergePolicy
name|newLogMergePolicy
parameter_list|(
name|int
name|mergeFactor
parameter_list|)
block|{
name|LogMergePolicy
name|logmp
init|=
name|newLogMergePolicy
argument_list|()
decl_stmt|;
name|logmp
operator|.
name|setMergeFactor
argument_list|(
name|mergeFactor
argument_list|)
expr_stmt|;
return|return
name|logmp
return|;
block|}
comment|/**    * Returns a new Directory instance. Use this when the test does not    * care about the specific Directory implementation (most tests).    *<p>    * The Directory is wrapped with {@link BaseDirectoryWrapper}.    * this means usually it will be picky, such as ensuring that you    * properly close it and all open files in your test. It will emulate    * some features of Windows, such as not allowing open files to be    * overwritten.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newDirectory
parameter_list|()
block|{
return|return
name|newDirectory
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a new Directory instance, using the specified random.    * See {@link #newDirectory()} for more information.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newDirectory
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
return|return
name|wrapDirectory
argument_list|(
name|r
argument_list|,
name|newDirectoryImpl
argument_list|(
name|r
argument_list|,
name|TEST_DIRECTORY
argument_list|)
argument_list|,
name|rarely
argument_list|(
name|r
argument_list|)
argument_list|)
return|;
block|}
DECL|method|newMockDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newMockDirectory
parameter_list|()
block|{
return|return
name|newMockDirectory
argument_list|(
name|random
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newMockDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newMockDirectory
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
return|return
operator|(
name|MockDirectoryWrapper
operator|)
name|wrapDirectory
argument_list|(
name|r
argument_list|,
name|newDirectoryImpl
argument_list|(
name|r
argument_list|,
name|TEST_DIRECTORY
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|newMockFSDirectory
specifier|public
specifier|static
name|MockDirectoryWrapper
name|newMockFSDirectory
parameter_list|(
name|File
name|f
parameter_list|)
block|{
return|return
operator|(
name|MockDirectoryWrapper
operator|)
name|newFSDirectory
argument_list|(
name|f
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Returns a new Directory instance, with contents copied from the    * provided directory. See {@link #newDirectory()} for more    * information.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newDirectory
parameter_list|(
name|Directory
name|d
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|newDirectory
argument_list|(
name|random
argument_list|()
argument_list|,
name|d
argument_list|)
return|;
block|}
comment|/** Returns a new FSDirectory instance over the given file, which must be a folder. */
DECL|method|newFSDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newFSDirectory
parameter_list|(
name|File
name|f
parameter_list|)
block|{
return|return
name|newFSDirectory
argument_list|(
name|f
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Returns a new FSDirectory instance over the given file, which must be a folder. */
DECL|method|newFSDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newFSDirectory
parameter_list|(
name|File
name|f
parameter_list|,
name|LockFactory
name|lf
parameter_list|)
block|{
return|return
name|newFSDirectory
argument_list|(
name|f
argument_list|,
name|lf
argument_list|,
name|rarely
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newFSDirectory
specifier|private
specifier|static
name|BaseDirectoryWrapper
name|newFSDirectory
parameter_list|(
name|File
name|f
parameter_list|,
name|LockFactory
name|lf
parameter_list|,
name|boolean
name|bare
parameter_list|)
block|{
name|String
name|fsdirClass
init|=
name|TEST_DIRECTORY
decl_stmt|;
if|if
condition|(
name|fsdirClass
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
block|{
name|fsdirClass
operator|=
name|RandomPicks
operator|.
name|randomFrom
argument_list|(
name|random
argument_list|()
argument_list|,
name|FS_DIRECTORIES
argument_list|)
expr_stmt|;
block|}
name|Class
argument_list|<
name|?
extends|extends
name|FSDirectory
argument_list|>
name|clazz
decl_stmt|;
try|try
block|{
try|try
block|{
name|clazz
operator|=
name|CommandLineUtil
operator|.
name|loadFSDirectoryClass
argument_list|(
name|fsdirClass
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
comment|// TEST_DIRECTORY is not a sub-class of FSDirectory, so draw one at random
name|fsdirClass
operator|=
name|RandomPicks
operator|.
name|randomFrom
argument_list|(
name|random
argument_list|()
argument_list|,
name|FS_DIRECTORIES
argument_list|)
expr_stmt|;
name|clazz
operator|=
name|CommandLineUtil
operator|.
name|loadFSDirectoryClass
argument_list|(
name|fsdirClass
argument_list|)
expr_stmt|;
block|}
name|Directory
name|fsdir
init|=
name|newFSDirectoryImpl
argument_list|(
name|clazz
argument_list|,
name|f
argument_list|)
decl_stmt|;
name|BaseDirectoryWrapper
name|wrapped
init|=
name|wrapDirectory
argument_list|(
name|random
argument_list|()
argument_list|,
name|fsdir
argument_list|,
name|bare
argument_list|)
decl_stmt|;
if|if
condition|(
name|lf
operator|!=
literal|null
condition|)
block|{
name|wrapped
operator|.
name|setLockFactory
argument_list|(
name|lf
argument_list|)
expr_stmt|;
block|}
return|return
name|wrapped
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns a new Directory instance, using the specified random    * with contents copied from the provided directory. See     * {@link #newDirectory()} for more information.    */
DECL|method|newDirectory
specifier|public
specifier|static
name|BaseDirectoryWrapper
name|newDirectory
parameter_list|(
name|Random
name|r
parameter_list|,
name|Directory
name|d
parameter_list|)
throws|throws
name|IOException
block|{
name|Directory
name|impl
init|=
name|newDirectoryImpl
argument_list|(
name|r
argument_list|,
name|TEST_DIRECTORY
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|d
operator|.
name|listAll
argument_list|()
control|)
block|{
name|d
operator|.
name|copy
argument_list|(
name|impl
argument_list|,
name|file
argument_list|,
name|file
argument_list|,
name|newIOContext
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|wrapDirectory
argument_list|(
name|r
argument_list|,
name|impl
argument_list|,
name|rarely
argument_list|(
name|r
argument_list|)
argument_list|)
return|;
block|}
DECL|method|wrapDirectory
specifier|private
specifier|static
name|BaseDirectoryWrapper
name|wrapDirectory
parameter_list|(
name|Random
name|random
parameter_list|,
name|Directory
name|directory
parameter_list|,
name|boolean
name|bare
parameter_list|)
block|{
if|if
condition|(
name|rarely
argument_list|(
name|random
argument_list|)
condition|)
block|{
name|directory
operator|=
operator|new
name|NRTCachingDirectory
argument_list|(
name|directory
argument_list|,
name|random
operator|.
name|nextDouble
argument_list|()
argument_list|,
name|random
operator|.
name|nextDouble
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bare
condition|)
block|{
name|BaseDirectoryWrapper
name|base
init|=
operator|new
name|BaseDirectoryWrapper
argument_list|(
name|directory
argument_list|)
decl_stmt|;
name|closeAfterSuite
argument_list|(
operator|new
name|CloseableDirectory
argument_list|(
name|base
argument_list|,
name|suiteFailureMarker
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|base
return|;
block|}
else|else
block|{
name|MockDirectoryWrapper
name|mock
init|=
operator|new
name|MockDirectoryWrapper
argument_list|(
name|random
argument_list|,
name|directory
argument_list|)
decl_stmt|;
name|mock
operator|.
name|setThrottling
argument_list|(
name|TEST_THROTTLING
argument_list|)
expr_stmt|;
name|closeAfterSuite
argument_list|(
operator|new
name|CloseableDirectory
argument_list|(
name|mock
argument_list|,
name|suiteFailureMarker
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mock
return|;
block|}
block|}
DECL|method|newStringField
specifier|public
specifier|static
name|Field
name|newStringField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Store
name|stored
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|()
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|stored
operator|==
name|Store
operator|.
name|YES
condition|?
name|StringField
operator|.
name|TYPE_STORED
else|:
name|StringField
operator|.
name|TYPE_NOT_STORED
argument_list|)
return|;
block|}
DECL|method|newTextField
specifier|public
specifier|static
name|Field
name|newTextField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Store
name|stored
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|()
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|stored
operator|==
name|Store
operator|.
name|YES
condition|?
name|TextField
operator|.
name|TYPE_STORED
else|:
name|TextField
operator|.
name|TYPE_NOT_STORED
argument_list|)
return|;
block|}
DECL|method|newStringField
specifier|public
specifier|static
name|Field
name|newStringField
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Store
name|stored
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|stored
operator|==
name|Store
operator|.
name|YES
condition|?
name|StringField
operator|.
name|TYPE_STORED
else|:
name|StringField
operator|.
name|TYPE_NOT_STORED
argument_list|)
return|;
block|}
DECL|method|newTextField
specifier|public
specifier|static
name|Field
name|newTextField
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|Store
name|stored
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|stored
operator|==
name|Store
operator|.
name|YES
condition|?
name|TextField
operator|.
name|TYPE_STORED
else|:
name|TextField
operator|.
name|TYPE_NOT_STORED
argument_list|)
return|;
block|}
DECL|method|newField
specifier|public
specifier|static
name|Field
name|newField
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|FieldType
name|type
parameter_list|)
block|{
return|return
name|newField
argument_list|(
name|random
argument_list|()
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|method|newField
specifier|public
specifier|static
name|Field
name|newField
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|FieldType
name|type
parameter_list|)
block|{
name|name
operator|=
operator|new
name|String
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|usually
argument_list|(
name|random
argument_list|)
operator|||
operator|!
name|type
operator|.
name|indexed
argument_list|()
condition|)
block|{
comment|// most of the time, don't modify the params
return|return
operator|new
name|Field
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|// TODO: once all core& test codecs can index
comment|// offsets, sometimes randomly turn on offsets if we are
comment|// already indexing positions...
name|FieldType
name|newType
init|=
operator|new
name|FieldType
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newType
operator|.
name|stored
argument_list|()
operator|&&
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStored
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// randomly store it
block|}
if|if
condition|(
operator|!
name|newType
operator|.
name|storeTermVectors
argument_list|()
operator|&&
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStoreTermVectors
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newType
operator|.
name|storeTermVectorOffsets
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStoreTermVectorOffsets
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newType
operator|.
name|storeTermVectorPositions
argument_list|()
condition|)
block|{
name|newType
operator|.
name|setStoreTermVectorPositions
argument_list|(
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: we need to do this, but smarter, ie, most of
comment|// the time we set the same value for a given field but
comment|// sometimes (rarely) we change it up:
comment|/*     if (newType.omitNorms()) {       newType.setOmitNorms(random.nextBoolean());     }     */
return|return
operator|new
name|Field
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|newType
argument_list|)
return|;
block|}
comment|/**     * Return a random Locale from the available locales on the system.    * @see "https://issues.apache.org/jira/browse/LUCENE-4020"    */
DECL|method|randomLocale
specifier|public
specifier|static
name|Locale
name|randomLocale
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|Locale
name|locales
index|[]
init|=
name|Locale
operator|.
name|getAvailableLocales
argument_list|()
decl_stmt|;
return|return
name|locales
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|locales
operator|.
name|length
argument_list|)
index|]
return|;
block|}
comment|/**     * Return a random TimeZone from the available timezones on the system    * @see "https://issues.apache.org/jira/browse/LUCENE-4020"     */
DECL|method|randomTimeZone
specifier|public
specifier|static
name|TimeZone
name|randomTimeZone
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
name|String
name|tzIds
index|[]
init|=
name|TimeZone
operator|.
name|getAvailableIDs
argument_list|()
decl_stmt|;
return|return
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
name|tzIds
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|tzIds
operator|.
name|length
argument_list|)
index|]
argument_list|)
return|;
block|}
comment|/** return a Locale object equivalent to its programmatic name */
DECL|method|localeForName
specifier|public
specifier|static
name|Locale
name|localeForName
parameter_list|(
name|String
name|localeName
parameter_list|)
block|{
name|String
name|elements
index|[]
init|=
name|localeName
operator|.
name|split
argument_list|(
literal|"\\_"
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|elements
operator|.
name|length
condition|)
block|{
case|case
literal|4
case|:
comment|/* fallthrough for special cases */
case|case
literal|3
case|:
return|return
operator|new
name|Locale
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|,
name|elements
index|[
literal|1
index|]
argument_list|,
name|elements
index|[
literal|2
index|]
argument_list|)
return|;
case|case
literal|2
case|:
return|return
operator|new
name|Locale
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|,
name|elements
index|[
literal|1
index|]
argument_list|)
return|;
case|case
literal|1
case|:
return|return
operator|new
name|Locale
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid Locale: "
operator|+
name|localeName
argument_list|)
throw|;
block|}
block|}
DECL|method|newFSDirectoryImpl
specifier|private
specifier|static
name|Directory
name|newFSDirectoryImpl
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|FSDirectory
argument_list|>
name|clazz
parameter_list|,
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDirectory
name|d
init|=
literal|null
decl_stmt|;
try|try
block|{
name|d
operator|=
name|CommandLineUtil
operator|.
name|newFSDirectory
argument_list|(
name|clazz
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|d
operator|=
name|FSDirectory
operator|.
name|open
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
DECL|method|newDirectoryImpl
specifier|static
name|Directory
name|newDirectoryImpl
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|clazzName
parameter_list|)
block|{
if|if
condition|(
name|clazzName
operator|.
name|equals
argument_list|(
literal|"random"
argument_list|)
condition|)
block|{
if|if
condition|(
name|rarely
argument_list|(
name|random
argument_list|)
condition|)
block|{
name|clazzName
operator|=
name|RandomPicks
operator|.
name|randomFrom
argument_list|(
name|random
argument_list|,
name|CORE_DIRECTORIES
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clazzName
operator|=
literal|"RAMDirectory"
expr_stmt|;
block|}
block|}
try|try
block|{
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Directory
argument_list|>
name|clazz
init|=
name|CommandLineUtil
operator|.
name|loadDirectoryClass
argument_list|(
name|clazzName
argument_list|)
decl_stmt|;
comment|// If it is a FSDirectory type, try its ctor(File)
if|if
condition|(
name|FSDirectory
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|clazz
argument_list|)
condition|)
block|{
specifier|final
name|File
name|dir
init|=
name|_TestUtil
operator|.
name|getTempDir
argument_list|(
literal|"index"
argument_list|)
decl_stmt|;
name|dir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
comment|// ensure it's created so we 'have' it.
return|return
name|newFSDirectoryImpl
argument_list|(
name|clazz
operator|.
name|asSubclass
argument_list|(
name|FSDirectory
operator|.
name|class
argument_list|)
argument_list|,
name|dir
argument_list|)
return|;
block|}
comment|// try empty ctor
return|return
name|clazz
operator|.
name|newInstance
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Sometimes wrap the IndexReader as slow, parallel or filter reader (or    * combinations of that)    */
DECL|method|maybeWrapReader
specifier|public
specifier|static
name|IndexReader
name|maybeWrapReader
parameter_list|(
name|IndexReader
name|r
parameter_list|)
throws|throws
name|IOException
block|{
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
if|if
condition|(
name|rarely
argument_list|()
condition|)
block|{
comment|// TODO: remove this, and fix those tests to wrap before putting slow around:
specifier|final
name|boolean
name|wasOriginallyAtomic
init|=
name|r
operator|instanceof
name|AtomicReader
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|c
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|6
argument_list|)
operator|+
literal|1
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|r
operator|=
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|// will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:
name|r
operator|=
operator|(
name|r
operator|instanceof
name|AtomicReader
operator|)
condition|?
operator|new
name|ParallelAtomicReader
argument_list|(
operator|(
name|AtomicReader
operator|)
name|r
argument_list|)
else|:
operator|new
name|ParallelCompositeReader
argument_list|(
operator|(
name|CompositeReader
operator|)
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|// Hckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use
comment|// QueryUtils' reader with a fake cache key, so insanity checker cannot walk
comment|// along our reader:
name|r
operator|=
operator|new
name|FCInvisibleMultiReader
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
specifier|final
name|AtomicReader
name|ar
init|=
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|r
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|allFields
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldInfo
name|fi
range|:
name|ar
operator|.
name|getFieldInfos
argument_list|()
control|)
block|{
name|allFields
operator|.
name|add
argument_list|(
name|fi
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|shuffle
argument_list|(
name|allFields
argument_list|,
name|random
argument_list|)
expr_stmt|;
specifier|final
name|int
name|end
init|=
name|allFields
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|random
operator|.
name|nextInt
argument_list|(
name|allFields
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|fields
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|allFields
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|end
argument_list|)
argument_list|)
decl_stmt|;
comment|// will create no FC insanity as ParallelAtomicReader has own cache key:
name|r
operator|=
operator|new
name|ParallelAtomicReader
argument_list|(
operator|new
name|FieldFilterAtomicReader
argument_list|(
name|ar
argument_list|,
name|fields
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|FieldFilterAtomicReader
argument_list|(
name|ar
argument_list|,
name|fields
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|// Hckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use
comment|// QueryUtils' reader with a fake cache key, so insanity checker cannot walk
comment|// along our reader:
if|if
condition|(
name|r
operator|instanceof
name|AtomicReader
condition|)
block|{
name|r
operator|=
operator|new
name|AssertingAtomicReader
argument_list|(
operator|(
name|AtomicReader
operator|)
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|instanceof
name|DirectoryReader
condition|)
block|{
name|r
operator|=
operator|new
name|AssertingDirectoryReader
argument_list|(
operator|(
name|DirectoryReader
operator|)
name|r
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fail
argument_list|(
literal|"should not get here"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wasOriginallyAtomic
condition|)
block|{
name|r
operator|=
name|SlowCompositeReaderWrapper
operator|.
name|wrap
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|r
operator|instanceof
name|CompositeReader
operator|)
operator|&&
operator|!
operator|(
name|r
operator|instanceof
name|FCInvisibleMultiReader
operator|)
condition|)
block|{
comment|// prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:
name|r
operator|=
operator|new
name|FCInvisibleMultiReader
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"maybeWrapReader wrapped: "
operator|+
name|r
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|r
return|;
block|}
comment|/** TODO: javadoc */
DECL|method|newIOContext
specifier|public
specifier|static
name|IOContext
name|newIOContext
parameter_list|(
name|Random
name|random
parameter_list|)
block|{
specifier|final
name|int
name|randomNumDocs
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|4192
argument_list|)
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|512
argument_list|)
operator|*
name|randomNumDocs
decl_stmt|;
specifier|final
name|IOContext
name|context
decl_stmt|;
switch|switch
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|context
operator|=
name|IOContext
operator|.
name|DEFAULT
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|context
operator|=
name|IOContext
operator|.
name|READ
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|context
operator|=
name|IOContext
operator|.
name|READONCE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|context
operator|=
operator|new
name|IOContext
argument_list|(
operator|new
name|MergeInfo
argument_list|(
name|randomNumDocs
argument_list|,
name|size
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|context
operator|=
operator|new
name|IOContext
argument_list|(
operator|new
name|FlushInfo
argument_list|(
name|randomNumDocs
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|context
operator|=
name|IOContext
operator|.
name|DEFAULT
expr_stmt|;
block|}
return|return
name|context
return|;
block|}
comment|/**    * Create a new searcher over the reader. This searcher might randomly use    * threads.    */
DECL|method|newSearcher
specifier|public
specifier|static
name|IndexSearcher
name|newSearcher
parameter_list|(
name|IndexReader
name|r
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|newSearcher
argument_list|(
name|r
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Create a new searcher over the reader. This searcher might randomly use    * threads. if<code>maybeWrap</code> is true, this searcher might wrap the    * reader with one that returns null for getSequentialSubReaders.    */
DECL|method|newSearcher
specifier|public
specifier|static
name|IndexSearcher
name|newSearcher
parameter_list|(
name|IndexReader
name|r
parameter_list|,
name|boolean
name|maybeWrap
parameter_list|)
throws|throws
name|IOException
block|{
name|Random
name|random
init|=
name|random
argument_list|()
decl_stmt|;
if|if
condition|(
name|usually
argument_list|()
condition|)
block|{
if|if
condition|(
name|maybeWrap
condition|)
block|{
name|r
operator|=
name|maybeWrapReader
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|IndexSearcher
name|ret
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|AssertingIndexSearcher
argument_list|(
name|random
argument_list|,
name|r
argument_list|)
else|:
operator|new
name|AssertingIndexSearcher
argument_list|(
name|random
argument_list|,
name|r
operator|.
name|getTopReaderContext
argument_list|()
argument_list|)
decl_stmt|;
name|ret
operator|.
name|setSimilarity
argument_list|(
name|classEnvRule
operator|.
name|similarity
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|int
name|threads
init|=
literal|0
decl_stmt|;
specifier|final
name|ThreadPoolExecutor
name|ex
decl_stmt|;
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|ex
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|threads
operator|=
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ex
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
name|threads
argument_list|,
name|threads
argument_list|,
literal|0L
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|,
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
operator|new
name|NamedThreadFactory
argument_list|(
literal|"LuceneTestCase"
argument_list|)
argument_list|)
expr_stmt|;
comment|// uncomment to intensify LUCENE-3840
comment|// ex.prestartAllCoreThreads();
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"NOTE: newSearcher using ExecutorService with "
operator|+
name|threads
operator|+
literal|" threads"
argument_list|)
expr_stmt|;
block|}
name|r
operator|.
name|addReaderClosedListener
argument_list|(
operator|new
name|ReaderClosedListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onClose
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
block|{
name|_TestUtil
operator|.
name|shutdownExecutorService
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|IndexSearcher
name|ret
init|=
name|random
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|AssertingIndexSearcher
argument_list|(
name|random
argument_list|,
name|r
argument_list|,
name|ex
argument_list|)
else|:
operator|new
name|AssertingIndexSearcher
argument_list|(
name|random
argument_list|,
name|r
operator|.
name|getTopReaderContext
argument_list|()
argument_list|,
name|ex
argument_list|)
decl_stmt|;
name|ret
operator|.
name|setSimilarity
argument_list|(
name|classEnvRule
operator|.
name|similarity
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
comment|/**    * Gets a resource from the classpath as {@link File}. This method should only    * be used, if a real file is needed. To get a stream, code should prefer    * {@link Class#getResourceAsStream} using {@code this.getClass()}.    */
DECL|method|getDataFile
specifier|protected
name|File
name|getDataFile
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
operator|new
name|File
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getResource
argument_list|(
name|name
argument_list|)
operator|.
name|toURI
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot find resource: "
operator|+
name|name
argument_list|)
throw|;
block|}
block|}
block|}
end_class
end_unit
