begin_unit
begin_package
DECL|package|org.apache.lucene.util
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|CharBuffer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|ZipEntry
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|ZipFile
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|PostingsFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene40
operator|.
name|Lucene40Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|perfield
operator|.
name|PerFieldPostingsFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|DocValuesField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CheckIndex
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|ConcurrentMergeScheduler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexableField
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LogMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MergeScheduler
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiFields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TieredMergePolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FieldDoc
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|ScoreDoc
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|TopDocs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import
begin_class
DECL|class|_TestUtil
specifier|public
class|class
name|_TestUtil
block|{
comment|/** Returns temp dir, based on String arg in its name;    *  does not create the directory. */
DECL|method|getTempDir
specifier|public
specifier|static
name|File
name|getTempDir
parameter_list|(
name|String
name|desc
parameter_list|)
block|{
try|try
block|{
name|File
name|f
init|=
name|createTempFile
argument_list|(
name|desc
argument_list|,
literal|"tmp"
argument_list|,
name|LuceneTestCase
operator|.
name|TEMP_DIR
argument_list|)
decl_stmt|;
name|f
operator|.
name|delete
argument_list|()
expr_stmt|;
name|LuceneTestCase
operator|.
name|registerTempDir
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Deletes a directory and everything underneath it.    */
DECL|method|rmDir
specifier|public
specifier|static
name|void
name|rmDir
parameter_list|(
name|File
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|dir
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|dir
operator|.
name|isFile
argument_list|()
operator|&&
operator|!
name|dir
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"could not delete "
operator|+
name|dir
argument_list|)
throw|;
block|}
for|for
control|(
name|File
name|f
range|:
name|dir
operator|.
name|listFiles
argument_list|()
control|)
block|{
if|if
condition|(
name|f
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|rmDir
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|f
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"could not delete "
operator|+
name|f
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|dir
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"could not delete "
operator|+
name|dir
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**     * Convenience method: Unzip zipName + ".zip" under destDir, removing destDir first     */
DECL|method|unzip
specifier|public
specifier|static
name|void
name|unzip
parameter_list|(
name|File
name|zipName
parameter_list|,
name|File
name|destDir
parameter_list|)
throws|throws
name|IOException
block|{
name|ZipFile
name|zipFile
init|=
operator|new
name|ZipFile
argument_list|(
name|zipName
argument_list|)
decl_stmt|;
name|Enumeration
argument_list|<
name|?
extends|extends
name|ZipEntry
argument_list|>
name|entries
init|=
name|zipFile
operator|.
name|entries
argument_list|()
decl_stmt|;
name|rmDir
argument_list|(
name|destDir
argument_list|)
expr_stmt|;
name|destDir
operator|.
name|mkdir
argument_list|()
expr_stmt|;
name|LuceneTestCase
operator|.
name|registerTempDir
argument_list|(
name|destDir
argument_list|)
expr_stmt|;
while|while
condition|(
name|entries
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|ZipEntry
name|entry
init|=
name|entries
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|InputStream
name|in
init|=
name|zipFile
operator|.
name|getInputStream
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|File
name|targetFile
init|=
operator|new
name|File
argument_list|(
name|destDir
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|// allow unzipping with directory structure
name|targetFile
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|targetFile
operator|.
name|getParentFile
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// be on the safe side: do not rely on that directories are always extracted
comment|// before their children (although this makes sense, but is it guaranteed?)
name|targetFile
operator|.
name|getParentFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
block|}
name|OutputStream
name|out
init|=
operator|new
name|BufferedOutputStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|targetFile
argument_list|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|8192
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|in
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|zipFile
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|syncConcurrentMerges
specifier|public
specifier|static
name|void
name|syncConcurrentMerges
parameter_list|(
name|IndexWriter
name|writer
parameter_list|)
block|{
name|syncConcurrentMerges
argument_list|(
name|writer
operator|.
name|getConfig
argument_list|()
operator|.
name|getMergeScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|syncConcurrentMerges
specifier|public
specifier|static
name|void
name|syncConcurrentMerges
parameter_list|(
name|MergeScheduler
name|ms
parameter_list|)
block|{
if|if
condition|(
name|ms
operator|instanceof
name|ConcurrentMergeScheduler
condition|)
operator|(
operator|(
name|ConcurrentMergeScheduler
operator|)
name|ms
operator|)
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
comment|/** This runs the CheckIndex tool on the index in.  If any    *  issues are hit, a RuntimeException is thrown; else,    *  true is returned. */
DECL|method|checkIndex
specifier|public
specifier|static
name|CheckIndex
operator|.
name|Status
name|checkIndex
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|checkIndex
argument_list|(
name|dir
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|checkIndex
specifier|public
specifier|static
name|CheckIndex
operator|.
name|Status
name|checkIndex
parameter_list|(
name|Directory
name|dir
parameter_list|,
name|boolean
name|crossCheckTermVectors
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|bos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
literal|1024
argument_list|)
decl_stmt|;
name|CheckIndex
name|checker
init|=
operator|new
name|CheckIndex
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|checker
operator|.
name|setCrossCheckTermVectors
argument_list|(
name|crossCheckTermVectors
argument_list|)
expr_stmt|;
name|checker
operator|.
name|setInfoStream
argument_list|(
operator|new
name|PrintStream
argument_list|(
name|bos
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|CheckIndex
operator|.
name|Status
name|indexStatus
init|=
name|checker
operator|.
name|checkIndex
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexStatus
operator|==
literal|null
operator|||
name|indexStatus
operator|.
name|clean
operator|==
literal|false
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"CheckIndex failed"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|bos
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"CheckIndex failed"
argument_list|)
throw|;
block|}
else|else
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|INFOSTREAM
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|bos
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|indexStatus
return|;
block|}
block|}
comment|// NOTE: only works for TMP and LMP!!
DECL|method|setUseCompoundFile
specifier|public
specifier|static
name|void
name|setUseCompoundFile
parameter_list|(
name|MergePolicy
name|mp
parameter_list|,
name|boolean
name|v
parameter_list|)
block|{
if|if
condition|(
name|mp
operator|instanceof
name|TieredMergePolicy
condition|)
block|{
operator|(
operator|(
name|TieredMergePolicy
operator|)
name|mp
operator|)
operator|.
name|setUseCompoundFile
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|instanceof
name|LogMergePolicy
condition|)
block|{
operator|(
operator|(
name|LogMergePolicy
operator|)
name|mp
operator|)
operator|.
name|setUseCompoundFile
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** start and end are BOTH inclusive */
DECL|method|nextInt
specifier|public
specifier|static
name|int
name|nextInt
parameter_list|(
name|Random
name|r
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
return|return
name|start
operator|+
name|r
operator|.
name|nextInt
argument_list|(
name|end
operator|-
name|start
operator|+
literal|1
argument_list|)
return|;
block|}
DECL|method|randomSimpleString
specifier|public
specifier|static
name|String
name|randomSimpleString
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|r
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
literal|0
condition|)
block|{
comment|// allow 0 length
return|return
literal|""
return|;
block|}
specifier|final
name|char
index|[]
name|buffer
init|=
operator|new
name|char
index|[
name|end
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|97
argument_list|,
literal|102
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|end
argument_list|)
return|;
block|}
comment|/** Returns random string, including full unicode range. */
DECL|method|randomUnicodeString
specifier|public
specifier|static
name|String
name|randomUnicodeString
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
return|return
name|randomUnicodeString
argument_list|(
name|r
argument_list|,
literal|20
argument_list|)
return|;
block|}
comment|/**    * Returns a random string up to a certain length.    */
DECL|method|randomUnicodeString
specifier|public
specifier|static
name|String
name|randomUnicodeString
parameter_list|(
name|Random
name|r
parameter_list|,
name|int
name|maxLength
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|r
operator|.
name|nextInt
argument_list|(
name|maxLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
literal|0
condition|)
block|{
comment|// allow 0 length
return|return
literal|""
return|;
block|}
specifier|final
name|char
index|[]
name|buffer
init|=
operator|new
name|char
index|[
name|end
index|]
decl_stmt|;
name|randomFixedLengthUnicodeString
argument_list|(
name|r
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|end
argument_list|)
return|;
block|}
comment|/**    * Fills provided char[] with valid random unicode code    * unit sequence.    */
DECL|method|randomFixedLengthUnicodeString
specifier|public
specifier|static
name|void
name|randomFixedLengthUnicodeString
parameter_list|(
name|Random
name|random
parameter_list|,
name|char
index|[]
name|chars
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|i
init|=
name|offset
decl_stmt|;
specifier|final
name|int
name|end
init|=
name|offset
operator|+
name|length
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|end
condition|)
block|{
specifier|final
name|int
name|t
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|t
operator|&&
name|i
operator|<
name|length
operator|-
literal|1
condition|)
block|{
comment|// Make a surrogate pair
comment|// High surrogate
name|chars
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0xd800
argument_list|,
literal|0xdbff
argument_list|)
expr_stmt|;
comment|// Low surrogate
name|chars
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0xdc00
argument_list|,
literal|0xdfff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|<=
literal|1
condition|)
block|{
name|chars
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|random
operator|.
name|nextInt
argument_list|(
literal|0x80
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|2
operator|==
name|t
condition|)
block|{
name|chars
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0x80
argument_list|,
literal|0x7ff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|3
operator|==
name|t
condition|)
block|{
name|chars
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0x800
argument_list|,
literal|0xd7ff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|4
operator|==
name|t
condition|)
block|{
name|chars
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0xe000
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns a String thats "regexpish" (contains lots of operators typically found in regular expressions)    * If you call this enough times, you might get a valid regex!    */
DECL|method|randomRegexpishString
specifier|public
specifier|static
name|String
name|randomRegexpishString
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|r
operator|.
name|nextInt
argument_list|(
literal|20
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
literal|0
condition|)
block|{
comment|// allow 0 length
return|return
literal|""
return|;
block|}
specifier|final
name|char
index|[]
name|buffer
init|=
operator|new
name|char
index|[
name|end
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|int
name|t
init|=
name|r
operator|.
name|nextInt
argument_list|(
literal|11
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|_TestUtil
operator|.
name|nextInt
argument_list|(
name|r
argument_list|,
literal|97
argument_list|,
literal|102
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|1
operator|==
name|t
condition|)
name|buffer
index|[
name|i
index|]
operator|=
literal|'.'
expr_stmt|;
elseif|else
if|if
condition|(
literal|2
operator|==
name|t
condition|)
name|buffer
index|[
name|i
index|]
operator|=
literal|'?'
expr_stmt|;
elseif|else
if|if
condition|(
literal|3
operator|==
name|t
condition|)
name|buffer
index|[
name|i
index|]
operator|=
literal|'*'
expr_stmt|;
elseif|else
if|if
condition|(
literal|4
operator|==
name|t
condition|)
name|buffer
index|[
name|i
index|]
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
literal|5
operator|==
name|t
condition|)
name|buffer
index|[
name|i
index|]
operator|=
literal|'('
expr_stmt|;
elseif|else
if|if
condition|(
literal|6
operator|==
name|t
condition|)
name|buffer
index|[
name|i
index|]
operator|=
literal|')'
expr_stmt|;
elseif|else
if|if
condition|(
literal|7
operator|==
name|t
condition|)
name|buffer
index|[
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
elseif|else
if|if
condition|(
literal|8
operator|==
name|t
condition|)
name|buffer
index|[
name|i
index|]
operator|=
literal|'['
expr_stmt|;
elseif|else
if|if
condition|(
literal|9
operator|==
name|t
condition|)
name|buffer
index|[
name|i
index|]
operator|=
literal|']'
expr_stmt|;
elseif|else
if|if
condition|(
literal|10
operator|==
name|t
condition|)
name|buffer
index|[
name|i
index|]
operator|=
literal|'|'
expr_stmt|;
block|}
return|return
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|end
argument_list|)
return|;
block|}
DECL|field|HTML_CHAR_ENTITIES
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|HTML_CHAR_ENTITIES
init|=
block|{
literal|"AElig"
block|,
literal|"Aacute"
block|,
literal|"Acirc"
block|,
literal|"Agrave"
block|,
literal|"Alpha"
block|,
literal|"AMP"
block|,
literal|"Aring"
block|,
literal|"Atilde"
block|,
literal|"Auml"
block|,
literal|"Beta"
block|,
literal|"COPY"
block|,
literal|"Ccedil"
block|,
literal|"Chi"
block|,
literal|"Dagger"
block|,
literal|"Delta"
block|,
literal|"ETH"
block|,
literal|"Eacute"
block|,
literal|"Ecirc"
block|,
literal|"Egrave"
block|,
literal|"Epsilon"
block|,
literal|"Eta"
block|,
literal|"Euml"
block|,
literal|"Gamma"
block|,
literal|"GT"
block|,
literal|"Iacute"
block|,
literal|"Icirc"
block|,
literal|"Igrave"
block|,
literal|"Iota"
block|,
literal|"Iuml"
block|,
literal|"Kappa"
block|,
literal|"Lambda"
block|,
literal|"LT"
block|,
literal|"Mu"
block|,
literal|"Ntilde"
block|,
literal|"Nu"
block|,
literal|"OElig"
block|,
literal|"Oacute"
block|,
literal|"Ocirc"
block|,
literal|"Ograve"
block|,
literal|"Omega"
block|,
literal|"Omicron"
block|,
literal|"Oslash"
block|,
literal|"Otilde"
block|,
literal|"Ouml"
block|,
literal|"Phi"
block|,
literal|"Pi"
block|,
literal|"Prime"
block|,
literal|"Psi"
block|,
literal|"QUOT"
block|,
literal|"REG"
block|,
literal|"Rho"
block|,
literal|"Scaron"
block|,
literal|"Sigma"
block|,
literal|"THORN"
block|,
literal|"Tau"
block|,
literal|"Theta"
block|,
literal|"Uacute"
block|,
literal|"Ucirc"
block|,
literal|"Ugrave"
block|,
literal|"Upsilon"
block|,
literal|"Uuml"
block|,
literal|"Xi"
block|,
literal|"Yacute"
block|,
literal|"Yuml"
block|,
literal|"Zeta"
block|,
literal|"aacute"
block|,
literal|"acirc"
block|,
literal|"acute"
block|,
literal|"aelig"
block|,
literal|"agrave"
block|,
literal|"alefsym"
block|,
literal|"alpha"
block|,
literal|"amp"
block|,
literal|"and"
block|,
literal|"ang"
block|,
literal|"apos"
block|,
literal|"aring"
block|,
literal|"asymp"
block|,
literal|"atilde"
block|,
literal|"auml"
block|,
literal|"bdquo"
block|,
literal|"beta"
block|,
literal|"brvbar"
block|,
literal|"bull"
block|,
literal|"cap"
block|,
literal|"ccedil"
block|,
literal|"cedil"
block|,
literal|"cent"
block|,
literal|"chi"
block|,
literal|"circ"
block|,
literal|"clubs"
block|,
literal|"cong"
block|,
literal|"copy"
block|,
literal|"crarr"
block|,
literal|"cup"
block|,
literal|"curren"
block|,
literal|"dArr"
block|,
literal|"dagger"
block|,
literal|"darr"
block|,
literal|"deg"
block|,
literal|"delta"
block|,
literal|"diams"
block|,
literal|"divide"
block|,
literal|"eacute"
block|,
literal|"ecirc"
block|,
literal|"egrave"
block|,
literal|"empty"
block|,
literal|"emsp"
block|,
literal|"ensp"
block|,
literal|"epsilon"
block|,
literal|"equiv"
block|,
literal|"eta"
block|,
literal|"eth"
block|,
literal|"euml"
block|,
literal|"euro"
block|,
literal|"exist"
block|,
literal|"fnof"
block|,
literal|"forall"
block|,
literal|"frac12"
block|,
literal|"frac14"
block|,
literal|"frac34"
block|,
literal|"frasl"
block|,
literal|"gamma"
block|,
literal|"ge"
block|,
literal|"gt"
block|,
literal|"hArr"
block|,
literal|"harr"
block|,
literal|"hearts"
block|,
literal|"hellip"
block|,
literal|"iacute"
block|,
literal|"icirc"
block|,
literal|"iexcl"
block|,
literal|"igrave"
block|,
literal|"image"
block|,
literal|"infin"
block|,
literal|"int"
block|,
literal|"iota"
block|,
literal|"iquest"
block|,
literal|"isin"
block|,
literal|"iuml"
block|,
literal|"kappa"
block|,
literal|"lArr"
block|,
literal|"lambda"
block|,
literal|"lang"
block|,
literal|"laquo"
block|,
literal|"larr"
block|,
literal|"lceil"
block|,
literal|"ldquo"
block|,
literal|"le"
block|,
literal|"lfloor"
block|,
literal|"lowast"
block|,
literal|"loz"
block|,
literal|"lrm"
block|,
literal|"lsaquo"
block|,
literal|"lsquo"
block|,
literal|"lt"
block|,
literal|"macr"
block|,
literal|"mdash"
block|,
literal|"micro"
block|,
literal|"middot"
block|,
literal|"minus"
block|,
literal|"mu"
block|,
literal|"nabla"
block|,
literal|"nbsp"
block|,
literal|"ndash"
block|,
literal|"ne"
block|,
literal|"ni"
block|,
literal|"not"
block|,
literal|"notin"
block|,
literal|"nsub"
block|,
literal|"ntilde"
block|,
literal|"nu"
block|,
literal|"oacute"
block|,
literal|"ocirc"
block|,
literal|"oelig"
block|,
literal|"ograve"
block|,
literal|"oline"
block|,
literal|"omega"
block|,
literal|"omicron"
block|,
literal|"oplus"
block|,
literal|"or"
block|,
literal|"ordf"
block|,
literal|"ordm"
block|,
literal|"oslash"
block|,
literal|"otilde"
block|,
literal|"otimes"
block|,
literal|"ouml"
block|,
literal|"para"
block|,
literal|"part"
block|,
literal|"permil"
block|,
literal|"perp"
block|,
literal|"phi"
block|,
literal|"pi"
block|,
literal|"piv"
block|,
literal|"plusmn"
block|,
literal|"pound"
block|,
literal|"prime"
block|,
literal|"prod"
block|,
literal|"prop"
block|,
literal|"psi"
block|,
literal|"quot"
block|,
literal|"rArr"
block|,
literal|"radic"
block|,
literal|"rang"
block|,
literal|"raquo"
block|,
literal|"rarr"
block|,
literal|"rceil"
block|,
literal|"rdquo"
block|,
literal|"real"
block|,
literal|"reg"
block|,
literal|"rfloor"
block|,
literal|"rho"
block|,
literal|"rlm"
block|,
literal|"rsaquo"
block|,
literal|"rsquo"
block|,
literal|"sbquo"
block|,
literal|"scaron"
block|,
literal|"sdot"
block|,
literal|"sect"
block|,
literal|"shy"
block|,
literal|"sigma"
block|,
literal|"sigmaf"
block|,
literal|"sim"
block|,
literal|"spades"
block|,
literal|"sub"
block|,
literal|"sube"
block|,
literal|"sum"
block|,
literal|"sup"
block|,
literal|"sup1"
block|,
literal|"sup2"
block|,
literal|"sup3"
block|,
literal|"supe"
block|,
literal|"szlig"
block|,
literal|"tau"
block|,
literal|"there4"
block|,
literal|"theta"
block|,
literal|"thetasym"
block|,
literal|"thinsp"
block|,
literal|"thorn"
block|,
literal|"tilde"
block|,
literal|"times"
block|,
literal|"trade"
block|,
literal|"uArr"
block|,
literal|"uacute"
block|,
literal|"uarr"
block|,
literal|"ucirc"
block|,
literal|"ugrave"
block|,
literal|"uml"
block|,
literal|"upsih"
block|,
literal|"upsilon"
block|,
literal|"uuml"
block|,
literal|"weierp"
block|,
literal|"xi"
block|,
literal|"yacute"
block|,
literal|"yen"
block|,
literal|"yuml"
block|,
literal|"zeta"
block|,
literal|"zwj"
block|,
literal|"zwnj"
block|}
decl_stmt|;
DECL|method|randomHtmlishString
specifier|public
specifier|static
name|String
name|randomHtmlishString
parameter_list|(
name|Random
name|random
parameter_list|,
name|int
name|numElements
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|numElements
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
literal|0
condition|)
block|{
comment|// allow 0 length
return|return
literal|""
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|int
name|val
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|25
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
literal|0
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"<p>"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"<"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"    "
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|randomSimpleString
argument_list|(
name|random
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|randomSimpleString
argument_list|(
name|random
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" "
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" "
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\""
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|randomSimpleString
argument_list|(
name|random
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\""
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"    "
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"/"
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|">"
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|2
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"</"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"    "
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|randomSimpleString
argument_list|(
name|random
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"    "
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|">"
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|3
case|:
name|sb
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"</p>"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"<!--"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"<!--#"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"<script><!-- f('"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"</script>"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"<?"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"?>"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\\'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"-->"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"&"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|sb
operator|.
name|append
argument_list|(
name|randomSimpleString
argument_list|(
name|random
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sb
operator|.
name|append
argument_list|(
name|HTML_CHAR_ENTITIES
index|[
name|random
operator|.
name|nextInt
argument_list|(
name|HTML_CHAR_ENTITIES
operator|.
name|length
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|";"
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|17
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"&#"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|";"
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|18
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"&#x"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|1
argument_list|)
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|";"
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|19
case|:
name|sb
operator|.
name|append
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|20
case|:
name|sb
operator|.
name|append
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|21
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|22
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"          "
operator|.
name|substring
argument_list|(
name|nextInt
argument_list|(
name|random
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sb
operator|.
name|append
argument_list|(
name|randomSimpleString
argument_list|(
name|random
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|field|blockStarts
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|blockStarts
init|=
block|{
literal|0x0000
block|,
literal|0x0080
block|,
literal|0x0100
block|,
literal|0x0180
block|,
literal|0x0250
block|,
literal|0x02B0
block|,
literal|0x0300
block|,
literal|0x0370
block|,
literal|0x0400
block|,
literal|0x0500
block|,
literal|0x0530
block|,
literal|0x0590
block|,
literal|0x0600
block|,
literal|0x0700
block|,
literal|0x0750
block|,
literal|0x0780
block|,
literal|0x07C0
block|,
literal|0x0800
block|,
literal|0x0900
block|,
literal|0x0980
block|,
literal|0x0A00
block|,
literal|0x0A80
block|,
literal|0x0B00
block|,
literal|0x0B80
block|,
literal|0x0C00
block|,
literal|0x0C80
block|,
literal|0x0D00
block|,
literal|0x0D80
block|,
literal|0x0E00
block|,
literal|0x0E80
block|,
literal|0x0F00
block|,
literal|0x1000
block|,
literal|0x10A0
block|,
literal|0x1100
block|,
literal|0x1200
block|,
literal|0x1380
block|,
literal|0x13A0
block|,
literal|0x1400
block|,
literal|0x1680
block|,
literal|0x16A0
block|,
literal|0x1700
block|,
literal|0x1720
block|,
literal|0x1740
block|,
literal|0x1760
block|,
literal|0x1780
block|,
literal|0x1800
block|,
literal|0x18B0
block|,
literal|0x1900
block|,
literal|0x1950
block|,
literal|0x1980
block|,
literal|0x19E0
block|,
literal|0x1A00
block|,
literal|0x1A20
block|,
literal|0x1B00
block|,
literal|0x1B80
block|,
literal|0x1C00
block|,
literal|0x1C50
block|,
literal|0x1CD0
block|,
literal|0x1D00
block|,
literal|0x1D80
block|,
literal|0x1DC0
block|,
literal|0x1E00
block|,
literal|0x1F00
block|,
literal|0x2000
block|,
literal|0x2070
block|,
literal|0x20A0
block|,
literal|0x20D0
block|,
literal|0x2100
block|,
literal|0x2150
block|,
literal|0x2190
block|,
literal|0x2200
block|,
literal|0x2300
block|,
literal|0x2400
block|,
literal|0x2440
block|,
literal|0x2460
block|,
literal|0x2500
block|,
literal|0x2580
block|,
literal|0x25A0
block|,
literal|0x2600
block|,
literal|0x2700
block|,
literal|0x27C0
block|,
literal|0x27F0
block|,
literal|0x2800
block|,
literal|0x2900
block|,
literal|0x2980
block|,
literal|0x2A00
block|,
literal|0x2B00
block|,
literal|0x2C00
block|,
literal|0x2C60
block|,
literal|0x2C80
block|,
literal|0x2D00
block|,
literal|0x2D30
block|,
literal|0x2D80
block|,
literal|0x2DE0
block|,
literal|0x2E00
block|,
literal|0x2E80
block|,
literal|0x2F00
block|,
literal|0x2FF0
block|,
literal|0x3000
block|,
literal|0x3040
block|,
literal|0x30A0
block|,
literal|0x3100
block|,
literal|0x3130
block|,
literal|0x3190
block|,
literal|0x31A0
block|,
literal|0x31C0
block|,
literal|0x31F0
block|,
literal|0x3200
block|,
literal|0x3300
block|,
literal|0x3400
block|,
literal|0x4DC0
block|,
literal|0x4E00
block|,
literal|0xA000
block|,
literal|0xA490
block|,
literal|0xA4D0
block|,
literal|0xA500
block|,
literal|0xA640
block|,
literal|0xA6A0
block|,
literal|0xA700
block|,
literal|0xA720
block|,
literal|0xA800
block|,
literal|0xA830
block|,
literal|0xA840
block|,
literal|0xA880
block|,
literal|0xA8E0
block|,
literal|0xA900
block|,
literal|0xA930
block|,
literal|0xA960
block|,
literal|0xA980
block|,
literal|0xAA00
block|,
literal|0xAA60
block|,
literal|0xAA80
block|,
literal|0xABC0
block|,
literal|0xAC00
block|,
literal|0xD7B0
block|,
literal|0xE000
block|,
literal|0xF900
block|,
literal|0xFB00
block|,
literal|0xFB50
block|,
literal|0xFE00
block|,
literal|0xFE10
block|,
literal|0xFE20
block|,
literal|0xFE30
block|,
literal|0xFE50
block|,
literal|0xFE70
block|,
literal|0xFF00
block|,
literal|0xFFF0
block|,
literal|0x10000
block|,
literal|0x10080
block|,
literal|0x10100
block|,
literal|0x10140
block|,
literal|0x10190
block|,
literal|0x101D0
block|,
literal|0x10280
block|,
literal|0x102A0
block|,
literal|0x10300
block|,
literal|0x10330
block|,
literal|0x10380
block|,
literal|0x103A0
block|,
literal|0x10400
block|,
literal|0x10450
block|,
literal|0x10480
block|,
literal|0x10800
block|,
literal|0x10840
block|,
literal|0x10900
block|,
literal|0x10920
block|,
literal|0x10A00
block|,
literal|0x10A60
block|,
literal|0x10B00
block|,
literal|0x10B40
block|,
literal|0x10B60
block|,
literal|0x10C00
block|,
literal|0x10E60
block|,
literal|0x11080
block|,
literal|0x12000
block|,
literal|0x12400
block|,
literal|0x13000
block|,
literal|0x1D000
block|,
literal|0x1D100
block|,
literal|0x1D200
block|,
literal|0x1D300
block|,
literal|0x1D360
block|,
literal|0x1D400
block|,
literal|0x1F000
block|,
literal|0x1F030
block|,
literal|0x1F100
block|,
literal|0x1F200
block|,
literal|0x20000
block|,
literal|0x2A700
block|,
literal|0x2F800
block|,
literal|0xE0000
block|,
literal|0xE0100
block|,
literal|0xF0000
block|,
literal|0x100000
block|}
decl_stmt|;
DECL|field|blockEnds
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|blockEnds
init|=
block|{
literal|0x007F
block|,
literal|0x00FF
block|,
literal|0x017F
block|,
literal|0x024F
block|,
literal|0x02AF
block|,
literal|0x02FF
block|,
literal|0x036F
block|,
literal|0x03FF
block|,
literal|0x04FF
block|,
literal|0x052F
block|,
literal|0x058F
block|,
literal|0x05FF
block|,
literal|0x06FF
block|,
literal|0x074F
block|,
literal|0x077F
block|,
literal|0x07BF
block|,
literal|0x07FF
block|,
literal|0x083F
block|,
literal|0x097F
block|,
literal|0x09FF
block|,
literal|0x0A7F
block|,
literal|0x0AFF
block|,
literal|0x0B7F
block|,
literal|0x0BFF
block|,
literal|0x0C7F
block|,
literal|0x0CFF
block|,
literal|0x0D7F
block|,
literal|0x0DFF
block|,
literal|0x0E7F
block|,
literal|0x0EFF
block|,
literal|0x0FFF
block|,
literal|0x109F
block|,
literal|0x10FF
block|,
literal|0x11FF
block|,
literal|0x137F
block|,
literal|0x139F
block|,
literal|0x13FF
block|,
literal|0x167F
block|,
literal|0x169F
block|,
literal|0x16FF
block|,
literal|0x171F
block|,
literal|0x173F
block|,
literal|0x175F
block|,
literal|0x177F
block|,
literal|0x17FF
block|,
literal|0x18AF
block|,
literal|0x18FF
block|,
literal|0x194F
block|,
literal|0x197F
block|,
literal|0x19DF
block|,
literal|0x19FF
block|,
literal|0x1A1F
block|,
literal|0x1AAF
block|,
literal|0x1B7F
block|,
literal|0x1BBF
block|,
literal|0x1C4F
block|,
literal|0x1C7F
block|,
literal|0x1CFF
block|,
literal|0x1D7F
block|,
literal|0x1DBF
block|,
literal|0x1DFF
block|,
literal|0x1EFF
block|,
literal|0x1FFF
block|,
literal|0x206F
block|,
literal|0x209F
block|,
literal|0x20CF
block|,
literal|0x20FF
block|,
literal|0x214F
block|,
literal|0x218F
block|,
literal|0x21FF
block|,
literal|0x22FF
block|,
literal|0x23FF
block|,
literal|0x243F
block|,
literal|0x245F
block|,
literal|0x24FF
block|,
literal|0x257F
block|,
literal|0x259F
block|,
literal|0x25FF
block|,
literal|0x26FF
block|,
literal|0x27BF
block|,
literal|0x27EF
block|,
literal|0x27FF
block|,
literal|0x28FF
block|,
literal|0x297F
block|,
literal|0x29FF
block|,
literal|0x2AFF
block|,
literal|0x2BFF
block|,
literal|0x2C5F
block|,
literal|0x2C7F
block|,
literal|0x2CFF
block|,
literal|0x2D2F
block|,
literal|0x2D7F
block|,
literal|0x2DDF
block|,
literal|0x2DFF
block|,
literal|0x2E7F
block|,
literal|0x2EFF
block|,
literal|0x2FDF
block|,
literal|0x2FFF
block|,
literal|0x303F
block|,
literal|0x309F
block|,
literal|0x30FF
block|,
literal|0x312F
block|,
literal|0x318F
block|,
literal|0x319F
block|,
literal|0x31BF
block|,
literal|0x31EF
block|,
literal|0x31FF
block|,
literal|0x32FF
block|,
literal|0x33FF
block|,
literal|0x4DBF
block|,
literal|0x4DFF
block|,
literal|0x9FFF
block|,
literal|0xA48F
block|,
literal|0xA4CF
block|,
literal|0xA4FF
block|,
literal|0xA63F
block|,
literal|0xA69F
block|,
literal|0xA6FF
block|,
literal|0xA71F
block|,
literal|0xA7FF
block|,
literal|0xA82F
block|,
literal|0xA83F
block|,
literal|0xA87F
block|,
literal|0xA8DF
block|,
literal|0xA8FF
block|,
literal|0xA92F
block|,
literal|0xA95F
block|,
literal|0xA97F
block|,
literal|0xA9DF
block|,
literal|0xAA5F
block|,
literal|0xAA7F
block|,
literal|0xAADF
block|,
literal|0xABFF
block|,
literal|0xD7AF
block|,
literal|0xD7FF
block|,
literal|0xF8FF
block|,
literal|0xFAFF
block|,
literal|0xFB4F
block|,
literal|0xFDFF
block|,
literal|0xFE0F
block|,
literal|0xFE1F
block|,
literal|0xFE2F
block|,
literal|0xFE4F
block|,
literal|0xFE6F
block|,
literal|0xFEFF
block|,
literal|0xFFEF
block|,
literal|0xFFFF
block|,
literal|0x1007F
block|,
literal|0x100FF
block|,
literal|0x1013F
block|,
literal|0x1018F
block|,
literal|0x101CF
block|,
literal|0x101FF
block|,
literal|0x1029F
block|,
literal|0x102DF
block|,
literal|0x1032F
block|,
literal|0x1034F
block|,
literal|0x1039F
block|,
literal|0x103DF
block|,
literal|0x1044F
block|,
literal|0x1047F
block|,
literal|0x104AF
block|,
literal|0x1083F
block|,
literal|0x1085F
block|,
literal|0x1091F
block|,
literal|0x1093F
block|,
literal|0x10A5F
block|,
literal|0x10A7F
block|,
literal|0x10B3F
block|,
literal|0x10B5F
block|,
literal|0x10B7F
block|,
literal|0x10C4F
block|,
literal|0x10E7F
block|,
literal|0x110CF
block|,
literal|0x123FF
block|,
literal|0x1247F
block|,
literal|0x1342F
block|,
literal|0x1D0FF
block|,
literal|0x1D1FF
block|,
literal|0x1D24F
block|,
literal|0x1D35F
block|,
literal|0x1D37F
block|,
literal|0x1D7FF
block|,
literal|0x1F02F
block|,
literal|0x1F09F
block|,
literal|0x1F1FF
block|,
literal|0x1F2FF
block|,
literal|0x2A6DF
block|,
literal|0x2B73F
block|,
literal|0x2FA1F
block|,
literal|0xE007F
block|,
literal|0xE01EF
block|,
literal|0xFFFFF
block|,
literal|0x10FFFF
block|}
decl_stmt|;
comment|/** Returns random string of length between 0-20 codepoints, all codepoints within the same unicode block. */
DECL|method|randomRealisticUnicodeString
specifier|public
specifier|static
name|String
name|randomRealisticUnicodeString
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
return|return
name|randomRealisticUnicodeString
argument_list|(
name|r
argument_list|,
literal|20
argument_list|)
return|;
block|}
comment|/** Returns random string of length up to maxLength codepoints , all codepoints within the same unicode block. */
DECL|method|randomRealisticUnicodeString
specifier|public
specifier|static
name|String
name|randomRealisticUnicodeString
parameter_list|(
name|Random
name|r
parameter_list|,
name|int
name|maxLength
parameter_list|)
block|{
return|return
name|randomRealisticUnicodeString
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|)
return|;
block|}
comment|/** Returns random string of length between min and max codepoints, all codepoints within the same unicode block. */
DECL|method|randomRealisticUnicodeString
specifier|public
specifier|static
name|String
name|randomRealisticUnicodeString
parameter_list|(
name|Random
name|r
parameter_list|,
name|int
name|minLength
parameter_list|,
name|int
name|maxLength
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|minLength
operator|+
name|r
operator|.
name|nextInt
argument_list|(
name|maxLength
argument_list|)
decl_stmt|;
specifier|final
name|int
name|block
init|=
name|r
operator|.
name|nextInt
argument_list|(
name|blockStarts
operator|.
name|length
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
name|sb
operator|.
name|appendCodePoint
argument_list|(
name|nextInt
argument_list|(
name|r
argument_list|,
name|blockStarts
index|[
name|block
index|]
argument_list|,
name|blockEnds
index|[
name|block
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Returns random string, with a given UTF-8 byte length*/
DECL|method|randomFixedByteLengthUnicodeString
specifier|public
specifier|static
name|String
name|randomFixedByteLengthUnicodeString
parameter_list|(
name|Random
name|r
parameter_list|,
name|int
name|length
parameter_list|)
block|{
specifier|final
name|char
index|[]
name|buffer
init|=
operator|new
name|char
index|[
name|length
operator|*
literal|3
index|]
decl_stmt|;
name|int
name|bytes
init|=
name|length
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|buffer
operator|.
name|length
operator|&&
name|bytes
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|int
name|t
decl_stmt|;
if|if
condition|(
name|bytes
operator|>=
literal|4
condition|)
block|{
name|t
operator|=
name|r
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|3
condition|)
block|{
name|t
operator|=
name|r
operator|.
name|nextInt
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|2
condition|)
block|{
name|t
operator|=
name|r
operator|.
name|nextInt
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|r
operator|.
name|nextInt
argument_list|(
literal|0x80
argument_list|)
expr_stmt|;
name|bytes
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|1
operator|==
name|t
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|r
argument_list|,
literal|0x80
argument_list|,
literal|0x7ff
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|2
operator|==
name|t
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|r
argument_list|,
literal|0x800
argument_list|,
literal|0xd7ff
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|3
operator|==
name|t
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|r
argument_list|,
literal|0xe000
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|4
operator|==
name|t
condition|)
block|{
comment|// Make a surrogate pair
comment|// High surrogate
name|buffer
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|r
argument_list|,
literal|0xd800
argument_list|,
literal|0xdbff
argument_list|)
expr_stmt|;
comment|// Low surrogate
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|nextInt
argument_list|(
name|r
argument_list|,
literal|0xdc00
argument_list|,
literal|0xdfff
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|4
expr_stmt|;
block|}
block|}
return|return
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
return|;
block|}
comment|/** Return a Codec that can read any of the    *  default codecs and formats, but always writes in the specified    *  format. */
DECL|method|alwaysPostingsFormat
specifier|public
specifier|static
name|Codec
name|alwaysPostingsFormat
parameter_list|(
specifier|final
name|PostingsFormat
name|format
parameter_list|)
block|{
return|return
operator|new
name|Lucene40Codec
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|PostingsFormat
name|getPostingsFormatForField
parameter_list|(
name|String
name|field
parameter_list|)
block|{
return|return
name|format
return|;
block|}
block|}
return|;
block|}
comment|// TODO: generalize all 'test-checks-for-crazy-codecs' to
comment|// annotations (LUCENE-3489)
DECL|method|getPostingsFormat
specifier|public
specifier|static
name|String
name|getPostingsFormat
parameter_list|(
name|String
name|field
parameter_list|)
block|{
name|PostingsFormat
name|p
init|=
name|Codec
operator|.
name|getDefault
argument_list|()
operator|.
name|postingsFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|instanceof
name|PerFieldPostingsFormat
condition|)
block|{
return|return
operator|(
operator|(
name|PerFieldPostingsFormat
operator|)
name|p
operator|)
operator|.
name|getPostingsFormatForField
argument_list|(
name|field
argument_list|)
operator|.
name|getName
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|p
operator|.
name|getName
argument_list|()
return|;
block|}
block|}
DECL|method|anyFilesExceptWriteLock
specifier|public
specifier|static
name|boolean
name|anyFilesExceptWriteLock
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
name|String
index|[]
name|files
init|=
name|dir
operator|.
name|listAll
argument_list|()
decl_stmt|;
if|if
condition|(
name|files
operator|.
name|length
operator|>
literal|1
operator|||
operator|(
name|files
operator|.
name|length
operator|==
literal|1
operator|&&
operator|!
name|files
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"write.lock"
argument_list|)
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/** just tries to configure things to keep the open file    * count lowish */
DECL|method|reduceOpenFiles
specifier|public
specifier|static
name|void
name|reduceOpenFiles
parameter_list|(
name|IndexWriter
name|w
parameter_list|)
block|{
comment|// keep number of open files lowish
name|MergePolicy
name|mp
init|=
name|w
operator|.
name|getConfig
argument_list|()
operator|.
name|getMergePolicy
argument_list|()
decl_stmt|;
if|if
condition|(
name|mp
operator|instanceof
name|LogMergePolicy
condition|)
block|{
name|LogMergePolicy
name|lmp
init|=
operator|(
name|LogMergePolicy
operator|)
name|mp
decl_stmt|;
name|lmp
operator|.
name|setMergeFactor
argument_list|(
name|Math
operator|.
name|min
argument_list|(
literal|5
argument_list|,
name|lmp
operator|.
name|getMergeFactor
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|instanceof
name|TieredMergePolicy
condition|)
block|{
name|TieredMergePolicy
name|tmp
init|=
operator|(
name|TieredMergePolicy
operator|)
name|mp
decl_stmt|;
name|tmp
operator|.
name|setMaxMergeAtOnce
argument_list|(
name|Math
operator|.
name|min
argument_list|(
literal|5
argument_list|,
name|tmp
operator|.
name|getMaxMergeAtOnce
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setSegmentsPerTier
argument_list|(
name|Math
operator|.
name|min
argument_list|(
literal|5
argument_list|,
name|tmp
operator|.
name|getSegmentsPerTier
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MergeScheduler
name|ms
init|=
name|w
operator|.
name|getConfig
argument_list|()
operator|.
name|getMergeScheduler
argument_list|()
decl_stmt|;
if|if
condition|(
name|ms
operator|instanceof
name|ConcurrentMergeScheduler
condition|)
block|{
operator|(
operator|(
name|ConcurrentMergeScheduler
operator|)
name|ms
operator|)
operator|.
name|setMaxThreadCount
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ConcurrentMergeScheduler
operator|)
name|ms
operator|)
operator|.
name|setMaxMergeCount
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Checks some basic behaviour of an AttributeImpl    * @param reflectedValues contains a map with "AttributeClass#key" as values    */
DECL|method|assertAttributeReflection
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|assertAttributeReflection
parameter_list|(
specifier|final
name|AttributeImpl
name|att
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|reflectedValues
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|att
operator|.
name|reflectWith
argument_list|(
operator|new
name|AttributeReflector
argument_list|()
block|{
specifier|public
name|void
name|reflect
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Attribute
argument_list|>
name|attClass
parameter_list|,
name|String
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|map
operator|.
name|put
argument_list|(
name|attClass
operator|.
name|getName
argument_list|()
operator|+
literal|'#'
operator|+
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Reflection does not produce same map"
argument_list|,
name|reflectedValues
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|keepFullyDeletedSegments
specifier|public
specifier|static
name|void
name|keepFullyDeletedSegments
parameter_list|(
name|IndexWriter
name|w
parameter_list|)
block|{
try|try
block|{
comment|// Carefully invoke what is a package-private (test
comment|// only, internal) method on IndexWriter:
name|Method
name|m
init|=
name|IndexWriter
operator|.
name|class
operator|.
name|getDeclaredMethod
argument_list|(
literal|"keepFullyDeletedSegments"
argument_list|)
decl_stmt|;
name|m
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|m
operator|.
name|invoke
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Should not happen?
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Adds field info for a Document. */
DECL|method|add
specifier|public
specifier|static
name|void
name|add
parameter_list|(
name|Document
name|doc
parameter_list|,
name|FieldInfos
name|fieldInfos
parameter_list|)
block|{
for|for
control|(
name|IndexableField
name|field
range|:
name|doc
control|)
block|{
name|fieldInfos
operator|.
name|addOrUpdate
argument_list|(
name|field
operator|.
name|name
argument_list|()
argument_list|,
name|field
operator|.
name|fieldType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * insecure, fast version of File.createTempFile    * uses Random instead of SecureRandom.    */
DECL|method|createTempFile
specifier|public
specifier|static
name|File
name|createTempFile
parameter_list|(
name|String
name|prefix
parameter_list|,
name|String
name|suffix
parameter_list|,
name|File
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Force a prefix null check first
if|if
condition|(
name|prefix
operator|.
name|length
argument_list|()
operator|<
literal|3
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"prefix must be 3"
argument_list|)
throw|;
block|}
name|String
name|newSuffix
init|=
name|suffix
operator|==
literal|null
condition|?
literal|".tmp"
else|:
name|suffix
decl_stmt|;
name|File
name|result
decl_stmt|;
do|do
block|{
name|result
operator|=
name|genTempFile
argument_list|(
name|prefix
argument_list|,
name|newSuffix
argument_list|,
name|directory
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|result
operator|.
name|createNewFile
argument_list|()
condition|)
do|;
return|return
name|result
return|;
block|}
comment|/* Temp file counter */
DECL|field|counter
specifier|private
specifier|static
name|int
name|counter
init|=
literal|0
decl_stmt|;
comment|/* identify for differnt VM processes */
DECL|field|counterBase
specifier|private
specifier|static
name|int
name|counterBase
init|=
literal|0
decl_stmt|;
DECL|class|TempFileLocker
specifier|private
specifier|static
class|class
name|TempFileLocker
block|{}
empty_stmt|;
DECL|field|tempFileLocker
specifier|private
specifier|static
name|TempFileLocker
name|tempFileLocker
init|=
operator|new
name|TempFileLocker
argument_list|()
decl_stmt|;
DECL|method|genTempFile
specifier|private
specifier|static
name|File
name|genTempFile
parameter_list|(
name|String
name|prefix
parameter_list|,
name|String
name|suffix
parameter_list|,
name|File
name|directory
parameter_list|)
block|{
name|int
name|identify
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|tempFileLocker
init|)
block|{
if|if
condition|(
name|counter
operator|==
literal|0
condition|)
block|{
name|int
name|newInt
init|=
operator|new
name|Random
argument_list|()
operator|.
name|nextInt
argument_list|()
decl_stmt|;
name|counter
operator|=
operator|(
operator|(
name|newInt
operator|/
literal|65535
operator|)
operator|&
literal|0xFFFF
operator|)
operator|+
literal|0x2710
expr_stmt|;
name|counterBase
operator|=
name|counter
expr_stmt|;
block|}
name|identify
operator|=
name|counter
operator|++
expr_stmt|;
block|}
name|StringBuilder
name|newName
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|newName
operator|.
name|append
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|newName
operator|.
name|append
argument_list|(
name|counterBase
argument_list|)
expr_stmt|;
name|newName
operator|.
name|append
argument_list|(
name|identify
argument_list|)
expr_stmt|;
name|newName
operator|.
name|append
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
return|return
operator|new
name|File
argument_list|(
name|directory
argument_list|,
name|newName
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
DECL|method|assertEquals
specifier|public
specifier|static
name|void
name|assertEquals
parameter_list|(
name|TopDocs
name|expected
parameter_list|,
name|TopDocs
name|actual
parameter_list|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"wrong total hits"
argument_list|,
name|expected
operator|.
name|totalHits
argument_list|,
name|actual
operator|.
name|totalHits
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"wrong maxScore"
argument_list|,
name|expected
operator|.
name|getMaxScore
argument_list|()
argument_list|,
name|actual
operator|.
name|getMaxScore
argument_list|()
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"wrong hit count"
argument_list|,
name|expected
operator|.
name|scoreDocs
operator|.
name|length
argument_list|,
name|actual
operator|.
name|scoreDocs
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|hitIDX
init|=
literal|0
init|;
name|hitIDX
operator|<
name|expected
operator|.
name|scoreDocs
operator|.
name|length
condition|;
name|hitIDX
operator|++
control|)
block|{
specifier|final
name|ScoreDoc
name|expectedSD
init|=
name|expected
operator|.
name|scoreDocs
index|[
name|hitIDX
index|]
decl_stmt|;
specifier|final
name|ScoreDoc
name|actualSD
init|=
name|actual
operator|.
name|scoreDocs
index|[
name|hitIDX
index|]
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"wrong hit docID"
argument_list|,
name|expectedSD
operator|.
name|doc
argument_list|,
name|actualSD
operator|.
name|doc
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"wrong hit score"
argument_list|,
name|expectedSD
operator|.
name|score
argument_list|,
name|actualSD
operator|.
name|score
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedSD
operator|instanceof
name|FieldDoc
condition|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|actualSD
operator|instanceof
name|FieldDoc
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertArrayEquals
argument_list|(
literal|"wrong sort field values"
argument_list|,
operator|(
operator|(
name|FieldDoc
operator|)
name|expectedSD
operator|)
operator|.
name|fields
argument_list|,
operator|(
operator|(
name|FieldDoc
operator|)
name|actualSD
operator|)
operator|.
name|fields
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Assert
operator|.
name|assertFalse
argument_list|(
name|actualSD
operator|instanceof
name|FieldDoc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// NOTE: this is likely buggy, and cannot clone fields
comment|// with tokenStreamValues, etc.  Use at your own risk!!
comment|// TODO: is there a pre-existing way to do this!!!
DECL|method|cloneDocument
specifier|public
specifier|static
name|Document
name|cloneDocument
parameter_list|(
name|Document
name|doc1
parameter_list|)
block|{
specifier|final
name|Document
name|doc2
init|=
operator|new
name|Document
argument_list|()
decl_stmt|;
for|for
control|(
name|IndexableField
name|f
range|:
name|doc1
control|)
block|{
specifier|final
name|Field
name|field1
init|=
operator|(
name|Field
operator|)
name|f
decl_stmt|;
specifier|final
name|Field
name|field2
decl_stmt|;
if|if
condition|(
name|field1
operator|instanceof
name|DocValuesField
condition|)
block|{
specifier|final
name|DocValues
operator|.
name|Type
name|dvType
init|=
name|field1
operator|.
name|fieldType
argument_list|()
operator|.
name|docValueType
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|dvType
condition|)
block|{
case|case
name|VAR_INTS
case|:
case|case
name|FIXED_INTS_8
case|:
case|case
name|FIXED_INTS_16
case|:
case|case
name|FIXED_INTS_32
case|:
case|case
name|FIXED_INTS_64
case|:
name|field2
operator|=
operator|new
name|DocValuesField
argument_list|(
name|field1
operator|.
name|name
argument_list|()
argument_list|,
name|field1
operator|.
name|numericValue
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|dvType
argument_list|)
expr_stmt|;
break|break;
case|case
name|BYTES_FIXED_DEREF
case|:
case|case
name|BYTES_FIXED_STRAIGHT
case|:
case|case
name|BYTES_VAR_DEREF
case|:
case|case
name|BYTES_VAR_STRAIGHT
case|:
case|case
name|BYTES_FIXED_SORTED
case|:
case|case
name|BYTES_VAR_SORTED
case|:
name|field2
operator|=
operator|new
name|DocValuesField
argument_list|(
name|field1
operator|.
name|name
argument_list|()
argument_list|,
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|field1
operator|.
name|binaryValue
argument_list|()
argument_list|)
argument_list|,
name|dvType
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_32
case|:
case|case
name|FLOAT_64
case|:
name|field2
operator|=
operator|new
name|DocValuesField
argument_list|(
name|field1
operator|.
name|name
argument_list|()
argument_list|,
name|field1
operator|.
name|numericValue
argument_list|()
operator|.
name|doubleValue
argument_list|()
argument_list|,
name|dvType
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"don't know how to clone DV field="
operator|+
name|field1
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|field2
operator|=
operator|new
name|Field
argument_list|(
name|field1
operator|.
name|name
argument_list|()
argument_list|,
name|field1
operator|.
name|stringValue
argument_list|()
argument_list|,
name|field1
operator|.
name|fieldType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|doc2
operator|.
name|add
argument_list|(
name|field2
argument_list|)
expr_stmt|;
block|}
return|return
name|doc2
return|;
block|}
comment|// Returns a DocsEnum, but randomly sometimes uses a
comment|// DocsAndFreqsEnum, DocsAndPositionsEnum.  Returns null
comment|// if field/term doesn't exist:
DECL|method|docs
specifier|public
specifier|static
name|DocsEnum
name|docs
parameter_list|(
name|Random
name|random
parameter_list|,
name|IndexReader
name|r
parameter_list|,
name|String
name|field
parameter_list|,
name|BytesRef
name|term
parameter_list|,
name|Bits
name|liveDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|boolean
name|needsFreqs
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Terms
name|terms
init|=
name|MultiFields
operator|.
name|getTerms
argument_list|(
name|r
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|TermsEnum
name|termsEnum
init|=
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|termsEnum
operator|.
name|seekExact
argument_list|(
name|term
argument_list|,
name|random
operator|.
name|nextBoolean
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// TODO: cast re-use to D&PE if we can...?
name|DocsAndPositionsEnum
name|docsAndPositions
init|=
name|termsEnum
operator|.
name|docsAndPositions
argument_list|(
name|liveDocs
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|docsAndPositions
operator|==
literal|null
condition|)
block|{
name|docsAndPositions
operator|=
name|termsEnum
operator|.
name|docsAndPositions
argument_list|(
name|liveDocs
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|docsAndPositions
operator|!=
literal|null
condition|)
block|{
return|return
name|docsAndPositions
return|;
block|}
block|}
specifier|final
name|DocsEnum
name|docsAndFreqs
init|=
name|termsEnum
operator|.
name|docs
argument_list|(
name|liveDocs
argument_list|,
name|reuse
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|docsAndFreqs
operator|!=
literal|null
condition|)
block|{
return|return
name|docsAndFreqs
return|;
block|}
block|}
return|return
name|termsEnum
operator|.
name|docs
argument_list|(
name|liveDocs
argument_list|,
name|reuse
argument_list|,
name|needsFreqs
argument_list|)
return|;
block|}
comment|// Returns a DocsEnum from a positioned TermsEnum, but
comment|// randomly sometimes uses a DocsAndFreqsEnum, DocsAndPositionsEnum.
DECL|method|docs
specifier|public
specifier|static
name|DocsEnum
name|docs
parameter_list|(
name|Random
name|random
parameter_list|,
name|TermsEnum
name|termsEnum
parameter_list|,
name|Bits
name|liveDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|boolean
name|needsFreqs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
if|if
condition|(
name|random
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// TODO: cast re-use to D&PE if we can...?
name|DocsAndPositionsEnum
name|docsAndPositions
init|=
name|termsEnum
operator|.
name|docsAndPositions
argument_list|(
name|liveDocs
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|docsAndPositions
operator|==
literal|null
condition|)
block|{
name|docsAndPositions
operator|=
name|termsEnum
operator|.
name|docsAndPositions
argument_list|(
name|liveDocs
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|docsAndPositions
operator|!=
literal|null
condition|)
block|{
return|return
name|docsAndPositions
return|;
block|}
block|}
specifier|final
name|DocsEnum
name|docsAndFreqs
init|=
name|termsEnum
operator|.
name|docs
argument_list|(
name|liveDocs
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|docsAndFreqs
operator|!=
literal|null
condition|)
block|{
return|return
name|docsAndFreqs
return|;
block|}
block|}
return|return
name|termsEnum
operator|.
name|docs
argument_list|(
name|liveDocs
argument_list|,
literal|null
argument_list|,
name|needsFreqs
argument_list|)
return|;
block|}
DECL|method|stringToCharSequence
specifier|public
specifier|static
name|CharSequence
name|stringToCharSequence
parameter_list|(
name|String
name|string
parameter_list|,
name|Random
name|random
parameter_list|)
block|{
return|return
name|bytesToCharSequence
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|string
argument_list|)
argument_list|,
name|random
argument_list|)
return|;
block|}
DECL|method|bytesToCharSequence
specifier|public
specifier|static
name|CharSequence
name|bytesToCharSequence
parameter_list|(
name|BytesRef
name|ref
parameter_list|,
name|Random
name|random
parameter_list|)
block|{
switch|switch
condition|(
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
name|CharsRef
name|chars
init|=
operator|new
name|CharsRef
argument_list|(
name|ref
operator|.
name|length
argument_list|)
decl_stmt|;
name|UnicodeUtil
operator|.
name|UTF8toUTF16
argument_list|(
name|ref
operator|.
name|bytes
argument_list|,
name|ref
operator|.
name|offset
argument_list|,
name|ref
operator|.
name|length
argument_list|,
name|chars
argument_list|)
expr_stmt|;
return|return
name|chars
return|;
case|case
literal|3
case|:
return|return
name|CharBuffer
operator|.
name|wrap
argument_list|(
name|ref
operator|.
name|utf8ToString
argument_list|()
argument_list|)
return|;
default|default:
return|return
name|ref
operator|.
name|utf8ToString
argument_list|()
return|;
block|}
block|}
block|}
end_class
end_unit
