begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.geo
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|geo
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|NumericUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|SloppyMath
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|RandomizedContext
import|;
end_import
begin_comment
comment|/** static methods for testing geo */
end_comment
begin_class
DECL|class|GeoTestUtil
specifier|public
class|class
name|GeoTestUtil
block|{
comment|/** returns next pseudorandom latitude (anywhere) */
DECL|method|nextLatitude
specifier|public
specifier|static
name|double
name|nextLatitude
parameter_list|()
block|{
return|return
name|nextDoubleInternal
argument_list|(
operator|-
literal|90
argument_list|,
literal|90
argument_list|)
return|;
block|}
comment|/** returns next pseudorandom longitude (anywhere) */
DECL|method|nextLongitude
specifier|public
specifier|static
name|double
name|nextLongitude
parameter_list|()
block|{
return|return
name|nextDoubleInternal
argument_list|(
operator|-
literal|180
argument_list|,
literal|180
argument_list|)
return|;
block|}
comment|/**    * Returns next double within range.    *<p>    * Don't pass huge numbers or infinity or anything like that yet. may have bugs!    */
comment|// the goal is to adjust random number generation to test edges, create more duplicates, create "one-offs" in floating point space, etc.
comment|// we do this by first picking a good "base value" (explicitly targeting edges, zero if allowed, or "discrete values"). but it also
comment|// ensures we pick any double in the range and generally still produces randomish looking numbers.
comment|// then we sometimes perturb that by one ulp.
DECL|method|nextDoubleInternal
specifier|private
specifier|static
name|double
name|nextDoubleInternal
parameter_list|(
name|double
name|low
parameter_list|,
name|double
name|high
parameter_list|)
block|{
assert|assert
name|low
operator|>=
name|Integer
operator|.
name|MIN_VALUE
assert|;
assert|assert
name|high
operator|<=
name|Integer
operator|.
name|MAX_VALUE
assert|;
assert|assert
name|Double
operator|.
name|isFinite
argument_list|(
name|low
argument_list|)
assert|;
assert|assert
name|Double
operator|.
name|isFinite
argument_list|(
name|high
argument_list|)
assert|;
assert|assert
name|high
operator|>=
name|low
operator|:
literal|"low="
operator|+
name|low
operator|+
literal|" high="
operator|+
name|high
assert|;
comment|// if they are equal, not much we can do
if|if
condition|(
name|low
operator|==
name|high
condition|)
block|{
return|return
name|low
return|;
block|}
comment|// first pick a base value.
specifier|final
name|double
name|baseValue
decl_stmt|;
name|int
name|surpriseMe
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|17
argument_list|)
decl_stmt|;
if|if
condition|(
name|surpriseMe
operator|==
literal|0
condition|)
block|{
comment|// random bits
name|long
name|lowBits
init|=
name|NumericUtils
operator|.
name|doubleToSortableLong
argument_list|(
name|low
argument_list|)
decl_stmt|;
name|long
name|highBits
init|=
name|NumericUtils
operator|.
name|doubleToSortableLong
argument_list|(
name|high
argument_list|)
decl_stmt|;
name|baseValue
operator|=
name|NumericUtils
operator|.
name|sortableLongToDouble
argument_list|(
name|TestUtil
operator|.
name|nextLong
argument_list|(
name|random
argument_list|()
argument_list|,
name|lowBits
argument_list|,
name|highBits
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|surpriseMe
operator|==
literal|1
condition|)
block|{
comment|// edge case
name|baseValue
operator|=
name|low
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|surpriseMe
operator|==
literal|2
condition|)
block|{
comment|// edge case
name|baseValue
operator|=
name|high
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|surpriseMe
operator|==
literal|3
operator|&&
name|low
operator|<=
literal|0
operator|&&
name|high
operator|>=
literal|0
condition|)
block|{
comment|// may trigger divide by 0
name|baseValue
operator|=
literal|0.0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|surpriseMe
operator|==
literal|4
condition|)
block|{
comment|// divide up space into block of 360
name|double
name|delta
init|=
operator|(
name|high
operator|-
name|low
operator|)
operator|/
literal|360
decl_stmt|;
name|int
name|block
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|360
argument_list|)
decl_stmt|;
name|baseValue
operator|=
name|low
operator|+
name|delta
operator|*
name|block
expr_stmt|;
block|}
else|else
block|{
comment|// distributed ~ evenly
name|baseValue
operator|=
name|low
operator|+
operator|(
name|high
operator|-
name|low
operator|)
operator|*
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
expr_stmt|;
block|}
assert|assert
name|baseValue
operator|>=
name|low
assert|;
assert|assert
name|baseValue
operator|<=
name|high
assert|;
comment|// either return the base value or adjust it by 1 ulp in a random direction (if possible)
name|int
name|adjustMe
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|17
argument_list|)
decl_stmt|;
if|if
condition|(
name|adjustMe
operator|==
literal|0
condition|)
block|{
return|return
name|Math
operator|.
name|nextAfter
argument_list|(
name|adjustMe
argument_list|,
name|high
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|adjustMe
operator|==
literal|1
condition|)
block|{
return|return
name|Math
operator|.
name|nextAfter
argument_list|(
name|adjustMe
argument_list|,
name|low
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|baseValue
return|;
block|}
block|}
comment|/** returns next pseudorandom latitude, kinda close to {@code otherLatitude} */
DECL|method|nextLatitudeNear
specifier|private
specifier|static
name|double
name|nextLatitudeNear
parameter_list|(
name|double
name|otherLatitude
parameter_list|,
name|double
name|delta
parameter_list|)
block|{
name|delta
operator|=
name|Math
operator|.
name|abs
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|GeoUtils
operator|.
name|checkLatitude
argument_list|(
name|otherLatitude
argument_list|)
expr_stmt|;
name|int
name|surpriseMe
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|97
argument_list|)
decl_stmt|;
if|if
condition|(
name|surpriseMe
operator|==
literal|0
condition|)
block|{
comment|// purely random
return|return
name|nextLatitude
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|surpriseMe
operator|<
literal|49
condition|)
block|{
comment|// upper half of region (the exact point or 1 ulp difference is still likely)
return|return
name|nextDoubleInternal
argument_list|(
name|otherLatitude
argument_list|,
name|Math
operator|.
name|min
argument_list|(
literal|90
argument_list|,
name|otherLatitude
operator|+
name|delta
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|// lower half of region (the exact point or 1 ulp difference is still likely)
return|return
name|nextDoubleInternal
argument_list|(
name|Math
operator|.
name|max
argument_list|(
operator|-
literal|90
argument_list|,
name|otherLatitude
operator|-
name|delta
argument_list|)
argument_list|,
name|otherLatitude
argument_list|)
return|;
block|}
block|}
comment|/** returns next pseudorandom longitude, kinda close to {@code otherLongitude} */
DECL|method|nextLongitudeNear
specifier|private
specifier|static
name|double
name|nextLongitudeNear
parameter_list|(
name|double
name|otherLongitude
parameter_list|,
name|double
name|delta
parameter_list|)
block|{
name|delta
operator|=
name|Math
operator|.
name|abs
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|GeoUtils
operator|.
name|checkLongitude
argument_list|(
name|otherLongitude
argument_list|)
expr_stmt|;
name|int
name|surpriseMe
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|97
argument_list|)
decl_stmt|;
if|if
condition|(
name|surpriseMe
operator|==
literal|0
condition|)
block|{
comment|// purely random
return|return
name|nextLongitude
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|surpriseMe
operator|<
literal|49
condition|)
block|{
comment|// upper half of region (the exact point or 1 ulp difference is still likely)
return|return
name|nextDoubleInternal
argument_list|(
name|otherLongitude
argument_list|,
name|Math
operator|.
name|min
argument_list|(
literal|180
argument_list|,
name|otherLongitude
operator|+
name|delta
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|// lower half of region (the exact point or 1 ulp difference is still likely)
return|return
name|nextDoubleInternal
argument_list|(
name|Math
operator|.
name|max
argument_list|(
operator|-
literal|180
argument_list|,
name|otherLongitude
operator|-
name|delta
argument_list|)
argument_list|,
name|otherLongitude
argument_list|)
return|;
block|}
block|}
comment|/**    * returns next pseudorandom latitude, kinda close to {@code minLatitude/maxLatitude}    *<b>NOTE:</b>minLatitude/maxLatitude are merely guidelines. the returned value is sometimes    * outside of that range! this is to facilitate edge testing of lines    */
DECL|method|nextLatitudeBetween
specifier|private
specifier|static
name|double
name|nextLatitudeBetween
parameter_list|(
name|double
name|minLatitude
parameter_list|,
name|double
name|maxLatitude
parameter_list|)
block|{
assert|assert
name|maxLatitude
operator|>=
name|minLatitude
assert|;
name|GeoUtils
operator|.
name|checkLatitude
argument_list|(
name|minLatitude
argument_list|)
expr_stmt|;
name|GeoUtils
operator|.
name|checkLatitude
argument_list|(
name|maxLatitude
argument_list|)
expr_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|47
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// purely random
return|return
name|nextLatitude
argument_list|()
return|;
block|}
else|else
block|{
comment|// extend the range by 1%
name|double
name|difference
init|=
operator|(
name|maxLatitude
operator|-
name|minLatitude
operator|)
operator|/
literal|100
decl_stmt|;
name|double
name|lower
init|=
name|Math
operator|.
name|max
argument_list|(
operator|-
literal|90
argument_list|,
name|minLatitude
operator|-
name|difference
argument_list|)
decl_stmt|;
name|double
name|upper
init|=
name|Math
operator|.
name|min
argument_list|(
literal|90
argument_list|,
name|maxLatitude
operator|+
name|difference
argument_list|)
decl_stmt|;
return|return
name|nextDoubleInternal
argument_list|(
name|lower
argument_list|,
name|upper
argument_list|)
return|;
block|}
block|}
comment|/**    * returns next pseudorandom longitude, kinda close to {@code minLongitude/maxLongitude}    *<b>NOTE:</b>minLongitude/maxLongitude are merely guidelines. the returned value is sometimes    * outside of that range! this is to facilitate edge testing of lines    */
DECL|method|nextLongitudeBetween
specifier|private
specifier|static
name|double
name|nextLongitudeBetween
parameter_list|(
name|double
name|minLongitude
parameter_list|,
name|double
name|maxLongitude
parameter_list|)
block|{
assert|assert
name|maxLongitude
operator|>=
name|minLongitude
assert|;
name|GeoUtils
operator|.
name|checkLongitude
argument_list|(
name|minLongitude
argument_list|)
expr_stmt|;
name|GeoUtils
operator|.
name|checkLongitude
argument_list|(
name|maxLongitude
argument_list|)
expr_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|47
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// purely random
return|return
name|nextLongitude
argument_list|()
return|;
block|}
else|else
block|{
comment|// extend the range by 1%
name|double
name|difference
init|=
operator|(
name|maxLongitude
operator|-
name|minLongitude
operator|)
operator|/
literal|100
decl_stmt|;
name|double
name|lower
init|=
name|Math
operator|.
name|max
argument_list|(
operator|-
literal|180
argument_list|,
name|minLongitude
operator|-
name|difference
argument_list|)
decl_stmt|;
name|double
name|upper
init|=
name|Math
operator|.
name|min
argument_list|(
literal|180
argument_list|,
name|maxLongitude
operator|+
name|difference
argument_list|)
decl_stmt|;
return|return
name|nextDoubleInternal
argument_list|(
name|lower
argument_list|,
name|upper
argument_list|)
return|;
block|}
block|}
comment|/** Returns the next point around a line (more or less) */
DECL|method|nextPointAroundLine
specifier|private
specifier|static
name|double
index|[]
name|nextPointAroundLine
parameter_list|(
name|double
name|lat1
parameter_list|,
name|double
name|lon1
parameter_list|,
name|double
name|lat2
parameter_list|,
name|double
name|lon2
parameter_list|)
block|{
name|double
name|x1
init|=
name|lon1
decl_stmt|;
name|double
name|x2
init|=
name|lon2
decl_stmt|;
name|double
name|y1
init|=
name|lat1
decl_stmt|;
name|double
name|y2
init|=
name|lat2
decl_stmt|;
name|double
name|minX
init|=
name|Math
operator|.
name|min
argument_list|(
name|x1
argument_list|,
name|x2
argument_list|)
decl_stmt|;
name|double
name|maxX
init|=
name|Math
operator|.
name|max
argument_list|(
name|x1
argument_list|,
name|x2
argument_list|)
decl_stmt|;
name|double
name|minY
init|=
name|Math
operator|.
name|min
argument_list|(
name|y1
argument_list|,
name|y2
argument_list|)
decl_stmt|;
name|double
name|maxY
init|=
name|Math
operator|.
name|max
argument_list|(
name|y1
argument_list|,
name|y2
argument_list|)
decl_stmt|;
if|if
condition|(
name|minX
operator|==
name|maxX
condition|)
block|{
return|return
operator|new
name|double
index|[]
block|{
name|nextLatitudeBetween
argument_list|(
name|minY
argument_list|,
name|maxY
argument_list|)
block|,
name|nextLongitudeNear
argument_list|(
name|minX
argument_list|,
literal|0.01
operator|*
operator|(
name|maxY
operator|-
name|minY
operator|)
argument_list|)
block|}
return|;
block|}
elseif|else
if|if
condition|(
name|minY
operator|==
name|maxY
condition|)
block|{
return|return
operator|new
name|double
index|[]
block|{
name|nextLatitudeNear
argument_list|(
name|minY
argument_list|,
literal|0.01
operator|*
operator|(
name|maxX
operator|-
name|minX
operator|)
argument_list|)
block|,
name|nextLongitudeBetween
argument_list|(
name|minX
argument_list|,
name|maxX
argument_list|)
block|}
return|;
block|}
else|else
block|{
name|double
name|x
init|=
name|nextLongitudeBetween
argument_list|(
name|minX
argument_list|,
name|maxX
argument_list|)
decl_stmt|;
name|double
name|y
init|=
operator|(
name|y1
operator|-
name|y2
operator|)
operator|/
operator|(
name|x1
operator|-
name|x2
operator|)
operator|*
operator|(
name|x
operator|-
name|x1
operator|)
operator|+
name|y1
decl_stmt|;
if|if
condition|(
name|Double
operator|.
name|isFinite
argument_list|(
name|y
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// this can happen due to underflow when delta between x values is wonderfully tiny!
name|y
operator|=
name|Math
operator|.
name|copySign
argument_list|(
literal|90
argument_list|,
name|x1
argument_list|)
expr_stmt|;
block|}
name|double
name|delta
init|=
operator|(
name|maxY
operator|-
name|minY
operator|)
operator|*
literal|0.01
decl_stmt|;
comment|// our formula may put the targeted Y out of bounds
name|y
operator|=
name|Math
operator|.
name|min
argument_list|(
literal|90
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|y
operator|=
name|Math
operator|.
name|max
argument_list|(
operator|-
literal|90
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
operator|new
name|double
index|[]
block|{
name|nextLatitudeNear
argument_list|(
name|y
argument_list|,
name|delta
argument_list|)
block|,
name|x
block|}
return|;
block|}
block|}
comment|/** Returns next point (lat/lon) for testing near a Box. It may cross the dateline */
DECL|method|nextPointNear
specifier|public
specifier|static
name|double
index|[]
name|nextPointNear
parameter_list|(
name|Rectangle
name|rectangle
parameter_list|)
block|{
if|if
condition|(
name|rectangle
operator|.
name|crossesDateline
argument_list|()
condition|)
block|{
comment|// pick a "side" of the two boxes we really are
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
return|return
name|nextPointNear
argument_list|(
operator|new
name|Rectangle
argument_list|(
name|rectangle
operator|.
name|minLat
argument_list|,
name|rectangle
operator|.
name|maxLat
argument_list|,
operator|-
literal|180
argument_list|,
name|rectangle
operator|.
name|maxLon
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|nextPointNear
argument_list|(
operator|new
name|Rectangle
argument_list|(
name|rectangle
operator|.
name|minLat
argument_list|,
name|rectangle
operator|.
name|maxLat
argument_list|,
name|rectangle
operator|.
name|minLon
argument_list|,
literal|180
argument_list|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|nextPointNear
argument_list|(
name|boxPolygon
argument_list|(
name|rectangle
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Returns next point (lat/lon) for testing near a Polygon */
comment|// see http://www-ma2.upc.es/geoc/Schirra-pointPolygon.pdf for more info on some of these strategies
DECL|method|nextPointNear
specifier|public
specifier|static
name|double
index|[]
name|nextPointNear
parameter_list|(
name|Polygon
name|polygon
parameter_list|)
block|{
name|double
name|polyLats
index|[]
init|=
name|polygon
operator|.
name|getPolyLats
argument_list|()
decl_stmt|;
name|double
name|polyLons
index|[]
init|=
name|polygon
operator|.
name|getPolyLons
argument_list|()
decl_stmt|;
name|Polygon
name|holes
index|[]
init|=
name|polygon
operator|.
name|getHoles
argument_list|()
decl_stmt|;
comment|// if there are any holes, target them aggressively
if|if
condition|(
name|holes
operator|.
name|length
operator|>
literal|0
operator|&&
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|nextPointNear
argument_list|(
name|holes
index|[
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|holes
operator|.
name|length
argument_list|)
index|]
argument_list|)
return|;
block|}
name|int
name|surpriseMe
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|97
argument_list|)
decl_stmt|;
if|if
condition|(
name|surpriseMe
operator|==
literal|0
condition|)
block|{
comment|// purely random
return|return
operator|new
name|double
index|[]
block|{
name|nextLatitude
argument_list|()
block|,
name|nextLongitude
argument_list|()
block|}
return|;
block|}
elseif|else
if|if
condition|(
name|surpriseMe
operator|<
literal|5
condition|)
block|{
comment|// purely random within bounding box
return|return
operator|new
name|double
index|[]
block|{
name|nextLatitudeBetween
argument_list|(
name|polygon
operator|.
name|minLat
argument_list|,
name|polygon
operator|.
name|maxLat
argument_list|)
block|,
name|nextLongitudeBetween
argument_list|(
name|polygon
operator|.
name|minLon
argument_list|,
name|polygon
operator|.
name|maxLon
argument_list|)
block|}
return|;
block|}
elseif|else
if|if
condition|(
name|surpriseMe
operator|<
literal|20
condition|)
block|{
comment|// target a vertex
name|int
name|vertex
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|polyLats
operator|.
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
operator|new
name|double
index|[]
block|{
name|nextLatitudeNear
argument_list|(
name|polyLats
index|[
name|vertex
index|]
argument_list|,
name|polyLats
index|[
name|vertex
operator|+
literal|1
index|]
operator|-
name|polyLats
index|[
name|vertex
index|]
argument_list|)
block|,
name|nextLongitudeNear
argument_list|(
name|polyLons
index|[
name|vertex
index|]
argument_list|,
name|polyLons
index|[
name|vertex
operator|+
literal|1
index|]
operator|-
name|polyLons
index|[
name|vertex
index|]
argument_list|)
block|}
return|;
block|}
elseif|else
if|if
condition|(
name|surpriseMe
operator|<
literal|30
condition|)
block|{
comment|// target points around the bounding box edges
name|Polygon
name|container
init|=
name|boxPolygon
argument_list|(
operator|new
name|Rectangle
argument_list|(
name|polygon
operator|.
name|minLat
argument_list|,
name|polygon
operator|.
name|maxLat
argument_list|,
name|polygon
operator|.
name|minLon
argument_list|,
name|polygon
operator|.
name|maxLon
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|containerLats
index|[]
init|=
name|container
operator|.
name|getPolyLats
argument_list|()
decl_stmt|;
name|double
name|containerLons
index|[]
init|=
name|container
operator|.
name|getPolyLons
argument_list|()
decl_stmt|;
name|int
name|startVertex
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|containerLats
operator|.
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
name|nextPointAroundLine
argument_list|(
name|containerLats
index|[
name|startVertex
index|]
argument_list|,
name|containerLons
index|[
name|startVertex
index|]
argument_list|,
name|containerLats
index|[
name|startVertex
operator|+
literal|1
index|]
argument_list|,
name|containerLons
index|[
name|startVertex
operator|+
literal|1
index|]
argument_list|)
return|;
block|}
else|else
block|{
comment|// target points around diagonals between vertices
name|int
name|startVertex
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|polyLats
operator|.
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// but favor edges heavily
name|int
name|endVertex
init|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
name|startVertex
operator|+
literal|1
else|:
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|polyLats
operator|.
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
name|nextPointAroundLine
argument_list|(
name|polyLats
index|[
name|startVertex
index|]
argument_list|,
name|polyLons
index|[
name|startVertex
index|]
argument_list|,
name|polyLats
index|[
name|endVertex
index|]
argument_list|,
name|polyLons
index|[
name|endVertex
index|]
argument_list|)
return|;
block|}
block|}
comment|/** Returns next box for testing near a Polygon */
DECL|method|nextBoxNear
specifier|public
specifier|static
name|Rectangle
name|nextBoxNear
parameter_list|(
name|Polygon
name|polygon
parameter_list|)
block|{
specifier|final
name|double
name|point1
index|[]
decl_stmt|;
specifier|final
name|double
name|point2
index|[]
decl_stmt|;
comment|// if there are any holes, target them aggressively
name|Polygon
name|holes
index|[]
init|=
name|polygon
operator|.
name|getHoles
argument_list|()
decl_stmt|;
if|if
condition|(
name|holes
operator|.
name|length
operator|>
literal|0
operator|&&
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|nextBoxNear
argument_list|(
name|holes
index|[
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|holes
operator|.
name|length
argument_list|)
index|]
argument_list|)
return|;
block|}
name|int
name|surpriseMe
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|97
argument_list|)
decl_stmt|;
if|if
condition|(
name|surpriseMe
operator|==
literal|0
condition|)
block|{
comment|// formed from two interesting points
name|point1
operator|=
name|nextPointNear
argument_list|(
name|polygon
argument_list|)
expr_stmt|;
name|point2
operator|=
name|nextPointNear
argument_list|(
name|polygon
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// formed from one interesting point: then random within delta.
name|point1
operator|=
name|nextPointNear
argument_list|(
name|polygon
argument_list|)
expr_stmt|;
name|point2
operator|=
operator|new
name|double
index|[
literal|2
index|]
expr_stmt|;
comment|// now figure out a good delta: we use a rough heuristic, up to the length of an edge
name|double
name|polyLats
index|[]
init|=
name|polygon
operator|.
name|getPolyLats
argument_list|()
decl_stmt|;
name|double
name|polyLons
index|[]
init|=
name|polygon
operator|.
name|getPolyLons
argument_list|()
decl_stmt|;
name|int
name|vertex
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|polyLats
operator|.
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
name|double
name|deltaX
init|=
name|polyLons
index|[
name|vertex
operator|+
literal|1
index|]
operator|-
name|polyLons
index|[
name|vertex
index|]
decl_stmt|;
name|double
name|deltaY
init|=
name|polyLats
index|[
name|vertex
operator|+
literal|1
index|]
operator|-
name|polyLats
index|[
name|vertex
index|]
decl_stmt|;
name|double
name|edgeLength
init|=
name|Math
operator|.
name|sqrt
argument_list|(
name|deltaX
operator|*
name|deltaX
operator|+
name|deltaY
operator|*
name|deltaY
argument_list|)
decl_stmt|;
name|point2
index|[
literal|0
index|]
operator|=
name|nextLatitudeNear
argument_list|(
name|point1
index|[
literal|0
index|]
argument_list|,
name|edgeLength
argument_list|)
expr_stmt|;
name|point2
index|[
literal|1
index|]
operator|=
name|nextLongitudeNear
argument_list|(
name|point1
index|[
literal|1
index|]
argument_list|,
name|edgeLength
argument_list|)
expr_stmt|;
block|}
comment|// form a box from the two points
name|double
name|minLat
init|=
name|Math
operator|.
name|min
argument_list|(
name|point1
index|[
literal|0
index|]
argument_list|,
name|point2
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|double
name|maxLat
init|=
name|Math
operator|.
name|max
argument_list|(
name|point1
index|[
literal|0
index|]
argument_list|,
name|point2
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|double
name|minLon
init|=
name|Math
operator|.
name|min
argument_list|(
name|point1
index|[
literal|1
index|]
argument_list|,
name|point2
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|double
name|maxLon
init|=
name|Math
operator|.
name|max
argument_list|(
name|point1
index|[
literal|1
index|]
argument_list|,
name|point2
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
return|return
operator|new
name|Rectangle
argument_list|(
name|minLat
argument_list|,
name|maxLat
argument_list|,
name|minLon
argument_list|,
name|maxLon
argument_list|)
return|;
block|}
comment|/** returns next pseudorandom box: can cross the 180th meridian */
DECL|method|nextBox
specifier|public
specifier|static
name|Rectangle
name|nextBox
parameter_list|()
block|{
return|return
name|nextBoxInternal
argument_list|(
name|nextLatitude
argument_list|()
argument_list|,
name|nextLatitude
argument_list|()
argument_list|,
name|nextLongitude
argument_list|()
argument_list|,
name|nextLongitude
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** Makes an n-gon, centered at the provided lat/lon, and each vertex approximately    *  distanceMeters away from the center.    *    * Do not invoke me across the dateline or a pole!! */
DECL|method|createRegularPolygon
specifier|public
specifier|static
name|Polygon
name|createRegularPolygon
parameter_list|(
name|double
name|centerLat
parameter_list|,
name|double
name|centerLon
parameter_list|,
name|double
name|radiusMeters
parameter_list|,
name|int
name|gons
parameter_list|)
block|{
comment|// System.out.println("MAKE POLY: centerLat=" + centerLat + " centerLon=" + centerLon + " radiusMeters=" + radiusMeters + " gons=" + gons);
name|double
index|[]
index|[]
name|result
init|=
operator|new
name|double
index|[
literal|2
index|]
index|[]
decl_stmt|;
name|result
index|[
literal|0
index|]
operator|=
operator|new
name|double
index|[
name|gons
operator|+
literal|1
index|]
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
operator|new
name|double
index|[
name|gons
operator|+
literal|1
index|]
expr_stmt|;
comment|//System.out.println("make gon=" + gons);
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gons
condition|;
name|i
operator|++
control|)
block|{
name|double
name|angle
init|=
literal|360.0
operator|-
name|i
operator|*
operator|(
literal|360.0
operator|/
name|gons
operator|)
decl_stmt|;
comment|//System.out.println("  angle " + angle);
name|double
name|x
init|=
name|Math
operator|.
name|cos
argument_list|(
name|Math
operator|.
name|toRadians
argument_list|(
name|angle
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|y
init|=
name|Math
operator|.
name|sin
argument_list|(
name|Math
operator|.
name|toRadians
argument_list|(
name|angle
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|factor
init|=
literal|2.0
decl_stmt|;
name|double
name|step
init|=
literal|1.0
decl_stmt|;
name|int
name|last
init|=
literal|0
decl_stmt|;
comment|//System.out.println("angle " + angle + " slope=" + slope);
comment|// Iterate out along one spoke until we hone in on the point that's nearly exactly radiusMeters from the center:
while|while
condition|(
literal|true
condition|)
block|{
comment|// TODO: we could in fact cross a pole?  Just do what surpriseMePolygon does?
name|double
name|lat
init|=
name|centerLat
operator|+
name|y
operator|*
name|factor
decl_stmt|;
name|GeoUtils
operator|.
name|checkLatitude
argument_list|(
name|lat
argument_list|)
expr_stmt|;
name|double
name|lon
init|=
name|centerLon
operator|+
name|x
operator|*
name|factor
decl_stmt|;
name|GeoUtils
operator|.
name|checkLongitude
argument_list|(
name|lon
argument_list|)
expr_stmt|;
name|double
name|distanceMeters
init|=
name|SloppyMath
operator|.
name|haversinMeters
argument_list|(
name|centerLat
argument_list|,
name|centerLon
argument_list|,
name|lat
argument_list|,
name|lon
argument_list|)
decl_stmt|;
comment|//System.out.println("  iter lat=" + lat + " lon=" + lon + " distance=" + distanceMeters + " vs " + radiusMeters);
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|distanceMeters
operator|-
name|radiusMeters
argument_list|)
operator|<
literal|0.1
condition|)
block|{
comment|// Within 10 cm: close enough!
name|result
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|lat
expr_stmt|;
name|result
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
name|lon
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|distanceMeters
operator|>
name|radiusMeters
condition|)
block|{
comment|// too big
comment|//System.out.println("    smaller");
name|factor
operator|-=
name|step
expr_stmt|;
if|if
condition|(
name|last
operator|==
literal|1
condition|)
block|{
comment|//System.out.println("      half-step");
name|step
operator|/=
literal|2.0
expr_stmt|;
block|}
name|last
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|distanceMeters
operator|<
name|radiusMeters
condition|)
block|{
comment|// too small
comment|//System.out.println("    bigger");
name|factor
operator|+=
name|step
expr_stmt|;
if|if
condition|(
name|last
operator|==
operator|-
literal|1
condition|)
block|{
comment|//System.out.println("      half-step");
name|step
operator|/=
literal|2.0
expr_stmt|;
block|}
name|last
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|// close poly
name|result
index|[
literal|0
index|]
index|[
name|gons
index|]
operator|=
name|result
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|result
index|[
literal|1
index|]
index|[
name|gons
index|]
operator|=
name|result
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|//System.out.println("  polyLats=" + Arrays.toString(result[0]));
comment|//System.out.println("  polyLons=" + Arrays.toString(result[1]));
return|return
operator|new
name|Polygon
argument_list|(
name|result
index|[
literal|0
index|]
argument_list|,
name|result
index|[
literal|1
index|]
argument_list|)
return|;
block|}
comment|/** returns next pseudorandom polygon */
DECL|method|nextPolygon
specifier|public
specifier|static
name|Polygon
name|nextPolygon
parameter_list|()
block|{
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
return|return
name|surpriseMePolygon
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|// this poly is slow to create ... only do it 10% of the time:
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|gons
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|4
argument_list|,
literal|500
argument_list|)
decl_stmt|;
comment|// So the poly can cover at most 50% of the earth's surface:
name|double
name|radiusMeters
init|=
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|*
name|GeoUtils
operator|.
name|EARTH_MEAN_RADIUS_METERS
operator|*
name|Math
operator|.
name|PI
operator|/
literal|2.0
operator|+
literal|1.0
decl_stmt|;
try|try
block|{
return|return
name|createRegularPolygon
argument_list|(
name|nextLatitude
argument_list|()
argument_list|,
name|nextLongitude
argument_list|()
argument_list|,
name|radiusMeters
argument_list|,
name|gons
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// we tried to cross dateline or pole ... try again
block|}
block|}
block|}
name|Rectangle
name|box
init|=
name|nextBoxInternal
argument_list|(
name|nextLatitude
argument_list|()
argument_list|,
name|nextLatitude
argument_list|()
argument_list|,
name|nextLongitude
argument_list|()
argument_list|,
name|nextLongitude
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// box
return|return
name|boxPolygon
argument_list|(
name|box
argument_list|)
return|;
block|}
else|else
block|{
comment|// triangle
return|return
name|trianglePolygon
argument_list|(
name|box
argument_list|)
return|;
block|}
block|}
DECL|method|nextBoxInternal
specifier|private
specifier|static
name|Rectangle
name|nextBoxInternal
parameter_list|(
name|double
name|lat0
parameter_list|,
name|double
name|lat1
parameter_list|,
name|double
name|lon0
parameter_list|,
name|double
name|lon1
parameter_list|,
name|boolean
name|canCrossDateLine
parameter_list|)
block|{
if|if
condition|(
name|lat1
operator|<
name|lat0
condition|)
block|{
name|double
name|x
init|=
name|lat0
decl_stmt|;
name|lat0
operator|=
name|lat1
expr_stmt|;
name|lat1
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|canCrossDateLine
operator|==
literal|false
operator|&&
name|lon1
operator|<
name|lon0
condition|)
block|{
name|double
name|x
init|=
name|lon0
decl_stmt|;
name|lon0
operator|=
name|lon1
expr_stmt|;
name|lon1
operator|=
name|x
expr_stmt|;
block|}
return|return
operator|new
name|Rectangle
argument_list|(
name|lat0
argument_list|,
name|lat1
argument_list|,
name|lon0
argument_list|,
name|lon1
argument_list|)
return|;
block|}
DECL|method|boxPolygon
specifier|private
specifier|static
name|Polygon
name|boxPolygon
parameter_list|(
name|Rectangle
name|box
parameter_list|)
block|{
assert|assert
name|box
operator|.
name|crossesDateline
argument_list|()
operator|==
literal|false
assert|;
specifier|final
name|double
index|[]
name|polyLats
init|=
operator|new
name|double
index|[
literal|5
index|]
decl_stmt|;
specifier|final
name|double
index|[]
name|polyLons
init|=
operator|new
name|double
index|[
literal|5
index|]
decl_stmt|;
name|polyLats
index|[
literal|0
index|]
operator|=
name|box
operator|.
name|minLat
expr_stmt|;
name|polyLons
index|[
literal|0
index|]
operator|=
name|box
operator|.
name|minLon
expr_stmt|;
name|polyLats
index|[
literal|1
index|]
operator|=
name|box
operator|.
name|maxLat
expr_stmt|;
name|polyLons
index|[
literal|1
index|]
operator|=
name|box
operator|.
name|minLon
expr_stmt|;
name|polyLats
index|[
literal|2
index|]
operator|=
name|box
operator|.
name|maxLat
expr_stmt|;
name|polyLons
index|[
literal|2
index|]
operator|=
name|box
operator|.
name|maxLon
expr_stmt|;
name|polyLats
index|[
literal|3
index|]
operator|=
name|box
operator|.
name|minLat
expr_stmt|;
name|polyLons
index|[
literal|3
index|]
operator|=
name|box
operator|.
name|maxLon
expr_stmt|;
name|polyLats
index|[
literal|4
index|]
operator|=
name|box
operator|.
name|minLat
expr_stmt|;
name|polyLons
index|[
literal|4
index|]
operator|=
name|box
operator|.
name|minLon
expr_stmt|;
return|return
operator|new
name|Polygon
argument_list|(
name|polyLats
argument_list|,
name|polyLons
argument_list|)
return|;
block|}
DECL|method|trianglePolygon
specifier|private
specifier|static
name|Polygon
name|trianglePolygon
parameter_list|(
name|Rectangle
name|box
parameter_list|)
block|{
assert|assert
name|box
operator|.
name|crossesDateline
argument_list|()
operator|==
literal|false
assert|;
specifier|final
name|double
index|[]
name|polyLats
init|=
operator|new
name|double
index|[
literal|4
index|]
decl_stmt|;
specifier|final
name|double
index|[]
name|polyLons
init|=
operator|new
name|double
index|[
literal|4
index|]
decl_stmt|;
name|polyLats
index|[
literal|0
index|]
operator|=
name|box
operator|.
name|minLat
expr_stmt|;
name|polyLons
index|[
literal|0
index|]
operator|=
name|box
operator|.
name|minLon
expr_stmt|;
name|polyLats
index|[
literal|1
index|]
operator|=
name|box
operator|.
name|maxLat
expr_stmt|;
name|polyLons
index|[
literal|1
index|]
operator|=
name|box
operator|.
name|minLon
expr_stmt|;
name|polyLats
index|[
literal|2
index|]
operator|=
name|box
operator|.
name|maxLat
expr_stmt|;
name|polyLons
index|[
literal|2
index|]
operator|=
name|box
operator|.
name|maxLon
expr_stmt|;
name|polyLats
index|[
literal|3
index|]
operator|=
name|box
operator|.
name|minLat
expr_stmt|;
name|polyLons
index|[
literal|3
index|]
operator|=
name|box
operator|.
name|minLon
expr_stmt|;
return|return
operator|new
name|Polygon
argument_list|(
name|polyLats
argument_list|,
name|polyLons
argument_list|)
return|;
block|}
DECL|method|surpriseMePolygon
specifier|private
specifier|static
name|Polygon
name|surpriseMePolygon
parameter_list|()
block|{
comment|// repeat until we get a poly that doesn't cross dateline:
name|newPoly
label|:
while|while
condition|(
literal|true
condition|)
block|{
comment|//System.out.println("\nPOLY ITER");
name|double
name|centerLat
init|=
name|nextLatitude
argument_list|()
decl_stmt|;
name|double
name|centerLon
init|=
name|nextLongitude
argument_list|()
decl_stmt|;
name|double
name|radius
init|=
literal|0.1
operator|+
literal|20
operator|*
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
decl_stmt|;
name|double
name|radiusDelta
init|=
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Double
argument_list|>
name|lats
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Double
argument_list|>
name|lons
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|double
name|angle
init|=
literal|0.0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|angle
operator|+=
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|*
literal|40.0
expr_stmt|;
comment|//System.out.println("  angle " + angle);
if|if
condition|(
name|angle
operator|>
literal|360
condition|)
block|{
break|break;
block|}
name|double
name|len
init|=
name|radius
operator|*
operator|(
literal|1.0
operator|-
name|radiusDelta
operator|+
name|radiusDelta
operator|*
name|random
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|)
decl_stmt|;
comment|//System.out.println("    len=" + len);
name|double
name|lat
init|=
name|centerLat
operator|+
name|len
operator|*
name|Math
operator|.
name|cos
argument_list|(
name|Math
operator|.
name|toRadians
argument_list|(
name|angle
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|lon
init|=
name|centerLon
operator|+
name|len
operator|*
name|Math
operator|.
name|sin
argument_list|(
name|Math
operator|.
name|toRadians
argument_list|(
name|angle
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lon
operator|<=
name|GeoUtils
operator|.
name|MIN_LON_INCL
operator|||
name|lon
operator|>=
name|GeoUtils
operator|.
name|MAX_LON_INCL
condition|)
block|{
comment|// cannot cross dateline: try again!
continue|continue
name|newPoly
continue|;
block|}
if|if
condition|(
name|lat
operator|>
literal|90
condition|)
block|{
comment|// cross the north pole
name|lat
operator|=
literal|180
operator|-
name|lat
expr_stmt|;
name|lon
operator|=
literal|180
operator|-
name|lon
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lat
operator|<
operator|-
literal|90
condition|)
block|{
comment|// cross the south pole
name|lat
operator|=
operator|-
literal|180
operator|-
name|lat
expr_stmt|;
name|lon
operator|=
literal|180
operator|-
name|lon
expr_stmt|;
block|}
if|if
condition|(
name|lon
operator|<=
name|GeoUtils
operator|.
name|MIN_LON_INCL
operator|||
name|lon
operator|>=
name|GeoUtils
operator|.
name|MAX_LON_INCL
condition|)
block|{
comment|// cannot cross dateline: try again!
continue|continue
name|newPoly
continue|;
block|}
name|lats
operator|.
name|add
argument_list|(
name|lat
argument_list|)
expr_stmt|;
name|lons
operator|.
name|add
argument_list|(
name|lon
argument_list|)
expr_stmt|;
comment|//System.out.println("    lat=" + lats.get(lats.size()-1) + " lon=" + lons.get(lons.size()-1));
block|}
comment|// close it
name|lats
operator|.
name|add
argument_list|(
name|lats
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|lons
operator|.
name|add
argument_list|(
name|lons
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|double
index|[]
name|latsArray
init|=
operator|new
name|double
index|[
name|lats
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|double
index|[]
name|lonsArray
init|=
operator|new
name|double
index|[
name|lons
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lats
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|latsArray
index|[
name|i
index|]
operator|=
name|lats
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|lonsArray
index|[
name|i
index|]
operator|=
name|lons
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Polygon
argument_list|(
name|latsArray
argument_list|,
name|lonsArray
argument_list|)
return|;
block|}
block|}
comment|/** Keep it simple, we don't need to take arbitrary Random for geo tests */
DECL|method|random
specifier|private
specifier|static
name|Random
name|random
parameter_list|()
block|{
return|return
name|RandomizedContext
operator|.
name|current
argument_list|()
operator|.
name|getRandom
argument_list|()
return|;
block|}
comment|/**     * Returns svg of polygon for debugging.     *<p>    * You can pass any number of objects:    * Polygon: polygon with optional holes    * Polygon[]: arrays of polygons for convenience    * Rectangle: for a box    * double[2]: as latitude,longitude for a point    *<p>    * At least one object must be a polygon. The viewBox is formed around all polygons    * found in the arguments.    */
DECL|method|toSVG
specifier|public
specifier|static
name|String
name|toSVG
parameter_list|(
name|Object
modifier|...
name|objects
parameter_list|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|flattened
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|objects
control|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Polygon
index|[]
condition|)
block|{
name|flattened
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|(
name|Polygon
index|[]
operator|)
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flattened
operator|.
name|add
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
comment|// first compute bounding area of all the objects
name|double
name|minLat
init|=
name|Double
operator|.
name|POSITIVE_INFINITY
decl_stmt|;
name|double
name|maxLat
init|=
name|Double
operator|.
name|NEGATIVE_INFINITY
decl_stmt|;
name|double
name|minLon
init|=
name|Double
operator|.
name|POSITIVE_INFINITY
decl_stmt|;
name|double
name|maxLon
init|=
name|Double
operator|.
name|NEGATIVE_INFINITY
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|flattened
control|)
block|{
specifier|final
name|Rectangle
name|r
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|Polygon
condition|)
block|{
name|r
operator|=
name|Rectangle
operator|.
name|fromPolygon
argument_list|(
operator|new
name|Polygon
index|[]
block|{
operator|(
name|Polygon
operator|)
name|o
block|}
argument_list|)
expr_stmt|;
name|minLat
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minLat
argument_list|,
name|r
operator|.
name|minLat
argument_list|)
expr_stmt|;
name|maxLat
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxLat
argument_list|,
name|r
operator|.
name|maxLat
argument_list|)
expr_stmt|;
name|minLon
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minLon
argument_list|,
name|r
operator|.
name|minLon
argument_list|)
expr_stmt|;
name|maxLon
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxLon
argument_list|,
name|r
operator|.
name|maxLon
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Double
operator|.
name|isFinite
argument_list|(
name|minLat
argument_list|)
operator|==
literal|false
operator|||
name|Double
operator|.
name|isFinite
argument_list|(
name|maxLat
argument_list|)
operator|==
literal|false
operator|||
name|Double
operator|.
name|isFinite
argument_list|(
name|minLon
argument_list|)
operator|==
literal|false
operator|||
name|Double
operator|.
name|isFinite
argument_list|(
name|maxLon
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"you must pass at least one polygon"
argument_list|)
throw|;
block|}
comment|// add some additional padding so we can really see what happens on the edges too
name|double
name|xpadding
init|=
operator|(
name|maxLon
operator|-
name|minLon
operator|)
operator|/
literal|64
decl_stmt|;
name|double
name|ypadding
init|=
operator|(
name|maxLat
operator|-
name|minLat
operator|)
operator|/
literal|64
decl_stmt|;
comment|// expand points to be this large
name|double
name|pointX
init|=
name|xpadding
operator|*
literal|0.1
decl_stmt|;
name|double
name|pointY
init|=
name|ypadding
operator|*
literal|0.1
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"640\" width=\"480\" viewBox=\""
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|minLon
operator|-
name|xpadding
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
literal|90
operator|-
name|maxLat
operator|-
name|ypadding
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|maxLon
operator|-
name|minLon
operator|+
operator|(
literal|2
operator|*
name|xpadding
operator|)
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|maxLat
operator|-
name|minLat
operator|+
operator|(
literal|2
operator|*
name|ypadding
operator|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\">\n"
argument_list|)
expr_stmt|;
comment|// encode each object
for|for
control|(
name|Object
name|o
range|:
name|flattened
control|)
block|{
comment|// tostring
if|if
condition|(
name|o
operator|instanceof
name|double
index|[]
condition|)
block|{
name|double
name|point
index|[]
init|=
operator|(
name|double
index|[]
operator|)
name|o
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"<!-- point: "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|point
index|[
literal|0
index|]
operator|+
literal|","
operator|+
name|point
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" -->\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"<!-- "
operator|+
name|o
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": \n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n-->\n"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Polygon
name|gon
decl_stmt|;
specifier|final
name|String
name|style
decl_stmt|;
specifier|final
name|String
name|opacity
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|Rectangle
condition|)
block|{
name|gon
operator|=
name|boxPolygon
argument_list|(
operator|(
name|Rectangle
operator|)
name|o
argument_list|)
expr_stmt|;
name|style
operator|=
literal|"fill:lightskyblue;stroke:black;stroke-width:0.2%;stroke-dasharray:0.5%,1%;"
expr_stmt|;
name|opacity
operator|=
literal|"0.3"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|double
index|[]
condition|)
block|{
name|double
name|point
index|[]
init|=
operator|(
name|double
index|[]
operator|)
name|o
decl_stmt|;
name|gon
operator|=
name|boxPolygon
argument_list|(
operator|new
name|Rectangle
argument_list|(
name|Math
operator|.
name|max
argument_list|(
operator|-
literal|90
argument_list|,
name|point
index|[
literal|0
index|]
operator|-
name|pointY
argument_list|)
argument_list|,
name|Math
operator|.
name|min
argument_list|(
literal|90
argument_list|,
name|point
index|[
literal|0
index|]
operator|+
name|pointY
argument_list|)
argument_list|,
name|Math
operator|.
name|max
argument_list|(
operator|-
literal|180
argument_list|,
name|point
index|[
literal|1
index|]
operator|-
name|pointX
argument_list|)
argument_list|,
name|Math
operator|.
name|min
argument_list|(
literal|180
argument_list|,
name|point
index|[
literal|1
index|]
operator|+
name|pointX
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|style
operator|=
literal|"fill:red;stroke:red;stroke-width:0.1%;"
expr_stmt|;
name|opacity
operator|=
literal|"0.7"
expr_stmt|;
block|}
else|else
block|{
name|gon
operator|=
operator|(
name|Polygon
operator|)
name|o
expr_stmt|;
name|style
operator|=
literal|"fill:lawngreen;stroke:black;stroke-width:0.3%;"
expr_stmt|;
name|opacity
operator|=
literal|"0.5"
expr_stmt|;
block|}
comment|// polygon
name|double
name|polyLats
index|[]
init|=
name|gon
operator|.
name|getPolyLats
argument_list|()
decl_stmt|;
name|double
name|polyLons
index|[]
init|=
name|gon
operator|.
name|getPolyLons
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"<polygon fill-opacity=\""
operator|+
name|opacity
operator|+
literal|"\" points=\""
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|polyLats
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|polyLons
index|[
name|i
index|]
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
operator|.
name|append
argument_list|(
literal|90
operator|-
name|polyLats
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\" style=\""
operator|+
name|style
operator|+
literal|"\"/>\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|Polygon
name|hole
range|:
name|gon
operator|.
name|getHoles
argument_list|()
control|)
block|{
name|double
name|holeLats
index|[]
init|=
name|hole
operator|.
name|getPolyLats
argument_list|()
decl_stmt|;
name|double
name|holeLons
index|[]
init|=
name|hole
operator|.
name|getPolyLons
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"<polygon points=\""
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|holeLats
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|holeLons
index|[
name|i
index|]
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
operator|.
name|append
argument_list|(
literal|90
operator|-
name|holeLats
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\" style=\"fill:lightgray\"/>\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"</svg>\n"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Simple slow point in polygon check (for testing)    */
comment|// direct port of PNPOLY C code (https://www.ecse.rpi.edu/~wrf/Research/Short_Notes/pnpoly.html)
comment|// this allows us to improve the code yet still ensure we have its properties
comment|// it is under the BSD license (https://www.ecse.rpi.edu/~wrf/Research/Short_Notes/pnpoly.html#License%20to%20Use)
comment|//
comment|// Copyright (c) 1970-2003, Wm. Randolph Franklin
comment|//
comment|// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
comment|// documentation files (the "Software"), to deal in the Software without restriction, including without limitation
comment|// the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
comment|// to permit persons to whom the Software is furnished to do so, subject to the following conditions:
comment|//
comment|// 1. Redistributions of source code must retain the above copyright
comment|//    notice, this list of conditions and the following disclaimers.
comment|// 2. Redistributions in binary form must reproduce the above copyright
comment|//    notice in the documentation and/or other materials provided with
comment|//    the distribution.
comment|// 3. The name of W. Randolph Franklin may not be used to endorse or
comment|//    promote products derived from this Software without specific
comment|//    prior written permission.
comment|//
comment|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
comment|// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
comment|// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
comment|// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
comment|// IN THE SOFTWARE.
DECL|method|containsSlowly
specifier|public
specifier|static
name|boolean
name|containsSlowly
parameter_list|(
name|Polygon
name|polygon
parameter_list|,
name|double
name|latitude
parameter_list|,
name|double
name|longitude
parameter_list|)
block|{
if|if
condition|(
name|polygon
operator|.
name|getHoles
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"this testing method does not support holes"
argument_list|)
throw|;
block|}
name|double
name|polyLats
index|[]
init|=
name|polygon
operator|.
name|getPolyLats
argument_list|()
decl_stmt|;
name|double
name|polyLons
index|[]
init|=
name|polygon
operator|.
name|getPolyLons
argument_list|()
decl_stmt|;
comment|// bounding box check required due to rounding errors (we don't solve that problem)
if|if
condition|(
name|latitude
argument_list|<
name|polygon
operator|.
name|minLat
operator|||
name|latitude
argument_list|>
name|polygon
operator|.
name|maxLat
operator|||
name|longitude
argument_list|<
name|polygon
operator|.
name|minLon
operator|||
name|longitude
argument_list|>
name|polygon
operator|.
name|maxLon
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|c
init|=
literal|false
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|nvert
init|=
name|polyLats
operator|.
name|length
decl_stmt|;
name|double
name|verty
index|[]
init|=
name|polyLats
decl_stmt|;
name|double
name|vertx
index|[]
init|=
name|polyLons
decl_stmt|;
name|double
name|testy
init|=
name|latitude
decl_stmt|;
name|double
name|testx
init|=
name|longitude
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|nvert
operator|-
literal|1
init|;
name|i
operator|<
name|nvert
condition|;
name|j
operator|=
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|verty
index|[
name|i
index|]
operator|>
name|testy
operator|)
operator|!=
operator|(
name|verty
index|[
name|j
index|]
operator|>
name|testy
operator|)
operator|)
operator|&&
operator|(
name|testx
operator|<
operator|(
name|vertx
index|[
name|j
index|]
operator|-
name|vertx
index|[
name|i
index|]
operator|)
operator|*
operator|(
name|testy
operator|-
name|verty
index|[
name|i
index|]
operator|)
operator|/
operator|(
name|verty
index|[
name|j
index|]
operator|-
name|verty
index|[
name|i
index|]
operator|)
operator|+
name|vertx
index|[
name|i
index|]
operator|)
condition|)
name|c
operator|=
operator|!
name|c
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
block|}
end_class
end_unit
