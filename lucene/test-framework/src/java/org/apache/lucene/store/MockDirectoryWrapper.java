begin_unit
begin_package
DECL|package|org.apache.lucene.store
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|NoSuchFileException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriterConfig
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|NoDeletionPolicy
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ThrottledIndexOutput
import|;
end_import
begin_comment
comment|/**  * This is a Directory Wrapper that adds methods  * intended to be used only by unit tests.  * It also adds a number of features useful for testing:  *<ul>  *<li> Instances created by {@link LuceneTestCase#newDirectory()} are tracked   *        to ensure they are closed by the test.  *<li> When a MockDirectoryWrapper is closed, it will throw an exception if   *        it has any open files against it (with a stacktrace indicating where   *        they were opened from).  *<li> When a MockDirectoryWrapper is closed, it runs CheckIndex to test if  *        the index was corrupted.  *<li> MockDirectoryWrapper simulates some "features" of Windows, such as  *        refusing to write/delete to open files.  *</ul>  */
end_comment
begin_class
DECL|class|MockDirectoryWrapper
specifier|public
class|class
name|MockDirectoryWrapper
extends|extends
name|BaseDirectoryWrapper
block|{
DECL|field|maxSize
name|long
name|maxSize
decl_stmt|;
comment|// Max actual bytes used. This is set by MockRAMOutputStream:
DECL|field|maxUsedSize
name|long
name|maxUsedSize
decl_stmt|;
DECL|field|randomIOExceptionRate
name|double
name|randomIOExceptionRate
decl_stmt|;
DECL|field|randomIOExceptionRateOnOpen
name|double
name|randomIOExceptionRateOnOpen
decl_stmt|;
DECL|field|randomState
name|Random
name|randomState
decl_stmt|;
DECL|field|noDeleteOpenFile
name|boolean
name|noDeleteOpenFile
init|=
literal|true
decl_stmt|;
DECL|field|assertNoDeleteOpenFile
name|boolean
name|assertNoDeleteOpenFile
init|=
literal|false
decl_stmt|;
DECL|field|preventDoubleWrite
name|boolean
name|preventDoubleWrite
init|=
literal|true
decl_stmt|;
DECL|field|trackDiskUsage
name|boolean
name|trackDiskUsage
init|=
literal|false
decl_stmt|;
DECL|field|wrapLockFactory
name|boolean
name|wrapLockFactory
init|=
literal|true
decl_stmt|;
DECL|field|useSlowOpenClosers
name|boolean
name|useSlowOpenClosers
init|=
literal|true
decl_stmt|;
DECL|field|enableVirusScanner
name|boolean
name|enableVirusScanner
init|=
literal|true
decl_stmt|;
DECL|field|allowRandomFileNotFoundException
name|boolean
name|allowRandomFileNotFoundException
init|=
literal|true
decl_stmt|;
DECL|field|allowReadingFilesStillOpenForWrite
name|boolean
name|allowReadingFilesStillOpenForWrite
init|=
literal|false
decl_stmt|;
DECL|field|unSyncedFiles
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|unSyncedFiles
decl_stmt|;
DECL|field|createdFiles
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|createdFiles
decl_stmt|;
DECL|field|openFilesForWrite
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|openFilesForWrite
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|openLocks
name|Map
argument_list|<
name|String
argument_list|,
name|Exception
argument_list|>
name|openLocks
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Exception
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|crashed
specifier|volatile
name|boolean
name|crashed
decl_stmt|;
DECL|field|throttledOutput
specifier|private
name|ThrottledIndexOutput
name|throttledOutput
decl_stmt|;
DECL|field|throttling
specifier|private
name|Throttling
name|throttling
init|=
name|Throttling
operator|.
name|SOMETIMES
decl_stmt|;
DECL|field|lockFactory
specifier|protected
name|LockFactory
name|lockFactory
decl_stmt|;
DECL|field|inputCloneCount
specifier|final
name|AtomicInteger
name|inputCloneCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// use this for tracking files for crash.
comment|// additionally: provides debugging information in case you leave one open
DECL|field|openFileHandles
specifier|private
name|Map
argument_list|<
name|Closeable
argument_list|,
name|Exception
argument_list|>
name|openFileHandles
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|IdentityHashMap
argument_list|<
name|Closeable
argument_list|,
name|Exception
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|// NOTE: we cannot initialize the Map here due to the
comment|// order in which our constructor actually does this
comment|// member initialization vs when it calls super.  It seems
comment|// like super is called, then our members are initialized:
DECL|field|openFiles
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|openFiles
decl_stmt|;
comment|// Only tracked if noDeleteOpenFile is true: if an attempt
comment|// is made to delete an open file, we enroll it here.
DECL|field|openFilesDeleted
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|openFilesDeleted
decl_stmt|;
comment|// only tracked if virus scanner is enabled:
comment|// set of files it prevented deletion for
DECL|field|triedToDelete
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|triedToDelete
decl_stmt|;
DECL|method|init
specifier|private
specifier|synchronized
name|void
name|init
parameter_list|()
block|{
if|if
condition|(
name|openFiles
operator|==
literal|null
condition|)
block|{
name|openFiles
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|openFilesDeleted
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|triedToDelete
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|createdFiles
operator|==
literal|null
condition|)
name|createdFiles
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
if|if
condition|(
name|unSyncedFiles
operator|==
literal|null
condition|)
name|unSyncedFiles
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
block|}
DECL|method|MockDirectoryWrapper
specifier|public
name|MockDirectoryWrapper
parameter_list|(
name|Random
name|random
parameter_list|,
name|Directory
name|delegate
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
comment|// must make a private random since our methods are
comment|// called from different threads; else test failures may
comment|// not be reproducible from the original seed
name|this
operator|.
name|randomState
operator|=
operator|new
name|Random
argument_list|(
name|random
operator|.
name|nextInt
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|throttledOutput
operator|=
operator|new
name|ThrottledIndexOutput
argument_list|(
name|ThrottledIndexOutput
operator|.
name|mBitsToBytes
argument_list|(
literal|40
operator|+
name|randomState
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
argument_list|)
argument_list|,
literal|5
operator|+
name|randomState
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// force wrapping of lockfactory
name|this
operator|.
name|lockFactory
operator|=
operator|new
name|MockLockFactoryWrapper
argument_list|(
name|this
argument_list|,
name|delegate
operator|.
name|getLockFactory
argument_list|()
argument_list|)
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
block|}
DECL|method|getInputCloneCount
specifier|public
name|int
name|getInputCloneCount
parameter_list|()
block|{
return|return
name|inputCloneCount
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|setTrackDiskUsage
specifier|public
name|void
name|setTrackDiskUsage
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
name|trackDiskUsage
operator|=
name|v
expr_stmt|;
block|}
comment|/** If set to true, we throw an IOException if the same    *  file is opened by createOutput, ever. */
DECL|method|setPreventDoubleWrite
specifier|public
name|void
name|setPreventDoubleWrite
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|preventDoubleWrite
operator|=
name|value
expr_stmt|;
block|}
comment|/** If set to true (the default), when we throw random    *  IOException on openInput or createOutput, we may    *  sometimes throw FileNotFoundException or    *  NoSuchFileException. */
DECL|method|setAllowRandomFileNotFoundException
specifier|public
name|void
name|setAllowRandomFileNotFoundException
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|allowRandomFileNotFoundException
operator|=
name|value
expr_stmt|;
block|}
comment|/** If set to true, you can open an inputstream on a file    *  that is still open for writes. */
DECL|method|setAllowReadingFilesStillOpenForWrite
specifier|public
name|void
name|setAllowReadingFilesStillOpenForWrite
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|allowReadingFilesStillOpenForWrite
operator|=
name|value
expr_stmt|;
block|}
comment|/** Returns true if the virus scanner is enabled */
DECL|method|getEnableVirusScanner
specifier|public
name|boolean
name|getEnableVirusScanner
parameter_list|()
block|{
return|return
name|enableVirusScanner
return|;
block|}
comment|/** If set to true (the default), deleteFile sometimes    *  fails because a virus scanner is open.    */
DECL|method|setEnableVirusScanner
specifier|public
name|void
name|setEnableVirusScanner
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|this
operator|.
name|enableVirusScanner
operator|=
name|value
expr_stmt|;
block|}
comment|/**    * Enum for controlling hard disk throttling.    * Set via {@link MockDirectoryWrapper #setThrottling(Throttling)}    *<p>    * WARNING: can make tests very slow.    */
DECL|enum|Throttling
specifier|public
specifier|static
enum|enum
name|Throttling
block|{
comment|/** always emulate a slow hard disk. could be very slow! */
DECL|enum constant|ALWAYS
name|ALWAYS
block|,
comment|/** sometimes (2% of the time) emulate a slow hard disk. */
DECL|enum constant|SOMETIMES
name|SOMETIMES
block|,
comment|/** never throttle output */
DECL|enum constant|NEVER
name|NEVER
block|}
DECL|method|setThrottling
specifier|public
name|void
name|setThrottling
parameter_list|(
name|Throttling
name|throttling
parameter_list|)
block|{
name|this
operator|.
name|throttling
operator|=
name|throttling
expr_stmt|;
block|}
comment|/**     * By default, opening and closing has a rare small sleep to catch race conditions    *<p>    * You can disable this if you dont need it    */
DECL|method|setUseSlowOpenClosers
specifier|public
name|void
name|setUseSlowOpenClosers
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
name|useSlowOpenClosers
operator|=
name|v
expr_stmt|;
block|}
comment|/**    * Returns true if {@link #in} must sync its files.    * Currently, only {@link NRTCachingDirectory} requires sync'ing its files    * because otherwise they are cached in an internal {@link RAMDirectory}. If    * other directories require that too, they should be added to this method.    */
DECL|method|mustSync
specifier|private
name|boolean
name|mustSync
parameter_list|()
block|{
name|Directory
name|delegate
init|=
name|in
decl_stmt|;
while|while
condition|(
name|delegate
operator|instanceof
name|FilterDirectory
condition|)
block|{
if|if
condition|(
name|delegate
operator|instanceof
name|NRTCachingDirectory
condition|)
block|{
return|return
literal|true
return|;
block|}
name|delegate
operator|=
operator|(
operator|(
name|FilterDirectory
operator|)
name|delegate
operator|)
operator|.
name|getDelegate
argument_list|()
expr_stmt|;
block|}
return|return
name|delegate
operator|instanceof
name|NRTCachingDirectory
return|;
block|}
annotation|@
name|Override
DECL|method|sync
specifier|public
specifier|synchronized
name|void
name|sync
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
throws|throws
name|IOException
block|{
name|maybeYield
argument_list|()
expr_stmt|;
name|maybeThrowDeterministicException
argument_list|()
expr_stmt|;
if|if
condition|(
name|crashed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"cannot sync after crash"
argument_list|)
throw|;
block|}
comment|// don't wear out our hardware so much in tests.
if|if
condition|(
name|LuceneTestCase
operator|.
name|rarely
argument_list|(
name|randomState
argument_list|)
operator|||
name|mustSync
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
comment|// randomly fail with IOE on any file
name|maybeThrowIOException
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|in
operator|.
name|sync
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|unSyncedFiles
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|unSyncedFiles
operator|.
name|removeAll
argument_list|(
name|names
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|renameFile
specifier|public
specifier|synchronized
name|void
name|renameFile
parameter_list|(
name|String
name|source
parameter_list|,
name|String
name|dest
parameter_list|)
throws|throws
name|IOException
block|{
name|maybeYield
argument_list|()
expr_stmt|;
name|maybeThrowDeterministicException
argument_list|()
expr_stmt|;
if|if
condition|(
name|crashed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"cannot rename after crash"
argument_list|)
throw|;
block|}
if|if
condition|(
name|openFiles
operator|.
name|containsKey
argument_list|(
name|source
argument_list|)
condition|)
block|{
if|if
condition|(
name|assertNoDeleteOpenFile
condition|)
block|{
throw|throw
operator|(
name|AssertionError
operator|)
name|fillOpenTrace
argument_list|(
operator|new
name|AssertionError
argument_list|(
literal|"MockDirectoryWrapper: file \""
operator|+
name|source
operator|+
literal|"\" is still open: cannot rename"
argument_list|)
argument_list|,
name|source
argument_list|,
literal|true
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|noDeleteOpenFile
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|fillOpenTrace
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"MockDirectoryWrapper: file \""
operator|+
name|source
operator|+
literal|"\" is still open: cannot rename"
argument_list|)
argument_list|,
name|source
argument_list|,
literal|true
argument_list|)
throw|;
block|}
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|in
operator|.
name|renameFile
argument_list|(
name|source
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
comment|// we don't do this stuff with lucene's commit, but its just for completeness
if|if
condition|(
name|unSyncedFiles
operator|.
name|contains
argument_list|(
name|source
argument_list|)
condition|)
block|{
name|unSyncedFiles
operator|.
name|remove
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|unSyncedFiles
operator|.
name|add
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
name|openFilesDeleted
operator|.
name|remove
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|sizeInBytes
specifier|public
specifier|synchronized
specifier|final
name|long
name|sizeInBytes
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|instanceof
name|RAMDirectory
condition|)
return|return
operator|(
operator|(
name|RAMDirectory
operator|)
name|in
operator|)
operator|.
name|ramBytesUsed
argument_list|()
return|;
else|else
block|{
comment|// hack
name|long
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|in
operator|.
name|listAll
argument_list|()
control|)
name|size
operator|+=
name|in
operator|.
name|fileLength
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
block|}
comment|/** Simulates a crash of OS or machine by overwriting    *  unsynced files. */
DECL|method|crash
specifier|public
specifier|synchronized
name|void
name|crash
parameter_list|()
throws|throws
name|IOException
block|{
name|crashed
operator|=
literal|true
expr_stmt|;
name|openFiles
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|openFilesForWrite
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|openFilesDeleted
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|unSyncedFiles
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|unSyncedFiles
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
comment|// first force-close all files, so we can corrupt on windows etc.
comment|// clone the file map, as these guys want to remove themselves on close.
name|Map
argument_list|<
name|Closeable
argument_list|,
name|Exception
argument_list|>
name|m
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|(
name|openFileHandles
argument_list|)
decl_stmt|;
for|for
control|(
name|Closeable
name|f
range|:
name|m
operator|.
name|keySet
argument_list|()
control|)
block|{
try|try
block|{
name|f
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{}
block|}
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|name
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|damage
init|=
name|randomState
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|String
name|action
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|damage
operator|==
literal|0
condition|)
block|{
name|action
operator|=
literal|"deleted"
expr_stmt|;
name|deleteFile
argument_list|(
name|name
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|damage
operator|==
literal|1
condition|)
block|{
name|action
operator|=
literal|"zeroed"
expr_stmt|;
comment|// Zero out file entirely
name|long
name|length
init|=
name|fileLength
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|byte
index|[]
name|zeroes
init|=
operator|new
name|byte
index|[
literal|256
index|]
decl_stmt|;
name|long
name|upto
init|=
literal|0
decl_stmt|;
name|IndexOutput
name|out
init|=
name|in
operator|.
name|createOutput
argument_list|(
name|name
argument_list|,
name|LuceneTestCase
operator|.
name|newIOContext
argument_list|(
name|randomState
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|length
condition|)
block|{
specifier|final
name|int
name|limit
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|length
operator|-
name|upto
argument_list|,
name|zeroes
operator|.
name|length
argument_list|)
decl_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|zeroes
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|upto
operator|+=
name|limit
expr_stmt|;
block|}
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|damage
operator|==
literal|2
condition|)
block|{
name|action
operator|=
literal|"partially truncated"
expr_stmt|;
comment|// Partially Truncate the file:
comment|// First, make temp file and copy only half this
comment|// file over:
name|String
name|tempFileName
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|tempFileName
operator|=
literal|""
operator|+
name|randomState
operator|.
name|nextInt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|LuceneTestCase
operator|.
name|slowFileExists
argument_list|(
name|in
argument_list|,
name|tempFileName
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
specifier|final
name|IndexOutput
name|tempOut
init|=
name|in
operator|.
name|createOutput
argument_list|(
name|tempFileName
argument_list|,
name|LuceneTestCase
operator|.
name|newIOContext
argument_list|(
name|randomState
argument_list|)
argument_list|)
decl_stmt|;
name|IndexInput
name|ii
init|=
name|in
operator|.
name|openInput
argument_list|(
name|name
argument_list|,
name|LuceneTestCase
operator|.
name|newIOContext
argument_list|(
name|randomState
argument_list|)
argument_list|)
decl_stmt|;
name|tempOut
operator|.
name|copyBytes
argument_list|(
name|ii
argument_list|,
name|ii
operator|.
name|length
argument_list|()
operator|/
literal|2
argument_list|)
expr_stmt|;
name|tempOut
operator|.
name|close
argument_list|()
expr_stmt|;
name|ii
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Delete original and copy bytes back:
name|deleteFile
argument_list|(
name|name
argument_list|,
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|IndexOutput
name|out
init|=
name|in
operator|.
name|createOutput
argument_list|(
name|name
argument_list|,
name|LuceneTestCase
operator|.
name|newIOContext
argument_list|(
name|randomState
argument_list|)
argument_list|)
decl_stmt|;
name|ii
operator|=
name|in
operator|.
name|openInput
argument_list|(
name|tempFileName
argument_list|,
name|LuceneTestCase
operator|.
name|newIOContext
argument_list|(
name|randomState
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|copyBytes
argument_list|(
name|ii
argument_list|,
name|ii
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|ii
operator|.
name|close
argument_list|()
expr_stmt|;
name|deleteFile
argument_list|(
name|tempFileName
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|damage
operator|==
literal|3
condition|)
block|{
comment|// The file survived intact:
name|action
operator|=
literal|"didn't change"
expr_stmt|;
block|}
else|else
block|{
name|action
operator|=
literal|"fully truncated"
expr_stmt|;
comment|// Totally truncate the file to zero bytes
name|deleteFile
argument_list|(
name|name
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|IndexOutput
name|out
init|=
name|in
operator|.
name|createOutput
argument_list|(
name|name
argument_list|,
name|LuceneTestCase
operator|.
name|newIOContext
argument_list|(
name|randomState
argument_list|)
argument_list|)
decl_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"MockDirectoryWrapper: "
operator|+
name|action
operator|+
literal|" unsynced file: "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|clearCrash
specifier|public
specifier|synchronized
name|void
name|clearCrash
parameter_list|()
block|{
name|crashed
operator|=
literal|false
expr_stmt|;
name|openLocks
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|setMaxSizeInBytes
specifier|public
name|void
name|setMaxSizeInBytes
parameter_list|(
name|long
name|maxSize
parameter_list|)
block|{
name|this
operator|.
name|maxSize
operator|=
name|maxSize
expr_stmt|;
block|}
DECL|method|getMaxSizeInBytes
specifier|public
name|long
name|getMaxSizeInBytes
parameter_list|()
block|{
return|return
name|this
operator|.
name|maxSize
return|;
block|}
comment|/**    * Returns the peek actual storage used (bytes) in this    * directory.    */
DECL|method|getMaxUsedSizeInBytes
specifier|public
name|long
name|getMaxUsedSizeInBytes
parameter_list|()
block|{
return|return
name|this
operator|.
name|maxUsedSize
return|;
block|}
DECL|method|resetMaxUsedSizeInBytes
specifier|public
name|void
name|resetMaxUsedSizeInBytes
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|maxUsedSize
operator|=
name|getRecomputedActualSizeInBytes
argument_list|()
expr_stmt|;
block|}
comment|/**    * Emulate windows whereby deleting an open file is not    * allowed (raise IOException).   */
DECL|method|setNoDeleteOpenFile
specifier|public
name|void
name|setNoDeleteOpenFile
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|this
operator|.
name|noDeleteOpenFile
operator|=
name|value
expr_stmt|;
block|}
DECL|method|getNoDeleteOpenFile
specifier|public
name|boolean
name|getNoDeleteOpenFile
parameter_list|()
block|{
return|return
name|noDeleteOpenFile
return|;
block|}
comment|/**    * Trip a test assert if there is an attempt    * to delete an open file.   */
DECL|method|setAssertNoDeleteOpenFile
specifier|public
name|void
name|setAssertNoDeleteOpenFile
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|this
operator|.
name|assertNoDeleteOpenFile
operator|=
name|value
expr_stmt|;
block|}
DECL|method|getAssertNoDeleteOpenFile
specifier|public
name|boolean
name|getAssertNoDeleteOpenFile
parameter_list|()
block|{
return|return
name|assertNoDeleteOpenFile
return|;
block|}
comment|/**    * If 0.0, no exceptions will be thrown.  Else this should    * be a double 0.0 - 1.0.  We will randomly throw an    * IOException on the first write to an OutputStream based    * on this probability.    */
DECL|method|setRandomIOExceptionRate
specifier|public
name|void
name|setRandomIOExceptionRate
parameter_list|(
name|double
name|rate
parameter_list|)
block|{
name|randomIOExceptionRate
operator|=
name|rate
expr_stmt|;
block|}
DECL|method|getRandomIOExceptionRate
specifier|public
name|double
name|getRandomIOExceptionRate
parameter_list|()
block|{
return|return
name|randomIOExceptionRate
return|;
block|}
comment|/**    * If 0.0, no exceptions will be thrown during openInput    * and createOutput.  Else this should    * be a double 0.0 - 1.0 and we will randomly throw an    * IOException in openInput and createOutput with    * this probability.    */
DECL|method|setRandomIOExceptionRateOnOpen
specifier|public
name|void
name|setRandomIOExceptionRateOnOpen
parameter_list|(
name|double
name|rate
parameter_list|)
block|{
name|randomIOExceptionRateOnOpen
operator|=
name|rate
expr_stmt|;
block|}
DECL|method|getRandomIOExceptionRateOnOpen
specifier|public
name|double
name|getRandomIOExceptionRateOnOpen
parameter_list|()
block|{
return|return
name|randomIOExceptionRateOnOpen
return|;
block|}
DECL|method|maybeThrowIOException
name|void
name|maybeThrowIOException
parameter_list|(
name|String
name|message
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|randomState
operator|.
name|nextDouble
argument_list|()
operator|<
name|randomIOExceptionRate
condition|)
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": MockDirectoryWrapper: now throw random exception"
operator|+
operator|(
name|message
operator|==
literal|null
condition|?
literal|""
else|:
literal|" ("
operator|+
name|message
operator|+
literal|")"
operator|)
argument_list|)
expr_stmt|;
operator|new
name|Throwable
argument_list|()
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"a random IOException"
operator|+
operator|(
name|message
operator|==
literal|null
condition|?
literal|""
else|:
literal|" ("
operator|+
name|message
operator|+
literal|")"
operator|)
argument_list|)
throw|;
block|}
block|}
DECL|method|maybeThrowIOExceptionOnOpen
name|void
name|maybeThrowIOExceptionOnOpen
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|randomState
operator|.
name|nextDouble
argument_list|()
operator|<
name|randomIOExceptionRateOnOpen
condition|)
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": MockDirectoryWrapper: now throw random exception during open file="
operator|+
name|name
argument_list|)
expr_stmt|;
operator|new
name|Throwable
argument_list|()
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allowRandomFileNotFoundException
operator|==
literal|false
operator|||
name|randomState
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"a random IOException ("
operator|+
name|name
operator|+
literal|")"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|randomState
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|FileNotFoundException
argument_list|(
literal|"a random IOException ("
operator|+
name|name
operator|+
literal|")"
argument_list|)
else|:
operator|new
name|NoSuchFileException
argument_list|(
literal|"a random IOException ("
operator|+
name|name
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** returns current open file handle count */
DECL|method|getFileHandleCount
specifier|public
specifier|synchronized
name|long
name|getFileHandleCount
parameter_list|()
block|{
return|return
name|openFileHandles
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|deleteFile
specifier|public
specifier|synchronized
name|void
name|deleteFile
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|maybeYield
argument_list|()
expr_stmt|;
name|deleteFile
argument_list|(
name|name
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// sets the cause of the incoming ioe to be the stack
comment|// trace when the offending file name was opened
DECL|method|fillOpenTrace
specifier|private
specifier|synchronized
name|Throwable
name|fillOpenTrace
parameter_list|(
name|Throwable
name|t
parameter_list|,
name|String
name|name
parameter_list|,
name|boolean
name|input
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Closeable
argument_list|,
name|Exception
argument_list|>
name|ent
range|:
name|openFileHandles
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|input
operator|&&
name|ent
operator|.
name|getKey
argument_list|()
operator|instanceof
name|MockIndexInputWrapper
operator|&&
operator|(
operator|(
name|MockIndexInputWrapper
operator|)
name|ent
operator|.
name|getKey
argument_list|()
operator|)
operator|.
name|name
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|t
operator|.
name|initCause
argument_list|(
name|ent
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|input
operator|&&
name|ent
operator|.
name|getKey
argument_list|()
operator|instanceof
name|MockIndexOutputWrapper
operator|&&
operator|(
operator|(
name|MockIndexOutputWrapper
operator|)
name|ent
operator|.
name|getKey
argument_list|()
operator|)
operator|.
name|name
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|t
operator|.
name|initCause
argument_list|(
name|ent
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|t
return|;
block|}
DECL|method|maybeYield
specifier|private
name|void
name|maybeYield
parameter_list|()
block|{
if|if
condition|(
name|randomState
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|deleteFile
specifier|private
specifier|synchronized
name|void
name|deleteFile
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|forced
parameter_list|)
throws|throws
name|IOException
block|{
name|maybeYield
argument_list|()
expr_stmt|;
name|maybeThrowDeterministicException
argument_list|()
expr_stmt|;
if|if
condition|(
name|crashed
operator|&&
operator|!
name|forced
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"cannot delete after crash"
argument_list|)
throw|;
if|if
condition|(
name|unSyncedFiles
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
name|unSyncedFiles
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|forced
operator|&&
operator|(
name|noDeleteOpenFile
operator|||
name|assertNoDeleteOpenFile
operator|)
condition|)
block|{
if|if
condition|(
name|openFiles
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|openFilesDeleted
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|assertNoDeleteOpenFile
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|fillOpenTrace
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"MockDirectoryWrapper: file \""
operator|+
name|name
operator|+
literal|"\" is still open: cannot delete"
argument_list|)
argument_list|,
name|name
argument_list|,
literal|true
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|(
name|AssertionError
operator|)
name|fillOpenTrace
argument_list|(
operator|new
name|AssertionError
argument_list|(
literal|"MockDirectoryWrapper: file \""
operator|+
name|name
operator|+
literal|"\" is still open: cannot delete"
argument_list|)
argument_list|,
name|name
argument_list|,
literal|true
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|openFilesDeleted
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|forced
operator|&&
name|enableVirusScanner
operator|&&
operator|(
name|randomState
operator|.
name|nextInt
argument_list|(
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|triedToDelete
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"MDW: now refuse to delete file: "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"cannot delete file: "
operator|+
name|name
operator|+
literal|", a virus scanner has it open"
argument_list|)
throw|;
block|}
name|triedToDelete
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|in
operator|.
name|deleteFile
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/** Returns true if {@link #deleteFile} was called with this    *  fileName, but the virus checker prevented the deletion. */
DECL|method|didTryToDelete
specifier|public
name|boolean
name|didTryToDelete
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
return|return
name|triedToDelete
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
return|;
block|}
DECL|method|getOpenDeletedFiles
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|String
argument_list|>
name|getOpenDeletedFiles
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|openFilesDeleted
argument_list|)
return|;
block|}
DECL|field|failOnCreateOutput
specifier|private
name|boolean
name|failOnCreateOutput
init|=
literal|true
decl_stmt|;
DECL|method|setFailOnCreateOutput
specifier|public
name|void
name|setFailOnCreateOutput
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
name|failOnCreateOutput
operator|=
name|v
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createOutput
specifier|public
specifier|synchronized
name|IndexOutput
name|createOutput
parameter_list|(
name|String
name|name
parameter_list|,
name|IOContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|maybeThrowDeterministicException
argument_list|()
expr_stmt|;
name|maybeThrowIOExceptionOnOpen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|maybeYield
argument_list|()
expr_stmt|;
if|if
condition|(
name|failOnCreateOutput
condition|)
block|{
name|maybeThrowDeterministicException
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|crashed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"cannot createOutput after crash"
argument_list|)
throw|;
block|}
name|init
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|preventDoubleWrite
operator|&&
name|createdFiles
operator|.
name|contains
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|name
operator|.
name|equals
argument_list|(
literal|"segments.gen"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"file \""
operator|+
name|name
operator|+
literal|"\" was already written to"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|(
name|noDeleteOpenFile
operator|||
name|assertNoDeleteOpenFile
operator|)
operator|&&
name|openFiles
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|assertNoDeleteOpenFile
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"MockDirectoryWrapper: file \""
operator|+
name|name
operator|+
literal|"\" is still open: cannot overwrite"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"MockDirectoryWrapper: file \""
operator|+
name|name
operator|+
literal|"\" is still open: cannot overwrite"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|crashed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"cannot createOutput after crash"
argument_list|)
throw|;
block|}
name|unSyncedFiles
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|createdFiles
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|instanceof
name|RAMDirectory
condition|)
block|{
name|RAMDirectory
name|ramdir
init|=
operator|(
name|RAMDirectory
operator|)
name|in
decl_stmt|;
name|RAMFile
name|file
init|=
operator|new
name|RAMFile
argument_list|(
name|ramdir
argument_list|)
decl_stmt|;
name|RAMFile
name|existing
init|=
name|ramdir
operator|.
name|fileMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|// Enforce write once:
if|if
condition|(
name|existing
operator|!=
literal|null
operator|&&
operator|!
name|name
operator|.
name|equals
argument_list|(
literal|"segments.gen"
argument_list|)
operator|&&
name|preventDoubleWrite
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"file "
operator|+
name|name
operator|+
literal|" already exists"
argument_list|)
throw|;
block|}
else|else
block|{
if|if
condition|(
name|existing
operator|!=
literal|null
condition|)
block|{
name|ramdir
operator|.
name|sizeInBytes
operator|.
name|getAndAdd
argument_list|(
operator|-
name|existing
operator|.
name|sizeInBytes
argument_list|)
expr_stmt|;
name|existing
operator|.
name|directory
operator|=
literal|null
expr_stmt|;
block|}
name|ramdir
operator|.
name|fileMap
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
comment|//System.out.println(Thread.currentThread().getName() + ": MDW: create " + name);
name|IndexOutput
name|delegateOutput
init|=
name|in
operator|.
name|createOutput
argument_list|(
name|name
argument_list|,
name|LuceneTestCase
operator|.
name|newIOContext
argument_list|(
name|randomState
argument_list|,
name|context
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|IndexOutput
name|io
init|=
operator|new
name|MockIndexOutputWrapper
argument_list|(
name|this
argument_list|,
name|delegateOutput
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|addFileHandle
argument_list|(
name|io
argument_list|,
name|name
argument_list|,
name|Handle
operator|.
name|Output
argument_list|)
expr_stmt|;
name|openFilesForWrite
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|// throttling REALLY slows down tests, so don't do it very often for SOMETIMES.
if|if
condition|(
name|throttling
operator|==
name|Throttling
operator|.
name|ALWAYS
operator|||
operator|(
name|throttling
operator|==
name|Throttling
operator|.
name|SOMETIMES
operator|&&
name|randomState
operator|.
name|nextInt
argument_list|(
literal|200
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|in
operator|instanceof
name|RateLimitedDirectoryWrapper
operator|)
condition|)
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"MockDirectoryWrapper: throttling indexOutput ("
operator|+
name|name
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
name|throttledOutput
operator|.
name|newFromDelegate
argument_list|(
name|io
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|io
return|;
block|}
block|}
DECL|enum|Handle
specifier|private
specifier|static
enum|enum
name|Handle
block|{
DECL|enum constant|Input
DECL|enum constant|Output
DECL|enum constant|Slice
name|Input
block|,
name|Output
block|,
name|Slice
block|}
DECL|method|addFileHandle
specifier|synchronized
name|void
name|addFileHandle
parameter_list|(
name|Closeable
name|c
parameter_list|,
name|String
name|name
parameter_list|,
name|Handle
name|handle
parameter_list|)
block|{
name|Integer
name|v
init|=
name|openFiles
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
literal|null
condition|)
block|{
name|v
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|v
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|openFiles
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|openFiles
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|openFileHandles
operator|.
name|put
argument_list|(
name|c
argument_list|,
operator|new
name|RuntimeException
argument_list|(
literal|"unclosed Index"
operator|+
name|handle
operator|.
name|name
argument_list|()
operator|+
literal|": "
operator|+
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|field|failOnOpenInput
specifier|private
name|boolean
name|failOnOpenInput
init|=
literal|true
decl_stmt|;
DECL|method|setFailOnOpenInput
specifier|public
name|void
name|setFailOnOpenInput
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
name|failOnOpenInput
operator|=
name|v
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|openInput
specifier|public
specifier|synchronized
name|IndexInput
name|openInput
parameter_list|(
name|String
name|name
parameter_list|,
name|IOContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|maybeThrowDeterministicException
argument_list|()
expr_stmt|;
name|maybeThrowIOExceptionOnOpen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|maybeYield
argument_list|()
expr_stmt|;
if|if
condition|(
name|failOnOpenInput
condition|)
block|{
name|maybeThrowDeterministicException
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|LuceneTestCase
operator|.
name|slowFileExists
argument_list|(
name|in
argument_list|,
name|name
argument_list|)
condition|)
block|{
throw|throw
name|randomState
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|new
name|FileNotFoundException
argument_list|(
name|name
operator|+
literal|" in dir="
operator|+
name|in
argument_list|)
else|:
operator|new
name|NoSuchFileException
argument_list|(
name|name
operator|+
literal|" in dir="
operator|+
name|in
argument_list|)
throw|;
block|}
comment|// cannot open a file for input if it's still open for
comment|// output, except for segments.gen and segments_N
if|if
condition|(
operator|!
name|allowReadingFilesStillOpenForWrite
operator|&&
name|openFilesForWrite
operator|.
name|contains
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|name
operator|.
name|startsWith
argument_list|(
literal|"segments"
argument_list|)
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|fillOpenTrace
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"MockDirectoryWrapper: file \""
operator|+
name|name
operator|+
literal|"\" is still open for writing"
argument_list|)
argument_list|,
name|name
argument_list|,
literal|false
argument_list|)
throw|;
block|}
name|IndexInput
name|delegateInput
init|=
name|in
operator|.
name|openInput
argument_list|(
name|name
argument_list|,
name|LuceneTestCase
operator|.
name|newIOContext
argument_list|(
name|randomState
argument_list|,
name|context
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|IndexInput
name|ii
decl_stmt|;
name|int
name|randomInt
init|=
name|randomState
operator|.
name|nextInt
argument_list|(
literal|500
argument_list|)
decl_stmt|;
if|if
condition|(
name|useSlowOpenClosers
operator|&&
name|randomInt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"MockDirectoryWrapper: using SlowClosingMockIndexInputWrapper for file "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
name|ii
operator|=
operator|new
name|SlowClosingMockIndexInputWrapper
argument_list|(
name|this
argument_list|,
name|name
argument_list|,
name|delegateInput
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|useSlowOpenClosers
operator|&&
name|randomInt
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"MockDirectoryWrapper: using SlowOpeningMockIndexInputWrapper for file "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
name|ii
operator|=
operator|new
name|SlowOpeningMockIndexInputWrapper
argument_list|(
name|this
argument_list|,
name|name
argument_list|,
name|delegateInput
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ii
operator|=
operator|new
name|MockIndexInputWrapper
argument_list|(
name|this
argument_list|,
name|name
argument_list|,
name|delegateInput
argument_list|)
expr_stmt|;
block|}
name|addFileHandle
argument_list|(
name|ii
argument_list|,
name|name
argument_list|,
name|Handle
operator|.
name|Input
argument_list|)
expr_stmt|;
return|return
name|ii
return|;
block|}
comment|/** Provided for testing purposes.  Use sizeInBytes() instead. */
DECL|method|getRecomputedSizeInBytes
specifier|public
specifier|synchronized
specifier|final
name|long
name|getRecomputedSizeInBytes
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
operator|(
name|in
operator|instanceof
name|RAMDirectory
operator|)
condition|)
return|return
name|sizeInBytes
argument_list|()
return|;
name|long
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|RAMFile
name|file
range|:
operator|(
operator|(
name|RAMDirectory
operator|)
name|in
operator|)
operator|.
name|fileMap
operator|.
name|values
argument_list|()
control|)
block|{
name|size
operator|+=
name|file
operator|.
name|ramBytesUsed
argument_list|()
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
comment|/** Like getRecomputedSizeInBytes(), but, uses actual file    * lengths rather than buffer allocations (which are    * quantized up to nearest    * RAMOutputStream.BUFFER_SIZE (now 1024) bytes.    */
DECL|method|getRecomputedActualSizeInBytes
specifier|public
specifier|final
specifier|synchronized
name|long
name|getRecomputedActualSizeInBytes
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
operator|(
name|in
operator|instanceof
name|RAMDirectory
operator|)
condition|)
return|return
name|sizeInBytes
argument_list|()
return|;
name|long
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|RAMFile
name|file
range|:
operator|(
operator|(
name|RAMDirectory
operator|)
name|in
operator|)
operator|.
name|fileMap
operator|.
name|values
argument_list|()
control|)
name|size
operator|+=
name|file
operator|.
name|length
expr_stmt|;
return|return
name|size
return|;
block|}
comment|// NOTE: This is off by default; see LUCENE-5574
DECL|field|assertNoUnreferencedFilesOnClose
specifier|private
name|boolean
name|assertNoUnreferencedFilesOnClose
decl_stmt|;
DECL|method|setAssertNoUnrefencedFilesOnClose
specifier|public
name|void
name|setAssertNoUnrefencedFilesOnClose
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
name|assertNoUnreferencedFilesOnClose
operator|=
name|v
expr_stmt|;
block|}
comment|/**    * Set to false if you want to return the pure lockfactory    * and not wrap it with MockLockFactoryWrapper.    *<p>    * Be careful if you turn this off: MockDirectoryWrapper might    * no longer be able to detect if you forget to close an IndexWriter,    * and spit out horribly scary confusing exceptions instead of    * simply telling you that.    */
DECL|method|setWrapLockFactory
specifier|public
name|void
name|setWrapLockFactory
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
name|this
operator|.
name|wrapLockFactory
operator|=
name|v
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|// files that we tried to delete, but couldn't because readers were open.
comment|// all that matters is that we tried! (they will eventually go away)
comment|//   still open when we tried to delete
name|Set
argument_list|<
name|String
argument_list|>
name|pendingDeletions
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|openFilesDeleted
argument_list|)
decl_stmt|;
comment|//   virus scanner when we tried to delete
name|pendingDeletions
operator|.
name|addAll
argument_list|(
name|triedToDelete
argument_list|)
expr_stmt|;
name|maybeYield
argument_list|()
expr_stmt|;
if|if
condition|(
name|openFiles
operator|==
literal|null
condition|)
block|{
name|openFiles
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|openFilesDeleted
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|openFiles
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// print the first one as its very verbose otherwise
name|Exception
name|cause
init|=
literal|null
decl_stmt|;
name|Iterator
argument_list|<
name|Exception
argument_list|>
name|stacktraces
init|=
name|openFileHandles
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|stacktraces
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|cause
operator|=
name|stacktraces
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
comment|// RuntimeException instead of IOException because
comment|// super() does not throw IOException currently:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"MockDirectoryWrapper: cannot close: there are still open files: "
operator|+
name|openFiles
argument_list|,
name|cause
argument_list|)
throw|;
block|}
if|if
condition|(
name|openLocks
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Exception
name|cause
init|=
literal|null
decl_stmt|;
name|Iterator
argument_list|<
name|Exception
argument_list|>
name|stacktraces
init|=
name|openLocks
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|stacktraces
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|cause
operator|=
name|stacktraces
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"MockDirectoryWrapper: cannot close: there are still open locks: "
operator|+
name|openLocks
argument_list|,
name|cause
argument_list|)
throw|;
block|}
name|isOpen
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|getCheckIndexOnClose
argument_list|()
condition|)
block|{
name|randomIOExceptionRate
operator|=
literal|0.0
expr_stmt|;
name|randomIOExceptionRateOnOpen
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|DirectoryReader
operator|.
name|indexExists
argument_list|(
name|this
argument_list|)
condition|)
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nNOTE: MockDirectoryWrapper: now crush"
argument_list|)
expr_stmt|;
block|}
name|crash
argument_list|()
expr_stmt|;
comment|// corrupt any unsynced-files
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nNOTE: MockDirectoryWrapper: now run CheckIndex"
argument_list|)
expr_stmt|;
block|}
name|TestUtil
operator|.
name|checkIndex
argument_list|(
name|this
argument_list|,
name|getCrossCheckTermVectorsOnClose
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles
if|if
condition|(
name|assertNoUnreferencedFilesOnClose
condition|)
block|{
comment|// now look for unreferenced files: discount ones that we tried to delete but could not
name|Set
argument_list|<
name|String
argument_list|>
name|allFiles
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|listAll
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|allFiles
operator|.
name|removeAll
argument_list|(
name|pendingDeletions
argument_list|)
expr_stmt|;
name|String
index|[]
name|startFiles
init|=
name|allFiles
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|IndexWriterConfig
name|iwc
init|=
operator|new
name|IndexWriterConfig
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|iwc
operator|.
name|setIndexDeletionPolicy
argument_list|(
name|NoDeletionPolicy
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
operator|new
name|IndexWriter
argument_list|(
name|in
argument_list|,
name|iwc
argument_list|)
operator|.
name|rollback
argument_list|()
expr_stmt|;
name|String
index|[]
name|endFiles
init|=
name|in
operator|.
name|listAll
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|startSet
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|startFiles
argument_list|)
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|endSet
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|endFiles
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pendingDeletions
operator|.
name|contains
argument_list|(
literal|"segments.gen"
argument_list|)
operator|&&
name|endSet
operator|.
name|contains
argument_list|(
literal|"segments.gen"
argument_list|)
condition|)
block|{
comment|// this is possible if we hit an exception while writing segments.gen, we try to delete it
comment|// and it ends out in pendingDeletions (but IFD wont remove this).
name|startSet
operator|.
name|add
argument_list|(
literal|"segments.gen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"MDW: Unreferenced check: Ignoring segments.gen that we could not delete."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// its possible we cannot delete the segments_N on windows if someone has it open and
comment|// maybe other files too, depending on timing. normally someone on windows wouldnt have
comment|// an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...
for|for
control|(
name|String
name|file
range|:
name|pendingDeletions
control|)
block|{
if|if
condition|(
name|file
operator|.
name|startsWith
argument_list|(
literal|"segments"
argument_list|)
operator|&&
operator|!
name|file
operator|.
name|equals
argument_list|(
literal|"segments.gen"
argument_list|)
operator|&&
name|endSet
operator|.
name|contains
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|startSet
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"MDW: Unreferenced check: Ignoring segments file: "
operator|+
name|file
operator|+
literal|" that we could not delete."
argument_list|)
expr_stmt|;
block|}
name|SegmentInfos
name|sis
decl_stmt|;
try|try
block|{
name|sis
operator|=
name|SegmentInfos
operator|.
name|readCommit
argument_list|(
name|in
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// OK: likely some of the .si files were deleted
name|sis
operator|=
operator|new
name|SegmentInfos
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|ghosts
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|sis
operator|.
name|files
argument_list|(
name|in
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|ghosts
control|)
block|{
if|if
condition|(
name|endSet
operator|.
name|contains
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|startSet
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
assert|assert
name|pendingDeletions
operator|.
name|contains
argument_list|(
name|s
argument_list|)
assert|;
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"MDW: Unreferenced check: Ignoring referenced file: "
operator|+
name|s
operator|+
literal|" "
operator|+
literal|"from "
operator|+
name|file
operator|+
literal|" that we could not delete."
argument_list|)
expr_stmt|;
block|}
name|startSet
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"ERROR processing leftover segments file "
operator|+
name|file
operator|+
literal|":"
argument_list|)
expr_stmt|;
name|t
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|startFiles
operator|=
name|startSet
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|endFiles
operator|=
name|endSet
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|startFiles
argument_list|,
name|endFiles
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|removed
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fileName
range|:
name|startFiles
control|)
block|{
if|if
condition|(
operator|!
name|endSet
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
name|removed
operator|.
name|add
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|String
argument_list|>
name|added
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fileName
range|:
name|endFiles
control|)
block|{
if|if
condition|(
operator|!
name|startSet
operator|.
name|contains
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
name|added
operator|.
name|add
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|extras
decl_stmt|;
if|if
condition|(
name|removed
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|extras
operator|=
literal|"\n\nThese files were removed: "
operator|+
name|removed
expr_stmt|;
block|}
else|else
block|{
name|extras
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|added
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|extras
operator|+=
literal|"\n\nThese files were added (waaaaaaaaaat!): "
operator|+
name|added
expr_stmt|;
block|}
if|if
condition|(
name|pendingDeletions
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|extras
operator|+=
literal|"\n\nThese files we had previously tried to delete, but couldn't: "
operator|+
name|pendingDeletions
expr_stmt|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unreferenced files: before delete:\n    "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|startFiles
argument_list|)
operator|+
literal|"\n  after delete:\n    "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|endFiles
argument_list|)
operator|+
name|extras
argument_list|)
throw|;
block|}
name|DirectoryReader
name|ir1
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|int
name|numDocs1
init|=
name|ir1
operator|.
name|numDocs
argument_list|()
decl_stmt|;
name|ir1
operator|.
name|close
argument_list|()
expr_stmt|;
operator|new
name|IndexWriter
argument_list|(
name|this
argument_list|,
operator|new
name|IndexWriterConfig
argument_list|(
literal|null
argument_list|)
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|DirectoryReader
name|ir2
init|=
name|DirectoryReader
operator|.
name|open
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|int
name|numDocs2
init|=
name|ir2
operator|.
name|numDocs
argument_list|()
decl_stmt|;
name|ir2
operator|.
name|close
argument_list|()
expr_stmt|;
assert|assert
name|numDocs1
operator|==
name|numDocs2
operator|:
literal|"numDocs changed after opening/closing IW: before="
operator|+
name|numDocs1
operator|+
literal|" after="
operator|+
name|numDocs2
assert|;
block|}
block|}
block|}
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|removeOpenFile
specifier|synchronized
name|void
name|removeOpenFile
parameter_list|(
name|Closeable
name|c
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|Integer
name|v
init|=
name|openFiles
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|// Could be null when crash() was called
if|if
condition|(
name|v
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|v
operator|.
name|intValue
argument_list|()
operator|==
literal|1
condition|)
block|{
name|openFiles
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|v
operator|.
name|intValue
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|openFiles
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
name|openFileHandles
operator|.
name|remove
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
DECL|method|removeIndexOutput
specifier|public
specifier|synchronized
name|void
name|removeIndexOutput
parameter_list|(
name|IndexOutput
name|out
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|openFilesForWrite
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|removeOpenFile
argument_list|(
name|out
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
DECL|method|removeIndexInput
specifier|public
specifier|synchronized
name|void
name|removeIndexInput
parameter_list|(
name|IndexInput
name|in
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|removeOpenFile
argument_list|(
name|in
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/**    * Objects that represent fail-able conditions. Objects of a derived    * class are created and registered with the mock directory. After    * register, each object will be invoked once for each first write    * of a file, giving the object a chance to throw an IOException.    */
DECL|class|Failure
specifier|public
specifier|static
class|class
name|Failure
block|{
comment|/**      * eval is called on the first write of every new file.      */
DECL|method|eval
specifier|public
name|void
name|eval
parameter_list|(
name|MockDirectoryWrapper
name|dir
parameter_list|)
throws|throws
name|IOException
block|{ }
comment|/**      * reset should set the state of the failure to its default      * (freshly constructed) state. Reset is convenient for tests      * that want to create one failure object and then reuse it in      * multiple cases. This, combined with the fact that Failure      * subclasses are often anonymous classes makes reset difficult to      * do otherwise.      *      * A typical example of use is      * Failure failure = new Failure() { ... };      * ...      * mock.failOn(failure.reset())      */
DECL|method|reset
specifier|public
name|Failure
name|reset
parameter_list|()
block|{
return|return
name|this
return|;
block|}
DECL|field|doFail
specifier|protected
name|boolean
name|doFail
decl_stmt|;
DECL|method|setDoFail
specifier|public
name|void
name|setDoFail
parameter_list|()
block|{
name|doFail
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|clearDoFail
specifier|public
name|void
name|clearDoFail
parameter_list|()
block|{
name|doFail
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|field|failures
name|ArrayList
argument_list|<
name|Failure
argument_list|>
name|failures
decl_stmt|;
comment|/**    * add a Failure object to the list of objects to be evaluated    * at every potential failure point    */
DECL|method|failOn
specifier|synchronized
specifier|public
name|void
name|failOn
parameter_list|(
name|Failure
name|fail
parameter_list|)
block|{
if|if
condition|(
name|failures
operator|==
literal|null
condition|)
block|{
name|failures
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|failures
operator|.
name|add
argument_list|(
name|fail
argument_list|)
expr_stmt|;
block|}
comment|/**    * Iterate through the failures list, giving each object a    * chance to throw an IOE    */
DECL|method|maybeThrowDeterministicException
specifier|synchronized
name|void
name|maybeThrowDeterministicException
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|failures
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|failures
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|failures
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|eval
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|LuceneTestCase
operator|.
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"MockDirectoryWrapper: throw exc"
argument_list|)
expr_stmt|;
name|t
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
name|IOUtils
operator|.
name|reThrow
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|listAll
specifier|public
specifier|synchronized
name|String
index|[]
name|listAll
parameter_list|()
throws|throws
name|IOException
block|{
name|maybeYield
argument_list|()
expr_stmt|;
return|return
name|in
operator|.
name|listAll
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|fileLength
specifier|public
specifier|synchronized
name|long
name|fileLength
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|maybeYield
argument_list|()
expr_stmt|;
return|return
name|in
operator|.
name|fileLength
argument_list|(
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|makeLock
specifier|public
specifier|synchronized
name|Lock
name|makeLock
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|maybeYield
argument_list|()
expr_stmt|;
return|return
name|getLockFactory
argument_list|()
operator|.
name|makeLock
argument_list|(
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|clearLock
specifier|public
specifier|synchronized
name|void
name|clearLock
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|maybeYield
argument_list|()
expr_stmt|;
name|getLockFactory
argument_list|()
operator|.
name|clearLock
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setLockFactory
specifier|public
specifier|synchronized
name|void
name|setLockFactory
parameter_list|(
name|LockFactory
name|lockFactory
parameter_list|)
throws|throws
name|IOException
block|{
name|maybeYield
argument_list|()
expr_stmt|;
comment|// sneaky: we must pass the original this way to the dir, because
comment|// some impls (e.g. FSDir) do instanceof here.
name|in
operator|.
name|setLockFactory
argument_list|(
name|lockFactory
argument_list|)
expr_stmt|;
comment|// now set our wrapped factory here
name|this
operator|.
name|lockFactory
operator|=
operator|new
name|MockLockFactoryWrapper
argument_list|(
name|this
argument_list|,
name|lockFactory
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getLockFactory
specifier|public
specifier|synchronized
name|LockFactory
name|getLockFactory
parameter_list|()
block|{
name|maybeYield
argument_list|()
expr_stmt|;
if|if
condition|(
name|wrapLockFactory
condition|)
block|{
return|return
name|lockFactory
return|;
block|}
else|else
block|{
return|return
name|in
operator|.
name|getLockFactory
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getLockID
specifier|public
specifier|synchronized
name|String
name|getLockID
parameter_list|()
block|{
name|maybeYield
argument_list|()
expr_stmt|;
return|return
name|in
operator|.
name|getLockID
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|copy
specifier|public
specifier|synchronized
name|void
name|copy
parameter_list|(
name|Directory
name|to
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|dest
parameter_list|,
name|IOContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|maybeYield
argument_list|()
expr_stmt|;
comment|// randomize the IOContext here?
name|in
operator|.
name|copy
argument_list|(
name|to
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
comment|/** Use this when throwing fake {@code IOException},    *  e.g. from {@link MockDirectoryWrapper.Failure}. */
DECL|class|FakeIOException
specifier|public
specifier|static
class|class
name|FakeIOException
extends|extends
name|IOException
block|{   }
block|}
end_class
end_unit
