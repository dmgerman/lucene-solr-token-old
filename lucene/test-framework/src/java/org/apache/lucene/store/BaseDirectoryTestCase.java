begin_unit
begin_package
DECL|package|org.apache.lucene.store
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|NoSuchFileException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|CRC32
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DirectoryReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexNotFoundException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import
begin_comment
comment|/** Base class for per-Directory tests. */
end_comment
begin_class
DECL|class|BaseDirectoryTestCase
specifier|public
specifier|abstract
class|class
name|BaseDirectoryTestCase
extends|extends
name|LuceneTestCase
block|{
comment|/** Subclass returns the Directory to be tested; if it's    *  an FS-based directory it should point to the specified    *  path, else it can ignore it. */
DECL|method|getDirectory
specifier|protected
specifier|abstract
name|Directory
name|getDirectory
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|// first some basic tests for the directory api
DECL|method|testCopy
specifier|public
name|void
name|testCopy
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|source
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testCopy"
argument_list|)
argument_list|)
decl_stmt|;
name|Directory
name|dest
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|IndexOutput
name|output
init|=
name|source
operator|.
name|createOutput
argument_list|(
literal|"foobar"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|numBytes
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|20000
argument_list|)
decl_stmt|;
name|byte
name|bytes
index|[]
init|=
operator|new
name|byte
index|[
name|numBytes
index|]
decl_stmt|;
name|random
argument_list|()
operator|.
name|nextBytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeBytes
argument_list|(
name|bytes
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|source
operator|.
name|copy
argument_list|(
name|dest
argument_list|,
literal|"foobar"
argument_list|,
literal|"foobaz"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|slowFileExists
argument_list|(
name|dest
argument_list|,
literal|"foobaz"
argument_list|)
argument_list|)
expr_stmt|;
name|IndexInput
name|input
init|=
name|dest
operator|.
name|openInput
argument_list|(
literal|"foobaz"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|byte
name|bytes2
index|[]
init|=
operator|new
name|byte
index|[
name|numBytes
index|]
decl_stmt|;
name|input
operator|.
name|readBytes
argument_list|(
name|bytes2
argument_list|,
literal|0
argument_list|,
name|bytes2
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|input
operator|.
name|length
argument_list|()
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertArrayEquals
argument_list|(
name|bytes
argument_list|,
name|bytes2
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|close
argument_list|(
name|source
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
DECL|method|testCopyDestination
specifier|public
name|void
name|testCopyDestination
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|source
init|=
name|newDirectory
argument_list|()
decl_stmt|;
name|Directory
name|dest
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testCopyDestination"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|source
operator|.
name|createOutput
argument_list|(
literal|"foobar"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|numBytes
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|20000
argument_list|)
decl_stmt|;
name|byte
name|bytes
index|[]
init|=
operator|new
name|byte
index|[
name|numBytes
index|]
decl_stmt|;
name|random
argument_list|()
operator|.
name|nextBytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeBytes
argument_list|(
name|bytes
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|source
operator|.
name|copy
argument_list|(
name|dest
argument_list|,
literal|"foobar"
argument_list|,
literal|"foobaz"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|slowFileExists
argument_list|(
name|dest
argument_list|,
literal|"foobaz"
argument_list|)
argument_list|)
expr_stmt|;
name|IndexInput
name|input
init|=
name|dest
operator|.
name|openInput
argument_list|(
literal|"foobaz"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|byte
name|bytes2
index|[]
init|=
operator|new
name|byte
index|[
name|numBytes
index|]
decl_stmt|;
name|input
operator|.
name|readBytes
argument_list|(
name|bytes2
argument_list|,
literal|0
argument_list|,
name|bytes2
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|input
operator|.
name|length
argument_list|()
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertArrayEquals
argument_list|(
name|bytes
argument_list|,
name|bytes2
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|close
argument_list|(
name|source
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
DECL|method|testRename
specifier|public
name|void
name|testRename
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testRename"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"foobar"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|numBytes
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|20000
argument_list|)
decl_stmt|;
name|byte
name|bytes
index|[]
init|=
operator|new
name|byte
index|[
name|numBytes
index|]
decl_stmt|;
name|random
argument_list|()
operator|.
name|nextBytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeBytes
argument_list|(
name|bytes
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|renameFile
argument_list|(
literal|"foobar"
argument_list|,
literal|"foobaz"
argument_list|)
expr_stmt|;
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"foobaz"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|byte
name|bytes2
index|[]
init|=
operator|new
name|byte
index|[
name|numBytes
index|]
decl_stmt|;
name|input
operator|.
name|readBytes
argument_list|(
name|bytes2
argument_list|,
literal|0
argument_list|,
name|bytes2
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|input
operator|.
name|length
argument_list|()
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertArrayEquals
argument_list|(
name|bytes
argument_list|,
name|bytes2
argument_list|)
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// TODO: are these semantics really needed by lucene? can we just throw exception?
DECL|method|testCopyOverwrite
specifier|public
name|void
name|testCopyOverwrite
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|source
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testCopyOverwrite"
argument_list|)
argument_list|)
decl_stmt|;
name|Directory
name|dest
init|=
name|newDirectory
argument_list|()
decl_stmt|;
comment|// we are double-writing intentionally, because thats the api
if|if
condition|(
name|dest
operator|instanceof
name|MockDirectoryWrapper
condition|)
block|{
operator|(
operator|(
name|MockDirectoryWrapper
operator|)
name|dest
operator|)
operator|.
name|setPreventDoubleWrite
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|IndexOutput
name|output
init|=
name|source
operator|.
name|createOutput
argument_list|(
literal|"foobar"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|numBytes
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|20000
argument_list|)
decl_stmt|;
name|byte
name|bytes
index|[]
init|=
operator|new
name|byte
index|[
name|numBytes
index|]
decl_stmt|;
name|random
argument_list|()
operator|.
name|nextBytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeBytes
argument_list|(
name|bytes
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// create foobaz first, it should be overwritten
name|IndexOutput
name|output2
init|=
name|dest
operator|.
name|createOutput
argument_list|(
literal|"foobaz"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|output2
operator|.
name|writeString
argument_list|(
literal|"bogus!"
argument_list|)
expr_stmt|;
name|output2
operator|.
name|close
argument_list|()
expr_stmt|;
name|source
operator|.
name|copy
argument_list|(
name|dest
argument_list|,
literal|"foobar"
argument_list|,
literal|"foobaz"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|slowFileExists
argument_list|(
name|dest
argument_list|,
literal|"foobaz"
argument_list|)
argument_list|)
expr_stmt|;
name|IndexInput
name|input
init|=
name|dest
operator|.
name|openInput
argument_list|(
literal|"foobaz"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|byte
name|bytes2
index|[]
init|=
operator|new
name|byte
index|[
name|numBytes
index|]
decl_stmt|;
name|input
operator|.
name|readBytes
argument_list|(
name|bytes2
argument_list|,
literal|0
argument_list|,
name|bytes2
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|input
operator|.
name|length
argument_list|()
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertArrayEquals
argument_list|(
name|bytes
argument_list|,
name|bytes2
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|close
argument_list|(
name|source
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
DECL|method|testDeleteFile
specifier|public
name|void
name|testDeleteFile
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testDeleteFile"
argument_list|)
argument_list|)
decl_stmt|;
name|dir
operator|.
name|createOutput
argument_list|(
literal|"foo.txt"
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|deleteFile
argument_list|(
literal|"foo.txt"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|dir
operator|.
name|listAll
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testByte
specifier|public
name|void
name|testByte
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testByte"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"byte"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|output
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|128
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"byte"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|byte
operator|)
literal|128
argument_list|,
name|input
operator|.
name|readByte
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testShort
specifier|public
name|void
name|testShort
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testShort"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"short"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|output
operator|.
name|writeShort
argument_list|(
operator|(
name|short
operator|)
operator|-
literal|20
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"short"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|short
operator|)
operator|-
literal|20
argument_list|,
name|input
operator|.
name|readShort
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testInt
specifier|public
name|void
name|testInt
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testInt"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"int"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|output
operator|.
name|writeInt
argument_list|(
operator|-
literal|500
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"int"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|500
argument_list|,
name|input
operator|.
name|readInt
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testLong
specifier|public
name|void
name|testLong
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testLong"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"long"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|output
operator|.
name|writeLong
argument_list|(
operator|-
literal|5000
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"long"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|8
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|5000L
argument_list|,
name|input
operator|.
name|readLong
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testString
specifier|public
name|void
name|testString
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testString"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"string"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|output
operator|.
name|writeString
argument_list|(
literal|"hello!"
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"string"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"hello!"
argument_list|,
name|input
operator|.
name|readString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testVInt
specifier|public
name|void
name|testVInt
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testVInt"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"vint"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|output
operator|.
name|writeVInt
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"vint"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|500
argument_list|,
name|input
operator|.
name|readVInt
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testVLong
specifier|public
name|void
name|testVLong
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testVLong"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"vlong"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|output
operator|.
name|writeVLong
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"vlong"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|9
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|,
name|input
operator|.
name|readVLong
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testZInt
specifier|public
name|void
name|testZInt
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|int
index|[]
name|ints
init|=
operator|new
name|int
index|[
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ints
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|ints
index|[
name|i
index|]
operator|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ints
index|[
name|i
index|]
operator|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
name|Integer
operator|.
name|MIN_VALUE
else|:
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ints
index|[
name|i
index|]
operator|=
operator|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
operator|*
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testZInt"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"zint"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|ints
control|)
block|{
name|output
operator|.
name|writeZInt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"zint"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|ints
control|)
block|{
name|assertEquals
argument_list|(
name|i
argument_list|,
name|input
operator|.
name|readZInt
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|input
operator|.
name|length
argument_list|()
argument_list|,
name|input
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testZLong
specifier|public
name|void
name|testZLong
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|long
index|[]
name|longs
init|=
operator|new
name|long
index|[
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|longs
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|longs
index|[
name|i
index|]
operator|=
name|random
argument_list|()
operator|.
name|nextLong
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|longs
index|[
name|i
index|]
operator|=
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
name|Long
operator|.
name|MIN_VALUE
else|:
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|longs
index|[
name|i
index|]
operator|=
operator|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
operator|*
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testZLong"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"zlong"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|long
name|l
range|:
name|longs
control|)
block|{
name|output
operator|.
name|writeZLong
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"zlong"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|long
name|l
range|:
name|longs
control|)
block|{
name|assertEquals
argument_list|(
name|l
argument_list|,
name|input
operator|.
name|readZLong
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|input
operator|.
name|length
argument_list|()
argument_list|,
name|input
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testStringSet
specifier|public
name|void
name|testStringSet
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testStringSet"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"stringset"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|output
operator|.
name|writeStringSet
argument_list|(
name|asSet
argument_list|(
literal|"test1"
argument_list|,
literal|"test2"
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"stringset"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|16
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|asSet
argument_list|(
literal|"test1"
argument_list|,
literal|"test2"
argument_list|)
argument_list|,
name|input
operator|.
name|readStringSet
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testStringMap
specifier|public
name|void
name|testStringMap
parameter_list|()
throws|throws
name|Exception
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|m
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"test1"
argument_list|,
literal|"value1"
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"test2"
argument_list|,
literal|"value2"
argument_list|)
expr_stmt|;
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testStringMap"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"stringmap"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|output
operator|.
name|writeStringStringMap
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"stringmap"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|30
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|m
argument_list|,
name|input
operator|.
name|readStringStringMap
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// TODO: fold in some of the testing of o.a.l.index.TestIndexInput in here!
DECL|method|testChecksum
specifier|public
name|void
name|testChecksum
parameter_list|()
throws|throws
name|Exception
block|{
name|CRC32
name|expected
init|=
operator|new
name|CRC32
argument_list|()
decl_stmt|;
name|int
name|numBytes
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|20000
argument_list|)
decl_stmt|;
name|byte
name|bytes
index|[]
init|=
operator|new
name|byte
index|[
name|numBytes
index|]
decl_stmt|;
name|random
argument_list|()
operator|.
name|nextBytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|expected
operator|.
name|update
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testChecksum"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"checksum"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|output
operator|.
name|writeBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|ChecksumIndexInput
name|input
init|=
name|dir
operator|.
name|openChecksumInput
argument_list|(
literal|"checksum"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|input
operator|.
name|skipBytes
argument_list|(
name|numBytes
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
operator|.
name|getValue
argument_list|()
argument_list|,
name|input
operator|.
name|getChecksum
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Make sure directory throws AlreadyClosedException if    *  you try to createOutput after closing. */
DECL|method|testDetectClose
specifier|public
name|void
name|testDetectClose
parameter_list|()
throws|throws
name|Throwable
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testDetectClose"
argument_list|)
argument_list|)
decl_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
try|try
block|{
name|dir
operator|.
name|createOutput
argument_list|(
literal|"test"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"did not hit expected exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AlreadyClosedException
name|ace
parameter_list|)
block|{
comment|// expected
block|}
block|}
DECL|method|testThreadSafety
specifier|public
name|void
name|testThreadSafety
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testThreadSafety"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|instanceof
name|BaseDirectoryWrapper
condition|)
block|{
operator|(
operator|(
name|BaseDirectoryWrapper
operator|)
name|dir
operator|)
operator|.
name|setCheckIndexOnClose
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// we arent making an index
block|}
if|if
condition|(
name|dir
operator|instanceof
name|MockDirectoryWrapper
condition|)
block|{
operator|(
operator|(
name|MockDirectoryWrapper
operator|)
name|dir
operator|)
operator|.
name|setThrottling
argument_list|(
name|MockDirectoryWrapper
operator|.
name|Throttling
operator|.
name|NEVER
argument_list|)
expr_stmt|;
comment|// makes this test really slow
block|}
if|if
condition|(
name|VERBOSE
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
class|class
name|TheThread
extends|extends
name|Thread
block|{
specifier|private
name|String
name|name
decl_stmt|;
specifier|public
name|TheThread
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3000
condition|;
name|i
operator|++
control|)
block|{
name|String
name|fileName
init|=
name|this
operator|.
name|name
operator|+
name|i
decl_stmt|;
try|try
block|{
comment|//System.out.println("create:" + fileName);
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
name|fileName
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|slowFileExists
argument_list|(
name|dir
argument_list|,
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
empty_stmt|;
class|class
name|TheThread2
extends|extends
name|Thread
block|{
specifier|private
name|String
name|name
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|stop
decl_stmt|;
specifier|public
name|TheThread2
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|stop
operator|==
literal|false
condition|)
block|{
try|try
block|{
name|String
index|[]
name|files
init|=
name|dir
operator|.
name|listAll
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|files
control|)
block|{
comment|//System.out.println("file:" + file);
try|try
block|{
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
name|file
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
decl||
name|NoSuchFileException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getMessage
argument_list|()
operator|!=
literal|null
operator|&&
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"still open for writing"
argument_list|)
condition|)
block|{
comment|// ignore
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
empty_stmt|;
name|TheThread
name|theThread
init|=
operator|new
name|TheThread
argument_list|(
literal|"t1"
argument_list|)
decl_stmt|;
name|TheThread2
name|theThread2
init|=
operator|new
name|TheThread2
argument_list|(
literal|"t2"
argument_list|)
decl_stmt|;
name|theThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|theThread2
operator|.
name|start
argument_list|()
expr_stmt|;
name|theThread
operator|.
name|join
argument_list|()
expr_stmt|;
comment|// after first thread is done, no sense in waiting on thread 2
comment|// to listFiles() and loop over and over
name|theThread2
operator|.
name|stop
operator|=
literal|true
expr_stmt|;
name|theThread2
operator|.
name|join
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** LUCENE-1468: once we create an output, we should see    *  it in the dir listing and be able to open it with    *  openInput. */
DECL|method|testDirectoryFilter
specifier|public
name|void
name|testDirectoryFilter
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|name
init|=
literal|"file"
decl_stmt|;
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testDirectoryFilter"
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|dir
operator|.
name|createOutput
argument_list|(
name|name
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|slowFileExists
argument_list|(
name|dir
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|dir
operator|.
name|listAll
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|// LUCENE-2852
DECL|method|testSeekToEOFThenBack
specifier|public
name|void
name|testSeekToEOFThenBack
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testSeekToEOFThenBack"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|o
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"out"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
literal|3
operator|*
name|RAMInputStream
operator|.
name|BUFFER_SIZE
index|]
decl_stmt|;
name|o
operator|.
name|writeBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|o
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|i
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"out"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|i
operator|.
name|seek
argument_list|(
literal|2
operator|*
name|RAMInputStream
operator|.
name|BUFFER_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|i
operator|.
name|seek
argument_list|(
literal|3
operator|*
name|RAMInputStream
operator|.
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
name|i
operator|.
name|seek
argument_list|(
name|RAMInputStream
operator|.
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
name|i
operator|.
name|readBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|RAMInputStream
operator|.
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
name|i
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// LUCENE-1196
DECL|method|testIllegalEOF
specifier|public
name|void
name|testIllegalEOF
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testIllegalEOF"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|o
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"out"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
literal|1024
index|]
decl_stmt|;
name|o
operator|.
name|writeBytes
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|o
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|i
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"out"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|i
operator|.
name|seek
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|i
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testSeekPastEOF
specifier|public
name|void
name|testSeekPastEOF
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testSeekPastEOF"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|o
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"out"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|int
name|len
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|2048
argument_list|)
decl_stmt|;
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
name|o
operator|.
name|writeBytes
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|o
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|i
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"out"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|i
operator|.
name|seek
argument_list|(
name|len
operator|+
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|2048
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Did not get EOFException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|eof
parameter_list|)
block|{
comment|// pass
block|}
name|i
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testSliceOutOfBounds
specifier|public
name|void
name|testSliceOutOfBounds
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testSliceOutOfBounds"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|o
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"out"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|int
name|len
init|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|2040
argument_list|)
operator|+
literal|8
decl_stmt|;
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
name|o
operator|.
name|writeBytes
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|o
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|i
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"out"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|i
operator|.
name|slice
argument_list|(
literal|"slice1"
argument_list|,
literal|0
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Did not get IllegalArgumentException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// pass
block|}
try|try
block|{
name|i
operator|.
name|slice
argument_list|(
literal|"slice2"
argument_list|,
operator|-
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Did not get IllegalArgumentException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// pass
block|}
name|IndexInput
name|slice
init|=
name|i
operator|.
name|slice
argument_list|(
literal|"slice3"
argument_list|,
literal|4
argument_list|,
name|len
operator|/
literal|2
argument_list|)
decl_stmt|;
try|try
block|{
name|slice
operator|.
name|slice
argument_list|(
literal|"slice3sub"
argument_list|,
literal|1
argument_list|,
name|len
operator|/
literal|2
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Did not get IllegalArgumentException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
comment|// pass
block|}
name|i
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// LUCENE-3382 -- make sure we get exception if the directory really does not exist.
DECL|method|testNoDir
specifier|public
name|void
name|testNoDir
parameter_list|()
throws|throws
name|Throwable
block|{
name|Path
name|tempDir
init|=
name|createTempDir
argument_list|(
literal|"doesnotexist"
argument_list|)
decl_stmt|;
name|IOUtils
operator|.
name|rm
argument_list|(
name|tempDir
argument_list|)
expr_stmt|;
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|tempDir
argument_list|)
decl_stmt|;
try|try
block|{
name|DirectoryReader
operator|.
name|open
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"did not hit expected exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchFileException
decl||
name|IndexNotFoundException
name|nsde
parameter_list|)
block|{
comment|// expected
block|}
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testCopyBytes
specifier|public
name|void
name|testCopyBytes
parameter_list|()
throws|throws
name|Exception
block|{
name|testCopyBytes
argument_list|(
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testCopyBytes"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|value
specifier|private
specifier|static
name|byte
name|value
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
return|return
call|(
name|byte
call|)
argument_list|(
operator|(
name|idx
operator|%
literal|256
operator|)
operator|*
operator|(
literal|1
operator|+
operator|(
name|idx
operator|/
literal|256
operator|)
operator|)
argument_list|)
return|;
block|}
DECL|method|testCopyBytes
specifier|public
specifier|static
name|void
name|testCopyBytes
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|Exception
block|{
comment|// make random file
name|IndexOutput
name|out
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"test"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|77777
argument_list|)
index|]
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1777777
argument_list|)
decl_stmt|;
name|int
name|upto
init|=
literal|0
decl_stmt|;
name|int
name|byteUpto
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|size
condition|)
block|{
name|bytes
index|[
name|byteUpto
operator|++
index|]
operator|=
name|value
argument_list|(
name|upto
argument_list|)
expr_stmt|;
name|upto
operator|++
expr_stmt|;
if|if
condition|(
name|byteUpto
operator|==
name|bytes
operator|.
name|length
condition|)
block|{
name|out
operator|.
name|writeBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|byteUpto
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|out
operator|.
name|writeBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|byteUpto
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|size
argument_list|,
name|out
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|size
argument_list|,
name|dir
operator|.
name|fileLength
argument_list|(
literal|"test"
argument_list|)
argument_list|)
expr_stmt|;
comment|// copy from test -> test2
specifier|final
name|IndexInput
name|in
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"test"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|out
operator|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"test2"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|upto
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|upto
operator|<
name|size
condition|)
block|{
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|out
operator|.
name|writeByte
argument_list|(
name|in
operator|.
name|readByte
argument_list|()
argument_list|)
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|chunk
init|=
name|Math
operator|.
name|min
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
argument_list|,
name|size
operator|-
name|upto
argument_list|)
decl_stmt|;
name|out
operator|.
name|copyBytes
argument_list|(
name|in
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|upto
operator|+=
name|chunk
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
name|size
argument_list|,
name|upto
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// verify
name|IndexInput
name|in2
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"test2"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|upto
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|upto
operator|<
name|size
condition|)
block|{
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
specifier|final
name|byte
name|v
init|=
name|in2
operator|.
name|readByte
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|value
argument_list|(
name|upto
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|limit
init|=
name|Math
operator|.
name|min
argument_list|(
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|1
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
argument_list|,
name|size
operator|-
name|upto
argument_list|)
decl_stmt|;
name|in2
operator|.
name|readBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|byteIdx
init|=
literal|0
init|;
name|byteIdx
operator|<
name|limit
condition|;
name|byteIdx
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|value
argument_list|(
name|upto
argument_list|)
argument_list|,
name|bytes
index|[
name|byteIdx
index|]
argument_list|)
expr_stmt|;
name|upto
operator|++
expr_stmt|;
block|}
block|}
block|}
name|in2
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|deleteFile
argument_list|(
literal|"test"
argument_list|)
expr_stmt|;
name|dir
operator|.
name|deleteFile
argument_list|(
literal|"test2"
argument_list|)
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// LUCENE-3541
DECL|method|testCopyBytesWithThreads
specifier|public
name|void
name|testCopyBytesWithThreads
parameter_list|()
throws|throws
name|Exception
block|{
name|testCopyBytesWithThreads
argument_list|(
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testCopyBytesWithThreads"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testCopyBytesWithThreads
specifier|public
specifier|static
name|void
name|testCopyBytesWithThreads
parameter_list|(
name|Directory
name|d
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|datalen
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|101
argument_list|,
literal|10000
argument_list|)
decl_stmt|;
name|byte
name|data
index|[]
init|=
operator|new
name|byte
index|[
name|datalen
index|]
decl_stmt|;
name|random
argument_list|()
operator|.
name|nextBytes
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|IndexOutput
name|output
init|=
name|d
operator|.
name|createOutput
argument_list|(
literal|"data"
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
name|output
operator|.
name|writeBytes
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|input
init|=
name|d
operator|.
name|openInput
argument_list|(
literal|"data"
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
name|IndexOutput
name|outputHeader
init|=
name|d
operator|.
name|createOutput
argument_list|(
literal|"header"
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
comment|// copy our 100-byte header
name|outputHeader
operator|.
name|copyBytes
argument_list|(
name|input
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|outputHeader
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// now make N copies of the remaining bytes
name|CopyThread
name|copies
index|[]
init|=
operator|new
name|CopyThread
index|[
literal|10
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|copies
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|copies
index|[
name|i
index|]
operator|=
operator|new
name|CopyThread
argument_list|(
name|input
operator|.
name|clone
argument_list|()
argument_list|,
name|d
operator|.
name|createOutput
argument_list|(
literal|"copy"
operator|+
name|i
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|copies
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|copies
index|[
name|i
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|copies
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|copies
index|[
name|i
index|]
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|copies
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|IndexInput
name|copiedData
init|=
name|d
operator|.
name|openInput
argument_list|(
literal|"copy"
operator|+
name|i
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
name|byte
index|[]
name|dataCopy
init|=
operator|new
name|byte
index|[
name|datalen
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|dataCopy
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|// copy the header for easy testing
name|copiedData
operator|.
name|readBytes
argument_list|(
name|dataCopy
argument_list|,
literal|100
argument_list|,
name|datalen
operator|-
literal|100
argument_list|)
expr_stmt|;
name|assertArrayEquals
argument_list|(
name|data
argument_list|,
name|dataCopy
argument_list|)
expr_stmt|;
name|copiedData
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|d
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|class|CopyThread
specifier|static
class|class
name|CopyThread
extends|extends
name|Thread
block|{
DECL|field|src
specifier|final
name|IndexInput
name|src
decl_stmt|;
DECL|field|dst
specifier|final
name|IndexOutput
name|dst
decl_stmt|;
DECL|method|CopyThread
name|CopyThread
parameter_list|(
name|IndexInput
name|src
parameter_list|,
name|IndexOutput
name|dst
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|dst
operator|.
name|copyBytes
argument_list|(
name|src
argument_list|,
name|src
operator|.
name|length
argument_list|()
operator|-
literal|100
argument_list|)
expr_stmt|;
name|dst
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
block|}
comment|// this test backdoors the directory via the filesystem. so it must actually use the filesystem
comment|// TODO: somehow change this test to
DECL|method|testFsyncDoesntCreateNewFiles
specifier|public
name|void
name|testFsyncDoesntCreateNewFiles
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|path
init|=
name|createTempDir
argument_list|(
literal|"nocreate"
argument_list|)
decl_stmt|;
name|Directory
name|fsdir
init|=
name|getDirectory
argument_list|(
name|path
argument_list|)
decl_stmt|;
comment|// this test backdoors the directory via the filesystem. so it must be an FSDir (for now)
comment|// TODO: figure a way to test this better/clean it up. E.g. we should be testing for FileSwitchDir,
comment|// if its using two FSdirs and so on
if|if
condition|(
name|fsdir
operator|instanceof
name|FSDirectory
operator|==
literal|false
condition|)
block|{
name|fsdir
operator|.
name|close
argument_list|()
expr_stmt|;
name|assumeTrue
argument_list|(
literal|"test only works for FSDirectory subclasses"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// write a file
name|IndexOutput
name|out
init|=
name|fsdir
operator|.
name|createOutput
argument_list|(
literal|"afile"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|out
operator|.
name|writeString
argument_list|(
literal|"boo"
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// delete it
name|Files
operator|.
name|delete
argument_list|(
name|path
operator|.
name|resolve
argument_list|(
literal|"afile"
argument_list|)
argument_list|)
expr_stmt|;
comment|// directory is empty
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fsdir
operator|.
name|listAll
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// fsync it
try|try
block|{
name|fsdir
operator|.
name|sync
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
literal|"afile"
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"didn't get expected exception, instead fsync created new files: "
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|fsdir
operator|.
name|listAll
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
decl||
name|NoSuchFileException
name|expected
parameter_list|)
block|{
comment|// ok
block|}
comment|// directory is still empty
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fsdir
operator|.
name|listAll
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|fsdir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// random access APIs
DECL|method|testRandomLong
specifier|public
name|void
name|testRandomLong
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testLongs"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"longs"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|num
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|50
argument_list|,
literal|3000
argument_list|)
decl_stmt|;
name|long
name|longs
index|[]
init|=
operator|new
name|long
index|[
name|num
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|longs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|longs
index|[
name|i
index|]
operator|=
name|TestUtil
operator|.
name|nextLong
argument_list|(
name|random
argument_list|()
argument_list|,
name|Long
operator|.
name|MIN_VALUE
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeLong
argument_list|(
name|longs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// slice
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"longs"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RandomAccessInput
name|slice
init|=
name|input
operator|.
name|randomAccessSlice
argument_list|(
literal|0
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|longs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|longs
index|[
name|i
index|]
argument_list|,
name|slice
operator|.
name|readLong
argument_list|(
name|i
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// subslices
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|longs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|long
name|offset
init|=
name|i
operator|*
literal|8
decl_stmt|;
name|RandomAccessInput
name|subslice
init|=
name|input
operator|.
name|randomAccessSlice
argument_list|(
name|offset
argument_list|,
name|input
operator|.
name|length
argument_list|()
operator|-
name|offset
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<
name|longs
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|longs
index|[
name|j
index|]
argument_list|,
name|subslice
operator|.
name|readLong
argument_list|(
operator|(
name|j
operator|-
name|i
operator|)
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// with padding
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
literal|"longs-"
operator|+
name|i
decl_stmt|;
name|IndexOutput
name|o
init|=
name|dir
operator|.
name|createOutput
argument_list|(
name|name
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|byte
name|junk
index|[]
init|=
operator|new
name|byte
index|[
name|i
index|]
decl_stmt|;
name|random
argument_list|()
operator|.
name|nextBytes
argument_list|(
name|junk
argument_list|)
expr_stmt|;
name|o
operator|.
name|writeBytes
argument_list|(
name|junk
argument_list|,
name|junk
operator|.
name|length
argument_list|)
expr_stmt|;
name|input
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|.
name|copyBytes
argument_list|(
name|input
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|o
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|padded
init|=
name|dir
operator|.
name|openInput
argument_list|(
name|name
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RandomAccessInput
name|whole
init|=
name|padded
operator|.
name|randomAccessSlice
argument_list|(
name|i
argument_list|,
name|padded
operator|.
name|length
argument_list|()
operator|-
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|longs
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|longs
index|[
name|j
index|]
argument_list|,
name|whole
operator|.
name|readLong
argument_list|(
name|j
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|padded
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testRandomInt
specifier|public
name|void
name|testRandomInt
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testInts"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"ints"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|num
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|50
argument_list|,
literal|3000
argument_list|)
decl_stmt|;
name|int
name|ints
index|[]
init|=
operator|new
name|int
index|[
name|num
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ints
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ints
index|[
name|i
index|]
operator|=
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
expr_stmt|;
name|output
operator|.
name|writeInt
argument_list|(
name|ints
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// slice
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"ints"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RandomAccessInput
name|slice
init|=
name|input
operator|.
name|randomAccessSlice
argument_list|(
literal|0
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ints
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|ints
index|[
name|i
index|]
argument_list|,
name|slice
operator|.
name|readInt
argument_list|(
name|i
operator|*
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// subslices
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ints
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|long
name|offset
init|=
name|i
operator|*
literal|4
decl_stmt|;
name|RandomAccessInput
name|subslice
init|=
name|input
operator|.
name|randomAccessSlice
argument_list|(
name|offset
argument_list|,
name|input
operator|.
name|length
argument_list|()
operator|-
name|offset
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<
name|ints
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|ints
index|[
name|j
index|]
argument_list|,
name|subslice
operator|.
name|readInt
argument_list|(
operator|(
name|j
operator|-
name|i
operator|)
operator|*
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// with padding
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
literal|"ints-"
operator|+
name|i
decl_stmt|;
name|IndexOutput
name|o
init|=
name|dir
operator|.
name|createOutput
argument_list|(
name|name
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|byte
name|junk
index|[]
init|=
operator|new
name|byte
index|[
name|i
index|]
decl_stmt|;
name|random
argument_list|()
operator|.
name|nextBytes
argument_list|(
name|junk
argument_list|)
expr_stmt|;
name|o
operator|.
name|writeBytes
argument_list|(
name|junk
argument_list|,
name|junk
operator|.
name|length
argument_list|)
expr_stmt|;
name|input
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|.
name|copyBytes
argument_list|(
name|input
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|o
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|padded
init|=
name|dir
operator|.
name|openInput
argument_list|(
name|name
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RandomAccessInput
name|whole
init|=
name|padded
operator|.
name|randomAccessSlice
argument_list|(
name|i
argument_list|,
name|padded
operator|.
name|length
argument_list|()
operator|-
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|ints
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|ints
index|[
name|j
index|]
argument_list|,
name|whole
operator|.
name|readInt
argument_list|(
name|j
operator|*
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|padded
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testRandomShort
specifier|public
name|void
name|testRandomShort
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testShorts"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"shorts"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|num
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|50
argument_list|,
literal|3000
argument_list|)
decl_stmt|;
name|short
name|shorts
index|[]
init|=
operator|new
name|short
index|[
name|num
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|shorts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|shorts
index|[
name|i
index|]
operator|=
operator|(
name|short
operator|)
name|random
argument_list|()
operator|.
name|nextInt
argument_list|()
expr_stmt|;
name|output
operator|.
name|writeShort
argument_list|(
name|shorts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// slice
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"shorts"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RandomAccessInput
name|slice
init|=
name|input
operator|.
name|randomAccessSlice
argument_list|(
literal|0
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|shorts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|shorts
index|[
name|i
index|]
argument_list|,
name|slice
operator|.
name|readShort
argument_list|(
name|i
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// subslices
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|shorts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|long
name|offset
init|=
name|i
operator|*
literal|2
decl_stmt|;
name|RandomAccessInput
name|subslice
init|=
name|input
operator|.
name|randomAccessSlice
argument_list|(
name|offset
argument_list|,
name|input
operator|.
name|length
argument_list|()
operator|-
name|offset
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<
name|shorts
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|shorts
index|[
name|j
index|]
argument_list|,
name|subslice
operator|.
name|readShort
argument_list|(
operator|(
name|j
operator|-
name|i
operator|)
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// with padding
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
literal|"shorts-"
operator|+
name|i
decl_stmt|;
name|IndexOutput
name|o
init|=
name|dir
operator|.
name|createOutput
argument_list|(
name|name
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|byte
name|junk
index|[]
init|=
operator|new
name|byte
index|[
name|i
index|]
decl_stmt|;
name|random
argument_list|()
operator|.
name|nextBytes
argument_list|(
name|junk
argument_list|)
expr_stmt|;
name|o
operator|.
name|writeBytes
argument_list|(
name|junk
argument_list|,
name|junk
operator|.
name|length
argument_list|)
expr_stmt|;
name|input
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|.
name|copyBytes
argument_list|(
name|input
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|o
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|padded
init|=
name|dir
operator|.
name|openInput
argument_list|(
name|name
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RandomAccessInput
name|whole
init|=
name|padded
operator|.
name|randomAccessSlice
argument_list|(
name|i
argument_list|,
name|padded
operator|.
name|length
argument_list|()
operator|-
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|shorts
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|shorts
index|[
name|j
index|]
argument_list|,
name|whole
operator|.
name|readShort
argument_list|(
name|j
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|padded
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|testRandomByte
specifier|public
name|void
name|testRandomByte
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"testBytes"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"bytes"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|num
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|50
argument_list|,
literal|3000
argument_list|)
decl_stmt|;
name|byte
name|bytes
index|[]
init|=
operator|new
name|byte
index|[
name|num
index|]
decl_stmt|;
name|random
argument_list|()
operator|.
name|nextBytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|output
operator|.
name|writeByte
argument_list|(
name|bytes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// slice
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"bytes"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RandomAccessInput
name|slice
init|=
name|input
operator|.
name|randomAccessSlice
argument_list|(
literal|0
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|bytes
index|[
name|i
index|]
argument_list|,
name|slice
operator|.
name|readByte
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// subslices
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|bytes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|long
name|offset
init|=
name|i
decl_stmt|;
name|RandomAccessInput
name|subslice
init|=
name|input
operator|.
name|randomAccessSlice
argument_list|(
name|offset
argument_list|,
name|input
operator|.
name|length
argument_list|()
operator|-
name|offset
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<
name|bytes
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|bytes
index|[
name|j
index|]
argument_list|,
name|subslice
operator|.
name|readByte
argument_list|(
name|j
operator|-
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// with padding
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
literal|"bytes-"
operator|+
name|i
decl_stmt|;
name|IndexOutput
name|o
init|=
name|dir
operator|.
name|createOutput
argument_list|(
name|name
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|byte
name|junk
index|[]
init|=
operator|new
name|byte
index|[
name|i
index|]
decl_stmt|;
name|random
argument_list|()
operator|.
name|nextBytes
argument_list|(
name|junk
argument_list|)
expr_stmt|;
name|o
operator|.
name|writeBytes
argument_list|(
name|junk
argument_list|,
name|junk
operator|.
name|length
argument_list|)
expr_stmt|;
name|input
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|.
name|copyBytes
argument_list|(
name|input
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|o
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|padded
init|=
name|dir
operator|.
name|openInput
argument_list|(
name|name
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RandomAccessInput
name|whole
init|=
name|padded
operator|.
name|randomAccessSlice
argument_list|(
name|i
argument_list|,
name|padded
operator|.
name|length
argument_list|()
operator|-
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|bytes
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|bytes
index|[
name|j
index|]
argument_list|,
name|whole
operator|.
name|readByte
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|padded
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** try to stress slices of slices */
DECL|method|testSliceOfSlice
specifier|public
name|void
name|testSliceOfSlice
parameter_list|()
throws|throws
name|Exception
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"sliceOfSlice"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|output
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"bytes"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|num
init|=
name|TestUtil
operator|.
name|nextInt
argument_list|(
name|random
argument_list|()
argument_list|,
literal|50
argument_list|,
literal|2500
argument_list|)
decl_stmt|;
name|byte
name|bytes
index|[]
init|=
operator|new
name|byte
index|[
name|num
index|]
decl_stmt|;
name|random
argument_list|()
operator|.
name|nextBytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|output
operator|.
name|writeByte
argument_list|(
name|bytes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|IndexInput
name|input
init|=
name|dir
operator|.
name|openInput
argument_list|(
literal|"bytes"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// seek to a random spot shouldnt impact slicing.
name|input
operator|.
name|seek
argument_list|(
name|TestUtil
operator|.
name|nextLong
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
name|input
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|IndexInput
name|slice1
init|=
name|input
operator|.
name|slice
argument_list|(
literal|"slice1"
argument_list|,
name|i
argument_list|,
name|num
operator|-
name|i
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|slice1
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|num
operator|-
name|i
argument_list|,
name|slice1
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|// seek to a random spot shouldnt impact slicing.
name|slice1
operator|.
name|seek
argument_list|(
name|TestUtil
operator|.
name|nextLong
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
name|slice1
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|slice1
operator|.
name|length
argument_list|()
condition|;
name|j
operator|+=
literal|16
control|)
block|{
name|IndexInput
name|slice2
init|=
name|slice1
operator|.
name|slice
argument_list|(
literal|"slice2"
argument_list|,
name|j
argument_list|,
name|num
operator|-
name|i
operator|-
name|j
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|slice2
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|num
operator|-
name|i
operator|-
name|j
argument_list|,
name|slice2
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|byte
name|data
index|[]
init|=
operator|new
name|byte
index|[
name|num
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|i
operator|+
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
comment|// read the bytes for this slice-of-slice
name|slice2
operator|.
name|readBytes
argument_list|(
name|data
argument_list|,
name|i
operator|+
name|j
argument_list|,
name|num
operator|-
name|i
operator|-
name|j
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// seek to a random spot in between, read some, seek back and read the rest
name|long
name|seek
init|=
name|TestUtil
operator|.
name|nextLong
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0
argument_list|,
name|slice2
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|slice2
operator|.
name|seek
argument_list|(
name|seek
argument_list|)
expr_stmt|;
name|slice2
operator|.
name|readBytes
argument_list|(
name|data
argument_list|,
call|(
name|int
call|)
argument_list|(
name|i
operator|+
name|j
operator|+
name|seek
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|num
operator|-
name|i
operator|-
name|j
operator|-
name|seek
argument_list|)
argument_list|)
expr_stmt|;
name|slice2
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|slice2
operator|.
name|readBytes
argument_list|(
name|data
argument_list|,
name|i
operator|+
name|j
argument_list|,
operator|(
name|int
operator|)
name|seek
argument_list|)
expr_stmt|;
block|}
name|assertArrayEquals
argument_list|(
name|bytes
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**     * This test that writes larger than the size of the buffer output    * will correctly increment the file pointer.    */
DECL|method|testLargeWrites
specifier|public
name|void
name|testLargeWrites
parameter_list|()
throws|throws
name|IOException
block|{
name|Directory
name|dir
init|=
name|getDirectory
argument_list|(
name|createTempDir
argument_list|(
literal|"largeWrites"
argument_list|)
argument_list|)
decl_stmt|;
name|IndexOutput
name|os
init|=
name|dir
operator|.
name|createOutput
argument_list|(
literal|"testBufferStart.txt"
argument_list|,
name|newIOContext
argument_list|(
name|random
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|largeBuf
init|=
operator|new
name|byte
index|[
literal|2048
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|largeBuf
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|largeBuf
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|Math
operator|.
name|random
argument_list|()
operator|*
literal|256
argument_list|)
expr_stmt|;
block|}
name|long
name|currentPos
init|=
name|os
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
name|os
operator|.
name|writeBytes
argument_list|(
name|largeBuf
argument_list|,
name|largeBuf
operator|.
name|length
argument_list|)
expr_stmt|;
try|try
block|{
name|assertEquals
argument_list|(
name|currentPos
operator|+
name|largeBuf
operator|.
name|length
argument_list|,
name|os
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
end_class
end_unit
