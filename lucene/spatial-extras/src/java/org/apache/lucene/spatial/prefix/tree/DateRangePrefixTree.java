begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.spatial.prefix.tree
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|prefix
operator|.
name|tree
package|;
end_package
begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|time
operator|.
name|ZonedDateTime
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|GregorianCalendar
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import
begin_import
import|import
name|org
operator|.
name|locationtech
operator|.
name|spatial4j
operator|.
name|shape
operator|.
name|Shape
import|;
end_import
begin_comment
comment|/**  * A PrefixTree for date ranges in which the levels of the tree occur at natural periods of time (e.g. years,  * months, ...). You pass in {@link Calendar} objects with the desired fields set and the unspecified  * fields unset, which conveys the precision.  The implementation makes some optimization assumptions about a  * {@link java.util.GregorianCalendar}; others could probably be supported easily.  *<p>  * Warning: If you construct a Calendar and then get something from the object like a field (e.g. year) or  * milliseconds, then every field is fully set by side-effect. So after setting the fields, pass it to this  * API first.  * @lucene.experimental  */
end_comment
begin_class
DECL|class|DateRangePrefixTree
specifier|public
class|class
name|DateRangePrefixTree
extends|extends
name|NumberRangePrefixTree
block|{
comment|/*     WARNING  java.util.Calendar is tricky to work with:     * If you "get" any field value, every field becomes "set". This can introduce a Heisenbug effect,         when in a debugger in some cases. Fortunately, Calendar.toString() doesn't apply.     * Beware Calendar underflow of the underlying long.  If you create a Calendar from LONG.MIN_VALUE, and clear      a field, it will underflow and appear close to LONG.MAX_VALUE (BC to AD).      There are no doubt other reasons but those two were hard fought lessons here.      TODO Improvements:     * Make max precision configurable (i.e. to SECOND).     * Make min& max year span configurable. Use that to remove pointless top levels of the SPT.         If year span is> 10k, then add 1k year level. If year span is> 10k of 1k levels, add 1M level.     * NumberRangePrefixTree: override getTreeCellIterator for optimized case where the shape isn't a date span; use       FilterCellIterator of the cell stack.    */
DECL|field|UTC
specifier|private
specifier|static
specifier|final
name|TimeZone
name|UTC
init|=
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"UTC"
argument_list|)
decl_stmt|;
comment|/**    * The Java platform default {@link Calendar} with UTC&amp; ROOT Locale.  Generally a {@link GregorianCalendar}.    * Do<em>not</em> modify this!    */
DECL|field|DEFAULT_CAL
specifier|public
specifier|static
specifier|final
name|Calendar
name|DEFAULT_CAL
decl_stmt|;
comment|//template
static|static
block|{
name|DEFAULT_CAL
operator|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|UTC
argument_list|,
name|Locale
operator|.
name|ROOT
argument_list|)
expr_stmt|;
name|DEFAULT_CAL
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * A Calendar instance compatible with {@link java.time.ZonedDateTime} as seen from    * {@link GregorianCalendar#from(ZonedDateTime)}.    * Do<em>not</em> modify this!    */
DECL|field|JAVA_UTIL_TIME_COMPAT_CAL
specifier|public
specifier|static
specifier|final
name|Calendar
name|JAVA_UTIL_TIME_COMPAT_CAL
decl_stmt|;
static|static
block|{
comment|// see source of GregorianCalendar.from(ZonedDateTime)
name|GregorianCalendar
name|cal
init|=
operator|new
name|GregorianCalendar
argument_list|(
name|UTC
argument_list|,
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
name|cal
operator|.
name|setGregorianChange
argument_list|(
operator|new
name|Date
argument_list|(
name|Long
operator|.
name|MIN_VALUE
argument_list|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|setFirstDayOfWeek
argument_list|(
name|Calendar
operator|.
name|MONDAY
argument_list|)
expr_stmt|;
comment|// might not matter?
name|cal
operator|.
name|setMinimalDaysInFirstWeek
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|// might not matter
name|cal
operator|.
name|clear
argument_list|()
expr_stmt|;
name|JAVA_UTIL_TIME_COMPAT_CAL
operator|=
name|cal
expr_stmt|;
block|}
DECL|field|FIELD_BY_LEVEL
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|FIELD_BY_LEVEL
init|=
block|{
operator|-
literal|1
comment|/*unused*/
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|Calendar
operator|.
name|YEAR
block|,
name|Calendar
operator|.
name|MONTH
block|,
name|Calendar
operator|.
name|DAY_OF_MONTH
block|,
name|Calendar
operator|.
name|HOUR_OF_DAY
block|,
name|Calendar
operator|.
name|MINUTE
block|,
name|Calendar
operator|.
name|SECOND
block|,
name|Calendar
operator|.
name|MILLISECOND
block|}
decl_stmt|;
DECL|field|YEAR_LEVEL
specifier|private
specifier|static
specifier|final
name|int
name|YEAR_LEVEL
init|=
literal|3
decl_stmt|;
comment|//how many million years are there?
DECL|field|NUM_MYEARS
specifier|private
specifier|static
specifier|final
name|int
name|NUM_MYEARS
init|=
literal|585
decl_stmt|;
comment|// we assert how this was computed in the constructor
comment|/** An instanced based on {@link Calendar#getInstance(TimeZone, Locale)} with UTC and Locale.Root. This    * will (always?) be a {@link GregorianCalendar} with a so-called "Gregorian Change Date" of 1582.    */
annotation|@
name|Deprecated
DECL|field|INSTANCE
specifier|public
specifier|static
specifier|final
name|DateRangePrefixTree
name|INSTANCE
init|=
operator|new
name|DateRangePrefixTree
argument_list|(
name|DEFAULT_CAL
argument_list|)
decl_stmt|;
comment|// Instance fields: (all are final)
DECL|field|CAL_TMP
specifier|private
specifier|final
name|Calendar
name|CAL_TMP
decl_stmt|;
comment|//template
DECL|field|MINCAL
specifier|private
specifier|final
name|Calendar
name|MINCAL
decl_stmt|;
DECL|field|MAXCAL
specifier|private
specifier|final
name|Calendar
name|MAXCAL
decl_stmt|;
DECL|field|BC_FIRSTYEAR
specifier|private
specifier|final
name|int
name|BC_FIRSTYEAR
decl_stmt|;
DECL|field|BC_LASTYEAR
specifier|private
specifier|final
name|int
name|BC_LASTYEAR
decl_stmt|;
DECL|field|BC_YEARS
specifier|private
specifier|final
name|int
name|BC_YEARS
decl_stmt|;
DECL|field|AD_FIRSTYEAR
specifier|private
specifier|final
name|int
name|AD_FIRSTYEAR
decl_stmt|;
DECL|field|AD_LASTYEAR
specifier|private
specifier|final
name|int
name|AD_LASTYEAR
decl_stmt|;
DECL|field|AD_YEAR_BASE
specifier|private
specifier|final
name|int
name|AD_YEAR_BASE
decl_stmt|;
DECL|field|minLV
DECL|field|maxLV
specifier|private
specifier|final
name|UnitNRShape
name|minLV
decl_stmt|,
name|maxLV
decl_stmt|;
DECL|field|gregorianChangeDateLV
specifier|private
specifier|final
name|UnitNRShape
name|gregorianChangeDateLV
decl_stmt|;
comment|/** Constructs with the specified calendar used as a template to be cloned whenever a new    * Calendar needs to be created.  See {@link #DEFAULT_CAL} and {@link #JAVA_UTIL_TIME_COMPAT_CAL}. */
DECL|method|DateRangePrefixTree
specifier|public
name|DateRangePrefixTree
parameter_list|(
name|Calendar
name|templateCal
parameter_list|)
block|{
name|super
argument_list|(
operator|new
name|int
index|[]
block|{
comment|//sublevels by level
name|NUM_MYEARS
block|,
literal|1000
block|,
comment|//1 thousand thousand-years in a million years
literal|1000
block|,
comment|//1 thousand years in a thousand-year
name|calFieldLen
argument_list|(
name|templateCal
argument_list|,
name|Calendar
operator|.
name|MONTH
argument_list|)
block|,
name|calFieldLen
argument_list|(
name|templateCal
argument_list|,
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|)
block|,
name|calFieldLen
argument_list|(
name|templateCal
argument_list|,
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|)
block|,
name|calFieldLen
argument_list|(
name|templateCal
argument_list|,
name|Calendar
operator|.
name|MINUTE
argument_list|)
block|,
name|calFieldLen
argument_list|(
name|templateCal
argument_list|,
name|Calendar
operator|.
name|SECOND
argument_list|)
block|,
name|calFieldLen
argument_list|(
name|templateCal
argument_list|,
name|Calendar
operator|.
name|MILLISECOND
argument_list|)
block|,     }
argument_list|)
expr_stmt|;
name|CAL_TMP
operator|=
operator|(
name|Calendar
operator|)
name|templateCal
operator|.
name|clone
argument_list|()
expr_stmt|;
comment|// defensive copy
name|MINCAL
operator|=
operator|(
name|Calendar
operator|)
name|CAL_TMP
operator|.
name|clone
argument_list|()
expr_stmt|;
name|MINCAL
operator|.
name|setTimeInMillis
argument_list|(
name|Long
operator|.
name|MIN_VALUE
argument_list|)
expr_stmt|;
name|MAXCAL
operator|=
operator|(
name|Calendar
operator|)
name|CAL_TMP
operator|.
name|clone
argument_list|()
expr_stmt|;
name|MAXCAL
operator|.
name|setTimeInMillis
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
comment|//BC years are decreasing, remember.  Yet ActualMaximum is the numerically high value, ActualMinimum is 1.
name|BC_FIRSTYEAR
operator|=
name|MINCAL
operator|.
name|getActualMaximum
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
expr_stmt|;
name|BC_LASTYEAR
operator|=
name|MINCAL
operator|.
name|getActualMinimum
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
expr_stmt|;
comment|// 1
name|BC_YEARS
operator|=
name|BC_FIRSTYEAR
operator|-
name|BC_LASTYEAR
operator|+
literal|1
expr_stmt|;
name|AD_FIRSTYEAR
operator|=
name|MAXCAL
operator|.
name|getActualMinimum
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
expr_stmt|;
comment|// 1
name|AD_LASTYEAR
operator|=
name|MAXCAL
operator|.
name|getActualMaximum
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
expr_stmt|;
name|AD_YEAR_BASE
operator|=
operator|(
operator|(
operator|(
name|BC_YEARS
operator|-
literal|1
operator|)
operator|/
literal|1000_000
operator|)
operator|+
literal|1
operator|)
operator|*
literal|1000_000
expr_stmt|;
assert|assert
name|BC_LASTYEAR
operator|==
literal|1
operator|&&
name|AD_FIRSTYEAR
operator|==
literal|1
assert|;
assert|assert
name|NUM_MYEARS
operator|==
operator|(
name|AD_YEAR_BASE
operator|+
name|AD_LASTYEAR
operator|)
operator|/
literal|1000_000
assert|;
name|maxLV
operator|=
name|toShape
argument_list|(
operator|(
name|Calendar
operator|)
name|MAXCAL
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
name|minLV
operator|=
name|toShape
argument_list|(
operator|(
name|Calendar
operator|)
name|MINCAL
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAXCAL
operator|instanceof
name|GregorianCalendar
condition|)
block|{
name|GregorianCalendar
name|gCal
init|=
operator|(
name|GregorianCalendar
operator|)
name|MAXCAL
decl_stmt|;
name|gregorianChangeDateLV
operator|=
name|toUnitShape
argument_list|(
name|gCal
operator|.
name|getGregorianChange
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gregorianChangeDateLV
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|calFieldLen
specifier|private
specifier|static
name|int
name|calFieldLen
parameter_list|(
name|Calendar
name|cal
parameter_list|,
name|int
name|field
parameter_list|)
block|{
return|return
name|cal
operator|.
name|getMaximum
argument_list|(
name|field
argument_list|)
operator|-
name|cal
operator|.
name|getMinimum
argument_list|(
name|field
argument_list|)
operator|+
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|getNumSubCells
specifier|public
name|int
name|getNumSubCells
parameter_list|(
name|UnitNRShape
name|lv
parameter_list|)
block|{
name|int
name|cmp
init|=
name|comparePrefix
argument_list|(
name|lv
argument_list|,
name|maxLV
argument_list|)
decl_stmt|;
assert|assert
name|cmp
operator|<=
literal|0
assert|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
comment|//edge case (literally!)
return|return
name|maxLV
operator|.
name|getValAtLevel
argument_list|(
name|lv
operator|.
name|getLevel
argument_list|()
operator|+
literal|1
argument_list|)
return|;
comment|// if using GregorianCalendar and we're after the "Gregorian change date" then we'll compute
comment|//  the sub-cells ourselves more efficiently without the need to construct a Calendar.
name|cmp
operator|=
name|gregorianChangeDateLV
operator|!=
literal|null
condition|?
name|comparePrefix
argument_list|(
name|lv
argument_list|,
name|gregorianChangeDateLV
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
comment|//TODO consider also doing fast-path if field is<= hours even if before greg change date
if|if
condition|(
name|cmp
operator|>=
literal|0
condition|)
block|{
name|int
name|result
init|=
name|fastSubCells
argument_list|(
name|lv
argument_list|)
decl_stmt|;
assert|assert
name|result
operator|==
name|slowSubCells
argument_list|(
name|lv
argument_list|)
operator|:
literal|"fast/slow numSubCells inconsistency"
assert|;
return|return
name|result
return|;
block|}
else|else
block|{
return|return
name|slowSubCells
argument_list|(
name|lv
argument_list|)
return|;
block|}
block|}
DECL|method|fastSubCells
specifier|private
name|int
name|fastSubCells
parameter_list|(
name|UnitNRShape
name|lv
parameter_list|)
block|{
if|if
condition|(
name|lv
operator|.
name|getLevel
argument_list|()
operator|==
name|YEAR_LEVEL
operator|+
literal|1
condition|)
block|{
comment|//month
switch|switch
condition|(
name|lv
operator|.
name|getValAtLevel
argument_list|(
name|lv
operator|.
name|getLevel
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|Calendar
operator|.
name|SEPTEMBER
case|:
case|case
name|Calendar
operator|.
name|APRIL
case|:
case|case
name|Calendar
operator|.
name|JUNE
case|:
case|case
name|Calendar
operator|.
name|NOVEMBER
case|:
return|return
literal|30
return|;
case|case
name|Calendar
operator|.
name|FEBRUARY
case|:
comment|//get the year (negative numbers for BC)
name|int
name|yearAdj
init|=
name|lv
operator|.
name|getValAtLevel
argument_list|(
literal|1
argument_list|)
operator|*
literal|1_000_000
decl_stmt|;
name|yearAdj
operator|+=
name|lv
operator|.
name|getValAtLevel
argument_list|(
literal|2
argument_list|)
operator|*
literal|1000
expr_stmt|;
name|yearAdj
operator|+=
name|lv
operator|.
name|getValAtLevel
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|int
name|year
init|=
name|yearAdj
operator|-
name|AD_YEAR_BASE
decl_stmt|;
if|if
condition|(
name|year
operator|%
literal|4
operator|==
literal|0
operator|&&
operator|!
operator|(
name|year
operator|%
literal|100
operator|==
literal|0
operator|&&
name|year
operator|%
literal|400
operator|!=
literal|0
operator|)
condition|)
comment|//leap year
return|return
literal|29
return|;
else|else
return|return
literal|28
return|;
default|default:
return|return
literal|31
return|;
block|}
block|}
else|else
block|{
comment|//typical:
return|return
name|super
operator|.
name|getNumSubCells
argument_list|(
name|lv
argument_list|)
return|;
block|}
block|}
DECL|method|slowSubCells
specifier|private
name|int
name|slowSubCells
parameter_list|(
name|UnitNRShape
name|lv
parameter_list|)
block|{
name|int
name|field
init|=
name|FIELD_BY_LEVEL
index|[
name|lv
operator|.
name|getLevel
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
comment|//short-circuit optimization (GregorianCalendar assumptions)
if|if
condition|(
name|field
operator|==
operator|-
literal|1
operator|||
name|field
operator|==
name|Calendar
operator|.
name|YEAR
operator|||
name|field
operator|>=
name|Calendar
operator|.
name|HOUR_OF_DAY
condition|)
comment|//TODO make configurable
return|return
name|super
operator|.
name|getNumSubCells
argument_list|(
name|lv
argument_list|)
return|;
name|Calendar
name|cal
init|=
name|toCalendar
argument_list|(
name|lv
argument_list|)
decl_stmt|;
comment|//somewhat heavyweight op; ideally should be stored on UnitNRShape somehow
return|return
name|cal
operator|.
name|getActualMaximum
argument_list|(
name|field
argument_list|)
operator|-
name|cal
operator|.
name|getActualMinimum
argument_list|(
name|field
argument_list|)
operator|+
literal|1
return|;
block|}
comment|/** Calendar utility method:    * Returns a clone of the {@link Calendar} passed to the constructor with all fields cleared. */
DECL|method|newCal
specifier|public
name|Calendar
name|newCal
parameter_list|()
block|{
return|return
operator|(
name|Calendar
operator|)
name|CAL_TMP
operator|.
name|clone
argument_list|()
return|;
block|}
comment|/** Calendar utility method:    * Returns the spatial prefix tree level for the corresponding {@link java.util.Calendar} field, such as    * {@link java.util.Calendar#YEAR}.  If there's no match, the next greatest level is returned as a negative value.    */
DECL|method|getTreeLevelForCalendarField
specifier|public
name|int
name|getTreeLevelForCalendarField
parameter_list|(
name|int
name|calField
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|YEAR_LEVEL
init|;
name|i
operator|<
name|FIELD_BY_LEVEL
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|FIELD_BY_LEVEL
index|[
name|i
index|]
operator|==
name|calField
condition|)
block|{
return|return
name|i
return|;
block|}
elseif|else
if|if
condition|(
name|FIELD_BY_LEVEL
index|[
name|i
index|]
operator|>
name|calField
condition|)
block|{
return|return
operator|-
literal|1
operator|*
name|i
return|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Bad calendar field?: "
operator|+
name|calField
argument_list|)
throw|;
block|}
comment|/** Calendar utility method:    * Gets the Calendar field code of the last field that is set prior to an unset field. It only    * examines fields relevant to the prefix tree. If no fields are set, it returns -1. */
DECL|method|getCalPrecisionField
specifier|public
name|int
name|getCalPrecisionField
parameter_list|(
name|Calendar
name|cal
parameter_list|)
block|{
name|int
name|lastField
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
name|YEAR_LEVEL
init|;
name|level
operator|<
name|FIELD_BY_LEVEL
operator|.
name|length
condition|;
name|level
operator|++
control|)
block|{
name|int
name|field
init|=
name|FIELD_BY_LEVEL
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|cal
operator|.
name|isSet
argument_list|(
name|field
argument_list|)
condition|)
break|break;
name|lastField
operator|=
name|field
expr_stmt|;
block|}
return|return
name|lastField
return|;
block|}
comment|/** Calendar utility method:    * Calls {@link Calendar#clear(int)} for every field after {@code field}. Beware of Calendar underflow. */
DECL|method|clearFieldsAfter
specifier|public
name|void
name|clearFieldsAfter
parameter_list|(
name|Calendar
name|cal
parameter_list|,
name|int
name|field
parameter_list|)
block|{
name|int
name|assertEra
init|=
operator|-
literal|1
decl_stmt|;
assert|assert
operator|(
name|assertEra
operator|=
operator|(
operator|(
operator|(
name|Calendar
operator|)
name|cal
operator|.
name|clone
argument_list|()
operator|)
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|)
operator|)
operator|)
operator|>=
literal|0
assert|;
comment|//a trick to only get this if assert enabled
comment|//note: Calendar.ERA == 0;
for|for
control|(
name|int
name|f
init|=
name|field
operator|+
literal|1
init|;
name|f
operator|<=
name|Calendar
operator|.
name|MILLISECOND
condition|;
name|f
operator|++
control|)
block|{
name|cal
operator|.
name|clear
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
assert|assert
name|field
operator|+
literal|1
operator|==
name|Calendar
operator|.
name|ERA
operator|||
operator|(
operator|(
name|Calendar
operator|)
name|cal
operator|.
name|clone
argument_list|()
operator|)
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|)
operator|==
name|assertEra
operator|:
literal|"Calendar underflow"
assert|;
block|}
comment|/** Converts {@code value} from a {@link Calendar} or {@link Date} to a {@link Shape}. Other arguments    * result in a {@link java.lang.IllegalArgumentException}.    * If a Calendar is passed in, there might be problems if it is not created via {@link #newCal()}.    */
annotation|@
name|Override
DECL|method|toUnitShape
specifier|public
name|UnitNRShape
name|toUnitShape
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Calendar
condition|)
block|{
return|return
name|toShape
argument_list|(
operator|(
name|Calendar
operator|)
name|value
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Date
condition|)
block|{
name|Calendar
name|cal
init|=
name|newCal
argument_list|()
decl_stmt|;
name|cal
operator|.
name|setTime
argument_list|(
operator|(
name|Date
operator|)
name|value
argument_list|)
expr_stmt|;
return|return
name|toShape
argument_list|(
name|cal
argument_list|)
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting Calendar or Date but got: "
operator|+
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
comment|/** Converts the Calendar into a Shape.    * The isSet() state of the Calendar is re-instated when done.    * If a Calendar is passed in, there might be problems if it is not created via {@link #newCal()}.    */
DECL|method|toShape
specifier|public
name|UnitNRShape
name|toShape
parameter_list|(
name|Calendar
name|cal
parameter_list|)
block|{
comment|// Convert a Calendar into a stack of cell numbers
specifier|final
name|int
name|calPrecField
init|=
name|getCalPrecisionField
argument_list|(
name|cal
argument_list|)
decl_stmt|;
comment|//must call first; getters set all fields
try|try
block|{
name|int
index|[]
name|valStack
init|=
operator|new
name|int
index|[
name|maxLevels
index|]
decl_stmt|;
comment|//starts at level 1, not 0
name|int
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|calPrecField
operator|>=
name|Calendar
operator|.
name|YEAR
condition|)
block|{
comment|//year or better precision
name|int
name|year
init|=
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
decl_stmt|;
name|int
name|yearAdj
init|=
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|)
operator|==
literal|0
condition|?
name|AD_YEAR_BASE
operator|-
operator|(
name|year
operator|-
literal|1
operator|)
else|:
name|AD_YEAR_BASE
operator|+
name|year
decl_stmt|;
name|valStack
index|[
name|len
operator|++
index|]
operator|=
name|yearAdj
operator|/
literal|1000_000
expr_stmt|;
name|yearAdj
operator|-=
name|valStack
index|[
name|len
operator|-
literal|1
index|]
operator|*
literal|1000_000
expr_stmt|;
name|valStack
index|[
name|len
operator|++
index|]
operator|=
name|yearAdj
operator|/
literal|1000
expr_stmt|;
name|yearAdj
operator|-=
name|valStack
index|[
name|len
operator|-
literal|1
index|]
operator|*
literal|1000
expr_stmt|;
name|valStack
index|[
name|len
operator|++
index|]
operator|=
name|yearAdj
expr_stmt|;
for|for
control|(
name|int
name|level
init|=
name|YEAR_LEVEL
operator|+
literal|1
init|;
name|level
operator|<
name|FIELD_BY_LEVEL
operator|.
name|length
condition|;
name|level
operator|++
control|)
block|{
name|int
name|field
init|=
name|FIELD_BY_LEVEL
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
name|field
operator|>
name|calPrecField
condition|)
break|break;
name|valStack
index|[
name|len
operator|++
index|]
operator|=
name|cal
operator|.
name|get
argument_list|(
name|field
argument_list|)
operator|-
name|cal
operator|.
name|getActualMinimum
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|toShape
argument_list|(
name|valStack
argument_list|,
name|len
argument_list|)
return|;
block|}
finally|finally
block|{
name|clearFieldsAfter
argument_list|(
name|cal
argument_list|,
name|calPrecField
argument_list|)
expr_stmt|;
comment|//restore precision state modified by get()
block|}
block|}
comment|/** Calls {@link #toCalendar(org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape)}. */
annotation|@
name|Override
DECL|method|toObject
specifier|public
name|Object
name|toObject
parameter_list|(
name|UnitNRShape
name|shape
parameter_list|)
block|{
return|return
name|toCalendar
argument_list|(
name|shape
argument_list|)
return|;
block|}
comment|/** Converts the {@link org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape} shape to a    * corresponding Calendar that is cleared below its level. */
DECL|method|toCalendar
specifier|public
name|Calendar
name|toCalendar
parameter_list|(
name|UnitNRShape
name|lv
parameter_list|)
block|{
if|if
condition|(
name|lv
operator|.
name|getLevel
argument_list|()
operator|==
literal|0
condition|)
return|return
name|newCal
argument_list|()
return|;
if|if
condition|(
name|comparePrefix
argument_list|(
name|lv
argument_list|,
name|minLV
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|//shouldn't typically happen; sometimes in a debugger
return|return
operator|(
name|Calendar
operator|)
name|MINCAL
operator|.
name|clone
argument_list|()
return|;
comment|//full precision; truncation would cause underflow
block|}
assert|assert
name|comparePrefix
argument_list|(
name|lv
argument_list|,
name|maxLV
argument_list|)
operator|<=
literal|0
assert|;
name|Calendar
name|cal
init|=
name|newCal
argument_list|()
decl_stmt|;
name|int
name|yearAdj
init|=
name|lv
operator|.
name|getValAtLevel
argument_list|(
literal|1
argument_list|)
operator|*
literal|1_000_000
decl_stmt|;
if|if
condition|(
name|lv
operator|.
name|getLevel
argument_list|()
operator|>
literal|1
condition|)
block|{
name|yearAdj
operator|+=
name|lv
operator|.
name|getValAtLevel
argument_list|(
literal|2
argument_list|)
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
name|lv
operator|.
name|getLevel
argument_list|()
operator|>
literal|2
condition|)
block|{
name|yearAdj
operator|+=
name|lv
operator|.
name|getValAtLevel
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|yearAdj
operator|>
name|AD_YEAR_BASE
condition|)
block|{
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|,
name|yearAdj
operator|-
name|AD_YEAR_BASE
argument_list|)
expr_stmt|;
comment|//setting the year resets the era
block|}
else|else
block|{
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|//we assert this "sticks" at the end
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|,
operator|(
name|AD_YEAR_BASE
operator|-
name|yearAdj
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|level
init|=
name|YEAR_LEVEL
operator|+
literal|1
init|;
name|level
operator|<=
name|lv
operator|.
name|getLevel
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
name|int
name|field
init|=
name|FIELD_BY_LEVEL
index|[
name|level
index|]
decl_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|field
argument_list|,
name|lv
operator|.
name|getValAtLevel
argument_list|(
name|level
argument_list|)
operator|+
name|cal
operator|.
name|getActualMinimum
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
assert|assert
name|yearAdj
operator|>
name|AD_YEAR_BASE
operator|||
operator|(
operator|(
name|Calendar
operator|)
name|cal
operator|.
name|clone
argument_list|()
operator|)
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|)
operator|==
literal|0
operator|:
literal|"ERA / YEAR underflow"
assert|;
return|return
name|cal
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|protected
name|String
name|toString
parameter_list|(
name|UnitNRShape
name|lv
parameter_list|)
block|{
return|return
name|toString
argument_list|(
name|toCalendar
argument_list|(
name|lv
argument_list|)
argument_list|)
return|;
block|}
comment|/** Calendar utility method consistent with {@link java.time.format.DateTimeFormatter#ISO_INSTANT} except    * has no trailing 'Z', and will be truncated to the units given according to    * {@link Calendar#isSet(int)}.    * A fully cleared calendar will yield the string "*".    * The isSet() state of the Calendar is re-instated when done. */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|(
name|Calendar
name|cal
parameter_list|)
block|{
specifier|final
name|int
name|calPrecField
init|=
name|getCalPrecisionField
argument_list|(
name|cal
argument_list|)
decl_stmt|;
comment|//must call first; getters set all fields
if|if
condition|(
name|calPrecField
operator|==
operator|-
literal|1
condition|)
return|return
literal|"*"
return|;
try|try
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"yyyy-MM-dd'T'HH:mm:ss.SSS"
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
comment|//typical
name|int
name|year
init|=
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
decl_stmt|;
comment|// within the era (thus always positve).>= 1.
if|if
condition|(
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// BC
name|year
operator|-=
literal|1
expr_stmt|;
comment|// 1BC should be "0000", so shift by one
if|if
condition|(
name|year
operator|>
literal|0
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|year
operator|>
literal|9999
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
block|}
name|appendPadded
argument_list|(
name|builder
argument_list|,
name|year
argument_list|,
operator|(
name|short
operator|)
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|calPrecField
operator|>=
name|Calendar
operator|.
name|MONTH
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|appendPadded
argument_list|(
name|builder
argument_list|,
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|)
operator|+
literal|1
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
comment|// +1 since first is 0
block|}
if|if
condition|(
name|calPrecField
operator|>=
name|Calendar
operator|.
name|DAY_OF_MONTH
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|appendPadded
argument_list|(
name|builder
argument_list|,
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|)
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|calPrecField
operator|>=
name|Calendar
operator|.
name|HOUR_OF_DAY
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
name|appendPadded
argument_list|(
name|builder
argument_list|,
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|)
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|calPrecField
operator|>=
name|Calendar
operator|.
name|MINUTE
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|appendPadded
argument_list|(
name|builder
argument_list|,
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|)
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|calPrecField
operator|>=
name|Calendar
operator|.
name|SECOND
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|appendPadded
argument_list|(
name|builder
argument_list|,
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|SECOND
argument_list|)
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|calPrecField
operator|>=
name|Calendar
operator|.
name|MILLISECOND
operator|&&
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MILLISECOND
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|// only if non-zero
name|builder
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|appendPadded
argument_list|(
name|builder
argument_list|,
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MILLISECOND
argument_list|)
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
finally|finally
block|{
name|clearFieldsAfter
argument_list|(
name|cal
argument_list|,
name|calPrecField
argument_list|)
expr_stmt|;
comment|//restore precision state modified by get()
block|}
block|}
DECL|method|appendPadded
specifier|private
name|void
name|appendPadded
parameter_list|(
name|StringBuilder
name|builder
parameter_list|,
name|int
name|integer
parameter_list|,
name|short
name|positions
parameter_list|)
block|{
assert|assert
name|integer
operator|>=
literal|0
operator|&&
name|positions
operator|>=
literal|1
operator|&&
name|positions
operator|<=
literal|4
assert|;
name|int
name|preBuilderLen
init|=
name|builder
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|intStrLen
decl_stmt|;
if|if
condition|(
name|integer
operator|>
literal|999
condition|)
block|{
name|intStrLen
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer
operator|>
literal|99
condition|)
block|{
name|intStrLen
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer
operator|>
literal|9
condition|)
block|{
name|intStrLen
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|intStrLen
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|positions
operator|-
name|intStrLen
condition|;
name|i
operator|++
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
name|integer
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|parseUnitShape
specifier|protected
name|UnitNRShape
name|parseUnitShape
parameter_list|(
name|String
name|str
parameter_list|)
throws|throws
name|ParseException
block|{
return|return
name|toShape
argument_list|(
name|parseCalendar
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
block|}
comment|/** Calendar utility method:    * The reverse of {@link #toString(java.util.Calendar)}. It will only set the fields found, leaving    * the remainder in an un-set state. A leading '-' or '+' is optional (positive assumed), and a    * trailing 'Z' is also optional.    * @param str not null and not empty    * @return not null    */
DECL|method|parseCalendar
specifier|public
name|Calendar
name|parseCalendar
parameter_list|(
name|String
name|str
parameter_list|)
throws|throws
name|ParseException
block|{
comment|// example: +2014-10-23T21:22:33.159Z
if|if
condition|(
name|str
operator|==
literal|null
operator|||
name|str
operator|.
name|isEmpty
argument_list|()
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"str is null or blank"
argument_list|)
throw|;
name|Calendar
name|cal
init|=
name|newCal
argument_list|()
decl_stmt|;
if|if
condition|(
name|str
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
condition|)
return|return
name|cal
return|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|//a pointer
try|try
block|{
comment|//year& era:
name|int
name|lastOffset
init|=
name|str
operator|.
name|charAt
argument_list|(
name|str
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'Z'
condition|?
name|str
operator|.
name|length
argument_list|()
operator|-
literal|1
else|:
name|str
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|hyphenIdx
init|=
name|str
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|//look past possible leading hyphen
if|if
condition|(
name|hyphenIdx
operator|<
literal|0
condition|)
name|hyphenIdx
operator|=
name|lastOffset
expr_stmt|;
name|int
name|year
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|offset
argument_list|,
name|hyphenIdx
argument_list|)
argument_list|)
decl_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|,
name|year
operator|<=
literal|0
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|,
name|year
operator|<=
literal|0
condition|?
operator|-
literal|1
operator|*
name|year
operator|+
literal|1
else|:
name|year
argument_list|)
expr_stmt|;
name|offset
operator|=
name|hyphenIdx
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lastOffset
operator|<
name|offset
condition|)
return|return
name|cal
return|;
comment|//NOTE: We aren't validating separator chars, and we unintentionally accept leading +/-.
comment|// The str.substring()'s hopefully get optimized to be stack-allocated.
comment|//month:
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//starts at 0
name|offset
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|lastOffset
operator|<
name|offset
condition|)
return|return
name|cal
return|;
comment|//day:
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|lastOffset
operator|<
name|offset
condition|)
return|return
name|cal
return|;
comment|//hour:
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|lastOffset
operator|<
name|offset
condition|)
return|return
name|cal
return|;
comment|//minute:
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|lastOffset
operator|<
name|offset
condition|)
return|return
name|cal
return|;
comment|//second:
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|SECOND
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|lastOffset
operator|<
name|offset
condition|)
return|return
name|cal
return|;
comment|//ms:
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MILLISECOND
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|3
expr_stmt|;
comment|//last one, move to next char
if|if
condition|(
name|lastOffset
operator|==
name|offset
condition|)
return|return
name|cal
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|ParseException
name|pe
init|=
operator|new
name|ParseException
argument_list|(
literal|"Improperly formatted date: "
operator|+
name|str
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|pe
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|pe
throw|;
block|}
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Improperly formatted date: "
operator|+
name|str
argument_list|,
name|offset
argument_list|)
throw|;
block|}
block|}
end_class
end_unit
