begin_unit
begin_package
DECL|package|org.apache.lucene.validation.ivyde
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|validation
operator|.
name|ivyde
package|;
end_package
begin_comment
comment|/*  *  Licensed to the Apache Software Foundation (ASF) under one or more  *  contributor license agreements.  See the NOTICE file distributed with  *  this work for additional information regarding copyright ownership.  *  The ASF licenses this file to You under the Apache License, Version 2.0  *  (the "License"); you may not use this file except in compliance with  *  the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|module
operator|.
name|id
operator|.
name|ModuleId
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|module
operator|.
name|id
operator|.
name|ModuleRevisionId
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|report
operator|.
name|ResolveReport
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|resolve
operator|.
name|IvyNode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|resolve
operator|.
name|IvyNodeCallers
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_comment
comment|/**  * This class is copied from org/apache/ivyde/eclipse/resolvevisualizer/model/IvyNodeElementAdapter.java at   * https://svn.apache.org/repos/asf/ant/ivy/ivyde/trunk/org.apache.ivyde.eclipse.resolvevisualizer/src/  *   * Changes include: uncommenting generics and converting to diamond operators where appropriate;  * removing unnecessary casts; and removing javadoc tags with no description.  */
end_comment
begin_class
DECL|class|IvyNodeElementAdapter
specifier|public
class|class
name|IvyNodeElementAdapter
block|{
comment|/**    * Adapt all dependencies and evictions from the ResolveReport.    * @return the root node adapted from the ResolveReport    */
DECL|method|adapt
specifier|public
specifier|static
name|IvyNodeElement
name|adapt
parameter_list|(
name|ResolveReport
name|report
parameter_list|)
block|{
name|Map
argument_list|<
name|ModuleRevisionId
argument_list|,
name|IvyNodeElement
argument_list|>
name|resolvedNodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|IvyNodeElement
name|root
init|=
operator|new
name|IvyNodeElement
argument_list|()
decl_stmt|;
name|root
operator|.
name|setModuleRevisionId
argument_list|(
name|report
operator|.
name|getModuleDescriptor
argument_list|()
operator|.
name|getModuleRevisionId
argument_list|()
argument_list|)
expr_stmt|;
name|resolvedNodes
operator|.
name|put
argument_list|(
name|report
operator|.
name|getModuleDescriptor
argument_list|()
operator|.
name|getModuleRevisionId
argument_list|()
argument_list|,
name|root
argument_list|)
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|IvyNode
argument_list|>
name|dependencies
init|=
name|report
operator|.
name|getDependencies
argument_list|()
decl_stmt|;
comment|// First pass - build the map of resolved nodes by revision id
for|for
control|(
name|Iterator
argument_list|<
name|IvyNode
argument_list|>
name|iter
init|=
name|dependencies
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|IvyNode
name|node
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getAllEvictingNodes
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// Nodes that are evicted as a result of conf inheritance still appear
comment|// as dependencies, but with eviction data. They also appear as evictions.
comment|// We map them as evictions rather than dependencies.
continue|continue;
block|}
name|IvyNodeElement
name|nodeElement
init|=
operator|new
name|IvyNodeElement
argument_list|()
decl_stmt|;
name|nodeElement
operator|.
name|setModuleRevisionId
argument_list|(
name|node
operator|.
name|getResolvedId
argument_list|()
argument_list|)
expr_stmt|;
name|resolvedNodes
operator|.
name|put
argument_list|(
name|node
operator|.
name|getResolvedId
argument_list|()
argument_list|,
name|nodeElement
argument_list|)
expr_stmt|;
block|}
comment|// Second pass - establish relationships between the resolved nodes
for|for
control|(
name|Iterator
argument_list|<
name|IvyNode
argument_list|>
name|iter
init|=
name|dependencies
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|IvyNode
name|node
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getAllEvictingNodes
argument_list|()
operator|!=
literal|null
condition|)
block|{
continue|continue;
comment|// see note above
block|}
name|IvyNodeElement
name|nodeElement
init|=
name|resolvedNodes
operator|.
name|get
argument_list|(
name|node
operator|.
name|getResolvedId
argument_list|()
argument_list|)
decl_stmt|;
name|IvyNodeCallers
operator|.
name|Caller
index|[]
name|callers
init|=
name|node
operator|.
name|getAllRealCallers
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|callers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|IvyNodeElement
name|caller
init|=
name|resolvedNodes
operator|.
name|get
argument_list|(
name|callers
index|[
name|i
index|]
operator|.
name|getModuleRevisionId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|caller
operator|!=
literal|null
condition|)
block|{
name|nodeElement
operator|.
name|addCaller
argument_list|(
name|caller
argument_list|)
expr_stmt|;
name|nodeElement
operator|.
name|setCallerConfigurations
argument_list|(
name|caller
argument_list|,
name|callers
index|[
name|i
index|]
operator|.
name|getCallerConfigurations
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|IvyNode
index|[]
name|evictions
init|=
name|report
operator|.
name|getEvictedNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|evictions
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|IvyNode
name|eviction
init|=
name|evictions
index|[
name|i
index|]
decl_stmt|;
name|IvyNodeElement
name|evictionElement
init|=
operator|new
name|IvyNodeElement
argument_list|()
decl_stmt|;
name|evictionElement
operator|.
name|setModuleRevisionId
argument_list|(
name|eviction
operator|.
name|getResolvedId
argument_list|()
argument_list|)
expr_stmt|;
name|evictionElement
operator|.
name|setEvicted
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|IvyNodeCallers
operator|.
name|Caller
index|[]
name|callers
init|=
name|eviction
operator|.
name|getAllCallers
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|callers
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|IvyNodeElement
name|caller
init|=
name|resolvedNodes
operator|.
name|get
argument_list|(
name|callers
index|[
name|j
index|]
operator|.
name|getModuleRevisionId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|caller
operator|!=
literal|null
condition|)
block|{
name|evictionElement
operator|.
name|addCaller
argument_list|(
name|caller
argument_list|)
expr_stmt|;
name|evictionElement
operator|.
name|setCallerConfigurations
argument_list|(
name|caller
argument_list|,
name|callers
index|[
name|j
index|]
operator|.
name|getCallerConfigurations
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Recursively set depth starting at root
name|root
operator|.
name|setDepth
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|findConflictsBeneathNode
argument_list|(
name|root
argument_list|)
expr_stmt|;
return|return
name|root
return|;
block|}
comment|/**    * Derives configuration conflicts that exist between node and all of its descendant dependencies.    */
DECL|method|findConflictsBeneathNode
specifier|private
specifier|static
name|void
name|findConflictsBeneathNode
parameter_list|(
name|IvyNodeElement
name|node
parameter_list|)
block|{
comment|// Derive conflicts
name|Map
argument_list|<
name|ModuleId
argument_list|,
name|Collection
argument_list|<
name|IvyNodeElement
argument_list|>
argument_list|>
name|moduleRevisionMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|IvyNodeElement
index|[]
name|deepDependencies
init|=
name|node
operator|.
name|getDeepDependencies
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|deepDependencies
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|deepDependencies
index|[
name|i
index|]
operator|.
name|isEvicted
argument_list|()
condition|)
continue|continue;
name|ModuleId
name|moduleId
init|=
name|deepDependencies
index|[
name|i
index|]
operator|.
name|getModuleRevisionId
argument_list|()
operator|.
name|getModuleId
argument_list|()
decl_stmt|;
if|if
condition|(
name|moduleRevisionMap
operator|.
name|containsKey
argument_list|(
name|moduleId
argument_list|)
condition|)
block|{
name|Collection
argument_list|<
name|IvyNodeElement
argument_list|>
name|conflicts
init|=
name|moduleRevisionMap
operator|.
name|get
argument_list|(
name|moduleId
argument_list|)
decl_stmt|;
name|conflicts
operator|.
name|add
argument_list|(
name|deepDependencies
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|IvyNodeElement
argument_list|>
name|iter
init|=
name|conflicts
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|IvyNodeElement
name|conflict
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|conflict
operator|.
name|setConflicts
argument_list|(
name|conflicts
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|List
argument_list|<
name|IvyNodeElement
argument_list|>
name|immutableMatchingSet
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|deepDependencies
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|moduleRevisionMap
operator|.
name|put
argument_list|(
name|moduleId
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|immutableMatchingSet
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class
end_unit
