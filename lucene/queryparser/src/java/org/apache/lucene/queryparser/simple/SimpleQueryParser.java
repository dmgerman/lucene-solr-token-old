begin_unit
begin_package
DECL|package|org.apache.lucene.queryparser.simple
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queryparser
operator|.
name|simple
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BoostQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FuzzyQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|MatchAllDocsQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|MatchNoDocsQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|PrefixQuery
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|QueryBuilder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|LevenshteinAutomata
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_comment
comment|/**  * SimpleQueryParser is used to parse human readable query syntax.  *<p>  * The main idea behind this parser is that a person should be able to type  * whatever they want to represent a query, and this parser will do its best  * to interpret what to search for no matter how poorly composed the request  * may be. Tokens are considered to be any of a term, phrase, or subquery for the  * operations described below.  Whitespace including ' ' '\n' '\r' and '\t'  * and certain operators may be used to delimit tokens ( ) + | " .  *<p>  * Any errors in query syntax will be ignored and the parser will attempt  * to decipher what it can; however, this may mean odd or unexpected results.  *<p>  *<b>Query Operators</b>  *<ul>  *<li>'{@code +}' specifies {@code AND} operation:<tt>token1+token2</tt>  *<li>'{@code |}' specifies {@code OR} operation:<tt>token1|token2</tt>  *<li>'{@code -}' negates a single token:<tt>-token0</tt>  *<li>'{@code "}' creates phrases of terms:<tt>"term1 term2 ..."</tt>  *<li>'{@code *}' at the end of terms specifies prefix query:<tt>term*</tt>  *<li>'{@code ~}N' at the end of terms specifies fuzzy query:<tt>term~1</tt>  *<li>'{@code ~}N' at the end of phrases specifies near query:<tt>"term1 term2"~5</tt>  *<li>'{@code (}' and '{@code )}' specifies precedence:<tt>token1 + (token2 | token3)</tt>  *</ul>  *<p>  * The {@link #setDefaultOperator default operator} is {@code OR} if no other operator is specified.  * For example, the following will {@code OR} {@code token1} and {@code token2} together:  *<tt>token1 token2</tt>  *<p>  * Normal operator precedence will be simple order from right to left.  * For example, the following will evaluate {@code token1 OR token2} first,  * then {@code AND} with {@code token3}:  *<blockquote>token1 | token2 + token3</blockquote>  *<b>Escaping</b>  *<p>  * An individual term may contain any possible character with certain characters  * requiring escaping using a '{@code \}'.  The following characters will need to be escaped in  * terms and phrases:  * {@code + | " ( ) ' \}  *<p>  * The '{@code -}' operator is a special case.  On individual terms (not phrases) the first  * character of a term that is {@code -} must be escaped; however, any '{@code -}' characters  * beyond the first character do not need to be escaped.  * For example:  *<ul>  *<li>{@code -term1}   -- Specifies {@code NOT} operation against {@code term1}  *<li>{@code \-term1}  -- Searches for the term {@code -term1}.  *<li>{@code term-1}   -- Searches for the term {@code term-1}.  *<li>{@code term\-1}  -- Searches for the term {@code term-1}.  *</ul>  *<p>  * The '{@code *}' operator is a special case. On individual terms (not phrases) the last  * character of a term that is '{@code *}' must be escaped; however, any '{@code *}' characters  * before the last character do not need to be escaped:  *<ul>  *<li>{@code term1*}  --  Searches for the prefix {@code term1}  *<li>{@code term1\*} --  Searches for the term {@code term1*}  *<li>{@code term*1}  --  Searches for the term {@code term*1}  *<li>{@code term\*1} --  Searches for the term {@code term*1}  *</ul>  *<p>  * Note that above examples consider the terms before text processing.  */
end_comment
begin_class
DECL|class|SimpleQueryParser
specifier|public
class|class
name|SimpleQueryParser
extends|extends
name|QueryBuilder
block|{
comment|/** Map of fields to query against with their weights */
DECL|field|weights
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|weights
decl_stmt|;
comment|/** flags to the parser (to turn features on/off) */
DECL|field|flags
specifier|protected
specifier|final
name|int
name|flags
decl_stmt|;
comment|/** Enables {@code AND} operator (+) */
DECL|field|AND_OPERATOR
specifier|public
specifier|static
specifier|final
name|int
name|AND_OPERATOR
init|=
literal|1
operator|<<
literal|0
decl_stmt|;
comment|/** Enables {@code NOT} operator (-) */
DECL|field|NOT_OPERATOR
specifier|public
specifier|static
specifier|final
name|int
name|NOT_OPERATOR
init|=
literal|1
operator|<<
literal|1
decl_stmt|;
comment|/** Enables {@code OR} operator (|) */
DECL|field|OR_OPERATOR
specifier|public
specifier|static
specifier|final
name|int
name|OR_OPERATOR
init|=
literal|1
operator|<<
literal|2
decl_stmt|;
comment|/** Enables {@code PREFIX} operator (*) */
DECL|field|PREFIX_OPERATOR
specifier|public
specifier|static
specifier|final
name|int
name|PREFIX_OPERATOR
init|=
literal|1
operator|<<
literal|3
decl_stmt|;
comment|/** Enables {@code PHRASE} operator (") */
DECL|field|PHRASE_OPERATOR
specifier|public
specifier|static
specifier|final
name|int
name|PHRASE_OPERATOR
init|=
literal|1
operator|<<
literal|4
decl_stmt|;
comment|/** Enables {@code PRECEDENCE} operators: {@code (} and {@code )} */
DECL|field|PRECEDENCE_OPERATORS
specifier|public
specifier|static
specifier|final
name|int
name|PRECEDENCE_OPERATORS
init|=
literal|1
operator|<<
literal|5
decl_stmt|;
comment|/** Enables {@code ESCAPE} operator (\) */
DECL|field|ESCAPE_OPERATOR
specifier|public
specifier|static
specifier|final
name|int
name|ESCAPE_OPERATOR
init|=
literal|1
operator|<<
literal|6
decl_stmt|;
comment|/** Enables {@code WHITESPACE} operators: ' ' '\n' '\r' '\t' */
DECL|field|WHITESPACE_OPERATOR
specifier|public
specifier|static
specifier|final
name|int
name|WHITESPACE_OPERATOR
init|=
literal|1
operator|<<
literal|7
decl_stmt|;
comment|/** Enables {@code FUZZY} operators: (~) on single terms */
DECL|field|FUZZY_OPERATOR
specifier|public
specifier|static
specifier|final
name|int
name|FUZZY_OPERATOR
init|=
literal|1
operator|<<
literal|8
decl_stmt|;
comment|/** Enables {@code NEAR} operators: (~) on phrases */
DECL|field|NEAR_OPERATOR
specifier|public
specifier|static
specifier|final
name|int
name|NEAR_OPERATOR
init|=
literal|1
operator|<<
literal|9
decl_stmt|;
DECL|field|defaultOperator
specifier|private
name|BooleanClause
operator|.
name|Occur
name|defaultOperator
init|=
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
decl_stmt|;
comment|/** Creates a new parser searching over a single field. */
DECL|method|SimpleQueryParser
specifier|public
name|SimpleQueryParser
parameter_list|(
name|Analyzer
name|analyzer
parameter_list|,
name|String
name|field
parameter_list|)
block|{
name|this
argument_list|(
name|analyzer
argument_list|,
name|Collections
operator|.
name|singletonMap
argument_list|(
name|field
argument_list|,
literal|1.0F
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a new parser searching over multiple fields with different weights. */
DECL|method|SimpleQueryParser
specifier|public
name|SimpleQueryParser
parameter_list|(
name|Analyzer
name|analyzer
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|weights
parameter_list|)
block|{
name|this
argument_list|(
name|analyzer
argument_list|,
name|weights
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a new parser with custom flags used to enable/disable certain features. */
DECL|method|SimpleQueryParser
specifier|public
name|SimpleQueryParser
parameter_list|(
name|Analyzer
name|analyzer
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|weights
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|super
argument_list|(
name|analyzer
argument_list|)
expr_stmt|;
name|this
operator|.
name|weights
operator|=
name|weights
expr_stmt|;
name|this
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
block|}
comment|/** Parses the query text and returns parsed query */
DECL|method|parse
specifier|public
name|Query
name|parse
parameter_list|(
name|String
name|queryText
parameter_list|)
block|{
name|char
name|data
index|[]
init|=
name|queryText
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|char
name|buffer
index|[]
init|=
operator|new
name|char
index|[
name|data
operator|.
name|length
index|]
decl_stmt|;
name|State
name|state
init|=
operator|new
name|State
argument_list|(
name|data
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|)
decl_stmt|;
name|parseSubQuery
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|top
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|MatchNoDocsQuery
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|state
operator|.
name|top
return|;
block|}
block|}
DECL|method|parseSubQuery
specifier|private
name|void
name|parseSubQuery
parameter_list|(
name|State
name|state
parameter_list|)
block|{
while|while
condition|(
name|state
operator|.
name|index
operator|<
name|state
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'('
operator|&&
operator|(
name|flags
operator|&
name|PRECEDENCE_OPERATORS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// the beginning of a subquery has been found
name|consumeSubQuery
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|')'
operator|&&
operator|(
name|flags
operator|&
name|PRECEDENCE_OPERATORS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// this is an extraneous character so it is ignored
operator|++
name|state
operator|.
name|index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'"'
operator|&&
operator|(
name|flags
operator|&
name|PHRASE_OPERATOR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// the beginning of a phrase has been found
name|consumePhrase
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'+'
operator|&&
operator|(
name|flags
operator|&
name|AND_OPERATOR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// an and operation has been explicitly set
comment|// if an operation has already been set this one is ignored
comment|// if a term (or phrase or subquery) has not been found yet the
comment|// operation is also ignored since there is no previous
comment|// term (or phrase or subquery) to and with
if|if
condition|(
name|state
operator|.
name|currentOperation
operator|==
literal|null
operator|&&
name|state
operator|.
name|top
operator|!=
literal|null
condition|)
block|{
name|state
operator|.
name|currentOperation
operator|=
name|BooleanClause
operator|.
name|Occur
operator|.
name|MUST
expr_stmt|;
block|}
operator|++
name|state
operator|.
name|index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'|'
operator|&&
operator|(
name|flags
operator|&
name|OR_OPERATOR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// an or operation has been explicitly set
comment|// if an operation has already been set this one is ignored
comment|// if a term (or phrase or subquery) has not been found yet the
comment|// operation is also ignored since there is no previous
comment|// term (or phrase or subquery) to or with
if|if
condition|(
name|state
operator|.
name|currentOperation
operator|==
literal|null
operator|&&
name|state
operator|.
name|top
operator|!=
literal|null
condition|)
block|{
name|state
operator|.
name|currentOperation
operator|=
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
expr_stmt|;
block|}
operator|++
name|state
operator|.
name|index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'-'
operator|&&
operator|(
name|flags
operator|&
name|NOT_OPERATOR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// a not operator has been found, so increase the not count
comment|// two not operators in a row negate each other
operator|++
name|state
operator|.
name|not
expr_stmt|;
operator|++
name|state
operator|.
name|index
expr_stmt|;
comment|// continue so the not operator is not reset
comment|// before the next character is determined
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|' '
operator|||
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'\t'
operator|||
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'\n'
operator|||
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'\r'
operator|)
operator|&&
operator|(
name|flags
operator|&
name|WHITESPACE_OPERATOR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// ignore any whitespace found as it may have already been
comment|// used a delimiter across a term (or phrase or subquery)
comment|// or is simply extraneous
operator|++
name|state
operator|.
name|index
expr_stmt|;
block|}
else|else
block|{
comment|// the beginning of a token has been found
name|consumeToken
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
comment|// reset the not operator as even whitespace is not allowed when
comment|// specifying the not operation for a term (or phrase or subquery)
name|state
operator|.
name|not
operator|=
literal|0
expr_stmt|;
block|}
block|}
DECL|method|consumeSubQuery
specifier|private
name|void
name|consumeSubQuery
parameter_list|(
name|State
name|state
parameter_list|)
block|{
assert|assert
operator|(
name|flags
operator|&
name|PRECEDENCE_OPERATORS
operator|)
operator|!=
literal|0
assert|;
name|int
name|start
init|=
operator|++
name|state
operator|.
name|index
decl_stmt|;
name|int
name|precedence
init|=
literal|1
decl_stmt|;
name|boolean
name|escaped
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|state
operator|.
name|index
operator|<
name|state
operator|.
name|length
condition|)
block|{
if|if
condition|(
operator|!
name|escaped
condition|)
block|{
if|if
condition|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'\\'
operator|&&
operator|(
name|flags
operator|&
name|ESCAPE_OPERATOR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// an escape character has been found so
comment|// whatever character is next will become
comment|// part of the subquery unless the escape
comment|// character is the last one in the data
name|escaped
operator|=
literal|true
expr_stmt|;
operator|++
name|state
operator|.
name|index
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'('
condition|)
block|{
comment|// increase the precedence as there is a
comment|// subquery in the current subquery
operator|++
name|precedence
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|')'
condition|)
block|{
operator|--
name|precedence
expr_stmt|;
if|if
condition|(
name|precedence
operator|==
literal|0
condition|)
block|{
comment|// this should be the end of the subquery
comment|// all characters found will used for
comment|// creating the subquery
break|break;
block|}
block|}
block|}
name|escaped
operator|=
literal|false
expr_stmt|;
operator|++
name|state
operator|.
name|index
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|.
name|index
operator|==
name|state
operator|.
name|length
condition|)
block|{
comment|// a closing parenthesis was never found so the opening
comment|// parenthesis is considered extraneous and will be ignored
name|state
operator|.
name|index
operator|=
name|start
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|.
name|index
operator|==
name|start
condition|)
block|{
comment|// a closing parenthesis was found immediately after the opening
comment|// parenthesis so the current operation is reset since it would
comment|// have been applied to this subquery
name|state
operator|.
name|currentOperation
operator|=
literal|null
expr_stmt|;
operator|++
name|state
operator|.
name|index
expr_stmt|;
block|}
else|else
block|{
comment|// a complete subquery has been found and is recursively parsed by
comment|// starting over with a new state object
name|State
name|subState
init|=
operator|new
name|State
argument_list|(
name|state
operator|.
name|data
argument_list|,
name|state
operator|.
name|buffer
argument_list|,
name|start
argument_list|,
name|state
operator|.
name|index
argument_list|)
decl_stmt|;
name|parseSubQuery
argument_list|(
name|subState
argument_list|)
expr_stmt|;
name|buildQueryTree
argument_list|(
name|state
argument_list|,
name|subState
operator|.
name|top
argument_list|)
expr_stmt|;
operator|++
name|state
operator|.
name|index
expr_stmt|;
block|}
block|}
DECL|method|consumePhrase
specifier|private
name|void
name|consumePhrase
parameter_list|(
name|State
name|state
parameter_list|)
block|{
assert|assert
operator|(
name|flags
operator|&
name|PHRASE_OPERATOR
operator|)
operator|!=
literal|0
assert|;
name|int
name|start
init|=
operator|++
name|state
operator|.
name|index
decl_stmt|;
name|int
name|copied
init|=
literal|0
decl_stmt|;
name|boolean
name|escaped
init|=
literal|false
decl_stmt|;
name|boolean
name|hasSlop
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|state
operator|.
name|index
operator|<
name|state
operator|.
name|length
condition|)
block|{
if|if
condition|(
operator|!
name|escaped
condition|)
block|{
if|if
condition|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'\\'
operator|&&
operator|(
name|flags
operator|&
name|ESCAPE_OPERATOR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// an escape character has been found so
comment|// whatever character is next will become
comment|// part of the phrase unless the escape
comment|// character is the last one in the data
name|escaped
operator|=
literal|true
expr_stmt|;
operator|++
name|state
operator|.
name|index
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'"'
condition|)
block|{
comment|// if there are still characters after the closing ", check for a
comment|// tilde
if|if
condition|(
name|state
operator|.
name|length
operator|>
operator|(
name|state
operator|.
name|index
operator|+
literal|1
operator|)
operator|&&
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
operator|+
literal|1
index|]
operator|==
literal|'~'
operator|&&
operator|(
name|flags
operator|&
name|NEAR_OPERATOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|state
operator|.
name|index
operator|++
expr_stmt|;
comment|// check for characters after the tilde
if|if
condition|(
name|state
operator|.
name|length
operator|>
operator|(
name|state
operator|.
name|index
operator|+
literal|1
operator|)
condition|)
block|{
name|hasSlop
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|// this should be the end of the phrase
comment|// all characters found will used for
comment|// creating the phrase query
break|break;
block|}
block|}
block|}
name|escaped
operator|=
literal|false
expr_stmt|;
name|state
operator|.
name|buffer
index|[
name|copied
operator|++
index|]
operator|=
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
operator|++
index|]
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|.
name|index
operator|==
name|state
operator|.
name|length
condition|)
block|{
comment|// a closing double quote was never found so the opening
comment|// double quote is considered extraneous and will be ignored
name|state
operator|.
name|index
operator|=
name|start
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|.
name|index
operator|==
name|start
condition|)
block|{
comment|// a closing double quote was found immediately after the opening
comment|// double quote so the current operation is reset since it would
comment|// have been applied to this phrase
name|state
operator|.
name|currentOperation
operator|=
literal|null
expr_stmt|;
operator|++
name|state
operator|.
name|index
expr_stmt|;
block|}
else|else
block|{
comment|// a complete phrase has been found and is parsed through
comment|// through the analyzer from the given field
name|String
name|phrase
init|=
operator|new
name|String
argument_list|(
name|state
operator|.
name|buffer
argument_list|,
literal|0
argument_list|,
name|copied
argument_list|)
decl_stmt|;
name|Query
name|branch
decl_stmt|;
if|if
condition|(
name|hasSlop
condition|)
block|{
name|branch
operator|=
name|newPhraseQuery
argument_list|(
name|phrase
argument_list|,
name|parseFuzziness
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|branch
operator|=
name|newPhraseQuery
argument_list|(
name|phrase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|buildQueryTree
argument_list|(
name|state
argument_list|,
name|branch
argument_list|)
expr_stmt|;
operator|++
name|state
operator|.
name|index
expr_stmt|;
block|}
block|}
DECL|method|consumeToken
specifier|private
name|void
name|consumeToken
parameter_list|(
name|State
name|state
parameter_list|)
block|{
name|int
name|copied
init|=
literal|0
decl_stmt|;
name|boolean
name|escaped
init|=
literal|false
decl_stmt|;
name|boolean
name|prefix
init|=
literal|false
decl_stmt|;
name|boolean
name|fuzzy
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|state
operator|.
name|index
operator|<
name|state
operator|.
name|length
condition|)
block|{
if|if
condition|(
operator|!
name|escaped
condition|)
block|{
if|if
condition|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'\\'
operator|&&
operator|(
name|flags
operator|&
name|ESCAPE_OPERATOR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// an escape character has been found so
comment|// whatever character is next will become
comment|// part of the term unless the escape
comment|// character is the last one in the data
name|escaped
operator|=
literal|true
expr_stmt|;
name|prefix
operator|=
literal|false
expr_stmt|;
operator|++
name|state
operator|.
name|index
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|tokenFinished
argument_list|(
name|state
argument_list|)
condition|)
block|{
comment|// this should be the end of the term
comment|// all characters found will used for
comment|// creating the term query
break|break;
block|}
elseif|else
if|if
condition|(
name|copied
operator|>
literal|0
operator|&&
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'~'
operator|&&
operator|(
name|flags
operator|&
name|FUZZY_OPERATOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|fuzzy
operator|=
literal|true
expr_stmt|;
break|break;
block|}
comment|// wildcard tracks whether or not the last character
comment|// was a '*' operator that hasn't been escaped
comment|// there must be at least one valid character before
comment|// searching for a prefixed set of terms
name|prefix
operator|=
name|copied
operator|>
literal|0
operator|&&
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'*'
operator|&&
operator|(
name|flags
operator|&
name|PREFIX_OPERATOR
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
name|escaped
operator|=
literal|false
expr_stmt|;
name|state
operator|.
name|buffer
index|[
name|copied
operator|++
index|]
operator|=
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
operator|++
index|]
expr_stmt|;
block|}
if|if
condition|(
name|copied
operator|>
literal|0
condition|)
block|{
specifier|final
name|Query
name|branch
decl_stmt|;
if|if
condition|(
name|fuzzy
operator|&&
operator|(
name|flags
operator|&
name|FUZZY_OPERATOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|String
name|token
init|=
operator|new
name|String
argument_list|(
name|state
operator|.
name|buffer
argument_list|,
literal|0
argument_list|,
name|copied
argument_list|)
decl_stmt|;
name|int
name|fuzziness
init|=
name|parseFuzziness
argument_list|(
name|state
argument_list|)
decl_stmt|;
comment|// edit distance has a maximum, limit to the maximum supported
name|fuzziness
operator|=
name|Math
operator|.
name|min
argument_list|(
name|fuzziness
argument_list|,
name|LevenshteinAutomata
operator|.
name|MAXIMUM_SUPPORTED_DISTANCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuzziness
operator|==
literal|0
condition|)
block|{
name|branch
operator|=
name|newDefaultQuery
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|branch
operator|=
name|newFuzzyQuery
argument_list|(
name|token
argument_list|,
name|fuzziness
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|prefix
condition|)
block|{
comment|// if a term is found with a closing '*' it is considered to be a prefix query
comment|// and will have prefix added as an option
name|String
name|token
init|=
operator|new
name|String
argument_list|(
name|state
operator|.
name|buffer
argument_list|,
literal|0
argument_list|,
name|copied
operator|-
literal|1
argument_list|)
decl_stmt|;
name|branch
operator|=
name|newPrefixQuery
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// a standard term has been found so it will be run through
comment|// the entire analysis chain from the specified schema field
name|String
name|token
init|=
operator|new
name|String
argument_list|(
name|state
operator|.
name|buffer
argument_list|,
literal|0
argument_list|,
name|copied
argument_list|)
decl_stmt|;
name|branch
operator|=
name|newDefaultQuery
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
name|buildQueryTree
argument_list|(
name|state
argument_list|,
name|branch
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addClause
specifier|private
specifier|static
name|BooleanQuery
name|addClause
parameter_list|(
name|BooleanQuery
name|bq
parameter_list|,
name|Query
name|query
parameter_list|,
name|BooleanClause
operator|.
name|Occur
name|occur
parameter_list|)
block|{
name|BooleanQuery
operator|.
name|Builder
name|newBq
init|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|newBq
operator|.
name|setDisableCoord
argument_list|(
name|bq
operator|.
name|isCoordDisabled
argument_list|()
argument_list|)
expr_stmt|;
name|newBq
operator|.
name|setMinimumNumberShouldMatch
argument_list|(
name|bq
operator|.
name|getMinimumNumberShouldMatch
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|BooleanClause
name|clause
range|:
name|bq
control|)
block|{
name|newBq
operator|.
name|add
argument_list|(
name|clause
argument_list|)
expr_stmt|;
block|}
name|newBq
operator|.
name|add
argument_list|(
name|query
argument_list|,
name|occur
argument_list|)
expr_stmt|;
return|return
name|newBq
operator|.
name|build
argument_list|()
return|;
block|}
comment|// buildQueryTree should be called after a term, phrase, or subquery
comment|// is consumed to be added to our existing query tree
comment|// this method will only add to the existing tree if the branch contained in state is not null
DECL|method|buildQueryTree
specifier|private
name|void
name|buildQueryTree
parameter_list|(
name|State
name|state
parameter_list|,
name|Query
name|branch
parameter_list|)
block|{
if|if
condition|(
name|branch
operator|!=
literal|null
condition|)
block|{
comment|// modify our branch to a BooleanQuery wrapper for not
comment|// this is necessary any time a term, phrase, or subquery is negated
if|if
condition|(
name|state
operator|.
name|not
operator|%
literal|2
operator|==
literal|1
condition|)
block|{
name|BooleanQuery
operator|.
name|Builder
name|nq
init|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|nq
operator|.
name|add
argument_list|(
name|branch
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|MUST_NOT
argument_list|)
expr_stmt|;
name|nq
operator|.
name|add
argument_list|(
operator|new
name|MatchAllDocsQuery
argument_list|()
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
name|branch
operator|=
name|nq
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|// first term (or phrase or subquery) found and will begin our query tree
if|if
condition|(
name|state
operator|.
name|top
operator|==
literal|null
condition|)
block|{
name|state
operator|.
name|top
operator|=
name|branch
expr_stmt|;
block|}
else|else
block|{
comment|// more than one term (or phrase or subquery) found
comment|// set currentOperation to the default if no other operation is explicitly set
if|if
condition|(
name|state
operator|.
name|currentOperation
operator|==
literal|null
condition|)
block|{
name|state
operator|.
name|currentOperation
operator|=
name|defaultOperator
expr_stmt|;
block|}
comment|// operational change requiring a new parent node
comment|// this occurs if the previous operation is not the same as current operation
comment|// because the previous operation must be evaluated separately to preserve
comment|// the proper precedence and the current operation will take over as the top of the tree
if|if
condition|(
name|state
operator|.
name|previousOperation
operator|!=
name|state
operator|.
name|currentOperation
condition|)
block|{
name|BooleanQuery
operator|.
name|Builder
name|bq
init|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|bq
operator|.
name|add
argument_list|(
name|state
operator|.
name|top
argument_list|,
name|state
operator|.
name|currentOperation
argument_list|)
expr_stmt|;
name|state
operator|.
name|top
operator|=
name|bq
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|// reset all of the state for reuse
name|state
operator|.
name|top
operator|=
name|addClause
argument_list|(
operator|(
name|BooleanQuery
operator|)
name|state
operator|.
name|top
argument_list|,
name|branch
argument_list|,
name|state
operator|.
name|currentOperation
argument_list|)
expr_stmt|;
name|state
operator|.
name|previousOperation
operator|=
name|state
operator|.
name|currentOperation
expr_stmt|;
block|}
comment|// reset the current operation as it was intended to be applied to
comment|// the incoming term (or phrase or subquery) even if branch was null
comment|// due to other possible errors
name|state
operator|.
name|currentOperation
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Helper parsing fuzziness from parsing state    * @return slop/edit distance, 0 in the case of non-parsing slop/edit string    */
DECL|method|parseFuzziness
specifier|private
name|int
name|parseFuzziness
parameter_list|(
name|State
name|state
parameter_list|)
block|{
name|char
name|slopText
index|[]
init|=
operator|new
name|char
index|[
name|state
operator|.
name|length
index|]
decl_stmt|;
name|int
name|slopLength
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'~'
condition|)
block|{
while|while
condition|(
name|state
operator|.
name|index
operator|<
name|state
operator|.
name|length
condition|)
block|{
name|state
operator|.
name|index
operator|++
expr_stmt|;
comment|// it's possible that the ~ was at the end, so check after incrementing
comment|// to make sure we don't go out of bounds
if|if
condition|(
name|state
operator|.
name|index
operator|<
name|state
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|tokenFinished
argument_list|(
name|state
argument_list|)
condition|)
block|{
break|break;
block|}
name|slopText
index|[
name|slopLength
index|]
operator|=
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
expr_stmt|;
name|slopLength
operator|++
expr_stmt|;
block|}
block|}
name|int
name|fuzziness
init|=
literal|0
decl_stmt|;
try|try
block|{
name|fuzziness
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
operator|new
name|String
argument_list|(
name|slopText
argument_list|,
literal|0
argument_list|,
name|slopLength
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
comment|// swallow number format exceptions parsing fuzziness
block|}
comment|// negative -> 0
if|if
condition|(
name|fuzziness
operator|<
literal|0
condition|)
block|{
name|fuzziness
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|fuzziness
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/**    * Helper returning true if the state has reached the end of token.    */
DECL|method|tokenFinished
specifier|private
name|boolean
name|tokenFinished
parameter_list|(
name|State
name|state
parameter_list|)
block|{
if|if
condition|(
operator|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'"'
operator|&&
operator|(
name|flags
operator|&
name|PHRASE_OPERATOR
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'|'
operator|&&
operator|(
name|flags
operator|&
name|OR_OPERATOR
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'+'
operator|&&
operator|(
name|flags
operator|&
name|AND_OPERATOR
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'('
operator|&&
operator|(
name|flags
operator|&
name|PRECEDENCE_OPERATORS
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|')'
operator|&&
operator|(
name|flags
operator|&
name|PRECEDENCE_OPERATORS
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|' '
operator|||
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'\t'
operator|||
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'\n'
operator|||
name|state
operator|.
name|data
index|[
name|state
operator|.
name|index
index|]
operator|==
literal|'\r'
operator|)
operator|&&
operator|(
name|flags
operator|&
name|WHITESPACE_OPERATOR
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Factory method to generate a standard query (no phrase or prefix operators).    */
DECL|method|newDefaultQuery
specifier|protected
name|Query
name|newDefaultQuery
parameter_list|(
name|String
name|text
parameter_list|)
block|{
name|BooleanQuery
operator|.
name|Builder
name|bq
init|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|bq
operator|.
name|setDisableCoord
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|entry
range|:
name|weights
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Query
name|q
init|=
name|createBooleanQuery
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|text
argument_list|,
name|defaultOperator
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
name|float
name|boost
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|boost
operator|!=
literal|1f
condition|)
block|{
name|q
operator|=
operator|new
name|BoostQuery
argument_list|(
name|q
argument_list|,
name|boost
argument_list|)
expr_stmt|;
block|}
name|bq
operator|.
name|add
argument_list|(
name|q
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|simplify
argument_list|(
name|bq
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Factory method to generate a fuzzy query.    */
DECL|method|newFuzzyQuery
specifier|protected
name|Query
name|newFuzzyQuery
parameter_list|(
name|String
name|text
parameter_list|,
name|int
name|fuzziness
parameter_list|)
block|{
name|BooleanQuery
operator|.
name|Builder
name|bq
init|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|bq
operator|.
name|setDisableCoord
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|entry
range|:
name|weights
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Query
name|q
init|=
operator|new
name|FuzzyQuery
argument_list|(
operator|new
name|Term
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|text
argument_list|)
argument_list|,
name|fuzziness
argument_list|)
decl_stmt|;
name|float
name|boost
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|boost
operator|!=
literal|1f
condition|)
block|{
name|q
operator|=
operator|new
name|BoostQuery
argument_list|(
name|q
argument_list|,
name|boost
argument_list|)
expr_stmt|;
block|}
name|bq
operator|.
name|add
argument_list|(
name|q
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
block|}
return|return
name|simplify
argument_list|(
name|bq
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Factory method to generate a phrase query with slop.    */
DECL|method|newPhraseQuery
specifier|protected
name|Query
name|newPhraseQuery
parameter_list|(
name|String
name|text
parameter_list|,
name|int
name|slop
parameter_list|)
block|{
name|BooleanQuery
operator|.
name|Builder
name|bq
init|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|bq
operator|.
name|setDisableCoord
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|entry
range|:
name|weights
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Query
name|q
init|=
name|createPhraseQuery
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|text
argument_list|,
name|slop
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
name|float
name|boost
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|boost
operator|!=
literal|1f
condition|)
block|{
name|q
operator|=
operator|new
name|BoostQuery
argument_list|(
name|q
argument_list|,
name|boost
argument_list|)
expr_stmt|;
block|}
name|bq
operator|.
name|add
argument_list|(
name|q
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|simplify
argument_list|(
name|bq
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Factory method to generate a prefix query.    */
DECL|method|newPrefixQuery
specifier|protected
name|Query
name|newPrefixQuery
parameter_list|(
name|String
name|text
parameter_list|)
block|{
name|BooleanQuery
operator|.
name|Builder
name|bq
init|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|bq
operator|.
name|setDisableCoord
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|entry
range|:
name|weights
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Query
name|q
init|=
operator|new
name|PrefixQuery
argument_list|(
operator|new
name|Term
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|text
argument_list|)
argument_list|)
decl_stmt|;
name|float
name|boost
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|boost
operator|!=
literal|1f
condition|)
block|{
name|q
operator|=
operator|new
name|BoostQuery
argument_list|(
name|q
argument_list|,
name|boost
argument_list|)
expr_stmt|;
block|}
name|bq
operator|.
name|add
argument_list|(
name|q
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
block|}
return|return
name|simplify
argument_list|(
name|bq
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Helper to simplify boolean queries with 0 or 1 clause    */
DECL|method|simplify
specifier|protected
name|Query
name|simplify
parameter_list|(
name|BooleanQuery
name|bq
parameter_list|)
block|{
if|if
condition|(
name|bq
operator|.
name|clauses
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|bq
operator|.
name|clauses
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|bq
operator|.
name|clauses
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getQuery
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|bq
return|;
block|}
block|}
comment|/**    * Returns the implicit operator setting, which will be    * either {@code SHOULD} or {@code MUST}.    */
DECL|method|getDefaultOperator
specifier|public
name|BooleanClause
operator|.
name|Occur
name|getDefaultOperator
parameter_list|()
block|{
return|return
name|defaultOperator
return|;
block|}
comment|/**    * Sets the implicit operator setting, which must be    * either {@code SHOULD} or {@code MUST}.    */
DECL|method|setDefaultOperator
specifier|public
name|void
name|setDefaultOperator
parameter_list|(
name|BooleanClause
operator|.
name|Occur
name|operator
parameter_list|)
block|{
if|if
condition|(
name|operator
operator|!=
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
operator|&&
name|operator
operator|!=
name|BooleanClause
operator|.
name|Occur
operator|.
name|MUST
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"invalid operator: only SHOULD or MUST are allowed"
argument_list|)
throw|;
block|}
name|this
operator|.
name|defaultOperator
operator|=
name|operator
expr_stmt|;
block|}
DECL|class|State
specifier|static
class|class
name|State
block|{
DECL|field|data
specifier|final
name|char
index|[]
name|data
decl_stmt|;
comment|// the characters in the query string
DECL|field|buffer
specifier|final
name|char
index|[]
name|buffer
decl_stmt|;
comment|// a temporary buffer used to reduce necessary allocations
DECL|field|index
name|int
name|index
decl_stmt|;
DECL|field|length
name|int
name|length
decl_stmt|;
DECL|field|currentOperation
name|BooleanClause
operator|.
name|Occur
name|currentOperation
decl_stmt|;
DECL|field|previousOperation
name|BooleanClause
operator|.
name|Occur
name|previousOperation
decl_stmt|;
DECL|field|not
name|int
name|not
decl_stmt|;
DECL|field|top
name|Query
name|top
decl_stmt|;
DECL|method|State
name|State
parameter_list|(
name|char
index|[]
name|data
parameter_list|,
name|char
index|[]
name|buffer
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|this
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|length
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
