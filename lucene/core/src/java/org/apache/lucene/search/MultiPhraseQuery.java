begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|PostingsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|Similarity
operator|.
name|SimScorer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import
begin_comment
comment|/**  * A generalized version of {@link PhraseQuery}, with the possibility of  * adding more than one term at the same position that are treated as a disjunction (OR).  * To use this class to search for the phrase "Microsoft app*" first create a Builder and use  * {@link Builder#add(Term)} on the term "microsoft" (assuming lowercase analysis), then  * find all terms that have "app" as prefix using {@link LeafReader#terms(String)},  * seeking to "app" then iterating and collecting terms until there is no longer  * that prefix, and finally use {@link Builder#add(Term[])} to add them.  * {@link Builder#build()} returns the fully constructed (and immutable) MultiPhraseQuery.  */
end_comment
begin_class
DECL|class|MultiPhraseQuery
specifier|public
class|class
name|MultiPhraseQuery
extends|extends
name|Query
block|{
comment|/** A builder for multi-phrase queries */
DECL|class|Builder
specifier|public
specifier|static
class|class
name|Builder
block|{
DECL|field|field
specifier|private
name|String
name|field
decl_stmt|;
comment|// becomes non-null on first add() then is unmodified
DECL|field|termArrays
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|Term
index|[]
argument_list|>
name|termArrays
decl_stmt|;
DECL|field|positions
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|positions
decl_stmt|;
DECL|field|slop
specifier|private
name|int
name|slop
decl_stmt|;
comment|/** Default constructor. */
DECL|method|Builder
specifier|public
name|Builder
parameter_list|()
block|{
name|this
operator|.
name|field
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|termArrays
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|positions
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|slop
operator|=
literal|0
expr_stmt|;
block|}
comment|/** Copy constructor: this will create a builder that has the same      *  configuration as the provided builder. */
DECL|method|Builder
specifier|public
name|Builder
parameter_list|(
name|MultiPhraseQuery
name|multiPhraseQuery
parameter_list|)
block|{
name|this
operator|.
name|field
operator|=
name|multiPhraseQuery
operator|.
name|field
expr_stmt|;
name|int
name|length
init|=
name|multiPhraseQuery
operator|.
name|termArrays
operator|.
name|length
decl_stmt|;
name|this
operator|.
name|termArrays
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|this
operator|.
name|positions
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
name|this
operator|.
name|termArrays
operator|.
name|add
argument_list|(
name|multiPhraseQuery
operator|.
name|termArrays
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|this
operator|.
name|positions
operator|.
name|add
argument_list|(
name|multiPhraseQuery
operator|.
name|positions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|slop
operator|=
name|multiPhraseQuery
operator|.
name|slop
expr_stmt|;
block|}
comment|/** Sets the phrase slop for this query.      * @see PhraseQuery#getSlop()      */
DECL|method|setSlop
specifier|public
name|Builder
name|setSlop
parameter_list|(
name|int
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"slop value cannot be negative"
argument_list|)
throw|;
block|}
name|slop
operator|=
name|s
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Add a single term at the next position in the phrase.      */
DECL|method|add
specifier|public
name|Builder
name|add
parameter_list|(
name|Term
name|term
parameter_list|)
block|{
return|return
name|add
argument_list|(
operator|new
name|Term
index|[]
block|{
name|term
block|}
argument_list|)
return|;
block|}
comment|/** Add multiple terms at the next position in the phrase.  Any of the terms      * may match (a disjunction).      * The array is not copied or mutated, the caller should consider it      * immutable subsequent to calling this method.      */
DECL|method|add
specifier|public
name|Builder
name|add
parameter_list|(
name|Term
index|[]
name|terms
parameter_list|)
block|{
name|int
name|position
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|positions
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
name|position
operator|=
name|positions
operator|.
name|get
argument_list|(
name|positions
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|add
argument_list|(
name|terms
argument_list|,
name|position
argument_list|)
return|;
block|}
comment|/**      * Allows to specify the relative position of terms within the phrase.      * The array is not copied or mutated, the caller should consider it      * immutable subsequent to calling this method.      */
DECL|method|add
specifier|public
name|Builder
name|add
parameter_list|(
name|Term
index|[]
name|terms
parameter_list|,
name|int
name|position
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|terms
argument_list|,
literal|"Term array must not be null"
argument_list|)
expr_stmt|;
if|if
condition|(
name|termArrays
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
name|field
operator|=
name|terms
index|[
literal|0
index|]
operator|.
name|field
argument_list|()
expr_stmt|;
for|for
control|(
name|Term
name|term
range|:
name|terms
control|)
block|{
if|if
condition|(
operator|!
name|term
operator|.
name|field
argument_list|()
operator|.
name|equals
argument_list|(
name|field
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"All phrase terms must be in the same field ("
operator|+
name|field
operator|+
literal|"): "
operator|+
name|term
argument_list|)
throw|;
block|}
block|}
name|termArrays
operator|.
name|add
argument_list|(
name|terms
argument_list|)
expr_stmt|;
name|positions
operator|.
name|add
argument_list|(
name|position
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Builds a {@link MultiPhraseQuery}. */
DECL|method|build
specifier|public
name|MultiPhraseQuery
name|build
parameter_list|()
block|{
name|int
index|[]
name|positionsArray
init|=
operator|new
name|int
index|[
name|this
operator|.
name|positions
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|positions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|positionsArray
index|[
name|i
index|]
operator|=
name|this
operator|.
name|positions
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|Term
index|[]
index|[]
name|termArraysArray
init|=
name|termArrays
operator|.
name|toArray
argument_list|(
operator|new
name|Term
index|[
name|termArrays
operator|.
name|size
argument_list|()
index|]
index|[]
argument_list|)
decl_stmt|;
return|return
operator|new
name|MultiPhraseQuery
argument_list|(
name|field
argument_list|,
name|termArraysArray
argument_list|,
name|positionsArray
argument_list|,
name|slop
argument_list|)
return|;
block|}
block|}
DECL|field|field
specifier|private
specifier|final
name|String
name|field
decl_stmt|;
DECL|field|termArrays
specifier|private
specifier|final
name|Term
index|[]
index|[]
name|termArrays
decl_stmt|;
DECL|field|positions
specifier|private
specifier|final
name|int
index|[]
name|positions
decl_stmt|;
DECL|field|slop
specifier|private
specifier|final
name|int
name|slop
decl_stmt|;
DECL|method|MultiPhraseQuery
specifier|private
name|MultiPhraseQuery
parameter_list|(
name|String
name|field
parameter_list|,
name|Term
index|[]
index|[]
name|termArrays
parameter_list|,
name|int
index|[]
name|positions
parameter_list|,
name|int
name|slop
parameter_list|)
block|{
comment|// No argument checks here since they are provided by the MultiPhraseQuery.Builder
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|termArrays
operator|=
name|termArrays
expr_stmt|;
name|this
operator|.
name|positions
operator|=
name|positions
expr_stmt|;
name|this
operator|.
name|slop
operator|=
name|slop
expr_stmt|;
block|}
comment|/** Sets the phrase slop for this query.    * @see PhraseQuery#getSlop()    */
DECL|method|getSlop
specifier|public
name|int
name|getSlop
parameter_list|()
block|{
return|return
name|slop
return|;
block|}
comment|/**    * Returns the arrays of arrays of terms in the multi-phrase.    * Do not modify!    */
DECL|method|getTermArrays
specifier|public
name|Term
index|[]
index|[]
name|getTermArrays
parameter_list|()
block|{
return|return
name|termArrays
return|;
block|}
comment|/**    * Returns the relative positions of terms in this phrase.    * Do not modify!    */
DECL|method|getPositions
specifier|public
name|int
index|[]
name|getPositions
parameter_list|()
block|{
return|return
name|positions
return|;
block|}
DECL|class|MultiPhraseWeight
specifier|private
class|class
name|MultiPhraseWeight
extends|extends
name|Weight
block|{
DECL|field|similarity
specifier|private
specifier|final
name|Similarity
name|similarity
decl_stmt|;
DECL|field|stats
specifier|private
specifier|final
name|Similarity
operator|.
name|SimWeight
name|stats
decl_stmt|;
DECL|field|termContexts
specifier|private
specifier|final
name|Map
argument_list|<
name|Term
argument_list|,
name|TermContext
argument_list|>
name|termContexts
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|needsScores
specifier|private
specifier|final
name|boolean
name|needsScores
decl_stmt|;
DECL|method|MultiPhraseWeight
specifier|public
name|MultiPhraseWeight
parameter_list|(
name|IndexSearcher
name|searcher
parameter_list|,
name|boolean
name|needsScores
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|MultiPhraseQuery
operator|.
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|needsScores
operator|=
name|needsScores
expr_stmt|;
name|this
operator|.
name|similarity
operator|=
name|searcher
operator|.
name|getSimilarity
argument_list|(
name|needsScores
argument_list|)
expr_stmt|;
specifier|final
name|IndexReaderContext
name|context
init|=
name|searcher
operator|.
name|getTopReaderContext
argument_list|()
decl_stmt|;
comment|// compute idf
name|ArrayList
argument_list|<
name|TermStatistics
argument_list|>
name|allTermStats
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Term
index|[]
name|terms
range|:
name|termArrays
control|)
block|{
for|for
control|(
name|Term
name|term
range|:
name|terms
control|)
block|{
name|TermContext
name|termContext
init|=
name|termContexts
operator|.
name|get
argument_list|(
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
name|termContext
operator|==
literal|null
condition|)
block|{
name|termContext
operator|=
name|TermContext
operator|.
name|build
argument_list|(
name|context
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|termContexts
operator|.
name|put
argument_list|(
name|term
argument_list|,
name|termContext
argument_list|)
expr_stmt|;
block|}
name|allTermStats
operator|.
name|add
argument_list|(
name|searcher
operator|.
name|termStatistics
argument_list|(
name|term
argument_list|,
name|termContext
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|stats
operator|=
name|similarity
operator|.
name|computeWeight
argument_list|(
name|searcher
operator|.
name|collectionStatistics
argument_list|(
name|field
argument_list|)
argument_list|,
name|allTermStats
operator|.
name|toArray
argument_list|(
operator|new
name|TermStatistics
index|[
name|allTermStats
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|extractTerms
specifier|public
name|void
name|extractTerms
parameter_list|(
name|Set
argument_list|<
name|Term
argument_list|>
name|terms
parameter_list|)
block|{
for|for
control|(
specifier|final
name|Term
index|[]
name|arr
range|:
name|termArrays
control|)
block|{
name|Collections
operator|.
name|addAll
argument_list|(
name|terms
argument_list|,
name|arr
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getValueForNormalization
specifier|public
name|float
name|getValueForNormalization
parameter_list|()
block|{
return|return
name|stats
operator|.
name|getValueForNormalization
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|normalize
specifier|public
name|void
name|normalize
parameter_list|(
name|float
name|queryNorm
parameter_list|,
name|float
name|boost
parameter_list|)
block|{
name|stats
operator|.
name|normalize
argument_list|(
name|queryNorm
argument_list|,
name|boost
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|scorer
specifier|public
name|Scorer
name|scorer
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|termArrays
operator|.
name|length
operator|!=
literal|0
assert|;
specifier|final
name|LeafReader
name|reader
init|=
name|context
operator|.
name|reader
argument_list|()
decl_stmt|;
name|PhraseQuery
operator|.
name|PostingsAndFreq
index|[]
name|postingsFreqs
init|=
operator|new
name|PhraseQuery
operator|.
name|PostingsAndFreq
index|[
name|termArrays
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|Terms
name|fieldTerms
init|=
name|reader
operator|.
name|terms
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldTerms
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// TODO: move this check to createWeight to happen earlier to the user?
if|if
condition|(
name|fieldTerms
operator|.
name|hasPositions
argument_list|()
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"field \""
operator|+
name|field
operator|+
literal|"\" was indexed without position data;"
operator|+
literal|" cannot run MultiPhraseQuery (phrase="
operator|+
name|getQuery
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
comment|// Reuse single TermsEnum below:
specifier|final
name|TermsEnum
name|termsEnum
init|=
name|fieldTerms
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|float
name|totalMatchCost
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|postingsFreqs
operator|.
name|length
condition|;
name|pos
operator|++
control|)
block|{
name|Term
index|[]
name|terms
init|=
name|termArrays
index|[
name|pos
index|]
decl_stmt|;
name|List
argument_list|<
name|PostingsEnum
argument_list|>
name|postings
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Term
name|term
range|:
name|terms
control|)
block|{
name|TermState
name|termState
init|=
name|termContexts
operator|.
name|get
argument_list|(
name|term
argument_list|)
operator|.
name|get
argument_list|(
name|context
operator|.
name|ord
argument_list|)
decl_stmt|;
if|if
condition|(
name|termState
operator|!=
literal|null
condition|)
block|{
name|termsEnum
operator|.
name|seekExact
argument_list|(
name|term
operator|.
name|bytes
argument_list|()
argument_list|,
name|termState
argument_list|)
expr_stmt|;
name|postings
operator|.
name|add
argument_list|(
name|termsEnum
operator|.
name|postings
argument_list|(
literal|null
argument_list|,
name|PostingsEnum
operator|.
name|POSITIONS
argument_list|)
argument_list|)
expr_stmt|;
name|totalMatchCost
operator|+=
name|PhraseQuery
operator|.
name|termPositionsCost
argument_list|(
name|termsEnum
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|postings
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|PostingsEnum
name|postingsEnum
decl_stmt|;
if|if
condition|(
name|postings
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|postingsEnum
operator|=
name|postings
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|postingsEnum
operator|=
operator|new
name|UnionPostingsEnum
argument_list|(
name|postings
argument_list|)
expr_stmt|;
block|}
name|postingsFreqs
index|[
name|pos
index|]
operator|=
operator|new
name|PhraseQuery
operator|.
name|PostingsAndFreq
argument_list|(
name|postingsEnum
argument_list|,
name|positions
index|[
name|pos
index|]
argument_list|,
name|terms
argument_list|)
expr_stmt|;
block|}
comment|// sort by increasing docFreq order
if|if
condition|(
name|slop
operator|==
literal|0
condition|)
block|{
name|ArrayUtil
operator|.
name|timSort
argument_list|(
name|postingsFreqs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|slop
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|ExactPhraseScorer
argument_list|(
name|this
argument_list|,
name|postingsFreqs
argument_list|,
name|similarity
operator|.
name|simScorer
argument_list|(
name|stats
argument_list|,
name|context
argument_list|)
argument_list|,
name|needsScores
argument_list|,
name|totalMatchCost
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|SloppyPhraseScorer
argument_list|(
name|this
argument_list|,
name|postingsFreqs
argument_list|,
name|slop
argument_list|,
name|similarity
operator|.
name|simScorer
argument_list|(
name|stats
argument_list|,
name|context
argument_list|)
argument_list|,
name|needsScores
argument_list|,
name|totalMatchCost
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|explain
specifier|public
name|Explanation
name|explain
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|,
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|Scorer
name|scorer
init|=
name|scorer
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|scorer
operator|!=
literal|null
condition|)
block|{
name|int
name|newDoc
init|=
name|scorer
operator|.
name|iterator
argument_list|()
operator|.
name|advance
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDoc
operator|==
name|doc
condition|)
block|{
name|float
name|freq
init|=
name|slop
operator|==
literal|0
condition|?
name|scorer
operator|.
name|freq
argument_list|()
else|:
operator|(
operator|(
name|SloppyPhraseScorer
operator|)
name|scorer
operator|)
operator|.
name|sloppyFreq
argument_list|()
decl_stmt|;
name|SimScorer
name|docScorer
init|=
name|similarity
operator|.
name|simScorer
argument_list|(
name|stats
argument_list|,
name|context
argument_list|)
decl_stmt|;
name|Explanation
name|freqExplanation
init|=
name|Explanation
operator|.
name|match
argument_list|(
name|freq
argument_list|,
literal|"phraseFreq="
operator|+
name|freq
argument_list|)
decl_stmt|;
name|Explanation
name|scoreExplanation
init|=
name|docScorer
operator|.
name|explain
argument_list|(
name|doc
argument_list|,
name|freqExplanation
argument_list|)
decl_stmt|;
return|return
name|Explanation
operator|.
name|match
argument_list|(
name|scoreExplanation
operator|.
name|getValue
argument_list|()
argument_list|,
literal|"weight("
operator|+
name|getQuery
argument_list|()
operator|+
literal|" in "
operator|+
name|doc
operator|+
literal|") ["
operator|+
name|similarity
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"], result of:"
argument_list|,
name|scoreExplanation
argument_list|)
return|;
block|}
block|}
return|return
name|Explanation
operator|.
name|noMatch
argument_list|(
literal|"no matching term"
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|rewrite
specifier|public
name|Query
name|rewrite
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|termArrays
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|MatchNoDocsQuery
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|termArrays
operator|.
name|length
operator|==
literal|1
condition|)
block|{
comment|// optimize one-term case
name|Term
index|[]
name|terms
init|=
name|termArrays
index|[
literal|0
index|]
decl_stmt|;
name|BooleanQuery
operator|.
name|Builder
name|builder
init|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setDisableCoord
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|Term
name|term
range|:
name|terms
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
operator|new
name|TermQuery
argument_list|(
name|term
argument_list|)
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|rewrite
argument_list|(
name|reader
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|createWeight
specifier|public
name|Weight
name|createWeight
parameter_list|(
name|IndexSearcher
name|searcher
parameter_list|,
name|boolean
name|needsScores
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|MultiPhraseWeight
argument_list|(
name|searcher
argument_list|,
name|needsScores
argument_list|)
return|;
block|}
comment|/** Prints a user-readable version of this query. */
annotation|@
name|Override
DECL|method|toString
specifier|public
specifier|final
name|String
name|toString
parameter_list|(
name|String
name|f
parameter_list|)
block|{
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|null
operator|||
operator|!
name|field
operator|.
name|equals
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
name|int
name|lastPos
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|termArrays
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|Term
index|[]
name|terms
init|=
name|termArrays
index|[
name|i
index|]
decl_stmt|;
name|int
name|position
init|=
name|positions
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
operator|(
name|position
operator|-
name|lastPos
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|"? "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|terms
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|terms
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|terms
index|[
name|j
index|]
operator|.
name|text
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|terms
operator|.
name|length
operator|-
literal|1
condition|)
name|buffer
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buffer
operator|.
name|append
argument_list|(
name|terms
index|[
literal|0
index|]
operator|.
name|text
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|lastPos
operator|=
name|position
expr_stmt|;
block|}
name|buffer
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|slop
operator|!=
literal|0
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|"~"
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|slop
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Returns true if<code>o</code> is equal to this. */
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|super
operator|.
name|equals
argument_list|(
name|o
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
name|MultiPhraseQuery
name|other
init|=
operator|(
name|MultiPhraseQuery
operator|)
name|o
decl_stmt|;
return|return
name|this
operator|.
name|slop
operator|==
name|other
operator|.
name|slop
operator|&&
name|termArraysEquals
argument_list|(
name|this
operator|.
name|termArrays
argument_list|,
name|other
operator|.
name|termArrays
argument_list|)
comment|// terms equal implies field equal
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|this
operator|.
name|positions
argument_list|,
name|other
operator|.
name|positions
argument_list|)
return|;
block|}
comment|/** Returns a hash code value for this object.*/
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|super
operator|.
name|hashCode
argument_list|()
operator|^
name|slop
operator|^
name|termArraysHashCode
argument_list|()
comment|// terms equal implies field equal
operator|^
name|Arrays
operator|.
name|hashCode
argument_list|(
name|positions
argument_list|)
return|;
block|}
comment|// Breakout calculation of the termArrays hashcode
DECL|method|termArraysHashCode
specifier|private
name|int
name|termArraysHashCode
parameter_list|()
block|{
name|int
name|hashCode
init|=
literal|1
decl_stmt|;
for|for
control|(
specifier|final
name|Term
index|[]
name|termArray
range|:
name|termArrays
control|)
block|{
name|hashCode
operator|=
literal|31
operator|*
name|hashCode
operator|+
operator|(
name|termArray
operator|==
literal|null
condition|?
literal|0
else|:
name|Arrays
operator|.
name|hashCode
argument_list|(
name|termArray
argument_list|)
operator|)
expr_stmt|;
block|}
return|return
name|hashCode
return|;
block|}
comment|// Breakout calculation of the termArrays equals
DECL|method|termArraysEquals
specifier|private
name|boolean
name|termArraysEquals
parameter_list|(
name|Term
index|[]
index|[]
name|termArrays1
parameter_list|,
name|Term
index|[]
index|[]
name|termArrays2
parameter_list|)
block|{
if|if
condition|(
name|termArrays1
operator|.
name|length
operator|!=
name|termArrays2
operator|.
name|length
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|termArrays1
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|Term
index|[]
name|termArray1
init|=
name|termArrays1
index|[
name|i
index|]
decl_stmt|;
name|Term
index|[]
name|termArray2
init|=
name|termArrays2
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|termArray1
operator|==
literal|null
condition|?
name|termArray2
operator|==
literal|null
else|:
name|Arrays
operator|.
name|equals
argument_list|(
name|termArray1
argument_list|,
name|termArray2
argument_list|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Takes the logical union of multiple PostingsEnum iterators.    *<p>    * Note: positions are merged during freq()    */
DECL|class|UnionPostingsEnum
specifier|static
class|class
name|UnionPostingsEnum
extends|extends
name|PostingsEnum
block|{
comment|/** queue ordered by docid */
DECL|field|docsQueue
specifier|final
name|DocsQueue
name|docsQueue
decl_stmt|;
comment|/** cost of this enum: sum of its subs */
DECL|field|cost
specifier|final
name|long
name|cost
decl_stmt|;
comment|/** queue ordered by position for current doc */
DECL|field|posQueue
specifier|final
name|PositionsQueue
name|posQueue
init|=
operator|new
name|PositionsQueue
argument_list|()
decl_stmt|;
comment|/** current doc posQueue is working */
DECL|field|posQueueDoc
name|int
name|posQueueDoc
init|=
operator|-
literal|2
decl_stmt|;
comment|/** list of subs (unordered) */
DECL|field|subs
specifier|final
name|PostingsEnum
index|[]
name|subs
decl_stmt|;
DECL|method|UnionPostingsEnum
name|UnionPostingsEnum
parameter_list|(
name|Collection
argument_list|<
name|PostingsEnum
argument_list|>
name|subs
parameter_list|)
block|{
name|docsQueue
operator|=
operator|new
name|DocsQueue
argument_list|(
name|subs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|cost
init|=
literal|0
decl_stmt|;
for|for
control|(
name|PostingsEnum
name|sub
range|:
name|subs
control|)
block|{
name|docsQueue
operator|.
name|add
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|sub
operator|.
name|cost
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|cost
operator|=
name|cost
expr_stmt|;
name|this
operator|.
name|subs
operator|=
name|subs
operator|.
name|toArray
argument_list|(
operator|new
name|PostingsEnum
index|[
name|subs
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|doc
init|=
name|docID
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
operator|!=
name|posQueueDoc
condition|)
block|{
name|posQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|PostingsEnum
name|sub
range|:
name|subs
control|)
block|{
if|if
condition|(
name|sub
operator|.
name|docID
argument_list|()
operator|==
name|doc
condition|)
block|{
name|int
name|freq
init|=
name|sub
operator|.
name|freq
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|freq
condition|;
name|i
operator|++
control|)
block|{
name|posQueue
operator|.
name|add
argument_list|(
name|sub
operator|.
name|nextPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|posQueue
operator|.
name|sort
argument_list|()
expr_stmt|;
name|posQueueDoc
operator|=
name|doc
expr_stmt|;
block|}
return|return
name|posQueue
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|nextPosition
specifier|public
name|int
name|nextPosition
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|posQueue
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|docsQueue
operator|.
name|top
argument_list|()
operator|.
name|docID
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
name|PostingsEnum
name|top
init|=
name|docsQueue
operator|.
name|top
argument_list|()
decl_stmt|;
name|int
name|doc
init|=
name|top
operator|.
name|docID
argument_list|()
decl_stmt|;
do|do
block|{
name|top
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
name|top
operator|=
name|docsQueue
operator|.
name|updateTop
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|top
operator|.
name|docID
argument_list|()
operator|==
name|doc
condition|)
do|;
return|return
name|top
operator|.
name|docID
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
name|PostingsEnum
name|top
init|=
name|docsQueue
operator|.
name|top
argument_list|()
decl_stmt|;
do|do
block|{
name|top
operator|.
name|advance
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|top
operator|=
name|docsQueue
operator|.
name|updateTop
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|top
operator|.
name|docID
argument_list|()
operator|<
name|target
condition|)
do|;
return|return
name|top
operator|.
name|docID
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|cost
return|;
block|}
annotation|@
name|Override
DECL|method|startOffset
specifier|public
name|int
name|startOffset
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|-
literal|1
return|;
comment|// offsets are unsupported
block|}
annotation|@
name|Override
DECL|method|endOffset
specifier|public
name|int
name|endOffset
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|-
literal|1
return|;
comment|// offsets are unsupported
block|}
annotation|@
name|Override
DECL|method|getPayload
specifier|public
name|BytesRef
name|getPayload
parameter_list|()
throws|throws
name|IOException
block|{
return|return
literal|null
return|;
comment|// payloads are unsupported
block|}
comment|/**      * disjunction of postings ordered by docid.      */
DECL|class|DocsQueue
specifier|static
class|class
name|DocsQueue
extends|extends
name|PriorityQueue
argument_list|<
name|PostingsEnum
argument_list|>
block|{
DECL|method|DocsQueue
name|DocsQueue
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|super
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|lessThan
specifier|public
specifier|final
name|boolean
name|lessThan
parameter_list|(
name|PostingsEnum
name|a
parameter_list|,
name|PostingsEnum
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|docID
argument_list|()
operator|<
name|b
operator|.
name|docID
argument_list|()
return|;
block|}
block|}
comment|/**      * queue of terms for a single document. its a sorted array of      * all the positions from all the postings      */
DECL|class|PositionsQueue
specifier|static
class|class
name|PositionsQueue
block|{
DECL|field|arraySize
specifier|private
name|int
name|arraySize
init|=
literal|16
decl_stmt|;
DECL|field|index
specifier|private
name|int
name|index
init|=
literal|0
decl_stmt|;
DECL|field|size
specifier|private
name|int
name|size
init|=
literal|0
decl_stmt|;
DECL|field|array
specifier|private
name|int
index|[]
name|array
init|=
operator|new
name|int
index|[
name|arraySize
index|]
decl_stmt|;
DECL|method|add
name|void
name|add
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
name|arraySize
condition|)
name|growArray
argument_list|()
expr_stmt|;
name|array
index|[
name|size
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
DECL|method|next
name|int
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
DECL|method|sort
name|void
name|sort
parameter_list|()
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|array
argument_list|,
name|index
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
DECL|method|clear
name|void
name|clear
parameter_list|()
block|{
name|index
operator|=
literal|0
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|size
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
DECL|method|growArray
specifier|private
name|void
name|growArray
parameter_list|()
block|{
name|int
index|[]
name|newArray
init|=
operator|new
name|int
index|[
name|arraySize
operator|*
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|array
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|arraySize
argument_list|)
expr_stmt|;
name|array
operator|=
name|newArray
expr_stmt|;
name|arraySize
operator|*=
literal|2
expr_stmt|;
block|}
block|}
block|}
block|}
end_class
end_unit
