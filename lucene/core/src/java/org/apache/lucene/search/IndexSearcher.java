begin_unit
begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletionService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorCompletionService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|AtomicReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DirectoryReader
import|;
end_import
begin_comment
comment|// javadocs
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MultiFields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|ReaderUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StoredDocument
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|StoredFieldVisitor
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|DefaultSimilarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|NIOFSDirectory
import|;
end_import
begin_comment
comment|// javadoc
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ThreadInterruptedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import
begin_comment
comment|// javadocs
end_comment
begin_comment
comment|/** Implements search over a single IndexReader.  *  *<p>Applications usually need only call the inherited  * {@link #search(Query,int)}  * or {@link #search(Query,Filter,int)} methods. For  * performance reasons, if your index is unchanging, you  * should share a single IndexSearcher instance across  * multiple searches instead of creating a new one  * per-search.  If your index has changed and you wish to  * see the changes reflected in searching, you should  * use {@link DirectoryReader#openIfChanged(DirectoryReader)}  * to obtain a new reader and  * then create a new IndexSearcher from that.  Also, for  * low-latency turnaround it's best to use a near-real-time  * reader ({@link DirectoryReader#open(IndexWriter,boolean)}).  * Once you have a new {@link IndexReader}, it's relatively  * cheap to create a new IndexSearcher from it.  *   *<a name="thread-safety"></a><p><b>NOTE</b>:<code>{@link  * IndexSearcher}</code> instances are completely  * thread safe, meaning multiple threads can call any of its  * methods, concurrently.  If your application requires  * external synchronization, you should<b>not</b>  * synchronize on the<code>IndexSearcher</code> instance;  * use your own (non-Lucene) objects instead.</p>  */
end_comment
begin_class
DECL|class|IndexSearcher
specifier|public
class|class
name|IndexSearcher
block|{
DECL|field|reader
specifier|final
name|IndexReader
name|reader
decl_stmt|;
comment|// package private for testing!
comment|// NOTE: these members might change in incompatible ways
comment|// in the next release
DECL|field|readerContext
specifier|protected
specifier|final
name|IndexReaderContext
name|readerContext
decl_stmt|;
DECL|field|leafContexts
specifier|protected
specifier|final
name|List
argument_list|<
name|AtomicReaderContext
argument_list|>
name|leafContexts
decl_stmt|;
comment|/** used with executor - each slice holds a set of leafs executed within one thread */
DECL|field|leafSlices
specifier|protected
specifier|final
name|LeafSlice
index|[]
name|leafSlices
decl_stmt|;
comment|// These are only used for multi-threaded search
DECL|field|executor
specifier|private
specifier|final
name|ExecutorService
name|executor
decl_stmt|;
comment|// the default Similarity
DECL|field|defaultSimilarity
specifier|private
specifier|static
specifier|final
name|Similarity
name|defaultSimilarity
init|=
operator|new
name|DefaultSimilarity
argument_list|()
decl_stmt|;
comment|/**    * Expert: returns a default Similarity instance.    * In general, this method is only called to initialize searchers and writers.    * User code and query implementations should respect    * {@link IndexSearcher#getSimilarity()}.    * @lucene.internal    */
DECL|method|getDefaultSimilarity
specifier|public
specifier|static
name|Similarity
name|getDefaultSimilarity
parameter_list|()
block|{
return|return
name|defaultSimilarity
return|;
block|}
comment|/** The Similarity implementation used by this searcher. */
DECL|field|similarity
specifier|private
name|Similarity
name|similarity
init|=
name|defaultSimilarity
decl_stmt|;
comment|/** Creates a searcher searching the provided index. */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|IndexReader
name|r
parameter_list|)
block|{
name|this
argument_list|(
name|r
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/** Runs searches for each segment separately, using the    *  provided ExecutorService.  IndexSearcher will not    *  shutdown/awaitTermination this ExecutorService on    *  close; you must do so, eventually, on your own.  NOTE:    *  if you are using {@link NIOFSDirectory}, do not use    *  the shutdownNow method of ExecutorService as this uses    *  Thread.interrupt under-the-hood which can silently    *  close file descriptors (see<a    *  href="https://issues.apache.org/jira/browse/LUCENE-2239">LUCENE-2239</a>).    *     * @lucene.experimental */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|IndexReader
name|r
parameter_list|,
name|ExecutorService
name|executor
parameter_list|)
block|{
name|this
argument_list|(
name|r
operator|.
name|getContext
argument_list|()
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a searcher searching the provided top-level {@link IndexReaderContext}.    *<p>    * Given a non-<code>null</code> {@link ExecutorService} this method runs    * searches for each segment separately, using the provided ExecutorService.    * IndexSearcher will not shutdown/awaitTermination this ExecutorService on    * close; you must do so, eventually, on your own. NOTE: if you are using    * {@link NIOFSDirectory}, do not use the shutdownNow method of    * ExecutorService as this uses Thread.interrupt under-the-hood which can    * silently close file descriptors (see<a    * href="https://issues.apache.org/jira/browse/LUCENE-2239">LUCENE-2239</a>).    *     * @see IndexReaderContext    * @see IndexReader#getContext()    * @lucene.experimental    */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|IndexReaderContext
name|context
parameter_list|,
name|ExecutorService
name|executor
parameter_list|)
block|{
assert|assert
name|context
operator|.
name|isTopLevel
operator|:
literal|"IndexSearcher's ReaderContext must be topLevel for reader"
operator|+
name|context
operator|.
name|reader
argument_list|()
assert|;
name|reader
operator|=
name|context
operator|.
name|reader
argument_list|()
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
name|this
operator|.
name|readerContext
operator|=
name|context
expr_stmt|;
name|leafContexts
operator|=
name|context
operator|.
name|leaves
argument_list|()
expr_stmt|;
name|this
operator|.
name|leafSlices
operator|=
name|executor
operator|==
literal|null
condition|?
literal|null
else|:
name|slices
argument_list|(
name|leafContexts
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a searcher searching the provided top-level {@link IndexReaderContext}.    *    * @see IndexReaderContext    * @see IndexReader#getContext()    * @lucene.experimental    */
DECL|method|IndexSearcher
specifier|public
name|IndexSearcher
parameter_list|(
name|IndexReaderContext
name|context
parameter_list|)
block|{
name|this
argument_list|(
name|context
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expert: Creates an array of leaf slices each holding a subset of the given leaves.    * Each {@link LeafSlice} is executed in a single thread. By default there    * will be one {@link LeafSlice} per leaf ({@link AtomicReaderContext}).    */
DECL|method|slices
specifier|protected
name|LeafSlice
index|[]
name|slices
parameter_list|(
name|List
argument_list|<
name|AtomicReaderContext
argument_list|>
name|leaves
parameter_list|)
block|{
name|LeafSlice
index|[]
name|slices
init|=
operator|new
name|LeafSlice
index|[
name|leaves
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|slices
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|slices
index|[
name|i
index|]
operator|=
operator|new
name|LeafSlice
argument_list|(
name|leaves
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|slices
return|;
block|}
comment|/** Return the {@link IndexReader} this searches. */
DECL|method|getIndexReader
specifier|public
name|IndexReader
name|getIndexReader
parameter_list|()
block|{
return|return
name|reader
return|;
block|}
comment|/** Sugar for<code>.getIndexReader().document(docID)</code> */
DECL|method|doc
specifier|public
name|StoredDocument
name|doc
parameter_list|(
name|int
name|docID
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|reader
operator|.
name|document
argument_list|(
name|docID
argument_list|)
return|;
block|}
comment|/** Sugar for<code>.getIndexReader().document(docID, fieldVisitor)</code> */
DECL|method|doc
specifier|public
name|void
name|doc
parameter_list|(
name|int
name|docID
parameter_list|,
name|StoredFieldVisitor
name|fieldVisitor
parameter_list|)
throws|throws
name|IOException
block|{
name|reader
operator|.
name|document
argument_list|(
name|docID
argument_list|,
name|fieldVisitor
argument_list|)
expr_stmt|;
block|}
comment|/** Sugar for<code>.getIndexReader().document(docID, fieldsToLoad)</code> */
DECL|method|document
specifier|public
specifier|final
name|StoredDocument
name|document
parameter_list|(
name|int
name|docID
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fieldsToLoad
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|reader
operator|.
name|document
argument_list|(
name|docID
argument_list|,
name|fieldsToLoad
argument_list|)
return|;
block|}
comment|/** Expert: Set the Similarity implementation used by this IndexSearcher.    *    */
DECL|method|setSimilarity
specifier|public
name|void
name|setSimilarity
parameter_list|(
name|Similarity
name|similarity
parameter_list|)
block|{
name|this
operator|.
name|similarity
operator|=
name|similarity
expr_stmt|;
block|}
DECL|method|getSimilarity
specifier|public
name|Similarity
name|getSimilarity
parameter_list|()
block|{
return|return
name|similarity
return|;
block|}
comment|/** @lucene.internal */
DECL|method|wrapFilter
specifier|protected
name|Query
name|wrapFilter
parameter_list|(
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|)
block|{
return|return
operator|(
name|filter
operator|==
literal|null
operator|)
condition|?
name|query
else|:
operator|new
name|FilteredQuery
argument_list|(
name|query
argument_list|,
name|filter
argument_list|)
return|;
block|}
comment|/** Finds the top<code>n</code>    * hits for<code>query</code> where all results are after a previous     * result (<code>after</code>).    *<p>    * By passing the bottom result from a previous page as<code>after</code>,    * this method can be used for efficient 'deep-paging' across potentially    * large result sets.    *    * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|searchAfter
specifier|public
name|TopDocs
name|searchAfter
parameter_list|(
name|ScoreDoc
name|after
parameter_list|,
name|Query
name|query
parameter_list|,
name|int
name|n
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|createNormalizedWeight
argument_list|(
name|query
argument_list|)
argument_list|,
name|after
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Finds the top<code>n</code>    * hits for<code>query</code>, applying<code>filter</code> if non-null,    * where all results are after a previous result (<code>after</code>).    *<p>    * By passing the bottom result from a previous page as<code>after</code>,    * this method can be used for efficient 'deep-paging' across potentially    * large result sets.    *    * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|searchAfter
specifier|public
name|TopDocs
name|searchAfter
parameter_list|(
name|ScoreDoc
name|after
parameter_list|,
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|n
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|createNormalizedWeight
argument_list|(
name|wrapFilter
argument_list|(
name|query
argument_list|,
name|filter
argument_list|)
argument_list|)
argument_list|,
name|after
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Finds the top<code>n</code>    * hits for<code>query</code>.    *    * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|search
specifier|public
name|TopDocs
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|n
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Finds the top<code>n</code>    * hits for<code>query</code>, applying<code>filter</code> if non-null.    *    * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|search
specifier|public
name|TopDocs
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|n
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|createNormalizedWeight
argument_list|(
name|wrapFilter
argument_list|(
name|query
argument_list|,
name|filter
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Lower-level search API.    *    *<p>{@link Collector#collect(int)} is called for every matching    * document.    *    * @param query to match documents    * @param filter if non-null, used to permit documents to be collected.    * @param results to receive hits    * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|search
specifier|public
name|void
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|Collector
name|results
parameter_list|)
throws|throws
name|IOException
block|{
name|search
argument_list|(
name|leafContexts
argument_list|,
name|createNormalizedWeight
argument_list|(
name|wrapFilter
argument_list|(
name|query
argument_list|,
name|filter
argument_list|)
argument_list|)
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
comment|/** Lower-level search API.    *    *<p>{@link Collector#collect(int)} is called for every matching document.    *    * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|search
specifier|public
name|void
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|Collector
name|results
parameter_list|)
throws|throws
name|IOException
block|{
name|search
argument_list|(
name|leafContexts
argument_list|,
name|createNormalizedWeight
argument_list|(
name|query
argument_list|)
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
comment|/** Search implementation with arbitrary sorting.  Finds    * the top<code>n</code> hits for<code>query</code>, applying    *<code>filter</code> if non-null, and sorting the hits by the criteria in    *<code>sort</code>.    *     *<p>NOTE: this does not compute scores by default; use    * {@link IndexSearcher#search(Query,Filter,int,Sort,boolean,boolean)} to    * control scoring.    *    * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|search
specifier|public
name|TopFieldDocs
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|n
parameter_list|,
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|createNormalizedWeight
argument_list|(
name|wrapFilter
argument_list|(
name|query
argument_list|,
name|filter
argument_list|)
argument_list|)
argument_list|,
name|n
argument_list|,
name|sort
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Search implementation with arbitrary sorting, plus    * control over whether hit scores and max score    * should be computed.  Finds    * the top<code>n</code> hits for<code>query</code>, applying    *<code>filter</code> if non-null, and sorting the hits by the criteria in    *<code>sort</code>.  If<code>doDocScores</code> is<code>true</code>    * then the score of each hit will be computed and    * returned.  If<code>doMaxScore</code> is    *<code>true</code> then the maximum score over all    * collected hits will be computed.    *     * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|search
specifier|public
name|TopFieldDocs
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|n
parameter_list|,
name|Sort
name|sort
parameter_list|,
name|boolean
name|doDocScores
parameter_list|,
name|boolean
name|doMaxScore
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|createNormalizedWeight
argument_list|(
name|wrapFilter
argument_list|(
name|query
argument_list|,
name|filter
argument_list|)
argument_list|)
argument_list|,
name|n
argument_list|,
name|sort
argument_list|,
name|doDocScores
argument_list|,
name|doMaxScore
argument_list|)
return|;
block|}
comment|/** Finds the top<code>n</code>    * hits for<code>query</code>, applying<code>filter</code> if non-null,    * where all results are after a previous result (<code>after</code>).    *<p>    * By passing the bottom result from a previous page as<code>after</code>,    * this method can be used for efficient 'deep-paging' across potentially    * large result sets.    *    * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|searchAfter
specifier|public
name|TopDocs
name|searchAfter
parameter_list|(
name|ScoreDoc
name|after
parameter_list|,
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|n
parameter_list|,
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|after
operator|!=
literal|null
operator|&&
operator|!
operator|(
name|after
operator|instanceof
name|FieldDoc
operator|)
condition|)
block|{
comment|// TODO: if we fix type safety of TopFieldDocs we can
comment|// remove this
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"after must be a FieldDoc; got "
operator|+
name|after
argument_list|)
throw|;
block|}
return|return
name|search
argument_list|(
name|createNormalizedWeight
argument_list|(
name|wrapFilter
argument_list|(
name|query
argument_list|,
name|filter
argument_list|)
argument_list|)
argument_list|,
operator|(
name|FieldDoc
operator|)
name|after
argument_list|,
name|n
argument_list|,
name|sort
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Search implementation with arbitrary sorting and no filter.    * @param query The query to search for    * @param n Return only the top n results    * @param sort The {@link org.apache.lucene.search.Sort} object    * @return The top docs, sorted according to the supplied {@link org.apache.lucene.search.Sort} instance    * @throws IOException if there is a low-level I/O error    */
DECL|method|search
specifier|public
name|TopFieldDocs
name|search
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|n
parameter_list|,
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|createNormalizedWeight
argument_list|(
name|query
argument_list|)
argument_list|,
name|n
argument_list|,
name|sort
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Finds the top<code>n</code>    * hits for<code>query</code> where all results are after a previous     * result (<code>after</code>).    *<p>    * By passing the bottom result from a previous page as<code>after</code>,    * this method can be used for efficient 'deep-paging' across potentially    * large result sets.    *    * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|searchAfter
specifier|public
name|TopDocs
name|searchAfter
parameter_list|(
name|ScoreDoc
name|after
parameter_list|,
name|Query
name|query
parameter_list|,
name|int
name|n
parameter_list|,
name|Sort
name|sort
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|after
operator|!=
literal|null
operator|&&
operator|!
operator|(
name|after
operator|instanceof
name|FieldDoc
operator|)
condition|)
block|{
comment|// TODO: if we fix type safety of TopFieldDocs we can
comment|// remove this
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"after must be a FieldDoc; got "
operator|+
name|after
argument_list|)
throw|;
block|}
return|return
name|search
argument_list|(
name|createNormalizedWeight
argument_list|(
name|query
argument_list|)
argument_list|,
operator|(
name|FieldDoc
operator|)
name|after
argument_list|,
name|n
argument_list|,
name|sort
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Finds the top<code>n</code>    * hits for<code>query</code> where all results are after a previous     * result (<code>after</code>), allowing control over    * whether hit scores and max score should be computed.    *<p>    * By passing the bottom result from a previous page as<code>after</code>,    * this method can be used for efficient 'deep-paging' across potentially    * large result sets.  If<code>doDocScores</code> is<code>true</code>    * then the score of each hit will be computed and    * returned.  If<code>doMaxScore</code> is    *<code>true</code> then the maximum score over all    * collected hits will be computed.    *    * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|searchAfter
specifier|public
name|TopDocs
name|searchAfter
parameter_list|(
name|ScoreDoc
name|after
parameter_list|,
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|int
name|n
parameter_list|,
name|Sort
name|sort
parameter_list|,
name|boolean
name|doDocScores
parameter_list|,
name|boolean
name|doMaxScore
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|after
operator|!=
literal|null
operator|&&
operator|!
operator|(
name|after
operator|instanceof
name|FieldDoc
operator|)
condition|)
block|{
comment|// TODO: if we fix type safety of TopFieldDocs we can
comment|// remove this
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"after must be a FieldDoc; got "
operator|+
name|after
argument_list|)
throw|;
block|}
return|return
name|search
argument_list|(
name|createNormalizedWeight
argument_list|(
name|wrapFilter
argument_list|(
name|query
argument_list|,
name|filter
argument_list|)
argument_list|)
argument_list|,
operator|(
name|FieldDoc
operator|)
name|after
argument_list|,
name|n
argument_list|,
name|sort
argument_list|,
literal|true
argument_list|,
name|doDocScores
argument_list|,
name|doMaxScore
argument_list|)
return|;
block|}
comment|/** Expert: Low-level search implementation.  Finds the top<code>n</code>    * hits for<code>query</code>, applying<code>filter</code> if non-null.    *    *<p>Applications should usually call {@link IndexSearcher#search(Query,int)} or    * {@link IndexSearcher#search(Query,Filter,int)} instead.    * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|search
specifier|protected
name|TopDocs
name|search
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|ScoreDoc
name|after
parameter_list|,
name|int
name|nDocs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
block|{
return|return
name|search
argument_list|(
name|leafContexts
argument_list|,
name|weight
argument_list|,
name|after
argument_list|,
name|nDocs
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|HitQueue
name|hq
init|=
operator|new
name|HitQueue
argument_list|(
name|nDocs
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|Lock
name|lock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|final
name|ExecutionHelper
argument_list|<
name|TopDocs
argument_list|>
name|runner
init|=
operator|new
name|ExecutionHelper
argument_list|<
name|TopDocs
argument_list|>
argument_list|(
name|executor
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leafSlices
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// search each sub
name|runner
operator|.
name|submit
argument_list|(
operator|new
name|SearcherCallableNoSort
argument_list|(
name|lock
argument_list|,
name|this
argument_list|,
name|leafSlices
index|[
name|i
index|]
argument_list|,
name|weight
argument_list|,
name|after
argument_list|,
name|nDocs
argument_list|,
name|hq
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|totalHits
init|=
literal|0
decl_stmt|;
name|float
name|maxScore
init|=
name|Float
operator|.
name|NEGATIVE_INFINITY
decl_stmt|;
for|for
control|(
specifier|final
name|TopDocs
name|topDocs
range|:
name|runner
control|)
block|{
if|if
condition|(
name|topDocs
operator|.
name|totalHits
operator|!=
literal|0
condition|)
block|{
name|totalHits
operator|+=
name|topDocs
operator|.
name|totalHits
expr_stmt|;
name|maxScore
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxScore
argument_list|,
name|topDocs
operator|.
name|getMaxScore
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|ScoreDoc
index|[]
name|scoreDocs
init|=
operator|new
name|ScoreDoc
index|[
name|hq
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|hq
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
comment|// put docs in array
name|scoreDocs
index|[
name|i
index|]
operator|=
name|hq
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
operator|new
name|TopDocs
argument_list|(
name|totalHits
argument_list|,
name|scoreDocs
argument_list|,
name|maxScore
argument_list|)
return|;
block|}
block|}
comment|/** Expert: Low-level search implementation.  Finds the top<code>n</code>    * hits for<code>query</code>.    *    *<p>Applications should usually call {@link IndexSearcher#search(Query,int)} or    * {@link IndexSearcher#search(Query,Filter,int)} instead.    * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|search
specifier|protected
name|TopDocs
name|search
parameter_list|(
name|List
argument_list|<
name|AtomicReaderContext
argument_list|>
name|leaves
parameter_list|,
name|Weight
name|weight
parameter_list|,
name|ScoreDoc
name|after
parameter_list|,
name|int
name|nDocs
parameter_list|)
throws|throws
name|IOException
block|{
comment|// single thread
name|int
name|limit
init|=
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
block|{
name|limit
operator|=
literal|1
expr_stmt|;
block|}
name|nDocs
operator|=
name|Math
operator|.
name|min
argument_list|(
name|nDocs
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|TopScoreDocCollector
name|collector
init|=
name|TopScoreDocCollector
operator|.
name|create
argument_list|(
name|nDocs
argument_list|,
name|after
argument_list|,
operator|!
name|weight
operator|.
name|scoresDocsOutOfOrder
argument_list|()
argument_list|)
decl_stmt|;
name|search
argument_list|(
name|leaves
argument_list|,
name|weight
argument_list|,
name|collector
argument_list|)
expr_stmt|;
return|return
name|collector
operator|.
name|topDocs
argument_list|()
return|;
block|}
comment|/** Expert: Low-level search implementation with arbitrary    * sorting and control over whether hit scores and max    * score should be computed.  Finds    * the top<code>n</code> hits for<code>query</code> and sorting the hits    * by the criteria in<code>sort</code>.    *    *<p>Applications should usually call {@link    * IndexSearcher#search(Query,Filter,int,Sort)} instead.    *     * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|search
specifier|protected
name|TopFieldDocs
name|search
parameter_list|(
name|Weight
name|weight
parameter_list|,
specifier|final
name|int
name|nDocs
parameter_list|,
name|Sort
name|sort
parameter_list|,
name|boolean
name|doDocScores
parameter_list|,
name|boolean
name|doMaxScore
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|search
argument_list|(
name|weight
argument_list|,
literal|null
argument_list|,
name|nDocs
argument_list|,
name|sort
argument_list|,
literal|true
argument_list|,
name|doDocScores
argument_list|,
name|doMaxScore
argument_list|)
return|;
block|}
comment|/**    * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose    * whether or not the fields in the returned {@link FieldDoc} instances should    * be set by specifying fillFields.    *    *<p>NOTE: this does not compute scores by default.  If you    * need scores, create a {@link TopFieldCollector}    * instance by calling {@link TopFieldCollector#create} and    * then pass that to {@link #search(List, Weight,    * Collector)}.</p>    */
DECL|method|search
specifier|protected
name|TopFieldDocs
name|search
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|FieldDoc
name|after
parameter_list|,
name|int
name|nDocs
parameter_list|,
name|Sort
name|sort
parameter_list|,
name|boolean
name|fillFields
parameter_list|,
name|boolean
name|doDocScores
parameter_list|,
name|boolean
name|doMaxScore
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|sort
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
block|{
comment|// use all leaves here!
return|return
name|search
argument_list|(
name|leafContexts
argument_list|,
name|weight
argument_list|,
name|after
argument_list|,
name|nDocs
argument_list|,
name|sort
argument_list|,
name|fillFields
argument_list|,
name|doDocScores
argument_list|,
name|doMaxScore
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|TopFieldCollector
name|topCollector
init|=
name|TopFieldCollector
operator|.
name|create
argument_list|(
name|sort
argument_list|,
name|nDocs
argument_list|,
name|after
argument_list|,
name|fillFields
argument_list|,
name|doDocScores
argument_list|,
name|doMaxScore
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|Lock
name|lock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|final
name|ExecutionHelper
argument_list|<
name|TopFieldDocs
argument_list|>
name|runner
init|=
operator|new
name|ExecutionHelper
argument_list|<
name|TopFieldDocs
argument_list|>
argument_list|(
name|executor
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leafSlices
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// search each leaf slice
name|runner
operator|.
name|submit
argument_list|(
operator|new
name|SearcherCallableWithSort
argument_list|(
name|lock
argument_list|,
name|this
argument_list|,
name|leafSlices
index|[
name|i
index|]
argument_list|,
name|weight
argument_list|,
name|after
argument_list|,
name|nDocs
argument_list|,
name|topCollector
argument_list|,
name|sort
argument_list|,
name|doDocScores
argument_list|,
name|doMaxScore
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|totalHits
init|=
literal|0
decl_stmt|;
name|float
name|maxScore
init|=
name|Float
operator|.
name|NEGATIVE_INFINITY
decl_stmt|;
for|for
control|(
specifier|final
name|TopFieldDocs
name|topFieldDocs
range|:
name|runner
control|)
block|{
if|if
condition|(
name|topFieldDocs
operator|.
name|totalHits
operator|!=
literal|0
condition|)
block|{
name|totalHits
operator|+=
name|topFieldDocs
operator|.
name|totalHits
expr_stmt|;
name|maxScore
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxScore
argument_list|,
name|topFieldDocs
operator|.
name|getMaxScore
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|TopFieldDocs
name|topDocs
init|=
operator|(
name|TopFieldDocs
operator|)
name|topCollector
operator|.
name|topDocs
argument_list|()
decl_stmt|;
return|return
operator|new
name|TopFieldDocs
argument_list|(
name|totalHits
argument_list|,
name|topDocs
operator|.
name|scoreDocs
argument_list|,
name|topDocs
operator|.
name|fields
argument_list|,
name|topDocs
operator|.
name|getMaxScore
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose    * whether or not the fields in the returned {@link FieldDoc} instances should    * be set by specifying fillFields.    */
DECL|method|search
specifier|protected
name|TopFieldDocs
name|search
parameter_list|(
name|List
argument_list|<
name|AtomicReaderContext
argument_list|>
name|leaves
parameter_list|,
name|Weight
name|weight
parameter_list|,
name|FieldDoc
name|after
parameter_list|,
name|int
name|nDocs
parameter_list|,
name|Sort
name|sort
parameter_list|,
name|boolean
name|fillFields
parameter_list|,
name|boolean
name|doDocScores
parameter_list|,
name|boolean
name|doMaxScore
parameter_list|)
throws|throws
name|IOException
block|{
comment|// single thread
name|int
name|limit
init|=
name|reader
operator|.
name|maxDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
block|{
name|limit
operator|=
literal|1
expr_stmt|;
block|}
name|nDocs
operator|=
name|Math
operator|.
name|min
argument_list|(
name|nDocs
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|TopFieldCollector
name|collector
init|=
name|TopFieldCollector
operator|.
name|create
argument_list|(
name|sort
argument_list|,
name|nDocs
argument_list|,
name|after
argument_list|,
name|fillFields
argument_list|,
name|doDocScores
argument_list|,
name|doMaxScore
argument_list|,
operator|!
name|weight
operator|.
name|scoresDocsOutOfOrder
argument_list|()
argument_list|)
decl_stmt|;
name|search
argument_list|(
name|leaves
argument_list|,
name|weight
argument_list|,
name|collector
argument_list|)
expr_stmt|;
return|return
operator|(
name|TopFieldDocs
operator|)
name|collector
operator|.
name|topDocs
argument_list|()
return|;
block|}
comment|/**    * Lower-level search API.    *     *<p>    * {@link Collector#collect(int)} is called for every document.<br>    *     *<p>    * NOTE: this method executes the searches on all given leaves exclusively.    * To search across all the searchers leaves use {@link #leafContexts}.    *     * @param leaves     *          the searchers leaves to execute the searches on    * @param weight    *          to match documents    * @param collector    *          to receive hits    * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|search
specifier|protected
name|void
name|search
parameter_list|(
name|List
argument_list|<
name|AtomicReaderContext
argument_list|>
name|leaves
parameter_list|,
name|Weight
name|weight
parameter_list|,
name|Collector
name|collector
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: should we make this
comment|// threaded...?  the Collector could be sync'd?
comment|// always use single thread:
for|for
control|(
name|AtomicReaderContext
name|ctx
range|:
name|leaves
control|)
block|{
comment|// search each subreader
name|collector
operator|.
name|setNextReader
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|Scorer
name|scorer
init|=
name|weight
operator|.
name|scorer
argument_list|(
name|ctx
argument_list|,
operator|!
name|collector
operator|.
name|acceptsDocsOutOfOrder
argument_list|()
argument_list|,
literal|true
argument_list|,
name|ctx
operator|.
name|reader
argument_list|()
operator|.
name|getLiveDocs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|scorer
operator|!=
literal|null
condition|)
block|{
name|scorer
operator|.
name|score
argument_list|(
name|collector
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Expert: called to re-write queries into primitive queries.    * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|rewrite
specifier|public
name|Query
name|rewrite
parameter_list|(
name|Query
name|original
parameter_list|)
throws|throws
name|IOException
block|{
name|Query
name|query
init|=
name|original
decl_stmt|;
for|for
control|(
name|Query
name|rewrittenQuery
init|=
name|query
operator|.
name|rewrite
argument_list|(
name|reader
argument_list|)
init|;
name|rewrittenQuery
operator|!=
name|query
condition|;
name|rewrittenQuery
operator|=
name|query
operator|.
name|rewrite
argument_list|(
name|reader
argument_list|)
control|)
block|{
name|query
operator|=
name|rewrittenQuery
expr_stmt|;
block|}
return|return
name|query
return|;
block|}
comment|/** Returns an Explanation that describes how<code>doc</code> scored against    *<code>query</code>.    *    *<p>This is intended to be used in developing Similarity implementations,    * and, for good performance, should not be displayed with every hit.    * Computing an explanation is as expensive as executing the query over the    * entire index.    */
DECL|method|explain
specifier|public
name|Explanation
name|explain
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|explain
argument_list|(
name|createNormalizedWeight
argument_list|(
name|query
argument_list|)
argument_list|,
name|doc
argument_list|)
return|;
block|}
comment|/** Expert: low-level implementation method    * Returns an Explanation that describes how<code>doc</code> scored against    *<code>weight</code>.    *    *<p>This is intended to be used in developing Similarity implementations,    * and, for good performance, should not be displayed with every hit.    * Computing an explanation is as expensive as executing the query over the    * entire index.    *<p>Applications should call {@link IndexSearcher#explain(Query, int)}.    * @throws BooleanQuery.TooManyClauses If a query would exceed     *         {@link BooleanQuery#getMaxClauseCount()} clauses.    */
DECL|method|explain
specifier|protected
name|Explanation
name|explain
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|n
init|=
name|ReaderUtil
operator|.
name|subIndex
argument_list|(
name|doc
argument_list|,
name|leafContexts
argument_list|)
decl_stmt|;
specifier|final
name|AtomicReaderContext
name|ctx
init|=
name|leafContexts
operator|.
name|get
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|int
name|deBasedDoc
init|=
name|doc
operator|-
name|ctx
operator|.
name|docBase
decl_stmt|;
return|return
name|weight
operator|.
name|explain
argument_list|(
name|ctx
argument_list|,
name|deBasedDoc
argument_list|)
return|;
block|}
comment|/**    * Creates a normalized weight for a top-level {@link Query}.    * The query is rewritten by this method and {@link Query#createWeight} called,    * afterwards the {@link Weight} is normalized. The returned {@code Weight}    * can then directly be used to get a {@link Scorer}.    * @lucene.internal    */
DECL|method|createNormalizedWeight
specifier|public
name|Weight
name|createNormalizedWeight
parameter_list|(
name|Query
name|query
parameter_list|)
throws|throws
name|IOException
block|{
name|query
operator|=
name|rewrite
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|Weight
name|weight
init|=
name|query
operator|.
name|createWeight
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|float
name|v
init|=
name|weight
operator|.
name|getValueForNormalization
argument_list|()
decl_stmt|;
name|float
name|norm
init|=
name|getSimilarity
argument_list|()
operator|.
name|queryNorm
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|Float
operator|.
name|isInfinite
argument_list|(
name|norm
argument_list|)
operator|||
name|Float
operator|.
name|isNaN
argument_list|(
name|norm
argument_list|)
condition|)
block|{
name|norm
operator|=
literal|1.0f
expr_stmt|;
block|}
name|weight
operator|.
name|normalize
argument_list|(
name|norm
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
return|return
name|weight
return|;
block|}
comment|/**    * Returns this searchers the top-level {@link IndexReaderContext}.    * @see IndexReader#getContext()    */
comment|/* sugar for #getReader().getTopReaderContext() */
DECL|method|getTopReaderContext
specifier|public
name|IndexReaderContext
name|getTopReaderContext
parameter_list|()
block|{
return|return
name|readerContext
return|;
block|}
comment|/**    * A thread subclass for searching a single searchable     */
DECL|class|SearcherCallableNoSort
specifier|private
specifier|static
specifier|final
class|class
name|SearcherCallableNoSort
implements|implements
name|Callable
argument_list|<
name|TopDocs
argument_list|>
block|{
DECL|field|lock
specifier|private
specifier|final
name|Lock
name|lock
decl_stmt|;
DECL|field|searcher
specifier|private
specifier|final
name|IndexSearcher
name|searcher
decl_stmt|;
DECL|field|weight
specifier|private
specifier|final
name|Weight
name|weight
decl_stmt|;
DECL|field|after
specifier|private
specifier|final
name|ScoreDoc
name|after
decl_stmt|;
DECL|field|nDocs
specifier|private
specifier|final
name|int
name|nDocs
decl_stmt|;
DECL|field|hq
specifier|private
specifier|final
name|HitQueue
name|hq
decl_stmt|;
DECL|field|slice
specifier|private
specifier|final
name|LeafSlice
name|slice
decl_stmt|;
DECL|method|SearcherCallableNoSort
specifier|public
name|SearcherCallableNoSort
parameter_list|(
name|Lock
name|lock
parameter_list|,
name|IndexSearcher
name|searcher
parameter_list|,
name|LeafSlice
name|slice
parameter_list|,
name|Weight
name|weight
parameter_list|,
name|ScoreDoc
name|after
parameter_list|,
name|int
name|nDocs
parameter_list|,
name|HitQueue
name|hq
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|=
name|lock
expr_stmt|;
name|this
operator|.
name|searcher
operator|=
name|searcher
expr_stmt|;
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
name|this
operator|.
name|after
operator|=
name|after
expr_stmt|;
name|this
operator|.
name|nDocs
operator|=
name|nDocs
expr_stmt|;
name|this
operator|.
name|hq
operator|=
name|hq
expr_stmt|;
name|this
operator|.
name|slice
operator|=
name|slice
expr_stmt|;
block|}
DECL|method|call
specifier|public
name|TopDocs
name|call
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|TopDocs
name|docs
init|=
name|searcher
operator|.
name|search
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|slice
operator|.
name|leaves
argument_list|)
argument_list|,
name|weight
argument_list|,
name|after
argument_list|,
name|nDocs
argument_list|)
decl_stmt|;
specifier|final
name|ScoreDoc
index|[]
name|scoreDocs
init|=
name|docs
operator|.
name|scoreDocs
decl_stmt|;
comment|//it would be so nice if we had a thread-safe insert
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|scoreDocs
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
comment|// merge scoreDocs into hq
specifier|final
name|ScoreDoc
name|scoreDoc
init|=
name|scoreDocs
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|scoreDoc
operator|==
name|hq
operator|.
name|insertWithOverflow
argument_list|(
name|scoreDoc
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|docs
return|;
block|}
block|}
comment|/**    * A thread subclass for searching a single searchable     */
DECL|class|SearcherCallableWithSort
specifier|private
specifier|static
specifier|final
class|class
name|SearcherCallableWithSort
implements|implements
name|Callable
argument_list|<
name|TopFieldDocs
argument_list|>
block|{
DECL|field|lock
specifier|private
specifier|final
name|Lock
name|lock
decl_stmt|;
DECL|field|searcher
specifier|private
specifier|final
name|IndexSearcher
name|searcher
decl_stmt|;
DECL|field|weight
specifier|private
specifier|final
name|Weight
name|weight
decl_stmt|;
DECL|field|nDocs
specifier|private
specifier|final
name|int
name|nDocs
decl_stmt|;
DECL|field|hq
specifier|private
specifier|final
name|TopFieldCollector
name|hq
decl_stmt|;
DECL|field|sort
specifier|private
specifier|final
name|Sort
name|sort
decl_stmt|;
DECL|field|slice
specifier|private
specifier|final
name|LeafSlice
name|slice
decl_stmt|;
DECL|field|after
specifier|private
specifier|final
name|FieldDoc
name|after
decl_stmt|;
DECL|field|doDocScores
specifier|private
specifier|final
name|boolean
name|doDocScores
decl_stmt|;
DECL|field|doMaxScore
specifier|private
specifier|final
name|boolean
name|doMaxScore
decl_stmt|;
DECL|method|SearcherCallableWithSort
specifier|public
name|SearcherCallableWithSort
parameter_list|(
name|Lock
name|lock
parameter_list|,
name|IndexSearcher
name|searcher
parameter_list|,
name|LeafSlice
name|slice
parameter_list|,
name|Weight
name|weight
parameter_list|,
name|FieldDoc
name|after
parameter_list|,
name|int
name|nDocs
parameter_list|,
name|TopFieldCollector
name|hq
parameter_list|,
name|Sort
name|sort
parameter_list|,
name|boolean
name|doDocScores
parameter_list|,
name|boolean
name|doMaxScore
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|=
name|lock
expr_stmt|;
name|this
operator|.
name|searcher
operator|=
name|searcher
expr_stmt|;
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
name|this
operator|.
name|nDocs
operator|=
name|nDocs
expr_stmt|;
name|this
operator|.
name|hq
operator|=
name|hq
expr_stmt|;
name|this
operator|.
name|sort
operator|=
name|sort
expr_stmt|;
name|this
operator|.
name|slice
operator|=
name|slice
expr_stmt|;
name|this
operator|.
name|after
operator|=
name|after
expr_stmt|;
name|this
operator|.
name|doDocScores
operator|=
name|doDocScores
expr_stmt|;
name|this
operator|.
name|doMaxScore
operator|=
name|doMaxScore
expr_stmt|;
block|}
DECL|class|FakeScorer
specifier|private
specifier|final
class|class
name|FakeScorer
extends|extends
name|Scorer
block|{
DECL|field|score
name|float
name|score
decl_stmt|;
DECL|field|doc
name|int
name|doc
decl_stmt|;
DECL|method|FakeScorer
specifier|public
name|FakeScorer
parameter_list|()
block|{
name|super
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|score
specifier|public
name|float
name|score
parameter_list|()
block|{
return|return
name|score
return|;
block|}
block|}
DECL|field|fakeScorer
specifier|private
specifier|final
name|FakeScorer
name|fakeScorer
init|=
operator|new
name|FakeScorer
argument_list|()
decl_stmt|;
DECL|method|call
specifier|public
name|TopFieldDocs
name|call
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|slice
operator|.
name|leaves
operator|.
name|length
operator|==
literal|1
assert|;
specifier|final
name|TopFieldDocs
name|docs
init|=
name|searcher
operator|.
name|search
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|slice
operator|.
name|leaves
argument_list|)
argument_list|,
name|weight
argument_list|,
name|after
argument_list|,
name|nDocs
argument_list|,
name|sort
argument_list|,
literal|true
argument_list|,
name|doDocScores
argument_list|,
name|doMaxScore
argument_list|)
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|AtomicReaderContext
name|ctx
init|=
name|slice
operator|.
name|leaves
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|int
name|base
init|=
name|ctx
operator|.
name|docBase
decl_stmt|;
name|hq
operator|.
name|setNextReader
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|hq
operator|.
name|setScorer
argument_list|(
name|fakeScorer
argument_list|)
expr_stmt|;
for|for
control|(
name|ScoreDoc
name|scoreDoc
range|:
name|docs
operator|.
name|scoreDocs
control|)
block|{
name|fakeScorer
operator|.
name|doc
operator|=
name|scoreDoc
operator|.
name|doc
operator|-
name|base
expr_stmt|;
name|fakeScorer
operator|.
name|score
operator|=
name|scoreDoc
operator|.
name|score
expr_stmt|;
name|hq
operator|.
name|collect
argument_list|(
name|scoreDoc
operator|.
name|doc
operator|-
name|base
argument_list|)
expr_stmt|;
block|}
comment|// Carry over maxScore from sub:
if|if
condition|(
name|doMaxScore
operator|&&
name|docs
operator|.
name|getMaxScore
argument_list|()
operator|>
name|hq
operator|.
name|maxScore
condition|)
block|{
name|hq
operator|.
name|maxScore
operator|=
name|docs
operator|.
name|getMaxScore
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|docs
return|;
block|}
block|}
comment|/**    * A helper class that wraps a {@link CompletionService} and provides an    * iterable interface to the completed {@link Callable} instances.    *     * @param<T>    *          the type of the {@link Callable} return value    */
DECL|class|ExecutionHelper
specifier|private
specifier|static
specifier|final
class|class
name|ExecutionHelper
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Iterator
argument_list|<
name|T
argument_list|>
implements|,
name|Iterable
argument_list|<
name|T
argument_list|>
block|{
DECL|field|service
specifier|private
specifier|final
name|CompletionService
argument_list|<
name|T
argument_list|>
name|service
decl_stmt|;
DECL|field|numTasks
specifier|private
name|int
name|numTasks
decl_stmt|;
DECL|method|ExecutionHelper
name|ExecutionHelper
parameter_list|(
specifier|final
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|service
operator|=
operator|new
name|ExecutorCompletionService
argument_list|<
name|T
argument_list|>
argument_list|(
name|executor
argument_list|)
expr_stmt|;
block|}
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|numTasks
operator|>
literal|0
return|;
block|}
DECL|method|submit
specifier|public
name|void
name|submit
parameter_list|(
name|Callable
argument_list|<
name|T
argument_list|>
name|task
parameter_list|)
block|{
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
name|task
argument_list|)
expr_stmt|;
operator|++
name|numTasks
expr_stmt|;
block|}
DECL|method|next
specifier|public
name|T
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|hasNext
argument_list|()
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
try|try
block|{
return|return
name|service
operator|.
name|take
argument_list|()
operator|.
name|get
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ThreadInterruptedException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
operator|--
name|numTasks
expr_stmt|;
block|}
block|}
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
comment|// use the shortcut here - this is only used in a private context
return|return
name|this
return|;
block|}
block|}
comment|/**    * A class holding a subset of the {@link IndexSearcher}s leaf contexts to be    * executed within a single thread.    *     * @lucene.experimental    */
DECL|class|LeafSlice
specifier|public
specifier|static
class|class
name|LeafSlice
block|{
DECL|field|leaves
specifier|final
name|AtomicReaderContext
index|[]
name|leaves
decl_stmt|;
DECL|method|LeafSlice
specifier|public
name|LeafSlice
parameter_list|(
name|AtomicReaderContext
modifier|...
name|leaves
parameter_list|)
block|{
name|this
operator|.
name|leaves
operator|=
name|leaves
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"IndexSearcher("
operator|+
name|reader
operator|+
literal|"; executor="
operator|+
name|executor
operator|+
literal|")"
return|;
block|}
comment|/**    * Returns {@link TermStatistics} for a term.    *     * This can be overridden for example, to return a term's statistics    * across a distributed collection.    * @lucene.experimental    */
DECL|method|termStatistics
specifier|public
name|TermStatistics
name|termStatistics
parameter_list|(
name|Term
name|term
parameter_list|,
name|TermContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|TermStatistics
argument_list|(
name|term
operator|.
name|bytes
argument_list|()
argument_list|,
name|context
operator|.
name|docFreq
argument_list|()
argument_list|,
name|context
operator|.
name|totalTermFreq
argument_list|()
argument_list|)
return|;
block|}
empty_stmt|;
comment|/**    * Returns {@link CollectionStatistics} for a field.    *     * This can be overridden for example, to return a field's statistics    * across a distributed collection.    * @lucene.experimental    */
DECL|method|collectionStatistics
specifier|public
name|CollectionStatistics
name|collectionStatistics
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|docCount
decl_stmt|;
specifier|final
name|long
name|sumTotalTermFreq
decl_stmt|;
specifier|final
name|long
name|sumDocFreq
decl_stmt|;
assert|assert
name|field
operator|!=
literal|null
assert|;
name|Terms
name|terms
init|=
name|MultiFields
operator|.
name|getTerms
argument_list|(
name|reader
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|==
literal|null
condition|)
block|{
name|docCount
operator|=
literal|0
expr_stmt|;
name|sumTotalTermFreq
operator|=
literal|0
expr_stmt|;
name|sumDocFreq
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|docCount
operator|=
name|terms
operator|.
name|getDocCount
argument_list|()
expr_stmt|;
name|sumTotalTermFreq
operator|=
name|terms
operator|.
name|getSumTotalTermFreq
argument_list|()
expr_stmt|;
name|sumDocFreq
operator|=
name|terms
operator|.
name|getSumDocFreq
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|CollectionStatistics
argument_list|(
name|field
argument_list|,
name|reader
operator|.
name|maxDoc
argument_list|()
argument_list|,
name|docCount
argument_list|,
name|sumTotalTermFreq
argument_list|,
name|sumDocFreq
argument_list|)
return|;
block|}
block|}
end_class
end_unit
