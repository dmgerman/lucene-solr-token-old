begin_unit
begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|NumericTokenStream
import|;
end_import
begin_comment
comment|// for javadocs
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|DoubleField
import|;
end_import
begin_comment
comment|// for javadocs
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|FloatField
import|;
end_import
begin_comment
comment|// for javadocs
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|IntField
import|;
end_import
begin_comment
comment|// for javadocs
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|LongField
import|;
end_import
begin_comment
comment|// for javadocs
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|AtomicReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|BinaryDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocTermOrds
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SortedDocValues
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|NumericUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_comment
comment|/**  * Expert: Maintains caches of term values.  *  *<p>Created: May 19, 2004 11:13:14 AM  *  * @since   lucene 1.4  * @see org.apache.lucene.util.FieldCacheSanityChecker  *  * @lucene.internal  */
end_comment
begin_interface
DECL|interface|FieldCache
specifier|public
interface|interface
name|FieldCache
block|{
comment|/** Field values as 8-bit signed bytes */
DECL|class|Bytes
specifier|public
specifier|static
specifier|abstract
class|class
name|Bytes
block|{
comment|/** Return a single Byte representation of this field's value. */
DECL|method|get
specifier|public
specifier|abstract
name|byte
name|get
parameter_list|(
name|int
name|docID
parameter_list|)
function_decl|;
block|}
comment|/** Field values as 16-bit signed shorts */
DECL|class|Shorts
specifier|public
specifier|static
specifier|abstract
class|class
name|Shorts
block|{
comment|/** Return a short representation of this field's value. */
DECL|method|get
specifier|public
specifier|abstract
name|short
name|get
parameter_list|(
name|int
name|docID
parameter_list|)
function_decl|;
block|}
comment|/** Field values as 32-bit signed integers */
DECL|class|Ints
specifier|public
specifier|static
specifier|abstract
class|class
name|Ints
block|{
comment|/** Return an integer representation of this field's value. */
DECL|method|get
specifier|public
specifier|abstract
name|int
name|get
parameter_list|(
name|int
name|docID
parameter_list|)
function_decl|;
block|}
comment|/** Field values as 32-bit signed long integers */
DECL|class|Longs
specifier|public
specifier|static
specifier|abstract
class|class
name|Longs
block|{
comment|/** Return an long representation of this field's value. */
DECL|method|get
specifier|public
specifier|abstract
name|long
name|get
parameter_list|(
name|int
name|docID
parameter_list|)
function_decl|;
block|}
comment|/** Field values as 32-bit floats */
DECL|class|Floats
specifier|public
specifier|static
specifier|abstract
class|class
name|Floats
block|{
comment|/** Return an float representation of this field's value. */
DECL|method|get
specifier|public
specifier|abstract
name|float
name|get
parameter_list|(
name|int
name|docID
parameter_list|)
function_decl|;
block|}
comment|/** Field values as 64-bit doubles */
DECL|class|Doubles
specifier|public
specifier|static
specifier|abstract
class|class
name|Doubles
block|{
comment|/** Return an double representation of this field's value. */
DECL|method|get
specifier|public
specifier|abstract
name|double
name|get
parameter_list|(
name|int
name|docID
parameter_list|)
function_decl|;
block|}
comment|/**    * Placeholder indicating creation of this cache is currently in-progress.    */
DECL|class|CreationPlaceholder
specifier|public
specifier|static
specifier|final
class|class
name|CreationPlaceholder
block|{
DECL|field|value
name|Object
name|value
decl_stmt|;
block|}
comment|/**    * Marker interface as super-interface to all parsers. It    * is used to specify a custom parser to {@link    * SortField#SortField(String, FieldCache.Parser)}.    */
DECL|interface|Parser
specifier|public
interface|interface
name|Parser
block|{
comment|/**      * Pulls a {@link TermsEnum} from the given {@link Terms}. This method allows certain parsers      * to filter the actual TermsEnum before the field cache is filled.      *       * @param terms the {@link Terms} instance to create the {@link TermsEnum} from.      * @return a possibly filtered {@link TermsEnum} instance, this method must not return<code>null</code>.      * @throws IOException if an {@link IOException} occurs      */
DECL|method|termsEnum
specifier|public
name|TermsEnum
name|termsEnum
parameter_list|(
name|Terms
name|terms
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
comment|/** Interface to parse bytes from document fields.    * @see FieldCache#getBytes(AtomicReader, String, FieldCache.ByteParser, boolean)    */
DECL|interface|ByteParser
specifier|public
interface|interface
name|ByteParser
extends|extends
name|Parser
block|{
comment|/** Return a single Byte representation of this field's value. */
DECL|method|parseByte
specifier|public
name|byte
name|parseByte
parameter_list|(
name|BytesRef
name|term
parameter_list|)
function_decl|;
block|}
comment|/** Interface to parse shorts from document fields.    * @see FieldCache#getShorts(AtomicReader, String, FieldCache.ShortParser, boolean)    */
DECL|interface|ShortParser
specifier|public
interface|interface
name|ShortParser
extends|extends
name|Parser
block|{
comment|/** Return a short representation of this field's value. */
DECL|method|parseShort
specifier|public
name|short
name|parseShort
parameter_list|(
name|BytesRef
name|term
parameter_list|)
function_decl|;
block|}
comment|/** Interface to parse ints from document fields.    * @see FieldCache#getInts(AtomicReader, String, FieldCache.IntParser, boolean)    */
DECL|interface|IntParser
specifier|public
interface|interface
name|IntParser
extends|extends
name|Parser
block|{
comment|/** Return an integer representation of this field's value. */
DECL|method|parseInt
specifier|public
name|int
name|parseInt
parameter_list|(
name|BytesRef
name|term
parameter_list|)
function_decl|;
block|}
comment|/** Interface to parse floats from document fields.    * @see FieldCache#getFloats(AtomicReader, String, FieldCache.FloatParser, boolean)    */
DECL|interface|FloatParser
specifier|public
interface|interface
name|FloatParser
extends|extends
name|Parser
block|{
comment|/** Return an float representation of this field's value. */
DECL|method|parseFloat
specifier|public
name|float
name|parseFloat
parameter_list|(
name|BytesRef
name|term
parameter_list|)
function_decl|;
block|}
comment|/** Interface to parse long from document fields.    * @see FieldCache#getLongs(AtomicReader, String, FieldCache.LongParser, boolean)    */
DECL|interface|LongParser
specifier|public
interface|interface
name|LongParser
extends|extends
name|Parser
block|{
comment|/** Return an long representation of this field's value. */
DECL|method|parseLong
specifier|public
name|long
name|parseLong
parameter_list|(
name|BytesRef
name|term
parameter_list|)
function_decl|;
block|}
comment|/** Interface to parse doubles from document fields.    * @see FieldCache#getDoubles(AtomicReader, String, FieldCache.DoubleParser, boolean)    */
DECL|interface|DoubleParser
specifier|public
interface|interface
name|DoubleParser
extends|extends
name|Parser
block|{
comment|/** Return an double representation of this field's value. */
DECL|method|parseDouble
specifier|public
name|double
name|parseDouble
parameter_list|(
name|BytesRef
name|term
parameter_list|)
function_decl|;
block|}
comment|/** Expert: The cache used internally by sorting and range query classes. */
DECL|field|DEFAULT
specifier|public
specifier|static
name|FieldCache
name|DEFAULT
init|=
operator|new
name|FieldCacheImpl
argument_list|()
decl_stmt|;
comment|/** The default parser for byte values, which are encoded by {@link Byte#toString(byte)} */
DECL|field|DEFAULT_BYTE_PARSER
specifier|public
specifier|static
specifier|final
name|ByteParser
name|DEFAULT_BYTE_PARSER
init|=
operator|new
name|ByteParser
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|byte
name|parseByte
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
comment|// TODO: would be far better to directly parse from
comment|// UTF8 bytes... but really users should use
comment|// IntField, instead, which already decodes
comment|// directly from byte[]
return|return
name|Byte
operator|.
name|parseByte
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".DEFAULT_BYTE_PARSER"
return|;
block|}
annotation|@
name|Override
specifier|public
name|TermsEnum
name|termsEnum
parameter_list|(
name|Terms
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/** The default parser for short values, which are encoded by {@link Short#toString(short)} */
DECL|field|DEFAULT_SHORT_PARSER
specifier|public
specifier|static
specifier|final
name|ShortParser
name|DEFAULT_SHORT_PARSER
init|=
operator|new
name|ShortParser
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|short
name|parseShort
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
comment|// TODO: would be far better to directly parse from
comment|// UTF8 bytes... but really users should use
comment|// IntField, instead, which already decodes
comment|// directly from byte[]
return|return
name|Short
operator|.
name|parseShort
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".DEFAULT_SHORT_PARSER"
return|;
block|}
annotation|@
name|Override
specifier|public
name|TermsEnum
name|termsEnum
parameter_list|(
name|Terms
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/** The default parser for int values, which are encoded by {@link Integer#toString(int)} */
DECL|field|DEFAULT_INT_PARSER
specifier|public
specifier|static
specifier|final
name|IntParser
name|DEFAULT_INT_PARSER
init|=
operator|new
name|IntParser
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|parseInt
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
comment|// TODO: would be far better to directly parse from
comment|// UTF8 bytes... but really users should use
comment|// IntField, instead, which already decodes
comment|// directly from byte[]
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|TermsEnum
name|termsEnum
parameter_list|(
name|Terms
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".DEFAULT_INT_PARSER"
return|;
block|}
block|}
decl_stmt|;
comment|/** The default parser for float values, which are encoded by {@link Float#toString(float)} */
DECL|field|DEFAULT_FLOAT_PARSER
specifier|public
specifier|static
specifier|final
name|FloatParser
name|DEFAULT_FLOAT_PARSER
init|=
operator|new
name|FloatParser
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|float
name|parseFloat
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
comment|// TODO: would be far better to directly parse from
comment|// UTF8 bytes... but really users should use
comment|// FloatField, instead, which already decodes
comment|// directly from byte[]
return|return
name|Float
operator|.
name|parseFloat
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|TermsEnum
name|termsEnum
parameter_list|(
name|Terms
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".DEFAULT_FLOAT_PARSER"
return|;
block|}
block|}
decl_stmt|;
comment|/** The default parser for long values, which are encoded by {@link Long#toString(long)} */
DECL|field|DEFAULT_LONG_PARSER
specifier|public
specifier|static
specifier|final
name|LongParser
name|DEFAULT_LONG_PARSER
init|=
operator|new
name|LongParser
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|long
name|parseLong
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
comment|// TODO: would be far better to directly parse from
comment|// UTF8 bytes... but really users should use
comment|// LongField, instead, which already decodes
comment|// directly from byte[]
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|TermsEnum
name|termsEnum
parameter_list|(
name|Terms
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".DEFAULT_LONG_PARSER"
return|;
block|}
block|}
decl_stmt|;
comment|/** The default parser for double values, which are encoded by {@link Double#toString(double)} */
DECL|field|DEFAULT_DOUBLE_PARSER
specifier|public
specifier|static
specifier|final
name|DoubleParser
name|DEFAULT_DOUBLE_PARSER
init|=
operator|new
name|DoubleParser
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|double
name|parseDouble
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
comment|// TODO: would be far better to directly parse from
comment|// UTF8 bytes... but really users should use
comment|// DoubleField, instead, which already decodes
comment|// directly from byte[]
return|return
name|Double
operator|.
name|parseDouble
argument_list|(
name|term
operator|.
name|utf8ToString
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|TermsEnum
name|termsEnum
parameter_list|(
name|Terms
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".DEFAULT_DOUBLE_PARSER"
return|;
block|}
block|}
decl_stmt|;
comment|/**    * A parser instance for int values encoded by {@link NumericUtils}, e.g. when indexed    * via {@link IntField}/{@link NumericTokenStream}.    */
DECL|field|NUMERIC_UTILS_INT_PARSER
specifier|public
specifier|static
specifier|final
name|IntParser
name|NUMERIC_UTILS_INT_PARSER
init|=
operator|new
name|IntParser
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|parseInt
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
return|return
name|NumericUtils
operator|.
name|prefixCodedToInt
argument_list|(
name|term
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|TermsEnum
name|termsEnum
parameter_list|(
name|Terms
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|NumericUtils
operator|.
name|filterPrefixCodedInts
argument_list|(
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".NUMERIC_UTILS_INT_PARSER"
return|;
block|}
block|}
decl_stmt|;
comment|/**    * A parser instance for float values encoded with {@link NumericUtils}, e.g. when indexed    * via {@link FloatField}/{@link NumericTokenStream}.    */
DECL|field|NUMERIC_UTILS_FLOAT_PARSER
specifier|public
specifier|static
specifier|final
name|FloatParser
name|NUMERIC_UTILS_FLOAT_PARSER
init|=
operator|new
name|FloatParser
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|float
name|parseFloat
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
return|return
name|NumericUtils
operator|.
name|sortableIntToFloat
argument_list|(
name|NumericUtils
operator|.
name|prefixCodedToInt
argument_list|(
name|term
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".NUMERIC_UTILS_FLOAT_PARSER"
return|;
block|}
annotation|@
name|Override
specifier|public
name|TermsEnum
name|termsEnum
parameter_list|(
name|Terms
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|NumericUtils
operator|.
name|filterPrefixCodedInts
argument_list|(
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * A parser instance for long values encoded by {@link NumericUtils}, e.g. when indexed    * via {@link LongField}/{@link NumericTokenStream}.    */
DECL|field|NUMERIC_UTILS_LONG_PARSER
specifier|public
specifier|static
specifier|final
name|LongParser
name|NUMERIC_UTILS_LONG_PARSER
init|=
operator|new
name|LongParser
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|long
name|parseLong
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
return|return
name|NumericUtils
operator|.
name|prefixCodedToLong
argument_list|(
name|term
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".NUMERIC_UTILS_LONG_PARSER"
return|;
block|}
annotation|@
name|Override
specifier|public
name|TermsEnum
name|termsEnum
parameter_list|(
name|Terms
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|NumericUtils
operator|.
name|filterPrefixCodedLongs
argument_list|(
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * A parser instance for double values encoded with {@link NumericUtils}, e.g. when indexed    * via {@link DoubleField}/{@link NumericTokenStream}.    */
DECL|field|NUMERIC_UTILS_DOUBLE_PARSER
specifier|public
specifier|static
specifier|final
name|DoubleParser
name|NUMERIC_UTILS_DOUBLE_PARSER
init|=
operator|new
name|DoubleParser
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|double
name|parseDouble
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
return|return
name|NumericUtils
operator|.
name|sortableLongToDouble
argument_list|(
name|NumericUtils
operator|.
name|prefixCodedToLong
argument_list|(
name|term
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|FieldCache
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".NUMERIC_UTILS_DOUBLE_PARSER"
return|;
block|}
annotation|@
name|Override
specifier|public
name|TermsEnum
name|termsEnum
parameter_list|(
name|Terms
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|NumericUtils
operator|.
name|filterPrefixCodedLongs
argument_list|(
name|terms
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/** Checks the internal cache for an appropriate entry, and if none is found,    *  reads the terms in<code>field</code> and returns a bit set at the size of    *<code>reader.maxDoc()</code>, with turned on bits for each docid that     *  does have a value for this field.  Note that if the field was only indexed    *  as DocValues then this method will not work (it will return a Bits stating    *  that no documents contain the field).    */
DECL|method|getDocsWithField
specifier|public
name|Bits
name|getDocsWithField
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if none is    * found, reads the terms in<code>field</code> as a single byte and returns an array    * of size<code>reader.maxDoc()</code> of the value each document    * has in the given field.    * @param reader  Used to get field values.    * @param field   Which field contains the single byte values.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getBytes
specifier|public
name|Bytes
name|getBytes
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if none is found,    * reads the terms in<code>field</code> as bytes and returns an array of    * size<code>reader.maxDoc()</code> of the value each document has in the    * given field.    * @param reader  Used to get field values.    * @param field   Which field contains the bytes.    * @param parser  Computes byte for string values.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getBytes
specifier|public
name|Bytes
name|getBytes
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|ByteParser
name|parser
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if none is    * found, reads the terms in<code>field</code> as shorts and returns an array    * of size<code>reader.maxDoc()</code> of the value each document    * has in the given field.    * @param reader  Used to get field values.    * @param field   Which field contains the shorts.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getShorts
specifier|public
name|Shorts
name|getShorts
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if none is found,    * reads the terms in<code>field</code> as shorts and returns an array of    * size<code>reader.maxDoc()</code> of the value each document has in the    * given field.    * @param reader  Used to get field values.    * @param field   Which field contains the shorts.    * @param parser  Computes short for string values.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getShorts
specifier|public
name|Shorts
name|getShorts
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|ShortParser
name|parser
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if none is    * found, reads the terms in<code>field</code> as integers and returns an array    * of size<code>reader.maxDoc()</code> of the value each document    * has in the given field.    * @param reader  Used to get field values.    * @param field   Which field contains the integers.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getInts
specifier|public
name|Ints
name|getInts
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if none is found,    * reads the terms in<code>field</code> as integers and returns an array of    * size<code>reader.maxDoc()</code> of the value each document has in the    * given field.    * @param reader  Used to get field values.    * @param field   Which field contains the integers.    * @param parser  Computes integer for string values.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getInts
specifier|public
name|Ints
name|getInts
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|IntParser
name|parser
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if    * none is found, reads the terms in<code>field</code> as floats and returns an array    * of size<code>reader.maxDoc()</code> of the value each document    * has in the given field.    * @param reader  Used to get field values.    * @param field   Which field contains the floats.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getFloats
specifier|public
name|Floats
name|getFloats
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if    * none is found, reads the terms in<code>field</code> as floats and returns an array    * of size<code>reader.maxDoc()</code> of the value each document    * has in the given field.    * @param reader  Used to get field values.    * @param field   Which field contains the floats.    * @param parser  Computes float for string values.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getFloats
specifier|public
name|Floats
name|getFloats
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|FloatParser
name|parser
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Checks the internal cache for an appropriate entry, and if none is    * found, reads the terms in<code>field</code> as longs and returns an array    * of size<code>reader.maxDoc()</code> of the value each document    * has in the given field.    *    * @param reader Used to get field values.    * @param field  Which field contains the longs.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws java.io.IOException If any error occurs.    */
DECL|method|getLongs
specifier|public
name|Longs
name|getLongs
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Checks the internal cache for an appropriate entry, and if none is found,    * reads the terms in<code>field</code> as longs and returns an array of    * size<code>reader.maxDoc()</code> of the value each document has in the    * given field.    *    * @param reader Used to get field values.    * @param field  Which field contains the longs.    * @param parser Computes integer for string values.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException If any error occurs.    */
DECL|method|getLongs
specifier|public
name|Longs
name|getLongs
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|LongParser
name|parser
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Checks the internal cache for an appropriate entry, and if none is    * found, reads the terms in<code>field</code> as integers and returns an array    * of size<code>reader.maxDoc()</code> of the value each document    * has in the given field.    *    * @param reader Used to get field values.    * @param field  Which field contains the doubles.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException If any error occurs.    */
DECL|method|getDoubles
specifier|public
name|Doubles
name|getDoubles
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Checks the internal cache for an appropriate entry, and if none is found,    * reads the terms in<code>field</code> as doubles and returns an array of    * size<code>reader.maxDoc()</code> of the value each document has in the    * given field.    *    * @param reader Used to get field values.    * @param field  Which field contains the doubles.    * @param parser Computes integer for string values.    * @param setDocsWithField  If true then {@link #getDocsWithField} will    *        also be computed and stored in the FieldCache.    * @return The values in the given field for each document.    * @throws IOException If any error occurs.    */
DECL|method|getDoubles
specifier|public
name|Doubles
name|getDoubles
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|DoubleParser
name|parser
parameter_list|,
name|boolean
name|setDocsWithField
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if none    * is found, reads the term values in<code>field</code>    * and returns a {@link BinaryDocValues} instance, providing a    * method to retrieve the term (as a BytesRef) per document.    * @param reader  Used to get field values.    * @param field   Which field contains the strings.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getTerms
specifier|public
name|BinaryDocValues
name|getTerms
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Expert: just like {@link #getTerms(AtomicReader,String)},    *  but you can specify whether more RAM should be consumed in exchange for    *  faster lookups (default is "true").  Note that the    *  first call for a given reader and field "wins",    *  subsequent calls will share the same cache entry. */
DECL|method|getTerms
specifier|public
name|BinaryDocValues
name|getTerms
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|float
name|acceptableOverheadRatio
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Checks the internal cache for an appropriate entry, and if none    * is found, reads the term values in<code>field</code>    * and returns a {@link SortedDocValues} instance,    * providing methods to retrieve sort ordinals and terms    * (as a ByteRef) per document.    * @param reader  Used to get field values.    * @param field   Which field contains the strings.    * @return The values in the given field for each document.    * @throws IOException  If any error occurs.    */
DECL|method|getTermsIndex
specifier|public
name|SortedDocValues
name|getTermsIndex
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Expert: just like {@link    *  #getTermsIndex(AtomicReader,String)}, but you can specify    *  whether more RAM should be consumed in exchange for    *  faster lookups (default is "true").  Note that the    *  first call for a given reader and field "wins",    *  subsequent calls will share the same cache entry. */
DECL|method|getTermsIndex
specifier|public
name|SortedDocValues
name|getTermsIndex
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|,
name|float
name|acceptableOverheadRatio
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Checks the internal cache for an appropriate entry, and if none is found, reads the term values    * in<code>field</code> and returns a {@link DocTermOrds} instance, providing a method to retrieve    * the terms (as ords) per document.    *    * @param reader  Used to build a {@link DocTermOrds} instance    * @param field   Which field contains the strings.    * @return a {@link DocTermOrds} instance    * @throws IOException  If any error occurs.    */
DECL|method|getDocTermOrds
specifier|public
name|DocTermOrds
name|getDocTermOrds
parameter_list|(
name|AtomicReader
name|reader
parameter_list|,
name|String
name|field
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * EXPERT: A unique Identifier/Description for each item in the FieldCache.     * Can be useful for logging/debugging.    * @lucene.experimental    */
DECL|class|CacheEntry
specifier|public
specifier|final
class|class
name|CacheEntry
block|{
DECL|field|readerKey
specifier|private
specifier|final
name|Object
name|readerKey
decl_stmt|;
DECL|field|fieldName
specifier|private
specifier|final
name|String
name|fieldName
decl_stmt|;
DECL|field|cacheType
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|cacheType
decl_stmt|;
DECL|field|custom
specifier|private
specifier|final
name|Object
name|custom
decl_stmt|;
DECL|field|value
specifier|private
specifier|final
name|Object
name|value
decl_stmt|;
DECL|field|size
specifier|private
name|String
name|size
decl_stmt|;
DECL|method|CacheEntry
specifier|public
name|CacheEntry
parameter_list|(
name|Object
name|readerKey
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|cacheType
parameter_list|,
name|Object
name|custom
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|this
operator|.
name|readerKey
operator|=
name|readerKey
expr_stmt|;
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
name|this
operator|.
name|cacheType
operator|=
name|cacheType
expr_stmt|;
name|this
operator|.
name|custom
operator|=
name|custom
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
DECL|method|getReaderKey
specifier|public
name|Object
name|getReaderKey
parameter_list|()
block|{
return|return
name|readerKey
return|;
block|}
DECL|method|getFieldName
specifier|public
name|String
name|getFieldName
parameter_list|()
block|{
return|return
name|fieldName
return|;
block|}
DECL|method|getCacheType
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
name|getCacheType
parameter_list|()
block|{
return|return
name|cacheType
return|;
block|}
DECL|method|getCustom
specifier|public
name|Object
name|getCustom
parameter_list|()
block|{
return|return
name|custom
return|;
block|}
DECL|method|getValue
specifier|public
name|Object
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
comment|/**       * Computes (and stores) the estimated size of the cache Value       * @see #getEstimatedSize      */
DECL|method|estimateSize
specifier|public
name|void
name|estimateSize
parameter_list|()
block|{
name|long
name|bytesUsed
init|=
name|RamUsageEstimator
operator|.
name|sizeOf
argument_list|(
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|size
operator|=
name|RamUsageEstimator
operator|.
name|humanReadableUnits
argument_list|(
name|bytesUsed
argument_list|)
expr_stmt|;
block|}
comment|/**      * The most recently estimated size of the value, null unless       * estimateSize has been called.      */
DECL|method|getEstimatedSize
specifier|public
name|String
name|getEstimatedSize
parameter_list|()
block|{
return|return
name|size
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
operator|.
name|append
argument_list|(
name|getReaderKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"'=>"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
operator|.
name|append
argument_list|(
name|getFieldName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"',"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|getCacheType
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
operator|.
name|append
argument_list|(
name|getCustom
argument_list|()
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"=>"
argument_list|)
operator|.
name|append
argument_list|(
name|getValue
argument_list|()
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"#"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|System
operator|.
name|identityHashCode
argument_list|(
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|s
init|=
name|getEstimatedSize
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|s
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" (size =~ "
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * EXPERT: Generates an array of CacheEntry objects representing all items     * currently in the FieldCache.    *<p>    * NOTE: These CacheEntry objects maintain a strong reference to the     * Cached Values.  Maintaining references to a CacheEntry the AtomicIndexReader     * associated with it has garbage collected will prevent the Value itself    * from being garbage collected when the Cache drops the WeakReference.    *</p>    * @lucene.experimental    */
DECL|method|getCacheEntries
specifier|public
specifier|abstract
name|CacheEntry
index|[]
name|getCacheEntries
parameter_list|()
function_decl|;
comment|/**    *<p>    * EXPERT: Instructs the FieldCache to forcibly expunge all entries     * from the underlying caches.  This is intended only to be used for     * test methods as a way to ensure a known base state of the Cache     * (with out needing to rely on GC to free WeakReferences).      * It should not be relied on for "Cache maintenance" in general     * application code.    *</p>    * @lucene.experimental    */
DECL|method|purgeAllCaches
specifier|public
specifier|abstract
name|void
name|purgeAllCaches
parameter_list|()
function_decl|;
comment|/**    * Expert: drops all cache entries associated with this    * reader.  NOTE: this reader must precisely match the    * reader that the cache entry is keyed on. If you pass a    * top-level reader, it usually will have no effect as    * Lucene now caches at the segment reader level.    */
DECL|method|purge
specifier|public
specifier|abstract
name|void
name|purge
parameter_list|(
name|AtomicReader
name|r
parameter_list|)
function_decl|;
comment|/**    * If non-null, FieldCacheImpl will warn whenever    * entries are created that are not sane according to    * {@link org.apache.lucene.util.FieldCacheSanityChecker}.    */
DECL|method|setInfoStream
specifier|public
name|void
name|setInfoStream
parameter_list|(
name|PrintStream
name|stream
parameter_list|)
function_decl|;
comment|/** counterpart of {@link #setInfoStream(PrintStream)} */
DECL|method|getInfoStream
specifier|public
name|PrintStream
name|getInfoStream
parameter_list|()
function_decl|;
block|}
end_interface
end_unit
