begin_unit
begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|OpenBitSet
import|;
end_import
begin_class
DECL|class|SloppyPhraseScorer
specifier|final
class|class
name|SloppyPhraseScorer
extends|extends
name|Scorer
block|{
DECL|field|min
DECL|field|max
specifier|private
name|PhrasePositions
name|min
decl_stmt|,
name|max
decl_stmt|;
DECL|field|sloppyFreq
specifier|private
name|float
name|sloppyFreq
decl_stmt|;
comment|//phrase frequency in current doc as computed by phraseFreq().
DECL|field|docScorer
specifier|private
specifier|final
name|Similarity
operator|.
name|SimScorer
name|docScorer
decl_stmt|;
DECL|field|slop
specifier|private
specifier|final
name|int
name|slop
decl_stmt|;
DECL|field|numPostings
specifier|private
specifier|final
name|int
name|numPostings
decl_stmt|;
DECL|field|pq
specifier|private
specifier|final
name|PhraseQueue
name|pq
decl_stmt|;
comment|// for advancing min position
DECL|field|end
specifier|private
name|int
name|end
decl_stmt|;
comment|// current largest phrase position
DECL|field|hasRpts
specifier|private
name|boolean
name|hasRpts
decl_stmt|;
comment|// flag indicating that there are repetitions (as checked in first candidate doc)
DECL|field|checkedRpts
specifier|private
name|boolean
name|checkedRpts
decl_stmt|;
comment|// flag to only check for repetitions in first candidate doc
DECL|field|hasMultiTermRpts
specifier|private
name|boolean
name|hasMultiTermRpts
decl_stmt|;
comment|//
DECL|field|rptGroups
specifier|private
name|PhrasePositions
index|[]
index|[]
name|rptGroups
decl_stmt|;
comment|// in each group are PPs that repeats each other (i.e. same term), sorted by (query) offset
DECL|field|rptStack
specifier|private
name|PhrasePositions
index|[]
name|rptStack
decl_stmt|;
comment|// temporary stack for switching colliding repeating pps
DECL|field|numMatches
specifier|private
name|int
name|numMatches
decl_stmt|;
DECL|field|cost
specifier|private
specifier|final
name|long
name|cost
decl_stmt|;
DECL|method|SloppyPhraseScorer
name|SloppyPhraseScorer
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|PhraseQuery
operator|.
name|PostingsAndFreq
index|[]
name|postings
parameter_list|,
name|int
name|slop
parameter_list|,
name|Similarity
operator|.
name|SimScorer
name|docScorer
parameter_list|)
block|{
name|super
argument_list|(
name|weight
argument_list|)
expr_stmt|;
name|this
operator|.
name|docScorer
operator|=
name|docScorer
expr_stmt|;
name|this
operator|.
name|slop
operator|=
name|slop
expr_stmt|;
name|this
operator|.
name|numPostings
operator|=
name|postings
operator|==
literal|null
condition|?
literal|0
else|:
name|postings
operator|.
name|length
expr_stmt|;
name|pq
operator|=
operator|new
name|PhraseQueue
argument_list|(
name|postings
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// min(cost)
name|cost
operator|=
name|postings
index|[
literal|0
index|]
operator|.
name|postings
operator|.
name|cost
argument_list|()
expr_stmt|;
comment|// convert tps to a list of phrase positions.
comment|// note: phrase-position differs from term-position in that its position
comment|// reflects the phrase offset: pp.pos = tp.pos - offset.
comment|// this allows to easily identify a matching (exact) phrase
comment|// when all PhrasePositions have exactly the same position.
if|if
condition|(
name|postings
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|min
operator|=
operator|new
name|PhrasePositions
argument_list|(
name|postings
index|[
literal|0
index|]
operator|.
name|postings
argument_list|,
name|postings
index|[
literal|0
index|]
operator|.
name|position
argument_list|,
literal|0
argument_list|,
name|postings
index|[
literal|0
index|]
operator|.
name|terms
argument_list|)
expr_stmt|;
name|max
operator|=
name|min
expr_stmt|;
name|max
operator|.
name|doc
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|postings
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|PhrasePositions
name|pp
init|=
operator|new
name|PhrasePositions
argument_list|(
name|postings
index|[
name|i
index|]
operator|.
name|postings
argument_list|,
name|postings
index|[
name|i
index|]
operator|.
name|position
argument_list|,
name|i
argument_list|,
name|postings
index|[
name|i
index|]
operator|.
name|terms
argument_list|)
decl_stmt|;
name|max
operator|.
name|next
operator|=
name|pp
expr_stmt|;
name|max
operator|=
name|pp
expr_stmt|;
name|max
operator|.
name|doc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|max
operator|.
name|next
operator|=
name|min
expr_stmt|;
comment|// make it cyclic for easier manipulation
block|}
block|}
comment|/**    * Score a candidate doc for all slop-valid position-combinations (matches)     * encountered while traversing/hopping the PhrasePositions.    *<br> The score contribution of a match depends on the distance:     *<br> - highest score for distance=0 (exact match).    *<br> - score gets lower as distance gets higher.    *<br>Example: for query "a b"~2, a document "x a b a y" can be scored twice:     * once for "a b" (distance=0), and once for "b a" (distance=2).    *<br>Possibly not all valid combinations are encountered, because for efficiency      * we always propagate the least PhrasePosition. This allows to base on     * PriorityQueue and move forward faster.     * As result, for example, document "a b c b a"    * would score differently for queries "a b c"~4 and "c b a"~4, although     * they really are equivalent.     * Similarly, for doc "a b c b a f g", query "c b"~2     * would get same score as "g f"~2, although "c b"~2 could be matched twice.    * We may want to fix this in the future (currently not, for performance reasons).    */
DECL|method|phraseFreq
specifier|private
name|float
name|phraseFreq
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|initPhrasePositions
argument_list|()
condition|)
block|{
return|return
literal|0.0f
return|;
block|}
name|float
name|freq
init|=
literal|0.0f
decl_stmt|;
name|numMatches
operator|=
literal|0
expr_stmt|;
name|PhrasePositions
name|pp
init|=
name|pq
operator|.
name|pop
argument_list|()
decl_stmt|;
name|int
name|matchLength
init|=
name|end
operator|-
name|pp
operator|.
name|position
decl_stmt|;
name|int
name|next
init|=
name|pq
operator|.
name|top
argument_list|()
operator|.
name|position
decl_stmt|;
while|while
condition|(
name|advancePP
argument_list|(
name|pp
argument_list|)
condition|)
block|{
if|if
condition|(
name|hasRpts
operator|&&
operator|!
name|advanceRpts
argument_list|(
name|pp
argument_list|)
condition|)
block|{
break|break;
comment|// pps exhausted
block|}
if|if
condition|(
name|pp
operator|.
name|position
operator|>
name|next
condition|)
block|{
comment|// done minimizing current match-length
if|if
condition|(
name|matchLength
operator|<=
name|slop
condition|)
block|{
name|freq
operator|+=
name|docScorer
operator|.
name|computeSlopFactor
argument_list|(
name|matchLength
argument_list|)
expr_stmt|;
comment|// score match
name|numMatches
operator|++
expr_stmt|;
block|}
name|pq
operator|.
name|add
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp
operator|=
name|pq
operator|.
name|pop
argument_list|()
expr_stmt|;
name|next
operator|=
name|pq
operator|.
name|top
argument_list|()
operator|.
name|position
expr_stmt|;
name|matchLength
operator|=
name|end
operator|-
name|pp
operator|.
name|position
expr_stmt|;
block|}
else|else
block|{
name|int
name|matchLength2
init|=
name|end
operator|-
name|pp
operator|.
name|position
decl_stmt|;
if|if
condition|(
name|matchLength2
operator|<
name|matchLength
condition|)
block|{
name|matchLength
operator|=
name|matchLength2
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|matchLength
operator|<=
name|slop
condition|)
block|{
name|freq
operator|+=
name|docScorer
operator|.
name|computeSlopFactor
argument_list|(
name|matchLength
argument_list|)
expr_stmt|;
comment|// score match
name|numMatches
operator|++
expr_stmt|;
block|}
return|return
name|freq
return|;
block|}
comment|/** advance a PhrasePosition and update 'end', return false if exhausted */
DECL|method|advancePP
specifier|private
name|boolean
name|advancePP
parameter_list|(
name|PhrasePositions
name|pp
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|pp
operator|.
name|nextPosition
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|pp
operator|.
name|position
operator|>
name|end
condition|)
block|{
name|end
operator|=
name|pp
operator|.
name|position
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/** pp was just advanced. If that caused a repeater collision, resolve by advancing the lesser    * of the two colliding pps. Note that there can only be one collision, as by the initialization    * there were no collisions before pp was advanced.  */
DECL|method|advanceRpts
specifier|private
name|boolean
name|advanceRpts
parameter_list|(
name|PhrasePositions
name|pp
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pp
operator|.
name|rptGroup
operator|<
literal|0
condition|)
block|{
return|return
literal|true
return|;
comment|// not a repeater
block|}
name|PhrasePositions
index|[]
name|rg
init|=
name|rptGroups
index|[
name|pp
operator|.
name|rptGroup
index|]
decl_stmt|;
name|OpenBitSet
name|bits
init|=
operator|new
name|OpenBitSet
argument_list|(
name|rg
operator|.
name|length
argument_list|)
decl_stmt|;
comment|// for re-queuing after collisions are resolved
name|int
name|k0
init|=
name|pp
operator|.
name|rptInd
decl_stmt|;
name|int
name|k
decl_stmt|;
while|while
condition|(
operator|(
name|k
operator|=
name|collide
argument_list|(
name|pp
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|pp
operator|=
name|lesser
argument_list|(
name|pp
argument_list|,
name|rg
index|[
name|k
index|]
argument_list|)
expr_stmt|;
comment|// always advance the lesser of the (only) two colliding pps
if|if
condition|(
operator|!
name|advancePP
argument_list|(
name|pp
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
comment|// exhausted
block|}
if|if
condition|(
name|k
operator|!=
name|k0
condition|)
block|{
comment|// careful: mark only those currently in the queue
name|bits
operator|.
name|set
argument_list|(
name|k
argument_list|)
expr_stmt|;
comment|// mark that pp2 need to be re-queued
block|}
block|}
comment|// collisions resolved, now re-queue
comment|// empty (partially) the queue until seeing all pps advanced for resolving collisions
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bits
operator|.
name|cardinality
argument_list|()
operator|>
literal|0
condition|)
block|{
name|PhrasePositions
name|pp2
init|=
name|pq
operator|.
name|pop
argument_list|()
decl_stmt|;
name|rptStack
index|[
name|n
operator|++
index|]
operator|=
name|pp2
expr_stmt|;
if|if
condition|(
name|pp2
operator|.
name|rptGroup
operator|>=
literal|0
operator|&&
name|bits
operator|.
name|get
argument_list|(
name|pp2
operator|.
name|rptInd
argument_list|)
condition|)
block|{
name|bits
operator|.
name|clear
argument_list|(
name|pp2
operator|.
name|rptInd
argument_list|)
expr_stmt|;
block|}
block|}
comment|// add back to queue
for|for
control|(
name|int
name|i
init|=
name|n
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|pq
operator|.
name|add
argument_list|(
name|rptStack
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/** compare two pps, but only by position and offset */
DECL|method|lesser
specifier|private
name|PhrasePositions
name|lesser
parameter_list|(
name|PhrasePositions
name|pp
parameter_list|,
name|PhrasePositions
name|pp2
parameter_list|)
block|{
if|if
condition|(
name|pp
operator|.
name|position
operator|<
name|pp2
operator|.
name|position
operator|||
operator|(
name|pp
operator|.
name|position
operator|==
name|pp2
operator|.
name|position
operator|&&
name|pp
operator|.
name|offset
operator|<
name|pp2
operator|.
name|offset
operator|)
condition|)
block|{
return|return
name|pp
return|;
block|}
return|return
name|pp2
return|;
block|}
comment|/** index of a pp2 colliding with pp, or -1 if none */
DECL|method|collide
specifier|private
name|int
name|collide
parameter_list|(
name|PhrasePositions
name|pp
parameter_list|)
block|{
name|int
name|tpPos
init|=
name|tpPos
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|PhrasePositions
index|[]
name|rg
init|=
name|rptGroups
index|[
name|pp
operator|.
name|rptGroup
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rg
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|PhrasePositions
name|pp2
init|=
name|rg
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pp2
operator|!=
name|pp
operator|&&
name|tpPos
argument_list|(
name|pp2
argument_list|)
operator|==
name|tpPos
condition|)
block|{
return|return
name|pp2
operator|.
name|rptInd
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Initialize PhrasePositions in place.    * A one time initialization for this scorer (on first doc matching all terms):    *<ul>    *<li>Check if there are repetitions    *<li>If there are, find groups of repetitions.    *</ul>    * Examples:    *<ol>    *<li>no repetitions:<b>"ho my"~2</b>    *<li>repetitions:<b>"ho my my"~2</b>    *<li>repetitions:<b>"my ho my"~2</b>    *</ol>    * @return false if PPs are exhausted (and so current doc will not be a match)     */
DECL|method|initPhrasePositions
specifier|private
name|boolean
name|initPhrasePositions
parameter_list|()
throws|throws
name|IOException
block|{
name|end
operator|=
name|Integer
operator|.
name|MIN_VALUE
expr_stmt|;
if|if
condition|(
operator|!
name|checkedRpts
condition|)
block|{
return|return
name|initFirstTime
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|hasRpts
condition|)
block|{
name|initSimple
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
comment|// PPs available
block|}
return|return
name|initComplex
argument_list|()
return|;
block|}
comment|/** no repeats: simplest case, and most common. It is important to keep this piece of the code simple and efficient */
DECL|method|initSimple
specifier|private
name|void
name|initSimple
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.err.println("initSimple: doc: "+min.doc);
name|pq
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// position pps and build queue from list
for|for
control|(
name|PhrasePositions
name|pp
init|=
name|min
init|,
name|prev
init|=
literal|null
init|;
name|prev
operator|!=
name|max
condition|;
name|pp
operator|=
operator|(
name|prev
operator|=
name|pp
operator|)
operator|.
name|next
control|)
block|{
comment|// iterate cyclic list: done once handled max
name|pp
operator|.
name|firstPosition
argument_list|()
expr_stmt|;
if|if
condition|(
name|pp
operator|.
name|position
operator|>
name|end
condition|)
block|{
name|end
operator|=
name|pp
operator|.
name|position
expr_stmt|;
block|}
name|pq
operator|.
name|add
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** with repeats: not so simple. */
DECL|method|initComplex
specifier|private
name|boolean
name|initComplex
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.err.println("initComplex: doc: "+min.doc);
name|placeFirstPositions
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|advanceRepeatGroups
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
comment|// PPs exhausted
block|}
name|fillQueue
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
comment|// PPs available
block|}
comment|/** move all PPs to their first position */
DECL|method|placeFirstPositions
specifier|private
name|void
name|placeFirstPositions
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|PhrasePositions
name|pp
init|=
name|min
init|,
name|prev
init|=
literal|null
init|;
name|prev
operator|!=
name|max
condition|;
name|pp
operator|=
operator|(
name|prev
operator|=
name|pp
operator|)
operator|.
name|next
control|)
block|{
comment|// iterate cyclic list: done once handled max
name|pp
operator|.
name|firstPosition
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Fill the queue (all pps are already placed */
DECL|method|fillQueue
specifier|private
name|void
name|fillQueue
parameter_list|()
block|{
name|pq
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|PhrasePositions
name|pp
init|=
name|min
init|,
name|prev
init|=
literal|null
init|;
name|prev
operator|!=
name|max
condition|;
name|pp
operator|=
operator|(
name|prev
operator|=
name|pp
operator|)
operator|.
name|next
control|)
block|{
comment|// iterate cyclic list: done once handled max
if|if
condition|(
name|pp
operator|.
name|position
operator|>
name|end
condition|)
block|{
name|end
operator|=
name|pp
operator|.
name|position
expr_stmt|;
block|}
name|pq
operator|.
name|add
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** At initialization (each doc), each repetition group is sorted by (query) offset.    * This provides the start condition: no collisions.    *<p>Case 1: no multi-term repeats<br>    * It is sufficient to advance each pp in the group by one less than its group index.    * So lesser pp is not advanced, 2nd one advance once, 3rd one advanced twice, etc.    *<p>Case 2: multi-term repeats<br>    *     * @return false if PPs are exhausted.     */
DECL|method|advanceRepeatGroups
specifier|private
name|boolean
name|advanceRepeatGroups
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|PhrasePositions
index|[]
name|rg
range|:
name|rptGroups
control|)
block|{
if|if
condition|(
name|hasMultiTermRpts
condition|)
block|{
comment|// more involved, some may not collide
name|int
name|incr
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rg
operator|.
name|length
condition|;
name|i
operator|+=
name|incr
control|)
block|{
name|incr
operator|=
literal|1
expr_stmt|;
name|PhrasePositions
name|pp
init|=
name|rg
index|[
name|i
index|]
decl_stmt|;
name|int
name|k
decl_stmt|;
while|while
condition|(
operator|(
name|k
operator|=
name|collide
argument_list|(
name|pp
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|PhrasePositions
name|pp2
init|=
name|lesser
argument_list|(
name|pp
argument_list|,
name|rg
index|[
name|k
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|advancePP
argument_list|(
name|pp2
argument_list|)
condition|)
block|{
comment|// at initialization always advance pp with higher offset
return|return
literal|false
return|;
comment|// exhausted
block|}
if|if
condition|(
name|pp2
operator|.
name|rptInd
operator|<
name|i
condition|)
block|{
comment|// should not happen?
name|incr
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// simpler, we know exactly how much to advance
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|rg
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|rg
index|[
name|j
index|]
operator|.
name|nextPosition
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
comment|// PPs exhausted
block|}
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
comment|// PPs available
block|}
comment|/** initialize with checking for repeats. Heavy work, but done only for the first candidate doc.<p>    * If there are repetitions, check if multi-term postings (MTP) are involved.<p>    * Without MTP, once PPs are placed in the first candidate doc, repeats (and groups) are visible.<br>    * With MTP, a more complex check is needed, up-front, as there may be "hidden collisions".<br>    * For example P1 has {A,B}, P1 has {B,C}, and the first doc is: "A C B". At start, P1 would point    * to "A", p2 to "C", and it will not be identified that P1 and P2 are repetitions of each other.<p>    * The more complex initialization has two parts:<br>    * (1) identification of repetition groups.<br>    * (2) advancing repeat groups at the start of the doc.<br>    * For (1), a possible solution is to just create a single repetition group,     * made of all repeating pps. But this would slow down the check for collisions,     * as all pps would need to be checked. Instead, we compute "connected regions"     * on the bipartite graph of postings and terms.      */
DECL|method|initFirstTime
specifier|private
name|boolean
name|initFirstTime
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.err.println("initFirstTime: doc: "+min.doc);
name|checkedRpts
operator|=
literal|true
expr_stmt|;
name|placeFirstPositions
argument_list|()
expr_stmt|;
name|LinkedHashMap
argument_list|<
name|Term
argument_list|,
name|Integer
argument_list|>
name|rptTerms
init|=
name|repeatingTerms
argument_list|()
decl_stmt|;
name|hasRpts
operator|=
operator|!
name|rptTerms
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
if|if
condition|(
name|hasRpts
condition|)
block|{
name|rptStack
operator|=
operator|new
name|PhrasePositions
index|[
name|numPostings
index|]
expr_stmt|;
comment|// needed with repetitions
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|PhrasePositions
argument_list|>
argument_list|>
name|rgs
init|=
name|gatherRptGroups
argument_list|(
name|rptTerms
argument_list|)
decl_stmt|;
name|sortRptGroups
argument_list|(
name|rgs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|advanceRepeatGroups
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
comment|// PPs exhausted
block|}
block|}
name|fillQueue
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
comment|// PPs available
block|}
comment|/** sort each repetition group by (query) offset.     * Done only once (at first doc) and allows to initialize faster for each doc. */
DECL|method|sortRptGroups
specifier|private
name|void
name|sortRptGroups
parameter_list|(
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|PhrasePositions
argument_list|>
argument_list|>
name|rgs
parameter_list|)
block|{
name|rptGroups
operator|=
operator|new
name|PhrasePositions
index|[
name|rgs
operator|.
name|size
argument_list|()
index|]
index|[]
expr_stmt|;
name|Comparator
argument_list|<
name|PhrasePositions
argument_list|>
name|cmprtr
init|=
operator|new
name|Comparator
argument_list|<
name|PhrasePositions
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|PhrasePositions
name|pp1
parameter_list|,
name|PhrasePositions
name|pp2
parameter_list|)
block|{
return|return
name|pp1
operator|.
name|offset
operator|-
name|pp2
operator|.
name|offset
return|;
block|}
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rptGroups
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|PhrasePositions
index|[]
name|rg
init|=
name|rgs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toArray
argument_list|(
operator|new
name|PhrasePositions
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|rg
argument_list|,
name|cmprtr
argument_list|)
expr_stmt|;
name|rptGroups
index|[
name|i
index|]
operator|=
name|rg
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|rg
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|rg
index|[
name|j
index|]
operator|.
name|rptInd
operator|=
name|j
expr_stmt|;
comment|// we use this index for efficient re-queuing
block|}
block|}
block|}
comment|/** Detect repetition groups. Done once - for first doc */
DECL|method|gatherRptGroups
specifier|private
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|PhrasePositions
argument_list|>
argument_list|>
name|gatherRptGroups
parameter_list|(
name|LinkedHashMap
argument_list|<
name|Term
argument_list|,
name|Integer
argument_list|>
name|rptTerms
parameter_list|)
throws|throws
name|IOException
block|{
name|PhrasePositions
index|[]
name|rpp
init|=
name|repeatingPPs
argument_list|(
name|rptTerms
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|PhrasePositions
argument_list|>
argument_list|>
name|res
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|PhrasePositions
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|hasMultiTermRpts
condition|)
block|{
comment|// simpler - no multi-terms - can base on positions in first doc
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rpp
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|PhrasePositions
name|pp
init|=
name|rpp
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pp
operator|.
name|rptGroup
operator|>=
literal|0
condition|)
continue|continue;
comment|// already marked as a repetition
name|int
name|tpPos
init|=
name|tpPos
argument_list|(
name|pp
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|rpp
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|PhrasePositions
name|pp2
init|=
name|rpp
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|pp2
operator|.
name|rptGroup
operator|>=
literal|0
comment|// already marked as a repetition
operator|||
name|pp2
operator|.
name|offset
operator|==
name|pp
operator|.
name|offset
comment|// not a repetition: two PPs are originally in same offset in the query!
operator|||
name|tpPos
argument_list|(
name|pp2
argument_list|)
operator|!=
name|tpPos
condition|)
block|{
comment|// not a repetition
continue|continue;
block|}
comment|// a repetition
name|int
name|g
init|=
name|pp
operator|.
name|rptGroup
decl_stmt|;
if|if
condition|(
name|g
operator|<
literal|0
condition|)
block|{
name|g
operator|=
name|res
operator|.
name|size
argument_list|()
expr_stmt|;
name|pp
operator|.
name|rptGroup
operator|=
name|g
expr_stmt|;
name|ArrayList
argument_list|<
name|PhrasePositions
argument_list|>
name|rl
init|=
operator|new
name|ArrayList
argument_list|<
name|PhrasePositions
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|rl
operator|.
name|add
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|res
operator|.
name|add
argument_list|(
name|rl
argument_list|)
expr_stmt|;
block|}
name|pp2
operator|.
name|rptGroup
operator|=
name|g
expr_stmt|;
name|res
operator|.
name|get
argument_list|(
name|g
argument_list|)
operator|.
name|add
argument_list|(
name|pp2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// more involved - has multi-terms
name|ArrayList
argument_list|<
name|HashSet
argument_list|<
name|PhrasePositions
argument_list|>
argument_list|>
name|tmp
init|=
operator|new
name|ArrayList
argument_list|<
name|HashSet
argument_list|<
name|PhrasePositions
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|OpenBitSet
argument_list|>
name|bb
init|=
name|ppTermsBitSets
argument_list|(
name|rpp
argument_list|,
name|rptTerms
argument_list|)
decl_stmt|;
name|unionTermGroups
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Term
argument_list|,
name|Integer
argument_list|>
name|tg
init|=
name|termGroups
argument_list|(
name|rptTerms
argument_list|,
name|bb
argument_list|)
decl_stmt|;
name|HashSet
argument_list|<
name|Integer
argument_list|>
name|distinctGroupIDs
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|tg
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|distinctGroupIDs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|.
name|add
argument_list|(
operator|new
name|HashSet
argument_list|<
name|PhrasePositions
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|PhrasePositions
name|pp
range|:
name|rpp
control|)
block|{
for|for
control|(
name|Term
name|t
range|:
name|pp
operator|.
name|terms
control|)
block|{
if|if
condition|(
name|rptTerms
operator|.
name|containsKey
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|int
name|g
init|=
name|tg
operator|.
name|get
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tmp
operator|.
name|get
argument_list|(
name|g
argument_list|)
operator|.
name|add
argument_list|(
name|pp
argument_list|)
expr_stmt|;
assert|assert
name|pp
operator|.
name|rptGroup
operator|==
operator|-
literal|1
operator|||
name|pp
operator|.
name|rptGroup
operator|==
name|g
assert|;
name|pp
operator|.
name|rptGroup
operator|=
name|g
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|HashSet
argument_list|<
name|PhrasePositions
argument_list|>
name|hs
range|:
name|tmp
control|)
block|{
name|res
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|PhrasePositions
argument_list|>
argument_list|(
name|hs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
comment|/** Actual position in doc of a PhrasePosition, relies on that position = tpPos - offset) */
DECL|method|tpPos
specifier|private
specifier|final
name|int
name|tpPos
parameter_list|(
name|PhrasePositions
name|pp
parameter_list|)
block|{
return|return
name|pp
operator|.
name|position
operator|+
name|pp
operator|.
name|offset
return|;
block|}
comment|/** find repeating terms and assign them ordinal values */
DECL|method|repeatingTerms
specifier|private
name|LinkedHashMap
argument_list|<
name|Term
argument_list|,
name|Integer
argument_list|>
name|repeatingTerms
parameter_list|()
block|{
name|LinkedHashMap
argument_list|<
name|Term
argument_list|,
name|Integer
argument_list|>
name|tord
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Term
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|Term
argument_list|,
name|Integer
argument_list|>
name|tcnt
init|=
operator|new
name|HashMap
argument_list|<
name|Term
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|PhrasePositions
name|pp
init|=
name|min
init|,
name|prev
init|=
literal|null
init|;
name|prev
operator|!=
name|max
condition|;
name|pp
operator|=
operator|(
name|prev
operator|=
name|pp
operator|)
operator|.
name|next
control|)
block|{
comment|// iterate cyclic list: done once handled max
for|for
control|(
name|Term
name|t
range|:
name|pp
operator|.
name|terms
control|)
block|{
name|Integer
name|cnt0
init|=
name|tcnt
operator|.
name|get
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|Integer
name|cnt
init|=
name|cnt0
operator|==
literal|null
condition|?
operator|new
name|Integer
argument_list|(
literal|1
argument_list|)
else|:
operator|new
name|Integer
argument_list|(
literal|1
operator|+
name|cnt0
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
name|tcnt
operator|.
name|put
argument_list|(
name|t
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|2
condition|)
block|{
name|tord
operator|.
name|put
argument_list|(
name|t
argument_list|,
name|tord
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|tord
return|;
block|}
comment|/** find repeating pps, and for each, if has multi-terms, update this.hasMultiTermRpts */
DECL|method|repeatingPPs
specifier|private
name|PhrasePositions
index|[]
name|repeatingPPs
parameter_list|(
name|HashMap
argument_list|<
name|Term
argument_list|,
name|Integer
argument_list|>
name|rptTerms
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|PhrasePositions
argument_list|>
name|rp
init|=
operator|new
name|ArrayList
argument_list|<
name|PhrasePositions
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|PhrasePositions
name|pp
init|=
name|min
init|,
name|prev
init|=
literal|null
init|;
name|prev
operator|!=
name|max
condition|;
name|pp
operator|=
operator|(
name|prev
operator|=
name|pp
operator|)
operator|.
name|next
control|)
block|{
comment|// iterate cyclic list: done once handled max
for|for
control|(
name|Term
name|t
range|:
name|pp
operator|.
name|terms
control|)
block|{
if|if
condition|(
name|rptTerms
operator|.
name|containsKey
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|rp
operator|.
name|add
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|hasMultiTermRpts
operator||=
operator|(
name|pp
operator|.
name|terms
operator|.
name|length
operator|>
literal|1
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|rp
operator|.
name|toArray
argument_list|(
operator|new
name|PhrasePositions
index|[
literal|0
index|]
argument_list|)
return|;
block|}
comment|/** bit-sets - for each repeating pp, for each of its repeating terms, the term ordinal values is set */
DECL|method|ppTermsBitSets
specifier|private
name|ArrayList
argument_list|<
name|OpenBitSet
argument_list|>
name|ppTermsBitSets
parameter_list|(
name|PhrasePositions
index|[]
name|rpp
parameter_list|,
name|HashMap
argument_list|<
name|Term
argument_list|,
name|Integer
argument_list|>
name|tord
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|OpenBitSet
argument_list|>
name|bb
init|=
operator|new
name|ArrayList
argument_list|<
name|OpenBitSet
argument_list|>
argument_list|(
name|rpp
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|PhrasePositions
name|pp
range|:
name|rpp
control|)
block|{
name|OpenBitSet
name|b
init|=
operator|new
name|OpenBitSet
argument_list|(
name|tord
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|Integer
name|ord
decl_stmt|;
for|for
control|(
name|Term
name|t
range|:
name|pp
operator|.
name|terms
control|)
block|{
if|if
condition|(
operator|(
name|ord
operator|=
name|tord
operator|.
name|get
argument_list|(
name|t
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|b
operator|.
name|set
argument_list|(
name|ord
argument_list|)
expr_stmt|;
block|}
block|}
name|bb
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|bb
return|;
block|}
comment|/** union (term group) bit-sets until they are disjoint (O(n^^2)), and each group have different terms */
DECL|method|unionTermGroups
specifier|private
name|void
name|unionTermGroups
parameter_list|(
name|ArrayList
argument_list|<
name|OpenBitSet
argument_list|>
name|bb
parameter_list|)
block|{
name|int
name|incr
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bb
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|+=
name|incr
control|)
block|{
name|incr
operator|=
literal|1
expr_stmt|;
name|int
name|j
init|=
name|i
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|j
operator|<
name|bb
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|bb
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|intersects
argument_list|(
name|bb
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
block|{
name|bb
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|union
argument_list|(
name|bb
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|bb
operator|.
name|remove
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|incr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|++
name|j
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** map each term to the single group that contains it */
DECL|method|termGroups
specifier|private
name|HashMap
argument_list|<
name|Term
argument_list|,
name|Integer
argument_list|>
name|termGroups
parameter_list|(
name|LinkedHashMap
argument_list|<
name|Term
argument_list|,
name|Integer
argument_list|>
name|tord
parameter_list|,
name|ArrayList
argument_list|<
name|OpenBitSet
argument_list|>
name|bb
parameter_list|)
throws|throws
name|IOException
block|{
name|HashMap
argument_list|<
name|Term
argument_list|,
name|Integer
argument_list|>
name|tg
init|=
operator|new
name|HashMap
argument_list|<
name|Term
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Term
index|[]
name|t
init|=
name|tord
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|Term
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bb
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// i is the group no.
name|DocIdSetIterator
name|bits
init|=
name|bb
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|ord
decl_stmt|;
while|while
condition|(
operator|(
name|ord
operator|=
name|bits
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|NO_MORE_DOCS
condition|)
block|{
name|tg
operator|.
name|put
argument_list|(
name|t
index|[
name|ord
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tg
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
block|{
return|return
name|numMatches
return|;
block|}
DECL|method|sloppyFreq
name|float
name|sloppyFreq
parameter_list|()
block|{
return|return
name|sloppyFreq
return|;
block|}
comment|//  private void printQueue(PrintStream ps, PhrasePositions ext, String title) {
comment|//    //if (min.doc != ?) return;
comment|//    ps.println();
comment|//    ps.println("---- "+title);
comment|//    ps.println("EXT: "+ext);
comment|//    PhrasePositions[] t = new PhrasePositions[pq.size()];
comment|//    if (pq.size()>0) {
comment|//      t[0] = pq.pop();
comment|//      ps.println("  " + 0 + "  " + t[0]);
comment|//      for (int i=1; i<t.length; i++) {
comment|//        t[i] = pq.pop();
comment|//        assert t[i-1].position<= t[i].position;
comment|//        ps.println("  " + i + "  " + t[i]);
comment|//      }
comment|//      // add them back
comment|//      for (int i=t.length-1; i>=0; i--) {
comment|//        pq.add(t[i]);
comment|//      }
comment|//    }
comment|//  }
DECL|method|advanceMin
specifier|private
name|boolean
name|advanceMin
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|min
operator|.
name|skipTo
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|max
operator|.
name|doc
operator|=
name|NO_MORE_DOCS
expr_stmt|;
comment|// for further calls to docID()
return|return
literal|false
return|;
block|}
name|min
operator|=
name|min
operator|.
name|next
expr_stmt|;
comment|// cyclic
name|max
operator|=
name|max
operator|.
name|next
expr_stmt|;
comment|// cyclic
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|max
operator|.
name|doc
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|advance
argument_list|(
name|max
operator|.
name|doc
operator|+
literal|1
argument_list|)
return|;
comment|// advance to the next doc after #docID()
block|}
annotation|@
name|Override
DECL|method|score
specifier|public
name|float
name|score
parameter_list|()
block|{
return|return
name|docScorer
operator|.
name|score
argument_list|(
name|max
operator|.
name|doc
argument_list|,
name|sloppyFreq
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|target
operator|>
name|docID
argument_list|()
assert|;
do|do
block|{
if|if
condition|(
operator|!
name|advanceMin
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
name|NO_MORE_DOCS
return|;
block|}
while|while
condition|(
name|min
operator|.
name|doc
operator|<
name|max
operator|.
name|doc
condition|)
block|{
if|if
condition|(
operator|!
name|advanceMin
argument_list|(
name|max
operator|.
name|doc
argument_list|)
condition|)
block|{
return|return
name|NO_MORE_DOCS
return|;
block|}
block|}
comment|// found a doc with all of the terms
name|sloppyFreq
operator|=
name|phraseFreq
argument_list|()
expr_stmt|;
comment|// check for phrase
name|target
operator|=
name|min
operator|.
name|doc
operator|+
literal|1
expr_stmt|;
comment|// next target in case sloppyFreq is still 0
block|}
do|while
condition|(
name|sloppyFreq
operator|==
literal|0f
condition|)
do|;
comment|// found a match
return|return
name|max
operator|.
name|doc
return|;
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|cost
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"scorer("
operator|+
name|weight
operator|+
literal|")"
return|;
block|}
block|}
end_class
end_unit
