begin_unit
begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FieldValueHitQueue
operator|.
name|Entry
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import
begin_comment
comment|/**  * A {@link Collector} that sorts by {@link SortField} using  * {@link FieldComparator}s.  *<p/>  * See the {@link #create(org.apache.lucene.search.Sort, int, boolean, boolean, boolean)} method  * for instantiating a TopFieldCollector.  *  * @lucene.experimental  */
end_comment
begin_class
DECL|class|TopFieldCollector
specifier|public
specifier|abstract
class|class
name|TopFieldCollector
extends|extends
name|TopDocsCollector
argument_list|<
name|Entry
argument_list|>
block|{
comment|// TODO: one optimization we could do is to pre-fill
comment|// the queue with sentinel value that guaranteed to
comment|// always compare lower than a real hit; this would
comment|// save having to check queueFull on each insert
DECL|class|OneComparatorLeafCollector
specifier|private
specifier|static
specifier|abstract
class|class
name|OneComparatorLeafCollector
implements|implements
name|LeafCollector
block|{
DECL|field|comparator
specifier|final
name|LeafFieldComparator
name|comparator
decl_stmt|;
DECL|field|reverseMul
specifier|final
name|int
name|reverseMul
decl_stmt|;
DECL|field|scorer
name|Scorer
name|scorer
decl_stmt|;
DECL|method|OneComparatorLeafCollector
name|OneComparatorLeafCollector
parameter_list|(
name|LeafFieldComparator
name|comparator
parameter_list|,
name|int
name|reverseMul
parameter_list|)
block|{
name|this
operator|.
name|comparator
operator|=
name|comparator
expr_stmt|;
name|this
operator|.
name|reverseMul
operator|=
name|reverseMul
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setScorer
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
name|comparator
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|MultiComparatorLeafCollector
specifier|private
specifier|static
specifier|abstract
class|class
name|MultiComparatorLeafCollector
implements|implements
name|LeafCollector
block|{
DECL|field|comparators
specifier|final
name|LeafFieldComparator
index|[]
name|comparators
decl_stmt|;
DECL|field|reverseMul
specifier|final
name|int
index|[]
name|reverseMul
decl_stmt|;
DECL|field|firstComparator
specifier|final
name|LeafFieldComparator
name|firstComparator
decl_stmt|;
DECL|field|firstReverseMul
specifier|final
name|int
name|firstReverseMul
decl_stmt|;
DECL|field|scorer
name|Scorer
name|scorer
decl_stmt|;
DECL|method|MultiComparatorLeafCollector
name|MultiComparatorLeafCollector
parameter_list|(
name|LeafFieldComparator
index|[]
name|comparators
parameter_list|,
name|int
index|[]
name|reverseMul
parameter_list|)
block|{
name|this
operator|.
name|comparators
operator|=
name|comparators
expr_stmt|;
name|this
operator|.
name|reverseMul
operator|=
name|reverseMul
expr_stmt|;
name|firstComparator
operator|=
name|comparators
index|[
literal|0
index|]
expr_stmt|;
name|firstReverseMul
operator|=
name|reverseMul
index|[
literal|0
index|]
expr_stmt|;
block|}
DECL|method|compareBottom
specifier|protected
specifier|final
name|int
name|compareBottom
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|cmp
init|=
name|firstReverseMul
operator|*
name|firstComparator
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|cmp
operator|=
name|reverseMul
index|[
name|i
index|]
operator|*
name|comparators
index|[
name|i
index|]
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
DECL|method|copy
specifier|protected
specifier|final
name|void
name|copy
parameter_list|(
name|int
name|slot
parameter_list|,
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|LeafFieldComparator
name|comparator
range|:
name|comparators
control|)
block|{
name|comparator
operator|.
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setBottom
specifier|protected
specifier|final
name|void
name|setBottom
parameter_list|(
name|int
name|slot
parameter_list|)
block|{
for|for
control|(
name|LeafFieldComparator
name|comparator
range|:
name|comparators
control|)
block|{
name|comparator
operator|.
name|setBottom
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|compareTop
specifier|protected
specifier|final
name|int
name|compareTop
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|cmp
init|=
name|firstReverseMul
operator|*
name|firstComparator
operator|.
name|compareTop
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|cmp
operator|=
name|reverseMul
index|[
name|i
index|]
operator|*
name|comparators
index|[
name|i
index|]
operator|.
name|compareTop
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|setScorer
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|scorer
operator|=
name|scorer
expr_stmt|;
for|for
control|(
name|LeafFieldComparator
name|comparator
range|:
name|comparators
control|)
block|{
name|comparator
operator|.
name|setScorer
argument_list|(
name|scorer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*    * Implements a TopFieldCollector over one SortField criteria, without    * tracking document scores and maxScore.    */
DECL|class|NonScoringCollector
specifier|private
specifier|static
class|class
name|NonScoringCollector
extends|extends
name|TopFieldCollector
block|{
DECL|field|queue
specifier|final
name|FieldValueHitQueue
argument_list|<
name|Entry
argument_list|>
name|queue
decl_stmt|;
DECL|method|NonScoringCollector
specifier|public
name|NonScoringCollector
parameter_list|(
name|Sort
name|sort
parameter_list|,
name|FieldValueHitQueue
argument_list|<
name|Entry
argument_list|>
name|queue
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|,
name|sort
operator|.
name|needsScores
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|queue
operator|=
name|queue
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getLeafCollector
specifier|public
name|LeafCollector
name|getLeafCollector
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|docBase
operator|=
name|context
operator|.
name|docBase
expr_stmt|;
specifier|final
name|LeafFieldComparator
index|[]
name|comparators
init|=
name|queue
operator|.
name|getComparators
argument_list|(
name|context
argument_list|)
decl_stmt|;
specifier|final
name|int
index|[]
name|reverseMul
init|=
name|queue
operator|.
name|getReverseMul
argument_list|()
decl_stmt|;
if|if
condition|(
name|comparators
operator|.
name|length
operator|==
literal|1
condition|)
block|{
return|return
operator|new
name|OneComparatorLeafCollector
argument_list|(
name|comparators
index|[
literal|0
index|]
argument_list|,
name|reverseMul
index|[
literal|0
index|]
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
if|if
condition|(
operator|(
name|reverseMul
operator|*
name|comparator
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
comment|// since docs are visited in doc Id order, if compare is 0, it means
comment|// this document is larger than anything else in the queue, and
comment|// therefore not competitive.
return|return;
block|}
comment|// This hit is competitive - replace bottom element in queue& adjustTop
name|comparator
operator|.
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|updateBottom
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
name|comparator
operator|.
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|Float
operator|.
name|NaN
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|;
block|}
else|else
block|{
return|return
operator|new
name|MultiComparatorLeafCollector
argument_list|(
name|comparators
argument_list|,
name|reverseMul
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
if|if
condition|(
operator|(
name|compareBottom
argument_list|(
name|doc
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
comment|// since docs are visited in doc Id order, if compare is 0, it means
comment|// this document is larger than anything else in the queue, and
comment|// therefore not competitive.
return|return;
block|}
comment|// This hit is competitive - replace bottom element in queue& adjustTop
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|updateBottom
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|Float
operator|.
name|NaN
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|;
block|}
block|}
block|}
comment|/*    * Implements a TopFieldCollector over one SortField criteria, while tracking    * document scores but no maxScore.    */
DECL|class|ScoringNoMaxScoreCollector
specifier|private
specifier|static
class|class
name|ScoringNoMaxScoreCollector
extends|extends
name|TopFieldCollector
block|{
DECL|field|queue
specifier|final
name|FieldValueHitQueue
argument_list|<
name|Entry
argument_list|>
name|queue
decl_stmt|;
DECL|method|ScoringNoMaxScoreCollector
specifier|public
name|ScoringNoMaxScoreCollector
parameter_list|(
name|Sort
name|sort
parameter_list|,
name|FieldValueHitQueue
argument_list|<
name|Entry
argument_list|>
name|queue
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|queue
operator|=
name|queue
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getLeafCollector
specifier|public
name|LeafCollector
name|getLeafCollector
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|docBase
operator|=
name|context
operator|.
name|docBase
expr_stmt|;
specifier|final
name|LeafFieldComparator
index|[]
name|comparators
init|=
name|queue
operator|.
name|getComparators
argument_list|(
name|context
argument_list|)
decl_stmt|;
specifier|final
name|int
index|[]
name|reverseMul
init|=
name|queue
operator|.
name|getReverseMul
argument_list|()
decl_stmt|;
if|if
condition|(
name|comparators
operator|.
name|length
operator|==
literal|1
condition|)
block|{
return|return
operator|new
name|OneComparatorLeafCollector
argument_list|(
name|comparators
index|[
literal|0
index|]
argument_list|,
name|reverseMul
index|[
literal|0
index|]
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
if|if
condition|(
operator|(
name|reverseMul
operator|*
name|comparator
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
comment|// since docs are visited in doc Id order, if compare is 0, it means
comment|// this document is largest than anything else in the queue, and
comment|// therefore not competitive.
return|return;
block|}
comment|// Compute the score only if the hit is competitive.
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
comment|// This hit is competitive - replace bottom element in queue& adjustTop
name|comparator
operator|.
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|updateBottom
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Compute the score only if the hit is competitive.
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
name|comparator
operator|.
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|;
block|}
else|else
block|{
return|return
operator|new
name|MultiComparatorLeafCollector
argument_list|(
name|comparators
argument_list|,
name|reverseMul
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
if|if
condition|(
operator|(
name|compareBottom
argument_list|(
name|doc
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
comment|// since docs are visited in doc Id order, if compare is 0, it means
comment|// this document is largest than anything else in the queue, and
comment|// therefore not competitive.
return|return;
block|}
comment|// Compute the score only if the hit is competitive.
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
comment|// This hit is competitive - replace bottom element in queue& adjustTop
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|updateBottom
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Compute the score only if the hit is competitive.
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|;
block|}
block|}
block|}
comment|/*    * Implements a TopFieldCollector over one SortField criteria, with tracking    * document scores and maxScore.    */
DECL|class|ScoringMaxScoreCollector
specifier|private
specifier|static
class|class
name|ScoringMaxScoreCollector
extends|extends
name|TopFieldCollector
block|{
DECL|field|queue
specifier|final
name|FieldValueHitQueue
argument_list|<
name|Entry
argument_list|>
name|queue
decl_stmt|;
DECL|method|ScoringMaxScoreCollector
specifier|public
name|ScoringMaxScoreCollector
parameter_list|(
name|Sort
name|sort
parameter_list|,
name|FieldValueHitQueue
argument_list|<
name|Entry
argument_list|>
name|queue
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|queue
operator|=
name|queue
expr_stmt|;
name|maxScore
operator|=
name|Float
operator|.
name|MIN_NORMAL
expr_stmt|;
comment|// otherwise we would keep NaN
block|}
annotation|@
name|Override
DECL|method|getLeafCollector
specifier|public
name|LeafCollector
name|getLeafCollector
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|docBase
operator|=
name|context
operator|.
name|docBase
expr_stmt|;
specifier|final
name|LeafFieldComparator
index|[]
name|comparators
init|=
name|queue
operator|.
name|getComparators
argument_list|(
name|context
argument_list|)
decl_stmt|;
specifier|final
name|int
index|[]
name|reverseMul
init|=
name|queue
operator|.
name|getReverseMul
argument_list|()
decl_stmt|;
if|if
condition|(
name|comparators
operator|.
name|length
operator|==
literal|1
condition|)
block|{
return|return
operator|new
name|OneComparatorLeafCollector
argument_list|(
name|comparators
index|[
literal|0
index|]
argument_list|,
name|reverseMul
index|[
literal|0
index|]
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
if|if
condition|(
name|score
operator|>
name|maxScore
condition|)
block|{
name|maxScore
operator|=
name|score
expr_stmt|;
block|}
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
if|if
condition|(
name|reverseMul
operator|*
name|comparator
operator|.
name|compareBottom
argument_list|(
name|doc
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|// since docs are visited in doc Id order, if compare is 0, it means
comment|// this document is largest than anything else in the queue, and
comment|// therefore not competitive.
return|return;
block|}
comment|// This hit is competitive - replace bottom element in queue& adjustTop
name|comparator
operator|.
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|updateBottom
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
name|comparator
operator|.
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
name|comparator
operator|.
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|;
block|}
else|else
block|{
return|return
operator|new
name|MultiComparatorLeafCollector
argument_list|(
name|comparators
argument_list|,
name|reverseMul
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|float
name|score
init|=
name|scorer
operator|.
name|score
argument_list|()
decl_stmt|;
if|if
condition|(
name|score
operator|>
name|maxScore
condition|)
block|{
name|maxScore
operator|=
name|score
expr_stmt|;
block|}
operator|++
name|totalHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
if|if
condition|(
name|compareBottom
argument_list|(
name|doc
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|// since docs are visited in doc Id order, if compare is 0, it means
comment|// this document is largest than anything else in the queue, and
comment|// therefore not competitive.
return|return;
block|}
comment|// This hit is competitive - replace bottom element in queue& adjustTop
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|updateBottom
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|totalHits
operator|-
literal|1
decl_stmt|;
comment|// Copy hit into queue
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|;
block|}
block|}
block|}
comment|/*    * Implements a TopFieldCollector when after != null.    */
DECL|class|PagingFieldCollector
specifier|private
specifier|final
specifier|static
class|class
name|PagingFieldCollector
extends|extends
name|TopFieldCollector
block|{
DECL|field|collectedHits
name|int
name|collectedHits
decl_stmt|;
DECL|field|queue
specifier|final
name|FieldValueHitQueue
argument_list|<
name|Entry
argument_list|>
name|queue
decl_stmt|;
DECL|field|trackDocScores
specifier|final
name|boolean
name|trackDocScores
decl_stmt|;
DECL|field|trackMaxScore
specifier|final
name|boolean
name|trackMaxScore
decl_stmt|;
DECL|field|after
specifier|final
name|FieldDoc
name|after
decl_stmt|;
DECL|method|PagingFieldCollector
specifier|public
name|PagingFieldCollector
parameter_list|(
name|Sort
name|sort
parameter_list|,
name|FieldValueHitQueue
argument_list|<
name|Entry
argument_list|>
name|queue
parameter_list|,
name|FieldDoc
name|after
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|,
name|boolean
name|trackDocScores
parameter_list|,
name|boolean
name|trackMaxScore
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|,
name|trackDocScores
operator|||
name|trackMaxScore
operator|||
name|sort
operator|.
name|needsScores
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|queue
operator|=
name|queue
expr_stmt|;
name|this
operator|.
name|trackDocScores
operator|=
name|trackDocScores
expr_stmt|;
name|this
operator|.
name|trackMaxScore
operator|=
name|trackMaxScore
expr_stmt|;
name|this
operator|.
name|after
operator|=
name|after
expr_stmt|;
comment|// Must set maxScore to NEG_INF, or otherwise Math.max always returns NaN.
name|maxScore
operator|=
name|Float
operator|.
name|NEGATIVE_INFINITY
expr_stmt|;
name|FieldComparator
argument_list|<
name|?
argument_list|>
index|[]
name|comparators
init|=
name|queue
operator|.
name|comparators
decl_stmt|;
comment|// Tell all comparators their top value:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|comparators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|FieldComparator
argument_list|<
name|Object
argument_list|>
name|comparator
init|=
operator|(
name|FieldComparator
argument_list|<
name|Object
argument_list|>
operator|)
name|comparators
index|[
name|i
index|]
decl_stmt|;
name|comparator
operator|.
name|setTopValue
argument_list|(
name|after
operator|.
name|fields
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getLeafCollector
specifier|public
name|LeafCollector
name|getLeafCollector
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|docBase
operator|=
name|context
operator|.
name|docBase
expr_stmt|;
specifier|final
name|int
name|afterDoc
init|=
name|after
operator|.
name|doc
operator|-
name|docBase
decl_stmt|;
return|return
operator|new
name|MultiComparatorLeafCollector
argument_list|(
name|queue
operator|.
name|getComparators
argument_list|(
name|context
argument_list|)
argument_list|,
name|queue
operator|.
name|getReverseMul
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("  collect doc=" + doc);
name|totalHits
operator|++
expr_stmt|;
name|float
name|score
init|=
name|Float
operator|.
name|NaN
decl_stmt|;
if|if
condition|(
name|trackMaxScore
condition|)
block|{
name|score
operator|=
name|scorer
operator|.
name|score
argument_list|()
expr_stmt|;
if|if
condition|(
name|score
operator|>
name|maxScore
condition|)
block|{
name|maxScore
operator|=
name|score
expr_stmt|;
block|}
block|}
if|if
condition|(
name|queueFull
condition|)
block|{
comment|// Fastmatch: return if this hit is no better than
comment|// the worst hit currently in the queue:
specifier|final
name|int
name|cmp
init|=
name|compareBottom
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
block|{
comment|// not competitive since documents are visited in doc id order
return|return;
block|}
block|}
specifier|final
name|int
name|topCmp
init|=
name|compareTop
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|topCmp
operator|>
literal|0
operator|||
operator|(
name|topCmp
operator|==
literal|0
operator|&&
name|doc
operator|<=
name|afterDoc
operator|)
condition|)
block|{
comment|// Already collected on a previous page
return|return;
block|}
if|if
condition|(
name|queueFull
condition|)
block|{
comment|// This hit is competitive - replace bottom element in queue& adjustTop
name|copy
argument_list|(
name|bottom
operator|.
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|// Compute score only if it is competitive.
if|if
condition|(
name|trackDocScores
operator|&&
operator|!
name|trackMaxScore
condition|)
block|{
name|score
operator|=
name|scorer
operator|.
name|score
argument_list|()
expr_stmt|;
block|}
name|updateBottom
argument_list|(
name|doc
argument_list|,
name|score
argument_list|)
expr_stmt|;
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|collectedHits
operator|++
expr_stmt|;
comment|// Startup transient: queue hasn't gathered numHits yet
specifier|final
name|int
name|slot
init|=
name|collectedHits
operator|-
literal|1
decl_stmt|;
comment|//System.out.println("    slot=" + slot);
comment|// Copy hit into queue
name|copy
argument_list|(
name|slot
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|// Compute score only if it is competitive.
if|if
condition|(
name|trackDocScores
operator|&&
operator|!
name|trackMaxScore
condition|)
block|{
name|score
operator|=
name|scorer
operator|.
name|score
argument_list|()
expr_stmt|;
block|}
name|bottom
operator|=
name|pq
operator|.
name|add
argument_list|(
operator|new
name|Entry
argument_list|(
name|slot
argument_list|,
name|docBase
operator|+
name|doc
argument_list|,
name|score
argument_list|)
argument_list|)
expr_stmt|;
name|queueFull
operator|=
name|collectedHits
operator|==
name|numHits
expr_stmt|;
if|if
condition|(
name|queueFull
condition|)
block|{
name|setBottom
argument_list|(
name|bottom
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|;
block|}
block|}
DECL|field|EMPTY_SCOREDOCS
specifier|private
specifier|static
specifier|final
name|ScoreDoc
index|[]
name|EMPTY_SCOREDOCS
init|=
operator|new
name|ScoreDoc
index|[
literal|0
index|]
decl_stmt|;
DECL|field|fillFields
specifier|private
specifier|final
name|boolean
name|fillFields
decl_stmt|;
comment|/*    * Stores the maximum score value encountered, needed for normalizing. If    * document scores are not tracked, this value is initialized to NaN.    */
DECL|field|maxScore
name|float
name|maxScore
init|=
name|Float
operator|.
name|NaN
decl_stmt|;
DECL|field|numHits
specifier|final
name|int
name|numHits
decl_stmt|;
DECL|field|bottom
name|FieldValueHitQueue
operator|.
name|Entry
name|bottom
init|=
literal|null
decl_stmt|;
DECL|field|queueFull
name|boolean
name|queueFull
decl_stmt|;
DECL|field|docBase
name|int
name|docBase
decl_stmt|;
DECL|field|needsScores
specifier|final
name|boolean
name|needsScores
decl_stmt|;
comment|// Declaring the constructor private prevents extending this class by anyone
comment|// else. Note that the class cannot be final since it's extended by the
comment|// internal versions. If someone will define a constructor with any other
comment|// visibility, then anyone will be able to extend the class, which is not what
comment|// we want.
DECL|method|TopFieldCollector
specifier|private
name|TopFieldCollector
parameter_list|(
name|PriorityQueue
argument_list|<
name|Entry
argument_list|>
name|pq
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|,
name|boolean
name|needsScores
parameter_list|)
block|{
name|super
argument_list|(
name|pq
argument_list|)
expr_stmt|;
name|this
operator|.
name|needsScores
operator|=
name|needsScores
expr_stmt|;
name|this
operator|.
name|numHits
operator|=
name|numHits
expr_stmt|;
name|this
operator|.
name|fillFields
operator|=
name|fillFields
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|needsScores
specifier|public
name|boolean
name|needsScores
parameter_list|()
block|{
return|return
name|needsScores
return|;
block|}
comment|/**    * Creates a new {@link TopFieldCollector} from the given    * arguments.    *    *<p><b>NOTE</b>: The instances returned by this method    * pre-allocate a full array of length    *<code>numHits</code>.    *    * @param sort    *          the sort criteria (SortFields).    * @param numHits    *          the number of results to collect.    * @param fillFields    *          specifies whether the actual field values should be returned on    *          the results (FieldDoc).    * @param trackDocScores    *          specifies whether document scores should be tracked and set on the    *          results. Note that if set to false, then the results' scores will    *          be set to Float.NaN. Setting this to true affects performance, as    *          it incurs the score computation on each competitive result.    *          Therefore if document scores are not required by the application,    *          it is recommended to set it to false.    * @param trackMaxScore    *          specifies whether the query's maxScore should be tracked and set    *          on the resulting {@link TopDocs}. Note that if set to false,    *          {@link TopDocs#getMaxScore()} returns Float.NaN. Setting this to    *          true affects performance as it incurs the score computation on    *          each result. Also, setting this true automatically sets    *<code>trackDocScores</code> to true as well.    * @return a {@link TopFieldCollector} instance which will sort the results by    *         the sort criteria.    * @throws IOException if there is a low-level I/O error    */
DECL|method|create
specifier|public
specifier|static
name|TopFieldCollector
name|create
parameter_list|(
name|Sort
name|sort
parameter_list|,
name|int
name|numHits
parameter_list|,
name|boolean
name|fillFields
parameter_list|,
name|boolean
name|trackDocScores
parameter_list|,
name|boolean
name|trackMaxScore
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|sort
argument_list|,
name|numHits
argument_list|,
literal|null
argument_list|,
name|fillFields
argument_list|,
name|trackDocScores
argument_list|,
name|trackMaxScore
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@link TopFieldCollector} from the given    * arguments.    *    *<p><b>NOTE</b>: The instances returned by this method    * pre-allocate a full array of length    *<code>numHits</code>.    *    * @param sort    *          the sort criteria (SortFields).    * @param numHits    *          the number of results to collect.    * @param after    *          only hits after this FieldDoc will be collected    * @param fillFields    *          specifies whether the actual field values should be returned on    *          the results (FieldDoc).    * @param trackDocScores    *          specifies whether document scores should be tracked and set on the    *          results. Note that if set to false, then the results' scores will    *          be set to Float.NaN. Setting this to true affects performance, as    *          it incurs the score computation on each competitive result.    *          Therefore if document scores are not required by the application,    *          it is recommended to set it to false.    * @param trackMaxScore    *          specifies whether the query's maxScore should be tracked and set    *          on the resulting {@link TopDocs}. Note that if set to false,    *          {@link TopDocs#getMaxScore()} returns Float.NaN. Setting this to    *          true affects performance as it incurs the score computation on    *          each result. Also, setting this true automatically sets    *<code>trackDocScores</code> to true as well.    * @return a {@link TopFieldCollector} instance which will sort the results by    *         the sort criteria.    * @throws IOException if there is a low-level I/O error    */
DECL|method|create
specifier|public
specifier|static
name|TopFieldCollector
name|create
parameter_list|(
name|Sort
name|sort
parameter_list|,
name|int
name|numHits
parameter_list|,
name|FieldDoc
name|after
parameter_list|,
name|boolean
name|fillFields
parameter_list|,
name|boolean
name|trackDocScores
parameter_list|,
name|boolean
name|trackMaxScore
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|sort
operator|.
name|fields
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Sort must contain at least one field"
argument_list|)
throw|;
block|}
if|if
condition|(
name|numHits
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"numHits must be> 0; please use TotalHitCountCollector if you just need the total hit count"
argument_list|)
throw|;
block|}
name|FieldValueHitQueue
argument_list|<
name|Entry
argument_list|>
name|queue
init|=
name|FieldValueHitQueue
operator|.
name|create
argument_list|(
name|sort
operator|.
name|fields
argument_list|,
name|numHits
argument_list|)
decl_stmt|;
if|if
condition|(
name|after
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|trackMaxScore
condition|)
block|{
return|return
operator|new
name|ScoringMaxScoreCollector
argument_list|(
name|sort
argument_list|,
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|trackDocScores
condition|)
block|{
return|return
operator|new
name|ScoringNoMaxScoreCollector
argument_list|(
name|sort
argument_list|,
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|NonScoringCollector
argument_list|(
name|sort
argument_list|,
name|queue
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|after
operator|.
name|fields
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"after.fields wasn't set; you must pass fillFields=true for the previous search"
argument_list|)
throw|;
block|}
if|if
condition|(
name|after
operator|.
name|fields
operator|.
name|length
operator|!=
name|sort
operator|.
name|getSort
argument_list|()
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"after.fields has "
operator|+
name|after
operator|.
name|fields
operator|.
name|length
operator|+
literal|" values but sort has "
operator|+
name|sort
operator|.
name|getSort
argument_list|()
operator|.
name|length
argument_list|)
throw|;
block|}
return|return
operator|new
name|PagingFieldCollector
argument_list|(
name|sort
argument_list|,
name|queue
argument_list|,
name|after
argument_list|,
name|numHits
argument_list|,
name|fillFields
argument_list|,
name|trackDocScores
argument_list|,
name|trackMaxScore
argument_list|)
return|;
block|}
block|}
DECL|method|add
specifier|final
name|void
name|add
parameter_list|(
name|int
name|slot
parameter_list|,
name|int
name|doc
parameter_list|,
name|float
name|score
parameter_list|)
block|{
name|bottom
operator|=
name|pq
operator|.
name|add
argument_list|(
operator|new
name|Entry
argument_list|(
name|slot
argument_list|,
name|docBase
operator|+
name|doc
argument_list|,
name|score
argument_list|)
argument_list|)
expr_stmt|;
name|queueFull
operator|=
name|totalHits
operator|==
name|numHits
expr_stmt|;
block|}
DECL|method|updateBottom
specifier|final
name|void
name|updateBottom
parameter_list|(
name|int
name|doc
parameter_list|)
block|{
comment|// bottom.score is already set to Float.NaN in add().
name|bottom
operator|.
name|doc
operator|=
name|docBase
operator|+
name|doc
expr_stmt|;
name|bottom
operator|=
name|pq
operator|.
name|updateTop
argument_list|()
expr_stmt|;
block|}
DECL|method|updateBottom
specifier|final
name|void
name|updateBottom
parameter_list|(
name|int
name|doc
parameter_list|,
name|float
name|score
parameter_list|)
block|{
name|bottom
operator|.
name|doc
operator|=
name|docBase
operator|+
name|doc
expr_stmt|;
name|bottom
operator|.
name|score
operator|=
name|score
expr_stmt|;
name|bottom
operator|=
name|pq
operator|.
name|updateTop
argument_list|()
expr_stmt|;
block|}
comment|/*    * Only the following callback methods need to be overridden since    * topDocs(int, int) calls them to return the results.    */
annotation|@
name|Override
DECL|method|populateResults
specifier|protected
name|void
name|populateResults
parameter_list|(
name|ScoreDoc
index|[]
name|results
parameter_list|,
name|int
name|howMany
parameter_list|)
block|{
if|if
condition|(
name|fillFields
condition|)
block|{
comment|// avoid casting if unnecessary.
name|FieldValueHitQueue
argument_list|<
name|Entry
argument_list|>
name|queue
init|=
operator|(
name|FieldValueHitQueue
argument_list|<
name|Entry
argument_list|>
operator|)
name|pq
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|howMany
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|results
index|[
name|i
index|]
operator|=
name|queue
operator|.
name|fillFields
argument_list|(
name|queue
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
name|howMany
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|Entry
name|entry
init|=
name|pq
operator|.
name|pop
argument_list|()
decl_stmt|;
name|results
index|[
name|i
index|]
operator|=
operator|new
name|FieldDoc
argument_list|(
name|entry
operator|.
name|doc
argument_list|,
name|entry
operator|.
name|score
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|newTopDocs
specifier|protected
name|TopDocs
name|newTopDocs
parameter_list|(
name|ScoreDoc
index|[]
name|results
parameter_list|,
name|int
name|start
parameter_list|)
block|{
if|if
condition|(
name|results
operator|==
literal|null
condition|)
block|{
name|results
operator|=
name|EMPTY_SCOREDOCS
expr_stmt|;
comment|// Set maxScore to NaN, in case this is a maxScore tracking collector.
name|maxScore
operator|=
name|Float
operator|.
name|NaN
expr_stmt|;
block|}
comment|// If this is a maxScoring tracking collector and there were no results,
return|return
operator|new
name|TopFieldDocs
argument_list|(
name|totalHits
argument_list|,
name|results
argument_list|,
operator|(
operator|(
name|FieldValueHitQueue
argument_list|<
name|Entry
argument_list|>
operator|)
name|pq
operator|)
operator|.
name|getFields
argument_list|()
argument_list|,
name|maxScore
argument_list|)
return|;
block|}
block|}
end_class
end_unit
