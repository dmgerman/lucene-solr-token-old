begin_unit
begin_package
DECL|package|org.apache.lucene.search
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReader
operator|.
name|CoreClosedListener
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|ReaderUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Accountable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Accountables
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RoaringDocIdSet
import|;
end_import
begin_comment
comment|/**  * A {@link QueryCache} that evicts queries using a LRU (least-recently-used)  * eviction policy in order to remain under a given maximum size and number of  * bytes used.  *  * This class is thread-safe.  *  * Note that query eviction runs in linear time with the total number of  * segments that have cache entries so this cache works best with  * {@link QueryCachingPolicy caching policies} that only cache on "large"  * segments, and it is advised to not share this cache across too many indices.  *  * Typical usage looks like this:  *<pre class="prettyprint">  *   final int maxNumberOfCachedQueries = 256;  *   final long maxRamBytesUsed = 50 * 1024L * 1024L; // 50MB  *   // these cache and policy instances can be shared across several queries and readers  *   // it is fine to eg. store them into static variables  *   final QueryCache queryCache = new LRUQueryCache(maxNumberOfCachedQueries, maxRamBytesUsed);  *   final QueryCachingPolicy defaultCachingPolicy = new UsageTrackingQueryCachingPolicy();  *  *   // ...  *  *   // Then at search time  *   Query myQuery = ...;  *   Query myCacheQuery = queryCache.doCache(myQuery, defaultCachingPolicy);  *   // myCacheQuery is now a wrapper around the original query that will interact with the cache  *   IndexSearcher searcher = ...;  *   TopDocs topDocs = searcher.search(new ConstantScoreQuery(myCacheQuery), 10);  *</pre>  *  * This cache exposes some global statistics ({@link #getHitCount() hit count},  * {@link #getMissCount() miss count}, {@link #getCacheSize() number of cache  * entries}, {@link #getCacheCount() total number of DocIdSets that have ever  * been cached}, {@link #getEvictionCount() number of evicted entries}). In  * case you would like to have more fine-grained statistics, such as per-index  * or per-query-class statistics, it is possible to override various callbacks:  * {@link #onHit}, {@link #onMiss},  * {@link #onQueryCache}, {@link #onQueryEviction},  * {@link #onDocIdSetCache}, {@link #onDocIdSetEviction} and {@link #onClear}.  * It is better to not perform heavy computations in these methods though since  * they are called synchronously and under a lock.  *  * @see QueryCachingPolicy  * @lucene.experimental  */
end_comment
begin_class
DECL|class|LRUQueryCache
specifier|public
class|class
name|LRUQueryCache
implements|implements
name|QueryCache
implements|,
name|Accountable
block|{
comment|// memory usage of a simple term query
DECL|field|QUERY_DEFAULT_RAM_BYTES_USED
specifier|static
specifier|final
name|long
name|QUERY_DEFAULT_RAM_BYTES_USED
init|=
literal|192
decl_stmt|;
DECL|field|HASHTABLE_RAM_BYTES_PER_ENTRY
specifier|static
specifier|final
name|long
name|HASHTABLE_RAM_BYTES_PER_ENTRY
init|=
literal|2
operator|*
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
comment|// key + value
operator|*
literal|2
decl_stmt|;
comment|// hash tables need to be oversized to avoid collisions, assume 2x capacity
DECL|field|LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY
specifier|static
specifier|final
name|long
name|LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY
init|=
name|HASHTABLE_RAM_BYTES_PER_ENTRY
operator|+
literal|2
operator|*
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
decl_stmt|;
comment|// previous& next references
DECL|field|maxSize
specifier|private
specifier|final
name|int
name|maxSize
decl_stmt|;
DECL|field|maxRamBytesUsed
specifier|private
specifier|final
name|long
name|maxRamBytesUsed
decl_stmt|;
comment|// maps queries that are contained in the cache to a singleton so that this
comment|// cache does not store several copies of the same query
DECL|field|uniqueQueries
specifier|private
specifier|final
name|Map
argument_list|<
name|Query
argument_list|,
name|Query
argument_list|>
name|uniqueQueries
decl_stmt|;
comment|// The contract between this set and the per-leaf caches is that per-leaf caches
comment|// are only allowed to store sub-sets of the queries that are contained in
comment|// mostRecentlyUsedQueries. This is why write operations are performed under a lock
DECL|field|mostRecentlyUsedQueries
specifier|private
specifier|final
name|Set
argument_list|<
name|Query
argument_list|>
name|mostRecentlyUsedQueries
decl_stmt|;
DECL|field|cache
specifier|private
specifier|final
name|Map
argument_list|<
name|Object
argument_list|,
name|LeafCache
argument_list|>
name|cache
decl_stmt|;
comment|// these variables are volatile so that we do not need to sync reads
comment|// but increments need to be performed under the lock
DECL|field|ramBytesUsed
specifier|private
specifier|volatile
name|long
name|ramBytesUsed
decl_stmt|;
DECL|field|hitCount
specifier|private
specifier|volatile
name|long
name|hitCount
decl_stmt|;
DECL|field|missCount
specifier|private
specifier|volatile
name|long
name|missCount
decl_stmt|;
DECL|field|cacheCount
specifier|private
specifier|volatile
name|long
name|cacheCount
decl_stmt|;
DECL|field|cacheSize
specifier|private
specifier|volatile
name|long
name|cacheSize
decl_stmt|;
comment|/**    * Create a new instance that will cache at most<code>maxSize</code> queries    * with at most<code>maxRamBytesUsed</code> bytes of memory.    */
DECL|method|LRUQueryCache
specifier|public
name|LRUQueryCache
parameter_list|(
name|int
name|maxSize
parameter_list|,
name|long
name|maxRamBytesUsed
parameter_list|)
block|{
name|this
operator|.
name|maxSize
operator|=
name|maxSize
expr_stmt|;
name|this
operator|.
name|maxRamBytesUsed
operator|=
name|maxRamBytesUsed
expr_stmt|;
name|uniqueQueries
operator|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
literal|16
argument_list|,
literal|0.75f
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|mostRecentlyUsedQueries
operator|=
name|uniqueQueries
operator|.
name|keySet
argument_list|()
expr_stmt|;
name|cache
operator|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|ramBytesUsed
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * Expert: callback when there is a cache hit on a given query.    * Implementing this method is typically useful in order to compute more    * fine-grained statistics about the query cache.    * @see #onMiss    * @lucene.experimental    */
DECL|method|onHit
specifier|protected
name|void
name|onHit
parameter_list|(
name|Object
name|readerCoreKey
parameter_list|,
name|Query
name|query
parameter_list|)
block|{
name|hitCount
operator|+=
literal|1
expr_stmt|;
block|}
comment|/**    * Expert: callback when there is a cache miss on a given query.    * @see #onHit    * @lucene.experimental    */
DECL|method|onMiss
specifier|protected
name|void
name|onMiss
parameter_list|(
name|Object
name|readerCoreKey
parameter_list|,
name|Query
name|query
parameter_list|)
block|{
assert|assert
name|query
operator|!=
literal|null
assert|;
name|missCount
operator|+=
literal|1
expr_stmt|;
block|}
comment|/**    * Expert: callback when a query is added to this cache.    * Implementing this method is typically useful in order to compute more    * fine-grained statistics about the query cache.    * @see #onQueryEviction    * @lucene.experimental    */
DECL|method|onQueryCache
specifier|protected
name|void
name|onQueryCache
parameter_list|(
name|Query
name|query
parameter_list|,
name|long
name|ramBytesUsed
parameter_list|)
block|{
name|this
operator|.
name|ramBytesUsed
operator|+=
name|ramBytesUsed
expr_stmt|;
block|}
comment|/**    * Expert: callback when a query is evicted from this cache.    * @see #onQueryCache    * @lucene.experimental    */
DECL|method|onQueryEviction
specifier|protected
name|void
name|onQueryEviction
parameter_list|(
name|Query
name|query
parameter_list|,
name|long
name|ramBytesUsed
parameter_list|)
block|{
name|this
operator|.
name|ramBytesUsed
operator|-=
name|ramBytesUsed
expr_stmt|;
block|}
comment|/**    * Expert: callback when a {@link DocIdSet} is added to this cache.    * Implementing this method is typically useful in order to compute more    * fine-grained statistics about the query cache.    * @see #onDocIdSetEviction    * @lucene.experimental    */
DECL|method|onDocIdSetCache
specifier|protected
name|void
name|onDocIdSetCache
parameter_list|(
name|Object
name|readerCoreKey
parameter_list|,
name|long
name|ramBytesUsed
parameter_list|)
block|{
name|cacheSize
operator|+=
literal|1
expr_stmt|;
name|cacheCount
operator|+=
literal|1
expr_stmt|;
name|this
operator|.
name|ramBytesUsed
operator|+=
name|ramBytesUsed
expr_stmt|;
block|}
comment|/**    * Expert: callback when one or more {@link DocIdSet}s are removed from this    * cache.    * @see #onDocIdSetCache    * @lucene.experimental    */
DECL|method|onDocIdSetEviction
specifier|protected
name|void
name|onDocIdSetEviction
parameter_list|(
name|Object
name|readerCoreKey
parameter_list|,
name|int
name|numEntries
parameter_list|,
name|long
name|sumRamBytesUsed
parameter_list|)
block|{
name|this
operator|.
name|ramBytesUsed
operator|-=
name|sumRamBytesUsed
expr_stmt|;
name|cacheSize
operator|-=
name|numEntries
expr_stmt|;
block|}
comment|/**    * Expert: callback when the cache is completely cleared.    * @lucene.experimental    */
DECL|method|onClear
specifier|protected
name|void
name|onClear
parameter_list|()
block|{
name|ramBytesUsed
operator|=
literal|0
expr_stmt|;
name|cacheSize
operator|=
literal|0
expr_stmt|;
block|}
comment|/** Whether evictions are required. */
DECL|method|requiresEviction
name|boolean
name|requiresEviction
parameter_list|()
block|{
specifier|final
name|int
name|size
init|=
name|mostRecentlyUsedQueries
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|size
operator|>
name|maxSize
operator|||
name|ramBytesUsed
argument_list|()
operator|>
name|maxRamBytesUsed
return|;
block|}
block|}
DECL|method|get
specifier|synchronized
name|DocIdSet
name|get
parameter_list|(
name|Query
name|key
parameter_list|,
name|LeafReaderContext
name|context
parameter_list|)
block|{
assert|assert
name|key
operator|instanceof
name|BoostQuery
operator|==
literal|false
assert|;
assert|assert
name|key
operator|instanceof
name|ConstantScoreQuery
operator|==
literal|false
assert|;
specifier|final
name|Object
name|readerKey
init|=
name|context
operator|.
name|reader
argument_list|()
operator|.
name|getCoreCacheKey
argument_list|()
decl_stmt|;
specifier|final
name|LeafCache
name|leafCache
init|=
name|cache
operator|.
name|get
argument_list|(
name|readerKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|leafCache
operator|==
literal|null
condition|)
block|{
name|onMiss
argument_list|(
name|readerKey
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// this get call moves the query to the most-recently-used position
specifier|final
name|Query
name|singleton
init|=
name|uniqueQueries
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|singleton
operator|==
literal|null
condition|)
block|{
name|onMiss
argument_list|(
name|readerKey
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|DocIdSet
name|cached
init|=
name|leafCache
operator|.
name|get
argument_list|(
name|singleton
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|==
literal|null
condition|)
block|{
name|onMiss
argument_list|(
name|readerKey
argument_list|,
name|singleton
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|onHit
argument_list|(
name|readerKey
argument_list|,
name|singleton
argument_list|)
expr_stmt|;
block|}
return|return
name|cached
return|;
block|}
DECL|method|putIfAbsent
specifier|synchronized
name|void
name|putIfAbsent
parameter_list|(
name|Query
name|query
parameter_list|,
name|LeafReaderContext
name|context
parameter_list|,
name|DocIdSet
name|set
parameter_list|)
block|{
comment|// under a lock to make sure that mostRecentlyUsedQueries and cache remain sync'ed
comment|// we don't want to have user-provided queries as keys in our cache since queries are mutable
assert|assert
name|query
operator|instanceof
name|BoostQuery
operator|==
literal|false
assert|;
assert|assert
name|query
operator|instanceof
name|ConstantScoreQuery
operator|==
literal|false
assert|;
name|Query
name|singleton
init|=
name|uniqueQueries
operator|.
name|putIfAbsent
argument_list|(
name|query
argument_list|,
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|singleton
operator|==
literal|null
condition|)
block|{
name|onQueryCache
argument_list|(
name|singleton
argument_list|,
name|LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY
operator|+
name|ramBytesUsed
argument_list|(
name|query
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|query
operator|=
name|singleton
expr_stmt|;
block|}
specifier|final
name|Object
name|key
init|=
name|context
operator|.
name|reader
argument_list|()
operator|.
name|getCoreCacheKey
argument_list|()
decl_stmt|;
name|LeafCache
name|leafCache
init|=
name|cache
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|leafCache
operator|==
literal|null
condition|)
block|{
name|leafCache
operator|=
operator|new
name|LeafCache
argument_list|(
name|key
argument_list|)
expr_stmt|;
specifier|final
name|LeafCache
name|previous
init|=
name|cache
operator|.
name|put
argument_list|(
name|context
operator|.
name|reader
argument_list|()
operator|.
name|getCoreCacheKey
argument_list|()
argument_list|,
name|leafCache
argument_list|)
decl_stmt|;
name|ramBytesUsed
operator|+=
name|HASHTABLE_RAM_BYTES_PER_ENTRY
expr_stmt|;
assert|assert
name|previous
operator|==
literal|null
assert|;
comment|// we just created a new leaf cache, need to register a close listener
name|context
operator|.
name|reader
argument_list|()
operator|.
name|addCoreClosedListener
argument_list|(
operator|new
name|CoreClosedListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onClose
parameter_list|(
name|Object
name|ownerCoreCacheKey
parameter_list|)
block|{
name|clearCoreCacheKey
argument_list|(
name|ownerCoreCacheKey
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|leafCache
operator|.
name|putIfAbsent
argument_list|(
name|query
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|evictIfNecessary
argument_list|()
expr_stmt|;
block|}
DECL|method|evictIfNecessary
specifier|synchronized
name|void
name|evictIfNecessary
parameter_list|()
block|{
comment|// under a lock to make sure that mostRecentlyUsedQueries and cache keep sync'ed
if|if
condition|(
name|requiresEviction
argument_list|()
condition|)
block|{
name|Iterator
argument_list|<
name|Query
argument_list|>
name|iterator
init|=
name|mostRecentlyUsedQueries
operator|.
name|iterator
argument_list|()
decl_stmt|;
do|do
block|{
specifier|final
name|Query
name|query
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|mostRecentlyUsedQueries
operator|.
name|size
argument_list|()
decl_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|mostRecentlyUsedQueries
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// size did not decrease, because the hash of the query changed since it has been
comment|// put into the cache
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|(
literal|"Removal from the cache failed! This "
operator|+
literal|"is probably due to a query which has been modified after having been put into "
operator|+
literal|" the cache or a badly implemented clone(). Query class: ["
operator|+
name|query
operator|.
name|getClass
argument_list|()
operator|+
literal|"], query: ["
operator|+
name|query
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|onEviction
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
operator|&&
name|requiresEviction
argument_list|()
condition|)
do|;
block|}
block|}
comment|/**    * Remove all cache entries for the given core cache key.    */
DECL|method|clearCoreCacheKey
specifier|public
specifier|synchronized
name|void
name|clearCoreCacheKey
parameter_list|(
name|Object
name|coreKey
parameter_list|)
block|{
specifier|final
name|LeafCache
name|leafCache
init|=
name|cache
operator|.
name|remove
argument_list|(
name|coreKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|leafCache
operator|!=
literal|null
condition|)
block|{
name|ramBytesUsed
operator|-=
name|HASHTABLE_RAM_BYTES_PER_ENTRY
expr_stmt|;
name|onDocIdSetEviction
argument_list|(
name|coreKey
argument_list|,
name|leafCache
operator|.
name|cache
operator|.
name|size
argument_list|()
argument_list|,
name|leafCache
operator|.
name|ramBytesUsed
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Remove all cache entries for the given query.    */
DECL|method|clearQuery
specifier|public
specifier|synchronized
name|void
name|clearQuery
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
specifier|final
name|Query
name|singleton
init|=
name|uniqueQueries
operator|.
name|remove
argument_list|(
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|singleton
operator|!=
literal|null
condition|)
block|{
name|onEviction
argument_list|(
name|singleton
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|onEviction
specifier|private
name|void
name|onEviction
parameter_list|(
name|Query
name|singleton
parameter_list|)
block|{
name|onQueryEviction
argument_list|(
name|singleton
argument_list|,
name|LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY
operator|+
name|ramBytesUsed
argument_list|(
name|singleton
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|LeafCache
name|leafCache
range|:
name|cache
operator|.
name|values
argument_list|()
control|)
block|{
name|leafCache
operator|.
name|remove
argument_list|(
name|singleton
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Clear the content of this cache.    */
DECL|method|clear
specifier|public
specifier|synchronized
name|void
name|clear
parameter_list|()
block|{
name|cache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mostRecentlyUsedQueries
operator|.
name|clear
argument_list|()
expr_stmt|;
name|onClear
argument_list|()
expr_stmt|;
block|}
comment|// pkg-private for testing
DECL|method|assertConsistent
specifier|synchronized
name|void
name|assertConsistent
parameter_list|()
block|{
if|if
condition|(
name|requiresEviction
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"requires evictions: size="
operator|+
name|mostRecentlyUsedQueries
operator|.
name|size
argument_list|()
operator|+
literal|", maxSize="
operator|+
name|maxSize
operator|+
literal|", ramBytesUsed="
operator|+
name|ramBytesUsed
argument_list|()
operator|+
literal|", maxRamBytesUsed="
operator|+
name|maxRamBytesUsed
argument_list|)
throw|;
block|}
for|for
control|(
name|LeafCache
name|leafCache
range|:
name|cache
operator|.
name|values
argument_list|()
control|)
block|{
name|Set
argument_list|<
name|Query
argument_list|>
name|keys
init|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
name|keys
operator|.
name|addAll
argument_list|(
name|leafCache
operator|.
name|cache
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|keys
operator|.
name|removeAll
argument_list|(
name|mostRecentlyUsedQueries
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"One leaf cache contains more keys than the top-level cache: "
operator|+
name|keys
argument_list|)
throw|;
block|}
block|}
name|long
name|recomputedRamBytesUsed
init|=
name|HASHTABLE_RAM_BYTES_PER_ENTRY
operator|*
name|cache
operator|.
name|size
argument_list|()
operator|+
name|LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY
operator|*
name|uniqueQueries
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|Query
name|query
range|:
name|mostRecentlyUsedQueries
control|)
block|{
name|recomputedRamBytesUsed
operator|+=
name|ramBytesUsed
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|LeafCache
name|leafCache
range|:
name|cache
operator|.
name|values
argument_list|()
control|)
block|{
name|recomputedRamBytesUsed
operator|+=
name|HASHTABLE_RAM_BYTES_PER_ENTRY
operator|*
name|leafCache
operator|.
name|cache
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|DocIdSet
name|set
range|:
name|leafCache
operator|.
name|cache
operator|.
name|values
argument_list|()
control|)
block|{
name|recomputedRamBytesUsed
operator|+=
name|set
operator|.
name|ramBytesUsed
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|recomputedRamBytesUsed
operator|!=
name|ramBytesUsed
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"ramBytesUsed mismatch : "
operator|+
name|ramBytesUsed
operator|+
literal|" != "
operator|+
name|recomputedRamBytesUsed
argument_list|)
throw|;
block|}
name|long
name|recomputedCacheSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|LeafCache
name|leafCache
range|:
name|cache
operator|.
name|values
argument_list|()
control|)
block|{
name|recomputedCacheSize
operator|+=
name|leafCache
operator|.
name|cache
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|recomputedCacheSize
operator|!=
name|getCacheSize
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"cacheSize mismatch : "
operator|+
name|getCacheSize
argument_list|()
operator|+
literal|" != "
operator|+
name|recomputedCacheSize
argument_list|)
throw|;
block|}
block|}
comment|// pkg-private for testing
comment|// return the list of cached queries in LRU order
DECL|method|cachedQueries
specifier|synchronized
name|List
argument_list|<
name|Query
argument_list|>
name|cachedQueries
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|mostRecentlyUsedQueries
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doCache
specifier|public
name|Weight
name|doCache
parameter_list|(
name|Weight
name|weight
parameter_list|,
name|QueryCachingPolicy
name|policy
parameter_list|)
block|{
while|while
condition|(
name|weight
operator|instanceof
name|CachingWrapperWeight
condition|)
block|{
name|weight
operator|=
operator|(
operator|(
name|CachingWrapperWeight
operator|)
name|weight
operator|)
operator|.
name|in
expr_stmt|;
block|}
return|return
operator|new
name|CachingWrapperWeight
argument_list|(
name|weight
argument_list|,
name|policy
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
return|return
name|ramBytesUsed
return|;
block|}
annotation|@
name|Override
DECL|method|getChildResources
specifier|public
name|Collection
argument_list|<
name|Accountable
argument_list|>
name|getChildResources
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
return|return
name|Accountables
operator|.
name|namedAccountables
argument_list|(
literal|"segment"
argument_list|,
name|cache
argument_list|)
return|;
block|}
block|}
comment|/**    * Return the number of bytes used by the given query. The default    * implementation returns {@link Accountable#ramBytesUsed()} if the query    * implements {@link Accountable} and<code>1024</code> otherwise.    */
DECL|method|ramBytesUsed
specifier|protected
name|long
name|ramBytesUsed
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
if|if
condition|(
name|query
operator|instanceof
name|Accountable
condition|)
block|{
return|return
operator|(
operator|(
name|Accountable
operator|)
name|query
operator|)
operator|.
name|ramBytesUsed
argument_list|()
return|;
block|}
return|return
name|QUERY_DEFAULT_RAM_BYTES_USED
return|;
block|}
comment|/**    * Default cache implementation: uses {@link RoaringDocIdSet}.    */
DECL|method|cacheImpl
specifier|protected
name|DocIdSet
name|cacheImpl
parameter_list|(
name|BulkScorer
name|scorer
parameter_list|,
name|int
name|maxDoc
parameter_list|)
throws|throws
name|IOException
block|{
name|RoaringDocIdSet
operator|.
name|Builder
name|builder
init|=
operator|new
name|RoaringDocIdSet
operator|.
name|Builder
argument_list|(
name|maxDoc
argument_list|)
decl_stmt|;
name|scorer
operator|.
name|score
argument_list|(
operator|new
name|LeafCollector
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|setScorer
parameter_list|(
name|Scorer
name|scorer
parameter_list|)
throws|throws
name|IOException
block|{}
annotation|@
name|Override
specifier|public
name|void
name|collect
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|builder
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Return the total number of times that a {@link Query} has been looked up    * in this {@link QueryCache}. Note that this number is incremented once per    * segment so running a cached query only once will increment this counter    * by the number of segments that are wrapped by the searcher.    * Note that by definition, {@link #getTotalCount()} is the sum of    * {@link #getHitCount()} and {@link #getMissCount()}.    * @see #getHitCount()    * @see #getMissCount()    */
DECL|method|getTotalCount
specifier|public
specifier|final
name|long
name|getTotalCount
parameter_list|()
block|{
return|return
name|getHitCount
argument_list|()
operator|+
name|getMissCount
argument_list|()
return|;
block|}
comment|/**    * Over the {@link #getTotalCount() total} number of times that a query has    * been looked up, return how many times a cached {@link DocIdSet} has been    * found and returned.    * @see #getTotalCount()    * @see #getMissCount()    */
DECL|method|getHitCount
specifier|public
specifier|final
name|long
name|getHitCount
parameter_list|()
block|{
return|return
name|hitCount
return|;
block|}
comment|/**    * Over the {@link #getTotalCount() total} number of times that a query has    * been looked up, return how many times this query was not contained in the    * cache.    * @see #getTotalCount()    * @see #getHitCount()    */
DECL|method|getMissCount
specifier|public
specifier|final
name|long
name|getMissCount
parameter_list|()
block|{
return|return
name|missCount
return|;
block|}
comment|/**    * Return the total number of {@link DocIdSet}s which are currently stored    * in the cache.    * @see #getCacheCount()    * @see #getEvictionCount()    */
DECL|method|getCacheSize
specifier|public
specifier|final
name|long
name|getCacheSize
parameter_list|()
block|{
return|return
name|cacheSize
return|;
block|}
comment|/**    * Return the total number of cache entries that have been generated and put    * in the cache. It is highly desirable to have a {@link #getHitCount() hit    * count} that is much higher than the {@link #getCacheCount() cache count}    * as the opposite would indicate that the query cache makes efforts in order    * to cache queries but then they do not get reused.    * @see #getCacheSize()    * @see #getEvictionCount()    */
DECL|method|getCacheCount
specifier|public
specifier|final
name|long
name|getCacheCount
parameter_list|()
block|{
return|return
name|cacheCount
return|;
block|}
comment|/**    * Return the number of cache entries that have been removed from the cache    * either in order to stay under the maximum configured size/ram usage, or    * because a segment has been closed. High numbers of evictions might mean    * that queries are not reused or that the {@link QueryCachingPolicy    * caching policy} caches too aggressively on NRT segments which get merged    * early.    * @see #getCacheCount()    * @see #getCacheSize()    */
DECL|method|getEvictionCount
specifier|public
specifier|final
name|long
name|getEvictionCount
parameter_list|()
block|{
return|return
name|getCacheCount
argument_list|()
operator|-
name|getCacheSize
argument_list|()
return|;
block|}
comment|// this class is not thread-safe, everything but ramBytesUsed needs to be called under a lock
DECL|class|LeafCache
specifier|private
class|class
name|LeafCache
implements|implements
name|Accountable
block|{
DECL|field|key
specifier|private
specifier|final
name|Object
name|key
decl_stmt|;
DECL|field|cache
specifier|private
specifier|final
name|Map
argument_list|<
name|Query
argument_list|,
name|DocIdSet
argument_list|>
name|cache
decl_stmt|;
DECL|field|ramBytesUsed
specifier|private
specifier|volatile
name|long
name|ramBytesUsed
decl_stmt|;
DECL|method|LeafCache
name|LeafCache
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|cache
operator|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|ramBytesUsed
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|onDocIdSetCache
specifier|private
name|void
name|onDocIdSetCache
parameter_list|(
name|long
name|ramBytesUsed
parameter_list|)
block|{
name|this
operator|.
name|ramBytesUsed
operator|+=
name|ramBytesUsed
expr_stmt|;
name|LRUQueryCache
operator|.
name|this
operator|.
name|onDocIdSetCache
argument_list|(
name|key
argument_list|,
name|ramBytesUsed
argument_list|)
expr_stmt|;
block|}
DECL|method|onDocIdSetEviction
specifier|private
name|void
name|onDocIdSetEviction
parameter_list|(
name|long
name|ramBytesUsed
parameter_list|)
block|{
name|this
operator|.
name|ramBytesUsed
operator|-=
name|ramBytesUsed
expr_stmt|;
name|LRUQueryCache
operator|.
name|this
operator|.
name|onDocIdSetEviction
argument_list|(
name|key
argument_list|,
literal|1
argument_list|,
name|ramBytesUsed
argument_list|)
expr_stmt|;
block|}
DECL|method|get
name|DocIdSet
name|get
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
assert|assert
name|query
operator|instanceof
name|BoostQuery
operator|==
literal|false
assert|;
assert|assert
name|query
operator|instanceof
name|ConstantScoreQuery
operator|==
literal|false
assert|;
return|return
name|cache
operator|.
name|get
argument_list|(
name|query
argument_list|)
return|;
block|}
DECL|method|putIfAbsent
name|void
name|putIfAbsent
parameter_list|(
name|Query
name|query
parameter_list|,
name|DocIdSet
name|set
parameter_list|)
block|{
assert|assert
name|query
operator|instanceof
name|BoostQuery
operator|==
literal|false
assert|;
assert|assert
name|query
operator|instanceof
name|ConstantScoreQuery
operator|==
literal|false
assert|;
if|if
condition|(
name|cache
operator|.
name|putIfAbsent
argument_list|(
name|query
argument_list|,
name|set
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// the set was actually put
name|onDocIdSetCache
argument_list|(
name|HASHTABLE_RAM_BYTES_PER_ENTRY
operator|+
name|set
operator|.
name|ramBytesUsed
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|remove
name|void
name|remove
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
assert|assert
name|query
operator|instanceof
name|BoostQuery
operator|==
literal|false
assert|;
assert|assert
name|query
operator|instanceof
name|ConstantScoreQuery
operator|==
literal|false
assert|;
name|DocIdSet
name|removed
init|=
name|cache
operator|.
name|remove
argument_list|(
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
operator|!=
literal|null
condition|)
block|{
name|onDocIdSetEviction
argument_list|(
name|HASHTABLE_RAM_BYTES_PER_ENTRY
operator|+
name|removed
operator|.
name|ramBytesUsed
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
return|return
name|ramBytesUsed
return|;
block|}
block|}
DECL|class|CachingWrapperWeight
specifier|private
class|class
name|CachingWrapperWeight
extends|extends
name|ConstantScoreWeight
block|{
DECL|field|in
specifier|private
specifier|final
name|Weight
name|in
decl_stmt|;
DECL|field|policy
specifier|private
specifier|final
name|QueryCachingPolicy
name|policy
decl_stmt|;
comment|// we use an AtomicBoolean because Weight.scorer may be called from multiple
comment|// threads when IndexSearcher is created with threads
DECL|field|used
specifier|private
specifier|final
name|AtomicBoolean
name|used
decl_stmt|;
DECL|method|CachingWrapperWeight
name|CachingWrapperWeight
parameter_list|(
name|Weight
name|in
parameter_list|,
name|QueryCachingPolicy
name|policy
parameter_list|)
block|{
name|super
argument_list|(
name|in
operator|.
name|getQuery
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|policy
operator|=
name|policy
expr_stmt|;
name|used
operator|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|extractTerms
specifier|public
name|void
name|extractTerms
parameter_list|(
name|Set
argument_list|<
name|Term
argument_list|>
name|terms
parameter_list|)
block|{
name|in
operator|.
name|extractTerms
argument_list|(
name|terms
argument_list|)
expr_stmt|;
block|}
DECL|method|cacheEntryHasReasonableWorstCaseSize
specifier|private
name|boolean
name|cacheEntryHasReasonableWorstCaseSize
parameter_list|(
name|int
name|maxDoc
parameter_list|)
block|{
comment|// The worst-case (dense) is a bit set which needs one bit per document
specifier|final
name|long
name|worstCaseRamUsage
init|=
name|maxDoc
operator|/
literal|8
decl_stmt|;
specifier|final
name|long
name|totalRamAvailable
init|=
name|maxRamBytesUsed
decl_stmt|;
comment|// Imagine the worst-case that a cache entry is large than the size of
comment|// the cache: not only will this entry be trashed immediately but it
comment|// will also evict all current entries from the cache. For this reason
comment|// we only cache on an IndexReader if we have available room for
comment|// 5 different filters on this reader to avoid excessive trashing
return|return
name|worstCaseRamUsage
operator|*
literal|5
operator|<
name|totalRamAvailable
return|;
block|}
DECL|method|cache
specifier|private
name|DocIdSet
name|cache
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|BulkScorer
name|scorer
init|=
name|in
operator|.
name|bulkScorer
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|scorer
operator|==
literal|null
condition|)
block|{
return|return
name|DocIdSet
operator|.
name|EMPTY
return|;
block|}
else|else
block|{
return|return
name|cacheImpl
argument_list|(
name|scorer
argument_list|,
name|context
operator|.
name|reader
argument_list|()
operator|.
name|maxDoc
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|method|shouldCache
specifier|private
name|boolean
name|shouldCache
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|cacheEntryHasReasonableWorstCaseSize
argument_list|(
name|ReaderUtil
operator|.
name|getTopLevelContext
argument_list|(
name|context
argument_list|)
operator|.
name|reader
argument_list|()
operator|.
name|maxDoc
argument_list|()
argument_list|)
operator|&&
name|policy
operator|.
name|shouldCache
argument_list|(
name|in
operator|.
name|getQuery
argument_list|()
argument_list|,
name|context
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|scorer
specifier|public
name|Scorer
name|scorer
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|used
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|policy
operator|.
name|onUse
argument_list|(
name|getQuery
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|DocIdSet
name|docIdSet
init|=
name|get
argument_list|(
name|in
operator|.
name|getQuery
argument_list|()
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|docIdSet
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|shouldCache
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|docIdSet
operator|=
name|cache
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|putIfAbsent
argument_list|(
name|in
operator|.
name|getQuery
argument_list|()
argument_list|,
name|context
argument_list|,
name|docIdSet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|in
operator|.
name|scorer
argument_list|(
name|context
argument_list|)
return|;
block|}
block|}
assert|assert
name|docIdSet
operator|!=
literal|null
assert|;
if|if
condition|(
name|docIdSet
operator|==
name|DocIdSet
operator|.
name|EMPTY
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|DocIdSetIterator
name|disi
init|=
name|docIdSet
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|disi
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|ConstantScoreScorer
argument_list|(
name|this
argument_list|,
literal|0f
argument_list|,
name|disi
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|bulkScorer
specifier|public
name|BulkScorer
name|bulkScorer
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|used
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|policy
operator|.
name|onUse
argument_list|(
name|getQuery
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|DocIdSet
name|docIdSet
init|=
name|get
argument_list|(
name|in
operator|.
name|getQuery
argument_list|()
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|docIdSet
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|shouldCache
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|docIdSet
operator|=
name|cache
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|putIfAbsent
argument_list|(
name|in
operator|.
name|getQuery
argument_list|()
argument_list|,
name|context
argument_list|,
name|docIdSet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|in
operator|.
name|bulkScorer
argument_list|(
name|context
argument_list|)
return|;
block|}
block|}
assert|assert
name|docIdSet
operator|!=
literal|null
assert|;
if|if
condition|(
name|docIdSet
operator|==
name|DocIdSet
operator|.
name|EMPTY
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|DocIdSetIterator
name|disi
init|=
name|docIdSet
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|disi
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|DefaultBulkScorer
argument_list|(
operator|new
name|ConstantScoreScorer
argument_list|(
name|this
argument_list|,
literal|0f
argument_list|,
name|disi
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
end_class
end_unit
