begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|NoSuchFileException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CollectionUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Constants
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|InfoStream
import|;
end_import
begin_comment
comment|/*  * This class keeps track of each SegmentInfos instance that  * is still "live", either because it corresponds to a  * segments_N file in the Directory (a "commit", i.e. a  * committed SegmentInfos) or because it's an in-memory  * SegmentInfos that a writer is actively updating but has  * not yet committed.  This class uses simple reference  * counting to map the live SegmentInfos instances to  * individual files in the Directory.  *  * The same directory file may be referenced by more than  * one IndexCommit, i.e. more than one SegmentInfos.  * Therefore we count how many commits reference each file.  * When all the commits referencing a certain file have been  * deleted, the refcount for that file becomes zero, and the  * file is deleted.  *  * A separate deletion policy interface  * (IndexDeletionPolicy) is consulted on creation (onInit)  * and once per commit (onCommit), to decide when a commit  * should be removed.  *  * It is the business of the IndexDeletionPolicy to choose  * when to delete commit points.  The actual mechanics of  * file deletion, retrying, etc, derived from the deletion  * of commit points is the business of the IndexFileDeleter.  *  * The current default deletion policy is {@link  * KeepOnlyLastCommitDeletionPolicy}, which removes all  * prior commits when a new commit has completed.  This  * matches the behavior before 2.2.  *  * Note that you must hold the write.lock before  * instantiating this class.  It opens segments_N file(s)  * directly with no retry logic.  */
end_comment
begin_class
DECL|class|IndexFileDeleter
specifier|final
class|class
name|IndexFileDeleter
implements|implements
name|Closeable
block|{
comment|/* Reference count for all files in the index.    * Counts how many existing commits reference a file.    **/
DECL|field|refCounts
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|RefCount
argument_list|>
name|refCounts
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/* Holds all commits (segments_N) currently in the index.    * This will have just 1 commit if you are using the    * default delete policy (KeepOnlyLastCommitDeletionPolicy).    * Other policies may leave commit points live for longer    * in which case this list would be longer than 1: */
DECL|field|commits
specifier|private
name|List
argument_list|<
name|CommitPoint
argument_list|>
name|commits
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/* Holds files we had incref'd from the previous    * non-commit checkpoint: */
DECL|field|lastFiles
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|lastFiles
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/* Commits that the IndexDeletionPolicy have decided to delete: */
DECL|field|commitsToDelete
specifier|private
name|List
argument_list|<
name|CommitPoint
argument_list|>
name|commitsToDelete
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|infoStream
specifier|private
specifier|final
name|InfoStream
name|infoStream
decl_stmt|;
DECL|field|directoryOrig
specifier|private
specifier|final
name|Directory
name|directoryOrig
decl_stmt|;
comment|// for commit point metadata
DECL|field|directory
specifier|private
specifier|final
name|Directory
name|directory
decl_stmt|;
DECL|field|policy
specifier|private
specifier|final
name|IndexDeletionPolicy
name|policy
decl_stmt|;
DECL|field|startingCommitDeleted
specifier|final
name|boolean
name|startingCommitDeleted
decl_stmt|;
DECL|field|lastSegmentInfos
specifier|private
name|SegmentInfos
name|lastSegmentInfos
decl_stmt|;
comment|/** Change to true to see details of reference counts when    *  infoStream is enabled */
DECL|field|VERBOSE_REF_COUNTS
specifier|public
specifier|static
name|boolean
name|VERBOSE_REF_COUNTS
init|=
literal|false
decl_stmt|;
DECL|field|writer
specifier|private
specifier|final
name|IndexWriter
name|writer
decl_stmt|;
comment|// called only from assert
DECL|method|locked
specifier|private
name|boolean
name|locked
parameter_list|()
block|{
return|return
name|writer
operator|==
literal|null
operator|||
name|Thread
operator|.
name|holdsLock
argument_list|(
name|writer
argument_list|)
return|;
block|}
comment|/**    * Initialize the deleter: find all previous commits in    * the Directory, incref the files they reference, call    * the policy to let it delete commits.  This will remove    * any files not referenced by any of the commits.    * @throws IOException if there is a low-level IO error    */
DECL|method|IndexFileDeleter
specifier|public
name|IndexFileDeleter
parameter_list|(
name|String
index|[]
name|files
parameter_list|,
name|Directory
name|directoryOrig
parameter_list|,
name|Directory
name|directory
parameter_list|,
name|IndexDeletionPolicy
name|policy
parameter_list|,
name|SegmentInfos
name|segmentInfos
parameter_list|,
name|InfoStream
name|infoStream
parameter_list|,
name|IndexWriter
name|writer
parameter_list|,
name|boolean
name|initialIndexExists
parameter_list|,
name|boolean
name|isReaderInit
parameter_list|)
throws|throws
name|IOException
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoStream
operator|=
name|infoStream
expr_stmt|;
name|this
operator|.
name|writer
operator|=
name|writer
expr_stmt|;
specifier|final
name|String
name|currentSegmentsFile
init|=
name|segmentInfos
operator|.
name|getSegmentsFileName
argument_list|()
decl_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
literal|"init: current segments file is \""
operator|+
name|currentSegmentsFile
operator|+
literal|"\"; deletionPolicy="
operator|+
name|policy
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|policy
operator|=
name|policy
expr_stmt|;
name|this
operator|.
name|directoryOrig
operator|=
name|directoryOrig
expr_stmt|;
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
comment|// First pass: walk the files and initialize our ref
comment|// counts:
name|CommitPoint
name|currentCommitPoint
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|currentSegmentsFile
operator|!=
literal|null
condition|)
block|{
name|Matcher
name|m
init|=
name|IndexFileNames
operator|.
name|CODEC_FILE_PATTERN
operator|.
name|matcher
argument_list|(
literal|""
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|fileName
range|:
name|files
control|)
block|{
name|m
operator|.
name|reset
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fileName
operator|.
name|endsWith
argument_list|(
literal|"write.lock"
argument_list|)
operator|&&
operator|(
name|m
operator|.
name|matches
argument_list|()
operator|||
name|fileName
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|)
operator|||
name|fileName
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|PENDING_SEGMENTS
argument_list|)
operator|)
condition|)
block|{
comment|// Add this file to refCounts with initial count 0:
name|getRefCount
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileName
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|)
operator|&&
operator|!
name|fileName
operator|.
name|equals
argument_list|(
name|IndexFileNames
operator|.
name|OLD_SEGMENTS_GEN
argument_list|)
condition|)
block|{
comment|// This is a commit (segments or segments_N), and
comment|// it's valid (<= the max gen).  Load it, then
comment|// incref all files it refers to:
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
literal|"init: load commit \""
operator|+
name|fileName
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
name|SegmentInfos
name|sis
init|=
name|SegmentInfos
operator|.
name|readCommit
argument_list|(
name|directoryOrig
argument_list|,
name|fileName
argument_list|)
decl_stmt|;
specifier|final
name|CommitPoint
name|commitPoint
init|=
operator|new
name|CommitPoint
argument_list|(
name|commitsToDelete
argument_list|,
name|directoryOrig
argument_list|,
name|sis
argument_list|)
decl_stmt|;
if|if
condition|(
name|sis
operator|.
name|getGeneration
argument_list|()
operator|==
name|segmentInfos
operator|.
name|getGeneration
argument_list|()
condition|)
block|{
name|currentCommitPoint
operator|=
name|commitPoint
expr_stmt|;
block|}
name|commits
operator|.
name|add
argument_list|(
name|commitPoint
argument_list|)
expr_stmt|;
name|incRef
argument_list|(
name|sis
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastSegmentInfos
operator|==
literal|null
operator|||
name|sis
operator|.
name|getGeneration
argument_list|()
operator|>
name|lastSegmentInfos
operator|.
name|getGeneration
argument_list|()
condition|)
block|{
name|lastSegmentInfos
operator|=
name|sis
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|currentCommitPoint
operator|==
literal|null
operator|&&
name|currentSegmentsFile
operator|!=
literal|null
operator|&&
name|initialIndexExists
condition|)
block|{
comment|// We did not in fact see the segments_N file
comment|// corresponding to the segmentInfos that was passed
comment|// in.  Yet, it must exist, because our caller holds
comment|// the write lock.  This can happen when the directory
comment|// listing was stale (eg when index accessed via NFS
comment|// client with stale directory listing cache).  So we
comment|// try now to explicitly open this commit point:
name|SegmentInfos
name|sis
init|=
literal|null
decl_stmt|;
try|try
block|{
name|sis
operator|=
name|SegmentInfos
operator|.
name|readCommit
argument_list|(
name|directoryOrig
argument_list|,
name|currentSegmentsFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CorruptIndexException
argument_list|(
literal|"unable to read current segments_N file"
argument_list|,
name|currentSegmentsFile
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
literal|"forced open of current segments file "
operator|+
name|segmentInfos
operator|.
name|getSegmentsFileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|currentCommitPoint
operator|=
operator|new
name|CommitPoint
argument_list|(
name|commitsToDelete
argument_list|,
name|directoryOrig
argument_list|,
name|sis
argument_list|)
expr_stmt|;
name|commits
operator|.
name|add
argument_list|(
name|currentCommitPoint
argument_list|)
expr_stmt|;
name|incRef
argument_list|(
name|sis
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isReaderInit
condition|)
block|{
comment|// Incoming SegmentInfos may have NRT changes not yet visible in the latest commit, so we have to protect its files from deletion too:
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// We keep commits list in sorted order (oldest to newest):
name|CollectionUtil
operator|.
name|timSort
argument_list|(
name|commits
argument_list|)
expr_stmt|;
comment|// refCounts only includes "normal" filenames (does not include write.lock)
name|inflateGens
argument_list|(
name|segmentInfos
argument_list|,
name|refCounts
operator|.
name|keySet
argument_list|()
argument_list|,
name|infoStream
argument_list|)
expr_stmt|;
comment|// Now delete anything with ref count at 0.  These are
comment|// presumably abandoned files eg due to crash of
comment|// IndexWriter.
name|Set
argument_list|<
name|String
argument_list|>
name|toDelete
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RefCount
argument_list|>
name|entry
range|:
name|refCounts
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|RefCount
name|rc
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|String
name|fileName
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|rc
operator|.
name|count
condition|)
block|{
comment|// A segments_N file should never have ref count 0 on init:
if|if
condition|(
name|fileName
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"file \""
operator|+
name|fileName
operator|+
literal|"\" has refCount=0, which should never happen on init"
argument_list|)
throw|;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
literal|"init: removing unreferenced file \""
operator|+
name|fileName
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
name|toDelete
operator|.
name|add
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
name|deleteFiles
argument_list|(
name|toDelete
argument_list|)
expr_stmt|;
comment|// Finally, give policy a chance to remove things on
comment|// startup:
name|policy
operator|.
name|onInit
argument_list|(
name|commits
argument_list|)
expr_stmt|;
comment|// Always protect the incoming segmentInfos since
comment|// sometime it may not be the most recent commit
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentCommitPoint
operator|==
literal|null
condition|)
block|{
name|startingCommitDeleted
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|startingCommitDeleted
operator|=
name|currentCommitPoint
operator|.
name|isDeleted
argument_list|()
expr_stmt|;
block|}
name|deleteCommits
argument_list|()
expr_stmt|;
block|}
comment|/** Set all gens beyond what we currently see in the directory, to avoid double-write in cases where the previous IndexWriter did not    *  gracefully close/rollback (e.g. os/machine crashed or lost power). */
DECL|method|inflateGens
specifier|static
name|void
name|inflateGens
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|files
parameter_list|,
name|InfoStream
name|infoStream
parameter_list|)
block|{
name|long
name|maxSegmentGen
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
name|int
name|maxSegmentName
init|=
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
comment|// Confusingly, this is the union of liveDocs, field infos, doc values
comment|// (and maybe others, in the future) gens.  This is somewhat messy,
comment|// since it means DV updates will suddenly write to the next gen after
comment|// live docs' gen, for example, but we don't have the APIs to ask the
comment|// codec which file is which:
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|maxPerSegmentGen
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fileName
range|:
name|files
control|)
block|{
if|if
condition|(
name|fileName
operator|.
name|equals
argument_list|(
name|IndexFileNames
operator|.
name|OLD_SEGMENTS_GEN
argument_list|)
operator|||
name|fileName
operator|.
name|equals
argument_list|(
name|IndexWriter
operator|.
name|WRITE_LOCK_NAME
argument_list|)
condition|)
block|{
comment|// do nothing
block|}
elseif|else
if|if
condition|(
name|fileName
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|)
condition|)
block|{
try|try
block|{
name|maxSegmentGen
operator|=
name|Math
operator|.
name|max
argument_list|(
name|SegmentInfos
operator|.
name|generationFromSegmentsFileName
argument_list|(
name|fileName
argument_list|)
argument_list|,
name|maxSegmentGen
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|ignore
parameter_list|)
block|{
comment|// trash file: we have to handle this since we allow anything starting with 'segments' here
block|}
block|}
elseif|else
if|if
condition|(
name|fileName
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|PENDING_SEGMENTS
argument_list|)
condition|)
block|{
try|try
block|{
name|maxSegmentGen
operator|=
name|Math
operator|.
name|max
argument_list|(
name|SegmentInfos
operator|.
name|generationFromSegmentsFileName
argument_list|(
name|fileName
operator|.
name|substring
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|,
name|maxSegmentGen
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|ignore
parameter_list|)
block|{
comment|// trash file: we have to handle this since we allow anything starting with 'pending_segments' here
block|}
block|}
else|else
block|{
name|String
name|segmentName
init|=
name|IndexFileNames
operator|.
name|parseSegmentName
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
assert|assert
name|segmentName
operator|.
name|startsWith
argument_list|(
literal|"_"
argument_list|)
operator|:
literal|"wtf? file="
operator|+
name|fileName
assert|;
if|if
condition|(
name|fileName
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
operator|.
name|endsWith
argument_list|(
literal|".tmp"
argument_list|)
condition|)
block|{
comment|// A temp file: don't try to look at its gen
continue|continue;
block|}
name|maxSegmentName
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxSegmentName
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|segmentName
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
argument_list|)
expr_stmt|;
name|Long
name|curGen
init|=
name|maxPerSegmentGen
operator|.
name|get
argument_list|(
name|segmentName
argument_list|)
decl_stmt|;
if|if
condition|(
name|curGen
operator|==
literal|null
condition|)
block|{
name|curGen
operator|=
literal|0L
expr_stmt|;
block|}
try|try
block|{
name|curGen
operator|=
name|Math
operator|.
name|max
argument_list|(
name|curGen
argument_list|,
name|IndexFileNames
operator|.
name|parseGeneration
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|ignore
parameter_list|)
block|{
comment|// trash file: we have to handle this since codec regex is only so good
block|}
name|maxPerSegmentGen
operator|.
name|put
argument_list|(
name|segmentName
argument_list|,
name|curGen
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Generation is advanced before write:
name|infos
operator|.
name|setNextWriteGeneration
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|infos
operator|.
name|getGeneration
argument_list|()
argument_list|,
name|maxSegmentGen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|infos
operator|.
name|counter
operator|<
literal|1
operator|+
name|maxSegmentName
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
literal|"init: inflate infos.counter to "
operator|+
operator|(
literal|1
operator|+
name|maxSegmentName
operator|)
operator|+
literal|" vs current="
operator|+
name|infos
operator|.
name|counter
argument_list|)
expr_stmt|;
block|}
name|infos
operator|.
name|counter
operator|=
literal|1
operator|+
name|maxSegmentName
expr_stmt|;
block|}
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|infos
control|)
block|{
name|Long
name|gen
init|=
name|maxPerSegmentGen
operator|.
name|get
argument_list|(
name|info
operator|.
name|info
operator|.
name|name
argument_list|)
decl_stmt|;
assert|assert
name|gen
operator|!=
literal|null
assert|;
name|long
name|genLong
init|=
name|gen
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|getNextWriteDelGen
argument_list|()
operator|<
name|genLong
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
literal|"init: seg="
operator|+
name|info
operator|.
name|info
operator|.
name|name
operator|+
literal|" set nextWriteDelGen="
operator|+
operator|(
name|genLong
operator|+
literal|1
operator|)
operator|+
literal|" vs current="
operator|+
name|info
operator|.
name|getNextWriteDelGen
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|info
operator|.
name|setNextWriteDelGen
argument_list|(
name|genLong
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|getNextWriteFieldInfosGen
argument_list|()
operator|<
name|genLong
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
literal|"init: seg="
operator|+
name|info
operator|.
name|info
operator|.
name|name
operator|+
literal|" set nextWriteFieldInfosGen="
operator|+
operator|(
name|genLong
operator|+
literal|1
operator|)
operator|+
literal|" vs current="
operator|+
name|info
operator|.
name|getNextWriteFieldInfosGen
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|info
operator|.
name|setNextWriteFieldInfosGen
argument_list|(
name|genLong
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|getNextWriteDocValuesGen
argument_list|()
operator|<
name|genLong
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
literal|"init: seg="
operator|+
name|info
operator|.
name|info
operator|.
name|name
operator|+
literal|" set nextWriteDocValuesGen="
operator|+
operator|(
name|genLong
operator|+
literal|1
operator|)
operator|+
literal|" vs current="
operator|+
name|info
operator|.
name|getNextWriteDocValuesGen
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|info
operator|.
name|setNextWriteDocValuesGen
argument_list|(
name|genLong
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|ensureOpen
name|void
name|ensureOpen
parameter_list|()
throws|throws
name|AlreadyClosedException
block|{
name|writer
operator|.
name|ensureOpen
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// since we allow 'closing' state, we must still check this, we could be closing because we hit e.g. OOM
if|if
condition|(
name|writer
operator|.
name|tragedy
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|AlreadyClosedException
argument_list|(
literal|"refusing to delete any files: this IndexWriter hit an unrecoverable exception"
argument_list|,
name|writer
operator|.
name|tragedy
argument_list|)
throw|;
block|}
block|}
comment|// for testing
DECL|method|isClosed
name|boolean
name|isClosed
parameter_list|()
block|{
try|try
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|AlreadyClosedException
name|ace
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
DECL|method|getLastSegmentInfos
specifier|public
name|SegmentInfos
name|getLastSegmentInfos
parameter_list|()
block|{
return|return
name|lastSegmentInfos
return|;
block|}
comment|/**    * Remove the CommitPoints in the commitsToDelete List by    * DecRef'ing all files from each SegmentInfos.    */
DECL|method|deleteCommits
specifier|private
name|void
name|deleteCommits
parameter_list|()
block|{
name|int
name|size
init|=
name|commitsToDelete
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
comment|// First decref all files that had been referred to by
comment|// the now-deleted commits:
name|Throwable
name|firstThrowable
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|CommitPoint
name|commit
init|=
name|commitsToDelete
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
literal|"deleteCommits: now decRef commit \""
operator|+
name|commit
operator|.
name|getSegmentsFileName
argument_list|()
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|decRef
argument_list|(
name|commit
operator|.
name|files
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|firstThrowable
operator|==
literal|null
condition|)
block|{
name|firstThrowable
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
name|commitsToDelete
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// NOTE: does nothing if firstThrowable is null
name|IOUtils
operator|.
name|reThrowUnchecked
argument_list|(
name|firstThrowable
argument_list|)
expr_stmt|;
comment|// Now compact commits to remove deleted ones (preserving the sort):
name|size
operator|=
name|commits
operator|.
name|size
argument_list|()
expr_stmt|;
name|int
name|readFrom
init|=
literal|0
decl_stmt|;
name|int
name|writeTo
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|readFrom
operator|<
name|size
condition|)
block|{
name|CommitPoint
name|commit
init|=
name|commits
operator|.
name|get
argument_list|(
name|readFrom
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|commit
operator|.
name|deleted
condition|)
block|{
if|if
condition|(
name|writeTo
operator|!=
name|readFrom
condition|)
block|{
name|commits
operator|.
name|set
argument_list|(
name|writeTo
argument_list|,
name|commits
operator|.
name|get
argument_list|(
name|readFrom
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|writeTo
operator|++
expr_stmt|;
block|}
name|readFrom
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|size
operator|>
name|writeTo
condition|)
block|{
name|commits
operator|.
name|remove
argument_list|(
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|size
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Writer calls this when it has hit an error and had to    * roll back, to tell us that there may now be    * unreferenced files in the filesystem.  So we re-list    * the filesystem and delete such files.  If segmentName    * is non-null, we will only delete files corresponding to    * that segment.    */
DECL|method|refresh
name|void
name|refresh
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
name|Set
argument_list|<
name|String
argument_list|>
name|toDelete
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|String
index|[]
name|files
init|=
name|directory
operator|.
name|listAll
argument_list|()
decl_stmt|;
name|Matcher
name|m
init|=
name|IndexFileNames
operator|.
name|CODEC_FILE_PATTERN
operator|.
name|matcher
argument_list|(
literal|""
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|files
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|fileName
init|=
name|files
index|[
name|i
index|]
decl_stmt|;
name|m
operator|.
name|reset
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fileName
operator|.
name|endsWith
argument_list|(
literal|"write.lock"
argument_list|)
operator|&&
operator|!
name|refCounts
operator|.
name|containsKey
argument_list|(
name|fileName
argument_list|)
operator|&&
operator|(
name|m
operator|.
name|matches
argument_list|()
operator|||
name|fileName
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|)
comment|// we only try to clear out pending_segments_N during rollback(), because we don't ref-count it
comment|// TODO: this is sneaky, should we do this, or change TestIWExceptions? rollback closes anyway, and
comment|// any leftover file will be deleted/retried on next IW bootup anyway...
operator|||
name|fileName
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|PENDING_SEGMENTS
argument_list|)
operator|)
condition|)
block|{
comment|// Unreferenced file, so remove it
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
literal|"refresh: removing newly created unreferenced file \""
operator|+
name|fileName
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
name|toDelete
operator|.
name|add
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
name|deleteFiles
argument_list|(
name|toDelete
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|// DecRef old files from the last checkpoint, if any:
assert|assert
name|locked
argument_list|()
assert|;
if|if
condition|(
operator|!
name|lastFiles
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|decRef
argument_list|(
name|lastFiles
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lastFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Revisits the {@link IndexDeletionPolicy} by calling its    * {@link IndexDeletionPolicy#onCommit(List)} again with the known commits.    * This is useful in cases where a deletion policy which holds onto index    * commits is used. The application may know that some commits are not held by    * the deletion policy anymore and call    * {@link IndexWriter#deleteUnusedFiles()}, which will attempt to delete the    * unused commits again.    */
DECL|method|revisitPolicy
name|void
name|revisitPolicy
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
literal|"now revisitPolicy"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commits
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|policy
operator|.
name|onCommit
argument_list|(
name|commits
argument_list|)
expr_stmt|;
name|deleteCommits
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * For definition of "check point" see IndexWriter comments:    * "Clarification: Check Points (and commits)".    *    * Writer calls this when it has made a "consistent    * change" to the index, meaning new files are written to    * the index and the in-memory SegmentInfos have been    * modified to point to those files.    *    * This may or may not be a commit (segments_N may or may    * not have been written).    *    * We simply incref the files referenced by the new    * SegmentInfos and decref the files we had previously    * seen (if any).    *    * If this is a commit, we also call the policy to give it    * a chance to remove other commits.  If any commits are    * removed, we decref their files as well.    */
DECL|method|checkpoint
specifier|public
name|void
name|checkpoint
parameter_list|(
name|SegmentInfos
name|segmentInfos
parameter_list|,
name|boolean
name|isCommit
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
assert|assert
name|Thread
operator|.
name|holdsLock
argument_list|(
name|writer
argument_list|)
assert|;
name|long
name|t0
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
name|t0
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
literal|"now checkpoint \""
operator|+
name|writer
operator|.
name|segString
argument_list|(
name|writer
operator|.
name|toLiveInfos
argument_list|(
name|segmentInfos
argument_list|)
argument_list|)
operator|+
literal|"\" ["
operator|+
name|segmentInfos
operator|.
name|size
argument_list|()
operator|+
literal|" segments "
operator|+
literal|"; isCommit = "
operator|+
name|isCommit
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
comment|// Incref the files:
name|incRef
argument_list|(
name|segmentInfos
argument_list|,
name|isCommit
argument_list|)
expr_stmt|;
if|if
condition|(
name|isCommit
condition|)
block|{
comment|// Append to our commits list:
name|commits
operator|.
name|add
argument_list|(
operator|new
name|CommitPoint
argument_list|(
name|commitsToDelete
argument_list|,
name|directoryOrig
argument_list|,
name|segmentInfos
argument_list|)
argument_list|)
expr_stmt|;
comment|// Tell policy so it can remove commits:
name|policy
operator|.
name|onCommit
argument_list|(
name|commits
argument_list|)
expr_stmt|;
comment|// Decref files for commits that were deleted by the policy:
name|deleteCommits
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// DecRef old files from the last checkpoint, if any:
try|try
block|{
name|decRef
argument_list|(
name|lastFiles
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lastFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// Save files so we can decr on next checkpoint/commit:
name|lastFiles
operator|.
name|addAll
argument_list|(
name|segmentInfos
operator|.
name|files
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
name|long
name|t1
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
operator|(
operator|(
name|t1
operator|-
name|t0
operator|)
operator|/
literal|1000000
operator|)
operator|+
literal|" msec to checkpoint"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|incRef
name|void
name|incRef
parameter_list|(
name|SegmentInfos
name|segmentInfos
parameter_list|,
name|boolean
name|isCommit
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
comment|// If this is a commit point, also incRef the
comment|// segments_N file:
for|for
control|(
specifier|final
name|String
name|fileName
range|:
name|segmentInfos
operator|.
name|files
argument_list|(
name|isCommit
argument_list|)
control|)
block|{
name|incRef
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|incRef
name|void
name|incRef
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
block|{
assert|assert
name|locked
argument_list|()
assert|;
for|for
control|(
specifier|final
name|String
name|file
range|:
name|files
control|)
block|{
name|incRef
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|incRef
name|void
name|incRef
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
assert|assert
name|locked
argument_list|()
assert|;
name|RefCount
name|rc
init|=
name|getRefCount
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
if|if
condition|(
name|VERBOSE_REF_COUNTS
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
literal|"  IncRef \""
operator|+
name|fileName
operator|+
literal|"\": pre-incr count is "
operator|+
name|rc
operator|.
name|count
argument_list|)
expr_stmt|;
block|}
block|}
name|rc
operator|.
name|IncRef
argument_list|()
expr_stmt|;
block|}
comment|/** Decrefs all provided files, even on exception; throws first exception hit, if any. */
DECL|method|decRef
name|void
name|decRef
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
name|Set
argument_list|<
name|String
argument_list|>
name|toDelete
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Throwable
name|firstThrowable
init|=
literal|null
decl_stmt|;
for|for
control|(
specifier|final
name|String
name|file
range|:
name|files
control|)
block|{
try|try
block|{
if|if
condition|(
name|decRef
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|toDelete
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|firstThrowable
operator|==
literal|null
condition|)
block|{
comment|// Save first exception and throw it in the end, but be sure to finish decRef all files
name|firstThrowable
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
try|try
block|{
name|deleteFiles
argument_list|(
name|toDelete
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|firstThrowable
operator|==
literal|null
condition|)
block|{
comment|// Save first exception and throw it in the end, but be sure to finish decRef all files
name|firstThrowable
operator|=
name|t
expr_stmt|;
block|}
block|}
comment|// NOTE: does nothing if firstThrowable is null
name|IOUtils
operator|.
name|reThrow
argument_list|(
name|firstThrowable
argument_list|)
expr_stmt|;
block|}
comment|/** Decrefs all provided files, ignoring any exceptions hit; call this if    *  you are already handling an exception. */
DECL|method|decRefWhileHandlingException
name|void
name|decRefWhileHandlingException
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
block|{
assert|assert
name|locked
argument_list|()
assert|;
name|Set
argument_list|<
name|String
argument_list|>
name|toDelete
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|String
name|file
range|:
name|files
control|)
block|{
try|try
block|{
if|if
condition|(
name|decRef
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|toDelete
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{       }
block|}
try|try
block|{
name|deleteFiles
argument_list|(
name|toDelete
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{     }
block|}
comment|/** Returns true if the file should now be deleted. */
DECL|method|decRef
specifier|private
name|boolean
name|decRef
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
assert|assert
name|locked
argument_list|()
assert|;
name|RefCount
name|rc
init|=
name|getRefCount
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
if|if
condition|(
name|VERBOSE_REF_COUNTS
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
literal|"  DecRef \""
operator|+
name|fileName
operator|+
literal|"\": pre-decr count is "
operator|+
name|rc
operator|.
name|count
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rc
operator|.
name|DecRef
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// This file is no longer referenced by any past
comment|// commit points nor by the in-memory SegmentInfos:
name|refCounts
operator|.
name|remove
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|method|decRef
name|void
name|decRef
parameter_list|(
name|SegmentInfos
name|segmentInfos
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
name|decRef
argument_list|(
name|segmentInfos
operator|.
name|files
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|exists
specifier|public
name|boolean
name|exists
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
assert|assert
name|locked
argument_list|()
assert|;
if|if
condition|(
operator|!
name|refCounts
operator|.
name|containsKey
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|getRefCount
argument_list|(
name|fileName
argument_list|)
operator|.
name|count
operator|>
literal|0
return|;
block|}
block|}
DECL|method|getRefCount
specifier|private
name|RefCount
name|getRefCount
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
assert|assert
name|locked
argument_list|()
assert|;
name|RefCount
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|refCounts
operator|.
name|containsKey
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
name|rc
operator|=
operator|new
name|RefCount
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|refCounts
operator|.
name|put
argument_list|(
name|fileName
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|refCounts
operator|.
name|get
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
comment|/** Deletes the specified files, but only if they are new    *  (have not yet been incref'd). */
DECL|method|deleteNewFiles
name|void
name|deleteNewFiles
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
name|Set
argument_list|<
name|String
argument_list|>
name|toDelete
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|String
name|fileName
range|:
name|files
control|)
block|{
comment|// NOTE: it's very unusual yet possible for the
comment|// refCount to be present and 0: it can happen if you
comment|// open IW on a crashed index, and it removes a bunch
comment|// of unref'd files, and then you add new docs / do
comment|// merging, and it reuses that segment name.
comment|// TestCrash.testCrashAfterReopen can hit this:
if|if
condition|(
operator|!
name|refCounts
operator|.
name|containsKey
argument_list|(
name|fileName
argument_list|)
operator|||
name|refCounts
operator|.
name|get
argument_list|(
name|fileName
argument_list|)
operator|.
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
literal|"will delete new file \""
operator|+
name|fileName
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
name|toDelete
operator|.
name|add
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
name|deleteFiles
argument_list|(
name|toDelete
argument_list|)
expr_stmt|;
block|}
DECL|method|deleteFiles
specifier|private
name|void
name|deleteFiles
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locked
argument_list|()
assert|;
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IFD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IFD"
argument_list|,
literal|"delete \""
operator|+
name|names
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
try|try
block|{
name|directory
operator|.
name|deleteFile
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchFileException
decl||
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!
if|if
condition|(
name|Constants
operator|.
name|WINDOWS
condition|)
block|{
comment|// TODO: can we remove this OS-specific hacky logic?  If windows deleteFile is buggy, we should instead contain this workaround in
comment|// a WindowsFSDirectory ...
comment|// LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing "pending delete" state, and falsely
comment|// return NSFE/FNFE
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Tracks the reference count for a single index file:    */
DECL|class|RefCount
specifier|final
specifier|private
specifier|static
class|class
name|RefCount
block|{
comment|// fileName used only for better assert error messages
DECL|field|fileName
specifier|final
name|String
name|fileName
decl_stmt|;
DECL|field|initDone
name|boolean
name|initDone
decl_stmt|;
DECL|method|RefCount
name|RefCount
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
name|this
operator|.
name|fileName
operator|=
name|fileName
expr_stmt|;
block|}
DECL|field|count
name|int
name|count
decl_stmt|;
DECL|method|IncRef
specifier|public
name|int
name|IncRef
parameter_list|()
block|{
if|if
condition|(
operator|!
name|initDone
condition|)
block|{
name|initDone
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|count
operator|>
literal|0
operator|:
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": RefCount is 0 pre-increment for file \""
operator|+
name|fileName
operator|+
literal|"\""
assert|;
block|}
return|return
operator|++
name|count
return|;
block|}
DECL|method|DecRef
specifier|public
name|int
name|DecRef
parameter_list|()
block|{
assert|assert
name|count
operator|>
literal|0
operator|:
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": RefCount is 0 pre-decrement for file \""
operator|+
name|fileName
operator|+
literal|"\""
assert|;
return|return
operator|--
name|count
return|;
block|}
block|}
comment|/**    * Holds details for each commit point.  This class is    * also passed to the deletion policy.  Note: this class    * has a natural ordering that is inconsistent with    * equals.    */
DECL|class|CommitPoint
specifier|final
specifier|private
specifier|static
class|class
name|CommitPoint
extends|extends
name|IndexCommit
block|{
DECL|field|files
name|Collection
argument_list|<
name|String
argument_list|>
name|files
decl_stmt|;
DECL|field|segmentsFileName
name|String
name|segmentsFileName
decl_stmt|;
DECL|field|deleted
name|boolean
name|deleted
decl_stmt|;
DECL|field|directoryOrig
name|Directory
name|directoryOrig
decl_stmt|;
DECL|field|commitsToDelete
name|Collection
argument_list|<
name|CommitPoint
argument_list|>
name|commitsToDelete
decl_stmt|;
DECL|field|generation
name|long
name|generation
decl_stmt|;
DECL|field|userData
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|userData
decl_stmt|;
DECL|field|segmentCount
specifier|private
specifier|final
name|int
name|segmentCount
decl_stmt|;
DECL|method|CommitPoint
specifier|public
name|CommitPoint
parameter_list|(
name|Collection
argument_list|<
name|CommitPoint
argument_list|>
name|commitsToDelete
parameter_list|,
name|Directory
name|directoryOrig
parameter_list|,
name|SegmentInfos
name|segmentInfos
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|directoryOrig
operator|=
name|directoryOrig
expr_stmt|;
name|this
operator|.
name|commitsToDelete
operator|=
name|commitsToDelete
expr_stmt|;
name|userData
operator|=
name|segmentInfos
operator|.
name|getUserData
argument_list|()
expr_stmt|;
name|segmentsFileName
operator|=
name|segmentInfos
operator|.
name|getSegmentsFileName
argument_list|()
expr_stmt|;
name|generation
operator|=
name|segmentInfos
operator|.
name|getGeneration
argument_list|()
expr_stmt|;
name|files
operator|=
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|segmentInfos
operator|.
name|files
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|segmentCount
operator|=
name|segmentInfos
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"IndexFileDeleter.CommitPoint("
operator|+
name|segmentsFileName
operator|+
literal|")"
return|;
block|}
annotation|@
name|Override
DECL|method|getSegmentCount
specifier|public
name|int
name|getSegmentCount
parameter_list|()
block|{
return|return
name|segmentCount
return|;
block|}
annotation|@
name|Override
DECL|method|getSegmentsFileName
specifier|public
name|String
name|getSegmentsFileName
parameter_list|()
block|{
return|return
name|segmentsFileName
return|;
block|}
annotation|@
name|Override
DECL|method|getFileNames
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getFileNames
parameter_list|()
block|{
return|return
name|files
return|;
block|}
annotation|@
name|Override
DECL|method|getDirectory
specifier|public
name|Directory
name|getDirectory
parameter_list|()
block|{
return|return
name|directoryOrig
return|;
block|}
annotation|@
name|Override
DECL|method|getGeneration
specifier|public
name|long
name|getGeneration
parameter_list|()
block|{
return|return
name|generation
return|;
block|}
annotation|@
name|Override
DECL|method|getUserData
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getUserData
parameter_list|()
block|{
return|return
name|userData
return|;
block|}
comment|/**      * Called only be the deletion policy, to remove this      * commit point from the index.      */
annotation|@
name|Override
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|()
block|{
if|if
condition|(
operator|!
name|deleted
condition|)
block|{
name|deleted
operator|=
literal|true
expr_stmt|;
name|commitsToDelete
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|isDeleted
specifier|public
name|boolean
name|isDeleted
parameter_list|()
block|{
return|return
name|deleted
return|;
block|}
block|}
block|}
end_class
end_unit
