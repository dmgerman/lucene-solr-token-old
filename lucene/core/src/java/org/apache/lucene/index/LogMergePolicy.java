begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MergePolicy
operator|.
name|MergeTrigger
import|;
end_import
begin_comment
comment|/**  *<p>This class implements a {@link MergePolicy} that tries  * to merge segments into levels of exponentially  * increasing size, where each level has fewer segments than  * the value of the merge factor. Whenever extra segments  * (beyond the merge factor upper bound) are encountered,  * all segments within the level are merged. You can get or  * set the merge factor using {@link #getMergeFactor()} and  * {@link #setMergeFactor(int)} respectively.</p>  *  *<p>This class is abstract and requires a subclass to  * define the {@link #size} method which specifies how a  * segment's size is determined.  {@link LogDocMergePolicy}  * is one subclass that measures size by document count in  * the segment.  {@link LogByteSizeMergePolicy} is another  * subclass that measures size as the total byte size of the  * file(s) for the segment.</p>  */
end_comment
begin_class
DECL|class|LogMergePolicy
specifier|public
specifier|abstract
class|class
name|LogMergePolicy
extends|extends
name|MergePolicy
block|{
comment|/** Defines the allowed range of log(size) for each    *  level.  A level is computed by taking the max segment    *  log size, minus LEVEL_LOG_SPAN, and finding all    *  segments falling within that range. */
DECL|field|LEVEL_LOG_SPAN
specifier|public
specifier|static
specifier|final
name|double
name|LEVEL_LOG_SPAN
init|=
literal|0.75
decl_stmt|;
comment|/** Default merge factor, which is how many segments are    *  merged at a time */
DECL|field|DEFAULT_MERGE_FACTOR
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MERGE_FACTOR
init|=
literal|10
decl_stmt|;
comment|/** Default maximum segment size.  A segment of this size    *  or larger will never be merged.  @see setMaxMergeDocs */
DECL|field|DEFAULT_MAX_MERGE_DOCS
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_MERGE_DOCS
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
comment|/** Default noCFSRatio.  If a merge's size is>= 10% of    *  the index, then we disable compound file for it.    *  @see #setNoCFSRatio */
DECL|field|DEFAULT_NO_CFS_RATIO
specifier|public
specifier|static
specifier|final
name|double
name|DEFAULT_NO_CFS_RATIO
init|=
literal|0.1
decl_stmt|;
comment|/** Default maxCFSSegmentSize value allows compound file    * for a segment of any size. The actual file format is    * still subject to noCFSRatio.    * @see #setMaxCFSSegmentSizeMB(double)    */
DECL|field|DEFAULT_MAX_CFS_SEGMENT_SIZE
specifier|public
specifier|static
specifier|final
name|long
name|DEFAULT_MAX_CFS_SEGMENT_SIZE
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
comment|/** How many segments to merge at a time. */
DECL|field|mergeFactor
specifier|protected
name|int
name|mergeFactor
init|=
name|DEFAULT_MERGE_FACTOR
decl_stmt|;
comment|/** Any segments whose size is smaller than this value    *  will be rounded up to this value.  This ensures that    *  tiny segments are aggressively merged. */
DECL|field|minMergeSize
specifier|protected
name|long
name|minMergeSize
decl_stmt|;
comment|/** If the size of a segment exceeds this value then it    *  will never be merged. */
DECL|field|maxMergeSize
specifier|protected
name|long
name|maxMergeSize
decl_stmt|;
comment|// Although the core MPs set it explicitly, we must default in case someone
comment|// out there wrote his own LMP ...
comment|/** If the size of a segment exceeds this value then it    * will never be merged during {@link IndexWriter#forceMerge}. */
DECL|field|maxMergeSizeForForcedMerge
specifier|protected
name|long
name|maxMergeSizeForForcedMerge
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
comment|/** If a segment has more than this many documents then it    *  will never be merged. */
DECL|field|maxMergeDocs
specifier|protected
name|int
name|maxMergeDocs
init|=
name|DEFAULT_MAX_MERGE_DOCS
decl_stmt|;
comment|/** If the size of the merge segment exceeds this ratio of    *  the total index size then it will remain in    *  non-compound format even if {@link    *  #setUseCompoundFile} is {@code true}. */
DECL|field|noCFSRatio
specifier|protected
name|double
name|noCFSRatio
init|=
name|DEFAULT_NO_CFS_RATIO
decl_stmt|;
comment|/** If the size of the merged segment exceeds    *  this value then it will not use compound file format. */
DECL|field|maxCFSSegmentSize
specifier|protected
name|long
name|maxCFSSegmentSize
init|=
name|DEFAULT_MAX_CFS_SEGMENT_SIZE
decl_stmt|;
comment|/** If true, we pro-rate a segment's size by the    *  percentage of non-deleted documents. */
DECL|field|calibrateSizeByDeletes
specifier|protected
name|boolean
name|calibrateSizeByDeletes
init|=
literal|true
decl_stmt|;
comment|/** True if new segments (flushed or merged) should use    *  the compound file format.  Note that large segments    *  may sometimes still use non-compound format (see    *  {@link #setNoCFSRatio}. */
DECL|field|useCompoundFile
specifier|protected
name|boolean
name|useCompoundFile
init|=
literal|true
decl_stmt|;
comment|/** Sole constructor. (For invocation by subclass     *  constructors, typically implicit.) */
DECL|method|LogMergePolicy
specifier|public
name|LogMergePolicy
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/** Returns true if {@code LMP} is enabled in {@link    *  IndexWriter}'s {@code infoStream}. */
DECL|method|verbose
specifier|protected
name|boolean
name|verbose
parameter_list|()
block|{
specifier|final
name|IndexWriter
name|w
init|=
name|writer
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|w
operator|!=
literal|null
operator|&&
name|w
operator|.
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"LMP"
argument_list|)
return|;
block|}
comment|/** Returns current {@code noCFSRatio}.    *    *  @see #setNoCFSRatio */
DECL|method|getNoCFSRatio
specifier|public
name|double
name|getNoCFSRatio
parameter_list|()
block|{
return|return
name|noCFSRatio
return|;
block|}
comment|/** If a merged segment will be more than this percentage    *  of the total size of the index, leave the segment as    *  non-compound file even if compound file is enabled.    *  Set to 1.0 to always use CFS regardless of merge    *  size. */
DECL|method|setNoCFSRatio
specifier|public
name|void
name|setNoCFSRatio
parameter_list|(
name|double
name|noCFSRatio
parameter_list|)
block|{
if|if
condition|(
name|noCFSRatio
argument_list|<
literal|0.0
operator|||
name|noCFSRatio
argument_list|>
literal|1.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"noCFSRatio must be 0.0 to 1.0 inclusive; got "
operator|+
name|noCFSRatio
argument_list|)
throw|;
block|}
name|this
operator|.
name|noCFSRatio
operator|=
name|noCFSRatio
expr_stmt|;
block|}
comment|/** Print a debug message to {@link IndexWriter}'s {@code    *  infoStream}. */
DECL|method|message
specifier|protected
name|void
name|message
parameter_list|(
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|writer
operator|.
name|get
argument_list|()
operator|.
name|infoStream
operator|.
name|message
argument_list|(
literal|"LMP"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**<p>Returns the number of segments that are merged at    * once and also controls the total number of segments    * allowed to accumulate in the index.</p> */
DECL|method|getMergeFactor
specifier|public
name|int
name|getMergeFactor
parameter_list|()
block|{
return|return
name|mergeFactor
return|;
block|}
comment|/** Determines how often segment indices are merged by    * addDocument().  With smaller values, less RAM is used    * while indexing, and searches are    * faster, but indexing speed is slower.  With larger    * values, more RAM is used during indexing, and while    * searches is slower, indexing is    * faster.  Thus larger values (> 10) are best for batch    * index creation, and smaller values (< 10) for indices    * that are interactively maintained. */
DECL|method|setMergeFactor
specifier|public
name|void
name|setMergeFactor
parameter_list|(
name|int
name|mergeFactor
parameter_list|)
block|{
if|if
condition|(
name|mergeFactor
operator|<
literal|2
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"mergeFactor cannot be less than 2"
argument_list|)
throw|;
name|this
operator|.
name|mergeFactor
operator|=
name|mergeFactor
expr_stmt|;
block|}
comment|// Javadoc inherited
annotation|@
name|Override
DECL|method|useCompoundFile
specifier|public
name|boolean
name|useCompoundFile
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|SegmentInfoPerCommit
name|mergedInfo
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|getUseCompoundFile
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|long
name|mergedInfoSize
init|=
name|size
argument_list|(
name|mergedInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergedInfoSize
operator|>
name|maxCFSSegmentSize
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|getNoCFSRatio
argument_list|()
operator|>=
literal|1.0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SegmentInfoPerCommit
name|info
range|:
name|infos
control|)
block|{
name|totalSize
operator|+=
name|size
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
return|return
name|mergedInfoSize
operator|<=
name|getNoCFSRatio
argument_list|()
operator|*
name|totalSize
return|;
block|}
comment|/** Sets whether compound file format should be used for    *  newly flushed and newly merged segments. */
DECL|method|setUseCompoundFile
specifier|public
name|void
name|setUseCompoundFile
parameter_list|(
name|boolean
name|useCompoundFile
parameter_list|)
block|{
name|this
operator|.
name|useCompoundFile
operator|=
name|useCompoundFile
expr_stmt|;
block|}
comment|/** Returns true if newly flushed and newly merge segments    *  are written in compound file format. @see    *  #setUseCompoundFile */
DECL|method|getUseCompoundFile
specifier|public
name|boolean
name|getUseCompoundFile
parameter_list|()
block|{
return|return
name|useCompoundFile
return|;
block|}
comment|/** Sets whether the segment size should be calibrated by    *  the number of deletes when choosing segments for merge. */
DECL|method|setCalibrateSizeByDeletes
specifier|public
name|void
name|setCalibrateSizeByDeletes
parameter_list|(
name|boolean
name|calibrateSizeByDeletes
parameter_list|)
block|{
name|this
operator|.
name|calibrateSizeByDeletes
operator|=
name|calibrateSizeByDeletes
expr_stmt|;
block|}
comment|/** Returns true if the segment size should be calibrated     *  by the number of deletes when choosing segments for merge. */
DECL|method|getCalibrateSizeByDeletes
specifier|public
name|boolean
name|getCalibrateSizeByDeletes
parameter_list|()
block|{
return|return
name|calibrateSizeByDeletes
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{}
comment|/** Return the size of the provided {@link    *  SegmentInfoPerCommit}. */
DECL|method|size
specifier|abstract
specifier|protected
name|long
name|size
parameter_list|(
name|SegmentInfoPerCommit
name|info
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Return the number of documents in the provided {@link    *  SegmentInfoPerCommit}, pro-rated by percentage of    *  non-deleted documents if {@link    *  #setCalibrateSizeByDeletes} is set. */
DECL|method|sizeDocs
specifier|protected
name|long
name|sizeDocs
parameter_list|(
name|SegmentInfoPerCommit
name|info
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|calibrateSizeByDeletes
condition|)
block|{
name|int
name|delCount
init|=
name|writer
operator|.
name|get
argument_list|()
operator|.
name|numDeletedDocs
argument_list|(
name|info
argument_list|)
decl_stmt|;
assert|assert
name|delCount
operator|<=
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
assert|;
return|return
operator|(
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|-
operator|(
name|long
operator|)
name|delCount
operator|)
return|;
block|}
else|else
block|{
return|return
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
return|;
block|}
block|}
comment|/** Return the byte size of the provided {@link    *  SegmentInfoPerCommit}, pro-rated by percentage of    *  non-deleted documents if {@link    *  #setCalibrateSizeByDeletes} is set. */
DECL|method|sizeBytes
specifier|protected
name|long
name|sizeBytes
parameter_list|(
name|SegmentInfoPerCommit
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|byteSize
init|=
name|info
operator|.
name|sizeInBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|calibrateSizeByDeletes
condition|)
block|{
name|int
name|delCount
init|=
name|writer
operator|.
name|get
argument_list|()
operator|.
name|numDeletedDocs
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|double
name|delRatio
init|=
operator|(
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|<=
literal|0
condition|?
literal|0.0f
else|:
operator|(
operator|(
name|float
operator|)
name|delCount
operator|/
operator|(
name|float
operator|)
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|)
operator|)
decl_stmt|;
assert|assert
name|delRatio
operator|<=
literal|1.0
assert|;
return|return
operator|(
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|<=
literal|0
condition|?
name|byteSize
else|:
call|(
name|long
call|)
argument_list|(
name|byteSize
operator|*
operator|(
literal|1.0
operator|-
name|delRatio
operator|)
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
name|byteSize
return|;
block|}
block|}
comment|/** Returns true if the number of segments eligible for    *  merging is less than or equal to the specified {@code    *  maxNumSegments}. */
DECL|method|isMerged
specifier|protected
name|boolean
name|isMerged
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|int
name|maxNumSegments
parameter_list|,
name|Map
argument_list|<
name|SegmentInfoPerCommit
argument_list|,
name|Boolean
argument_list|>
name|segmentsToMerge
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|numSegments
init|=
name|infos
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|numToMerge
init|=
literal|0
decl_stmt|;
name|SegmentInfoPerCommit
name|mergeInfo
init|=
literal|null
decl_stmt|;
name|boolean
name|segmentIsOriginal
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
operator|&&
name|numToMerge
operator|<=
name|maxNumSegments
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentInfoPerCommit
name|info
init|=
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|Boolean
name|isOriginal
init|=
name|segmentsToMerge
operator|.
name|get
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|isOriginal
operator|!=
literal|null
condition|)
block|{
name|segmentIsOriginal
operator|=
name|isOriginal
expr_stmt|;
name|numToMerge
operator|++
expr_stmt|;
name|mergeInfo
operator|=
name|info
expr_stmt|;
block|}
block|}
return|return
name|numToMerge
operator|<=
name|maxNumSegments
operator|&&
operator|(
name|numToMerge
operator|!=
literal|1
operator|||
operator|!
name|segmentIsOriginal
operator|||
name|isMerged
argument_list|(
name|mergeInfo
argument_list|)
operator|)
return|;
block|}
comment|/** Returns true if this single info is already fully merged (has no    *  pending norms or deletes, is in the same dir as the    *  writer, and matches the current compound file setting */
DECL|method|isMerged
specifier|protected
name|boolean
name|isMerged
parameter_list|(
name|SegmentInfoPerCommit
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|IndexWriter
name|w
init|=
name|writer
operator|.
name|get
argument_list|()
decl_stmt|;
assert|assert
name|w
operator|!=
literal|null
assert|;
name|boolean
name|hasDeletions
init|=
name|w
operator|.
name|numDeletedDocs
argument_list|(
name|info
argument_list|)
operator|>
literal|0
decl_stmt|;
return|return
operator|!
name|hasDeletions
operator|&&
name|info
operator|.
name|info
operator|.
name|dir
operator|==
name|w
operator|.
name|getDirectory
argument_list|()
operator|&&
operator|(
name|info
operator|.
name|info
operator|.
name|getUseCompoundFile
argument_list|()
operator|==
name|useCompoundFile
operator|||
name|noCFSRatio
operator|<
literal|1.0
operator|)
return|;
block|}
comment|/**    * Returns the merges necessary to merge the index, taking the max merge    * size or max merge docs into consideration. This method attempts to respect    * the {@code maxNumSegments} parameter, however it might be, due to size    * constraints, that more than that number of segments will remain in the    * index. Also, this method does not guarantee that exactly {@code    * maxNumSegments} will remain, but&lt;= that number.    */
DECL|method|findForcedMergesSizeLimit
specifier|private
name|MergeSpecification
name|findForcedMergesSizeLimit
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|int
name|maxNumSegments
parameter_list|,
name|int
name|last
parameter_list|)
throws|throws
name|IOException
block|{
name|MergeSpecification
name|spec
init|=
operator|new
name|MergeSpecification
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SegmentInfoPerCommit
argument_list|>
name|segments
init|=
name|infos
operator|.
name|asList
argument_list|()
decl_stmt|;
name|int
name|start
init|=
name|last
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|start
operator|>=
literal|0
condition|)
block|{
name|SegmentInfoPerCommit
name|info
init|=
name|infos
operator|.
name|info
argument_list|(
name|start
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
argument_list|(
name|info
argument_list|)
operator|>
name|maxMergeSizeForForcedMerge
operator|||
name|sizeDocs
argument_list|(
name|info
argument_list|)
operator|>
name|maxMergeDocs
condition|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"findForcedMergesSizeLimit: skip segment="
operator|+
name|info
operator|+
literal|": size is> maxMergeSize ("
operator|+
name|maxMergeSizeForForcedMerge
operator|+
literal|") or sizeDocs is> maxMergeDocs ("
operator|+
name|maxMergeDocs
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|// need to skip that segment + add a merge for the 'right' segments,
comment|// unless there is only 1 which is merged.
if|if
condition|(
name|last
operator|-
name|start
operator|-
literal|1
operator|>
literal|1
operator|||
operator|(
name|start
operator|!=
name|last
operator|-
literal|1
operator|&&
operator|!
name|isMerged
argument_list|(
name|infos
operator|.
name|info
argument_list|(
name|start
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|// there is more than 1 segment to the right of
comment|// this one, or a mergeable single segment.
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|segments
operator|.
name|subList
argument_list|(
name|start
operator|+
literal|1
argument_list|,
name|last
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|start
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last
operator|-
name|start
operator|==
name|mergeFactor
condition|)
block|{
comment|// mergeFactor eligible segments were found, add them as a merge.
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|segments
operator|.
name|subList
argument_list|(
name|start
argument_list|,
name|last
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|start
expr_stmt|;
block|}
operator|--
name|start
expr_stmt|;
block|}
comment|// Add any left-over segments, unless there is just 1
comment|// already fully merged
if|if
condition|(
name|last
operator|>
literal|0
operator|&&
operator|(
operator|++
name|start
operator|+
literal|1
operator|<
name|last
operator|||
operator|!
name|isMerged
argument_list|(
name|infos
operator|.
name|info
argument_list|(
name|start
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|segments
operator|.
name|subList
argument_list|(
name|start
argument_list|,
name|last
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|spec
operator|.
name|merges
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|spec
return|;
block|}
comment|/**    * Returns the merges necessary to forceMerge the index. This method constraints    * the returned merges only by the {@code maxNumSegments} parameter, and    * guaranteed that exactly that number of segments will remain in the index.    */
DECL|method|findForcedMergesMaxNumSegments
specifier|private
name|MergeSpecification
name|findForcedMergesMaxNumSegments
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|int
name|maxNumSegments
parameter_list|,
name|int
name|last
parameter_list|)
throws|throws
name|IOException
block|{
name|MergeSpecification
name|spec
init|=
operator|new
name|MergeSpecification
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SegmentInfoPerCommit
argument_list|>
name|segments
init|=
name|infos
operator|.
name|asList
argument_list|()
decl_stmt|;
comment|// First, enroll all "full" merges (size
comment|// mergeFactor) to potentially be run concurrently:
while|while
condition|(
name|last
operator|-
name|maxNumSegments
operator|+
literal|1
operator|>=
name|mergeFactor
condition|)
block|{
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|segments
operator|.
name|subList
argument_list|(
name|last
operator|-
name|mergeFactor
argument_list|,
name|last
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|-=
name|mergeFactor
expr_stmt|;
block|}
comment|// Only if there are no full merges pending do we
comment|// add a final partial (< mergeFactor segments) merge:
if|if
condition|(
literal|0
operator|==
name|spec
operator|.
name|merges
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|maxNumSegments
operator|==
literal|1
condition|)
block|{
comment|// Since we must merge down to 1 segment, the
comment|// choice is simple:
if|if
condition|(
name|last
operator|>
literal|1
operator|||
operator|!
name|isMerged
argument_list|(
name|infos
operator|.
name|info
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|segments
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|last
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|last
operator|>
name|maxNumSegments
condition|)
block|{
comment|// Take care to pick a partial merge that is
comment|// least cost, but does not make the index too
comment|// lopsided.  If we always just picked the
comment|// partial tail then we could produce a highly
comment|// lopsided index over time:
comment|// We must merge this many segments to leave
comment|// maxNumSegments in the index (from when
comment|// forceMerge was first kicked off):
specifier|final
name|int
name|finalMergeSize
init|=
name|last
operator|-
name|maxNumSegments
operator|+
literal|1
decl_stmt|;
comment|// Consider all possible starting points:
name|long
name|bestSize
init|=
literal|0
decl_stmt|;
name|int
name|bestStart
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|last
operator|-
name|finalMergeSize
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|long
name|sumSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|finalMergeSize
condition|;
name|j
operator|++
control|)
block|{
name|sumSize
operator|+=
name|size
argument_list|(
name|infos
operator|.
name|info
argument_list|(
name|j
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|||
operator|(
name|sumSize
operator|<
literal|2
operator|*
name|size
argument_list|(
name|infos
operator|.
name|info
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|&&
name|sumSize
operator|<
name|bestSize
operator|)
condition|)
block|{
name|bestStart
operator|=
name|i
expr_stmt|;
name|bestSize
operator|=
name|sumSize
expr_stmt|;
block|}
block|}
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|segments
operator|.
name|subList
argument_list|(
name|bestStart
argument_list|,
name|bestStart
operator|+
name|finalMergeSize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|spec
operator|.
name|merges
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|spec
return|;
block|}
comment|/** Returns the merges necessary to merge the index down    *  to a specified number of segments.    *  This respects the {@link #maxMergeSizeForForcedMerge} setting.    *  By default, and assuming {@code maxNumSegments=1}, only    *  one segment will be left in the index, where that segment    *  has no deletions pending nor separate norms, and it is in    *  compound file format if the current useCompoundFile    *  setting is true.  This method returns multiple merges    *  (mergeFactor at a time) so the {@link MergeScheduler}    *  in use may make use of concurrency. */
annotation|@
name|Override
DECL|method|findForcedMerges
specifier|public
name|MergeSpecification
name|findForcedMerges
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|int
name|maxNumSegments
parameter_list|,
name|Map
argument_list|<
name|SegmentInfoPerCommit
argument_list|,
name|Boolean
argument_list|>
name|segmentsToMerge
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|maxNumSegments
operator|>
literal|0
assert|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"findForcedMerges: maxNumSegs="
operator|+
name|maxNumSegments
operator|+
literal|" segsToMerge="
operator|+
name|segmentsToMerge
argument_list|)
expr_stmt|;
block|}
comment|// If the segments are already merged (e.g. there's only 1 segment), or
comment|// there are<maxNumSegments:.
if|if
condition|(
name|isMerged
argument_list|(
name|infos
argument_list|,
name|maxNumSegments
argument_list|,
name|segmentsToMerge
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"already merged; skip"
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|// Find the newest (rightmost) segment that needs to
comment|// be merged (other segments may have been flushed
comment|// since merging started):
name|int
name|last
init|=
name|infos
operator|.
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|last
operator|>
literal|0
condition|)
block|{
specifier|final
name|SegmentInfoPerCommit
name|info
init|=
name|infos
operator|.
name|info
argument_list|(
operator|--
name|last
argument_list|)
decl_stmt|;
if|if
condition|(
name|segmentsToMerge
operator|.
name|get
argument_list|(
name|info
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|last
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|last
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"last == 0; skip"
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|// There is only one segment already, and it is merged
if|if
condition|(
name|maxNumSegments
operator|==
literal|1
operator|&&
name|last
operator|==
literal|1
operator|&&
name|isMerged
argument_list|(
name|infos
operator|.
name|info
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"already 1 seg; skip"
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|// Check if there are any segments above the threshold
name|boolean
name|anyTooLarge
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
block|{
name|SegmentInfoPerCommit
name|info
init|=
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
argument_list|(
name|info
argument_list|)
operator|>
name|maxMergeSizeForForcedMerge
operator|||
name|sizeDocs
argument_list|(
name|info
argument_list|)
operator|>
name|maxMergeDocs
condition|)
block|{
name|anyTooLarge
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|anyTooLarge
condition|)
block|{
return|return
name|findForcedMergesSizeLimit
argument_list|(
name|infos
argument_list|,
name|maxNumSegments
argument_list|,
name|last
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|findForcedMergesMaxNumSegments
argument_list|(
name|infos
argument_list|,
name|maxNumSegments
argument_list|,
name|last
argument_list|)
return|;
block|}
block|}
comment|/**    * Finds merges necessary to force-merge all deletes from the    * index.  We simply merge adjacent segments that have    * deletes, up to mergeFactor at a time.    */
annotation|@
name|Override
DECL|method|findForcedDeletesMerges
specifier|public
name|MergeSpecification
name|findForcedDeletesMerges
parameter_list|(
name|SegmentInfos
name|segmentInfos
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|SegmentInfoPerCommit
argument_list|>
name|segments
init|=
name|segmentInfos
operator|.
name|asList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numSegments
init|=
name|segments
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"findForcedDeleteMerges: "
operator|+
name|numSegments
operator|+
literal|" segments"
argument_list|)
expr_stmt|;
block|}
name|MergeSpecification
name|spec
init|=
operator|new
name|MergeSpecification
argument_list|()
decl_stmt|;
name|int
name|firstSegmentWithDeletions
init|=
operator|-
literal|1
decl_stmt|;
name|IndexWriter
name|w
init|=
name|writer
operator|.
name|get
argument_list|()
decl_stmt|;
assert|assert
name|w
operator|!=
literal|null
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentInfoPerCommit
name|info
init|=
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|delCount
init|=
name|w
operator|.
name|numDeletedDocs
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|delCount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"  segment "
operator|+
name|info
operator|.
name|info
operator|.
name|name
operator|+
literal|" has deletions"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|firstSegmentWithDeletions
operator|==
operator|-
literal|1
condition|)
name|firstSegmentWithDeletions
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|-
name|firstSegmentWithDeletions
operator|==
name|mergeFactor
condition|)
block|{
comment|// We've seen mergeFactor segments in a row with
comment|// deletions, so force a merge now:
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"  add merge "
operator|+
name|firstSegmentWithDeletions
operator|+
literal|" to "
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
operator|+
literal|" inclusive"
argument_list|)
expr_stmt|;
block|}
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|segments
operator|.
name|subList
argument_list|(
name|firstSegmentWithDeletions
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|firstSegmentWithDeletions
operator|=
name|i
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|firstSegmentWithDeletions
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// End of a sequence of segments with deletions, so,
comment|// merge those past segments even if it's fewer than
comment|// mergeFactor segments
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"  add merge "
operator|+
name|firstSegmentWithDeletions
operator|+
literal|" to "
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
operator|+
literal|" inclusive"
argument_list|)
expr_stmt|;
block|}
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|segments
operator|.
name|subList
argument_list|(
name|firstSegmentWithDeletions
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|firstSegmentWithDeletions
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|firstSegmentWithDeletions
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"  add merge "
operator|+
name|firstSegmentWithDeletions
operator|+
literal|" to "
operator|+
operator|(
name|numSegments
operator|-
literal|1
operator|)
operator|+
literal|" inclusive"
argument_list|)
expr_stmt|;
block|}
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|segments
operator|.
name|subList
argument_list|(
name|firstSegmentWithDeletions
argument_list|,
name|numSegments
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|spec
return|;
block|}
DECL|class|SegmentInfoAndLevel
specifier|private
specifier|static
class|class
name|SegmentInfoAndLevel
implements|implements
name|Comparable
argument_list|<
name|SegmentInfoAndLevel
argument_list|>
block|{
DECL|field|info
name|SegmentInfoPerCommit
name|info
decl_stmt|;
DECL|field|level
name|float
name|level
decl_stmt|;
DECL|field|index
name|int
name|index
decl_stmt|;
DECL|method|SegmentInfoAndLevel
specifier|public
name|SegmentInfoAndLevel
parameter_list|(
name|SegmentInfoPerCommit
name|info
parameter_list|,
name|float
name|level
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|this
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|this
operator|.
name|level
operator|=
name|level
expr_stmt|;
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
block|}
comment|// Sorts largest to smallest
annotation|@
name|Override
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|SegmentInfoAndLevel
name|other
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|other
operator|.
name|level
argument_list|,
name|level
argument_list|)
return|;
block|}
block|}
comment|/** Checks if any merges are now necessary and returns a    *  {@link MergePolicy.MergeSpecification} if so.  A merge    *  is necessary when there are more than {@link    *  #setMergeFactor} segments at a given level.  When    *  multiple levels have too many segments, this method    *  will return multiple merges, allowing the {@link    *  MergeScheduler} to use concurrency. */
annotation|@
name|Override
DECL|method|findMerges
specifier|public
name|MergeSpecification
name|findMerges
parameter_list|(
name|MergeTrigger
name|mergeTrigger
parameter_list|,
name|SegmentInfos
name|infos
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|numSegments
init|=
name|infos
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"findMerges: "
operator|+
name|numSegments
operator|+
literal|" segments"
argument_list|)
expr_stmt|;
block|}
comment|// Compute levels, which is just log (base mergeFactor)
comment|// of the size of each segment
specifier|final
name|List
argument_list|<
name|SegmentInfoAndLevel
argument_list|>
name|levels
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentInfoAndLevel
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|float
name|norm
init|=
operator|(
name|float
operator|)
name|Math
operator|.
name|log
argument_list|(
name|mergeFactor
argument_list|)
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|SegmentInfoPerCommit
argument_list|>
name|mergingSegments
init|=
name|writer
operator|.
name|get
argument_list|()
operator|.
name|getMergingSegments
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentInfoPerCommit
name|info
init|=
name|infos
operator|.
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|size
init|=
name|size
argument_list|(
name|info
argument_list|)
decl_stmt|;
comment|// Floor tiny segments
if|if
condition|(
name|size
operator|<
literal|1
condition|)
block|{
name|size
operator|=
literal|1
expr_stmt|;
block|}
specifier|final
name|SegmentInfoAndLevel
name|infoLevel
init|=
operator|new
name|SegmentInfoAndLevel
argument_list|(
name|info
argument_list|,
operator|(
name|float
operator|)
name|Math
operator|.
name|log
argument_list|(
name|size
argument_list|)
operator|/
name|norm
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|levels
operator|.
name|add
argument_list|(
name|infoLevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
specifier|final
name|long
name|segBytes
init|=
name|sizeBytes
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|String
name|extra
init|=
name|mergingSegments
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|?
literal|" [merging]"
else|:
literal|""
decl_stmt|;
if|if
condition|(
name|size
operator|>=
name|maxMergeSize
condition|)
block|{
name|extra
operator|+=
literal|" [skip: too large]"
expr_stmt|;
block|}
name|message
argument_list|(
literal|"seg="
operator|+
name|writer
operator|.
name|get
argument_list|()
operator|.
name|segString
argument_list|(
name|info
argument_list|)
operator|+
literal|" level="
operator|+
name|infoLevel
operator|.
name|level
operator|+
literal|" size="
operator|+
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%.3f MB"
argument_list|,
name|segBytes
operator|/
literal|1024
operator|/
literal|1024.
argument_list|)
operator|+
name|extra
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|float
name|levelFloor
decl_stmt|;
if|if
condition|(
name|minMergeSize
operator|<=
literal|0
condition|)
name|levelFloor
operator|=
operator|(
name|float
operator|)
literal|0.0
expr_stmt|;
else|else
name|levelFloor
operator|=
call|(
name|float
call|)
argument_list|(
name|Math
operator|.
name|log
argument_list|(
name|minMergeSize
argument_list|)
operator|/
name|norm
argument_list|)
expr_stmt|;
comment|// Now, we quantize the log values into levels.  The
comment|// first level is any segment whose log size is within
comment|// LEVEL_LOG_SPAN of the max size, or, who has such as
comment|// segment "to the right".  Then, we find the max of all
comment|// other segments and use that to define the next level
comment|// segment, etc.
name|MergeSpecification
name|spec
init|=
literal|null
decl_stmt|;
specifier|final
name|int
name|numMergeableSegments
init|=
name|levels
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|numMergeableSegments
condition|)
block|{
comment|// Find max level of all segments not already
comment|// quantized.
name|float
name|maxLevel
init|=
name|levels
operator|.
name|get
argument_list|(
name|start
argument_list|)
operator|.
name|level
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
operator|+
name|start
init|;
name|i
operator|<
name|numMergeableSegments
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|float
name|level
init|=
name|levels
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|level
decl_stmt|;
if|if
condition|(
name|level
operator|>
name|maxLevel
condition|)
block|{
name|maxLevel
operator|=
name|level
expr_stmt|;
block|}
block|}
comment|// Now search backwards for the rightmost segment that
comment|// falls into this level:
name|float
name|levelBottom
decl_stmt|;
if|if
condition|(
name|maxLevel
operator|<=
name|levelFloor
condition|)
block|{
comment|// All remaining segments fall into the min level
name|levelBottom
operator|=
operator|-
literal|1.0F
expr_stmt|;
block|}
else|else
block|{
name|levelBottom
operator|=
call|(
name|float
call|)
argument_list|(
name|maxLevel
operator|-
name|LEVEL_LOG_SPAN
argument_list|)
expr_stmt|;
comment|// Force a boundary at the level floor
if|if
condition|(
name|levelBottom
operator|<
name|levelFloor
operator|&&
name|maxLevel
operator|>=
name|levelFloor
condition|)
block|{
name|levelBottom
operator|=
name|levelFloor
expr_stmt|;
block|}
block|}
name|int
name|upto
init|=
name|numMergeableSegments
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|upto
operator|>=
name|start
condition|)
block|{
if|if
condition|(
name|levels
operator|.
name|get
argument_list|(
name|upto
argument_list|)
operator|.
name|level
operator|>=
name|levelBottom
condition|)
block|{
break|break;
block|}
name|upto
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"  level "
operator|+
name|levelBottom
operator|+
literal|" to "
operator|+
name|maxLevel
operator|+
literal|": "
operator|+
operator|(
literal|1
operator|+
name|upto
operator|-
name|start
operator|)
operator|+
literal|" segments"
argument_list|)
expr_stmt|;
block|}
comment|// Finally, record all merges that are viable at this level:
name|int
name|end
init|=
name|start
operator|+
name|mergeFactor
decl_stmt|;
while|while
condition|(
name|end
operator|<=
literal|1
operator|+
name|upto
condition|)
block|{
name|boolean
name|anyTooLarge
init|=
literal|false
decl_stmt|;
name|boolean
name|anyMerging
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentInfoPerCommit
name|info
init|=
name|levels
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|info
decl_stmt|;
name|anyTooLarge
operator||=
operator|(
name|size
argument_list|(
name|info
argument_list|)
operator|>=
name|maxMergeSize
operator|||
name|sizeDocs
argument_list|(
name|info
argument_list|)
operator|>=
name|maxMergeDocs
operator|)
expr_stmt|;
if|if
condition|(
name|mergingSegments
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|anyMerging
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|anyMerging
condition|)
block|{
comment|// skip
block|}
elseif|else
if|if
condition|(
operator|!
name|anyTooLarge
condition|)
block|{
if|if
condition|(
name|spec
operator|==
literal|null
condition|)
name|spec
operator|=
operator|new
name|MergeSpecification
argument_list|()
expr_stmt|;
specifier|final
name|List
argument_list|<
name|SegmentInfoPerCommit
argument_list|>
name|mergeInfos
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentInfoPerCommit
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|mergeInfos
operator|.
name|add
argument_list|(
name|levels
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|info
argument_list|)
expr_stmt|;
assert|assert
name|infos
operator|.
name|contains
argument_list|(
name|levels
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|info
argument_list|)
assert|;
block|}
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"  add merge="
operator|+
name|writer
operator|.
name|get
argument_list|()
operator|.
name|segString
argument_list|(
name|mergeInfos
argument_list|)
operator|+
literal|" start="
operator|+
name|start
operator|+
literal|" end="
operator|+
name|end
argument_list|)
expr_stmt|;
block|}
name|spec
operator|.
name|add
argument_list|(
operator|new
name|OneMerge
argument_list|(
name|mergeInfos
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"    "
operator|+
name|start
operator|+
literal|" to "
operator|+
name|end
operator|+
literal|": contains segment over maxMergeSize or maxMergeDocs; skipping"
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|end
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|mergeFactor
expr_stmt|;
block|}
name|start
operator|=
literal|1
operator|+
name|upto
expr_stmt|;
block|}
return|return
name|spec
return|;
block|}
comment|/**<p>Determines the largest segment (measured by    * document count) that may be merged with other segments.    * Small values (e.g., less than 10,000) are best for    * interactive indexing, as this limits the length of    * pauses while indexing to a few seconds.  Larger values    * are best for batched indexing and speedier    * searches.</p>    *    *<p>The default value is {@link Integer#MAX_VALUE}.</p>    *    *<p>The default merge policy ({@link    * LogByteSizeMergePolicy}) also allows you to set this    * limit by net size (in MB) of the segment, using {@link    * LogByteSizeMergePolicy#setMaxMergeMB}.</p>    */
DECL|method|setMaxMergeDocs
specifier|public
name|void
name|setMaxMergeDocs
parameter_list|(
name|int
name|maxMergeDocs
parameter_list|)
block|{
name|this
operator|.
name|maxMergeDocs
operator|=
name|maxMergeDocs
expr_stmt|;
block|}
comment|/** Returns the largest segment (measured by document    *  count) that may be merged with other segments.    *  @see #setMaxMergeDocs */
DECL|method|getMaxMergeDocs
specifier|public
name|int
name|getMaxMergeDocs
parameter_list|()
block|{
return|return
name|maxMergeDocs
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"["
operator|+
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": "
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"minMergeSize="
argument_list|)
operator|.
name|append
argument_list|(
name|minMergeSize
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"mergeFactor="
argument_list|)
operator|.
name|append
argument_list|(
name|mergeFactor
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxMergeSize="
argument_list|)
operator|.
name|append
argument_list|(
name|maxMergeSize
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxMergeSizeForForcedMerge="
argument_list|)
operator|.
name|append
argument_list|(
name|maxMergeSizeForForcedMerge
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"calibrateSizeByDeletes="
argument_list|)
operator|.
name|append
argument_list|(
name|calibrateSizeByDeletes
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxMergeDocs="
argument_list|)
operator|.
name|append
argument_list|(
name|maxMergeDocs
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"useCompoundFile="
argument_list|)
operator|.
name|append
argument_list|(
name|useCompoundFile
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxCFSSegmentSizeMB="
argument_list|)
operator|.
name|append
argument_list|(
name|getMaxCFSSegmentSizeMB
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"noCFSRatio="
argument_list|)
operator|.
name|append
argument_list|(
name|noCFSRatio
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Returns the largest size allowed for a compound file segment */
DECL|method|getMaxCFSSegmentSizeMB
specifier|public
specifier|final
name|double
name|getMaxCFSSegmentSizeMB
parameter_list|()
block|{
return|return
name|maxCFSSegmentSize
operator|/
literal|1024
operator|/
literal|1024.
return|;
block|}
comment|/** If a merged segment will be more than this value,    *  leave the segment as    *  non-compound file even if compound file is enabled.    *  Set this to Double.POSITIVE_INFINITY (default) and noCFSRatio to 1.0    *  to always use CFS regardless of merge size. */
DECL|method|setMaxCFSSegmentSizeMB
specifier|public
specifier|final
name|void
name|setMaxCFSSegmentSizeMB
parameter_list|(
name|double
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|<
literal|0.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxCFSSegmentSizeMB must be>=0 (got "
operator|+
name|v
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|v
operator|*=
literal|1024
operator|*
literal|1024
expr_stmt|;
name|this
operator|.
name|maxCFSSegmentSize
operator|=
operator|(
name|v
operator|>
name|Long
operator|.
name|MAX_VALUE
operator|)
condition|?
name|Long
operator|.
name|MAX_VALUE
else|:
operator|(
name|long
operator|)
name|v
expr_stmt|;
block|}
block|}
end_class
end_unit
