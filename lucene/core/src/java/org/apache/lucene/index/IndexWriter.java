begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|NoSuchFileException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValuesUpdate
operator|.
name|BinaryDocValuesUpdate
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocValuesUpdate
operator|.
name|NumericDocValuesUpdate
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|DocValuesType
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
operator|.
name|FieldNumbers
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriterConfig
operator|.
name|OpenMode
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MergeState
operator|.
name|CheckAbort
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|CompoundFileDirectory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Lock
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|LockObtainFailedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|MergeInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|TrackingDirectoryWrapper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Accountable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Constants
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|InfoStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ThreadInterruptedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
import|;
end_import
begin_comment
comment|/**   An<code>IndexWriter</code> creates and maintains an index.<p>The {@link OpenMode} option on    {@link IndexWriterConfig#setOpenMode(OpenMode)} determines    whether a new index is created, or whether an existing index is   opened. Note that you can open an index with {@link OpenMode#CREATE}   even while readers are using the index. The old readers will    continue to search the "point in time" snapshot they had opened,    and won't see the newly created index until they re-open. If    {@link OpenMode#CREATE_OR_APPEND} is used IndexWriter will create a    new index if there is not already an index at the provided path   and otherwise open the existing index.</p><p>In either case, documents are added with {@link #addDocument(IndexDocument)   addDocument} and removed with {@link #deleteDocuments(Term...)} or {@link   #deleteDocuments(Query...)}. A document can be updated with {@link   #updateDocument(Term, IndexDocument) updateDocument} (which just deletes   and then adds the entire document). When finished adding, deleting    and updating documents, {@link #close() close} should be called.</p><a name="flush"></a><p>These changes are buffered in memory and periodically   flushed to the {@link Directory} (during the above method   calls). A flush is triggered when there are enough added documents   since the last flush. Flushing is triggered either by RAM usage of the   documents (see {@link IndexWriterConfig#setRAMBufferSizeMB}) or the   number of added documents (see {@link IndexWriterConfig#setMaxBufferedDocs(int)}).   The default is to flush when RAM usage hits   {@link IndexWriterConfig#DEFAULT_RAM_BUFFER_SIZE_MB} MB. For   best indexing speed you should flush by RAM usage with a   large RAM buffer. Additionally, if IndexWriter reaches the configured number of   buffered deletes (see {@link IndexWriterConfig#setMaxBufferedDeleteTerms})   the deleted terms and queries are flushed and applied to existing segments.   In contrast to the other flush options {@link IndexWriterConfig#setRAMBufferSizeMB} and    {@link IndexWriterConfig#setMaxBufferedDocs(int)}, deleted terms   won't trigger a segment flush. Note that flushing just moves the   internal buffered state in IndexWriter into the index, but   these changes are not visible to IndexReader until either   {@link #commit()} or {@link #close} is called.  A flush may   also trigger one or more segment merges which by default   run with a background thread so as not to block the   addDocument calls (see<a href="#mergePolicy">below</a>   for changing the {@link MergeScheduler}).</p><p>Opening an<code>IndexWriter</code> creates a lock file for the directory in use. Trying to open   another<code>IndexWriter</code> on the same directory will lead to a   {@link LockObtainFailedException}. The {@link LockObtainFailedException}   is also thrown if an IndexReader on the same directory is used to delete documents   from the index.</p><a name="deletionPolicy"></a><p>Expert:<code>IndexWriter</code> allows an optional   {@link IndexDeletionPolicy} implementation to be   specified.  You can use this to control when prior commits   are deleted from the index.  The default policy is {@link   KeepOnlyLastCommitDeletionPolicy} which removes all prior   commits as soon as a new commit is done (this matches   behavior before 2.2).  Creating your own policy can allow   you to explicitly keep previous "point in time" commits   alive in the index for some time, to allow readers to   refresh to the new commit without having the old commit   deleted out from under them.  This is necessary on   filesystems like NFS that do not support "delete on last   close" semantics, which Lucene's "point in time" search   normally relies on.</p><a name="mergePolicy"></a><p>Expert:<code>IndexWriter</code> allows you to separately change   the {@link MergePolicy} and the {@link MergeScheduler}.   The {@link MergePolicy} is invoked whenever there are   changes to the segments in the index.  Its role is to   select which merges to do, if any, and return a {@link   MergePolicy.MergeSpecification} describing the merges.   The default is {@link LogByteSizeMergePolicy}.  Then, the {@link   MergeScheduler} is invoked with the requested merges and   it decides when and how to run the merges.  The default is   {@link ConcurrentMergeScheduler}.</p><a name="OOME"></a><p><b>NOTE</b>: if you hit an   OutOfMemoryError then IndexWriter will quietly record this   fact and block all future segment commits.  This is a   defensive measure in case any internal state (buffered   documents and deletions) were corrupted.  Any subsequent   calls to {@link #commit()} will throw an   IllegalStateException.  The only course of action is to   call {@link #close()}, which internally will call {@link   #rollback()}, to undo any changes to the index since the   last commit.  You can also just call {@link #rollback()}   directly.</p><a name="thread-safety"></a><p><b>NOTE</b>: {@link   IndexWriter} instances are completely thread   safe, meaning multiple threads can call any of its   methods, concurrently.  If your application requires   external synchronization, you should<b>not</b>   synchronize on the<code>IndexWriter</code> instance as   this may cause deadlock; use your own (non-Lucene) objects   instead.</p><p><b>NOTE</b>: If you call<code>Thread.interrupt()</code> on a thread that's within   IndexWriter, IndexWriter will try to catch this (eg, if   it's in a wait() or Thread.sleep()), and will then throw   the unchecked exception {@link ThreadInterruptedException}   and<b>clear</b> the interrupt status on the thread.</p> */
end_comment
begin_comment
comment|/*  * Clarification: Check Points (and commits)  * IndexWriter writes new index files to the directory without writing a new segments_N  * file which references these new files. It also means that the state of  * the in memory SegmentInfos object is different than the most recent  * segments_N file written to the directory.  *  * Each time the SegmentInfos is changed, and matches the (possibly  * modified) directory files, we have a new "check point".  * If the modified/new SegmentInfos is written to disk - as a new  * (generation of) segments_N file - this check point is also an  * IndexCommit.  *  * A new checkpoint always replaces the previous checkpoint and  * becomes the new "front" of the index. This allows the IndexFileDeleter  * to delete files that are referenced only by stale checkpoints.  * (files that were created since the last commit, but are no longer  * referenced by the "front" of the index). For this, IndexFileDeleter  * keeps track of the last non commit checkpoint.  */
end_comment
begin_class
DECL|class|IndexWriter
specifier|public
class|class
name|IndexWriter
implements|implements
name|Closeable
implements|,
name|TwoPhaseCommit
implements|,
name|Accountable
block|{
comment|/** Hard limit on maximum number of documents that may be added to the    *  index.  If you try to add more than this you'll hit {@code IllegalStateException}. */
comment|// We defensively subtract 128 to be well below the lowest
comment|// ArrayUtil.MAX_ARRAY_LENGTH on "typical" JVMs.  We don't just use
comment|// ArrayUtil.MAX_ARRAY_LENGTH here because this can vary across JVMs:
DECL|field|MAX_DOCS
specifier|public
specifier|static
specifier|final
name|int
name|MAX_DOCS
init|=
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|128
decl_stmt|;
comment|// Use package-private instance var to enforce the limit so testing
comment|// can use less electricity:
DECL|field|actualMaxDocs
specifier|private
specifier|static
name|int
name|actualMaxDocs
init|=
name|MAX_DOCS
decl_stmt|;
comment|/** Used only for testing. */
DECL|method|setMaxDocs
specifier|static
name|void
name|setMaxDocs
parameter_list|(
name|int
name|maxDocs
parameter_list|)
block|{
if|if
condition|(
name|maxDocs
operator|>
name|MAX_DOCS
condition|)
block|{
comment|// Cannot go higher than the hard max:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxDocs must be<= IndexWriter.MAX_DOCS="
operator|+
name|MAX_DOCS
operator|+
literal|"; got: "
operator|+
name|maxDocs
argument_list|)
throw|;
block|}
name|IndexWriter
operator|.
name|actualMaxDocs
operator|=
name|maxDocs
expr_stmt|;
block|}
DECL|method|getActualMaxDocs
specifier|static
name|int
name|getActualMaxDocs
parameter_list|()
block|{
return|return
name|IndexWriter
operator|.
name|actualMaxDocs
return|;
block|}
DECL|field|UNBOUNDED_MAX_MERGE_SEGMENTS
specifier|private
specifier|static
specifier|final
name|int
name|UNBOUNDED_MAX_MERGE_SEGMENTS
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * Name of the write lock in the index.    */
DECL|field|WRITE_LOCK_NAME
specifier|public
specifier|static
specifier|final
name|String
name|WRITE_LOCK_NAME
init|=
literal|"write.lock"
decl_stmt|;
comment|/** Key for the source of a segment in the {@link SegmentInfo#getDiagnostics() diagnostics}. */
DECL|field|SOURCE
specifier|public
specifier|static
specifier|final
name|String
name|SOURCE
init|=
literal|"source"
decl_stmt|;
comment|/** Source of a segment which results from a merge of other segments. */
DECL|field|SOURCE_MERGE
specifier|public
specifier|static
specifier|final
name|String
name|SOURCE_MERGE
init|=
literal|"merge"
decl_stmt|;
comment|/** Source of a segment which results from a flush. */
DECL|field|SOURCE_FLUSH
specifier|public
specifier|static
specifier|final
name|String
name|SOURCE_FLUSH
init|=
literal|"flush"
decl_stmt|;
comment|/** Source of a segment which results from a call to {@link #addIndexes(IndexReader...)}. */
DECL|field|SOURCE_ADDINDEXES_READERS
specifier|public
specifier|static
specifier|final
name|String
name|SOURCE_ADDINDEXES_READERS
init|=
literal|"addIndexes(IndexReader...)"
decl_stmt|;
comment|/**    * Absolute hard maximum length for a term, in bytes once    * encoded as UTF8.  If a term arrives from the analyzer    * longer than this length, an    *<code>IllegalArgumentException</code>  is thrown    * and a message is printed to infoStream, if set (see {@link    * IndexWriterConfig#setInfoStream(InfoStream)}).    */
DECL|field|MAX_TERM_LENGTH
specifier|public
specifier|final
specifier|static
name|int
name|MAX_TERM_LENGTH
init|=
name|DocumentsWriterPerThread
operator|.
name|MAX_TERM_LENGTH_UTF8
decl_stmt|;
DECL|field|hitOOM
specifier|volatile
specifier|private
name|boolean
name|hitOOM
decl_stmt|;
DECL|field|directory
specifier|private
specifier|final
name|Directory
name|directory
decl_stmt|;
comment|// where this index resides
DECL|field|analyzer
specifier|private
specifier|final
name|Analyzer
name|analyzer
decl_stmt|;
comment|// how to analyze text
DECL|field|changeCount
specifier|private
specifier|volatile
name|long
name|changeCount
decl_stmt|;
comment|// increments every time a change is completed
DECL|field|lastCommitChangeCount
specifier|private
specifier|volatile
name|long
name|lastCommitChangeCount
decl_stmt|;
comment|// last changeCount that was committed
DECL|field|rollbackSegments
specifier|private
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|rollbackSegments
decl_stmt|;
comment|// list of segmentInfo we will fallback to if the commit fails
DECL|field|pendingCommit
specifier|volatile
name|SegmentInfos
name|pendingCommit
decl_stmt|;
comment|// set when a commit is pending (after prepareCommit()& before commit())
DECL|field|pendingCommitChangeCount
specifier|volatile
name|long
name|pendingCommitChangeCount
decl_stmt|;
DECL|field|filesToCommit
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|filesToCommit
decl_stmt|;
DECL|field|segmentInfos
specifier|final
name|SegmentInfos
name|segmentInfos
decl_stmt|;
comment|// the segments
DECL|field|globalFieldNumberMap
specifier|final
name|FieldNumbers
name|globalFieldNumberMap
decl_stmt|;
DECL|field|docWriter
specifier|private
specifier|final
name|DocumentsWriter
name|docWriter
decl_stmt|;
DECL|field|eventQueue
specifier|private
specifier|final
name|Queue
argument_list|<
name|Event
argument_list|>
name|eventQueue
decl_stmt|;
DECL|field|deleter
specifier|final
name|IndexFileDeleter
name|deleter
decl_stmt|;
comment|// used by forceMerge to note those needing merging
DECL|field|segmentsToMerge
specifier|private
name|Map
argument_list|<
name|SegmentCommitInfo
argument_list|,
name|Boolean
argument_list|>
name|segmentsToMerge
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|mergeMaxNumSegments
specifier|private
name|int
name|mergeMaxNumSegments
decl_stmt|;
DECL|field|writeLock
specifier|private
name|Lock
name|writeLock
decl_stmt|;
DECL|field|closed
specifier|private
specifier|volatile
name|boolean
name|closed
decl_stmt|;
DECL|field|closing
specifier|private
specifier|volatile
name|boolean
name|closing
decl_stmt|;
comment|// Holds all SegmentInfo instances currently involved in
comment|// merges
DECL|field|mergingSegments
specifier|private
name|HashSet
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|mergingSegments
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|mergePolicy
specifier|private
name|MergePolicy
name|mergePolicy
decl_stmt|;
DECL|field|mergeScheduler
specifier|private
specifier|final
name|MergeScheduler
name|mergeScheduler
decl_stmt|;
DECL|field|pendingMerges
specifier|private
name|LinkedList
argument_list|<
name|MergePolicy
operator|.
name|OneMerge
argument_list|>
name|pendingMerges
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|runningMerges
specifier|private
name|Set
argument_list|<
name|MergePolicy
operator|.
name|OneMerge
argument_list|>
name|runningMerges
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|mergeExceptions
specifier|private
name|List
argument_list|<
name|MergePolicy
operator|.
name|OneMerge
argument_list|>
name|mergeExceptions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|mergeGen
specifier|private
name|long
name|mergeGen
decl_stmt|;
DECL|field|stopMerges
specifier|private
name|boolean
name|stopMerges
decl_stmt|;
DECL|field|didMessageState
specifier|private
name|boolean
name|didMessageState
decl_stmt|;
DECL|field|flushCount
specifier|final
name|AtomicInteger
name|flushCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|flushDeletesCount
specifier|final
name|AtomicInteger
name|flushDeletesCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|readerPool
specifier|final
name|ReaderPool
name|readerPool
init|=
operator|new
name|ReaderPool
argument_list|()
decl_stmt|;
DECL|field|bufferedUpdatesStream
specifier|final
name|BufferedUpdatesStream
name|bufferedUpdatesStream
decl_stmt|;
comment|// This is a "write once" variable (like the organic dye
comment|// on a DVD-R that may or may not be heated by a laser and
comment|// then cooled to permanently record the event): it's
comment|// false, until getReader() is called for the first time,
comment|// at which point it's switched to true and never changes
comment|// back to false.  Once this is true, we hold open and
comment|// reuse SegmentReader instances internally for applying
comment|// deletes, doing merges, and reopening near real-time
comment|// readers.
DECL|field|poolReaders
specifier|private
specifier|volatile
name|boolean
name|poolReaders
decl_stmt|;
comment|// The instance that was passed to the constructor. It is saved only in order
comment|// to allow users to query an IndexWriter settings.
DECL|field|config
specifier|private
specifier|final
name|LiveIndexWriterConfig
name|config
decl_stmt|;
comment|/** System.nanoTime() when commit started; used to write    *  an infoStream message about how long commit took. */
DECL|field|startCommitTime
specifier|private
name|long
name|startCommitTime
decl_stmt|;
comment|/** How many documents are in the index, or are in the process of being    *  added (reserved).  E.g., operations like addIndexes will first reserve    *  the right to add N docs, before they actually change the index,    *  much like how hotels place an "authorization hold" on your credit    *  card to make sure they can later charge you when you check out. */
DECL|field|pendingNumDocs
specifier|final
name|AtomicLong
name|pendingNumDocs
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|method|getReader
name|DirectoryReader
name|getReader
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getReader
argument_list|(
literal|true
argument_list|)
return|;
block|}
comment|/**    * Expert: returns a readonly reader, covering all    * committed as well as un-committed changes to the index.    * This provides "near real-time" searching, in that    * changes made during an IndexWriter session can be    * quickly made available for searching without closing    * the writer nor calling {@link #commit}.    *    *<p>Note that this is functionally equivalent to calling    * {#flush} and then opening a new reader.  But the turnaround time of this    * method should be faster since it avoids the potentially    * costly {@link #commit}.</p>    *    *<p>You must close the {@link IndexReader} returned by    * this method once you are done using it.</p>    *    *<p>It's<i>near</i> real-time because there is no hard    * guarantee on how quickly you can get a new reader after    * making changes with IndexWriter.  You'll have to    * experiment in your situation to determine if it's    * fast enough.  As this is a new and experimental    * feature, please report back on your findings so we can    * learn, improve and iterate.</p>    *    *<p>The resulting reader supports {@link    * DirectoryReader#openIfChanged}, but that call will simply forward    * back to this method (though this may change in the    * future).</p>    *    *<p>The very first time this method is called, this    * writer instance will make every effort to pool the    * readers that it opens for doing merges, applying    * deletes, etc.  This means additional resources (RAM,    * file descriptors, CPU time) will be consumed.</p>    *    *<p>For lower latency on reopening a reader, you should    * call {@link IndexWriterConfig#setMergedSegmentWarmer} to    * pre-warm a newly merged segment before it's committed    * to the index.  This is important for minimizing    * index-to-search delay after a large merge.</p>    *    *<p>If an addIndexes* call is running in another thread,    * then this reader will only search those segments from    * the foreign index that have been successfully copied    * over, so far</p>.    *    *<p><b>NOTE</b>: Once the writer is closed, any    * outstanding readers may continue to be used.  However,    * if you attempt to reopen any of those readers, you'll    * hit an {@link AlreadyClosedException}.</p>    *    * @lucene.experimental    *    * @return IndexReader that covers entire index plus all    * changes made so far by this IndexWriter instance    *    * @throws IOException If there is a low-level I/O error    */
DECL|method|getReader
name|DirectoryReader
name|getReader
parameter_list|(
name|boolean
name|applyAllDeletes
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
specifier|final
name|long
name|tStart
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"flush at getReader"
argument_list|)
expr_stmt|;
block|}
comment|// Do this up front before flushing so that the readers
comment|// obtained during this flush are pooled, the first time
comment|// this method is called:
name|poolReaders
operator|=
literal|true
expr_stmt|;
name|DirectoryReader
name|r
init|=
literal|null
decl_stmt|;
name|doBeforeFlush
argument_list|()
expr_stmt|;
name|boolean
name|anySegmentFlushed
init|=
literal|false
decl_stmt|;
comment|/*      * for releasing a NRT reader we must ensure that       * DW doesn't add any segments or deletes until we are      * done with creating the NRT DirectoryReader.       * We release the two stage full flush after we are done opening the      * directory reader!      */
name|boolean
name|success2
init|=
literal|false
decl_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|fullFlushLock
init|)
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|anySegmentFlushed
operator|=
name|docWriter
operator|.
name|flushAllThreads
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anySegmentFlushed
condition|)
block|{
comment|// prevent double increment since docWriter#doFlush increments the flushcount
comment|// if we flushed anything.
name|flushCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
comment|// Prevent segmentInfos from changing while opening the
comment|// reader; in theory we could instead do similar retry logic,
comment|// just like we do when loading segments_N
synchronized|synchronized
init|(
name|this
init|)
block|{
name|maybeApplyDeletes
argument_list|(
name|applyAllDeletes
argument_list|)
expr_stmt|;
name|r
operator|=
name|StandardDirectoryReader
operator|.
name|open
argument_list|(
name|this
argument_list|,
name|segmentInfos
argument_list|,
name|applyAllDeletes
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"return reader version="
operator|+
name|r
operator|.
name|getVersion
argument_list|()
operator|+
literal|" reader="
operator|+
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"getReader"
argument_list|)
expr_stmt|;
comment|// never reached but javac disagrees:
return|return
literal|null
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"hit exception during NRT reader"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Done: finish the full flush!
name|docWriter
operator|.
name|finishFullFlush
argument_list|(
name|success
argument_list|)
expr_stmt|;
name|processEvents
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|doAfterFlush
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|anySegmentFlushed
condition|)
block|{
name|maybeMerge
argument_list|(
name|MergeTrigger
operator|.
name|FULL_FLUSH
argument_list|,
name|UNBOUNDED_MAX_MERGE_SEGMENTS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"getReader took "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|tStart
operator|)
operator|+
literal|" msec"
argument_list|)
expr_stmt|;
block|}
name|success2
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success2
condition|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|r
return|;
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
specifier|final
name|long
name|ramBytesUsed
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|docWriter
operator|.
name|ramBytesUsed
argument_list|()
return|;
block|}
comment|/** Holds shared SegmentReader instances. IndexWriter uses    *  SegmentReaders for 1) applying deletes, 2) doing    *  merges, 3) handing out a real-time reader.  This pool    *  reuses instances of the SegmentReaders in all these    *  places if it is in "near real-time mode" (getReader()    *  has been called on this instance). */
DECL|class|ReaderPool
class|class
name|ReaderPool
implements|implements
name|Closeable
block|{
DECL|field|readerMap
specifier|private
specifier|final
name|Map
argument_list|<
name|SegmentCommitInfo
argument_list|,
name|ReadersAndUpdates
argument_list|>
name|readerMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// used only by asserts
DECL|method|infoIsLive
specifier|public
specifier|synchronized
name|boolean
name|infoIsLive
parameter_list|(
name|SegmentCommitInfo
name|info
parameter_list|)
block|{
name|int
name|idx
init|=
name|segmentInfos
operator|.
name|indexOf
argument_list|(
name|info
argument_list|)
decl_stmt|;
assert|assert
name|idx
operator|!=
operator|-
literal|1
operator|:
literal|"info="
operator|+
name|info
operator|+
literal|" isn't live"
assert|;
assert|assert
name|segmentInfos
operator|.
name|info
argument_list|(
name|idx
argument_list|)
operator|==
name|info
operator|:
literal|"info="
operator|+
name|info
operator|+
literal|" doesn't match live info in segmentInfos"
assert|;
return|return
literal|true
return|;
block|}
DECL|method|drop
specifier|public
specifier|synchronized
name|void
name|drop
parameter_list|(
name|SegmentCommitInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ReadersAndUpdates
name|rld
init|=
name|readerMap
operator|.
name|get
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|rld
operator|!=
literal|null
condition|)
block|{
assert|assert
name|info
operator|==
name|rld
operator|.
name|info
assert|;
comment|//        System.out.println("[" + Thread.currentThread().getName() + "] ReaderPool.drop: " + info);
name|readerMap
operator|.
name|remove
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|rld
operator|.
name|dropReaders
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|anyPendingDeletes
specifier|public
specifier|synchronized
name|boolean
name|anyPendingDeletes
parameter_list|()
block|{
for|for
control|(
name|ReadersAndUpdates
name|rld
range|:
name|readerMap
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|rld
operator|.
name|getPendingDeleteCount
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|release
specifier|public
specifier|synchronized
name|void
name|release
parameter_list|(
name|ReadersAndUpdates
name|rld
parameter_list|)
throws|throws
name|IOException
block|{
name|release
argument_list|(
name|rld
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|release
specifier|public
specifier|synchronized
name|void
name|release
parameter_list|(
name|ReadersAndUpdates
name|rld
parameter_list|,
name|boolean
name|assertInfoLive
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Matches incRef in get:
name|rld
operator|.
name|decRef
argument_list|()
expr_stmt|;
comment|// Pool still holds a ref:
assert|assert
name|rld
operator|.
name|refCount
argument_list|()
operator|>=
literal|1
assert|;
if|if
condition|(
operator|!
name|poolReaders
operator|&&
name|rld
operator|.
name|refCount
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// This is the last ref to this RLD, and we're not
comment|// pooling, so remove it:
comment|//        System.out.println("[" + Thread.currentThread().getName() + "] ReaderPool.release: " + rld.info);
if|if
condition|(
name|rld
operator|.
name|writeLiveDocs
argument_list|(
name|directory
argument_list|)
condition|)
block|{
comment|// Make sure we only write del docs for a live segment:
assert|assert
name|assertInfoLive
operator|==
literal|false
operator|||
name|infoIsLive
argument_list|(
name|rld
operator|.
name|info
argument_list|)
assert|;
comment|// Must checkpoint because we just
comment|// created new _X_N.del and field updates files;
comment|// don't call IW.checkpoint because that also
comment|// increments SIS.version, which we do not want to
comment|// do here: it was done previously (after we
comment|// invoked BDS.applyDeletes), whereas here all we
comment|// did was move the state to disk:
name|checkpointNoSIS
argument_list|()
expr_stmt|;
block|}
comment|//System.out.println("IW: done writeLiveDocs for info=" + rld.info);
comment|//        System.out.println("[" + Thread.currentThread().getName() + "] ReaderPool.release: drop readers " + rld.info);
name|rld
operator|.
name|dropReaders
argument_list|()
expr_stmt|;
name|readerMap
operator|.
name|remove
argument_list|(
name|rld
operator|.
name|info
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|dropAll
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/** Remove all our references to readers, and commits      *  any pending changes. */
DECL|method|dropAll
specifier|synchronized
name|void
name|dropAll
parameter_list|(
name|boolean
name|doSave
parameter_list|)
throws|throws
name|IOException
block|{
name|Throwable
name|priorE
init|=
literal|null
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|SegmentCommitInfo
argument_list|,
name|ReadersAndUpdates
argument_list|>
argument_list|>
name|it
init|=
name|readerMap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|ReadersAndUpdates
name|rld
init|=
name|it
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|doSave
operator|&&
name|rld
operator|.
name|writeLiveDocs
argument_list|(
name|directory
argument_list|)
condition|)
block|{
comment|// Make sure we only write del docs and field updates for a live segment:
assert|assert
name|infoIsLive
argument_list|(
name|rld
operator|.
name|info
argument_list|)
assert|;
comment|// Must checkpoint because we just
comment|// created new _X_N.del and field updates files;
comment|// don't call IW.checkpoint because that also
comment|// increments SIS.version, which we do not want to
comment|// do here: it was done previously (after we
comment|// invoked BDS.applyDeletes), whereas here all we
comment|// did was move the state to disk:
name|checkpointNoSIS
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|doSave
condition|)
block|{
name|IOUtils
operator|.
name|reThrow
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|priorE
operator|==
literal|null
condition|)
block|{
name|priorE
operator|=
name|t
expr_stmt|;
block|}
block|}
comment|// Important to remove as-we-go, not with .clear()
comment|// in the end, in case we hit an exception;
comment|// otherwise we could over-decref if close() is
comment|// called again:
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|// NOTE: it is allowed that these decRefs do not
comment|// actually close the SRs; this happens when a
comment|// near real-time reader is kept open after the
comment|// IndexWriter instance is closed:
try|try
block|{
name|rld
operator|.
name|dropReaders
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|doSave
condition|)
block|{
name|IOUtils
operator|.
name|reThrow
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|priorE
operator|==
literal|null
condition|)
block|{
name|priorE
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
assert|assert
name|readerMap
operator|.
name|size
argument_list|()
operator|==
literal|0
assert|;
name|IOUtils
operator|.
name|reThrow
argument_list|(
name|priorE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Commit live docs changes for the segment readers for      * the provided infos.      *      * @throws IOException If there is a low-level I/O error      */
DECL|method|commit
specifier|public
specifier|synchronized
name|void
name|commit
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|infos
control|)
block|{
specifier|final
name|ReadersAndUpdates
name|rld
init|=
name|readerMap
operator|.
name|get
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|rld
operator|!=
literal|null
condition|)
block|{
assert|assert
name|rld
operator|.
name|info
operator|==
name|info
assert|;
if|if
condition|(
name|rld
operator|.
name|writeLiveDocs
argument_list|(
name|directory
argument_list|)
condition|)
block|{
comment|// Make sure we only write del docs for a live segment:
assert|assert
name|infoIsLive
argument_list|(
name|info
argument_list|)
assert|;
comment|// Must checkpoint because we just
comment|// created new _X_N.del and field updates files;
comment|// don't call IW.checkpoint because that also
comment|// increments SIS.version, which we do not want to
comment|// do here: it was done previously (after we
comment|// invoked BDS.applyDeletes), whereas here all we
comment|// did was move the state to disk:
name|checkpointNoSIS
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Obtain a ReadersAndLiveDocs instance from the      * readerPool.  If create is true, you must later call      * {@link #release(ReadersAndUpdates)}.      */
DECL|method|get
specifier|public
specifier|synchronized
name|ReadersAndUpdates
name|get
parameter_list|(
name|SegmentCommitInfo
name|info
parameter_list|,
name|boolean
name|create
parameter_list|)
block|{
assert|assert
name|info
operator|.
name|info
operator|.
name|dir
operator|==
name|directory
operator|:
literal|"info.dir="
operator|+
name|info
operator|.
name|info
operator|.
name|dir
operator|+
literal|" vs "
operator|+
name|directory
assert|;
name|ReadersAndUpdates
name|rld
init|=
name|readerMap
operator|.
name|get
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|rld
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|create
condition|)
block|{
return|return
literal|null
return|;
block|}
name|rld
operator|=
operator|new
name|ReadersAndUpdates
argument_list|(
name|IndexWriter
operator|.
name|this
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|// Steal initial reference:
name|readerMap
operator|.
name|put
argument_list|(
name|info
argument_list|,
name|rld
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|rld
operator|.
name|info
operator|==
name|info
operator|:
literal|"rld.info="
operator|+
name|rld
operator|.
name|info
operator|+
literal|" info="
operator|+
name|info
operator|+
literal|" isLive?="
operator|+
name|infoIsLive
argument_list|(
name|rld
operator|.
name|info
argument_list|)
operator|+
literal|" vs "
operator|+
name|infoIsLive
argument_list|(
name|info
argument_list|)
assert|;
block|}
if|if
condition|(
name|create
condition|)
block|{
comment|// Return ref to caller:
name|rld
operator|.
name|incRef
argument_list|()
expr_stmt|;
block|}
assert|assert
name|noDups
argument_list|()
assert|;
return|return
name|rld
return|;
block|}
comment|// Make sure that every segment appears only once in the
comment|// pool:
DECL|method|noDups
specifier|private
name|boolean
name|noDups
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|seen
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|readerMap
operator|.
name|keySet
argument_list|()
control|)
block|{
assert|assert
operator|!
name|seen
operator|.
name|contains
argument_list|(
name|info
operator|.
name|info
operator|.
name|name
argument_list|)
assert|;
name|seen
operator|.
name|add
argument_list|(
name|info
operator|.
name|info
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Obtain the number of deleted docs for a pooled reader.    * If the reader isn't being pooled, the segmentInfo's     * delCount is returned.    */
DECL|method|numDeletedDocs
specifier|public
name|int
name|numDeletedDocs
parameter_list|(
name|SegmentCommitInfo
name|info
parameter_list|)
block|{
name|ensureOpen
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|int
name|delCount
init|=
name|info
operator|.
name|getDelCount
argument_list|()
decl_stmt|;
specifier|final
name|ReadersAndUpdates
name|rld
init|=
name|readerPool
operator|.
name|get
argument_list|(
name|info
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|rld
operator|!=
literal|null
condition|)
block|{
name|delCount
operator|+=
name|rld
operator|.
name|getPendingDeleteCount
argument_list|()
expr_stmt|;
block|}
return|return
name|delCount
return|;
block|}
comment|/**    * Used internally to throw an {@link AlreadyClosedException} if this    * IndexWriter has been closed or is in the process of closing.    *     * @param failIfClosing    *          if true, also fail when {@code IndexWriter} is in the process of    *          closing ({@code closing=true}) but not yet done closing (    *          {@code closed=false})    * @throws AlreadyClosedException    *           if this IndexWriter is closed or in the process of closing    */
DECL|method|ensureOpen
specifier|protected
specifier|final
name|void
name|ensureOpen
parameter_list|(
name|boolean
name|failIfClosing
parameter_list|)
throws|throws
name|AlreadyClosedException
block|{
if|if
condition|(
name|closed
operator|||
operator|(
name|failIfClosing
operator|&&
name|closing
operator|)
condition|)
block|{
throw|throw
operator|new
name|AlreadyClosedException
argument_list|(
literal|"this IndexWriter is closed"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Used internally to throw an {@link    * AlreadyClosedException} if this IndexWriter has been    * closed ({@code closed=true}) or is in the process of    * closing ({@code closing=true}).    *<p>    * Calls {@link #ensureOpen(boolean) ensureOpen(true)}.    * @throws AlreadyClosedException if this IndexWriter is closed    */
DECL|method|ensureOpen
specifier|protected
specifier|final
name|void
name|ensureOpen
parameter_list|()
throws|throws
name|AlreadyClosedException
block|{
name|ensureOpen
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|field|codec
specifier|final
name|Codec
name|codec
decl_stmt|;
comment|// for writing new segments
comment|/**    * Constructs a new IndexWriter per the settings given in<code>conf</code>.    * If you want to make "live" changes to this writer instance, use    * {@link #getConfig()}.    *     *<p>    *<b>NOTE:</b> after ths writer is created, the given configuration instance    * cannot be passed to another writer. If you intend to do so, you should    * {@link IndexWriterConfig#clone() clone} it beforehand.    *     * @param d    *          the index directory. The index is either created or appended    *          according<code>conf.getOpenMode()</code>.    * @param conf    *          the configuration settings according to which IndexWriter should    *          be initialized.    * @throws IOException    *           if the directory cannot be read/written to, or if it does not    *           exist and<code>conf.getOpenMode()</code> is    *<code>OpenMode.APPEND</code> or if there is any other low-level    *           IO error    */
DECL|method|IndexWriter
specifier|public
name|IndexWriter
parameter_list|(
name|Directory
name|d
parameter_list|,
name|IndexWriterConfig
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|conf
operator|.
name|setIndexWriter
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// prevent reuse by other instances
name|config
operator|=
name|conf
expr_stmt|;
name|directory
operator|=
name|d
expr_stmt|;
name|analyzer
operator|=
name|config
operator|.
name|getAnalyzer
argument_list|()
expr_stmt|;
name|infoStream
operator|=
name|config
operator|.
name|getInfoStream
argument_list|()
expr_stmt|;
name|mergePolicy
operator|=
name|config
operator|.
name|getMergePolicy
argument_list|()
expr_stmt|;
name|mergeScheduler
operator|=
name|config
operator|.
name|getMergeScheduler
argument_list|()
expr_stmt|;
name|codec
operator|=
name|config
operator|.
name|getCodec
argument_list|()
expr_stmt|;
name|bufferedUpdatesStream
operator|=
operator|new
name|BufferedUpdatesStream
argument_list|(
name|infoStream
argument_list|)
expr_stmt|;
name|poolReaders
operator|=
name|config
operator|.
name|getReaderPooling
argument_list|()
expr_stmt|;
name|writeLock
operator|=
name|directory
operator|.
name|makeLock
argument_list|(
name|WRITE_LOCK_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|writeLock
operator|.
name|obtain
argument_list|(
name|config
operator|.
name|getWriteLockTimeout
argument_list|()
argument_list|)
condition|)
comment|// obtain write lock
throw|throw
operator|new
name|LockObtainFailedException
argument_list|(
literal|"Index locked for write: "
operator|+
name|writeLock
argument_list|)
throw|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|OpenMode
name|mode
init|=
name|config
operator|.
name|getOpenMode
argument_list|()
decl_stmt|;
name|boolean
name|create
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|OpenMode
operator|.
name|CREATE
condition|)
block|{
name|create
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|OpenMode
operator|.
name|APPEND
condition|)
block|{
name|create
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// CREATE_OR_APPEND - create only if an index does not exist
name|create
operator|=
operator|!
name|DirectoryReader
operator|.
name|indexExists
argument_list|(
name|directory
argument_list|)
expr_stmt|;
block|}
comment|// If index is too old, reading the segments will throw
comment|// IndexFormatTooOldException.
name|segmentInfos
operator|=
operator|new
name|SegmentInfos
argument_list|()
expr_stmt|;
name|boolean
name|initialIndexExists
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|create
condition|)
block|{
comment|// Try to read first.  This is to allow create
comment|// against an index that's currently open for
comment|// searching.  In this case we write the next
comment|// segments_N file with no segments:
try|try
block|{
name|segmentInfos
operator|.
name|read
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|segmentInfos
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Likely this means it's a fresh directory
name|initialIndexExists
operator|=
literal|false
expr_stmt|;
block|}
comment|// Record that we have a change (zero out all
comment|// segments) pending:
name|changed
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|segmentInfos
operator|.
name|read
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|IndexCommit
name|commit
init|=
name|config
operator|.
name|getIndexCommit
argument_list|()
decl_stmt|;
if|if
condition|(
name|commit
operator|!=
literal|null
condition|)
block|{
comment|// Swap out all segments, but, keep metadata in
comment|// SegmentInfos, like version& generation, to
comment|// preserve write-once.  This is important if
comment|// readers are open against the future commit
comment|// points.
if|if
condition|(
name|commit
operator|.
name|getDirectory
argument_list|()
operator|!=
name|directory
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"IndexCommit's directory doesn't match my directory"
argument_list|)
throw|;
name|SegmentInfos
name|oldInfos
init|=
operator|new
name|SegmentInfos
argument_list|()
decl_stmt|;
name|oldInfos
operator|.
name|read
argument_list|(
name|directory
argument_list|,
name|commit
operator|.
name|getSegmentsFileName
argument_list|()
argument_list|)
expr_stmt|;
name|segmentInfos
operator|.
name|replace
argument_list|(
name|oldInfos
argument_list|)
expr_stmt|;
name|changed
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"init: loaded commit \""
operator|+
name|commit
operator|.
name|getSegmentsFileName
argument_list|()
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|rollbackSegments
operator|=
name|segmentInfos
operator|.
name|createBackupSegmentInfos
argument_list|()
expr_stmt|;
comment|// start with previous field numbers, but new FieldInfos
name|globalFieldNumberMap
operator|=
name|getFieldNumberMap
argument_list|()
expr_stmt|;
name|config
operator|.
name|getFlushPolicy
argument_list|()
operator|.
name|init
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|docWriter
operator|=
operator|new
name|DocumentsWriter
argument_list|(
name|this
argument_list|,
name|config
argument_list|,
name|directory
argument_list|)
expr_stmt|;
name|eventQueue
operator|=
name|docWriter
operator|.
name|eventQueue
argument_list|()
expr_stmt|;
comment|// Default deleter (for backwards compatibility) is
comment|// KeepOnlyLastCommitDeleter:
synchronized|synchronized
init|(
name|this
init|)
block|{
name|deleter
operator|=
operator|new
name|IndexFileDeleter
argument_list|(
name|directory
argument_list|,
name|config
operator|.
name|getIndexDeletionPolicy
argument_list|()
argument_list|,
name|segmentInfos
argument_list|,
name|infoStream
argument_list|,
name|this
argument_list|,
name|initialIndexExists
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deleter
operator|.
name|startingCommitDeleted
condition|)
block|{
comment|// Deletion policy deleted the "head" commit point.
comment|// We have to mark ourself as changed so that if we
comment|// are closed w/o any further changes we write a new
comment|// segments_N file.
name|changed
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"init: create="
operator|+
name|create
argument_list|)
expr_stmt|;
name|messageState
argument_list|()
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"init: hit exception on init; releasing write lock"
argument_list|)
expr_stmt|;
block|}
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|writeLock
argument_list|)
expr_stmt|;
name|writeLock
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Loads or returns the already loaded the global field number map for this {@link SegmentInfos}.    * If this {@link SegmentInfos} has no global field number map the returned instance is empty    */
DECL|method|getFieldNumberMap
specifier|private
name|FieldNumbers
name|getFieldNumberMap
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|FieldNumbers
name|map
init|=
operator|new
name|FieldNumbers
argument_list|()
decl_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|segmentInfos
control|)
block|{
for|for
control|(
name|FieldInfo
name|fi
range|:
name|SegmentReader
operator|.
name|readFieldInfos
argument_list|(
name|info
argument_list|)
control|)
block|{
name|map
operator|.
name|addOrGet
argument_list|(
name|fi
operator|.
name|name
argument_list|,
name|fi
operator|.
name|number
argument_list|,
name|fi
operator|.
name|getDocValuesType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
return|;
block|}
comment|/**    * Returns a {@link LiveIndexWriterConfig}, which can be used to query the IndexWriter    * current settings, as well as modify "live" ones.    */
DECL|method|getConfig
specifier|public
name|LiveIndexWriterConfig
name|getConfig
parameter_list|()
block|{
name|ensureOpen
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|config
return|;
block|}
DECL|method|messageState
specifier|private
name|void
name|messageState
parameter_list|()
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
operator|&&
name|didMessageState
operator|==
literal|false
condition|)
block|{
name|didMessageState
operator|=
literal|true
expr_stmt|;
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"\ndir="
operator|+
name|directory
operator|+
literal|"\n"
operator|+
literal|"index="
operator|+
name|segString
argument_list|()
operator|+
literal|"\n"
operator|+
literal|"version="
operator|+
name|Constants
operator|.
name|LUCENE_VERSION
operator|+
literal|"\n"
operator|+
name|config
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Gracefully shuts down this {@code IndexWriter} instance,    *  by writing any changes, waiting for any running    *  merges, committing, and closing.  If you don't want to    *  wait for merges, use {@link #shutdown(boolean)} instead.    *    *<p>If you called prepareCommit but failed to call    *  commit, this method will throw {@code    *  IllegalStateException} and the {@code IndexWriter}    *  will not be closed.    *    *<p>If this method throws any other    *  exception, the {@code IndexWriter} will be closed, but    *  changes may have been lost.    *    *<p><b>NOTE</b>: You must ensure no    *  other threads are still making changes at the same    *  time that this method is invoked.  */
DECL|method|shutdown
specifier|public
name|void
name|shutdown
parameter_list|()
throws|throws
name|IOException
block|{
name|shutdown
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** Gracefully shut down this {@code IndexWriter}    *  instance, with control over whether to wait for    *  merges.  See {@link #shutdown()}. */
DECL|method|shutdown
specifier|public
name|void
name|shutdown
parameter_list|(
name|boolean
name|waitForMerges
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pendingCommit
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"cannot shutdown: prepareCommit was already called with no corresponding call to commit"
argument_list|)
throw|;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"now flush at shutdown"
argument_list|)
expr_stmt|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|flush
argument_list|(
name|waitForMerges
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|finishMerges
argument_list|(
name|waitForMerges
argument_list|)
expr_stmt|;
name|commit
argument_list|()
expr_stmt|;
comment|// TODO: we could just call rollback, but ... it's nice
comment|// to catch IW bugs where after waitForMerges/commit we
comment|// still have running merges / uncommitted changes, or
comment|// tests that illegally leave threads indexing and then
comment|// try to use shutdown:
name|close
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
comment|// Be certain to close the index on any exception
try|try
block|{
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Suppress so we keep throwing original exception
block|}
block|}
block|}
block|}
comment|/**    * Closes all open resources and releases the write lock.    * If there are running merges or uncommitted    * changes:    *<ul>    *<li> If config.matchVersion>= LUCENE_5_0 then the    *        changes are silently discarded.    *<li> Otherwise, a RuntimeException is thrown to    *        indicate what was lost, but the IndexWriter is    *        still closed.    *</ul>    *    * Use {@link #shutdown} if you want to flush, commit, and    * wait for merges, before closing.    *     * @throws IOException if there is a low-level IO error    *   (the IndexWriter will still be closed)    * @throws RuntimeException if config.matchVersion<    *   LUCENE_5_0 and there were pending changes that were    *   lost (the IndexWriter will still be closed)    */
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|// If there are uncommitted changes, or still running
comment|// merges, we will in fact close, but we'll throw an
comment|// exception notifying the caller that they lost
comment|// changes, if IWC.matchVersion is< 5.0:
name|boolean
name|lostChanges
init|=
literal|false
decl_stmt|;
comment|// Only check for lost changes if the version earlier than 5.0:
if|if
condition|(
name|config
operator|.
name|getMatchVersion
argument_list|()
operator|.
name|onOrAfter
argument_list|(
name|Version
operator|.
name|LUCENE_5_0
argument_list|)
operator|==
literal|false
condition|)
block|{
name|lostChanges
operator|=
name|hasUncommittedChanges
argument_list|()
expr_stmt|;
if|if
condition|(
name|lostChanges
operator|==
literal|false
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|pendingMerges
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
name|lostChanges
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|runningMerges
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
name|lostChanges
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// As long as there are no pending changes and no
comment|// running merges, we just rollback to close:
name|rollback
argument_list|()
expr_stmt|;
if|if
condition|(
name|lostChanges
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"this writer is closed, but some pending changes or running merges were discarded; use shutdown to save pending changes and finish merges before closing"
argument_list|)
throw|;
block|}
block|}
comment|// Returns true if this thread should attempt to close, or
comment|// false if IndexWriter is now closed; else, waits until
comment|// another thread finishes closing
DECL|method|shouldClose
specifier|synchronized
specifier|private
name|boolean
name|shouldClose
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
if|if
condition|(
operator|!
name|closing
condition|)
block|{
name|closing
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// Another thread is presently trying to close;
comment|// wait until it finishes one way (closes
comment|// successfully) or another (fails to close)
name|doWait
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
comment|/** Returns the Directory used by this index. */
DECL|method|getDirectory
specifier|public
name|Directory
name|getDirectory
parameter_list|()
block|{
return|return
name|directory
return|;
block|}
comment|/** Returns the analyzer used by this index. */
DECL|method|getAnalyzer
specifier|public
name|Analyzer
name|getAnalyzer
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|analyzer
return|;
block|}
comment|/** Returns total number of docs in this index, including    *  docs not yet flushed (still in the RAM buffer),    *  not counting deletions.    *  @see #numDocs */
DECL|method|maxDoc
specifier|public
specifier|synchronized
name|int
name|maxDoc
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|docWriter
operator|.
name|getNumDocs
argument_list|()
operator|+
name|segmentInfos
operator|.
name|totalDocCount
argument_list|()
return|;
block|}
comment|/** Returns total number of docs in this index, including    *  docs not yet flushed (still in the RAM buffer), and    *  including deletions.<b>NOTE:</b> buffered deletions    *  are not counted.  If you really need these to be    *  counted you should call {@link #commit()} first.    *  @see #numDocs */
DECL|method|numDocs
specifier|public
specifier|synchronized
name|int
name|numDocs
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|int
name|count
init|=
name|docWriter
operator|.
name|getNumDocs
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|SegmentCommitInfo
name|info
range|:
name|segmentInfos
control|)
block|{
name|count
operator|+=
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|-
name|numDeletedDocs
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**    * Returns true if this index has deletions (including    * buffered deletions).  Note that this will return true    * if there are buffered Term/Query deletions, even if it    * turns out those buffered deletions don't match any    * documents.    */
DECL|method|hasDeletions
specifier|public
specifier|synchronized
name|boolean
name|hasDeletions
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|bufferedUpdatesStream
operator|.
name|any
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|docWriter
operator|.
name|anyDeletions
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|readerPool
operator|.
name|anyPendingDeletes
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
for|for
control|(
specifier|final
name|SegmentCommitInfo
name|info
range|:
name|segmentInfos
control|)
block|{
if|if
condition|(
name|info
operator|.
name|hasDeletions
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Adds a document to this index.    *    *<p> Note that if an Exception is hit (for example disk full)    * then the index will be consistent, but this document    * may not have been added.  Furthermore, it's possible    * the index will have one segment in non-compound format    * even when using compound files (when a merge has    * partially succeeded).</p>    *    *<p> This method periodically flushes pending documents    * to the Directory (see<a href="#flush">above</a>), and    * also periodically triggers segment merges in the index    * according to the {@link MergePolicy} in use.</p>    *    *<p>Merges temporarily consume space in the    * directory. The amount of space required is up to 1X the    * size of all segments being merged, when no    * readers/searchers are open against the index, and up to    * 2X the size of all segments being merged when    * readers/searchers are open against the index (see    * {@link #forceMerge(int)} for details). The sequence of    * primitive merge operations performed is governed by the    * merge policy.    *    *<p>Note that each term in the document can be no longer    * than {@link #MAX_TERM_LENGTH} in bytes, otherwise an    * IllegalArgumentException will be thrown.</p>    *    *<p>Note that it's possible to create an invalid Unicode    * string in java if a UTF16 surrogate pair is malformed.    * In this case, the invalid characters are silently    * replaced with the Unicode replacement character    * U+FFFD.</p>    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|addDocument
specifier|public
name|void
name|addDocument
parameter_list|(
name|IndexDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|addDocument
argument_list|(
name|doc
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds a document to this index, using the provided analyzer instead of the    * value of {@link #getAnalyzer()}.    *    *<p>See {@link #addDocument(IndexDocument)} for details on    * index and IndexWriter state after an Exception, and    * flushing/merging temporary free space requirements.</p>    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|addDocument
specifier|public
name|void
name|addDocument
parameter_list|(
name|IndexDocument
name|doc
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|IOException
block|{
name|updateDocument
argument_list|(
literal|null
argument_list|,
name|doc
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
comment|/**    * Atomically adds a block of documents with sequentially    * assigned document IDs, such that an external reader    * will see all or none of the documents.    *    *<p><b>WARNING</b>: the index does not currently record    * which documents were added as a block.  Today this is    * fine, because merging will preserve a block. The order of    * documents within a segment will be preserved, even when child    * documents within a block are deleted. Most search features    * (like result grouping and block joining) require you to    * mark documents; when these documents are deleted these    * search features will not work as expected. Obviously adding    * documents to an existing block will require you the reindex    * the entire block.    *    *<p>However it's possible that in the future Lucene may    * merge more aggressively re-order documents (for example,    * perhaps to obtain better index compression), in which case    * you may need to fully re-index your documents at that time.    *    *<p>See {@link #addDocument(IndexDocument)} for details on    * index and IndexWriter state after an Exception, and    * flushing/merging temporary free space requirements.</p>    *    *<p><b>NOTE</b>: tools that do offline splitting of an index    * (for example, IndexSplitter in contrib) or    * re-sorting of documents (for example, IndexSorter in    * contrib) are not aware of these atomically added documents    * and will likely break them up.  Use such tools at your    * own risk!    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    *    * @lucene.experimental    */
DECL|method|addDocuments
specifier|public
name|void
name|addDocuments
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|IndexDocument
argument_list|>
name|docs
parameter_list|)
throws|throws
name|IOException
block|{
name|addDocuments
argument_list|(
name|docs
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
comment|/**    * Atomically adds a block of documents, analyzed using the    * provided analyzer, with sequentially assigned document    * IDs, such that an external reader will see all or none    * of the documents.     *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    *    * @lucene.experimental    */
DECL|method|addDocuments
specifier|public
name|void
name|addDocuments
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|IndexDocument
argument_list|>
name|docs
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|IOException
block|{
name|updateDocuments
argument_list|(
literal|null
argument_list|,
name|docs
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
comment|/**    * Atomically deletes documents matching the provided    * delTerm and adds a block of documents with sequentially    * assigned document IDs, such that an external reader    * will see all or none of the documents.     *    * See {@link #addDocuments(Iterable)}.    *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    *    * @lucene.experimental    */
DECL|method|updateDocuments
specifier|public
name|void
name|updateDocuments
parameter_list|(
name|Term
name|delTerm
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|IndexDocument
argument_list|>
name|docs
parameter_list|)
throws|throws
name|IOException
block|{
name|updateDocuments
argument_list|(
name|delTerm
argument_list|,
name|docs
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
comment|/**    * Atomically deletes documents matching the provided    * delTerm and adds a block of documents, analyzed  using    * the provided analyzer, with sequentially    * assigned document IDs, such that an external reader    * will see all or none of the documents.     *    * See {@link #addDocuments(Iterable)}.    *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    *    * @lucene.experimental    */
DECL|method|updateDocuments
specifier|public
name|void
name|updateDocuments
parameter_list|(
name|Term
name|delTerm
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|IndexDocument
argument_list|>
name|docs
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
try|try
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|docWriter
operator|.
name|updateDocuments
argument_list|(
name|docs
argument_list|,
name|analyzer
argument_list|,
name|delTerm
argument_list|)
condition|)
block|{
name|processEvents
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"hit exception updating document"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"updateDocuments"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Expert: attempts to delete by document ID, as long as    *  the provided reader is a near-real-time reader (from {@link    *  DirectoryReader#open(IndexWriter,boolean)}).  If the    *  provided reader is an NRT reader obtained from this    *  writer, and its segment has not been merged away, then    *  the delete succeeds and this method returns true; else, it    *  returns false the caller must then separately delete by    *  Term or Query.    *    *<b>NOTE</b>: this method can only delete documents    *  visible to the currently open NRT reader.  If you need    *  to delete documents indexed after opening the NRT    *  reader you must use {@link #deleteDocuments(Term...)}). */
DECL|method|tryDeleteDocument
specifier|public
specifier|synchronized
name|boolean
name|tryDeleteDocument
parameter_list|(
name|IndexReader
name|readerIn
parameter_list|,
name|int
name|docID
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|AtomicReader
name|reader
decl_stmt|;
if|if
condition|(
name|readerIn
operator|instanceof
name|AtomicReader
condition|)
block|{
comment|// Reader is already atomic: use the incoming docID:
name|reader
operator|=
operator|(
name|AtomicReader
operator|)
name|readerIn
expr_stmt|;
block|}
else|else
block|{
comment|// Composite reader: lookup sub-reader and re-base docID:
name|List
argument_list|<
name|AtomicReaderContext
argument_list|>
name|leaves
init|=
name|readerIn
operator|.
name|leaves
argument_list|()
decl_stmt|;
name|int
name|subIndex
init|=
name|ReaderUtil
operator|.
name|subIndex
argument_list|(
name|docID
argument_list|,
name|leaves
argument_list|)
decl_stmt|;
name|reader
operator|=
name|leaves
operator|.
name|get
argument_list|(
name|subIndex
argument_list|)
operator|.
name|reader
argument_list|()
expr_stmt|;
name|docID
operator|-=
name|leaves
operator|.
name|get
argument_list|(
name|subIndex
argument_list|)
operator|.
name|docBase
expr_stmt|;
assert|assert
name|docID
operator|>=
literal|0
assert|;
assert|assert
name|docID
operator|<
name|reader
operator|.
name|maxDoc
argument_list|()
assert|;
block|}
if|if
condition|(
operator|!
operator|(
name|reader
operator|instanceof
name|SegmentReader
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"the reader must be a SegmentReader or composite reader containing only SegmentReaders"
argument_list|)
throw|;
block|}
specifier|final
name|SegmentCommitInfo
name|info
init|=
operator|(
operator|(
name|SegmentReader
operator|)
name|reader
operator|)
operator|.
name|getSegmentInfo
argument_list|()
decl_stmt|;
comment|// TODO: this is a slow linear search, but, number of
comment|// segments should be contained unless something is
comment|// seriously wrong w/ the index, so it should be a minor
comment|// cost:
if|if
condition|(
name|segmentInfos
operator|.
name|indexOf
argument_list|(
name|info
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|ReadersAndUpdates
name|rld
init|=
name|readerPool
operator|.
name|get
argument_list|(
name|info
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|rld
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|bufferedUpdatesStream
init|)
block|{
name|rld
operator|.
name|initWritableLiveDocs
argument_list|()
expr_stmt|;
if|if
condition|(
name|rld
operator|.
name|delete
argument_list|(
name|docID
argument_list|)
condition|)
block|{
specifier|final
name|int
name|fullDelCount
init|=
name|rld
operator|.
name|info
operator|.
name|getDelCount
argument_list|()
operator|+
name|rld
operator|.
name|getPendingDeleteCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|fullDelCount
operator|==
name|rld
operator|.
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
condition|)
block|{
comment|// If a merge has already registered for this
comment|// segment, we leave it in the readerPool; the
comment|// merge will skip merging it and will then drop
comment|// it once it's done:
if|if
condition|(
operator|!
name|mergingSegments
operator|.
name|contains
argument_list|(
name|rld
operator|.
name|info
argument_list|)
condition|)
block|{
name|segmentInfos
operator|.
name|remove
argument_list|(
name|rld
operator|.
name|info
argument_list|)
expr_stmt|;
name|readerPool
operator|.
name|drop
argument_list|(
name|rld
operator|.
name|info
argument_list|)
expr_stmt|;
name|checkpoint
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Must bump changeCount so if no other changes
comment|// happened, we still commit this change:
name|changed
argument_list|()
expr_stmt|;
block|}
comment|//System.out.println("  yes " + info.info.name + " " + docID);
return|return
literal|true
return|;
block|}
block|}
else|else
block|{
comment|//System.out.println("  no rld " + info.info.name + " " + docID);
block|}
block|}
else|else
block|{
comment|//System.out.println("  no seg " + info.info.name + " " + docID);
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Deletes the document(s) containing any of the    * terms. All given deletes are applied and flushed atomically    * at the same time.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @param terms array of terms to identify the documents    * to be deleted    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|deleteDocuments
specifier|public
name|void
name|deleteDocuments
parameter_list|(
name|Term
modifier|...
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|docWriter
operator|.
name|deleteTerms
argument_list|(
name|terms
argument_list|)
condition|)
block|{
name|processEvents
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"deleteDocuments(Term..)"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Deletes the document(s) matching any of the provided queries.    * All given deletes are applied and flushed atomically at the same time.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @param queries array of queries to identify the documents    * to be deleted    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|deleteDocuments
specifier|public
name|void
name|deleteDocuments
parameter_list|(
name|Query
modifier|...
name|queries
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|docWriter
operator|.
name|deleteQueries
argument_list|(
name|queries
argument_list|)
condition|)
block|{
name|processEvents
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"deleteDocuments(Query..)"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Updates a document by first deleting the document(s)    * containing<code>term</code> and then adding the new    * document.  The delete and then add are atomic as seen    * by a reader on the same index (flush may happen only after    * the add).    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @param term the term to identify the document(s) to be    * deleted    * @param doc the document to be added    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|updateDocument
specifier|public
name|void
name|updateDocument
parameter_list|(
name|Term
name|term
parameter_list|,
name|IndexDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|updateDocument
argument_list|(
name|term
argument_list|,
name|doc
argument_list|,
name|analyzer
argument_list|)
expr_stmt|;
block|}
comment|/**    * Updates a document by first deleting the document(s)    * containing<code>term</code> and then adding the new    * document.  The delete and then add are atomic as seen    * by a reader on the same index (flush may happen only after    * the add).    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @param term the term to identify the document(s) to be    * deleted    * @param doc the document to be added    * @param analyzer the analyzer to use when analyzing the document    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|updateDocument
specifier|public
name|void
name|updateDocument
parameter_list|(
name|Term
name|term
parameter_list|,
name|IndexDocument
name|doc
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
try|try
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|docWriter
operator|.
name|updateDocument
argument_list|(
name|doc
argument_list|,
name|analyzer
argument_list|,
name|term
argument_list|)
condition|)
block|{
name|processEvents
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"hit exception updating document"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"updateDocument"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Updates a document's {@link NumericDocValues} for<code>field</code> to the    * given<code>value</code>. You can only update fields that already exist in    * the index, not add new fields through this method.    *     *<p>    *<b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately    * close the writer. See<a href="#OOME">above</a> for details.    *</p>    *     * @param term    *          the term to identify the document(s) to be updated    * @param field    *          field name of the {@link NumericDocValues} field    * @param value    *          new value for the field    * @throws CorruptIndexException    *           if the index is corrupt    * @throws IOException    *           if there is a low-level IO error    */
DECL|method|updateNumericDocValue
specifier|public
name|void
name|updateNumericDocValue
parameter_list|(
name|Term
name|term
parameter_list|,
name|String
name|field
parameter_list|,
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|globalFieldNumberMap
operator|.
name|contains
argument_list|(
name|field
argument_list|,
name|DocValuesType
operator|.
name|NUMERIC
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"can only update existing numeric-docvalues fields!"
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|docWriter
operator|.
name|updateDocValues
argument_list|(
operator|new
name|NumericDocValuesUpdate
argument_list|(
name|term
argument_list|,
name|field
argument_list|,
name|value
argument_list|)
argument_list|)
condition|)
block|{
name|processEvents
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"updateNumericDocValue"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Updates a document's {@link BinaryDocValues} for<code>field</code> to the    * given<code>value</code>. You can only update fields that already exist in    * the index, not add new fields through this method.    *     *<p>    *<b>NOTE:</b> this method currently replaces the existing value of all    * affected documents with the new value.    *     *<p>    *<b>NOTE:</b> if this method hits an OutOfMemoryError you should immediately    * close the writer. See<a href="#OOME">above</a> for details.    *</p>    *     * @param term    *          the term to identify the document(s) to be updated    * @param field    *          field name of the {@link BinaryDocValues} field    * @param value    *          new value for the field    * @throws CorruptIndexException    *           if the index is corrupt    * @throws IOException    *           if there is a low-level IO error    */
DECL|method|updateBinaryDocValue
specifier|public
name|void
name|updateBinaryDocValue
parameter_list|(
name|Term
name|term
parameter_list|,
name|String
name|field
parameter_list|,
name|BytesRef
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot update a field to a null value: "
operator|+
name|field
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|globalFieldNumberMap
operator|.
name|contains
argument_list|(
name|field
argument_list|,
name|DocValuesType
operator|.
name|BINARY
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"can only update existing binary-docvalues fields!"
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|docWriter
operator|.
name|updateDocValues
argument_list|(
operator|new
name|BinaryDocValuesUpdate
argument_list|(
name|term
argument_list|,
name|field
argument_list|,
name|value
argument_list|)
argument_list|)
condition|)
block|{
name|processEvents
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"updateBinaryDocValue"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Updates documents' DocValues fields to the given values. Each field update    * is applied to the set of documents that are associated with the    * {@link Term} to the same value. All updates are atomically applied and    * flushed together.    *     *<p>    *<b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately    * close the writer. See<a href="#OOME">above</a> for details.    *</p>    *     * @param updates    *          the updates to apply    * @throws CorruptIndexException    *           if the index is corrupt    * @throws IOException    *           if there is a low-level IO error    */
DECL|method|updateDocValues
specifier|public
name|void
name|updateDocValues
parameter_list|(
name|Term
name|term
parameter_list|,
name|Field
modifier|...
name|updates
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|DocValuesUpdate
index|[]
name|dvUpdates
init|=
operator|new
name|DocValuesUpdate
index|[
name|updates
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|updates
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Field
name|f
init|=
name|updates
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|DocValuesType
name|dvType
init|=
name|f
operator|.
name|fieldType
argument_list|()
operator|.
name|docValueType
argument_list|()
decl_stmt|;
if|if
condition|(
name|dvType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"can only update NUMERIC or BINARY fields! field="
operator|+
name|f
operator|.
name|name
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|globalFieldNumberMap
operator|.
name|contains
argument_list|(
name|f
operator|.
name|name
argument_list|()
argument_list|,
name|dvType
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"can only update existing docvalues fields! field="
operator|+
name|f
operator|.
name|name
argument_list|()
operator|+
literal|", type="
operator|+
name|dvType
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|dvType
condition|)
block|{
case|case
name|NUMERIC
case|:
name|dvUpdates
index|[
name|i
index|]
operator|=
operator|new
name|NumericDocValuesUpdate
argument_list|(
name|term
argument_list|,
name|f
operator|.
name|name
argument_list|()
argument_list|,
operator|(
name|Long
operator|)
name|f
operator|.
name|numericValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINARY
case|:
name|dvUpdates
index|[
name|i
index|]
operator|=
operator|new
name|BinaryDocValuesUpdate
argument_list|(
name|term
argument_list|,
name|f
operator|.
name|name
argument_list|()
argument_list|,
name|f
operator|.
name|binaryValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"can only update NUMERIC or BINARY fields: field="
operator|+
name|f
operator|.
name|name
argument_list|()
operator|+
literal|", type="
operator|+
name|dvType
argument_list|)
throw|;
block|}
block|}
try|try
block|{
if|if
condition|(
name|docWriter
operator|.
name|updateDocValues
argument_list|(
name|dvUpdates
argument_list|)
condition|)
block|{
name|processEvents
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"updateDocValues"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// for test purpose
DECL|method|getSegmentCount
specifier|final
specifier|synchronized
name|int
name|getSegmentCount
parameter_list|()
block|{
return|return
name|segmentInfos
operator|.
name|size
argument_list|()
return|;
block|}
comment|// for test purpose
DECL|method|getNumBufferedDocuments
specifier|final
specifier|synchronized
name|int
name|getNumBufferedDocuments
parameter_list|()
block|{
return|return
name|docWriter
operator|.
name|getNumDocs
argument_list|()
return|;
block|}
comment|// for test purpose
DECL|method|getIndexFileNames
specifier|final
specifier|synchronized
name|Collection
argument_list|<
name|String
argument_list|>
name|getIndexFileNames
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|segmentInfos
operator|.
name|files
argument_list|(
name|directory
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|// for test purpose
DECL|method|getDocCount
specifier|final
specifier|synchronized
name|int
name|getDocCount
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|segmentInfos
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|segmentInfos
operator|.
name|info
argument_list|(
name|i
argument_list|)
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|// for test purpose
DECL|method|getFlushCount
specifier|final
name|int
name|getFlushCount
parameter_list|()
block|{
return|return
name|flushCount
operator|.
name|get
argument_list|()
return|;
block|}
comment|// for test purpose
DECL|method|getFlushDeletesCount
specifier|final
name|int
name|getFlushDeletesCount
parameter_list|()
block|{
return|return
name|flushDeletesCount
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|newSegmentName
specifier|final
name|String
name|newSegmentName
parameter_list|()
block|{
comment|// Cannot synchronize on IndexWriter because that causes
comment|// deadlock
synchronized|synchronized
init|(
name|segmentInfos
init|)
block|{
comment|// Important to increment changeCount so that the
comment|// segmentInfos is written on close.  Otherwise we
comment|// could close, re-open and re-return the same segment
comment|// name that was previously returned which can cause
comment|// problems at least with ConcurrentMergeScheduler.
name|changeCount
operator|++
expr_stmt|;
name|segmentInfos
operator|.
name|changed
argument_list|()
expr_stmt|;
return|return
literal|"_"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|segmentInfos
operator|.
name|counter
operator|++
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
return|;
block|}
block|}
comment|/** If non-null, information about merges will be printed to this.    */
DECL|field|infoStream
specifier|final
name|InfoStream
name|infoStream
decl_stmt|;
comment|/**    * Forces merge policy to merge segments until there are<=    * maxNumSegments.  The actual merges to be    * executed are determined by the {@link MergePolicy}.    *    *<p>This is a horribly costly operation, especially when    * you pass a small {@code maxNumSegments}; usually you    * should only call this if the index is static (will no    * longer be changed).</p>    *    *<p>Note that this requires up to 2X the index size free    * space in your Directory (3X if you're using compound    * file format).  For example, if your index size is 10 MB    * then you need up to 20 MB free for this to complete (30    * MB if you're using compound file format).  Also,    * it's best to call {@link #commit()} afterwards,    * to allow IndexWriter to free up disk space.</p>    *    *<p>If some but not all readers re-open while merging    * is underway, this will cause> 2X temporary    * space to be consumed as those new readers will then    * hold open the temporary segments at that time.  It is    * best not to re-open readers while merging is running.</p>    *    *<p>The actual temporary usage could be much less than    * these figures (it depends on many factors).</p>    *    *<p>In general, once this completes, the total size of the    * index will be less than the size of the starting index.    * It could be quite a bit smaller (if there were many    * pending deletes) or just slightly smaller.</p>    *    *<p>If an Exception is hit, for example    * due to disk full, the index will not be corrupted and no    * documents will be lost.  However, it may have    * been partially merged (some segments were merged but    * not all), and it's possible that one of the segments in    * the index will be in non-compound format even when    * using compound file format.  This will occur when the    * Exception is hit during conversion of the segment into    * compound format.</p>    *    *<p>This call will merge those segments present in    * the index when the call started.  If other threads are    * still adding documents and flushing segments, those    * newly created segments will not be merged unless you    * call forceMerge again.</p>    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    *<p><b>NOTE</b>: if you call {@link #abortMerges}, which    * aborts all running merges, then any thread still    * running this method might hit a {@link    * MergePolicy.MergeAbortedException}.    *    * @param maxNumSegments maximum number of segments left    * in the index after merging finishes    *     * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    * @see MergePolicy#findMerges    *   */
DECL|method|forceMerge
specifier|public
name|void
name|forceMerge
parameter_list|(
name|int
name|maxNumSegments
parameter_list|)
throws|throws
name|IOException
block|{
name|forceMerge
argument_list|(
name|maxNumSegments
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** Just like {@link #forceMerge(int)}, except you can    *  specify whether the call should block until    *  all merging completes.  This is only meaningful with a    *  {@link MergeScheduler} that is able to run merges in    *  background threads.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    *  you should immediately close the writer.  See<a    *  href="#OOME">above</a> for details.</p>    */
DECL|method|forceMerge
specifier|public
name|void
name|forceMerge
parameter_list|(
name|int
name|maxNumSegments
parameter_list|,
name|boolean
name|doWait
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|maxNumSegments
operator|<
literal|1
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxNumSegments must be>= 1; got "
operator|+
name|maxNumSegments
argument_list|)
throw|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"forceMerge: index now "
operator|+
name|segString
argument_list|()
argument_list|)
expr_stmt|;
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"now flush at forceMerge"
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|resetMergeExceptions
argument_list|()
expr_stmt|;
name|segmentsToMerge
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|segmentInfos
control|)
block|{
name|segmentsToMerge
operator|.
name|put
argument_list|(
name|info
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|mergeMaxNumSegments
operator|=
name|maxNumSegments
expr_stmt|;
comment|// Now mark all pending& running merges for forced
comment|// merge:
for|for
control|(
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
range|:
name|pendingMerges
control|)
block|{
name|merge
operator|.
name|maxNumSegments
operator|=
name|maxNumSegments
expr_stmt|;
name|segmentsToMerge
operator|.
name|put
argument_list|(
name|merge
operator|.
name|info
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
range|:
name|runningMerges
control|)
block|{
name|merge
operator|.
name|maxNumSegments
operator|=
name|maxNumSegments
expr_stmt|;
name|segmentsToMerge
operator|.
name|put
argument_list|(
name|merge
operator|.
name|info
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
name|maybeMerge
argument_list|(
name|MergeTrigger
operator|.
name|EXPLICIT
argument_list|,
name|maxNumSegments
argument_list|)
expr_stmt|;
if|if
condition|(
name|doWait
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|hitOOM
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"this writer hit an OutOfMemoryError; cannot complete forceMerge"
argument_list|)
throw|;
block|}
if|if
condition|(
name|mergeExceptions
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Forward any exceptions in background merge
comment|// threads to the current thread:
specifier|final
name|int
name|size
init|=
name|mergeExceptions
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
init|=
name|mergeExceptions
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|merge
operator|.
name|maxNumSegments
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"background merge hit exception: "
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|directory
argument_list|)
argument_list|,
name|merge
operator|.
name|getException
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|maxNumSegmentsMergesPending
argument_list|()
condition|)
name|doWait
argument_list|()
expr_stmt|;
else|else
break|break;
block|}
block|}
comment|// If close is called while we are still
comment|// running, throw an exception so the calling
comment|// thread will know merging did not
comment|// complete
name|ensureOpen
argument_list|()
expr_stmt|;
block|}
comment|// NOTE: in the ConcurrentMergeScheduler case, when
comment|// doWait is false, we can return immediately while
comment|// background threads accomplish the merging
block|}
comment|/** Returns true if any merges in pendingMerges or    *  runningMerges are maxNumSegments merges. */
DECL|method|maxNumSegmentsMergesPending
specifier|private
specifier|synchronized
name|boolean
name|maxNumSegmentsMergesPending
parameter_list|()
block|{
for|for
control|(
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
range|:
name|pendingMerges
control|)
block|{
if|if
condition|(
name|merge
operator|.
name|maxNumSegments
operator|!=
operator|-
literal|1
condition|)
return|return
literal|true
return|;
block|}
for|for
control|(
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
range|:
name|runningMerges
control|)
block|{
if|if
condition|(
name|merge
operator|.
name|maxNumSegments
operator|!=
operator|-
literal|1
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Just like {@link #forceMergeDeletes()}, except you can    *  specify whether the call should block until the    *  operation completes.  This is only meaningful with a    *  {@link MergeScheduler} that is able to run merges in    *  background threads.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    *<p><b>NOTE</b>: if you call {@link #abortMerges}, which    * aborts all running merges, then any thread still    * running this method might hit a {@link    * MergePolicy.MergeAbortedException}. */
DECL|method|forceMergeDeletes
specifier|public
name|void
name|forceMergeDeletes
parameter_list|(
name|boolean
name|doWait
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|flush
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"forceMergeDeletes: index now "
operator|+
name|segString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|MergePolicy
operator|.
name|MergeSpecification
name|spec
decl_stmt|;
name|boolean
name|newMergesFound
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|spec
operator|=
name|mergePolicy
operator|.
name|findForcedDeletesMerges
argument_list|(
name|segmentInfos
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|newMergesFound
operator|=
name|spec
operator|!=
literal|null
expr_stmt|;
if|if
condition|(
name|newMergesFound
condition|)
block|{
specifier|final
name|int
name|numMerges
init|=
name|spec
operator|.
name|merges
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numMerges
condition|;
name|i
operator|++
control|)
name|registerMerge
argument_list|(
name|spec
operator|.
name|merges
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|mergeScheduler
operator|.
name|merge
argument_list|(
name|this
argument_list|,
name|MergeTrigger
operator|.
name|EXPLICIT
argument_list|,
name|newMergesFound
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
literal|null
operator|&&
name|doWait
condition|)
block|{
specifier|final
name|int
name|numMerges
init|=
name|spec
operator|.
name|merges
operator|.
name|size
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|boolean
name|running
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|running
condition|)
block|{
if|if
condition|(
name|hitOOM
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes"
argument_list|)
throw|;
block|}
comment|// Check each merge that MergePolicy asked us to
comment|// do, to see if any of them are still running and
comment|// if any of them have hit an exception.
name|running
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numMerges
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
init|=
name|spec
operator|.
name|merges
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|pendingMerges
operator|.
name|contains
argument_list|(
name|merge
argument_list|)
operator|||
name|runningMerges
operator|.
name|contains
argument_list|(
name|merge
argument_list|)
condition|)
block|{
name|running
operator|=
literal|true
expr_stmt|;
block|}
name|Throwable
name|t
init|=
name|merge
operator|.
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"background merge hit exception: "
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|directory
argument_list|)
argument_list|,
name|t
argument_list|)
throw|;
block|}
block|}
comment|// If any of our merges are still running, wait:
if|if
condition|(
name|running
condition|)
name|doWait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// NOTE: in the ConcurrentMergeScheduler case, when
comment|// doWait is false, we can return immediately while
comment|// background threads accomplish the merging
block|}
comment|/**    *  Forces merging of all segments that have deleted    *  documents.  The actual merges to be executed are    *  determined by the {@link MergePolicy}.  For example,    *  the default {@link TieredMergePolicy} will only    *  pick a segment if the percentage of    *  deleted docs is over 10%.    *    *<p>This is often a horribly costly operation; rarely    *  is it warranted.</p>    *    *<p>To see how    *  many deletions you have pending in your index, call    *  {@link IndexReader#numDeletedDocs}.</p>    *    *<p><b>NOTE</b>: this method first flushes a new    *  segment (if there are indexed documents), and applies    *  all buffered deletes.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    *  you should immediately close the writer.  See<a    *  href="#OOME">above</a> for details.</p>    */
DECL|method|forceMergeDeletes
specifier|public
name|void
name|forceMergeDeletes
parameter_list|()
throws|throws
name|IOException
block|{
name|forceMergeDeletes
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expert: asks the mergePolicy whether any merges are    * necessary now and if so, runs the requested merges and    * then iterate (test again if merges are needed) until no    * more merges are returned by the mergePolicy.    *    * Explicit calls to maybeMerge() are usually not    * necessary. The most common case is when merge policy    * parameters have changed.    *     * This method will call the {@link MergePolicy} with    * {@link MergeTrigger#EXPLICIT}.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    */
DECL|method|maybeMerge
specifier|public
specifier|final
name|void
name|maybeMerge
parameter_list|()
throws|throws
name|IOException
block|{
name|maybeMerge
argument_list|(
name|MergeTrigger
operator|.
name|EXPLICIT
argument_list|,
name|UNBOUNDED_MAX_MERGE_SEGMENTS
argument_list|)
expr_stmt|;
block|}
DECL|method|maybeMerge
specifier|private
specifier|final
name|void
name|maybeMerge
parameter_list|(
name|MergeTrigger
name|trigger
parameter_list|,
name|int
name|maxNumSegments
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|boolean
name|newMergesFound
init|=
name|updatePendingMerges
argument_list|(
name|trigger
argument_list|,
name|maxNumSegments
argument_list|)
decl_stmt|;
name|mergeScheduler
operator|.
name|merge
argument_list|(
name|this
argument_list|,
name|trigger
argument_list|,
name|newMergesFound
argument_list|)
expr_stmt|;
block|}
DECL|method|updatePendingMerges
specifier|private
specifier|synchronized
name|boolean
name|updatePendingMerges
parameter_list|(
name|MergeTrigger
name|trigger
parameter_list|,
name|int
name|maxNumSegments
parameter_list|)
throws|throws
name|IOException
block|{
comment|// In case infoStream was disabled on init, but then enabled at some
comment|// point, try again to log the config here:
name|messageState
argument_list|()
expr_stmt|;
assert|assert
name|maxNumSegments
operator|==
operator|-
literal|1
operator|||
name|maxNumSegments
operator|>
literal|0
assert|;
assert|assert
name|trigger
operator|!=
literal|null
assert|;
if|if
condition|(
name|stopMerges
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Do not start new merges if we've hit OOME
if|if
condition|(
name|hitOOM
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|newMergesFound
init|=
literal|false
decl_stmt|;
specifier|final
name|MergePolicy
operator|.
name|MergeSpecification
name|spec
decl_stmt|;
if|if
condition|(
name|maxNumSegments
operator|!=
name|UNBOUNDED_MAX_MERGE_SEGMENTS
condition|)
block|{
assert|assert
name|trigger
operator|==
name|MergeTrigger
operator|.
name|EXPLICIT
operator|||
name|trigger
operator|==
name|MergeTrigger
operator|.
name|MERGE_FINISHED
operator|:
literal|"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: "
operator|+
name|trigger
operator|.
name|name
argument_list|()
assert|;
name|spec
operator|=
name|mergePolicy
operator|.
name|findForcedMerges
argument_list|(
name|segmentInfos
argument_list|,
name|maxNumSegments
argument_list|,
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|segmentsToMerge
argument_list|)
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|newMergesFound
operator|=
name|spec
operator|!=
literal|null
expr_stmt|;
if|if
condition|(
name|newMergesFound
condition|)
block|{
specifier|final
name|int
name|numMerges
init|=
name|spec
operator|.
name|merges
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numMerges
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
init|=
name|spec
operator|.
name|merges
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|merge
operator|.
name|maxNumSegments
operator|=
name|maxNumSegments
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|spec
operator|=
name|mergePolicy
operator|.
name|findMerges
argument_list|(
name|trigger
argument_list|,
name|segmentInfos
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|newMergesFound
operator|=
name|spec
operator|!=
literal|null
expr_stmt|;
if|if
condition|(
name|newMergesFound
condition|)
block|{
specifier|final
name|int
name|numMerges
init|=
name|spec
operator|.
name|merges
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numMerges
condition|;
name|i
operator|++
control|)
block|{
name|registerMerge
argument_list|(
name|spec
operator|.
name|merges
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|newMergesFound
return|;
block|}
comment|/** Expert: to be used by a {@link MergePolicy} to avoid    *  selecting merges for segments already being merged.    *  The returned collection is not cloned, and thus is    *  only safe to access if you hold IndexWriter's lock    *  (which you do when IndexWriter invokes the    *  MergePolicy).    *    *<p>Do not alter the returned collection! */
DECL|method|getMergingSegments
specifier|public
specifier|synchronized
name|Collection
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|getMergingSegments
parameter_list|()
block|{
return|return
name|mergingSegments
return|;
block|}
comment|/**    * Expert: the {@link MergeScheduler} calls this method to retrieve the next    * merge requested by the MergePolicy    *     * @lucene.experimental    */
DECL|method|getNextMerge
specifier|public
specifier|synchronized
name|MergePolicy
operator|.
name|OneMerge
name|getNextMerge
parameter_list|()
block|{
if|if
condition|(
name|pendingMerges
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
comment|// Advance the merge from pending to running
name|MergePolicy
operator|.
name|OneMerge
name|merge
init|=
name|pendingMerges
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
name|runningMerges
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
return|return
name|merge
return|;
block|}
block|}
comment|/**    * Expert: returns true if there are merges waiting to be scheduled.    *     * @lucene.experimental    */
DECL|method|hasPendingMerges
specifier|public
specifier|synchronized
name|boolean
name|hasPendingMerges
parameter_list|()
block|{
return|return
name|pendingMerges
operator|.
name|size
argument_list|()
operator|!=
literal|0
return|;
block|}
comment|/**    * Close the<code>IndexWriter</code> without committing    * any changes that have occurred since the last commit    * (or since it was opened, if commit hasn't been called).    * This removes any temporary files that had been created,    * after which the state of the index will be the same as    * it was when commit() was last called or when this    * writer was first opened.  This also clears a previous    * call to {@link #prepareCommit}.    * @throws IOException if there is a low-level IO error    */
annotation|@
name|Override
DECL|method|rollback
specifier|public
name|void
name|rollback
parameter_list|()
throws|throws
name|IOException
block|{
comment|// don't call ensureOpen here: this acts like "close()" in closeable.
comment|// Ensure that only one thread actually gets to do the
comment|// closing, and make sure no commit is also in progress:
synchronized|synchronized
init|(
name|commitLock
init|)
block|{
if|if
condition|(
name|shouldClose
argument_list|()
condition|)
block|{
name|rollbackInternal
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|rollbackInternal
specifier|private
name|void
name|rollbackInternal
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"rollback"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|finishMerges
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|stopMerges
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"rollback: done finish merges"
argument_list|)
expr_stmt|;
block|}
comment|// Must pre-close these two, in case they increment
comment|// changeCount so that we can then set it to false
comment|// before calling closeInternal
name|mergePolicy
operator|.
name|close
argument_list|()
expr_stmt|;
name|mergeScheduler
operator|.
name|close
argument_list|()
expr_stmt|;
name|bufferedUpdatesStream
operator|.
name|clear
argument_list|()
expr_stmt|;
name|docWriter
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// mark it as closed first to prevent subsequent indexing actions/flushes
name|docWriter
operator|.
name|abort
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// don't sync on IW here
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|pendingCommit
operator|!=
literal|null
condition|)
block|{
name|pendingCommit
operator|.
name|rollbackCommit
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|decRef
argument_list|(
name|pendingCommit
argument_list|)
expr_stmt|;
name|pendingCommit
operator|=
literal|null
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|// Don't bother saving any changes in our segmentInfos
name|readerPool
operator|.
name|dropAll
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Keep the same segmentInfos instance but replace all
comment|// of its SegmentInfo instances.  This is so the next
comment|// attempt to commit using this instance of IndexWriter
comment|// will always write to a new generation ("write
comment|// once").
name|segmentInfos
operator|.
name|rollbackSegmentInfos
argument_list|(
name|rollbackSegments
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"rollback: infos="
operator|+
name|segString
argument_list|(
name|segmentInfos
argument_list|)
argument_list|)
expr_stmt|;
block|}
assert|assert
name|testPoint
argument_list|(
literal|"rollback before checkpoint"
argument_list|)
assert|;
comment|// Ask deleter to locate unreferenced files& remove
comment|// them:
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|refresh
argument_list|()
expr_stmt|;
name|lastCommitChangeCount
operator|=
name|changeCount
expr_stmt|;
name|deleter
operator|.
name|refresh
argument_list|()
expr_stmt|;
name|deleter
operator|.
name|close
argument_list|()
expr_stmt|;
name|IOUtils
operator|.
name|close
argument_list|(
name|writeLock
argument_list|)
expr_stmt|;
comment|// release write lock
name|writeLock
operator|=
literal|null
expr_stmt|;
assert|assert
name|docWriter
operator|.
name|perThreadPool
operator|.
name|numDeactivatedThreadStates
argument_list|()
operator|==
name|docWriter
operator|.
name|perThreadPool
operator|.
name|getMaxThreadStates
argument_list|()
operator|:
literal|""
operator|+
name|docWriter
operator|.
name|perThreadPool
operator|.
name|numDeactivatedThreadStates
argument_list|()
operator|+
literal|" "
operator|+
name|docWriter
operator|.
name|perThreadPool
operator|.
name|getMaxThreadStates
argument_list|()
assert|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"rollbackInternal"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// Must not hold IW's lock while closing
comment|// mergePolicy/Scheduler: this can lead to deadlock,
comment|// e.g. TestIW.testThreadInterruptDeadlock
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|mergePolicy
argument_list|,
name|mergeScheduler
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// we tried to be nice about it: do the minimum
comment|// don't leak a segments_N file if there is a pending commit
if|if
condition|(
name|pendingCommit
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|pendingCommit
operator|.
name|rollbackCommit
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|decRef
argument_list|(
name|pendingCommit
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{}
block|}
comment|// close all the closeables we can (but important is readerPool and writeLock to prevent leaks)
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|readerPool
argument_list|,
name|deleter
argument_list|,
name|writeLock
argument_list|)
expr_stmt|;
name|writeLock
operator|=
literal|null
expr_stmt|;
block|}
name|closed
operator|=
literal|true
expr_stmt|;
name|closing
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Delete all documents in the index.    *     *<p>    * This method will drop all buffered documents and will remove all segments    * from the index. This change will not be visible until a {@link #commit()}    * has been called. This method can be rolled back using {@link #rollback()}.    *</p>    *     *<p>    * NOTE: this method is much faster than using deleteDocuments( new    * MatchAllDocsQuery() ). Yet, this method also has different semantics    * compared to {@link #deleteDocuments(Query...)} since internal    * data-structures are cleared as well as all segment information is    * forcefully dropped anti-viral semantics like omitting norms are reset or    * doc value types are cleared. Essentially a call to {@link #deleteAll()} is    * equivalent to creating a new {@link IndexWriter} with    * {@link OpenMode#CREATE} which a delete query only marks documents as    * deleted.    *</p>    *     *<p>    * NOTE: this method will forcefully abort all merges in progress. If other    * threads are running {@link #forceMerge}, {@link #addIndexes(IndexReader[])}    * or {@link #forceMergeDeletes} methods, they may receive    * {@link MergePolicy.MergeAbortedException}s.    */
DECL|method|deleteAll
specifier|public
name|void
name|deleteAll
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
comment|// Remove any buffered docs
name|boolean
name|success
init|=
literal|false
decl_stmt|;
comment|/* hold the full flush lock to prevent concurrency commits / NRT reopens to      * get in our way and do unnecessary work. -- if we don't lock this here we might      * get in trouble if */
synchronized|synchronized
init|(
name|fullFlushLock
init|)
block|{
comment|/*          * We first abort and trash everything we have in-memory          * and keep the thread-states locked, the lockAndAbortAll operation          * also guarantees "point in time semantics" ie. the checkpoint that we need in terms          * of logical happens-before relationship in the DW. So we do          * abort all in memory structures           * We also drop global field numbering before during abort to make          * sure it's just like a fresh index.          */
try|try
block|{
name|docWriter
operator|.
name|lockAndAbortAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|processEvents
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
comment|// Abort any running merges
name|finishMerges
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Remove all segments
name|segmentInfos
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Ask deleter to locate unreferenced files& remove them:
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|/* don't refresh the deleter here since there might              * be concurrent indexing requests coming in opening              * files on the directory after we called DW#abort()              * if we do so these indexing requests might hit FNF exceptions.              * We will remove the files incrementally as we go...              */
comment|// Don't bother saving any changes in our segmentInfos
name|readerPool
operator|.
name|dropAll
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Mark that the index has changed
operator|++
name|changeCount
expr_stmt|;
name|segmentInfos
operator|.
name|changed
argument_list|()
expr_stmt|;
name|globalFieldNumberMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"deleteAll"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"hit exception during deleteAll"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
name|docWriter
operator|.
name|unlockAllAfterAbortAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Aborts running merges.  Be careful when using this    *  method: when you abort a long-running merge, you lose    *  a lot of work that must later be redone. */
DECL|method|abortMerges
specifier|public
name|void
name|abortMerges
parameter_list|()
block|{
name|finishMerges
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|finishMerges
specifier|private
specifier|synchronized
name|void
name|finishMerges
parameter_list|(
name|boolean
name|waitForMerges
parameter_list|)
block|{
if|if
condition|(
operator|!
name|waitForMerges
condition|)
block|{
name|stopMerges
operator|=
literal|true
expr_stmt|;
comment|// Abort all pending& running merges:
for|for
control|(
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
range|:
name|pendingMerges
control|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"now abort pending merge "
operator|+
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|merge
operator|.
name|abort
argument_list|()
expr_stmt|;
name|mergeFinish
argument_list|(
name|merge
argument_list|)
expr_stmt|;
block|}
name|pendingMerges
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
specifier|final
name|MergePolicy
operator|.
name|OneMerge
name|merge
range|:
name|runningMerges
control|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"now abort running merge "
operator|+
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|merge
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
comment|// These merges periodically check whether they have
comment|// been aborted, and stop if so.  We wait here to make
comment|// sure they all stop.  It should not take very long
comment|// because the merge threads periodically check if
comment|// they are aborted.
while|while
condition|(
name|runningMerges
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"now wait for "
operator|+
name|runningMerges
operator|.
name|size
argument_list|()
operator|+
literal|" running merge/s to abort"
argument_list|)
expr_stmt|;
block|}
name|doWait
argument_list|()
expr_stmt|;
block|}
name|stopMerges
operator|=
literal|false
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
assert|assert
literal|0
operator|==
name|mergingSegments
operator|.
name|size
argument_list|()
assert|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"all running merges have aborted"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// waitForMerges() will ensure any running addIndexes finishes.
comment|// It's fine if a new one attempts to start because from our
comment|// caller above the call will see that we are in the
comment|// process of closing, and will throw an
comment|// AlreadyClosedException.
name|waitForMerges
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Wait for any currently outstanding merges to finish.    *    *<p>It is guaranteed that any merges started prior to calling this method    *    will have completed once this method completes.</p>    */
DECL|method|waitForMerges
specifier|public
specifier|synchronized
name|void
name|waitForMerges
parameter_list|()
block|{
name|ensureOpen
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"waitForMerges"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|pendingMerges
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|||
name|runningMerges
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|doWait
argument_list|()
expr_stmt|;
block|}
comment|// sanity check
assert|assert
literal|0
operator|==
name|mergingSegments
operator|.
name|size
argument_list|()
assert|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"waitForMerges done"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Called whenever the SegmentInfos has been updated and    * the index files referenced exist (correctly) in the    * index directory.    */
DECL|method|checkpoint
specifier|synchronized
name|void
name|checkpoint
parameter_list|()
throws|throws
name|IOException
block|{
name|changed
argument_list|()
expr_stmt|;
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/** Checkpoints with IndexFileDeleter, so it's aware of    *  new files, and increments changeCount, so on    *  close/commit we will write a new segments file, but    *  does NOT bump segmentInfos.version. */
DECL|method|checkpointNoSIS
specifier|synchronized
name|void
name|checkpointNoSIS
parameter_list|()
throws|throws
name|IOException
block|{
name|changeCount
operator|++
expr_stmt|;
name|deleter
operator|.
name|checkpoint
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/** Called internally if any index state has changed. */
DECL|method|changed
specifier|synchronized
name|void
name|changed
parameter_list|()
block|{
name|changeCount
operator|++
expr_stmt|;
name|segmentInfos
operator|.
name|changed
argument_list|()
expr_stmt|;
block|}
DECL|method|publishFrozenUpdates
specifier|synchronized
name|void
name|publishFrozenUpdates
parameter_list|(
name|FrozenBufferedUpdates
name|packet
parameter_list|)
block|{
assert|assert
name|packet
operator|!=
literal|null
operator|&&
name|packet
operator|.
name|any
argument_list|()
assert|;
synchronized|synchronized
init|(
name|bufferedUpdatesStream
init|)
block|{
name|bufferedUpdatesStream
operator|.
name|push
argument_list|(
name|packet
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Atomically adds the segment private delete packet and publishes the flushed    * segments SegmentInfo to the index writer.    */
DECL|method|publishFlushedSegment
name|void
name|publishFlushedSegment
parameter_list|(
name|SegmentCommitInfo
name|newSegment
parameter_list|,
name|FrozenBufferedUpdates
name|packet
parameter_list|,
name|FrozenBufferedUpdates
name|globalPacket
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Lock order IW -> BDS
synchronized|synchronized
init|(
name|bufferedUpdatesStream
init|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"publishFlushedSegment"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|globalPacket
operator|!=
literal|null
operator|&&
name|globalPacket
operator|.
name|any
argument_list|()
condition|)
block|{
name|bufferedUpdatesStream
operator|.
name|push
argument_list|(
name|globalPacket
argument_list|)
expr_stmt|;
block|}
comment|// Publishing the segment must be synched on IW -> BDS to make the sure
comment|// that no merge prunes away the seg. private delete packet
specifier|final
name|long
name|nextGen
decl_stmt|;
if|if
condition|(
name|packet
operator|!=
literal|null
operator|&&
name|packet
operator|.
name|any
argument_list|()
condition|)
block|{
name|nextGen
operator|=
name|bufferedUpdatesStream
operator|.
name|push
argument_list|(
name|packet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Since we don't have a delete packet to apply we can get a new
comment|// generation right away
name|nextGen
operator|=
name|bufferedUpdatesStream
operator|.
name|getNextGen
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"publish sets newSegment delGen="
operator|+
name|nextGen
operator|+
literal|" seg="
operator|+
name|segString
argument_list|(
name|newSegment
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|newSegment
operator|.
name|setBufferedDeletesGen
argument_list|(
name|nextGen
argument_list|)
expr_stmt|;
name|segmentInfos
operator|.
name|add
argument_list|(
name|newSegment
argument_list|)
expr_stmt|;
name|checkpoint
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|flushCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|doAfterFlush
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|resetMergeExceptions
specifier|private
specifier|synchronized
name|void
name|resetMergeExceptions
parameter_list|()
block|{
name|mergeExceptions
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|mergeGen
operator|++
expr_stmt|;
block|}
DECL|method|noDupDirs
specifier|private
name|void
name|noDupDirs
parameter_list|(
name|Directory
modifier|...
name|dirs
parameter_list|)
block|{
name|HashSet
argument_list|<
name|Directory
argument_list|>
name|dups
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dups
operator|.
name|contains
argument_list|(
name|dirs
index|[
name|i
index|]
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Directory "
operator|+
name|dirs
index|[
name|i
index|]
operator|+
literal|" appears more than once"
argument_list|)
throw|;
if|if
condition|(
name|dirs
index|[
name|i
index|]
operator|==
name|directory
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot add directory to itself"
argument_list|)
throw|;
name|dups
operator|.
name|add
argument_list|(
name|dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Acquires write locks on all the directories; be sure    *  to match with a call to {@link IOUtils#close} in a    *  finally clause. */
DECL|method|acquireWriteLocks
specifier|private
name|List
argument_list|<
name|Lock
argument_list|>
name|acquireWriteLocks
parameter_list|(
name|Directory
modifier|...
name|dirs
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Lock
argument_list|>
name|locks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|Lock
name|lock
init|=
name|dirs
index|[
name|i
index|]
operator|.
name|makeLock
argument_list|(
name|WRITE_LOCK_NAME
argument_list|)
decl_stmt|;
name|locks
operator|.
name|add
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|lock
operator|.
name|obtain
argument_list|(
name|config
operator|.
name|getWriteLockTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
comment|// Release all previously acquired locks:
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|locks
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|locks
return|;
block|}
comment|/**    * Adds all segments from an array of indexes into this index.    *    *<p>This may be used to parallelize batch indexing. A large document    * collection can be broken into sub-collections. Each sub-collection can be    * indexed in parallel, on a different thread, process or machine. The    * complete index can then be created by merging sub-collection indexes    * with this method.    *    *<p>    *<b>NOTE:</b> this method acquires the write lock in    * each directory, to ensure that no {@code IndexWriter}    * is currently open or tries to open while this is    * running.    *    *<p>This method is transactional in how Exceptions are    * handled: it does not commit a new segments_N file until    * all indexes are added.  This means if an Exception    * occurs (for example disk full), then either no indexes    * will have been added or they all will have been.    *    *<p>Note that this requires temporary free space in the    * {@link Directory} up to 2X the sum of all input indexes    * (including the starting index). If readers/searchers    * are open against the starting index, then temporary    * free space required will be higher by the size of the    * starting index (see {@link #forceMerge(int)} for details).    *    *<p>    *<b>NOTE:</b> this method only copies the segments of the incoming indexes    * and does not merge them. Therefore deleted documents are not removed and    * the new segments are not merged with the existing ones.    *    *<p>This requires this index not be among those to be added.    *    *<p>    *<b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer. See<a    * href="#OOME">above</a> for details.    *    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    * @throws LockObtainFailedException if we were unable to    *   acquire the write lock in at least one directory    */
DECL|method|addIndexes
specifier|public
name|void
name|addIndexes
parameter_list|(
name|Directory
modifier|...
name|dirs
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|noDupDirs
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Lock
argument_list|>
name|locks
init|=
name|acquireWriteLocks
argument_list|(
name|dirs
argument_list|)
decl_stmt|;
name|boolean
name|successTop
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"flush at addIndexes(Directory...)"
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|infos
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|totalDocCount
init|=
literal|0
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
for|for
control|(
name|Directory
name|dir
range|:
name|dirs
control|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"addIndexes: process directory "
operator|+
name|dir
argument_list|)
expr_stmt|;
block|}
name|SegmentInfos
name|sis
init|=
operator|new
name|SegmentInfos
argument_list|()
decl_stmt|;
comment|// read infos from dir
name|sis
operator|.
name|read
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|totalDocCount
operator|+=
name|sis
operator|.
name|totalDocCount
argument_list|()
expr_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|sis
control|)
block|{
assert|assert
operator|!
name|infos
operator|.
name|contains
argument_list|(
name|info
argument_list|)
operator|:
literal|"dup info dir="
operator|+
name|info
operator|.
name|info
operator|.
name|dir
operator|+
literal|" name="
operator|+
name|info
operator|.
name|info
operator|.
name|name
assert|;
name|String
name|newSegName
init|=
name|newSegmentName
argument_list|()
decl_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"addIndexes: process segment origName="
operator|+
name|info
operator|.
name|info
operator|.
name|name
operator|+
literal|" newName="
operator|+
name|newSegName
operator|+
literal|" info="
operator|+
name|info
argument_list|)
expr_stmt|;
block|}
name|IOContext
name|context
init|=
operator|new
name|IOContext
argument_list|(
operator|new
name|MergeInfo
argument_list|(
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
argument_list|,
name|info
operator|.
name|sizeInBytes
argument_list|()
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|FieldInfo
name|fi
range|:
name|SegmentReader
operator|.
name|readFieldInfos
argument_list|(
name|info
argument_list|)
control|)
block|{
name|globalFieldNumberMap
operator|.
name|addOrGet
argument_list|(
name|fi
operator|.
name|name
argument_list|,
name|fi
operator|.
name|number
argument_list|,
name|fi
operator|.
name|getDocValuesType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|infos
operator|.
name|add
argument_list|(
name|copySegmentAsIs
argument_list|(
name|info
argument_list|,
name|newSegName
argument_list|,
name|context
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
for|for
control|(
name|SegmentCommitInfo
name|sipc
range|:
name|infos
control|)
block|{
for|for
control|(
name|String
name|file
range|:
name|sipc
operator|.
name|files
argument_list|()
control|)
block|{
try|try
block|{
name|directory
operator|.
name|deleteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{               }
block|}
block|}
block|}
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
comment|// Make sure adding the new documents to this index won't
comment|// exceed the limit:
name|reserveDocs
argument_list|(
name|totalDocCount
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
for|for
control|(
name|SegmentCommitInfo
name|sipc
range|:
name|infos
control|)
block|{
for|for
control|(
name|String
name|file
range|:
name|sipc
operator|.
name|files
argument_list|()
control|)
block|{
try|try
block|{
name|directory
operator|.
name|deleteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{                 }
block|}
block|}
block|}
block|}
name|segmentInfos
operator|.
name|addAll
argument_list|(
name|infos
argument_list|)
expr_stmt|;
name|checkpoint
argument_list|()
expr_stmt|;
block|}
name|successTop
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"addIndexes(Directory...)"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|successTop
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|locks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|locks
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Merges the provided indexes into this index.    *     *<p>    * The provided IndexReaders are not closed.    *     *<p>    * See {@link #addIndexes} for details on transactional semantics, temporary    * free space required in the Directory, and non-CFS segments on an Exception.    *     *<p>    *<b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately    * close the writer. See<a href="#OOME">above</a> for details.    *     *<p>    *<b>NOTE:</b> empty segments are dropped by this method and not added to this    * index.    *     *<p>    *<b>NOTE:</b> this method merges all given {@link IndexReader}s in one    * merge. If you intend to merge a large number of readers, it may be better    * to call this method multiple times, each time with a small set of readers.    * In principle, if you use a merge policy with a {@code mergeFactor} or    * {@code maxMergeAtOnce} parameter, you should pass that many readers in one    * call.    *     *<p>    *<b>NOTE</b>: if you call {@link #abortMerges}, which    * aborts all running merges, then any thread still running this method might    * hit a {@link MergePolicy.MergeAbortedException}.    *     * @throws CorruptIndexException    *           if the index is corrupt    * @throws IOException    *           if there is a low-level IO error    */
DECL|method|addIndexes
specifier|public
name|void
name|addIndexes
parameter_list|(
name|IndexReader
modifier|...
name|readers
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|int
name|numDocs
init|=
literal|0
decl_stmt|;
try|try
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"flush at addIndexes(IndexReader...)"
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|String
name|mergedName
init|=
name|newSegmentName
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|AtomicReader
argument_list|>
name|mergeReaders
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|IndexReader
name|indexReader
range|:
name|readers
control|)
block|{
name|numDocs
operator|+=
name|indexReader
operator|.
name|numDocs
argument_list|()
expr_stmt|;
for|for
control|(
name|AtomicReaderContext
name|ctx
range|:
name|indexReader
operator|.
name|leaves
argument_list|()
control|)
block|{
name|mergeReaders
operator|.
name|add
argument_list|(
name|ctx
operator|.
name|reader
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Make sure adding the new documents to this index won't
comment|// exceed the limit:
name|reserveDocs
argument_list|(
name|numDocs
argument_list|)
expr_stmt|;
specifier|final
name|IOContext
name|context
init|=
operator|new
name|IOContext
argument_list|(
operator|new
name|MergeInfo
argument_list|(
name|numDocs
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|// TODO: somehow we should fix this merge so it's
comment|// abortable so that IW.close(false) is able to stop it
name|TrackingDirectoryWrapper
name|trackingDir
init|=
operator|new
name|TrackingDirectoryWrapper
argument_list|(
name|directory
argument_list|)
decl_stmt|;
name|SegmentInfo
name|info
init|=
operator|new
name|SegmentInfo
argument_list|(
name|directory
argument_list|,
name|Constants
operator|.
name|LUCENE_MAIN_VERSION
argument_list|,
name|mergedName
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|,
name|codec
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|SegmentMerger
name|merger
init|=
operator|new
name|SegmentMerger
argument_list|(
name|mergeReaders
argument_list|,
name|info
argument_list|,
name|infoStream
argument_list|,
name|trackingDir
argument_list|,
name|MergeState
operator|.
name|CheckAbort
operator|.
name|NONE
argument_list|,
name|globalFieldNumberMap
argument_list|,
name|context
argument_list|,
name|config
operator|.
name|getCheckIntegrityAtMerge
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|merger
operator|.
name|shouldMerge
argument_list|()
condition|)
block|{
return|return;
block|}
name|MergeState
name|mergeState
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|mergeState
operator|=
name|merger
operator|.
name|merge
argument_list|()
expr_stmt|;
comment|// merge 'em
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|deleter
operator|.
name|refresh
argument_list|(
name|info
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SegmentCommitInfo
name|infoPerCommit
init|=
operator|new
name|SegmentCommitInfo
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
operator|-
literal|1L
argument_list|,
operator|-
literal|1L
argument_list|,
operator|-
literal|1L
argument_list|)
decl_stmt|;
name|info
operator|.
name|setFiles
argument_list|(
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|trackingDir
operator|.
name|getCreatedFiles
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|trackingDir
operator|.
name|getCreatedFiles
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|setDiagnostics
argument_list|(
name|info
argument_list|,
name|SOURCE_ADDINDEXES_READERS
argument_list|)
expr_stmt|;
name|boolean
name|useCompoundFile
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Guard segmentInfos
if|if
condition|(
name|stopMerges
condition|)
block|{
name|deleter
operator|.
name|deleteNewFiles
argument_list|(
name|infoPerCommit
operator|.
name|files
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|ensureOpen
argument_list|()
expr_stmt|;
name|useCompoundFile
operator|=
name|mergePolicy
operator|.
name|useCompoundFile
argument_list|(
name|segmentInfos
argument_list|,
name|infoPerCommit
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|// Now create the compound file if needed
if|if
condition|(
name|useCompoundFile
condition|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|filesToDelete
init|=
name|infoPerCommit
operator|.
name|files
argument_list|()
decl_stmt|;
try|try
block|{
name|createCompoundFile
argument_list|(
name|infoStream
argument_list|,
name|directory
argument_list|,
name|MergeState
operator|.
name|CheckAbort
operator|.
name|NONE
argument_list|,
name|info
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// delete new non cfs files directly: they were never
comment|// registered with IFD
synchronized|synchronized
init|(
name|this
init|)
block|{
name|deleter
operator|.
name|deleteNewFiles
argument_list|(
name|filesToDelete
argument_list|)
expr_stmt|;
block|}
block|}
name|info
operator|.
name|setUseCompoundFile
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Have codec write SegmentInfo.  Must do this after
comment|// creating CFS so that 1) .si isn't slurped into CFS,
comment|// and 2) .si reflects useCompoundFile=true change
comment|// above:
name|success
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|codec
operator|.
name|segmentInfoFormat
argument_list|()
operator|.
name|getSegmentInfoWriter
argument_list|()
operator|.
name|write
argument_list|(
name|trackingDir
argument_list|,
name|info
argument_list|,
name|mergeState
operator|.
name|fieldInfos
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|deleter
operator|.
name|refresh
argument_list|(
name|info
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|info
operator|.
name|addFiles
argument_list|(
name|trackingDir
operator|.
name|getCreatedFiles
argument_list|()
argument_list|)
expr_stmt|;
comment|// Register the new segment
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|stopMerges
condition|)
block|{
name|deleter
operator|.
name|deleteNewFiles
argument_list|(
name|info
operator|.
name|files
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|ensureOpen
argument_list|()
expr_stmt|;
name|segmentInfos
operator|.
name|add
argument_list|(
name|infoPerCommit
argument_list|)
expr_stmt|;
name|checkpoint
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"addIndexes(IndexReader...)"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Copies the segment files as-is into the IndexWriter's directory. */
DECL|method|copySegmentAsIs
specifier|private
name|SegmentCommitInfo
name|copySegmentAsIs
parameter_list|(
name|SegmentCommitInfo
name|info
parameter_list|,
name|String
name|segName
parameter_list|,
name|IOContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
comment|// note: we don't really need this fis (its copied), but we load it up
comment|// so we don't pass a null value to the si writer
name|FieldInfos
name|fis
init|=
name|SegmentReader
operator|.
name|readFieldInfos
argument_list|(
name|info
argument_list|)
decl_stmt|;
comment|//System.out.println("copy seg=" + info.info.name + " version=" + info.info.getVersion());
comment|// Same SI as before but we change directory and name
name|SegmentInfo
name|newInfo
init|=
operator|new
name|SegmentInfo
argument_list|(
name|directory
argument_list|,
name|info
operator|.
name|info
operator|.
name|getVersion
argument_list|()
argument_list|,
name|segName
argument_list|,
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
argument_list|,
name|info
operator|.
name|info
operator|.
name|getUseCompoundFile
argument_list|()
argument_list|,
name|info
operator|.
name|info
operator|.
name|getCodec
argument_list|()
argument_list|,
name|info
operator|.
name|info
operator|.
name|getDiagnostics
argument_list|()
argument_list|)
decl_stmt|;
name|SegmentCommitInfo
name|newInfoPerCommit
init|=
operator|new
name|SegmentCommitInfo
argument_list|(
name|newInfo
argument_list|,
name|info
operator|.
name|getDelCount
argument_list|()
argument_list|,
name|info
operator|.
name|getDelGen
argument_list|()
argument_list|,
name|info
operator|.
name|getFieldInfosGen
argument_list|()
argument_list|,
name|info
operator|.
name|getDocValuesGen
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|segFiles
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Build up new segment's file names.  Must do this
comment|// before writing SegmentInfo:
for|for
control|(
name|String
name|file
range|:
name|info
operator|.
name|files
argument_list|()
control|)
block|{
specifier|final
name|String
name|newFileName
decl_stmt|;
name|newFileName
operator|=
name|segName
operator|+
name|IndexFileNames
operator|.
name|stripSegmentName
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|segFiles
operator|.
name|add
argument_list|(
name|newFileName
argument_list|)
expr_stmt|;
block|}
name|newInfo
operator|.
name|setFiles
argument_list|(
name|segFiles
argument_list|)
expr_stmt|;
comment|// We must rewrite the SI file because it references segment name in its list of files, etc
name|TrackingDirectoryWrapper
name|trackingDir
init|=
operator|new
name|TrackingDirectoryWrapper
argument_list|(
name|directory
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|newInfo
operator|.
name|getCodec
argument_list|()
operator|.
name|segmentInfoFormat
argument_list|()
operator|.
name|getSegmentInfoWriter
argument_list|()
operator|.
name|write
argument_list|(
name|trackingDir
argument_list|,
name|newInfo
argument_list|,
name|fis
argument_list|,
name|context
argument_list|)
expr_stmt|;
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|siFiles
init|=
name|trackingDir
operator|.
name|getCreatedFiles
argument_list|()
decl_stmt|;
comment|// Copy the segment's files
for|for
control|(
name|String
name|file
range|:
name|info
operator|.
name|files
argument_list|()
control|)
block|{
specifier|final
name|String
name|newFileName
init|=
name|segName
operator|+
name|IndexFileNames
operator|.
name|stripSegmentName
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|siFiles
operator|.
name|contains
argument_list|(
name|newFileName
argument_list|)
condition|)
block|{
comment|// We already rewrote this above
continue|continue;
block|}
assert|assert
operator|!
name|slowFileExists
argument_list|(
name|directory
argument_list|,
name|newFileName
argument_list|)
operator|:
literal|"file \""
operator|+
name|newFileName
operator|+
literal|"\" already exists; siFiles="
operator|+
name|siFiles
assert|;
name|info
operator|.
name|info
operator|.
name|dir
operator|.
name|copy
argument_list|(
name|directory
argument_list|,
name|file
argument_list|,
name|newFileName
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
for|for
control|(
name|String
name|file
range|:
name|newInfo
operator|.
name|files
argument_list|()
control|)
block|{
try|try
block|{
name|directory
operator|.
name|deleteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{           }
block|}
block|}
block|}
return|return
name|newInfoPerCommit
return|;
block|}
comment|/**    * A hook for extending classes to execute operations after pending added and    * deleted documents have been flushed to the Directory but before the change    * is committed (new segments_N file written).    */
DECL|method|doAfterFlush
specifier|protected
name|void
name|doAfterFlush
parameter_list|()
throws|throws
name|IOException
block|{}
comment|/**    * A hook for extending classes to execute operations before pending added and    * deleted documents are flushed to the Directory.    */
DECL|method|doBeforeFlush
specifier|protected
name|void
name|doBeforeFlush
parameter_list|()
throws|throws
name|IOException
block|{}
comment|/**<p>Expert: prepare for commit.  This does the    *  first phase of 2-phase commit. This method does all    *  steps necessary to commit changes since this writer    *  was opened: flushes pending added and deleted docs,    *  syncs the index files, writes most of next segments_N    *  file.  After calling this you must call either {@link    *  #commit()} to finish the commit, or {@link    *  #rollback()} to revert the commit and undo all changes    *  done since the writer was opened.</p>    *    *<p>You can also just call {@link #commit()} directly    *  without prepareCommit first in which case that method    *  will internally call prepareCommit.    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    *  you should immediately close the writer.  See<a    *  href="#OOME">above</a> for details.</p>    */
annotation|@
name|Override
DECL|method|prepareCommit
specifier|public
specifier|final
name|void
name|prepareCommit
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|prepareCommitInternal
argument_list|()
expr_stmt|;
block|}
DECL|method|prepareCommitInternal
specifier|private
name|void
name|prepareCommitInternal
parameter_list|()
throws|throws
name|IOException
block|{
name|startCommitTime
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|commitLock
init|)
block|{
name|ensureOpen
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"prepareCommit: flush"
argument_list|)
expr_stmt|;
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"  index before flush "
operator|+
name|segString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hitOOM
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"this writer hit an OutOfMemoryError; cannot commit"
argument_list|)
throw|;
block|}
if|if
condition|(
name|pendingCommit
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"prepareCommit was already called with no corresponding call to commit"
argument_list|)
throw|;
block|}
name|doBeforeFlush
argument_list|()
expr_stmt|;
assert|assert
name|testPoint
argument_list|(
literal|"startDoFlush"
argument_list|)
assert|;
name|SegmentInfos
name|toCommit
init|=
literal|null
decl_stmt|;
name|boolean
name|anySegmentsFlushed
init|=
literal|false
decl_stmt|;
comment|// This is copied from doFlush, except it's modified to
comment|// clone& incRef the flushed SegmentInfos inside the
comment|// sync block:
try|try
block|{
synchronized|synchronized
init|(
name|fullFlushLock
init|)
block|{
name|boolean
name|flushSuccess
init|=
literal|false
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|anySegmentsFlushed
operator|=
name|docWriter
operator|.
name|flushAllThreads
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anySegmentsFlushed
condition|)
block|{
comment|// prevent double increment since docWriter#doFlush increments the flushcount
comment|// if we flushed anything.
name|flushCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
name|processEvents
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|flushSuccess
operator|=
literal|true
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|maybeApplyDeletes
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|readerPool
operator|.
name|commit
argument_list|(
name|segmentInfos
argument_list|)
expr_stmt|;
comment|// Must clone the segmentInfos while we still
comment|// hold fullFlushLock and while sync'd so that
comment|// no partial changes (eg a delete w/o
comment|// corresponding add from an updateDocument) can
comment|// sneak into the commit point:
name|toCommit
operator|=
name|segmentInfos
operator|.
name|clone
argument_list|()
expr_stmt|;
name|pendingCommitChangeCount
operator|=
name|changeCount
expr_stmt|;
comment|// This protects the segmentInfos we are now going
comment|// to commit.  This is important in case, eg, while
comment|// we are trying to sync all referenced files, a
comment|// merge completes which would otherwise have
comment|// removed the files we are now syncing.
name|filesToCommit
operator|=
name|toCommit
operator|.
name|files
argument_list|(
name|directory
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|incRef
argument_list|(
name|filesToCommit
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"hit exception during prepareCommit"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Done: finish the full flush!
name|docWriter
operator|.
name|finishFullFlush
argument_list|(
name|flushSuccess
argument_list|)
expr_stmt|;
name|doAfterFlush
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"prepareCommit"
argument_list|)
expr_stmt|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|anySegmentsFlushed
condition|)
block|{
name|maybeMerge
argument_list|(
name|MergeTrigger
operator|.
name|FULL_FLUSH
argument_list|,
name|UNBOUNDED_MAX_MERGE_SEGMENTS
argument_list|)
expr_stmt|;
block|}
name|startCommit
argument_list|(
name|toCommit
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|filesToCommit
operator|!=
literal|null
condition|)
block|{
name|deleter
operator|.
name|decRef
argument_list|(
name|filesToCommit
argument_list|)
expr_stmt|;
name|filesToCommit
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**    * Sets the commit user data map. That method is considered a transaction by    * {@link IndexWriter} and will be {@link #commit() committed} even if no other    * changes were made to the writer instance. Note that you must call this method    * before {@link #prepareCommit()}, or otherwise it won't be included in the    * follow-on {@link #commit()}.    *<p>    *<b>NOTE:</b> the map is cloned internally, therefore altering the map's    * contents after calling this method has no effect.    */
DECL|method|setCommitData
specifier|public
specifier|final
specifier|synchronized
name|void
name|setCommitData
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commitUserData
parameter_list|)
block|{
name|segmentInfos
operator|.
name|setUserData
argument_list|(
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|commitUserData
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|changeCount
expr_stmt|;
block|}
comment|/**    * Returns the commit user data map that was last committed, or the one that    * was set on {@link #setCommitData(Map)}.    */
DECL|method|getCommitData
specifier|public
specifier|final
specifier|synchronized
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getCommitData
parameter_list|()
block|{
return|return
name|segmentInfos
operator|.
name|getUserData
argument_list|()
return|;
block|}
comment|// Used only by commit and prepareCommit, below; lock
comment|// order is commitLock -> IW
DECL|field|commitLock
specifier|private
specifier|final
name|Object
name|commitLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|/**    *<p>Commits all pending changes (added& deleted    * documents, segment merges, added    * indexes, etc.) to the index, and syncs all referenced    * index files, such that a reader will see the changes    * and the index updates will survive an OS or machine    * crash or power loss.  Note that this does not wait for    * any running background merges to finish.  This may be a    * costly operation, so you should test the cost in your    * application and do it only when really necessary.</p>    *    *<p> Note that this operation calls Directory.sync on    * the index files.  That call should not return until the    * file contents& metadata are on stable storage.  For    * FSDirectory, this calls the OS's fsync.  But, beware:    * some hardware devices may in fact cache writes even    * during fsync, and return before the bits are actually    * on stable storage, to give the appearance of faster    * performance.  If you have such a device, and it does    * not have a battery backup (for example) then on power    * loss it may still lose data.  Lucene cannot guarantee    * consistency on such devices.</p>    *    *<p><b>NOTE</b>: if this method hits an OutOfMemoryError    * you should immediately close the writer.  See<a    * href="#OOME">above</a> for details.</p>    *    * @see #prepareCommit    */
annotation|@
name|Override
DECL|method|commit
specifier|public
specifier|final
name|void
name|commit
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|commitInternal
argument_list|()
expr_stmt|;
block|}
comment|/** Returns true if there may be changes that have not been    *  committed.  There are cases where this may return true    *  when there are no actual "real" changes to the index,    *  for example if you've deleted by Term or Query but    *  that Term or Query does not match any documents.    *  Also, if a merge kicked off as a result of flushing a    *  new segment during {@link #commit}, or a concurrent    *  merged finished, this method may return true right    *  after you had just called {@link #commit}. */
DECL|method|hasUncommittedChanges
specifier|public
specifier|final
name|boolean
name|hasUncommittedChanges
parameter_list|()
block|{
return|return
name|changeCount
operator|!=
name|lastCommitChangeCount
operator|||
name|docWriter
operator|.
name|anyChanges
argument_list|()
operator|||
name|bufferedUpdatesStream
operator|.
name|any
argument_list|()
return|;
block|}
DECL|method|commitInternal
specifier|private
specifier|final
name|void
name|commitInternal
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"commit: start"
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|commitLock
init|)
block|{
name|ensureOpen
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"commit: enter lock"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pendingCommit
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"commit: now prepare"
argument_list|)
expr_stmt|;
block|}
name|prepareCommitInternal
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"commit: already prepared"
argument_list|)
expr_stmt|;
block|}
block|}
name|finishCommit
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|finishCommit
specifier|private
specifier|synchronized
specifier|final
name|void
name|finishCommit
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pendingCommit
operator|!=
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"commit: pendingCommit != null"
argument_list|)
expr_stmt|;
block|}
name|pendingCommit
operator|.
name|finishCommit
argument_list|(
name|directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"commit: wrote segments file \""
operator|+
name|pendingCommit
operator|.
name|getSegmentsFileName
argument_list|()
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
name|segmentInfos
operator|.
name|updateGeneration
argument_list|(
name|pendingCommit
argument_list|)
expr_stmt|;
name|lastCommitChangeCount
operator|=
name|pendingCommitChangeCount
expr_stmt|;
name|rollbackSegments
operator|=
name|pendingCommit
operator|.
name|createBackupSegmentInfos
argument_list|()
expr_stmt|;
comment|// NOTE: don't use this.checkpoint() here, because
comment|// we do not want to increment changeCount:
name|deleter
operator|.
name|checkpoint
argument_list|(
name|pendingCommit
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Matches the incRef done in prepareCommit:
name|deleter
operator|.
name|decRef
argument_list|(
name|filesToCommit
argument_list|)
expr_stmt|;
name|filesToCommit
operator|=
literal|null
expr_stmt|;
name|pendingCommit
operator|=
literal|null
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"commit: took %.1f msec"
argument_list|,
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startCommitTime
operator|)
operator|/
literal|1000000.0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"commit: pendingCommit == null; skip"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"commit: done"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Ensures only one flush() is actually flushing segments
comment|// at a time:
DECL|field|fullFlushLock
specifier|private
specifier|final
name|Object
name|fullFlushLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|// for assert
DECL|method|holdsFullFlushLock
name|boolean
name|holdsFullFlushLock
parameter_list|()
block|{
return|return
name|Thread
operator|.
name|holdsLock
argument_list|(
name|fullFlushLock
argument_list|)
return|;
block|}
comment|/**    * Flush all in-memory buffered updates (adds and deletes)    * to the Directory.    * @param triggerMerge if true, we may merge segments (if    *  deletes or docs were flushed) if necessary    * @param applyAllDeletes whether pending deletes should also    */
DECL|method|flush
specifier|protected
specifier|final
name|void
name|flush
parameter_list|(
name|boolean
name|triggerMerge
parameter_list|,
name|boolean
name|applyAllDeletes
parameter_list|)
throws|throws
name|IOException
block|{
comment|// NOTE: this method cannot be sync'd because
comment|// maybeMerge() in turn calls mergeScheduler.merge which
comment|// in turn can take a long time to run and we don't want
comment|// to hold the lock for that.  In the case of
comment|// ConcurrentMergeScheduler this can lead to deadlock
comment|// when it stalls due to too many running merges.
comment|// We can be called during close, when closing==true, so we must pass false to ensureOpen:
name|ensureOpen
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|doFlush
argument_list|(
name|applyAllDeletes
argument_list|)
operator|&&
name|triggerMerge
condition|)
block|{
name|maybeMerge
argument_list|(
name|MergeTrigger
operator|.
name|FULL_FLUSH
argument_list|,
name|UNBOUNDED_MAX_MERGE_SEGMENTS
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doFlush
specifier|private
name|boolean
name|doFlush
parameter_list|(
name|boolean
name|applyAllDeletes
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|hitOOM
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"this writer hit an OutOfMemoryError; cannot flush"
argument_list|)
throw|;
block|}
name|doBeforeFlush
argument_list|()
expr_stmt|;
assert|assert
name|testPoint
argument_list|(
literal|"startDoFlush"
argument_list|)
assert|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"  start flush: applyAllDeletes="
operator|+
name|applyAllDeletes
argument_list|)
expr_stmt|;
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"  index before flush "
operator|+
name|segString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|anySegmentFlushed
decl_stmt|;
synchronized|synchronized
init|(
name|fullFlushLock
init|)
block|{
name|boolean
name|flushSuccess
init|=
literal|false
decl_stmt|;
try|try
block|{
name|anySegmentFlushed
operator|=
name|docWriter
operator|.
name|flushAllThreads
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|flushSuccess
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|docWriter
operator|.
name|finishFullFlush
argument_list|(
name|flushSuccess
argument_list|)
expr_stmt|;
name|processEvents
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
name|maybeApplyDeletes
argument_list|(
name|applyAllDeletes
argument_list|)
expr_stmt|;
name|doAfterFlush
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|anySegmentFlushed
condition|)
block|{
comment|// flushCount is incremented in flushAllThreads
name|flushCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|anySegmentFlushed
return|;
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"doFlush"
argument_list|)
expr_stmt|;
comment|// never hit
return|return
literal|false
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"hit exception during flush"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|maybeApplyDeletes
specifier|final
specifier|synchronized
name|void
name|maybeApplyDeletes
parameter_list|(
name|boolean
name|applyAllDeletes
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|applyAllDeletes
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"apply all deletes during flush"
argument_list|)
expr_stmt|;
block|}
name|applyAllDeletesAndUpdates
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"don't apply deletes now delTermCount="
operator|+
name|bufferedUpdatesStream
operator|.
name|numTerms
argument_list|()
operator|+
literal|" bytesUsed="
operator|+
name|bufferedUpdatesStream
operator|.
name|ramBytesUsed
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|applyAllDeletesAndUpdates
specifier|final
specifier|synchronized
name|void
name|applyAllDeletesAndUpdates
parameter_list|()
throws|throws
name|IOException
block|{
name|flushDeletesCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
specifier|final
name|BufferedUpdatesStream
operator|.
name|ApplyDeletesResult
name|result
decl_stmt|;
name|result
operator|=
name|bufferedUpdatesStream
operator|.
name|applyDeletesAndUpdates
argument_list|(
name|readerPool
argument_list|,
name|segmentInfos
operator|.
name|asList
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|anyDeletes
condition|)
block|{
name|checkpoint
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|keepFullyDeletedSegments
operator|&&
name|result
operator|.
name|allDeleted
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"drop 100% deleted segments: "
operator|+
name|segString
argument_list|(
name|result
operator|.
name|allDeleted
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|result
operator|.
name|allDeleted
control|)
block|{
comment|// If a merge has already registered for this
comment|// segment, we leave it in the readerPool; the
comment|// merge will skip merging it and will then drop
comment|// it once it's done:
if|if
condition|(
operator|!
name|mergingSegments
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|segmentInfos
operator|.
name|remove
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|pendingNumDocs
operator|.
name|addAndGet
argument_list|(
operator|-
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
argument_list|)
expr_stmt|;
name|readerPool
operator|.
name|drop
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
name|checkpoint
argument_list|()
expr_stmt|;
block|}
name|bufferedUpdatesStream
operator|.
name|prune
argument_list|(
name|segmentInfos
argument_list|)
expr_stmt|;
block|}
comment|// for testing only
DECL|method|getDocsWriter
name|DocumentsWriter
name|getDocsWriter
parameter_list|()
block|{
name|boolean
name|test
init|=
literal|false
decl_stmt|;
assert|assert
name|test
operator|=
literal|true
assert|;
return|return
name|test
condition|?
name|docWriter
else|:
literal|null
return|;
block|}
comment|/** Expert:  Return the number of documents currently    *  buffered in RAM. */
DECL|method|numRamDocs
specifier|public
specifier|final
specifier|synchronized
name|int
name|numRamDocs
parameter_list|()
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
return|return
name|docWriter
operator|.
name|getNumDocs
argument_list|()
return|;
block|}
DECL|method|ensureValidMerge
specifier|private
specifier|synchronized
name|void
name|ensureValidMerge
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
block|{
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|merge
operator|.
name|segments
control|)
block|{
if|if
condition|(
operator|!
name|segmentInfos
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MergePolicy
operator|.
name|MergeException
argument_list|(
literal|"MergePolicy selected a segment ("
operator|+
name|info
operator|.
name|info
operator|.
name|name
operator|+
literal|") that is not in the current index "
operator|+
name|segString
argument_list|()
argument_list|,
name|directory
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|skipDeletedDoc
specifier|private
name|void
name|skipDeletedDoc
parameter_list|(
name|DocValuesFieldUpdates
operator|.
name|Iterator
index|[]
name|updatesIters
parameter_list|,
name|int
name|deletedDoc
parameter_list|)
block|{
for|for
control|(
name|DocValuesFieldUpdates
operator|.
name|Iterator
name|iter
range|:
name|updatesIters
control|)
block|{
if|if
condition|(
name|iter
operator|.
name|doc
argument_list|()
operator|==
name|deletedDoc
condition|)
block|{
name|iter
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
block|}
comment|// when entering the method, all iterators must already be beyond the
comment|// deleted document, or right on it, in which case we advance them over
comment|// and they must be beyond it now.
assert|assert
name|iter
operator|.
name|doc
argument_list|()
operator|>
name|deletedDoc
operator|:
literal|"updateDoc="
operator|+
name|iter
operator|.
name|doc
argument_list|()
operator|+
literal|" deletedDoc="
operator|+
name|deletedDoc
assert|;
block|}
block|}
DECL|class|MergedDeletesAndUpdates
specifier|private
specifier|static
class|class
name|MergedDeletesAndUpdates
block|{
DECL|field|mergedDeletesAndUpdates
name|ReadersAndUpdates
name|mergedDeletesAndUpdates
init|=
literal|null
decl_stmt|;
DECL|field|docMap
name|MergePolicy
operator|.
name|DocMap
name|docMap
init|=
literal|null
decl_stmt|;
DECL|field|initializedWritableLiveDocs
name|boolean
name|initializedWritableLiveDocs
init|=
literal|false
decl_stmt|;
DECL|method|MergedDeletesAndUpdates
name|MergedDeletesAndUpdates
parameter_list|()
block|{}
DECL|method|init
specifier|final
name|void
name|init
parameter_list|(
name|ReaderPool
name|readerPool
parameter_list|,
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|,
name|MergeState
name|mergeState
parameter_list|,
name|boolean
name|initWritableLiveDocs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|mergedDeletesAndUpdates
operator|==
literal|null
condition|)
block|{
name|mergedDeletesAndUpdates
operator|=
name|readerPool
operator|.
name|get
argument_list|(
name|merge
operator|.
name|info
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|docMap
operator|=
name|merge
operator|.
name|getDocMap
argument_list|(
name|mergeState
argument_list|)
expr_stmt|;
assert|assert
name|docMap
operator|.
name|isConsistent
argument_list|(
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
argument_list|)
assert|;
block|}
if|if
condition|(
name|initWritableLiveDocs
operator|&&
operator|!
name|initializedWritableLiveDocs
condition|)
block|{
name|mergedDeletesAndUpdates
operator|.
name|initWritableLiveDocs
argument_list|()
expr_stmt|;
name|this
operator|.
name|initializedWritableLiveDocs
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
DECL|method|maybeApplyMergedDVUpdates
specifier|private
name|void
name|maybeApplyMergedDVUpdates
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|,
name|MergeState
name|mergeState
parameter_list|,
name|int
name|docUpto
parameter_list|,
name|MergedDeletesAndUpdates
name|holder
parameter_list|,
name|String
index|[]
name|mergingFields
parameter_list|,
name|DocValuesFieldUpdates
index|[]
name|dvFieldUpdates
parameter_list|,
name|DocValuesFieldUpdates
operator|.
name|Iterator
index|[]
name|updatesIters
parameter_list|,
name|int
name|curDoc
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|newDoc
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|mergingFields
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|DocValuesFieldUpdates
operator|.
name|Iterator
name|updatesIter
init|=
name|updatesIters
index|[
name|idx
index|]
decl_stmt|;
if|if
condition|(
name|updatesIter
operator|.
name|doc
argument_list|()
operator|==
name|curDoc
condition|)
block|{
comment|// document has an update
if|if
condition|(
name|holder
operator|.
name|mergedDeletesAndUpdates
operator|==
literal|null
condition|)
block|{
name|holder
operator|.
name|init
argument_list|(
name|readerPool
argument_list|,
name|merge
argument_list|,
name|mergeState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newDoc
operator|==
operator|-
literal|1
condition|)
block|{
comment|// map once per all field updates, but only if there are any updates
name|newDoc
operator|=
name|holder
operator|.
name|docMap
operator|.
name|map
argument_list|(
name|docUpto
argument_list|)
expr_stmt|;
block|}
name|DocValuesFieldUpdates
name|dvUpdates
init|=
name|dvFieldUpdates
index|[
name|idx
index|]
decl_stmt|;
name|dvUpdates
operator|.
name|add
argument_list|(
name|newDoc
argument_list|,
name|updatesIter
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|updatesIter
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
comment|// advance to next document
block|}
else|else
block|{
assert|assert
name|updatesIter
operator|.
name|doc
argument_list|()
operator|>
name|curDoc
operator|:
literal|"field="
operator|+
name|mergingFields
index|[
name|idx
index|]
operator|+
literal|" updateDoc="
operator|+
name|updatesIter
operator|.
name|doc
argument_list|()
operator|+
literal|" curDoc="
operator|+
name|curDoc
assert|;
block|}
block|}
block|}
comment|/**    * Carefully merges deletes and updates for the segments we just merged. This    * is tricky because, although merging will clear all deletes (compacts the    * documents) and compact all the updates, new deletes and updates may have    * been flushed to the segments since the merge was started. This method    * "carries over" such new deletes and updates onto the newly merged segment,    * and saves the resulting deletes and updates files (incrementing the delete    * and DV generations for merge.info). If no deletes were flushed, no new    * deletes file is saved.    */
DECL|method|commitMergedDeletesAndUpdates
specifier|synchronized
specifier|private
name|ReadersAndUpdates
name|commitMergedDeletesAndUpdates
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|,
name|MergeState
name|mergeState
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|testPoint
argument_list|(
literal|"startCommitMergeDeletes"
argument_list|)
assert|;
specifier|final
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|sourceSegments
init|=
name|merge
operator|.
name|segments
decl_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"commitMergeDeletes "
operator|+
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Carefully merge deletes that occurred after we
comment|// started merging:
name|int
name|docUpto
init|=
literal|0
decl_stmt|;
name|long
name|minGen
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
comment|// Lazy init (only when we find a delete to carry over):
specifier|final
name|MergedDeletesAndUpdates
name|holder
init|=
operator|new
name|MergedDeletesAndUpdates
argument_list|()
decl_stmt|;
specifier|final
name|DocValuesFieldUpdates
operator|.
name|Container
name|mergedDVUpdates
init|=
operator|new
name|DocValuesFieldUpdates
operator|.
name|Container
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sourceSegments
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SegmentCommitInfo
name|info
init|=
name|sourceSegments
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|minGen
operator|=
name|Math
operator|.
name|min
argument_list|(
name|info
operator|.
name|getBufferedDeletesGen
argument_list|()
argument_list|,
name|minGen
argument_list|)
expr_stmt|;
specifier|final
name|int
name|docCount
init|=
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
decl_stmt|;
specifier|final
name|Bits
name|prevLiveDocs
init|=
name|merge
operator|.
name|readers
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getLiveDocs
argument_list|()
decl_stmt|;
specifier|final
name|ReadersAndUpdates
name|rld
init|=
name|readerPool
operator|.
name|get
argument_list|(
name|info
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// We hold a ref so it should still be in the pool:
assert|assert
name|rld
operator|!=
literal|null
operator|:
literal|"seg="
operator|+
name|info
operator|.
name|info
operator|.
name|name
assert|;
specifier|final
name|Bits
name|currentLiveDocs
init|=
name|rld
operator|.
name|getLiveDocs
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|DocValuesFieldUpdates
argument_list|>
name|mergingFieldUpdates
init|=
name|rld
operator|.
name|getMergingFieldUpdates
argument_list|()
decl_stmt|;
specifier|final
name|String
index|[]
name|mergingFields
decl_stmt|;
specifier|final
name|DocValuesFieldUpdates
index|[]
name|dvFieldUpdates
decl_stmt|;
specifier|final
name|DocValuesFieldUpdates
operator|.
name|Iterator
index|[]
name|updatesIters
decl_stmt|;
if|if
condition|(
name|mergingFieldUpdates
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|mergingFields
operator|=
literal|null
expr_stmt|;
name|updatesIters
operator|=
literal|null
expr_stmt|;
name|dvFieldUpdates
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|mergingFields
operator|=
operator|new
name|String
index|[
name|mergingFieldUpdates
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|dvFieldUpdates
operator|=
operator|new
name|DocValuesFieldUpdates
index|[
name|mergingFieldUpdates
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|updatesIters
operator|=
operator|new
name|DocValuesFieldUpdates
operator|.
name|Iterator
index|[
name|mergingFieldUpdates
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|DocValuesFieldUpdates
argument_list|>
name|e
range|:
name|mergingFieldUpdates
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|DocValuesFieldUpdates
name|updates
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|mergingFields
index|[
name|idx
index|]
operator|=
name|field
expr_stmt|;
name|dvFieldUpdates
index|[
name|idx
index|]
operator|=
name|mergedDVUpdates
operator|.
name|getUpdates
argument_list|(
name|field
argument_list|,
name|updates
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvFieldUpdates
index|[
name|idx
index|]
operator|==
literal|null
condition|)
block|{
name|dvFieldUpdates
index|[
name|idx
index|]
operator|=
name|mergedDVUpdates
operator|.
name|newUpdates
argument_list|(
name|field
argument_list|,
name|updates
operator|.
name|type
argument_list|,
name|mergeState
operator|.
name|segmentInfo
operator|.
name|getDocCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|updatesIters
index|[
name|idx
index|]
operator|=
name|updates
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|updatesIters
index|[
name|idx
index|]
operator|.
name|nextDoc
argument_list|()
expr_stmt|;
comment|// advance to first update doc
operator|++
name|idx
expr_stmt|;
block|}
block|}
comment|//      System.out.println("[" + Thread.currentThread().getName() + "] IW.commitMergedDeletes: info=" + info + ", mergingUpdates=" + mergingUpdates);
if|if
condition|(
name|prevLiveDocs
operator|!=
literal|null
condition|)
block|{
comment|// If we had deletions on starting the merge we must
comment|// still have deletions now:
assert|assert
name|currentLiveDocs
operator|!=
literal|null
assert|;
assert|assert
name|prevLiveDocs
operator|.
name|length
argument_list|()
operator|==
name|docCount
assert|;
assert|assert
name|currentLiveDocs
operator|.
name|length
argument_list|()
operator|==
name|docCount
assert|;
comment|// There were deletes on this segment when the merge
comment|// started.  The merge has collapsed away those
comment|// deletes, but, if new deletes were flushed since
comment|// the merge started, we must now carefully keep any
comment|// newly flushed deletes but mapping them to the new
comment|// docIDs.
comment|// Since we copy-on-write, if any new deletes were
comment|// applied after merging has started, we can just
comment|// check if the before/after liveDocs have changed.
comment|// If so, we must carefully merge the liveDocs one
comment|// doc at a time:
if|if
condition|(
name|currentLiveDocs
operator|!=
name|prevLiveDocs
condition|)
block|{
comment|// This means this segment received new deletes
comment|// since we started the merge, so we
comment|// must merge them:
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|docCount
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|prevLiveDocs
operator|.
name|get
argument_list|(
name|j
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|currentLiveDocs
operator|.
name|get
argument_list|(
name|j
argument_list|)
assert|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|currentLiveDocs
operator|.
name|get
argument_list|(
name|j
argument_list|)
condition|)
block|{
if|if
condition|(
name|holder
operator|.
name|mergedDeletesAndUpdates
operator|==
literal|null
operator|||
operator|!
name|holder
operator|.
name|initializedWritableLiveDocs
condition|)
block|{
name|holder
operator|.
name|init
argument_list|(
name|readerPool
argument_list|,
name|merge
argument_list|,
name|mergeState
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|holder
operator|.
name|mergedDeletesAndUpdates
operator|.
name|delete
argument_list|(
name|holder
operator|.
name|docMap
operator|.
name|map
argument_list|(
name|docUpto
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mergingFields
operator|!=
literal|null
condition|)
block|{
comment|// advance all iters beyond the deleted document
name|skipDeletedDoc
argument_list|(
name|updatesIters
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mergingFields
operator|!=
literal|null
condition|)
block|{
name|maybeApplyMergedDVUpdates
argument_list|(
name|merge
argument_list|,
name|mergeState
argument_list|,
name|docUpto
argument_list|,
name|holder
argument_list|,
name|mergingFields
argument_list|,
name|dvFieldUpdates
argument_list|,
name|updatesIters
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|docUpto
operator|++
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mergingFields
operator|!=
literal|null
condition|)
block|{
comment|// need to check each non-deleted document if it has any updates
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|docCount
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|prevLiveDocs
operator|.
name|get
argument_list|(
name|j
argument_list|)
condition|)
block|{
comment|// document isn't deleted, check if any of the fields have an update to it
name|maybeApplyMergedDVUpdates
argument_list|(
name|merge
argument_list|,
name|mergeState
argument_list|,
name|docUpto
argument_list|,
name|holder
argument_list|,
name|mergingFields
argument_list|,
name|dvFieldUpdates
argument_list|,
name|updatesIters
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|// advance docUpto for every non-deleted document
name|docUpto
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// advance all iters beyond the deleted document
name|skipDeletedDoc
argument_list|(
name|updatesIters
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|docUpto
operator|+=
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|-
name|info
operator|.
name|getDelCount
argument_list|()
operator|-
name|rld
operator|.
name|getPendingDeleteCount
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|currentLiveDocs
operator|!=
literal|null
condition|)
block|{
assert|assert
name|currentLiveDocs
operator|.
name|length
argument_list|()
operator|==
name|docCount
assert|;
comment|// This segment had no deletes before but now it
comment|// does:
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|docCount
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|currentLiveDocs
operator|.
name|get
argument_list|(
name|j
argument_list|)
condition|)
block|{
if|if
condition|(
name|holder
operator|.
name|mergedDeletesAndUpdates
operator|==
literal|null
operator|||
operator|!
name|holder
operator|.
name|initializedWritableLiveDocs
condition|)
block|{
name|holder
operator|.
name|init
argument_list|(
name|readerPool
argument_list|,
name|merge
argument_list|,
name|mergeState
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|holder
operator|.
name|mergedDeletesAndUpdates
operator|.
name|delete
argument_list|(
name|holder
operator|.
name|docMap
operator|.
name|map
argument_list|(
name|docUpto
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mergingFields
operator|!=
literal|null
condition|)
block|{
comment|// advance all iters beyond the deleted document
name|skipDeletedDoc
argument_list|(
name|updatesIters
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mergingFields
operator|!=
literal|null
condition|)
block|{
name|maybeApplyMergedDVUpdates
argument_list|(
name|merge
argument_list|,
name|mergeState
argument_list|,
name|docUpto
argument_list|,
name|holder
argument_list|,
name|mergingFields
argument_list|,
name|dvFieldUpdates
argument_list|,
name|updatesIters
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|docUpto
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mergingFields
operator|!=
literal|null
condition|)
block|{
comment|// no deletions before or after, but there were updates
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|docCount
condition|;
name|j
operator|++
control|)
block|{
name|maybeApplyMergedDVUpdates
argument_list|(
name|merge
argument_list|,
name|mergeState
argument_list|,
name|docUpto
argument_list|,
name|holder
argument_list|,
name|mergingFields
argument_list|,
name|dvFieldUpdates
argument_list|,
name|updatesIters
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|// advance docUpto for every non-deleted document
name|docUpto
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// No deletes or updates before or after
name|docUpto
operator|+=
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
expr_stmt|;
block|}
block|}
assert|assert
name|docUpto
operator|==
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
assert|;
if|if
condition|(
name|mergedDVUpdates
operator|.
name|any
argument_list|()
condition|)
block|{
comment|//      System.out.println("[" + Thread.currentThread().getName() + "] IW.commitMergedDeletes: mergedDeletes.info=" + mergedDeletes.info + ", mergedFieldUpdates=" + mergedFieldUpdates);
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// if any error occurs while writing the field updates we should release
comment|// the info, otherwise it stays in the pool but is considered not "live"
comment|// which later causes false exceptions in pool.dropAll().
comment|// NOTE: currently this is the only place which throws a true
comment|// IOException. If this ever changes, we need to extend that try/finally
comment|// block to the rest of the method too.
name|holder
operator|.
name|mergedDeletesAndUpdates
operator|.
name|writeFieldUpdates
argument_list|(
name|directory
argument_list|,
name|mergedDVUpdates
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|holder
operator|.
name|mergedDeletesAndUpdates
operator|.
name|dropChanges
argument_list|()
expr_stmt|;
name|readerPool
operator|.
name|drop
argument_list|(
name|merge
operator|.
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
if|if
condition|(
name|holder
operator|.
name|mergedDeletesAndUpdates
operator|==
literal|null
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"no new deletes or field updates since merge started"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|msg
init|=
name|holder
operator|.
name|mergedDeletesAndUpdates
operator|.
name|getPendingDeleteCount
argument_list|()
operator|+
literal|" new deletes"
decl_stmt|;
if|if
condition|(
name|mergedDVUpdates
operator|.
name|any
argument_list|()
condition|)
block|{
name|msg
operator|+=
literal|" and "
operator|+
name|mergedDVUpdates
operator|.
name|size
argument_list|()
operator|+
literal|" new field updates"
expr_stmt|;
block|}
name|msg
operator|+=
literal|" since merge started"
expr_stmt|;
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
name|merge
operator|.
name|info
operator|.
name|setBufferedDeletesGen
argument_list|(
name|minGen
argument_list|)
expr_stmt|;
return|return
name|holder
operator|.
name|mergedDeletesAndUpdates
return|;
block|}
DECL|method|commitMerge
specifier|synchronized
specifier|private
name|boolean
name|commitMerge
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|,
name|MergeState
name|mergeState
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|testPoint
argument_list|(
literal|"startCommitMerge"
argument_list|)
assert|;
if|if
condition|(
name|hitOOM
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"this writer hit an OutOfMemoryError; cannot complete merge"
argument_list|)
throw|;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"commitMerge: "
operator|+
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
operator|+
literal|" index="
operator|+
name|segString
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|merge
operator|.
name|registerDone
assert|;
comment|// If merge was explicitly aborted, or, if rollback() or
comment|// rollbackTransaction() had been called since our merge
comment|// started (which results in an unqualified
comment|// deleter.refresh() call that will remove any index
comment|// file that current segments does not reference), we
comment|// abort this merge
if|if
condition|(
name|merge
operator|.
name|isAborted
argument_list|()
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"commitMerge: skip: it was aborted"
argument_list|)
expr_stmt|;
block|}
comment|// In case we opened and pooled a reader for this
comment|// segment, drop it now.  This ensures that we close
comment|// the reader before trying to delete any of its
comment|// files.  This is not a very big deal, since this
comment|// reader will never be used by any NRT reader, and
comment|// another thread is currently running close(false)
comment|// so it will be dropped shortly anyway, but not
comment|// doing this  makes  MockDirWrapper angry in
comment|// TestNRTThreads (LUCENE-5434):
name|readerPool
operator|.
name|drop
argument_list|(
name|merge
operator|.
name|info
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|deleteNewFiles
argument_list|(
name|merge
operator|.
name|info
operator|.
name|files
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|final
name|ReadersAndUpdates
name|mergedUpdates
init|=
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|commitMergedDeletesAndUpdates
argument_list|(
name|merge
argument_list|,
name|mergeState
argument_list|)
decl_stmt|;
comment|//    System.out.println("[" + Thread.currentThread().getName() + "] IW.commitMerge: mergedDeletes=" + mergedDeletes);
comment|// If the doc store we are using has been closed and
comment|// is in now compound format (but wasn't when we
comment|// started), then we will switch to the compound
comment|// format as well:
assert|assert
operator|!
name|segmentInfos
operator|.
name|contains
argument_list|(
name|merge
operator|.
name|info
argument_list|)
assert|;
specifier|final
name|boolean
name|allDeleted
init|=
name|merge
operator|.
name|segments
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|==
literal|0
operator|||
operator|(
name|mergedUpdates
operator|!=
literal|null
operator|&&
name|mergedUpdates
operator|.
name|getPendingDeleteCount
argument_list|()
operator|==
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
if|if
condition|(
name|allDeleted
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"merged segment "
operator|+
name|merge
operator|.
name|info
operator|+
literal|" is 100% deleted"
operator|+
operator|(
name|keepFullyDeletedSegments
condition|?
literal|""
else|:
literal|"; skipping insert"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|boolean
name|dropSegment
init|=
name|allDeleted
operator|&&
operator|!
name|keepFullyDeletedSegments
decl_stmt|;
comment|// If we merged no segments then we better be dropping
comment|// the new segment:
assert|assert
name|merge
operator|.
name|segments
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|||
name|dropSegment
assert|;
assert|assert
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|!=
literal|0
operator|||
name|keepFullyDeletedSegments
operator|||
name|dropSegment
assert|;
if|if
condition|(
name|mergedUpdates
operator|!=
literal|null
condition|)
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|dropSegment
condition|)
block|{
name|mergedUpdates
operator|.
name|dropChanges
argument_list|()
expr_stmt|;
block|}
comment|// Pass false for assertInfoLive because the merged
comment|// segment is not yet live (only below do we commit it
comment|// to the segmentInfos):
name|readerPool
operator|.
name|release
argument_list|(
name|mergedUpdates
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|mergedUpdates
operator|.
name|dropChanges
argument_list|()
expr_stmt|;
name|readerPool
operator|.
name|drop
argument_list|(
name|merge
operator|.
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Must do this after readerPool.release, in case an
comment|// exception is hit e.g. writing the live docs for the
comment|// merge segment, in which case we need to abort the
comment|// merge:
name|segmentInfos
operator|.
name|applyMergeChanges
argument_list|(
name|merge
argument_list|,
name|dropSegment
argument_list|)
expr_stmt|;
comment|// Now deduct the deleted docs that we just reclaimed from this
comment|// merge:
name|int
name|delDocCount
init|=
name|merge
operator|.
name|totalDocCount
operator|-
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
decl_stmt|;
assert|assert
name|delDocCount
operator|>=
literal|0
assert|;
name|pendingNumDocs
operator|.
name|addAndGet
argument_list|(
operator|-
name|delDocCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|dropSegment
condition|)
block|{
assert|assert
operator|!
name|segmentInfos
operator|.
name|contains
argument_list|(
name|merge
operator|.
name|info
argument_list|)
assert|;
name|readerPool
operator|.
name|drop
argument_list|(
name|merge
operator|.
name|info
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|deleteNewFiles
argument_list|(
name|merge
operator|.
name|info
operator|.
name|files
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// Must close before checkpoint, otherwise IFD won't be
comment|// able to delete the held-open files from the merge
comment|// readers:
name|closeMergeReaders
argument_list|(
name|merge
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
comment|// Must note the change to segmentInfos so any commits
comment|// in-flight don't lose it (IFD will incRef/protect the
comment|// new files we created):
if|if
condition|(
name|success
condition|)
block|{
name|checkpoint
argument_list|()
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|checkpoint
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Ignore so we keep throwing original exception.
block|}
block|}
block|}
name|deleter
operator|.
name|deletePendingFiles
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"after commitMerge: "
operator|+
name|segString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge
operator|.
name|maxNumSegments
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|dropSegment
condition|)
block|{
comment|// cascade the forceMerge:
if|if
condition|(
operator|!
name|segmentsToMerge
operator|.
name|containsKey
argument_list|(
name|merge
operator|.
name|info
argument_list|)
condition|)
block|{
name|segmentsToMerge
operator|.
name|put
argument_list|(
name|merge
operator|.
name|info
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|handleMergeException
specifier|final
specifier|private
name|void
name|handleMergeException
parameter_list|(
name|Throwable
name|t
parameter_list|,
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"handleMergeException: merge="
operator|+
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
operator|+
literal|" exc="
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
comment|// Set the exception on the merge, so if
comment|// forceMerge is waiting on us it sees the root
comment|// cause exception:
name|merge
operator|.
name|setException
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|addMergeException
argument_list|(
name|merge
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|MergePolicy
operator|.
name|MergeAbortedException
condition|)
block|{
comment|// We can ignore this exception (it happens when
comment|// close(false) or rollback is called), unless the
comment|// merge involves segments from external directories,
comment|// in which case we must throw it so, for example, the
comment|// rollbackTransaction code in addIndexes* is
comment|// executed.
if|if
condition|(
name|merge
operator|.
name|isExternal
condition|)
block|{
throw|throw
operator|(
name|MergePolicy
operator|.
name|MergeAbortedException
operator|)
name|t
throw|;
block|}
block|}
else|else
block|{
name|IOUtils
operator|.
name|reThrow
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Merges the indicated segments, replacing them in the stack with a    * single segment.    *     * @lucene.experimental    */
DECL|method|merge
specifier|public
name|void
name|merge
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
specifier|final
name|long
name|t0
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
try|try
block|{
try|try
block|{
name|mergeInit
argument_list|(
name|merge
argument_list|)
expr_stmt|;
comment|//if (merge.info != null) {
comment|//System.out.println("MERGE: " + merge.info.info.name);
comment|//}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"now merge\n  merge="
operator|+
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
operator|+
literal|"\n  index="
operator|+
name|segString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|mergeMiddle
argument_list|(
name|merge
argument_list|)
expr_stmt|;
name|mergeSuccess
argument_list|(
name|merge
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|handleMergeException
argument_list|(
name|t
argument_list|,
name|merge
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|mergeFinish
argument_list|(
name|merge
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"hit exception during merge"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge
operator|.
name|info
operator|!=
literal|null
operator|&&
operator|!
name|segmentInfos
operator|.
name|contains
argument_list|(
name|merge
operator|.
name|info
argument_list|)
condition|)
block|{
name|deleter
operator|.
name|refresh
argument_list|(
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|// This merge (and, generally, any change to the
comment|// segments) may now enable new merges, so we call
comment|// merge policy& update pending merges.
if|if
condition|(
name|success
operator|&&
operator|!
name|merge
operator|.
name|isAborted
argument_list|()
operator|&&
operator|(
name|merge
operator|.
name|maxNumSegments
operator|!=
operator|-
literal|1
operator|||
operator|(
operator|!
name|closed
operator|&&
operator|!
name|closing
operator|)
operator|)
condition|)
block|{
name|updatePendingMerges
argument_list|(
name|MergeTrigger
operator|.
name|MERGE_FINISHED
argument_list|,
name|merge
operator|.
name|maxNumSegments
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"merge"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge
operator|.
name|info
operator|!=
literal|null
operator|&&
operator|!
name|merge
operator|.
name|isAborted
argument_list|()
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"merge time "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|t0
operator|)
operator|+
literal|" msec for "
operator|+
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|+
literal|" docs"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Hook that's called when the specified merge is complete. */
DECL|method|mergeSuccess
name|void
name|mergeSuccess
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
block|{   }
comment|/** Checks whether this merge involves any segments    *  already participating in a merge.  If not, this merge    *  is "registered", meaning we record that its segments    *  are now participating in a merge, and true is    *  returned.  Else (the merge conflicts) false is    *  returned. */
DECL|method|registerMerge
specifier|final
specifier|synchronized
name|boolean
name|registerMerge
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|merge
operator|.
name|registerDone
condition|)
block|{
return|return
literal|true
return|;
block|}
assert|assert
name|merge
operator|.
name|segments
operator|.
name|size
argument_list|()
operator|>
literal|0
assert|;
if|if
condition|(
name|stopMerges
condition|)
block|{
name|merge
operator|.
name|abort
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|MergePolicy
operator|.
name|MergeAbortedException
argument_list|(
literal|"merge is aborted: "
operator|+
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
argument_list|)
throw|;
block|}
name|boolean
name|isExternal
init|=
literal|false
decl_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|merge
operator|.
name|segments
control|)
block|{
if|if
condition|(
name|mergingSegments
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"reject merge "
operator|+
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
operator|+
literal|": segment "
operator|+
name|segString
argument_list|(
name|info
argument_list|)
operator|+
literal|" is already marked for merge"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|segmentInfos
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"reject merge "
operator|+
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
operator|+
literal|": segment "
operator|+
name|segString
argument_list|(
name|info
argument_list|)
operator|+
literal|" does not exist in live infos"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|info
operator|.
name|info
operator|.
name|dir
operator|!=
name|directory
condition|)
block|{
name|isExternal
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|segmentsToMerge
operator|.
name|containsKey
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|merge
operator|.
name|maxNumSegments
operator|=
name|mergeMaxNumSegments
expr_stmt|;
block|}
block|}
name|ensureValidMerge
argument_list|(
name|merge
argument_list|)
expr_stmt|;
name|pendingMerges
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"add merge to pendingMerges: "
operator|+
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
operator|+
literal|" [total "
operator|+
name|pendingMerges
operator|.
name|size
argument_list|()
operator|+
literal|" pending]"
argument_list|)
expr_stmt|;
block|}
name|merge
operator|.
name|mergeGen
operator|=
name|mergeGen
expr_stmt|;
name|merge
operator|.
name|isExternal
operator|=
name|isExternal
expr_stmt|;
comment|// OK it does not conflict; now record that this merge
comment|// is running (while synchronized) to avoid race
comment|// condition where two conflicting merges from different
comment|// threads, start
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"registerMerge merging= ["
argument_list|)
decl_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|mergingSegments
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|info
operator|.
name|info
operator|.
name|name
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
comment|// don't call mergingSegments.toString() could lead to ConcurrentModException
comment|// since merge updates the segments FieldInfos
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|merge
operator|.
name|segments
control|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"registerMerge info="
operator|+
name|segString
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mergingSegments
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
assert|assert
name|merge
operator|.
name|estimatedMergeBytes
operator|==
literal|0
assert|;
assert|assert
name|merge
operator|.
name|totalMergeBytes
operator|==
literal|0
assert|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|merge
operator|.
name|segments
control|)
block|{
if|if
condition|(
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|delCount
init|=
name|numDeletedDocs
argument_list|(
name|info
argument_list|)
decl_stmt|;
assert|assert
name|delCount
operator|<=
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
assert|;
specifier|final
name|double
name|delRatio
init|=
operator|(
operator|(
name|double
operator|)
name|delCount
operator|)
operator|/
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
decl_stmt|;
name|merge
operator|.
name|estimatedMergeBytes
operator|+=
name|info
operator|.
name|sizeInBytes
argument_list|()
operator|*
operator|(
literal|1.0
operator|-
name|delRatio
operator|)
expr_stmt|;
name|merge
operator|.
name|totalMergeBytes
operator|+=
name|info
operator|.
name|sizeInBytes
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Merge is now registered
name|merge
operator|.
name|registerDone
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/** Does initial setup for a merge, which is fast but holds    *  the synchronized lock on IndexWriter instance.  */
DECL|method|mergeInit
specifier|final
specifier|synchronized
name|void
name|mergeInit
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|_mergeInit
argument_list|(
name|merge
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"hit exception in mergeInit"
argument_list|)
expr_stmt|;
block|}
name|mergeFinish
argument_list|(
name|merge
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|_mergeInit
specifier|synchronized
specifier|private
name|void
name|_mergeInit
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|testPoint
argument_list|(
literal|"startMergeInit"
argument_list|)
assert|;
assert|assert
name|merge
operator|.
name|registerDone
assert|;
assert|assert
name|merge
operator|.
name|maxNumSegments
operator|==
operator|-
literal|1
operator|||
name|merge
operator|.
name|maxNumSegments
operator|>
literal|0
assert|;
if|if
condition|(
name|hitOOM
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"this writer hit an OutOfMemoryError; cannot merge"
argument_list|)
throw|;
block|}
if|if
condition|(
name|merge
operator|.
name|info
operator|!=
literal|null
condition|)
block|{
comment|// mergeInit already done
return|return;
block|}
if|if
condition|(
name|merge
operator|.
name|isAborted
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// TODO: in the non-pool'd case this is somewhat
comment|// wasteful, because we open these readers, close them,
comment|// and then open them again for merging.  Maybe  we
comment|// could pre-pool them somehow in that case...
comment|// Lock order: IW -> BD
specifier|final
name|BufferedUpdatesStream
operator|.
name|ApplyDeletesResult
name|result
init|=
name|bufferedUpdatesStream
operator|.
name|applyDeletesAndUpdates
argument_list|(
name|readerPool
argument_list|,
name|merge
operator|.
name|segments
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|anyDeletes
condition|)
block|{
name|checkpoint
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|keepFullyDeletedSegments
operator|&&
name|result
operator|.
name|allDeleted
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"drop 100% deleted segments: "
operator|+
name|result
operator|.
name|allDeleted
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|result
operator|.
name|allDeleted
control|)
block|{
name|segmentInfos
operator|.
name|remove
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|pendingNumDocs
operator|.
name|addAndGet
argument_list|(
operator|-
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge
operator|.
name|segments
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|mergingSegments
operator|.
name|remove
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|merge
operator|.
name|segments
operator|.
name|remove
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|readerPool
operator|.
name|drop
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|checkpoint
argument_list|()
expr_stmt|;
block|}
comment|// Bind a new segment name here so even with
comment|// ConcurrentMergePolicy we keep deterministic segment
comment|// names.
specifier|final
name|String
name|mergeSegmentName
init|=
name|newSegmentName
argument_list|()
decl_stmt|;
name|SegmentInfo
name|si
init|=
operator|new
name|SegmentInfo
argument_list|(
name|directory
argument_list|,
name|Constants
operator|.
name|LUCENE_MAIN_VERSION
argument_list|,
name|mergeSegmentName
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|,
name|codec
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|details
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|details
operator|.
name|put
argument_list|(
literal|"mergeMaxNumSegments"
argument_list|,
literal|""
operator|+
name|merge
operator|.
name|maxNumSegments
argument_list|)
expr_stmt|;
name|details
operator|.
name|put
argument_list|(
literal|"mergeFactor"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|merge
operator|.
name|segments
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|setDiagnostics
argument_list|(
name|si
argument_list|,
name|SOURCE_MERGE
argument_list|,
name|details
argument_list|)
expr_stmt|;
name|merge
operator|.
name|setInfo
argument_list|(
operator|new
name|SegmentCommitInfo
argument_list|(
name|si
argument_list|,
literal|0
argument_list|,
operator|-
literal|1L
argument_list|,
operator|-
literal|1L
argument_list|,
operator|-
literal|1L
argument_list|)
argument_list|)
expr_stmt|;
comment|//    System.out.println("[" + Thread.currentThread().getName() + "] IW._mergeInit: " + segString(merge.segments) + " into " + si);
comment|// Lock order: IW -> BD
name|bufferedUpdatesStream
operator|.
name|prune
argument_list|(
name|segmentInfos
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"merge seg="
operator|+
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|name
operator|+
literal|" "
operator|+
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setDiagnostics
specifier|static
name|void
name|setDiagnostics
parameter_list|(
name|SegmentInfo
name|info
parameter_list|,
name|String
name|source
parameter_list|)
block|{
name|setDiagnostics
argument_list|(
name|info
argument_list|,
name|source
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|setDiagnostics
specifier|private
specifier|static
name|void
name|setDiagnostics
parameter_list|(
name|SegmentInfo
name|info
parameter_list|,
name|String
name|source
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|details
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|diagnostics
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|diagnostics
operator|.
name|put
argument_list|(
literal|"source"
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|diagnostics
operator|.
name|put
argument_list|(
literal|"lucene.version"
argument_list|,
name|Constants
operator|.
name|LUCENE_VERSION
argument_list|)
expr_stmt|;
name|diagnostics
operator|.
name|put
argument_list|(
literal|"os"
argument_list|,
name|Constants
operator|.
name|OS_NAME
argument_list|)
expr_stmt|;
name|diagnostics
operator|.
name|put
argument_list|(
literal|"os.arch"
argument_list|,
name|Constants
operator|.
name|OS_ARCH
argument_list|)
expr_stmt|;
name|diagnostics
operator|.
name|put
argument_list|(
literal|"os.version"
argument_list|,
name|Constants
operator|.
name|OS_VERSION
argument_list|)
expr_stmt|;
name|diagnostics
operator|.
name|put
argument_list|(
literal|"java.version"
argument_list|,
name|Constants
operator|.
name|JAVA_VERSION
argument_list|)
expr_stmt|;
name|diagnostics
operator|.
name|put
argument_list|(
literal|"java.vendor"
argument_list|,
name|Constants
operator|.
name|JAVA_VENDOR
argument_list|)
expr_stmt|;
name|diagnostics
operator|.
name|put
argument_list|(
literal|"timestamp"
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
operator|new
name|Date
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|details
operator|!=
literal|null
condition|)
block|{
name|diagnostics
operator|.
name|putAll
argument_list|(
name|details
argument_list|)
expr_stmt|;
block|}
name|info
operator|.
name|setDiagnostics
argument_list|(
name|diagnostics
argument_list|)
expr_stmt|;
block|}
comment|/** Does fininishing for a merge, which is fast but holds    *  the synchronized lock on IndexWriter instance. */
DECL|method|mergeFinish
specifier|final
specifier|synchronized
name|void
name|mergeFinish
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
block|{
comment|// forceMerge, addIndexes or finishMerges may be waiting
comment|// on merges to finish.
name|notifyAll
argument_list|()
expr_stmt|;
comment|// It's possible we are called twice, eg if there was an
comment|// exception inside mergeInit
if|if
condition|(
name|merge
operator|.
name|registerDone
condition|)
block|{
specifier|final
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|sourceSegments
init|=
name|merge
operator|.
name|segments
decl_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|sourceSegments
control|)
block|{
name|mergingSegments
operator|.
name|remove
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|merge
operator|.
name|registerDone
operator|=
literal|false
expr_stmt|;
block|}
name|runningMerges
operator|.
name|remove
argument_list|(
name|merge
argument_list|)
expr_stmt|;
block|}
DECL|method|closeMergeReaders
specifier|private
specifier|final
specifier|synchronized
name|void
name|closeMergeReaders
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|,
name|boolean
name|suppressExceptions
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|numSegments
init|=
name|merge
operator|.
name|readers
operator|.
name|size
argument_list|()
decl_stmt|;
name|Throwable
name|th
init|=
literal|null
decl_stmt|;
name|boolean
name|drop
init|=
operator|!
name|suppressExceptions
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSegments
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentReader
name|sr
init|=
name|merge
operator|.
name|readers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|sr
operator|!=
literal|null
condition|)
block|{
try|try
block|{
specifier|final
name|ReadersAndUpdates
name|rld
init|=
name|readerPool
operator|.
name|get
argument_list|(
name|sr
operator|.
name|getSegmentInfo
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// We still hold a ref so it should not have been removed:
assert|assert
name|rld
operator|!=
literal|null
assert|;
if|if
condition|(
name|drop
condition|)
block|{
name|rld
operator|.
name|dropChanges
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rld
operator|.
name|dropMergingUpdates
argument_list|()
expr_stmt|;
block|}
name|rld
operator|.
name|release
argument_list|(
name|sr
argument_list|)
expr_stmt|;
name|readerPool
operator|.
name|release
argument_list|(
name|rld
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop
condition|)
block|{
name|readerPool
operator|.
name|drop
argument_list|(
name|rld
operator|.
name|info
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|th
operator|==
literal|null
condition|)
block|{
name|th
operator|=
name|t
expr_stmt|;
block|}
block|}
name|merge
operator|.
name|readers
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If any error occured, throw it.
if|if
condition|(
operator|!
name|suppressExceptions
condition|)
block|{
name|IOUtils
operator|.
name|reThrow
argument_list|(
name|th
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Does the actual (time-consuming) work of the merge,    *  but without holding synchronized lock on IndexWriter    *  instance */
DECL|method|mergeMiddle
specifier|private
name|int
name|mergeMiddle
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
throws|throws
name|IOException
block|{
name|merge
operator|.
name|checkAborted
argument_list|(
name|directory
argument_list|)
expr_stmt|;
specifier|final
name|String
name|mergedName
init|=
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|name
decl_stmt|;
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|sourceSegments
init|=
name|merge
operator|.
name|segments
decl_stmt|;
name|IOContext
name|context
init|=
operator|new
name|IOContext
argument_list|(
name|merge
operator|.
name|getMergeInfo
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|MergeState
operator|.
name|CheckAbort
name|checkAbort
init|=
operator|new
name|MergeState
operator|.
name|CheckAbort
argument_list|(
name|merge
argument_list|,
name|directory
argument_list|)
decl_stmt|;
specifier|final
name|TrackingDirectoryWrapper
name|dirWrapper
init|=
operator|new
name|TrackingDirectoryWrapper
argument_list|(
name|directory
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"merging "
operator|+
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|merge
operator|.
name|readers
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
comment|// This is try/finally to make sure merger's readers are
comment|// closed:
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|int
name|segUpto
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|segUpto
operator|<
name|sourceSegments
operator|.
name|size
argument_list|()
condition|)
block|{
specifier|final
name|SegmentCommitInfo
name|info
init|=
name|sourceSegments
operator|.
name|get
argument_list|(
name|segUpto
argument_list|)
decl_stmt|;
comment|// Hold onto the "live" reader; we will use this to
comment|// commit merged deletes
specifier|final
name|ReadersAndUpdates
name|rld
init|=
name|readerPool
operator|.
name|get
argument_list|(
name|info
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// Carefully pull the most recent live docs and reader
name|SegmentReader
name|reader
decl_stmt|;
specifier|final
name|Bits
name|liveDocs
decl_stmt|;
specifier|final
name|int
name|delCount
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Must sync to ensure BufferedDeletesStream cannot change liveDocs,
comment|// pendingDeleteCount and field updates while we pull a copy:
name|reader
operator|=
name|rld
operator|.
name|getReaderForMerge
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|liveDocs
operator|=
name|rld
operator|.
name|getReadOnlyLiveDocs
argument_list|()
expr_stmt|;
name|delCount
operator|=
name|rld
operator|.
name|getPendingDeleteCount
argument_list|()
operator|+
name|info
operator|.
name|getDelCount
argument_list|()
expr_stmt|;
assert|assert
name|reader
operator|!=
literal|null
assert|;
assert|assert
name|rld
operator|.
name|verifyDocCounts
argument_list|()
assert|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
if|if
condition|(
name|rld
operator|.
name|getPendingDeleteCount
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"seg="
operator|+
name|segString
argument_list|(
name|info
argument_list|)
operator|+
literal|" delCount="
operator|+
name|info
operator|.
name|getDelCount
argument_list|()
operator|+
literal|" pendingDelCount="
operator|+
name|rld
operator|.
name|getPendingDeleteCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|.
name|getDelCount
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"seg="
operator|+
name|segString
argument_list|(
name|info
argument_list|)
operator|+
literal|" delCount="
operator|+
name|info
operator|.
name|getDelCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"seg="
operator|+
name|segString
argument_list|(
name|info
argument_list|)
operator|+
literal|" no deletes"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Deletes might have happened after we pulled the merge reader and
comment|// before we got a read-only copy of the segment's actual live docs
comment|// (taking pending deletes into account). In that case we need to
comment|// make a new reader with updated live docs and del count.
if|if
condition|(
name|reader
operator|.
name|numDeletedDocs
argument_list|()
operator|!=
name|delCount
condition|)
block|{
comment|// fix the reader's live docs and del count
assert|assert
name|delCount
operator|>
name|reader
operator|.
name|numDeletedDocs
argument_list|()
assert|;
comment|// beware of zombies
name|SegmentReader
name|newReader
init|=
operator|new
name|SegmentReader
argument_list|(
name|info
argument_list|,
name|reader
argument_list|,
name|liveDocs
argument_list|,
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|-
name|delCount
argument_list|)
decl_stmt|;
name|boolean
name|released
init|=
literal|false
decl_stmt|;
try|try
block|{
name|rld
operator|.
name|release
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|released
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|released
condition|)
block|{
name|newReader
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
name|reader
operator|=
name|newReader
expr_stmt|;
block|}
name|merge
operator|.
name|readers
operator|.
name|add
argument_list|(
name|reader
argument_list|)
expr_stmt|;
assert|assert
name|delCount
operator|<=
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|:
literal|"delCount="
operator|+
name|delCount
operator|+
literal|" info.docCount="
operator|+
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|+
literal|" rld.pendingDeleteCount="
operator|+
name|rld
operator|.
name|getPendingDeleteCount
argument_list|()
operator|+
literal|" info.getDelCount()="
operator|+
name|info
operator|.
name|getDelCount
argument_list|()
assert|;
name|segUpto
operator|++
expr_stmt|;
block|}
comment|//      System.out.println("[" + Thread.currentThread().getName() + "] IW.mergeMiddle: merging " + merge.getMergeReaders());
comment|// we pass merge.getMergeReaders() instead of merge.readers to allow the
comment|// OneMerge to return a view over the actual segments to merge
specifier|final
name|SegmentMerger
name|merger
init|=
operator|new
name|SegmentMerger
argument_list|(
name|merge
operator|.
name|getMergeReaders
argument_list|()
argument_list|,
name|merge
operator|.
name|info
operator|.
name|info
argument_list|,
name|infoStream
argument_list|,
name|dirWrapper
argument_list|,
name|checkAbort
argument_list|,
name|globalFieldNumberMap
argument_list|,
name|context
argument_list|,
name|config
operator|.
name|getCheckIntegrityAtMerge
argument_list|()
argument_list|)
decl_stmt|;
name|merge
operator|.
name|checkAborted
argument_list|(
name|directory
argument_list|)
expr_stmt|;
comment|// This is where all the work happens:
name|MergeState
name|mergeState
decl_stmt|;
name|boolean
name|success3
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|merger
operator|.
name|shouldMerge
argument_list|()
condition|)
block|{
comment|// would result in a 0 document segment: nothing to merge!
name|mergeState
operator|=
operator|new
name|MergeState
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|AtomicReader
argument_list|>
argument_list|()
argument_list|,
name|merge
operator|.
name|info
operator|.
name|info
argument_list|,
name|infoStream
argument_list|,
name|checkAbort
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mergeState
operator|=
name|merger
operator|.
name|merge
argument_list|()
expr_stmt|;
block|}
name|success3
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success3
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|deleter
operator|.
name|refresh
argument_list|(
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
assert|assert
name|mergeState
operator|.
name|segmentInfo
operator|==
name|merge
operator|.
name|info
operator|.
name|info
assert|;
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|setFiles
argument_list|(
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|dirWrapper
operator|.
name|getCreatedFiles
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Record which codec was used to write the segment
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
if|if
condition|(
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|==
literal|0
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"merge away fully deleted segments"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"merge codec="
operator|+
name|codec
operator|+
literal|" docCount="
operator|+
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|+
literal|"; merged segment has "
operator|+
operator|(
name|mergeState
operator|.
name|fieldInfos
operator|.
name|hasVectors
argument_list|()
condition|?
literal|"vectors"
else|:
literal|"no vectors"
operator|)
operator|+
literal|"; "
operator|+
operator|(
name|mergeState
operator|.
name|fieldInfos
operator|.
name|hasNorms
argument_list|()
condition|?
literal|"norms"
else|:
literal|"no norms"
operator|)
operator|+
literal|"; "
operator|+
operator|(
name|mergeState
operator|.
name|fieldInfos
operator|.
name|hasDocValues
argument_list|()
condition|?
literal|"docValues"
else|:
literal|"no docValues"
operator|)
operator|+
literal|"; "
operator|+
operator|(
name|mergeState
operator|.
name|fieldInfos
operator|.
name|hasProx
argument_list|()
condition|?
literal|"prox"
else|:
literal|"no prox"
operator|)
operator|+
literal|"; "
operator|+
operator|(
name|mergeState
operator|.
name|fieldInfos
operator|.
name|hasProx
argument_list|()
condition|?
literal|"freqs"
else|:
literal|"no freqs"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Very important to do this before opening the reader
comment|// because codec must know if prox was written for
comment|// this segment:
comment|//System.out.println("merger set hasProx=" + merger.hasProx() + " seg=" + merge.info.name);
name|boolean
name|useCompoundFile
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Guard segmentInfos
name|useCompoundFile
operator|=
name|mergePolicy
operator|.
name|useCompoundFile
argument_list|(
name|segmentInfos
argument_list|,
name|merge
operator|.
name|info
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useCompoundFile
condition|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|filesToRemove
init|=
name|merge
operator|.
name|info
operator|.
name|files
argument_list|()
decl_stmt|;
try|try
block|{
name|filesToRemove
operator|=
name|createCompoundFile
argument_list|(
name|infoStream
argument_list|,
name|directory
argument_list|,
name|checkAbort
argument_list|,
name|merge
operator|.
name|info
operator|.
name|info
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|merge
operator|.
name|isAborted
argument_list|()
condition|)
block|{
comment|// This can happen if rollback or close(false)
comment|// is called -- fall through to logic below to
comment|// remove the partially created CFS:
block|}
else|else
block|{
name|handleMergeException
argument_list|(
name|ioe
argument_list|,
name|merge
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|handleMergeException
argument_list|(
name|t
argument_list|,
name|merge
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"hit exception creating compound file during merge"
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
name|deleter
operator|.
name|deleteFile
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|mergedName
argument_list|,
literal|""
argument_list|,
name|IndexFileNames
operator|.
name|COMPOUND_FILE_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|deleteFile
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|mergedName
argument_list|,
literal|""
argument_list|,
name|IndexFileNames
operator|.
name|COMPOUND_FILE_ENTRIES_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|deleteNewFiles
argument_list|(
name|merge
operator|.
name|info
operator|.
name|files
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// So that, if we hit exc in deleteNewFiles (next)
comment|// or in commitMerge (later), we close the
comment|// per-segment readers in the finally clause below:
name|success
operator|=
literal|false
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// delete new non cfs files directly: they were never
comment|// registered with IFD
name|deleter
operator|.
name|deleteNewFiles
argument_list|(
name|filesToRemove
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge
operator|.
name|isAborted
argument_list|()
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"abort merge after building CFS"
argument_list|)
expr_stmt|;
block|}
name|deleter
operator|.
name|deleteFile
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|mergedName
argument_list|,
literal|""
argument_list|,
name|IndexFileNames
operator|.
name|COMPOUND_FILE_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|deleteFile
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|mergedName
argument_list|,
literal|""
argument_list|,
name|IndexFileNames
operator|.
name|COMPOUND_FILE_ENTRIES_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|setUseCompoundFile
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// So that, if we hit exc in commitMerge (later),
comment|// we close the per-segment readers in the finally
comment|// clause below:
name|success
operator|=
literal|false
expr_stmt|;
block|}
comment|// Have codec write SegmentInfo.  Must do this after
comment|// creating CFS so that 1) .si isn't slurped into CFS,
comment|// and 2) .si reflects useCompoundFile=true change
comment|// above:
name|boolean
name|success2
init|=
literal|false
decl_stmt|;
try|try
block|{
name|codec
operator|.
name|segmentInfoFormat
argument_list|()
operator|.
name|getSegmentInfoWriter
argument_list|()
operator|.
name|write
argument_list|(
name|directory
argument_list|,
name|merge
operator|.
name|info
operator|.
name|info
argument_list|,
name|mergeState
operator|.
name|fieldInfos
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|success2
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success2
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|deleter
operator|.
name|deleteNewFiles
argument_list|(
name|merge
operator|.
name|info
operator|.
name|files
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// TODO: ideally we would freeze merge.info here!!
comment|// because any changes after writing the .si will be
comment|// lost...
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"merged segment size=%.3f MB vs estimate=%.3f MB"
argument_list|,
name|merge
operator|.
name|info
operator|.
name|sizeInBytes
argument_list|()
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|,
name|merge
operator|.
name|estimatedMergeBytes
operator|/
literal|1024
operator|/
literal|1024.
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|IndexReaderWarmer
name|mergedSegmentWarmer
init|=
name|config
operator|.
name|getMergedSegmentWarmer
argument_list|()
decl_stmt|;
if|if
condition|(
name|poolReaders
operator|&&
name|mergedSegmentWarmer
operator|!=
literal|null
operator|&&
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
operator|!=
literal|0
condition|)
block|{
specifier|final
name|ReadersAndUpdates
name|rld
init|=
name|readerPool
operator|.
name|get
argument_list|(
name|merge
operator|.
name|info
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|SegmentReader
name|sr
init|=
name|rld
operator|.
name|getReader
argument_list|(
name|IOContext
operator|.
name|READ
argument_list|)
decl_stmt|;
try|try
block|{
name|mergedSegmentWarmer
operator|.
name|warm
argument_list|(
name|sr
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|rld
operator|.
name|release
argument_list|(
name|sr
argument_list|)
expr_stmt|;
name|readerPool
operator|.
name|release
argument_list|(
name|rld
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Force READ context because we merge deletes onto
comment|// this reader:
if|if
condition|(
operator|!
name|commitMerge
argument_list|(
name|merge
argument_list|,
name|mergeState
argument_list|)
condition|)
block|{
comment|// commitMerge will return false if this merge was
comment|// aborted
return|return
literal|0
return|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
comment|// Readers are already closed in commitMerge if we didn't hit
comment|// an exc:
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|closeMergeReaders
argument_list|(
name|merge
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|merge
operator|.
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
return|;
block|}
DECL|method|addMergeException
specifier|synchronized
name|void
name|addMergeException
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|)
block|{
assert|assert
name|merge
operator|.
name|getException
argument_list|()
operator|!=
literal|null
assert|;
if|if
condition|(
operator|!
name|mergeExceptions
operator|.
name|contains
argument_list|(
name|merge
argument_list|)
operator|&&
name|mergeGen
operator|==
name|merge
operator|.
name|mergeGen
condition|)
block|{
name|mergeExceptions
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
block|}
block|}
comment|// For test purposes.
DECL|method|getBufferedDeleteTermsSize
specifier|final
name|int
name|getBufferedDeleteTermsSize
parameter_list|()
block|{
return|return
name|docWriter
operator|.
name|getBufferedDeleteTermsSize
argument_list|()
return|;
block|}
comment|// For test purposes.
DECL|method|getNumBufferedDeleteTerms
specifier|final
name|int
name|getNumBufferedDeleteTerms
parameter_list|()
block|{
return|return
name|docWriter
operator|.
name|getNumBufferedDeleteTerms
argument_list|()
return|;
block|}
comment|// utility routines for tests
DECL|method|newestSegment
specifier|synchronized
name|SegmentCommitInfo
name|newestSegment
parameter_list|()
block|{
return|return
name|segmentInfos
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|?
name|segmentInfos
operator|.
name|info
argument_list|(
name|segmentInfos
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
else|:
literal|null
return|;
block|}
comment|/** Returns a string description of all segments, for    *  debugging.    *    * @lucene.internal */
DECL|method|segString
specifier|public
specifier|synchronized
name|String
name|segString
parameter_list|()
block|{
return|return
name|segString
argument_list|(
name|segmentInfos
argument_list|)
return|;
block|}
comment|/** Returns a string description of the specified    *  segments, for debugging.    *    * @lucene.internal */
DECL|method|segString
specifier|public
specifier|synchronized
name|String
name|segString
parameter_list|(
name|Iterable
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|infos
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|SegmentCommitInfo
name|info
range|:
name|infos
control|)
block|{
if|if
condition|(
name|buffer
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|.
name|append
argument_list|(
name|segString
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Returns a string description of the specified    *  segment, for debugging.    *    * @lucene.internal */
DECL|method|segString
specifier|public
specifier|synchronized
name|String
name|segString
parameter_list|(
name|SegmentCommitInfo
name|info
parameter_list|)
block|{
return|return
name|info
operator|.
name|toString
argument_list|(
name|info
operator|.
name|info
operator|.
name|dir
argument_list|,
name|numDeletedDocs
argument_list|(
name|info
argument_list|)
operator|-
name|info
operator|.
name|getDelCount
argument_list|()
argument_list|)
return|;
block|}
DECL|method|doWait
specifier|private
specifier|synchronized
name|void
name|doWait
parameter_list|()
block|{
comment|// NOTE: the callers of this method should in theory
comment|// be able to do simply wait(), but, as a defense
comment|// against thread timing hazards where notifyAll()
comment|// fails to be called, we wait for at most 1 second
comment|// and then return so caller can check if wait
comment|// conditions are satisfied:
try|try
block|{
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|ThreadInterruptedException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
DECL|field|keepFullyDeletedSegments
specifier|private
name|boolean
name|keepFullyDeletedSegments
decl_stmt|;
comment|/** Only for testing.    *    * @lucene.internal */
DECL|method|setKeepFullyDeletedSegments
name|void
name|setKeepFullyDeletedSegments
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
name|keepFullyDeletedSegments
operator|=
name|v
expr_stmt|;
block|}
DECL|method|getKeepFullyDeletedSegments
name|boolean
name|getKeepFullyDeletedSegments
parameter_list|()
block|{
return|return
name|keepFullyDeletedSegments
return|;
block|}
comment|// called only from assert
DECL|method|filesExist
specifier|private
name|boolean
name|filesExist
parameter_list|(
name|SegmentInfos
name|toSync
parameter_list|)
throws|throws
name|IOException
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|files
init|=
name|toSync
operator|.
name|files
argument_list|(
name|directory
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|String
name|fileName
range|:
name|files
control|)
block|{
assert|assert
name|slowFileExists
argument_list|(
name|directory
argument_list|,
name|fileName
argument_list|)
operator|:
literal|"file "
operator|+
name|fileName
operator|+
literal|" does not exist; files="
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|directory
operator|.
name|listAll
argument_list|()
argument_list|)
assert|;
comment|// If this trips it means we are missing a call to
comment|// .checkpoint somewhere, because by the time we
comment|// are called, deleter should know about every
comment|// file referenced by the current head
comment|// segmentInfos:
assert|assert
name|deleter
operator|.
name|exists
argument_list|(
name|fileName
argument_list|)
operator|:
literal|"IndexFileDeleter doesn't know about file "
operator|+
name|fileName
assert|;
block|}
return|return
literal|true
return|;
block|}
comment|// For infoStream output
DECL|method|toLiveInfos
specifier|synchronized
name|SegmentInfos
name|toLiveInfos
parameter_list|(
name|SegmentInfos
name|sis
parameter_list|)
block|{
specifier|final
name|SegmentInfos
name|newSIS
init|=
operator|new
name|SegmentInfos
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|SegmentCommitInfo
argument_list|,
name|SegmentCommitInfo
argument_list|>
name|liveSIS
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|segmentInfos
control|)
block|{
name|liveSIS
operator|.
name|put
argument_list|(
name|info
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|sis
control|)
block|{
name|SegmentCommitInfo
name|liveInfo
init|=
name|liveSIS
operator|.
name|get
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|liveInfo
operator|!=
literal|null
condition|)
block|{
name|info
operator|=
name|liveInfo
expr_stmt|;
block|}
name|newSIS
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
return|return
name|newSIS
return|;
block|}
comment|/** Walk through all files referenced by the current    *  segmentInfos and ask the Directory to sync each file,    *  if it wasn't already.  If that succeeds, then we    *  prepare a new segments_N file but do not fully commit    *  it. */
DECL|method|startCommit
specifier|private
name|void
name|startCommit
parameter_list|(
specifier|final
name|SegmentInfos
name|toSync
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|testPoint
argument_list|(
literal|"startStartCommit"
argument_list|)
assert|;
assert|assert
name|pendingCommit
operator|==
literal|null
assert|;
if|if
condition|(
name|hitOOM
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"this writer hit an OutOfMemoryError; cannot commit"
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"startCommit(): start"
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
assert|assert
name|lastCommitChangeCount
operator|<=
name|changeCount
operator|:
literal|"lastCommitChangeCount="
operator|+
name|lastCommitChangeCount
operator|+
literal|" changeCount="
operator|+
name|changeCount
assert|;
if|if
condition|(
name|pendingCommitChangeCount
operator|==
name|lastCommitChangeCount
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"  skip startCommit(): no changes pending"
argument_list|)
expr_stmt|;
block|}
name|deleter
operator|.
name|decRef
argument_list|(
name|filesToCommit
argument_list|)
expr_stmt|;
name|filesToCommit
operator|=
literal|null
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"startCommit index="
operator|+
name|segString
argument_list|(
name|toLiveInfos
argument_list|(
name|toSync
argument_list|)
argument_list|)
operator|+
literal|" changeCount="
operator|+
name|changeCount
argument_list|)
expr_stmt|;
block|}
assert|assert
name|filesExist
argument_list|(
name|toSync
argument_list|)
assert|;
block|}
assert|assert
name|testPoint
argument_list|(
literal|"midStartCommit"
argument_list|)
assert|;
name|boolean
name|pendingCommitSet
init|=
literal|false
decl_stmt|;
try|try
block|{
assert|assert
name|testPoint
argument_list|(
literal|"midStartCommit2"
argument_list|)
assert|;
synchronized|synchronized
init|(
name|this
init|)
block|{
assert|assert
name|pendingCommit
operator|==
literal|null
assert|;
assert|assert
name|segmentInfos
operator|.
name|getGeneration
argument_list|()
operator|==
name|toSync
operator|.
name|getGeneration
argument_list|()
assert|;
comment|// Exception here means nothing is prepared
comment|// (this method unwinds everything it did on
comment|// an exception)
name|toSync
operator|.
name|prepareCommit
argument_list|(
name|directory
argument_list|)
expr_stmt|;
comment|//System.out.println("DONE prepareCommit");
name|pendingCommitSet
operator|=
literal|true
expr_stmt|;
name|pendingCommit
operator|=
name|toSync
expr_stmt|;
block|}
comment|// This call can take a long time -- 10s of seconds
comment|// or more.  We do it without syncing on this:
name|boolean
name|success
init|=
literal|false
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|filesToSync
decl_stmt|;
try|try
block|{
name|filesToSync
operator|=
name|toSync
operator|.
name|files
argument_list|(
name|directory
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|directory
operator|.
name|sync
argument_list|(
name|filesToSync
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|pendingCommitSet
operator|=
literal|false
expr_stmt|;
name|pendingCommit
operator|=
literal|null
expr_stmt|;
name|toSync
operator|.
name|rollbackCommit
argument_list|(
name|directory
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"done all syncs: "
operator|+
name|filesToSync
argument_list|)
expr_stmt|;
block|}
assert|assert
name|testPoint
argument_list|(
literal|"midStartCommitSuccess"
argument_list|)
assert|;
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Have our master segmentInfos record the
comment|// generations we just prepared.  We do this
comment|// on error or success so we don't
comment|// double-write a segments_N file.
name|segmentInfos
operator|.
name|updateGeneration
argument_list|(
name|toSync
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pendingCommitSet
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"hit exception committing segments file"
argument_list|)
expr_stmt|;
block|}
comment|// Hit exception
name|deleter
operator|.
name|decRef
argument_list|(
name|filesToCommit
argument_list|)
expr_stmt|;
name|filesToCommit
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|)
block|{
name|handleOOM
argument_list|(
name|oom
argument_list|,
literal|"startCommit"
argument_list|)
expr_stmt|;
block|}
assert|assert
name|testPoint
argument_list|(
literal|"finishStartCommit"
argument_list|)
assert|;
block|}
comment|/**    * Returns<code>true</code> iff the index in the named directory is    * currently locked.    * @param directory the directory to check for a lock    * @throws IOException if there is a low-level IO error    */
DECL|method|isLocked
specifier|public
specifier|static
name|boolean
name|isLocked
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|directory
operator|.
name|makeLock
argument_list|(
name|WRITE_LOCK_NAME
argument_list|)
operator|.
name|isLocked
argument_list|()
return|;
block|}
comment|/**    * Forcibly unlocks the index in the named directory.    *<P>    * Caution: this should only be used by failure recovery code,    * when it is known that no other process nor thread is in fact    * currently accessing this index.    */
DECL|method|unlock
specifier|public
specifier|static
name|void
name|unlock
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
name|directory
operator|.
name|makeLock
argument_list|(
name|IndexWriter
operator|.
name|WRITE_LOCK_NAME
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** If {@link DirectoryReader#open(IndexWriter,boolean)} has    *  been called (ie, this writer is in near real-time    *  mode), then after a merge completes, this class can be    *  invoked to warm the reader on the newly merged    *  segment, before the merge commits.  This is not    *  required for near real-time search, but will reduce    *  search latency on opening a new near real-time reader    *  after a merge completes.    *    * @lucene.experimental    *    *<p><b>NOTE</b>: warm is called before any deletes have    * been carried over to the merged segment. */
DECL|class|IndexReaderWarmer
specifier|public
specifier|static
specifier|abstract
class|class
name|IndexReaderWarmer
block|{
comment|/** Sole constructor. (For invocation by subclass       *  constructors, typically implicit.) */
DECL|method|IndexReaderWarmer
specifier|protected
name|IndexReaderWarmer
parameter_list|()
block|{     }
comment|/** Invoked on the {@link AtomicReader} for the newly      *  merged segment, before that segment is made visible      *  to near-real-time readers. */
DECL|method|warm
specifier|public
specifier|abstract
name|void
name|warm
parameter_list|(
name|AtomicReader
name|reader
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
DECL|method|handleOOM
specifier|private
name|void
name|handleOOM
parameter_list|(
name|OutOfMemoryError
name|oom
parameter_list|,
name|String
name|location
parameter_list|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"hit OutOfMemoryError inside "
operator|+
name|location
argument_list|)
expr_stmt|;
block|}
name|hitOOM
operator|=
literal|true
expr_stmt|;
throw|throw
name|oom
throw|;
block|}
comment|// Used only by assert for testing.  Current points:
comment|//   startDoFlush
comment|//   startCommitMerge
comment|//   startStartCommit
comment|//   midStartCommit
comment|//   midStartCommit2
comment|//   midStartCommitSuccess
comment|//   finishStartCommit
comment|//   startCommitMergeDeletes
comment|//   startMergeInit
comment|//   DocumentsWriter.ThreadState.init start
DECL|method|testPoint
specifier|private
specifier|final
name|boolean
name|testPoint
parameter_list|(
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"TP"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"TP"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|nrtIsCurrent
specifier|synchronized
name|boolean
name|nrtIsCurrent
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|)
block|{
comment|//System.out.println("IW.nrtIsCurrent " + (infos.version == segmentInfos.version&& !docWriter.anyChanges()&& !bufferedDeletesStream.any()));
name|ensureOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"nrtIsCurrent: infoVersion matches: "
operator|+
operator|(
name|infos
operator|.
name|version
operator|==
name|segmentInfos
operator|.
name|version
operator|)
operator|+
literal|"; DW changes: "
operator|+
name|docWriter
operator|.
name|anyChanges
argument_list|()
operator|+
literal|"; BD changes: "
operator|+
name|bufferedUpdatesStream
operator|.
name|any
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|infos
operator|.
name|version
operator|==
name|segmentInfos
operator|.
name|version
operator|&&
operator|!
name|docWriter
operator|.
name|anyChanges
argument_list|()
operator|&&
operator|!
name|bufferedUpdatesStream
operator|.
name|any
argument_list|()
return|;
block|}
DECL|method|isClosed
specifier|synchronized
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|closed
return|;
block|}
comment|/** Expert: remove any index files that are no longer    *  used.    *    *<p> IndexWriter normally deletes unused files itself,    *  during indexing.  However, on Windows, which disallows    *  deletion of open files, if there is a reader open on    *  the index then those files cannot be deleted.  This is    *  fine, because IndexWriter will periodically retry    *  the deletion.</p>    *    *<p> However, IndexWriter doesn't try that often: only    *  on open, close, flushing a new segment, and finishing    *  a merge.  If you don't do any of these actions with your    *  IndexWriter, you'll see the unused files linger.  If    *  that's a problem, call this method to delete them    *  (once you've closed the open readers that were    *  preventing their deletion).     *      *<p> In addition, you can call this method to delete     *  unreferenced index commits. This might be useful if you     *  are using an {@link IndexDeletionPolicy} which holds    *  onto index commits until some criteria are met, but those    *  commits are no longer needed. Otherwise, those commits will    *  be deleted the next time commit() is called.    */
DECL|method|deleteUnusedFiles
specifier|public
specifier|synchronized
name|void
name|deleteUnusedFiles
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|deleter
operator|.
name|deletePendingFiles
argument_list|()
expr_stmt|;
name|deleter
operator|.
name|revisitPolicy
argument_list|()
expr_stmt|;
block|}
DECL|method|deletePendingFiles
specifier|private
specifier|synchronized
name|void
name|deletePendingFiles
parameter_list|()
throws|throws
name|IOException
block|{
name|deleter
operator|.
name|deletePendingFiles
argument_list|()
expr_stmt|;
block|}
comment|/**    * NOTE: this method creates a compound file for all files returned by    * info.files(). While, generally, this may include separate norms and    * deletion files, this SegmentInfo must not reference such files when this    * method is called, because they are not allowed within a compound file.    */
DECL|method|createCompoundFile
specifier|static
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|createCompoundFile
parameter_list|(
name|InfoStream
name|infoStream
parameter_list|,
name|Directory
name|directory
parameter_list|,
name|CheckAbort
name|checkAbort
parameter_list|,
specifier|final
name|SegmentInfo
name|info
parameter_list|,
name|IOContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|fileName
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|info
operator|.
name|name
argument_list|,
literal|""
argument_list|,
name|IndexFileNames
operator|.
name|COMPOUND_FILE_EXTENSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"IW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"IW"
argument_list|,
literal|"create compound file "
operator|+
name|fileName
argument_list|)
expr_stmt|;
block|}
comment|// Now merge all added files
name|Collection
argument_list|<
name|String
argument_list|>
name|files
init|=
name|info
operator|.
name|files
argument_list|()
decl_stmt|;
name|CompoundFileDirectory
name|cfsDir
init|=
operator|new
name|CompoundFileDirectory
argument_list|(
name|directory
argument_list|,
name|fileName
argument_list|,
name|context
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
for|for
control|(
name|String
name|file
range|:
name|files
control|)
block|{
name|directory
operator|.
name|copy
argument_list|(
name|cfsDir
argument_list|,
name|file
argument_list|,
name|file
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|checkAbort
operator|.
name|work
argument_list|(
name|directory
operator|.
name|fileLength
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|cfsDir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|cfsDir
argument_list|)
expr_stmt|;
try|try
block|{
name|directory
operator|.
name|deleteFile
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{         }
try|try
block|{
name|directory
operator|.
name|deleteFile
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|info
operator|.
name|name
argument_list|,
literal|""
argument_list|,
name|IndexFileNames
operator|.
name|COMPOUND_FILE_ENTRIES_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{         }
block|}
block|}
comment|// Replace all previous files with the CFS/CFE files:
name|Set
argument_list|<
name|String
argument_list|>
name|siFiles
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|siFiles
operator|.
name|add
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|siFiles
operator|.
name|add
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|info
operator|.
name|name
argument_list|,
literal|""
argument_list|,
name|IndexFileNames
operator|.
name|COMPOUND_FILE_ENTRIES_EXTENSION
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|setFiles
argument_list|(
name|siFiles
argument_list|)
expr_stmt|;
return|return
name|files
return|;
block|}
comment|/**    * Tries to delete the given files if unreferenced    * @param files the files to delete    * @throws IOException if an {@link IOException} occurs    * @see IndexFileDeleter#deleteNewFiles(Collection)    */
DECL|method|deleteNewFiles
specifier|synchronized
specifier|final
name|void
name|deleteNewFiles
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
throws|throws
name|IOException
block|{
name|deleter
operator|.
name|deleteNewFiles
argument_list|(
name|files
argument_list|)
expr_stmt|;
block|}
comment|/**    * Cleans up residuals from a segment that could not be entirely flushed due to an error    * @see IndexFileDeleter#refresh(String)     */
DECL|method|flushFailed
specifier|synchronized
specifier|final
name|void
name|flushFailed
parameter_list|(
name|SegmentInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|deleter
operator|.
name|refresh
argument_list|(
name|info
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
DECL|method|purge
specifier|final
name|int
name|purge
parameter_list|(
name|boolean
name|forced
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|docWriter
operator|.
name|purgeBuffer
argument_list|(
name|this
argument_list|,
name|forced
argument_list|)
return|;
block|}
DECL|method|applyDeletesAndPurge
specifier|final
name|void
name|applyDeletesAndPurge
parameter_list|(
name|boolean
name|forcePurge
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|purge
argument_list|(
name|forcePurge
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|applyAllDeletesAndUpdates
argument_list|()
expr_stmt|;
name|flushCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|doAfterSegmentFlushed
specifier|final
name|void
name|doAfterSegmentFlushed
parameter_list|(
name|boolean
name|triggerMerge
parameter_list|,
name|boolean
name|forcePurge
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|purge
argument_list|(
name|forcePurge
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|triggerMerge
condition|)
block|{
name|maybeMerge
argument_list|(
name|MergeTrigger
operator|.
name|SEGMENT_FLUSH
argument_list|,
name|UNBOUNDED_MAX_MERGE_SEGMENTS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|incRefDeleter
specifier|synchronized
name|void
name|incRefDeleter
parameter_list|(
name|SegmentInfos
name|segmentInfos
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|deleter
operator|.
name|incRef
argument_list|(
name|segmentInfos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|decRefDeleter
specifier|synchronized
name|void
name|decRefDeleter
parameter_list|(
name|SegmentInfos
name|segmentInfos
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|deleter
operator|.
name|decRef
argument_list|(
name|segmentInfos
argument_list|)
expr_stmt|;
block|}
DECL|method|processEvents
specifier|private
name|boolean
name|processEvents
parameter_list|(
name|boolean
name|triggerMerge
parameter_list|,
name|boolean
name|forcePurge
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|processEvents
argument_list|(
name|eventQueue
argument_list|,
name|triggerMerge
argument_list|,
name|forcePurge
argument_list|)
return|;
block|}
DECL|method|processEvents
specifier|private
name|boolean
name|processEvents
parameter_list|(
name|Queue
argument_list|<
name|Event
argument_list|>
name|queue
parameter_list|,
name|boolean
name|triggerMerge
parameter_list|,
name|boolean
name|forcePurge
parameter_list|)
throws|throws
name|IOException
block|{
name|Event
name|event
decl_stmt|;
name|boolean
name|processed
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|(
name|event
operator|=
name|queue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|processed
operator|=
literal|true
expr_stmt|;
name|event
operator|.
name|process
argument_list|(
name|this
argument_list|,
name|triggerMerge
argument_list|,
name|forcePurge
argument_list|)
expr_stmt|;
block|}
return|return
name|processed
return|;
block|}
comment|/**    * Interface for internal atomic events. See {@link DocumentsWriter} for details. Events are executed concurrently and no order is guaranteed.    * Each event should only rely on the serializeability within it's process method. All actions that must happen before or after a certain action must be    * encoded inside the {@link #process(IndexWriter, boolean, boolean)} method.    *    */
DECL|interface|Event
specifier|static
interface|interface
name|Event
block|{
comment|/**      * Processes the event. This method is called by the {@link IndexWriter}      * passed as the first argument.      *       * @param writer      *          the {@link IndexWriter} that executes the event.      * @param triggerMerge      *<code>false</code> iff this event should not trigger any segment merges      * @param clearBuffers      *<code>true</code> iff this event should clear all buffers associated with the event.      * @throws IOException      *           if an {@link IOException} occurs      */
DECL|method|process
name|void
name|process
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|boolean
name|triggerMerge
parameter_list|,
name|boolean
name|clearBuffers
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
comment|/** Used only by asserts: returns true if the file exists    *  (can be opened), false if it cannot be opened, and    *  (unlike Java's File.exists) throws IOException if    *  there's some unexpected error. */
DECL|method|slowFileExists
specifier|private
specifier|static
name|boolean
name|slowFileExists
parameter_list|(
name|Directory
name|dir
parameter_list|,
name|String
name|fileName
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|dir
operator|.
name|openInput
argument_list|(
name|fileName
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFileException
decl||
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/** Anything that will add N docs to the index should reserve first to    *  make sure it's allowed.  This will throw {@code    *  IllegalStateException} if it's not allowed. */
DECL|method|reserveDocs
specifier|private
name|void
name|reserveDocs
parameter_list|(
name|int
name|numDocs
parameter_list|)
block|{
if|if
condition|(
name|pendingNumDocs
operator|.
name|addAndGet
argument_list|(
name|numDocs
argument_list|)
operator|>
name|actualMaxDocs
condition|)
block|{
comment|// Reserve failed
name|pendingNumDocs
operator|.
name|addAndGet
argument_list|(
operator|-
name|numDocs
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"number of documents in the index cannot exceed "
operator|+
name|actualMaxDocs
argument_list|)
throw|;
block|}
block|}
block|}
end_class
end_unit
