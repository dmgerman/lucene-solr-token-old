begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MergePolicy
operator|.
name|OneMerge
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CollectionUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ThreadInterruptedException
import|;
end_import
begin_comment
comment|/** A {@link MergeScheduler} that runs each merge using a  *  separate thread.  *  *<p>Specify the max number of threads that may run at  *  once, and the maximum number of simultaneous merges  *  with {@link #setMaxMergesAndThreads}.</p>  *  *<p>If the number of merges exceeds the max number of threads   *  then the largest merges are paused until one of the smaller  *  merges completes.</p>  *  *<p>If more than {@link #getMaxMergeCount} merges are  *  requested then this class will forcefully throttle the  *  incoming threads by pausing until one more more merges  *  complete.</p>  *  *<p>This class attempts to detect whether the index is  *  on rotational storage (traditional hard drive) or not  *  (e.g. solid-state disk) and changes the default max merge  *  and thread count accordingly.  This detection is currently  *  Linux-only, and relies on the OS to put the right value  *  into /sys/block/&lt;dev&gt;/block/rotational.  For all  *  other operating systems it currently assumes a rotational  *  disk for backwards compatibility.  To enable default  *  settings for spinning or solid state disks for such  *  operating systems, use {@link #setDefaultMaxMergesAndThreads(boolean)}.  */
end_comment
begin_class
DECL|class|ConcurrentMergeScheduler
specifier|public
class|class
name|ConcurrentMergeScheduler
extends|extends
name|MergeScheduler
block|{
comment|/** Dynamic default for {@code maxThreadCount} and {@code maxMergeCount},    *  used to detect whether the index is backed by an SSD or rotational disk and    *  set {@code maxThreadCount} accordingly.  If it's an SSD,    *  {@code maxThreadCount} is set to {@code max(1, min(4, cpuCoreCount/2))},    *  otherwise 1.  Note that detection only currently works on    *  Linux; other platforms will assume the index is not on an SSD. */
DECL|field|AUTO_DETECT_MERGES_AND_THREADS
specifier|public
specifier|static
specifier|final
name|int
name|AUTO_DETECT_MERGES_AND_THREADS
init|=
operator|-
literal|1
decl_stmt|;
comment|/** List of currently active {@link MergeThread}s. */
DECL|field|mergeThreads
specifier|protected
specifier|final
name|List
argument_list|<
name|MergeThread
argument_list|>
name|mergeThreads
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Max number of merge threads allowed to be running at
comment|// once.  When there are more merges then this, we
comment|// forcefully pause the larger ones, letting the smaller
comment|// ones run, up until maxMergeCount merges at which point
comment|// we forcefully pause incoming threads (that presumably
comment|// are the ones causing so much merging).
DECL|field|maxThreadCount
specifier|private
name|int
name|maxThreadCount
init|=
name|AUTO_DETECT_MERGES_AND_THREADS
decl_stmt|;
comment|// Max number of merges we accept before forcefully
comment|// throttling the incoming threads
DECL|field|maxMergeCount
specifier|private
name|int
name|maxMergeCount
init|=
name|AUTO_DETECT_MERGES_AND_THREADS
decl_stmt|;
comment|/** How many {@link MergeThread}s have kicked off (this is use    *  to name them). */
DECL|field|mergeThreadCount
specifier|protected
name|int
name|mergeThreadCount
decl_stmt|;
comment|/** Floor for IO write rate limit (we will never go any lower than this) */
DECL|field|MIN_MERGE_MB_PER_SEC
specifier|private
specifier|static
specifier|final
name|double
name|MIN_MERGE_MB_PER_SEC
init|=
literal|5.0
decl_stmt|;
comment|/** Ceiling for IO write rate limit (we will never go any higher than this) */
DECL|field|MAX_MERGE_MB_PER_SEC
specifier|private
specifier|static
specifier|final
name|double
name|MAX_MERGE_MB_PER_SEC
init|=
literal|10240.0
decl_stmt|;
comment|/** Initial value for IO write rate limit when doAutoIOThrottle is true */
DECL|field|START_MB_PER_SEC
specifier|private
specifier|static
specifier|final
name|double
name|START_MB_PER_SEC
init|=
literal|20.0
decl_stmt|;
comment|/** Merges below this size are not counted in the maxThreadCount, i.e. they can freely run in their own thread (up until maxMergeCount). */
DECL|field|MIN_BIG_MERGE_MB
specifier|private
specifier|static
specifier|final
name|double
name|MIN_BIG_MERGE_MB
init|=
literal|50.0
decl_stmt|;
comment|/** Current IO writes throttle rate */
DECL|field|targetMBPerSec
specifier|protected
name|double
name|targetMBPerSec
init|=
name|START_MB_PER_SEC
decl_stmt|;
comment|/** true if we should rate-limit writes for each merge */
DECL|field|doAutoIOThrottle
specifier|private
name|boolean
name|doAutoIOThrottle
init|=
literal|true
decl_stmt|;
DECL|field|forceMergeMBPerSec
specifier|private
name|double
name|forceMergeMBPerSec
init|=
name|Double
operator|.
name|POSITIVE_INFINITY
decl_stmt|;
comment|/** Sole constructor, with all settings set to default    *  values. */
DECL|method|ConcurrentMergeScheduler
specifier|public
name|ConcurrentMergeScheduler
parameter_list|()
block|{   }
comment|/**    * Expert: directly set the maximum number of merge threads and    * simultaneous merges allowed.    *     * @param maxMergeCount the max # simultaneous merges that are allowed.    *       If a merge is necessary yet we already have this many    *       threads running, the incoming thread (that is calling    *       add/updateDocument) will block until a merge thread    *       has completed.  Note that we will only run the    *       smallest<code>maxThreadCount</code> merges at a time.    * @param maxThreadCount the max # simultaneous merge threads that should    *       be running at once.  This must be&lt;=<code>maxMergeCount</code>    */
DECL|method|setMaxMergesAndThreads
specifier|public
specifier|synchronized
name|void
name|setMaxMergesAndThreads
parameter_list|(
name|int
name|maxMergeCount
parameter_list|,
name|int
name|maxThreadCount
parameter_list|)
block|{
if|if
condition|(
name|maxMergeCount
operator|==
name|AUTO_DETECT_MERGES_AND_THREADS
operator|&&
name|maxThreadCount
operator|==
name|AUTO_DETECT_MERGES_AND_THREADS
condition|)
block|{
comment|// OK
name|this
operator|.
name|maxMergeCount
operator|=
name|AUTO_DETECT_MERGES_AND_THREADS
expr_stmt|;
name|this
operator|.
name|maxThreadCount
operator|=
name|AUTO_DETECT_MERGES_AND_THREADS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|maxMergeCount
operator|==
name|AUTO_DETECT_MERGES_AND_THREADS
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"both maxMergeCount and maxThreadCount must be AUTO_DETECT_MERGES_AND_THREADS"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|maxThreadCount
operator|==
name|AUTO_DETECT_MERGES_AND_THREADS
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"both maxMergeCount and maxThreadCount must be AUTO_DETECT_MERGES_AND_THREADS"
argument_list|)
throw|;
block|}
else|else
block|{
if|if
condition|(
name|maxThreadCount
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxThreadCount should be at least 1"
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxMergeCount
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxMergeCount should be at least 1"
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxThreadCount
operator|>
name|maxMergeCount
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxThreadCount should be<= maxMergeCount (= "
operator|+
name|maxMergeCount
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|this
operator|.
name|maxThreadCount
operator|=
name|maxThreadCount
expr_stmt|;
name|this
operator|.
name|maxMergeCount
operator|=
name|maxMergeCount
expr_stmt|;
block|}
block|}
comment|/** Sets max merges and threads to proper defaults for rotational    *  or non-rotational storage.    *    * @param spins true to set defaults best for traditional rotatational storage (spinning disks),     *        else false (e.g. for solid-state disks)    */
DECL|method|setDefaultMaxMergesAndThreads
specifier|public
specifier|synchronized
name|void
name|setDefaultMaxMergesAndThreads
parameter_list|(
name|boolean
name|spins
parameter_list|)
block|{
if|if
condition|(
name|spins
condition|)
block|{
name|maxThreadCount
operator|=
literal|1
expr_stmt|;
name|maxMergeCount
operator|=
literal|6
expr_stmt|;
block|}
else|else
block|{
name|maxThreadCount
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|Math
operator|.
name|min
argument_list|(
literal|4
argument_list|,
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|maxMergeCount
operator|=
name|maxThreadCount
operator|+
literal|5
expr_stmt|;
block|}
block|}
comment|/** Set the per-merge IO throttle rate for forced merges (default: {@code Double.POSITIVE_INFINITY}). */
DECL|method|setForceMergeMBPerSec
specifier|public
specifier|synchronized
name|void
name|setForceMergeMBPerSec
parameter_list|(
name|double
name|v
parameter_list|)
block|{
name|forceMergeMBPerSec
operator|=
name|v
expr_stmt|;
name|updateMergeThreads
argument_list|()
expr_stmt|;
block|}
comment|/** Get the per-merge IO throttle rate for forced merges. */
DECL|method|getForceMergeMBPerSec
specifier|public
specifier|synchronized
name|double
name|getForceMergeMBPerSec
parameter_list|()
block|{
return|return
name|forceMergeMBPerSec
return|;
block|}
comment|/** Turn on dynamic IO throttling, to adaptively rate limit writes    *  bytes/sec to the minimal rate necessary so merges do not fall behind.    *  By default this is enabled. */
DECL|method|enableAutoIOThrottle
specifier|public
specifier|synchronized
name|void
name|enableAutoIOThrottle
parameter_list|()
block|{
name|doAutoIOThrottle
operator|=
literal|true
expr_stmt|;
name|targetMBPerSec
operator|=
name|START_MB_PER_SEC
expr_stmt|;
name|updateMergeThreads
argument_list|()
expr_stmt|;
block|}
comment|/** Turn off auto IO throttling.    *    * @see #enableAutoIOThrottle */
DECL|method|disableAutoIOThrottle
specifier|public
specifier|synchronized
name|void
name|disableAutoIOThrottle
parameter_list|()
block|{
name|doAutoIOThrottle
operator|=
literal|false
expr_stmt|;
name|updateMergeThreads
argument_list|()
expr_stmt|;
block|}
comment|/** Returns the currently set per-merge IO writes rate limit, if {@link #enableAutoIOThrottle}    *  was called, else {@code Double.POSITIVE_INFINITY}. */
DECL|method|getIORateLimitMBPerSec
specifier|public
specifier|synchronized
name|double
name|getIORateLimitMBPerSec
parameter_list|()
block|{
if|if
condition|(
name|doAutoIOThrottle
condition|)
block|{
return|return
name|targetMBPerSec
return|;
block|}
else|else
block|{
return|return
name|Double
operator|.
name|POSITIVE_INFINITY
return|;
block|}
block|}
comment|/** Returns {@code maxThreadCount}.    *    * @see #setMaxMergesAndThreads(int, int) */
DECL|method|getMaxThreadCount
specifier|public
specifier|synchronized
name|int
name|getMaxThreadCount
parameter_list|()
block|{
return|return
name|maxThreadCount
return|;
block|}
comment|/** See {@link #setMaxMergesAndThreads}. */
DECL|method|getMaxMergeCount
specifier|public
specifier|synchronized
name|int
name|getMaxMergeCount
parameter_list|()
block|{
return|return
name|maxMergeCount
return|;
block|}
DECL|method|removeMergeThread
specifier|synchronized
name|void
name|removeMergeThread
parameter_list|(
name|MergeThread
name|thread
parameter_list|)
block|{
name|boolean
name|result
init|=
name|mergeThreads
operator|.
name|remove
argument_list|(
name|thread
argument_list|)
decl_stmt|;
assert|assert
name|result
assert|;
block|}
comment|/**    * Called whenever the running merges have changed, to set merge IO limits.    * This method sorts the merge threads by their merge size in    * descending order and then pauses/unpauses threads from first to last --    * that way, smaller merges are guaranteed to run before larger ones.    */
DECL|method|updateMergeThreads
specifier|protected
specifier|synchronized
name|void
name|updateMergeThreads
parameter_list|()
block|{
comment|// Only look at threads that are alive& not in the
comment|// process of stopping (ie have an active merge):
specifier|final
name|List
argument_list|<
name|MergeThread
argument_list|>
name|activeMerges
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|threadIdx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|threadIdx
operator|<
name|mergeThreads
operator|.
name|size
argument_list|()
condition|)
block|{
specifier|final
name|MergeThread
name|mergeThread
init|=
name|mergeThreads
operator|.
name|get
argument_list|(
name|threadIdx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mergeThread
operator|.
name|isAlive
argument_list|()
condition|)
block|{
comment|// Prune any dead threads
name|mergeThreads
operator|.
name|remove
argument_list|(
name|threadIdx
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|activeMerges
operator|.
name|add
argument_list|(
name|mergeThread
argument_list|)
expr_stmt|;
name|threadIdx
operator|++
expr_stmt|;
block|}
comment|// Sort the merge threads, largest first:
name|CollectionUtil
operator|.
name|timSort
argument_list|(
name|activeMerges
argument_list|)
expr_stmt|;
specifier|final
name|int
name|activeMergeCount
init|=
name|activeMerges
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|bigMergeCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|threadIdx
operator|=
name|activeMergeCount
operator|-
literal|1
init|;
name|threadIdx
operator|>=
literal|0
condition|;
name|threadIdx
operator|--
control|)
block|{
name|MergeThread
name|mergeThread
init|=
name|activeMerges
operator|.
name|get
argument_list|(
name|threadIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergeThread
operator|.
name|merge
operator|.
name|estimatedMergeBytes
operator|>
name|MIN_BIG_MERGE_MB
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
name|bigMergeCount
operator|=
literal|1
operator|+
name|threadIdx
expr_stmt|;
break|break;
block|}
block|}
name|long
name|now
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|StringBuilder
name|message
decl_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"updateMergeThreads ioThrottle=%s targetMBPerSec=%.1f MB/sec"
argument_list|,
name|doAutoIOThrottle
argument_list|,
name|targetMBPerSec
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
operator|=
literal|null
expr_stmt|;
block|}
for|for
control|(
name|threadIdx
operator|=
literal|0
init|;
name|threadIdx
operator|<
name|activeMergeCount
condition|;
name|threadIdx
operator|++
control|)
block|{
name|MergeThread
name|mergeThread
init|=
name|activeMerges
operator|.
name|get
argument_list|(
name|threadIdx
argument_list|)
decl_stmt|;
name|OneMerge
name|merge
init|=
name|mergeThread
operator|.
name|merge
decl_stmt|;
comment|// pause the thread if maxThreadCount is smaller than the number of merge threads.
specifier|final
name|boolean
name|doPause
init|=
name|threadIdx
operator|<
name|bigMergeCount
operator|-
name|maxThreadCount
decl_stmt|;
name|double
name|newMBPerSec
decl_stmt|;
if|if
condition|(
name|doPause
condition|)
block|{
name|newMBPerSec
operator|=
literal|0.0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|merge
operator|.
name|maxNumSegments
operator|!=
operator|-
literal|1
condition|)
block|{
name|newMBPerSec
operator|=
name|forceMergeMBPerSec
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|doAutoIOThrottle
operator|==
literal|false
condition|)
block|{
name|newMBPerSec
operator|=
name|Double
operator|.
name|POSITIVE_INFINITY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|merge
operator|.
name|estimatedMergeBytes
operator|<
name|MIN_BIG_MERGE_MB
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
comment|// Don't rate limit small merges:
name|newMBPerSec
operator|=
name|Double
operator|.
name|POSITIVE_INFINITY
expr_stmt|;
block|}
else|else
block|{
name|newMBPerSec
operator|=
name|targetMBPerSec
expr_stmt|;
block|}
name|double
name|curMBPerSec
init|=
name|merge
operator|.
name|rateLimiter
operator|.
name|getMBPerSec
argument_list|()
decl_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|long
name|mergeStartNS
init|=
name|merge
operator|.
name|mergeStartNS
decl_stmt|;
if|if
condition|(
name|mergeStartNS
operator|==
operator|-
literal|1
condition|)
block|{
comment|// IndexWriter didn't start the merge yet:
name|mergeStartNS
operator|=
name|now
expr_stmt|;
block|}
name|message
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"merge thread %s estSize=%.1f MB (written=%.1f MB) runTime=%.1fs (stopped=%.1fs, paused=%.1fs) rate=%s\n"
argument_list|,
name|mergeThread
operator|.
name|getName
argument_list|()
argument_list|,
name|bytesToMB
argument_list|(
name|merge
operator|.
name|estimatedMergeBytes
argument_list|)
argument_list|,
name|bytesToMB
argument_list|(
name|merge
operator|.
name|rateLimiter
operator|.
name|totalBytesWritten
argument_list|)
argument_list|,
name|nsToSec
argument_list|(
name|now
operator|-
name|mergeStartNS
argument_list|)
argument_list|,
name|nsToSec
argument_list|(
name|merge
operator|.
name|rateLimiter
operator|.
name|getTotalStoppedNS
argument_list|()
argument_list|)
argument_list|,
name|nsToSec
argument_list|(
name|merge
operator|.
name|rateLimiter
operator|.
name|getTotalPausedNS
argument_list|()
argument_list|)
argument_list|,
name|rateToString
argument_list|(
name|merge
operator|.
name|rateLimiter
operator|.
name|getMBPerSec
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newMBPerSec
operator|!=
name|curMBPerSec
condition|)
block|{
if|if
condition|(
name|newMBPerSec
operator|==
literal|0.0
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
literal|"  now stop"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curMBPerSec
operator|==
literal|0.0
condition|)
block|{
if|if
condition|(
name|newMBPerSec
operator|==
name|Double
operator|.
name|POSITIVE_INFINITY
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
literal|"  now resume"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"  now resume to %.1f MB/sec"
argument_list|,
name|newMBPerSec
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|message
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"  now change from %.1f MB/sec to %.1f MB/sec"
argument_list|,
name|curMBPerSec
argument_list|,
name|newMBPerSec
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|curMBPerSec
operator|==
literal|0.0
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
literal|"  leave stopped"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"  leave running at %.1f MB/sec"
argument_list|,
name|curMBPerSec
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|merge
operator|.
name|rateLimiter
operator|.
name|setMBPerSec
argument_list|(
name|newMBPerSec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
name|message
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|initDynamicDefaults
specifier|private
specifier|synchronized
name|void
name|initDynamicDefaults
parameter_list|(
name|IndexWriter
name|writer
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|maxThreadCount
operator|==
name|AUTO_DETECT_MERGES_AND_THREADS
condition|)
block|{
name|boolean
name|spins
init|=
name|IOUtils
operator|.
name|spins
argument_list|(
name|writer
operator|.
name|getDirectory
argument_list|()
argument_list|)
decl_stmt|;
name|setDefaultMaxMergesAndThreads
argument_list|(
name|spins
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"initDynamicDefaults spins="
operator|+
name|spins
operator|+
literal|" maxThreadCount="
operator|+
name|maxThreadCount
operator|+
literal|" maxMergeCount="
operator|+
name|maxMergeCount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|rateToString
specifier|private
specifier|static
name|String
name|rateToString
parameter_list|(
name|double
name|mbPerSec
parameter_list|)
block|{
if|if
condition|(
name|mbPerSec
operator|==
literal|0.0
condition|)
block|{
return|return
literal|"stopped"
return|;
block|}
elseif|else
if|if
condition|(
name|mbPerSec
operator|==
name|Double
operator|.
name|POSITIVE_INFINITY
condition|)
block|{
return|return
literal|"unlimited"
return|;
block|}
else|else
block|{
return|return
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%.1f MB/sec"
argument_list|,
name|mbPerSec
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
name|sync
argument_list|()
expr_stmt|;
block|}
comment|/** Wait for any running merge threads to finish. This call is not interruptible as used by {@link #close()}. */
DECL|method|sync
specifier|public
name|void
name|sync
parameter_list|()
block|{
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|MergeThread
name|toSync
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
for|for
control|(
name|MergeThread
name|t
range|:
name|mergeThreads
control|)
block|{
if|if
condition|(
name|t
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|toSync
operator|=
name|t
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|toSync
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|toSync
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// ignore this Exception, we will retry until all threads are dead
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
finally|finally
block|{
comment|// finally, restore interrupt status:
if|if
condition|(
name|interrupted
condition|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns the number of merge threads that are alive. Note that this number    * is&le; {@link #mergeThreads} size.    */
DECL|method|mergeThreadCount
specifier|protected
specifier|synchronized
name|int
name|mergeThreadCount
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|MergeThread
name|mergeThread
range|:
name|mergeThreads
control|)
block|{
if|if
condition|(
name|mergeThread
operator|.
name|isAlive
argument_list|()
operator|&&
name|mergeThread
operator|.
name|merge
operator|.
name|rateLimiter
operator|.
name|getAbort
argument_list|()
operator|==
literal|false
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
annotation|@
name|Override
DECL|method|merge
specifier|public
specifier|synchronized
name|void
name|merge
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|MergeTrigger
name|trigger
parameter_list|,
name|boolean
name|newMergesFound
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|Thread
operator|.
name|holdsLock
argument_list|(
name|writer
argument_list|)
assert|;
name|initDynamicDefaults
argument_list|(
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|trigger
operator|==
name|MergeTrigger
operator|.
name|CLOSING
condition|)
block|{
comment|// Disable throttling on close:
name|targetMBPerSec
operator|=
name|MAX_MERGE_MB_PER_SEC
expr_stmt|;
name|updateMergeThreads
argument_list|()
expr_stmt|;
block|}
comment|// First, quickly run through the newly proposed merges
comment|// and add any orthogonal merges (ie a merge not
comment|// involving segments already pending to be merged) to
comment|// the queue.  If we are way behind on merging, many of
comment|// these newly proposed merges will likely already be
comment|// registered.
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"now merge"
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"  index: "
operator|+
name|writer
operator|.
name|segString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Iterate, pulling from the IndexWriter's queue of
comment|// pending merges, until it's empty:
while|while
condition|(
literal|true
condition|)
block|{
name|maybeStall
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|OneMerge
name|merge
init|=
name|writer
operator|.
name|getNextMerge
argument_list|()
decl_stmt|;
if|if
condition|(
name|merge
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"  no more merges pending; now return"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|updateIOThrottle
argument_list|(
name|merge
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"  consider merge "
operator|+
name|writer
operator|.
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// OK to spawn a new merge thread to handle this
comment|// merge:
specifier|final
name|MergeThread
name|merger
init|=
name|getMergeThread
argument_list|(
name|writer
argument_list|,
name|merge
argument_list|)
decl_stmt|;
name|mergeThreads
operator|.
name|add
argument_list|(
name|merger
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"    launch new thread ["
operator|+
name|merger
operator|.
name|getName
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|merger
operator|.
name|start
argument_list|()
expr_stmt|;
name|updateMergeThreads
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|writer
operator|.
name|mergeFinish
argument_list|(
name|merge
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** This is invoked by {@link #merge} to possibly stall the incoming    *  thread when there are too many merges running or pending.  The     *  default behavior is to force this thread, which is producing too    *  many segments for merging to keep up, to wait until merges catch    *  up. Applications that can take other less drastic measures, such    *  as limiting how many threads are allowed to index, can do nothing    *  here and throttle elsewhere. */
DECL|method|maybeStall
specifier|protected
specifier|synchronized
name|void
name|maybeStall
parameter_list|(
name|IndexWriter
name|writer
parameter_list|)
block|{
name|long
name|startStallTime
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|writer
operator|.
name|hasPendingMerges
argument_list|()
operator|&&
name|mergeThreadCount
argument_list|()
operator|>=
name|maxMergeCount
condition|)
block|{
comment|// This means merging has fallen too far behind: we
comment|// have already created maxMergeCount threads, and
comment|// now there's at least one more merge pending.
comment|// Note that only maxThreadCount of
comment|// those created merge threads will actually be
comment|// running; the rest will be paused (see
comment|// updateMergeThreads).  We stall this producer
comment|// thread to prevent creation of new segments,
comment|// until merging has caught up:
if|if
condition|(
name|verbose
argument_list|()
operator|&&
name|startStallTime
operator|==
literal|0
condition|)
block|{
name|message
argument_list|(
literal|"    too many merges; stalling..."
argument_list|)
expr_stmt|;
block|}
name|startStallTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Only wait 0.25 seconds, so if all merges are aborted (by IW.rollback) we notice:
name|wait
argument_list|(
literal|250
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|ThreadInterruptedException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
if|if
condition|(
name|startStallTime
operator|!=
literal|0
condition|)
block|{
name|message
argument_list|(
literal|"  stalled for "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startStallTime
operator|)
operator|+
literal|" msec"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Does the actual merge, by calling {@link IndexWriter#merge} */
DECL|method|doMerge
specifier|protected
name|void
name|doMerge
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|OneMerge
name|merge
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|merge
argument_list|(
name|merge
argument_list|)
expr_stmt|;
block|}
comment|/** Create and return a new MergeThread */
DECL|method|getMergeThread
specifier|protected
specifier|synchronized
name|MergeThread
name|getMergeThread
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|OneMerge
name|merge
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MergeThread
name|thread
init|=
operator|new
name|MergeThread
argument_list|(
name|writer
argument_list|,
name|merge
argument_list|)
decl_stmt|;
name|thread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|thread
operator|.
name|setName
argument_list|(
literal|"Lucene Merge Thread #"
operator|+
name|mergeThreadCount
operator|++
argument_list|)
expr_stmt|;
return|return
name|thread
return|;
block|}
comment|/** Runs a merge thread to execute a single merge, then exits. */
DECL|class|MergeThread
specifier|protected
class|class
name|MergeThread
extends|extends
name|Thread
implements|implements
name|Comparable
argument_list|<
name|MergeThread
argument_list|>
block|{
DECL|field|writer
specifier|final
name|IndexWriter
name|writer
decl_stmt|;
DECL|field|merge
specifier|final
name|OneMerge
name|merge
decl_stmt|;
comment|/** Sole constructor. */
DECL|method|MergeThread
specifier|public
name|MergeThread
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|OneMerge
name|merge
parameter_list|)
block|{
name|this
operator|.
name|writer
operator|=
name|writer
expr_stmt|;
name|this
operator|.
name|merge
operator|=
name|merge
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compareTo
specifier|public
name|int
name|compareTo
parameter_list|(
name|MergeThread
name|other
parameter_list|)
block|{
comment|// Larger merges sort first:
return|return
name|Long
operator|.
name|compare
argument_list|(
name|other
operator|.
name|merge
operator|.
name|estimatedMergeBytes
argument_list|,
name|merge
operator|.
name|estimatedMergeBytes
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"  merge thread: start"
argument_list|)
expr_stmt|;
block|}
name|doMerge
argument_list|(
name|writer
argument_list|,
name|merge
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"  merge thread: done"
argument_list|)
expr_stmt|;
block|}
name|removeMergeThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Let CMS run new merges if necessary:
try|try
block|{
name|merge
argument_list|(
name|writer
argument_list|,
name|MergeTrigger
operator|.
name|MERGE_FINISHED
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AlreadyClosedException
name|ace
parameter_list|)
block|{
comment|// OK
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|exc
parameter_list|)
block|{
if|if
condition|(
name|exc
operator|instanceof
name|MergePolicy
operator|.
name|MergeAbortedException
condition|)
block|{
comment|// OK to ignore
block|}
elseif|else
if|if
condition|(
name|suppressExceptions
operator|==
literal|false
condition|)
block|{
comment|// suppressExceptions is normally only set during
comment|// testing.
name|handleMergeException
argument_list|(
name|writer
operator|.
name|getDirectory
argument_list|()
argument_list|,
name|exc
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|ConcurrentMergeScheduler
operator|.
name|this
init|)
block|{
name|updateMergeThreads
argument_list|()
expr_stmt|;
comment|// In case we had stalled indexing, we can now wake up
comment|// and possibly unstall:
name|ConcurrentMergeScheduler
operator|.
name|this
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Called when an exception is hit in a background merge    *  thread */
DECL|method|handleMergeException
specifier|protected
name|void
name|handleMergeException
parameter_list|(
name|Directory
name|dir
parameter_list|,
name|Throwable
name|exc
parameter_list|)
block|{
try|try
block|{
comment|// When an exception is hit during merge, IndexWriter
comment|// removes any partial files and then allows another
comment|// merge to run.  If whatever caused the error is not
comment|// transient then the exception will keep happening,
comment|// so, we sleep here to avoid saturating CPU in such
comment|// cases:
name|Thread
operator|.
name|sleep
argument_list|(
literal|250
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|ThreadInterruptedException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|MergePolicy
operator|.
name|MergeException
argument_list|(
name|exc
argument_list|,
name|dir
argument_list|)
throw|;
block|}
DECL|field|suppressExceptions
specifier|private
name|boolean
name|suppressExceptions
decl_stmt|;
comment|/** Used for testing */
DECL|method|setSuppressExceptions
name|void
name|setSuppressExceptions
parameter_list|()
block|{
name|suppressExceptions
operator|=
literal|true
expr_stmt|;
block|}
comment|/** Used for testing */
DECL|method|clearSuppressExceptions
name|void
name|clearSuppressExceptions
parameter_list|()
block|{
name|suppressExceptions
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": "
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxThreadCount="
argument_list|)
operator|.
name|append
argument_list|(
name|maxThreadCount
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxMergeCount="
argument_list|)
operator|.
name|append
argument_list|(
name|maxMergeCount
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"ioThrottle="
argument_list|)
operator|.
name|append
argument_list|(
name|doAutoIOThrottle
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|isBacklog
specifier|private
name|boolean
name|isBacklog
parameter_list|(
name|long
name|now
parameter_list|,
name|OneMerge
name|merge
parameter_list|)
block|{
name|double
name|mergeMB
init|=
name|bytesToMB
argument_list|(
name|merge
operator|.
name|estimatedMergeBytes
argument_list|)
decl_stmt|;
for|for
control|(
name|MergeThread
name|mergeThread
range|:
name|mergeThreads
control|)
block|{
name|long
name|mergeStartNS
init|=
name|mergeThread
operator|.
name|merge
operator|.
name|mergeStartNS
decl_stmt|;
if|if
condition|(
name|mergeThread
operator|.
name|isAlive
argument_list|()
operator|&&
name|mergeThread
operator|.
name|merge
operator|!=
name|merge
operator|&&
name|mergeStartNS
operator|!=
operator|-
literal|1
operator|&&
name|mergeThread
operator|.
name|merge
operator|.
name|estimatedMergeBytes
operator|>=
name|MIN_BIG_MERGE_MB
operator|*
literal|1024
operator|*
literal|1024
operator|&&
name|nsToSec
argument_list|(
name|now
operator|-
name|mergeStartNS
argument_list|)
operator|>
literal|3.0
condition|)
block|{
name|double
name|otherMergeMB
init|=
name|bytesToMB
argument_list|(
name|mergeThread
operator|.
name|merge
operator|.
name|estimatedMergeBytes
argument_list|)
decl_stmt|;
name|double
name|ratio
init|=
name|otherMergeMB
operator|/
name|mergeMB
decl_stmt|;
if|if
condition|(
name|ratio
operator|>
literal|0.3
operator|&&
name|ratio
operator|<
literal|3.0
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Tunes IO throttle when a new merge starts. */
DECL|method|updateIOThrottle
specifier|private
specifier|synchronized
name|void
name|updateIOThrottle
parameter_list|(
name|OneMerge
name|newMerge
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|doAutoIOThrottle
operator|==
literal|false
condition|)
block|{
return|return;
block|}
name|double
name|mergeMB
init|=
name|bytesToMB
argument_list|(
name|newMerge
operator|.
name|estimatedMergeBytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergeMB
operator|<
name|MIN_BIG_MERGE_MB
condition|)
block|{
comment|// Only watch non-trivial merges for throttling; this is safe because the MP must eventually
comment|// have to do larger merges:
return|return;
block|}
name|long
name|now
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
comment|// Simplistic closed-loop feedback control: if we find any other similarly
comment|// sized merges running, then we are falling behind, so we bump up the
comment|// IO throttle, else we lower it:
name|boolean
name|newBacklog
init|=
name|isBacklog
argument_list|(
name|now
argument_list|,
name|newMerge
argument_list|)
decl_stmt|;
name|boolean
name|curBacklog
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|newBacklog
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|mergeThreads
operator|.
name|size
argument_list|()
operator|>
name|maxThreadCount
condition|)
block|{
comment|// If there are already more than the maximum merge threads allowed, count that as backlog:
name|curBacklog
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// Now see if any still-running merges are backlog'd:
for|for
control|(
name|MergeThread
name|mergeThread
range|:
name|mergeThreads
control|)
block|{
if|if
condition|(
name|isBacklog
argument_list|(
name|now
argument_list|,
name|mergeThread
operator|.
name|merge
argument_list|)
condition|)
block|{
name|curBacklog
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|double
name|curMBPerSec
init|=
name|targetMBPerSec
decl_stmt|;
if|if
condition|(
name|newBacklog
condition|)
block|{
comment|// This new merge adds to the backlog: increase IO throttle by 20%
name|targetMBPerSec
operator|*=
literal|1.20
expr_stmt|;
if|if
condition|(
name|targetMBPerSec
operator|>
name|MAX_MERGE_MB_PER_SEC
condition|)
block|{
name|targetMBPerSec
operator|=
name|MAX_MERGE_MB_PER_SEC
expr_stmt|;
block|}
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
if|if
condition|(
name|curMBPerSec
operator|==
name|targetMBPerSec
condition|)
block|{
name|message
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"io throttle: new merge backlog; leave IO rate at ceiling %.1f MB/sec"
argument_list|,
name|targetMBPerSec
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"io throttle: new merge backlog; increase IO rate to %.1f MB/sec"
argument_list|,
name|targetMBPerSec
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|curBacklog
condition|)
block|{
comment|// We still have an existing backlog; leave the rate as is:
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"io throttle: current merge backlog; leave IO rate at %.1f MB/sec"
argument_list|,
name|targetMBPerSec
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// We are not falling behind: decrease IO throttle by 10%
name|targetMBPerSec
operator|/=
literal|1.10
expr_stmt|;
if|if
condition|(
name|targetMBPerSec
operator|<
name|MIN_MERGE_MB_PER_SEC
condition|)
block|{
name|targetMBPerSec
operator|=
name|MIN_MERGE_MB_PER_SEC
expr_stmt|;
block|}
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
if|if
condition|(
name|curMBPerSec
operator|==
name|targetMBPerSec
condition|)
block|{
name|message
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"io throttle: no merge backlog; leave IO rate at floor %.1f MB/sec"
argument_list|,
name|targetMBPerSec
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"io throttle: no merge backlog; decrease IO rate to %.1f MB/sec"
argument_list|,
name|targetMBPerSec
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|double
name|rate
decl_stmt|;
if|if
condition|(
name|newMerge
operator|.
name|maxNumSegments
operator|!=
operator|-
literal|1
condition|)
block|{
name|rate
operator|=
name|forceMergeMBPerSec
expr_stmt|;
block|}
else|else
block|{
name|rate
operator|=
name|targetMBPerSec
expr_stmt|;
block|}
name|newMerge
operator|.
name|rateLimiter
operator|.
name|setMBPerSec
argument_list|(
name|rate
argument_list|)
expr_stmt|;
name|targetMBPerSecChanged
argument_list|()
expr_stmt|;
block|}
comment|/** Subclass can override to tweak targetMBPerSec. */
DECL|method|targetMBPerSecChanged
specifier|protected
name|void
name|targetMBPerSecChanged
parameter_list|()
block|{   }
DECL|method|nsToSec
specifier|private
specifier|static
name|double
name|nsToSec
parameter_list|(
name|long
name|ns
parameter_list|)
block|{
return|return
name|ns
operator|/
literal|1000000000.0
return|;
block|}
DECL|method|bytesToMB
specifier|private
specifier|static
name|double
name|bytesToMB
parameter_list|(
name|long
name|bytes
parameter_list|)
block|{
return|return
name|bytes
operator|/
literal|1024.
operator|/
literal|1024.
return|;
block|}
block|}
end_class
end_unit
