begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocumentsWriterPerThread
operator|.
name|IndexingChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
operator|.
name|IndexReaderWarmer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|IndexSearcher
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|InfoStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PrintStreamInfoStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
import|;
end_import
begin_comment
comment|/**  * Holds all the configuration of {@link IndexWriter}.  You  * should instantiate this class, call the setters to set  * your configuration, then pass it to {@link IndexWriter}.  * Note that {@link IndexWriter} makes a private clone; if  * you need to subsequently change settings use {@link  * IndexWriter#getConfig}.  *  *<p>  * All setter methods return {@link IndexWriterConfig} to allow chaining  * settings conveniently, for example:  *   *<pre>  * IndexWriterConfig conf = new IndexWriterConfig(analyzer);  * conf.setter1().setter2();  *</pre>  *  * @since 3.1  */
end_comment
begin_class
DECL|class|IndexWriterConfig
specifier|public
specifier|final
class|class
name|IndexWriterConfig
implements|implements
name|Cloneable
block|{
comment|/**    * Specifies the open mode for {@link IndexWriter}:    *<ul>    * {@link #CREATE} - creates a new index or overwrites an existing one.    * {@link #CREATE_OR_APPEND} - creates a new index if one does not exist,    * otherwise it opens the index and documents will be appended.    * {@link #APPEND} - opens an existing index.    *</ul>    */
DECL|enum|OpenMode
DECL|enum constant|CREATE
DECL|enum constant|APPEND
DECL|enum constant|CREATE_OR_APPEND
specifier|public
specifier|static
enum|enum
name|OpenMode
block|{
name|CREATE
block|,
name|APPEND
block|,
name|CREATE_OR_APPEND
block|}
comment|/** Default value is 32. Change using {@link #setTermIndexInterval(int)}. */
DECL|field|DEFAULT_TERM_INDEX_INTERVAL
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_TERM_INDEX_INTERVAL
init|=
literal|32
decl_stmt|;
comment|// TODO: this should be private to the codec, not settable here
comment|/** Denotes a flush trigger is disabled. */
DECL|field|DISABLE_AUTO_FLUSH
specifier|public
specifier|final
specifier|static
name|int
name|DISABLE_AUTO_FLUSH
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Disabled by default (because IndexWriter flushes by RAM usage by default). */
DECL|field|DEFAULT_MAX_BUFFERED_DELETE_TERMS
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_BUFFERED_DELETE_TERMS
init|=
name|DISABLE_AUTO_FLUSH
decl_stmt|;
comment|/** Disabled by default (because IndexWriter flushes by RAM usage by default). */
DECL|field|DEFAULT_MAX_BUFFERED_DOCS
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_BUFFERED_DOCS
init|=
name|DISABLE_AUTO_FLUSH
decl_stmt|;
comment|/**    * Default value is 16 MB (which means flush when buffered docs consume    * approximately 16 MB RAM).    */
DECL|field|DEFAULT_RAM_BUFFER_SIZE_MB
specifier|public
specifier|final
specifier|static
name|double
name|DEFAULT_RAM_BUFFER_SIZE_MB
init|=
literal|16.0
decl_stmt|;
comment|/**    * Default value for the write lock timeout (1,000 ms).    *    * @see #setDefaultWriteLockTimeout(long)    */
DECL|field|WRITE_LOCK_TIMEOUT
specifier|public
specifier|static
name|long
name|WRITE_LOCK_TIMEOUT
init|=
literal|1000
decl_stmt|;
comment|/** Default setting for {@link #setReaderPooling}. */
DECL|field|DEFAULT_READER_POOLING
specifier|public
specifier|final
specifier|static
name|boolean
name|DEFAULT_READER_POOLING
init|=
literal|false
decl_stmt|;
comment|/** Default value is 1. Change using {@link #setReaderTermsIndexDivisor(int)}. */
DECL|field|DEFAULT_READER_TERMS_INDEX_DIVISOR
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_READER_TERMS_INDEX_DIVISOR
init|=
name|DirectoryReader
operator|.
name|DEFAULT_TERMS_INDEX_DIVISOR
decl_stmt|;
comment|/** Default value is 1945. Change using {@link #setRAMPerThreadHardLimitMB(int)} */
DECL|field|DEFAULT_RAM_PER_THREAD_HARD_LIMIT_MB
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_RAM_PER_THREAD_HARD_LIMIT_MB
init|=
literal|1945
decl_stmt|;
comment|/** The maximum number of simultaneous threads that may be    *  indexing documents at once in IndexWriter; if more    *  than this many threads arrive they will wait for    *  others to finish. Default value is 8. */
DECL|field|DEFAULT_MAX_THREAD_STATES
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_THREAD_STATES
init|=
literal|8
decl_stmt|;
comment|/**    * Sets the default (for any instance) maximum time to wait for a write lock    * (in milliseconds).    */
DECL|method|setDefaultWriteLockTimeout
specifier|public
specifier|static
name|void
name|setDefaultWriteLockTimeout
parameter_list|(
name|long
name|writeLockTimeout
parameter_list|)
block|{
name|WRITE_LOCK_TIMEOUT
operator|=
name|writeLockTimeout
expr_stmt|;
block|}
comment|/**    * Returns the default write lock timeout for newly instantiated    * IndexWriterConfigs.    *    * @see #setDefaultWriteLockTimeout(long)    */
DECL|method|getDefaultWriteLockTimeout
specifier|public
specifier|static
name|long
name|getDefaultWriteLockTimeout
parameter_list|()
block|{
return|return
name|WRITE_LOCK_TIMEOUT
return|;
block|}
DECL|field|analyzer
specifier|private
specifier|final
name|Analyzer
name|analyzer
decl_stmt|;
DECL|field|delPolicy
specifier|private
specifier|volatile
name|IndexDeletionPolicy
name|delPolicy
decl_stmt|;
DECL|field|commit
specifier|private
specifier|volatile
name|IndexCommit
name|commit
decl_stmt|;
DECL|field|openMode
specifier|private
specifier|volatile
name|OpenMode
name|openMode
decl_stmt|;
DECL|field|similarity
specifier|private
specifier|volatile
name|Similarity
name|similarity
decl_stmt|;
DECL|field|termIndexInterval
specifier|private
specifier|volatile
name|int
name|termIndexInterval
decl_stmt|;
comment|// TODO: this should be private to the codec, not settable here
DECL|field|mergeScheduler
specifier|private
specifier|volatile
name|MergeScheduler
name|mergeScheduler
decl_stmt|;
DECL|field|writeLockTimeout
specifier|private
specifier|volatile
name|long
name|writeLockTimeout
decl_stmt|;
DECL|field|maxBufferedDeleteTerms
specifier|private
specifier|volatile
name|int
name|maxBufferedDeleteTerms
decl_stmt|;
DECL|field|ramBufferSizeMB
specifier|private
specifier|volatile
name|double
name|ramBufferSizeMB
decl_stmt|;
DECL|field|maxBufferedDocs
specifier|private
specifier|volatile
name|int
name|maxBufferedDocs
decl_stmt|;
DECL|field|indexingChain
specifier|private
specifier|volatile
name|IndexingChain
name|indexingChain
decl_stmt|;
DECL|field|mergedSegmentWarmer
specifier|private
specifier|volatile
name|IndexReaderWarmer
name|mergedSegmentWarmer
decl_stmt|;
DECL|field|codec
specifier|private
specifier|volatile
name|Codec
name|codec
decl_stmt|;
DECL|field|infoStream
specifier|private
specifier|volatile
name|InfoStream
name|infoStream
decl_stmt|;
DECL|field|mergePolicy
specifier|private
specifier|volatile
name|MergePolicy
name|mergePolicy
decl_stmt|;
DECL|field|indexerThreadPool
specifier|private
specifier|volatile
name|DocumentsWriterPerThreadPool
name|indexerThreadPool
decl_stmt|;
DECL|field|readerPooling
specifier|private
specifier|volatile
name|boolean
name|readerPooling
decl_stmt|;
DECL|field|readerTermsIndexDivisor
specifier|private
specifier|volatile
name|int
name|readerTermsIndexDivisor
decl_stmt|;
DECL|field|flushPolicy
specifier|private
specifier|volatile
name|FlushPolicy
name|flushPolicy
decl_stmt|;
DECL|field|perThreadHardLimitMB
specifier|private
specifier|volatile
name|int
name|perThreadHardLimitMB
decl_stmt|;
DECL|field|matchVersion
specifier|private
name|Version
name|matchVersion
decl_stmt|;
comment|/**    * Creates a new config that with defaults that match the specified    * {@link Version} as well as the default {@link    * Analyzer}. If matchVersion is>= {@link    * Version#LUCENE_32}, {@link TieredMergePolicy} is used    * for merging; else {@link LogByteSizeMergePolicy}.    * Note that {@link TieredMergePolicy} is free to select    * non-contiguous merges, which means docIDs may not    * remain montonic over time.  If this is a problem you    * should switch to {@link LogByteSizeMergePolicy} or    * {@link LogDocMergePolicy}.    */
DECL|method|IndexWriterConfig
specifier|public
name|IndexWriterConfig
parameter_list|(
name|Version
name|matchVersion
parameter_list|,
name|Analyzer
name|analyzer
parameter_list|)
block|{
name|this
operator|.
name|matchVersion
operator|=
name|matchVersion
expr_stmt|;
name|this
operator|.
name|analyzer
operator|=
name|analyzer
expr_stmt|;
name|delPolicy
operator|=
operator|new
name|KeepOnlyLastCommitDeletionPolicy
argument_list|()
expr_stmt|;
name|commit
operator|=
literal|null
expr_stmt|;
name|openMode
operator|=
name|OpenMode
operator|.
name|CREATE_OR_APPEND
expr_stmt|;
name|similarity
operator|=
name|IndexSearcher
operator|.
name|getDefaultSimilarity
argument_list|()
expr_stmt|;
name|termIndexInterval
operator|=
name|DEFAULT_TERM_INDEX_INTERVAL
expr_stmt|;
comment|// TODO: this should be private to the codec, not settable here
name|mergeScheduler
operator|=
operator|new
name|ConcurrentMergeScheduler
argument_list|()
expr_stmt|;
name|writeLockTimeout
operator|=
name|WRITE_LOCK_TIMEOUT
expr_stmt|;
name|maxBufferedDeleteTerms
operator|=
name|DEFAULT_MAX_BUFFERED_DELETE_TERMS
expr_stmt|;
name|ramBufferSizeMB
operator|=
name|DEFAULT_RAM_BUFFER_SIZE_MB
expr_stmt|;
name|maxBufferedDocs
operator|=
name|DEFAULT_MAX_BUFFERED_DOCS
expr_stmt|;
name|indexingChain
operator|=
name|DocumentsWriterPerThread
operator|.
name|defaultIndexingChain
expr_stmt|;
name|mergedSegmentWarmer
operator|=
literal|null
expr_stmt|;
name|codec
operator|=
name|Codec
operator|.
name|getDefault
argument_list|()
expr_stmt|;
name|infoStream
operator|=
name|InfoStream
operator|.
name|getDefault
argument_list|()
expr_stmt|;
if|if
condition|(
name|matchVersion
operator|.
name|onOrAfter
argument_list|(
name|Version
operator|.
name|LUCENE_32
argument_list|)
condition|)
block|{
name|mergePolicy
operator|=
operator|new
name|TieredMergePolicy
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mergePolicy
operator|=
operator|new
name|LogByteSizeMergePolicy
argument_list|()
expr_stmt|;
block|}
name|flushPolicy
operator|=
operator|new
name|FlushByRamOrCountsPolicy
argument_list|()
expr_stmt|;
name|readerPooling
operator|=
name|DEFAULT_READER_POOLING
expr_stmt|;
name|indexerThreadPool
operator|=
operator|new
name|ThreadAffinityDocumentsWriterThreadPool
argument_list|(
name|DEFAULT_MAX_THREAD_STATES
argument_list|)
expr_stmt|;
name|readerTermsIndexDivisor
operator|=
name|DEFAULT_READER_TERMS_INDEX_DIVISOR
expr_stmt|;
name|perThreadHardLimitMB
operator|=
name|DEFAULT_RAM_PER_THREAD_HARD_LIMIT_MB
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|clone
specifier|public
name|IndexWriterConfig
name|clone
parameter_list|()
block|{
comment|// Shallow clone is the only thing that's possible, since parameters like
comment|// analyzer, index commit etc. do not implement Cloneable.
try|try
block|{
return|return
operator|(
name|IndexWriterConfig
operator|)
name|super
operator|.
name|clone
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
comment|// should not happen
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Returns the default analyzer to use for indexing documents. */
DECL|method|getAnalyzer
specifier|public
name|Analyzer
name|getAnalyzer
parameter_list|()
block|{
return|return
name|analyzer
return|;
block|}
comment|/** Specifies {@link OpenMode} of the index.    *     *<p>Only takes effect when IndexWriter is first created. */
DECL|method|setOpenMode
specifier|public
name|IndexWriterConfig
name|setOpenMode
parameter_list|(
name|OpenMode
name|openMode
parameter_list|)
block|{
name|this
operator|.
name|openMode
operator|=
name|openMode
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Returns the {@link OpenMode} set by {@link #setOpenMode(OpenMode)}. */
DECL|method|getOpenMode
specifier|public
name|OpenMode
name|getOpenMode
parameter_list|()
block|{
return|return
name|openMode
return|;
block|}
comment|/**    * Expert: allows an optional {@link IndexDeletionPolicy} implementation to be    * specified. You can use this to control when prior commits are deleted from    * the index. The default policy is {@link KeepOnlyLastCommitDeletionPolicy}    * which removes all prior commits as soon as a new commit is done (this    * matches behavior before 2.2). Creating your own policy can allow you to    * explicitly keep previous "point in time" commits alive in the index for    * some time, to allow readers to refresh to the new commit without having the    * old commit deleted out from under them. This is necessary on filesystems    * like NFS that do not support "delete on last close" semantics, which    * Lucene's "point in time" search normally relies on.    *<p>    *<b>NOTE:</b> the deletion policy cannot be null. If<code>null</code> is    * passed, the deletion policy will be set to the default.    *    *<p>Only takes effect when IndexWriter is first created.     */
DECL|method|setIndexDeletionPolicy
specifier|public
name|IndexWriterConfig
name|setIndexDeletionPolicy
parameter_list|(
name|IndexDeletionPolicy
name|delPolicy
parameter_list|)
block|{
name|this
operator|.
name|delPolicy
operator|=
name|delPolicy
operator|==
literal|null
condition|?
operator|new
name|KeepOnlyLastCommitDeletionPolicy
argument_list|()
else|:
name|delPolicy
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Returns the {@link IndexDeletionPolicy} specified in    * {@link #setIndexDeletionPolicy(IndexDeletionPolicy)} or the default    * {@link KeepOnlyLastCommitDeletionPolicy}/    */
DECL|method|getIndexDeletionPolicy
specifier|public
name|IndexDeletionPolicy
name|getIndexDeletionPolicy
parameter_list|()
block|{
return|return
name|delPolicy
return|;
block|}
comment|/**    * Expert: allows to open a certain commit point. The default is null which    * opens the latest commit point.    *    *<p>Only takes effect when IndexWriter is first created. */
DECL|method|setIndexCommit
specifier|public
name|IndexWriterConfig
name|setIndexCommit
parameter_list|(
name|IndexCommit
name|commit
parameter_list|)
block|{
name|this
operator|.
name|commit
operator|=
name|commit
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Returns the {@link IndexCommit} as specified in    * {@link #setIndexCommit(IndexCommit)} or the default,<code>null</code>    * which specifies to open the latest index commit point.    */
DECL|method|getIndexCommit
specifier|public
name|IndexCommit
name|getIndexCommit
parameter_list|()
block|{
return|return
name|commit
return|;
block|}
comment|/**    * Expert: set the {@link Similarity} implementation used by this IndexWriter.    *<p>    *<b>NOTE:</b> the similarity cannot be null. If<code>null</code> is passed,    * the similarity will be set to the default implementation (unspecified).    *    *<p>Only takes effect when IndexWriter is first created. */
DECL|method|setSimilarity
specifier|public
name|IndexWriterConfig
name|setSimilarity
parameter_list|(
name|Similarity
name|similarity
parameter_list|)
block|{
name|this
operator|.
name|similarity
operator|=
name|similarity
operator|==
literal|null
condition|?
name|IndexSearcher
operator|.
name|getDefaultSimilarity
argument_list|()
else|:
name|similarity
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Expert: returns the {@link Similarity} implementation used by this    * IndexWriter.    */
DECL|method|getSimilarity
specifier|public
name|Similarity
name|getSimilarity
parameter_list|()
block|{
return|return
name|similarity
return|;
block|}
comment|/**    * Expert: set the interval between indexed terms. Large values cause less    * memory to be used by IndexReader, but slow random-access to terms. Small    * values cause more memory to be used by an IndexReader, and speed    * random-access to terms.    *<p>    * This parameter determines the amount of computation required per query    * term, regardless of the number of documents that contain that term. In    * particular, it is the maximum number of other terms that must be scanned    * before a term is located and its frequency and position information may be    * processed. In a large index with user-entered query terms, query processing    * time is likely to be dominated not by term lookup but rather by the    * processing of frequency and positional data. In a small index or when many    * uncommon query terms are generated (e.g., by wildcard queries) term lookup    * may become a dominant cost.    *<p>    * In particular,<code>numUniqueTerms/interval</code> terms are read into    * memory by an IndexReader, and, on average,<code>interval/2</code> terms    * must be scanned for each random term access.    *    * @see #DEFAULT_TERM_INDEX_INTERVAL    *    *<p>Takes effect immediately, but only applies to newly    *  flushed/merged segments. */
DECL|method|setTermIndexInterval
specifier|public
name|IndexWriterConfig
name|setTermIndexInterval
parameter_list|(
name|int
name|interval
parameter_list|)
block|{
comment|// TODO: this should be private to the codec, not settable here
name|this
operator|.
name|termIndexInterval
operator|=
name|interval
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Returns the interval between indexed terms.    *    * @see #setTermIndexInterval(int)    */
DECL|method|getTermIndexInterval
specifier|public
name|int
name|getTermIndexInterval
parameter_list|()
block|{
comment|// TODO: this should be private to the codec, not settable here
return|return
name|termIndexInterval
return|;
block|}
comment|/**    * Expert: sets the merge scheduler used by this writer. The default is    * {@link ConcurrentMergeScheduler}.    *<p>    *<b>NOTE:</b> the merge scheduler cannot be null. If<code>null</code> is    * passed, the merge scheduler will be set to the default.    *    *<p>Only takes effect when IndexWriter is first created. */
DECL|method|setMergeScheduler
specifier|public
name|IndexWriterConfig
name|setMergeScheduler
parameter_list|(
name|MergeScheduler
name|mergeScheduler
parameter_list|)
block|{
name|this
operator|.
name|mergeScheduler
operator|=
name|mergeScheduler
operator|==
literal|null
condition|?
operator|new
name|ConcurrentMergeScheduler
argument_list|()
else|:
name|mergeScheduler
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Returns the {@link MergeScheduler} that was set by    * {@link #setMergeScheduler(MergeScheduler)}    */
DECL|method|getMergeScheduler
specifier|public
name|MergeScheduler
name|getMergeScheduler
parameter_list|()
block|{
return|return
name|mergeScheduler
return|;
block|}
comment|/**    * Sets the maximum time to wait for a write lock (in milliseconds) for this    * instance. You can change the default value for all instances by calling    * {@link #setDefaultWriteLockTimeout(long)}.    *    *<p>Only takes effect when IndexWriter is first created. */
DECL|method|setWriteLockTimeout
specifier|public
name|IndexWriterConfig
name|setWriteLockTimeout
parameter_list|(
name|long
name|writeLockTimeout
parameter_list|)
block|{
name|this
operator|.
name|writeLockTimeout
operator|=
name|writeLockTimeout
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Returns allowed timeout when acquiring the write lock.    *    * @see #setWriteLockTimeout(long)    */
DECL|method|getWriteLockTimeout
specifier|public
name|long
name|getWriteLockTimeout
parameter_list|()
block|{
return|return
name|writeLockTimeout
return|;
block|}
comment|/**    * Determines the minimal number of delete terms required before the buffered    * in-memory delete terms and queries are applied and flushed.    *<p>Disabled by default (writer flushes by RAM usage).</p>    *<p>    * NOTE:  This setting won't trigger a segment flush.    *</p>    *     * @throws IllegalArgumentException if maxBufferedDeleteTerms    * is enabled but smaller than 1    * @see #setRAMBufferSizeMB    * @see #setFlushPolicy(FlushPolicy)    *    *<p>Takes effect immediately, but only the next time a    * document is added, updated or deleted.    */
DECL|method|setMaxBufferedDeleteTerms
specifier|public
name|IndexWriterConfig
name|setMaxBufferedDeleteTerms
parameter_list|(
name|int
name|maxBufferedDeleteTerms
parameter_list|)
block|{
if|if
condition|(
name|maxBufferedDeleteTerms
operator|!=
name|DISABLE_AUTO_FLUSH
operator|&&
name|maxBufferedDeleteTerms
operator|<
literal|1
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxBufferedDeleteTerms must at least be 1 when enabled"
argument_list|)
throw|;
name|this
operator|.
name|maxBufferedDeleteTerms
operator|=
name|maxBufferedDeleteTerms
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Returns the number of buffered deleted terms that will trigger a flush of all    * buffered deletes if enabled.    *    * @see #setMaxBufferedDeleteTerms(int)    */
DECL|method|getMaxBufferedDeleteTerms
specifier|public
name|int
name|getMaxBufferedDeleteTerms
parameter_list|()
block|{
return|return
name|maxBufferedDeleteTerms
return|;
block|}
comment|/**    * Determines the amount of RAM that may be used for buffering added documents    * and deletions before they are flushed to the Directory. Generally for    * faster indexing performance it's best to flush by RAM usage instead of    * document count and use as large a RAM buffer as you can.    *<p>    * When this is set, the writer will flush whenever buffered documents and    * deletions use this much RAM. Pass in {@link #DISABLE_AUTO_FLUSH} to prevent    * triggering a flush due to RAM usage. Note that if flushing by document    * count is also enabled, then the flush will be triggered by whichever comes    * first.    *<p>    * The maximum RAM limit is inherently determined by the JVMs available memory.    * Yet, an {@link IndexWriter} session can consume a significantly larger amount    * of memory than the given RAM limit since this limit is just an indicator when    * to flush memory resident documents to the Directory. Flushes are likely happen    * concurrently while other threads adding documents to the writer. For application    * stability the available memory in the JVM should be significantly larger than    * the RAM buffer used for indexing.    *<p>    *<b>NOTE</b>: the account of RAM usage for pending deletions is only    * approximate. Specifically, if you delete by Query, Lucene currently has no    * way to measure the RAM usage of individual Queries so the accounting will    * under-estimate and you should compensate by either calling commit()    * periodically yourself, or by using {@link #setMaxBufferedDeleteTerms(int)}    * to flush and apply buffered deletes by count instead of RAM usage    * (for each buffered delete Query a constant number of bytes is used to estimate    * RAM usage). Note that enabling {@link #setMaxBufferedDeleteTerms(int)} will    * not trigger any segment flushes.    *<p>    *<b>NOTE</b>: It's not guaranteed that all memory resident documents are flushed     * once this limit is exceeded. Depending on the configured {@link FlushPolicy} only a    * subset of the buffered documents are flushed and therefore only parts of the RAM    * buffer is released.        *<p>    *     * The default value is {@link #DEFAULT_RAM_BUFFER_SIZE_MB}.    * @see #setFlushPolicy(FlushPolicy)    * @see #setRAMPerThreadHardLimitMB(int)    *    *<p>Takes effect immediately, but only the next time a    * document is added, updated or deleted.    *    * @throws IllegalArgumentException    *           if ramBufferSize is enabled but non-positive, or it disables    *           ramBufferSize when maxBufferedDocs is already disabled    *               */
DECL|method|setRAMBufferSizeMB
specifier|public
name|IndexWriterConfig
name|setRAMBufferSizeMB
parameter_list|(
name|double
name|ramBufferSizeMB
parameter_list|)
block|{
if|if
condition|(
name|ramBufferSizeMB
operator|!=
name|DISABLE_AUTO_FLUSH
operator|&&
name|ramBufferSizeMB
operator|<=
literal|0.0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ramBufferSize should be> 0.0 MB when enabled"
argument_list|)
throw|;
if|if
condition|(
name|ramBufferSizeMB
operator|==
name|DISABLE_AUTO_FLUSH
operator|&&
name|maxBufferedDocs
operator|==
name|DISABLE_AUTO_FLUSH
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"at least one of ramBufferSize and maxBufferedDocs must be enabled"
argument_list|)
throw|;
name|this
operator|.
name|ramBufferSizeMB
operator|=
name|ramBufferSizeMB
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Returns the value set by {@link #setRAMBufferSizeMB(double)} if enabled. */
DECL|method|getRAMBufferSizeMB
specifier|public
name|double
name|getRAMBufferSizeMB
parameter_list|()
block|{
return|return
name|ramBufferSizeMB
return|;
block|}
comment|/**    * Determines the minimal number of documents required before the buffered    * in-memory documents are flushed as a new Segment. Large values generally    * give faster indexing.    *    *<p>    * When this is set, the writer will flush every maxBufferedDocs added    * documents. Pass in {@link #DISABLE_AUTO_FLUSH} to prevent triggering a    * flush due to number of buffered documents. Note that if flushing by RAM    * usage is also enabled, then the flush will be triggered by whichever comes    * first.    *    *<p>    * Disabled by default (writer flushes by RAM usage).    *    *<p>Takes effect immediately, but only the next time a    * document is added, updated or deleted.    *    * @see #setRAMBufferSizeMB(double)    * @see #setFlushPolicy(FlushPolicy)    * @throws IllegalArgumentException    *           if maxBufferedDocs is enabled but smaller than 2, or it disables    *           maxBufferedDocs when ramBufferSize is already disabled    */
DECL|method|setMaxBufferedDocs
specifier|public
name|IndexWriterConfig
name|setMaxBufferedDocs
parameter_list|(
name|int
name|maxBufferedDocs
parameter_list|)
block|{
if|if
condition|(
name|maxBufferedDocs
operator|!=
name|DISABLE_AUTO_FLUSH
operator|&&
name|maxBufferedDocs
operator|<
literal|2
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxBufferedDocs must at least be 2 when enabled"
argument_list|)
throw|;
if|if
condition|(
name|maxBufferedDocs
operator|==
name|DISABLE_AUTO_FLUSH
operator|&&
name|ramBufferSizeMB
operator|==
name|DISABLE_AUTO_FLUSH
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"at least one of ramBufferSize and maxBufferedDocs must be enabled"
argument_list|)
throw|;
name|this
operator|.
name|maxBufferedDocs
operator|=
name|maxBufferedDocs
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Returns the number of buffered added documents that will trigger a flush if    * enabled.    *    * @see #setMaxBufferedDocs(int)    */
DECL|method|getMaxBufferedDocs
specifier|public
name|int
name|getMaxBufferedDocs
parameter_list|()
block|{
return|return
name|maxBufferedDocs
return|;
block|}
comment|/** Set the merged segment warmer. See {@link IndexReaderWarmer}.    *    *<p>Takes effect on the next merge. */
DECL|method|setMergedSegmentWarmer
specifier|public
name|IndexWriterConfig
name|setMergedSegmentWarmer
parameter_list|(
name|IndexReaderWarmer
name|mergeSegmentWarmer
parameter_list|)
block|{
name|this
operator|.
name|mergedSegmentWarmer
operator|=
name|mergeSegmentWarmer
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Returns the current merged segment warmer. See {@link IndexReaderWarmer}. */
DECL|method|getMergedSegmentWarmer
specifier|public
name|IndexReaderWarmer
name|getMergedSegmentWarmer
parameter_list|()
block|{
return|return
name|mergedSegmentWarmer
return|;
block|}
comment|/**    * Expert: {@link MergePolicy} is invoked whenever there are changes to the    * segments in the index. Its role is to select which merges to do, if any,    * and return a {@link MergePolicy.MergeSpecification} describing the merges.    * It also selects merges to do for forceMerge. (The default is    * {@link LogByteSizeMergePolicy}.    *    *<p>Only takes effect when IndexWriter is first created. */
DECL|method|setMergePolicy
specifier|public
name|IndexWriterConfig
name|setMergePolicy
parameter_list|(
name|MergePolicy
name|mergePolicy
parameter_list|)
block|{
name|this
operator|.
name|mergePolicy
operator|=
name|mergePolicy
operator|==
literal|null
condition|?
operator|new
name|LogByteSizeMergePolicy
argument_list|()
else|:
name|mergePolicy
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Set the Codec. See {@link Codec}.    *    *<p>Only takes effect when IndexWriter is first created. */
DECL|method|setCodec
specifier|public
name|IndexWriterConfig
name|setCodec
parameter_list|(
name|Codec
name|codec
parameter_list|)
block|{
name|this
operator|.
name|codec
operator|=
name|codec
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Returns the current Codec. See {@link Codec}. */
DECL|method|getCodec
specifier|public
name|Codec
name|getCodec
parameter_list|()
block|{
return|return
name|codec
return|;
block|}
comment|/**    * Returns the current MergePolicy in use by this writer.    *    * @see #setMergePolicy(MergePolicy)    */
DECL|method|getMergePolicy
specifier|public
name|MergePolicy
name|getMergePolicy
parameter_list|()
block|{
return|return
name|mergePolicy
return|;
block|}
comment|/** Expert: Sets the {@link DocumentsWriterPerThreadPool} instance used by the    * IndexWriter to assign thread-states to incoming indexing threads. If no    * {@link DocumentsWriterPerThreadPool} is set {@link IndexWriter} will use    * {@link ThreadAffinityDocumentsWriterThreadPool} with max number of    * thread-states set to {@link #DEFAULT_MAX_THREAD_STATES} (see    * {@link #DEFAULT_MAX_THREAD_STATES}).    *</p>    *<p>    * NOTE: The given {@link DocumentsWriterPerThreadPool} instance must not be used with    * other {@link IndexWriter} instances once it has been initialized / associated with an    * {@link IndexWriter}.    *</p>    *<p>    * NOTE: This only takes effect when IndexWriter is first created.</p>*/
DECL|method|setIndexerThreadPool
specifier|public
name|IndexWriterConfig
name|setIndexerThreadPool
parameter_list|(
name|DocumentsWriterPerThreadPool
name|threadPool
parameter_list|)
block|{
if|if
condition|(
name|threadPool
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"DocumentsWriterPerThreadPool must not be nul"
argument_list|)
throw|;
block|}
name|this
operator|.
name|indexerThreadPool
operator|=
name|threadPool
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Returns the configured {@link DocumentsWriterPerThreadPool} instance.    * @see #setIndexerThreadPool(DocumentsWriterPerThreadPool)    * @return the configured {@link DocumentsWriterPerThreadPool} instance.*/
DECL|method|getIndexerThreadPool
specifier|public
name|DocumentsWriterPerThreadPool
name|getIndexerThreadPool
parameter_list|()
block|{
return|return
name|this
operator|.
name|indexerThreadPool
return|;
block|}
comment|/** By default, IndexWriter does not pool the    *  SegmentReaders it must open for deletions and    *  merging, unless a near-real-time reader has been    *  obtained by calling {@link DirectoryReader#open(IndexWriter, boolean)}.    *  This method lets you enable pooling without getting a    *  near-real-time reader.  NOTE: if you set this to    *  false, IndexWriter will still pool readers once    *  {@link DirectoryReader#open(IndexWriter, boolean)} is called.    *    *<p>Only takes effect when IndexWriter is first created. */
DECL|method|setReaderPooling
specifier|public
name|IndexWriterConfig
name|setReaderPooling
parameter_list|(
name|boolean
name|readerPooling
parameter_list|)
block|{
name|this
operator|.
name|readerPooling
operator|=
name|readerPooling
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Returns true if IndexWriter should pool readers even    *  if {@link DirectoryReader#open(IndexWriter, boolean)} has not been called. */
DECL|method|getReaderPooling
specifier|public
name|boolean
name|getReaderPooling
parameter_list|()
block|{
return|return
name|readerPooling
return|;
block|}
comment|/** Expert: sets the {@link DocConsumer} chain to be used to process documents.    *    *<p>Only takes effect when IndexWriter is first created. */
DECL|method|setIndexingChain
name|IndexWriterConfig
name|setIndexingChain
parameter_list|(
name|IndexingChain
name|indexingChain
parameter_list|)
block|{
name|this
operator|.
name|indexingChain
operator|=
name|indexingChain
operator|==
literal|null
condition|?
name|DocumentsWriterPerThread
operator|.
name|defaultIndexingChain
else|:
name|indexingChain
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Returns the indexing chain set on {@link #setIndexingChain(IndexingChain)}. */
DECL|method|getIndexingChain
name|IndexingChain
name|getIndexingChain
parameter_list|()
block|{
return|return
name|indexingChain
return|;
block|}
comment|/** Sets the termsIndexDivisor passed to any readers that    *  IndexWriter opens, for example when applying deletes    *  or creating a near-real-time reader in {@link    *  DirectoryReader#open(IndexWriter, boolean)}. If you pass -1, the terms index     *  won't be loaded by the readers. This is only useful in     *  advanced situations when you will only .next() through     *  all terms; attempts to seek will hit an exception.    *    *<p>Takes effect immediately, but only applies to    * readers opened after this call */
DECL|method|setReaderTermsIndexDivisor
specifier|public
name|IndexWriterConfig
name|setReaderTermsIndexDivisor
parameter_list|(
name|int
name|divisor
parameter_list|)
block|{
if|if
condition|(
name|divisor
operator|<=
literal|0
operator|&&
name|divisor
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"divisor must be>= 1, or -1 (got "
operator|+
name|divisor
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|readerTermsIndexDivisor
operator|=
name|divisor
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** @see #setReaderTermsIndexDivisor(int) */
DECL|method|getReaderTermsIndexDivisor
specifier|public
name|int
name|getReaderTermsIndexDivisor
parameter_list|()
block|{
return|return
name|readerTermsIndexDivisor
return|;
block|}
comment|/**    * Expert: Controls when segments are flushed to disk during indexing.    * The {@link FlushPolicy} initialized during {@link IndexWriter} instantiation and once initialized    * the given instance is bound to this {@link IndexWriter} and should not be used with another writer.    * @see #setMaxBufferedDeleteTerms(int)    * @see #setMaxBufferedDocs(int)    * @see #setRAMBufferSizeMB(double)    */
DECL|method|setFlushPolicy
specifier|public
name|IndexWriterConfig
name|setFlushPolicy
parameter_list|(
name|FlushPolicy
name|flushPolicy
parameter_list|)
block|{
name|this
operator|.
name|flushPolicy
operator|=
name|flushPolicy
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Expert: Sets the maximum memory consumption per thread triggering a forced    * flush if exceeded. A {@link DocumentsWriterPerThread} is forcefully flushed    * once it exceeds this limit even if the {@link #getRAMBufferSizeMB()} has    * not been exceeded. This is a safety limit to prevent a    * {@link DocumentsWriterPerThread} from address space exhaustion due to its    * internal 32 bit signed integer based memory addressing.    * The given value must be less that 2GB (2048MB)    *     * @see #DEFAULT_RAM_PER_THREAD_HARD_LIMIT_MB    */
DECL|method|setRAMPerThreadHardLimitMB
specifier|public
name|IndexWriterConfig
name|setRAMPerThreadHardLimitMB
parameter_list|(
name|int
name|perThreadHardLimitMB
parameter_list|)
block|{
if|if
condition|(
name|perThreadHardLimitMB
operator|<=
literal|0
operator|||
name|perThreadHardLimitMB
operator|>=
literal|2048
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"PerThreadHardLimit must be greater than 0 and less than 2048MB"
argument_list|)
throw|;
block|}
name|this
operator|.
name|perThreadHardLimitMB
operator|=
name|perThreadHardLimitMB
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Returns the max amount of memory each {@link DocumentsWriterPerThread} can    * consume until forcefully flushed.    * @see #setRAMPerThreadHardLimitMB(int)     */
DECL|method|getRAMPerThreadHardLimitMB
specifier|public
name|int
name|getRAMPerThreadHardLimitMB
parameter_list|()
block|{
return|return
name|perThreadHardLimitMB
return|;
block|}
comment|/**    * @see #setFlushPolicy(FlushPolicy)    */
DECL|method|getFlushPolicy
specifier|public
name|FlushPolicy
name|getFlushPolicy
parameter_list|()
block|{
return|return
name|flushPolicy
return|;
block|}
comment|/**    * @see #setInfoStream(InfoStream)    */
DECL|method|getInfoStream
specifier|public
name|InfoStream
name|getInfoStream
parameter_list|()
block|{
return|return
name|infoStream
return|;
block|}
comment|/** If non-null, information about merges, deletes and a    * message when maxFieldLength is reached will be printed    * to this.    */
DECL|method|setInfoStream
specifier|public
name|IndexWriterConfig
name|setInfoStream
parameter_list|(
name|InfoStream
name|infoStream
parameter_list|)
block|{
if|if
condition|(
name|infoStream
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot set InfoStream implementation to null. "
operator|+
literal|"To disable logging use InfoStream.NO_OUTPUT"
argument_list|)
throw|;
block|}
name|this
operator|.
name|infoStream
operator|=
name|infoStream
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Convenience method that uses {@link PrintStreamInfoStream}    */
DECL|method|setInfoStream
specifier|public
name|IndexWriterConfig
name|setInfoStream
parameter_list|(
name|PrintStream
name|printStream
parameter_list|)
block|{
return|return
name|setInfoStream
argument_list|(
name|printStream
operator|==
literal|null
condition|?
name|InfoStream
operator|.
name|NO_OUTPUT
else|:
operator|new
name|PrintStreamInfoStream
argument_list|(
name|printStream
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"matchVersion="
argument_list|)
operator|.
name|append
argument_list|(
name|matchVersion
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"analyzer="
argument_list|)
operator|.
name|append
argument_list|(
name|analyzer
operator|==
literal|null
condition|?
literal|"null"
else|:
name|analyzer
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"delPolicy="
argument_list|)
operator|.
name|append
argument_list|(
name|delPolicy
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"commit="
argument_list|)
operator|.
name|append
argument_list|(
name|commit
operator|==
literal|null
condition|?
literal|"null"
else|:
name|commit
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"openMode="
argument_list|)
operator|.
name|append
argument_list|(
name|openMode
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"similarity="
argument_list|)
operator|.
name|append
argument_list|(
name|similarity
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"termIndexInterval="
argument_list|)
operator|.
name|append
argument_list|(
name|termIndexInterval
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|// TODO: this should be private to the codec, not settable here
name|sb
operator|.
name|append
argument_list|(
literal|"mergeScheduler="
argument_list|)
operator|.
name|append
argument_list|(
name|mergeScheduler
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"default WRITE_LOCK_TIMEOUT="
argument_list|)
operator|.
name|append
argument_list|(
name|WRITE_LOCK_TIMEOUT
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"writeLockTimeout="
argument_list|)
operator|.
name|append
argument_list|(
name|writeLockTimeout
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxBufferedDeleteTerms="
argument_list|)
operator|.
name|append
argument_list|(
name|maxBufferedDeleteTerms
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"ramBufferSizeMB="
argument_list|)
operator|.
name|append
argument_list|(
name|ramBufferSizeMB
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxBufferedDocs="
argument_list|)
operator|.
name|append
argument_list|(
name|maxBufferedDocs
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"mergedSegmentWarmer="
argument_list|)
operator|.
name|append
argument_list|(
name|mergedSegmentWarmer
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"codec="
argument_list|)
operator|.
name|append
argument_list|(
name|codec
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"infoStream="
argument_list|)
operator|.
name|append
argument_list|(
name|infoStream
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"mergePolicy="
argument_list|)
operator|.
name|append
argument_list|(
name|mergePolicy
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"indexerThreadPool="
argument_list|)
operator|.
name|append
argument_list|(
name|indexerThreadPool
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"readerPooling="
argument_list|)
operator|.
name|append
argument_list|(
name|readerPooling
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"readerTermsIndexDivisor="
argument_list|)
operator|.
name|append
argument_list|(
name|readerTermsIndexDivisor
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"flushPolicy="
argument_list|)
operator|.
name|append
argument_list|(
name|flushPolicy
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"perThreadHardLimitMB="
argument_list|)
operator|.
name|append
argument_list|(
name|perThreadHardLimitMB
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class
end_unit
