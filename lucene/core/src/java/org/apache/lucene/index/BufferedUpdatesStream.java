begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSet
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|DocIdSetIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|QueryWrapperFilter
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Accountable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|InfoStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import
begin_comment
comment|/* Tracks the stream of {@link BufferedDeletes}.  * When DocumentsWriterPerThread flushes, its buffered  * deletes and updates are appended to this stream.  We later  * apply them (resolve them to the actual  * docIDs, per segment) when a merge is started  * (only to the to-be-merged segments).  We  * also apply to all segments when NRT reader is pulled,  * commit/close is called, or when too many deletes or  updates are  * buffered and must be flushed (by RAM usage or by count).  *  * Each packet is assigned a generation, and each flushed or  * merged segment is also assigned a generation, so we can  * track which BufferedDeletes packets to apply to any given  * segment. */
end_comment
begin_class
DECL|class|BufferedUpdatesStream
class|class
name|BufferedUpdatesStream
implements|implements
name|Accountable
block|{
comment|// TODO: maybe linked list?
DECL|field|updates
specifier|private
specifier|final
name|List
argument_list|<
name|FrozenBufferedUpdates
argument_list|>
name|updates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Starts at 1 so that SegmentInfos that have never had
comment|// deletes applied (whose bufferedDelGen defaults to 0)
comment|// will be correct:
DECL|field|nextGen
specifier|private
name|long
name|nextGen
init|=
literal|1
decl_stmt|;
comment|// used only by assert
DECL|field|lastDeleteTerm
specifier|private
name|BytesRef
name|lastDeleteTerm
decl_stmt|;
DECL|field|infoStream
specifier|private
specifier|final
name|InfoStream
name|infoStream
decl_stmt|;
DECL|field|bytesUsed
specifier|private
specifier|final
name|AtomicLong
name|bytesUsed
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|numTerms
specifier|private
specifier|final
name|AtomicInteger
name|numTerms
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|method|BufferedUpdatesStream
specifier|public
name|BufferedUpdatesStream
parameter_list|(
name|InfoStream
name|infoStream
parameter_list|)
block|{
name|this
operator|.
name|infoStream
operator|=
name|infoStream
expr_stmt|;
block|}
comment|// Appends a new packet of buffered deletes to the stream,
comment|// setting its generation:
DECL|method|push
specifier|public
specifier|synchronized
name|long
name|push
parameter_list|(
name|FrozenBufferedUpdates
name|packet
parameter_list|)
block|{
comment|/*      * The insert operation must be atomic. If we let threads increment the gen      * and push the packet afterwards we risk that packets are out of order.      * With DWPT this is possible if two or more flushes are racing for pushing      * updates. If the pushed packets get our of order would loose documents      * since deletes are applied to the wrong segments.      */
name|packet
operator|.
name|setDelGen
argument_list|(
name|nextGen
operator|++
argument_list|)
expr_stmt|;
assert|assert
name|packet
operator|.
name|any
argument_list|()
assert|;
assert|assert
name|checkDeleteStats
argument_list|()
assert|;
assert|assert
name|packet
operator|.
name|delGen
argument_list|()
operator|<
name|nextGen
assert|;
assert|assert
name|updates
operator|.
name|isEmpty
argument_list|()
operator|||
name|updates
operator|.
name|get
argument_list|(
name|updates
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|delGen
argument_list|()
operator|<
name|packet
operator|.
name|delGen
argument_list|()
operator|:
literal|"Delete packets must be in order"
assert|;
name|updates
operator|.
name|add
argument_list|(
name|packet
argument_list|)
expr_stmt|;
name|numTerms
operator|.
name|addAndGet
argument_list|(
name|packet
operator|.
name|numTermDeletes
argument_list|)
expr_stmt|;
name|bytesUsed
operator|.
name|addAndGet
argument_list|(
name|packet
operator|.
name|bytesUsed
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"BD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"BD"
argument_list|,
literal|"push deletes "
operator|+
name|packet
operator|+
literal|" segmentPrivate?="
operator|+
name|packet
operator|.
name|isSegmentPrivate
operator|+
literal|" delGen="
operator|+
name|packet
operator|.
name|delGen
argument_list|()
operator|+
literal|" packetCount="
operator|+
name|updates
operator|.
name|size
argument_list|()
operator|+
literal|" totBytesUsed="
operator|+
name|bytesUsed
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|checkDeleteStats
argument_list|()
assert|;
return|return
name|packet
operator|.
name|delGen
argument_list|()
return|;
block|}
DECL|method|clear
specifier|public
specifier|synchronized
name|void
name|clear
parameter_list|()
block|{
name|updates
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nextGen
operator|=
literal|1
expr_stmt|;
name|numTerms
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bytesUsed
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|any
specifier|public
name|boolean
name|any
parameter_list|()
block|{
return|return
name|bytesUsed
operator|.
name|get
argument_list|()
operator|!=
literal|0
return|;
block|}
DECL|method|numTerms
specifier|public
name|int
name|numTerms
parameter_list|()
block|{
return|return
name|numTerms
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
return|return
name|bytesUsed
operator|.
name|get
argument_list|()
return|;
block|}
DECL|class|ApplyDeletesResult
specifier|public
specifier|static
class|class
name|ApplyDeletesResult
block|{
comment|// True if any actual deletes took place:
DECL|field|anyDeletes
specifier|public
specifier|final
name|boolean
name|anyDeletes
decl_stmt|;
comment|// Current gen, for the merged segment:
DECL|field|gen
specifier|public
specifier|final
name|long
name|gen
decl_stmt|;
comment|// If non-null, contains segments that are 100% deleted
DECL|field|allDeleted
specifier|public
specifier|final
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|allDeleted
decl_stmt|;
DECL|method|ApplyDeletesResult
name|ApplyDeletesResult
parameter_list|(
name|boolean
name|anyDeletes
parameter_list|,
name|long
name|gen
parameter_list|,
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|allDeleted
parameter_list|)
block|{
name|this
operator|.
name|anyDeletes
operator|=
name|anyDeletes
expr_stmt|;
name|this
operator|.
name|gen
operator|=
name|gen
expr_stmt|;
name|this
operator|.
name|allDeleted
operator|=
name|allDeleted
expr_stmt|;
block|}
block|}
comment|// Sorts SegmentInfos from smallest to biggest bufferedDelGen:
DECL|field|sortSegInfoByDelGen
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|sortSegInfoByDelGen
init|=
operator|new
name|Comparator
argument_list|<
name|SegmentCommitInfo
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|SegmentCommitInfo
name|si1
parameter_list|,
name|SegmentCommitInfo
name|si2
parameter_list|)
block|{
return|return
name|Long
operator|.
name|compare
argument_list|(
name|si1
operator|.
name|getBufferedDeletesGen
argument_list|()
argument_list|,
name|si2
operator|.
name|getBufferedDeletesGen
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/** Resolves the buffered deleted Term/Query/docIDs, into    *  actual deleted docIDs in the liveDocs MutableBits for    *  each SegmentReader. */
DECL|method|applyDeletesAndUpdates
specifier|public
specifier|synchronized
name|ApplyDeletesResult
name|applyDeletesAndUpdates
parameter_list|(
name|IndexWriter
operator|.
name|ReaderPool
name|pool
parameter_list|,
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|infos
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|t0
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
specifier|final
name|long
name|gen
init|=
name|nextGen
operator|++
decl_stmt|;
if|if
condition|(
name|infos
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|ApplyDeletesResult
argument_list|(
literal|false
argument_list|,
name|gen
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|// We only init these on demand, when we find our first deletes that need to be applied:
name|SegmentState
index|[]
name|segStates
init|=
literal|null
decl_stmt|;
name|long
name|totDelCount
init|=
literal|0
decl_stmt|;
name|long
name|totTermVisitedCount
init|=
literal|0
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|ApplyDeletesResult
name|result
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"BD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"BD"
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"applyDeletes: open segment readers took %d msec"
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|t0
argument_list|)
argument_list|)
expr_stmt|;
block|}
assert|assert
name|checkDeleteStats
argument_list|()
assert|;
if|if
condition|(
operator|!
name|any
argument_list|()
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"BD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"BD"
argument_list|,
literal|"applyDeletes: no segments; skipping"
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ApplyDeletesResult
argument_list|(
literal|false
argument_list|,
name|gen
argument_list|,
literal|null
argument_list|)
return|;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"BD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"BD"
argument_list|,
literal|"applyDeletes: infos="
operator|+
name|infos
operator|+
literal|" packetCount="
operator|+
name|updates
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|infos
operator|=
name|sortByDelGen
argument_list|(
name|infos
argument_list|)
expr_stmt|;
name|CoalescedUpdates
name|coalescedUpdates
init|=
literal|null
decl_stmt|;
name|int
name|infosIDX
init|=
name|infos
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
name|int
name|delIDX
init|=
name|updates
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
comment|// Backwards merge sort the segment delGens with the packet delGens in the buffered stream:
while|while
condition|(
name|infosIDX
operator|>=
literal|0
condition|)
block|{
specifier|final
name|FrozenBufferedUpdates
name|packet
init|=
name|delIDX
operator|>=
literal|0
condition|?
name|updates
operator|.
name|get
argument_list|(
name|delIDX
argument_list|)
else|:
literal|null
decl_stmt|;
specifier|final
name|SegmentCommitInfo
name|info
init|=
name|infos
operator|.
name|get
argument_list|(
name|infosIDX
argument_list|)
decl_stmt|;
specifier|final
name|long
name|segGen
init|=
name|info
operator|.
name|getBufferedDeletesGen
argument_list|()
decl_stmt|;
if|if
condition|(
name|packet
operator|!=
literal|null
operator|&&
name|segGen
operator|<
name|packet
operator|.
name|delGen
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|packet
operator|.
name|isSegmentPrivate
operator|&&
name|packet
operator|.
name|any
argument_list|()
condition|)
block|{
comment|/*              * Only coalesce if we are NOT on a segment private del packet: the segment private del packet              * must only apply to segments with the same delGen.  Yet, if a segment is already deleted              * from the SI since it had no more documents remaining after some del packets younger than              * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been              * removed.              */
if|if
condition|(
name|coalescedUpdates
operator|==
literal|null
condition|)
block|{
name|coalescedUpdates
operator|=
operator|new
name|CoalescedUpdates
argument_list|()
expr_stmt|;
block|}
name|coalescedUpdates
operator|.
name|update
argument_list|(
name|packet
argument_list|)
expr_stmt|;
block|}
name|delIDX
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|packet
operator|!=
literal|null
operator|&&
name|segGen
operator|==
name|packet
operator|.
name|delGen
argument_list|()
condition|)
block|{
assert|assert
name|packet
operator|.
name|isSegmentPrivate
operator|:
literal|"Packet and Segments deletegen can only match on a segment private del packet gen="
operator|+
name|segGen
assert|;
if|if
condition|(
name|segStates
operator|==
literal|null
condition|)
block|{
name|segStates
operator|=
name|openSegmentStates
argument_list|(
name|pool
argument_list|,
name|infos
argument_list|)
expr_stmt|;
block|}
name|SegmentState
name|segState
init|=
name|segStates
index|[
name|infosIDX
index|]
decl_stmt|;
comment|// Lock order: IW -> BD -> RP
assert|assert
name|pool
operator|.
name|infoIsLive
argument_list|(
name|info
argument_list|)
assert|;
name|int
name|delCount
init|=
literal|0
decl_stmt|;
specifier|final
name|DocValuesFieldUpdates
operator|.
name|Container
name|dvUpdates
init|=
operator|new
name|DocValuesFieldUpdates
operator|.
name|Container
argument_list|()
decl_stmt|;
if|if
condition|(
name|coalescedUpdates
operator|!=
literal|null
condition|)
block|{
name|delCount
operator|+=
name|applyQueryDeletes
argument_list|(
name|coalescedUpdates
operator|.
name|queriesIterable
argument_list|()
argument_list|,
name|segState
argument_list|)
expr_stmt|;
name|applyDocValuesUpdates
argument_list|(
name|coalescedUpdates
operator|.
name|numericDVUpdates
argument_list|,
name|segState
argument_list|,
name|dvUpdates
argument_list|)
expr_stmt|;
name|applyDocValuesUpdates
argument_list|(
name|coalescedUpdates
operator|.
name|binaryDVUpdates
argument_list|,
name|segState
argument_list|,
name|dvUpdates
argument_list|)
expr_stmt|;
block|}
name|delCount
operator|+=
name|applyQueryDeletes
argument_list|(
name|packet
operator|.
name|queriesIterable
argument_list|()
argument_list|,
name|segState
argument_list|)
expr_stmt|;
name|applyDocValuesUpdates
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|packet
operator|.
name|numericDVUpdates
argument_list|)
argument_list|,
name|segState
argument_list|,
name|dvUpdates
argument_list|)
expr_stmt|;
name|applyDocValuesUpdates
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|packet
operator|.
name|binaryDVUpdates
argument_list|)
argument_list|,
name|segState
argument_list|,
name|dvUpdates
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvUpdates
operator|.
name|any
argument_list|()
condition|)
block|{
name|segState
operator|.
name|rld
operator|.
name|writeFieldUpdates
argument_list|(
name|info
operator|.
name|info
operator|.
name|dir
argument_list|,
name|dvUpdates
argument_list|)
expr_stmt|;
block|}
name|totDelCount
operator|+=
name|delCount
expr_stmt|;
comment|/*            * Since we are on a segment private del packet we must not            * update the coalescedUpdates here! We can simply advance to the             * next packet and seginfo.            */
name|delIDX
operator|--
expr_stmt|;
name|infosIDX
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|coalescedUpdates
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|segStates
operator|==
literal|null
condition|)
block|{
name|segStates
operator|=
name|openSegmentStates
argument_list|(
name|pool
argument_list|,
name|infos
argument_list|)
expr_stmt|;
block|}
name|SegmentState
name|segState
init|=
name|segStates
index|[
name|infosIDX
index|]
decl_stmt|;
comment|// Lock order: IW -> BD -> RP
assert|assert
name|pool
operator|.
name|infoIsLive
argument_list|(
name|info
argument_list|)
assert|;
name|int
name|delCount
init|=
literal|0
decl_stmt|;
name|delCount
operator|+=
name|applyQueryDeletes
argument_list|(
name|coalescedUpdates
operator|.
name|queriesIterable
argument_list|()
argument_list|,
name|segState
argument_list|)
expr_stmt|;
name|DocValuesFieldUpdates
operator|.
name|Container
name|dvUpdates
init|=
operator|new
name|DocValuesFieldUpdates
operator|.
name|Container
argument_list|()
decl_stmt|;
name|applyDocValuesUpdates
argument_list|(
name|coalescedUpdates
operator|.
name|numericDVUpdates
argument_list|,
name|segState
argument_list|,
name|dvUpdates
argument_list|)
expr_stmt|;
name|applyDocValuesUpdates
argument_list|(
name|coalescedUpdates
operator|.
name|binaryDVUpdates
argument_list|,
name|segState
argument_list|,
name|dvUpdates
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvUpdates
operator|.
name|any
argument_list|()
condition|)
block|{
name|segState
operator|.
name|rld
operator|.
name|writeFieldUpdates
argument_list|(
name|info
operator|.
name|info
operator|.
name|dir
argument_list|,
name|dvUpdates
argument_list|)
expr_stmt|;
block|}
name|totDelCount
operator|+=
name|delCount
expr_stmt|;
block|}
name|infosIDX
operator|--
expr_stmt|;
block|}
block|}
comment|// Now apply all term deletes:
if|if
condition|(
name|coalescedUpdates
operator|!=
literal|null
operator|&&
name|coalescedUpdates
operator|.
name|totalTermCount
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|segStates
operator|==
literal|null
condition|)
block|{
name|segStates
operator|=
name|openSegmentStates
argument_list|(
name|pool
argument_list|,
name|infos
argument_list|)
expr_stmt|;
block|}
name|totTermVisitedCount
operator|+=
name|applyTermDeletes
argument_list|(
name|coalescedUpdates
argument_list|,
name|segStates
argument_list|)
expr_stmt|;
block|}
assert|assert
name|checkDeleteStats
argument_list|()
assert|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|segStates
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|closeSegmentStates
argument_list|(
name|pool
argument_list|,
name|segStates
argument_list|,
name|success
argument_list|,
name|gen
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
operator|new
name|ApplyDeletesResult
argument_list|(
literal|false
argument_list|,
name|gen
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"BD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"BD"
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"applyDeletes took %d msec for %d segments, %d newly deleted docs (query deletes), %d visited terms, allDeleted=%s"
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|t0
argument_list|,
name|infos
operator|.
name|size
argument_list|()
argument_list|,
name|totDelCount
argument_list|,
name|totTermVisitedCount
argument_list|,
name|result
operator|.
name|allDeleted
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|sortByDelGen
specifier|private
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|sortByDelGen
parameter_list|(
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|infos
parameter_list|)
block|{
name|infos
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|infos
argument_list|)
expr_stmt|;
comment|// Smaller delGens come first:
name|Collections
operator|.
name|sort
argument_list|(
name|infos
argument_list|,
name|sortSegInfoByDelGen
argument_list|)
expr_stmt|;
return|return
name|infos
return|;
block|}
DECL|method|getNextGen
specifier|synchronized
name|long
name|getNextGen
parameter_list|()
block|{
return|return
name|nextGen
operator|++
return|;
block|}
comment|// Lock order IW -> BD
comment|/* Removes any BufferedDeletes that we no longer need to    * store because all segments in the index have had the    * deletes applied. */
DECL|method|prune
specifier|public
specifier|synchronized
name|void
name|prune
parameter_list|(
name|SegmentInfos
name|segmentInfos
parameter_list|)
block|{
assert|assert
name|checkDeleteStats
argument_list|()
assert|;
name|long
name|minGen
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|segmentInfos
control|)
block|{
name|minGen
operator|=
name|Math
operator|.
name|min
argument_list|(
name|info
operator|.
name|getBufferedDeletesGen
argument_list|()
argument_list|,
name|minGen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"BD"
argument_list|)
condition|)
block|{
name|Directory
name|dir
decl_stmt|;
if|if
condition|(
name|segmentInfos
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|dir
operator|=
name|segmentInfos
operator|.
name|info
argument_list|(
literal|0
argument_list|)
operator|.
name|info
operator|.
name|dir
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|=
literal|null
expr_stmt|;
block|}
name|infoStream
operator|.
name|message
argument_list|(
literal|"BD"
argument_list|,
literal|"prune sis="
operator|+
name|segmentInfos
operator|+
literal|" minGen="
operator|+
name|minGen
operator|+
literal|" packetCount="
operator|+
name|updates
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|limit
init|=
name|updates
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|delIDX
init|=
literal|0
init|;
name|delIDX
operator|<
name|limit
condition|;
name|delIDX
operator|++
control|)
block|{
if|if
condition|(
name|updates
operator|.
name|get
argument_list|(
name|delIDX
argument_list|)
operator|.
name|delGen
argument_list|()
operator|>=
name|minGen
condition|)
block|{
name|prune
argument_list|(
name|delIDX
argument_list|)
expr_stmt|;
assert|assert
name|checkDeleteStats
argument_list|()
assert|;
return|return;
block|}
block|}
comment|// All deletes pruned
name|prune
argument_list|(
name|limit
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|any
argument_list|()
assert|;
assert|assert
name|checkDeleteStats
argument_list|()
assert|;
block|}
DECL|method|prune
specifier|private
specifier|synchronized
name|void
name|prune
parameter_list|(
name|int
name|count
parameter_list|)
block|{
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"BD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"BD"
argument_list|,
literal|"pruneDeletes: prune "
operator|+
name|count
operator|+
literal|" packets; "
operator|+
operator|(
name|updates
operator|.
name|size
argument_list|()
operator|-
name|count
operator|)
operator|+
literal|" packets remain"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|delIDX
init|=
literal|0
init|;
name|delIDX
operator|<
name|count
condition|;
name|delIDX
operator|++
control|)
block|{
specifier|final
name|FrozenBufferedUpdates
name|packet
init|=
name|updates
operator|.
name|get
argument_list|(
name|delIDX
argument_list|)
decl_stmt|;
name|numTerms
operator|.
name|addAndGet
argument_list|(
operator|-
name|packet
operator|.
name|numTermDeletes
argument_list|)
expr_stmt|;
assert|assert
name|numTerms
operator|.
name|get
argument_list|()
operator|>=
literal|0
assert|;
name|bytesUsed
operator|.
name|addAndGet
argument_list|(
operator|-
name|packet
operator|.
name|bytesUsed
argument_list|)
expr_stmt|;
assert|assert
name|bytesUsed
operator|.
name|get
argument_list|()
operator|>=
literal|0
assert|;
block|}
name|updates
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|count
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|SegmentState
specifier|static
class|class
name|SegmentState
block|{
DECL|field|delGen
specifier|final
name|long
name|delGen
decl_stmt|;
DECL|field|rld
specifier|final
name|ReadersAndUpdates
name|rld
decl_stmt|;
DECL|field|reader
specifier|final
name|SegmentReader
name|reader
decl_stmt|;
DECL|field|startDelCount
specifier|final
name|int
name|startDelCount
decl_stmt|;
DECL|field|termsEnum
name|TermsEnum
name|termsEnum
decl_stmt|;
DECL|field|postingsEnum
name|PostingsEnum
name|postingsEnum
decl_stmt|;
DECL|field|term
name|BytesRef
name|term
decl_stmt|;
DECL|field|any
name|boolean
name|any
decl_stmt|;
DECL|method|SegmentState
specifier|public
name|SegmentState
parameter_list|(
name|IndexWriter
operator|.
name|ReaderPool
name|pool
parameter_list|,
name|SegmentCommitInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|rld
operator|=
name|pool
operator|.
name|get
argument_list|(
name|info
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|startDelCount
operator|=
name|rld
operator|.
name|getPendingDeleteCount
argument_list|()
expr_stmt|;
name|reader
operator|=
name|rld
operator|.
name|getReader
argument_list|(
name|IOContext
operator|.
name|READ
argument_list|)
expr_stmt|;
name|delGen
operator|=
name|info
operator|.
name|getBufferedDeletesGen
argument_list|()
expr_stmt|;
block|}
DECL|method|finish
specifier|public
name|void
name|finish
parameter_list|(
name|IndexWriter
operator|.
name|ReaderPool
name|pool
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|rld
operator|.
name|release
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|pool
operator|.
name|release
argument_list|(
name|rld
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Does a merge sort by current term across all segments. */
DECL|class|SegmentQueue
specifier|static
class|class
name|SegmentQueue
extends|extends
name|PriorityQueue
argument_list|<
name|SegmentState
argument_list|>
block|{
DECL|method|SegmentQueue
specifier|public
name|SegmentQueue
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|super
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|lessThan
specifier|protected
name|boolean
name|lessThan
parameter_list|(
name|SegmentState
name|a
parameter_list|,
name|SegmentState
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|term
operator|.
name|compareTo
argument_list|(
name|b
operator|.
name|term
argument_list|)
operator|<
literal|0
return|;
block|}
block|}
comment|/** Opens SegmentReader and inits SegmentState for each segment. */
DECL|method|openSegmentStates
specifier|private
name|SegmentState
index|[]
name|openSegmentStates
parameter_list|(
name|IndexWriter
operator|.
name|ReaderPool
name|pool
parameter_list|,
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|infos
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|numReaders
init|=
name|infos
operator|.
name|size
argument_list|()
decl_stmt|;
name|SegmentState
index|[]
name|segStates
init|=
operator|new
name|SegmentState
index|[
name|numReaders
index|]
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numReaders
condition|;
name|i
operator|++
control|)
block|{
name|segStates
index|[
name|i
index|]
operator|=
operator|new
name|SegmentState
argument_list|(
name|pool
argument_list|,
name|infos
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numReaders
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|segStates
index|[
name|j
index|]
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|segStates
index|[
name|j
index|]
operator|.
name|finish
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
comment|// suppress so we keep throwing original exc
block|}
block|}
block|}
block|}
block|}
return|return
name|segStates
return|;
block|}
comment|/** Close segment states previously opened with openSegmentStates. */
DECL|method|closeSegmentStates
specifier|private
name|ApplyDeletesResult
name|closeSegmentStates
parameter_list|(
name|IndexWriter
operator|.
name|ReaderPool
name|pool
parameter_list|,
name|SegmentState
index|[]
name|segStates
parameter_list|,
name|boolean
name|success
parameter_list|,
name|long
name|gen
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|numReaders
init|=
name|segStates
operator|.
name|length
decl_stmt|;
name|Throwable
name|firstExc
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|allDeleted
init|=
literal|null
decl_stmt|;
name|long
name|totDelCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numReaders
condition|;
name|j
operator|++
control|)
block|{
name|SegmentState
name|segState
init|=
name|segStates
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|totDelCount
operator|+=
name|segState
operator|.
name|rld
operator|.
name|getPendingDeleteCount
argument_list|()
operator|-
name|segState
operator|.
name|startDelCount
expr_stmt|;
name|segState
operator|.
name|reader
operator|.
name|getSegmentInfo
argument_list|()
operator|.
name|setBufferedDeletesGen
argument_list|(
name|gen
argument_list|)
expr_stmt|;
name|int
name|fullDelCount
init|=
name|segState
operator|.
name|rld
operator|.
name|info
operator|.
name|getDelCount
argument_list|()
operator|+
name|segState
operator|.
name|rld
operator|.
name|getPendingDeleteCount
argument_list|()
decl_stmt|;
assert|assert
name|fullDelCount
operator|<=
name|segState
operator|.
name|rld
operator|.
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
assert|;
if|if
condition|(
name|fullDelCount
operator|==
name|segState
operator|.
name|rld
operator|.
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
condition|)
block|{
if|if
condition|(
name|allDeleted
operator|==
literal|null
condition|)
block|{
name|allDeleted
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|allDeleted
operator|.
name|add
argument_list|(
name|segState
operator|.
name|reader
operator|.
name|getSegmentInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|segStates
index|[
name|j
index|]
operator|.
name|finish
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
if|if
condition|(
name|firstExc
operator|!=
literal|null
condition|)
block|{
name|firstExc
operator|=
name|th
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|success
condition|)
block|{
comment|// Does nothing if firstExc is null:
name|IOUtils
operator|.
name|reThrow
argument_list|(
name|firstExc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"BD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"BD"
argument_list|,
literal|"applyDeletes: "
operator|+
name|totDelCount
operator|+
literal|" new deleted documents"
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ApplyDeletesResult
argument_list|(
name|totDelCount
operator|>
literal|0
argument_list|,
name|gen
argument_list|,
name|allDeleted
argument_list|)
return|;
block|}
comment|/** Merge sorts the deleted terms and all segments to resolve terms to docIDs for deletion. */
DECL|method|applyTermDeletes
specifier|private
specifier|synchronized
name|long
name|applyTermDeletes
parameter_list|(
name|CoalescedUpdates
name|updates
parameter_list|,
name|SegmentState
index|[]
name|segStates
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|startNS
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|int
name|numReaders
init|=
name|segStates
operator|.
name|length
decl_stmt|;
name|long
name|delTermVisitedCount
init|=
literal|0
decl_stmt|;
name|long
name|segTermVisitedCount
init|=
literal|0
decl_stmt|;
name|FieldTermIterator
name|iter
init|=
name|updates
operator|.
name|termIterator
argument_list|()
decl_stmt|;
name|String
name|field
init|=
literal|null
decl_stmt|;
name|SegmentQueue
name|queue
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|boolean
name|newField
decl_stmt|;
name|newField
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|newField
condition|)
block|{
name|field
operator|=
name|iter
operator|.
name|field
argument_list|()
expr_stmt|;
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
comment|// No more terms:
break|break;
block|}
name|queue
operator|=
operator|new
name|SegmentQueue
argument_list|(
name|numReaders
argument_list|)
expr_stmt|;
name|long
name|segTermCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numReaders
condition|;
name|i
operator|++
control|)
block|{
name|SegmentState
name|state
init|=
name|segStates
index|[
name|i
index|]
decl_stmt|;
name|Terms
name|terms
init|=
name|state
operator|.
name|reader
operator|.
name|fields
argument_list|()
operator|.
name|terms
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|!=
literal|null
condition|)
block|{
name|segTermCount
operator|+=
name|terms
operator|.
name|size
argument_list|()
expr_stmt|;
name|state
operator|.
name|termsEnum
operator|=
name|terms
operator|.
name|iterator
argument_list|(
name|state
operator|.
name|termsEnum
argument_list|)
expr_stmt|;
name|state
operator|.
name|term
operator|=
name|state
operator|.
name|termsEnum
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|term
operator|!=
literal|null
condition|)
block|{
name|queue
operator|.
name|add
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
block|}
assert|assert
name|checkDeleteTerm
argument_list|(
literal|null
argument_list|)
assert|;
block|}
comment|// Get next term to delete
name|BytesRef
name|term
init|=
name|iter
operator|.
name|term
argument_list|()
decl_stmt|;
assert|assert
name|checkDeleteTerm
argument_list|(
name|term
argument_list|)
assert|;
name|delTermVisitedCount
operator|++
expr_stmt|;
name|long
name|delGen
init|=
name|iter
operator|.
name|delGen
argument_list|()
decl_stmt|;
while|while
condition|(
name|queue
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// Get next term merged across all segments
name|SegmentState
name|state
init|=
name|queue
operator|.
name|top
argument_list|()
decl_stmt|;
name|segTermVisitedCount
operator|++
expr_stmt|;
name|int
name|cmp
init|=
name|term
operator|.
name|compareTo
argument_list|(
name|state
operator|.
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
comment|// fall through
block|}
else|else
block|{
name|TermsEnum
operator|.
name|SeekStatus
name|status
init|=
name|state
operator|.
name|termsEnum
operator|.
name|seekCeil
argument_list|(
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|FOUND
condition|)
block|{
comment|// fallthrough
block|}
else|else
block|{
if|if
condition|(
name|status
operator|==
name|TermsEnum
operator|.
name|SeekStatus
operator|.
name|NOT_FOUND
condition|)
block|{
name|state
operator|.
name|term
operator|=
name|state
operator|.
name|termsEnum
operator|.
name|term
argument_list|()
expr_stmt|;
name|queue
operator|.
name|updateTop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// No more terms in this segment
name|queue
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
continue|continue;
block|}
block|}
assert|assert
name|state
operator|.
name|delGen
operator|!=
name|delGen
assert|;
if|if
condition|(
name|state
operator|.
name|delGen
operator|<
name|delGen
condition|)
block|{
comment|// we don't need term frequencies for this
name|state
operator|.
name|postingsEnum
operator|=
name|state
operator|.
name|termsEnum
operator|.
name|postings
argument_list|(
name|state
operator|.
name|rld
operator|.
name|getLiveDocs
argument_list|()
argument_list|,
name|state
operator|.
name|postingsEnum
argument_list|,
name|PostingsEnum
operator|.
name|NONE
argument_list|)
expr_stmt|;
assert|assert
name|state
operator|.
name|postingsEnum
operator|!=
literal|null
assert|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|docID
init|=
name|state
operator|.
name|postingsEnum
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|docID
operator|==
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|!
name|state
operator|.
name|any
condition|)
block|{
name|state
operator|.
name|rld
operator|.
name|initWritableLiveDocs
argument_list|()
expr_stmt|;
name|state
operator|.
name|any
operator|=
literal|true
expr_stmt|;
block|}
comment|// NOTE: there is no limit check on the docID
comment|// when deleting by Term (unlike by Query)
comment|// because on flush we apply all Term deletes to
comment|// each segment.  So all Term deleting here is
comment|// against prior segments:
name|state
operator|.
name|rld
operator|.
name|delete
argument_list|(
name|docID
argument_list|)
expr_stmt|;
block|}
block|}
name|state
operator|.
name|term
operator|=
name|state
operator|.
name|termsEnum
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|term
operator|==
literal|null
condition|)
block|{
name|queue
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|queue
operator|.
name|updateTop
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"BD"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"BD"
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"applyTermDeletes took %.1f msec for %d segments and %d packets; %d del terms visited; %d seg terms visited"
argument_list|,
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startNS
operator|)
operator|/
literal|1000000.
argument_list|,
name|numReaders
argument_list|,
name|updates
operator|.
name|terms
operator|.
name|size
argument_list|()
argument_list|,
name|delTermVisitedCount
argument_list|,
name|segTermVisitedCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|delTermVisitedCount
return|;
block|}
comment|// DocValues updates
DECL|method|applyDocValuesUpdates
specifier|private
specifier|synchronized
name|void
name|applyDocValuesUpdates
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|DocValuesUpdate
argument_list|>
name|updates
parameter_list|,
name|SegmentState
name|segState
parameter_list|,
name|DocValuesFieldUpdates
operator|.
name|Container
name|dvUpdatesContainer
parameter_list|)
throws|throws
name|IOException
block|{
name|Fields
name|fields
init|=
name|segState
operator|.
name|reader
operator|.
name|fields
argument_list|()
decl_stmt|;
comment|// TODO: we can process the updates per DV field, from last to first so that
comment|// if multiple terms affect same document for the same field, we add an update
comment|// only once (that of the last term). To do that, we can keep a bitset which
comment|// marks which documents have already been updated. So e.g. if term T1
comment|// updates doc 7, and then we process term T2 and it updates doc 7 as well,
comment|// we don't apply the update since we know T1 came last and therefore wins
comment|// the update.
comment|// We can also use that bitset as 'liveDocs' to pass to TermEnum.docs(), so
comment|// that these documents aren't even returned.
name|String
name|currentField
init|=
literal|null
decl_stmt|;
name|TermsEnum
name|termsEnum
init|=
literal|null
decl_stmt|;
name|PostingsEnum
name|postingsEnum
init|=
literal|null
decl_stmt|;
for|for
control|(
name|DocValuesUpdate
name|update
range|:
name|updates
control|)
block|{
name|Term
name|term
init|=
name|update
operator|.
name|term
decl_stmt|;
name|int
name|limit
init|=
name|update
operator|.
name|docIDUpto
decl_stmt|;
comment|// TODO: we traverse the terms in update order (not term order) so that we
comment|// apply the updates in the correct order, i.e. if two terms udpate the
comment|// same document, the last one that came in wins, irrespective of the
comment|// terms lexical order.
comment|// we can apply the updates in terms order if we keep an updatesGen (and
comment|// increment it with every update) and attach it to each NumericUpdate. Note
comment|// that we cannot rely only on docIDUpto because an app may send two updates
comment|// which will get same docIDUpto, yet will still need to respect the order
comment|// those updates arrived.
if|if
condition|(
operator|!
name|term
operator|.
name|field
argument_list|()
operator|.
name|equals
argument_list|(
name|currentField
argument_list|)
condition|)
block|{
comment|// if we change the code to process updates in terms order, enable this assert
comment|//        assert currentField == null || currentField.compareTo(term.field())< 0;
name|currentField
operator|=
name|term
operator|.
name|field
argument_list|()
expr_stmt|;
name|Terms
name|terms
init|=
name|fields
operator|.
name|terms
argument_list|(
name|currentField
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|!=
literal|null
condition|)
block|{
name|termsEnum
operator|=
name|terms
operator|.
name|iterator
argument_list|(
name|termsEnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|termsEnum
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|termsEnum
operator|==
literal|null
condition|)
block|{
comment|// no terms in this field
continue|continue;
block|}
if|if
condition|(
name|termsEnum
operator|.
name|seekExact
argument_list|(
name|term
operator|.
name|bytes
argument_list|()
argument_list|)
condition|)
block|{
comment|// we don't need term frequencies for this
name|postingsEnum
operator|=
name|termsEnum
operator|.
name|postings
argument_list|(
name|segState
operator|.
name|rld
operator|.
name|getLiveDocs
argument_list|()
argument_list|,
name|postingsEnum
argument_list|,
name|PostingsEnum
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|DocValuesFieldUpdates
name|dvUpdates
init|=
name|dvUpdatesContainer
operator|.
name|getUpdates
argument_list|(
name|update
operator|.
name|field
argument_list|,
name|update
operator|.
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|dvUpdates
operator|==
literal|null
condition|)
block|{
name|dvUpdates
operator|=
name|dvUpdatesContainer
operator|.
name|newUpdates
argument_list|(
name|update
operator|.
name|field
argument_list|,
name|update
operator|.
name|type
argument_list|,
name|segState
operator|.
name|reader
operator|.
name|maxDoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|doc
decl_stmt|;
while|while
condition|(
operator|(
name|doc
operator|=
name|postingsEnum
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocIdSetIterator
operator|.
name|NO_MORE_DOCS
condition|)
block|{
if|if
condition|(
name|doc
operator|>=
name|limit
condition|)
block|{
break|break;
comment|// no more docs that can be updated for this term
block|}
name|dvUpdates
operator|.
name|add
argument_list|(
name|doc
argument_list|,
name|update
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|QueryAndLimit
specifier|public
specifier|static
class|class
name|QueryAndLimit
block|{
DECL|field|query
specifier|public
specifier|final
name|Query
name|query
decl_stmt|;
DECL|field|limit
specifier|public
specifier|final
name|int
name|limit
decl_stmt|;
DECL|method|QueryAndLimit
specifier|public
name|QueryAndLimit
parameter_list|(
name|Query
name|query
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|this
operator|.
name|query
operator|=
name|query
expr_stmt|;
name|this
operator|.
name|limit
operator|=
name|limit
expr_stmt|;
block|}
block|}
comment|// Delete by query
DECL|method|applyQueryDeletes
specifier|private
specifier|static
name|long
name|applyQueryDeletes
parameter_list|(
name|Iterable
argument_list|<
name|QueryAndLimit
argument_list|>
name|queriesIter
parameter_list|,
name|SegmentState
name|segState
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|delCount
init|=
literal|0
decl_stmt|;
specifier|final
name|LeafReaderContext
name|readerContext
init|=
name|segState
operator|.
name|reader
operator|.
name|getContext
argument_list|()
decl_stmt|;
for|for
control|(
name|QueryAndLimit
name|ent
range|:
name|queriesIter
control|)
block|{
name|Query
name|query
init|=
name|ent
operator|.
name|query
decl_stmt|;
name|int
name|limit
init|=
name|ent
operator|.
name|limit
decl_stmt|;
specifier|final
name|DocIdSet
name|docs
init|=
operator|new
name|QueryWrapperFilter
argument_list|(
name|query
argument_list|)
operator|.
name|getDocIdSet
argument_list|(
name|readerContext
argument_list|,
name|segState
operator|.
name|reader
operator|.
name|getLiveDocs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|docs
operator|!=
literal|null
condition|)
block|{
specifier|final
name|DocIdSetIterator
name|it
init|=
name|docs
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|it
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|doc
init|=
name|it
operator|.
name|nextDoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
operator|>=
name|limit
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|!
name|segState
operator|.
name|any
condition|)
block|{
name|segState
operator|.
name|rld
operator|.
name|initWritableLiveDocs
argument_list|()
expr_stmt|;
name|segState
operator|.
name|any
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|segState
operator|.
name|rld
operator|.
name|delete
argument_list|(
name|doc
argument_list|)
condition|)
block|{
name|delCount
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|delCount
return|;
block|}
comment|// used only by assert
DECL|method|checkDeleteTerm
specifier|private
name|boolean
name|checkDeleteTerm
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
if|if
condition|(
name|term
operator|!=
literal|null
condition|)
block|{
assert|assert
name|lastDeleteTerm
operator|==
literal|null
operator|||
name|term
operator|.
name|compareTo
argument_list|(
name|lastDeleteTerm
argument_list|)
operator|>=
literal|0
operator|:
literal|"lastTerm="
operator|+
name|lastDeleteTerm
operator|+
literal|" vs term="
operator|+
name|term
assert|;
block|}
comment|// TODO: we re-use term now in our merged iterable, but we shouldn't clone, instead copy for this assert
name|lastDeleteTerm
operator|=
name|term
operator|==
literal|null
condition|?
literal|null
else|:
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|term
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// only for assert
DECL|method|checkDeleteStats
specifier|private
name|boolean
name|checkDeleteStats
parameter_list|()
block|{
name|int
name|numTerms2
init|=
literal|0
decl_stmt|;
name|long
name|bytesUsed2
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FrozenBufferedUpdates
name|packet
range|:
name|updates
control|)
block|{
name|numTerms2
operator|+=
name|packet
operator|.
name|numTermDeletes
expr_stmt|;
name|bytesUsed2
operator|+=
name|packet
operator|.
name|bytesUsed
expr_stmt|;
block|}
assert|assert
name|numTerms2
operator|==
name|numTerms
operator|.
name|get
argument_list|()
operator|:
literal|"numTerms2="
operator|+
name|numTerms2
operator|+
literal|" vs "
operator|+
name|numTerms
operator|.
name|get
argument_list|()
assert|;
assert|assert
name|bytesUsed2
operator|==
name|bytesUsed
operator|.
name|get
argument_list|()
operator|:
literal|"bytesUsed2="
operator|+
name|bytesUsed2
operator|+
literal|" vs "
operator|+
name|bytesUsed
assert|;
return|return
literal|true
return|;
block|}
block|}
end_class
end_unit
