begin_unit
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocumentsWriterPerThreadPool
operator|.
name|ThreadState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Accountable
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|InfoStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ThreadInterruptedException
import|;
end_import
begin_comment
comment|/**  * This class controls {@link DocumentsWriterPerThread} flushing during  * indexing. It tracks the memory consumption per  * {@link DocumentsWriterPerThread} and uses a configured {@link FlushPolicy} to  * decide if a {@link DocumentsWriterPerThread} must flush.  *<p>  * In addition to the {@link FlushPolicy} the flush control might set certain  * {@link DocumentsWriterPerThread} as flush pending iff a  * {@link DocumentsWriterPerThread} exceeds the  * {@link IndexWriterConfig#getRAMPerThreadHardLimitMB()} to prevent address  * space exhaustion.  */
end_comment
begin_class
DECL|class|DocumentsWriterFlushControl
specifier|final
class|class
name|DocumentsWriterFlushControl
implements|implements
name|Accountable
block|{
DECL|field|hardMaxBytesPerDWPT
specifier|private
specifier|final
name|long
name|hardMaxBytesPerDWPT
decl_stmt|;
DECL|field|activeBytes
specifier|private
name|long
name|activeBytes
init|=
literal|0
decl_stmt|;
DECL|field|flushBytes
specifier|private
name|long
name|flushBytes
init|=
literal|0
decl_stmt|;
DECL|field|numPending
specifier|private
specifier|volatile
name|int
name|numPending
init|=
literal|0
decl_stmt|;
DECL|field|numDocsSinceStalled
specifier|private
name|int
name|numDocsSinceStalled
init|=
literal|0
decl_stmt|;
comment|// only with assert
DECL|field|flushDeletes
specifier|final
name|AtomicBoolean
name|flushDeletes
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|fullFlush
specifier|private
name|boolean
name|fullFlush
init|=
literal|false
decl_stmt|;
DECL|field|flushQueue
specifier|private
specifier|final
name|Queue
argument_list|<
name|DocumentsWriterPerThread
argument_list|>
name|flushQueue
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// only for safety reasons if a DWPT is close to the RAM limit
DECL|field|blockedFlushes
specifier|private
specifier|final
name|Queue
argument_list|<
name|BlockedFlush
argument_list|>
name|blockedFlushes
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|flushingWriters
specifier|private
specifier|final
name|IdentityHashMap
argument_list|<
name|DocumentsWriterPerThread
argument_list|,
name|Long
argument_list|>
name|flushingWriters
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|maxConfiguredRamBuffer
name|double
name|maxConfiguredRamBuffer
init|=
literal|0
decl_stmt|;
DECL|field|peakActiveBytes
name|long
name|peakActiveBytes
init|=
literal|0
decl_stmt|;
comment|// only with assert
DECL|field|peakFlushBytes
name|long
name|peakFlushBytes
init|=
literal|0
decl_stmt|;
comment|// only with assert
DECL|field|peakNetBytes
name|long
name|peakNetBytes
init|=
literal|0
decl_stmt|;
comment|// only with assert
DECL|field|peakDelta
name|long
name|peakDelta
init|=
literal|0
decl_stmt|;
comment|// only with assert
DECL|field|flushByRAMWasDisabled
name|boolean
name|flushByRAMWasDisabled
decl_stmt|;
comment|// only with assert
DECL|field|stallControl
specifier|final
name|DocumentsWriterStallControl
name|stallControl
decl_stmt|;
DECL|field|perThreadPool
specifier|private
specifier|final
name|DocumentsWriterPerThreadPool
name|perThreadPool
decl_stmt|;
DECL|field|flushPolicy
specifier|private
specifier|final
name|FlushPolicy
name|flushPolicy
decl_stmt|;
DECL|field|closed
specifier|private
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
DECL|field|documentsWriter
specifier|private
specifier|final
name|DocumentsWriter
name|documentsWriter
decl_stmt|;
DECL|field|config
specifier|private
specifier|final
name|LiveIndexWriterConfig
name|config
decl_stmt|;
DECL|field|bufferedUpdatesStream
specifier|private
specifier|final
name|BufferedUpdatesStream
name|bufferedUpdatesStream
decl_stmt|;
DECL|field|infoStream
specifier|private
specifier|final
name|InfoStream
name|infoStream
decl_stmt|;
DECL|method|DocumentsWriterFlushControl
name|DocumentsWriterFlushControl
parameter_list|(
name|DocumentsWriter
name|documentsWriter
parameter_list|,
name|LiveIndexWriterConfig
name|config
parameter_list|,
name|BufferedUpdatesStream
name|bufferedUpdatesStream
parameter_list|)
block|{
name|this
operator|.
name|infoStream
operator|=
name|config
operator|.
name|getInfoStream
argument_list|()
expr_stmt|;
name|this
operator|.
name|stallControl
operator|=
operator|new
name|DocumentsWriterStallControl
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|this
operator|.
name|perThreadPool
operator|=
name|documentsWriter
operator|.
name|perThreadPool
expr_stmt|;
name|this
operator|.
name|flushPolicy
operator|=
name|documentsWriter
operator|.
name|flushPolicy
expr_stmt|;
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
name|this
operator|.
name|hardMaxBytesPerDWPT
operator|=
name|config
operator|.
name|getRAMPerThreadHardLimitMB
argument_list|()
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
name|this
operator|.
name|documentsWriter
operator|=
name|documentsWriter
expr_stmt|;
name|this
operator|.
name|bufferedUpdatesStream
operator|=
name|bufferedUpdatesStream
expr_stmt|;
block|}
DECL|method|activeBytes
specifier|public
specifier|synchronized
name|long
name|activeBytes
parameter_list|()
block|{
return|return
name|activeBytes
return|;
block|}
DECL|method|flushBytes
specifier|public
specifier|synchronized
name|long
name|flushBytes
parameter_list|()
block|{
return|return
name|flushBytes
return|;
block|}
DECL|method|netBytes
specifier|public
specifier|synchronized
name|long
name|netBytes
parameter_list|()
block|{
return|return
name|flushBytes
operator|+
name|activeBytes
return|;
block|}
DECL|method|stallLimitBytes
specifier|private
name|long
name|stallLimitBytes
parameter_list|()
block|{
specifier|final
name|double
name|maxRamMB
init|=
name|config
operator|.
name|getRAMBufferSizeMB
argument_list|()
decl_stmt|;
return|return
name|maxRamMB
operator|!=
name|IndexWriterConfig
operator|.
name|DISABLE_AUTO_FLUSH
condition|?
call|(
name|long
call|)
argument_list|(
literal|2
operator|*
operator|(
name|maxRamMB
operator|*
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
else|:
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
DECL|method|assertMemory
specifier|private
name|boolean
name|assertMemory
parameter_list|()
block|{
specifier|final
name|double
name|maxRamMB
init|=
name|config
operator|.
name|getRAMBufferSizeMB
argument_list|()
decl_stmt|;
comment|// We can only assert if we have always been flushing by RAM usage; otherwise the assert will false trip if e.g. the
comment|// flush-by-doc-count * doc size was large enough to use far more RAM than the sudden change to IWC's maxRAMBufferSizeMB:
if|if
condition|(
name|maxRamMB
operator|!=
name|IndexWriterConfig
operator|.
name|DISABLE_AUTO_FLUSH
operator|&&
name|flushByRAMWasDisabled
operator|==
literal|false
condition|)
block|{
comment|// for this assert we must be tolerant to ram buffer changes!
name|maxConfiguredRamBuffer
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxRamMB
argument_list|,
name|maxConfiguredRamBuffer
argument_list|)
expr_stmt|;
specifier|final
name|long
name|ram
init|=
name|flushBytes
operator|+
name|activeBytes
decl_stmt|;
specifier|final
name|long
name|ramBufferBytes
init|=
call|(
name|long
call|)
argument_list|(
name|maxConfiguredRamBuffer
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
decl_stmt|;
comment|// take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta
comment|// 2 * ramBufferBytes -> before we stall we need to cross the 2xRAM Buffer border this is still a valid limit
comment|// (numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) -> those are the total number of DWPT that are not active but not yet fully flushed
comment|// all of them could theoretically be taken out of the loop once they crossed the RAM buffer and the last document was the peak delta
comment|// (numDocsSinceStalled * peakDelta) -> at any given time there could be n threads in flight that crossed the stall control before we reached the limit and each of them could hold a peak document
specifier|final
name|long
name|expected
init|=
operator|(
literal|2
operator|*
name|ramBufferBytes
operator|)
operator|+
operator|(
operator|(
name|numPending
operator|+
name|numFlushingDWPT
argument_list|()
operator|+
name|numBlockedFlushes
argument_list|()
operator|)
operator|*
name|peakDelta
operator|)
operator|+
operator|(
name|numDocsSinceStalled
operator|*
name|peakDelta
operator|)
decl_stmt|;
comment|// the expected ram consumption is an upper bound at this point and not really the expected consumption
if|if
condition|(
name|peakDelta
operator|<
operator|(
name|ramBufferBytes
operator|>>
literal|1
operator|)
condition|)
block|{
comment|/*          * if we are indexing with very low maxRamBuffer like 0.1MB memory can          * easily overflow if we check out some DWPT based on docCount and have          * several DWPT in flight indexing large documents (compared to the ram          * buffer). This means that those DWPT and their threads will not hit          * the stall control before asserting the memory which would in turn          * fail. To prevent this we only assert if the the largest document seen          * is smaller than the 1/2 of the maxRamBufferMB          */
assert|assert
name|ram
operator|<=
name|expected
operator|:
literal|"actual mem: "
operator|+
name|ram
operator|+
literal|" byte, expected mem: "
operator|+
name|expected
operator|+
literal|" byte, flush mem: "
operator|+
name|flushBytes
operator|+
literal|", active mem: "
operator|+
name|activeBytes
operator|+
literal|", pending DWPT: "
operator|+
name|numPending
operator|+
literal|", flushing DWPT: "
operator|+
name|numFlushingDWPT
argument_list|()
operator|+
literal|", blocked DWPT: "
operator|+
name|numBlockedFlushes
argument_list|()
operator|+
literal|", peakDelta mem: "
operator|+
name|peakDelta
operator|+
literal|" bytes, ramBufferBytes="
operator|+
name|ramBufferBytes
operator|+
literal|", maxConfiguredRamBuffer="
operator|+
name|maxConfiguredRamBuffer
assert|;
block|}
block|}
else|else
block|{
name|flushByRAMWasDisabled
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|commitPerThreadBytes
specifier|private
name|void
name|commitPerThreadBytes
parameter_list|(
name|ThreadState
name|perThread
parameter_list|)
block|{
specifier|final
name|long
name|delta
init|=
name|perThread
operator|.
name|dwpt
operator|.
name|bytesUsed
argument_list|()
operator|-
name|perThread
operator|.
name|bytesUsed
decl_stmt|;
name|perThread
operator|.
name|bytesUsed
operator|+=
name|delta
expr_stmt|;
comment|/*      * We need to differentiate here if we are pending since setFlushPending      * moves the perThread memory to the flushBytes and we could be set to      * pending during a delete      */
if|if
condition|(
name|perThread
operator|.
name|flushPending
condition|)
block|{
name|flushBytes
operator|+=
name|delta
expr_stmt|;
block|}
else|else
block|{
name|activeBytes
operator|+=
name|delta
expr_stmt|;
block|}
assert|assert
name|updatePeaks
argument_list|(
name|delta
argument_list|)
assert|;
block|}
comment|// only for asserts
DECL|method|updatePeaks
specifier|private
name|boolean
name|updatePeaks
parameter_list|(
name|long
name|delta
parameter_list|)
block|{
name|peakActiveBytes
operator|=
name|Math
operator|.
name|max
argument_list|(
name|peakActiveBytes
argument_list|,
name|activeBytes
argument_list|)
expr_stmt|;
name|peakFlushBytes
operator|=
name|Math
operator|.
name|max
argument_list|(
name|peakFlushBytes
argument_list|,
name|flushBytes
argument_list|)
expr_stmt|;
name|peakNetBytes
operator|=
name|Math
operator|.
name|max
argument_list|(
name|peakNetBytes
argument_list|,
name|netBytes
argument_list|()
argument_list|)
expr_stmt|;
name|peakDelta
operator|=
name|Math
operator|.
name|max
argument_list|(
name|peakDelta
argument_list|,
name|delta
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|doAfterDocument
specifier|synchronized
name|DocumentsWriterPerThread
name|doAfterDocument
parameter_list|(
name|ThreadState
name|perThread
parameter_list|,
name|boolean
name|isUpdate
parameter_list|)
block|{
try|try
block|{
name|commitPerThreadBytes
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|perThread
operator|.
name|flushPending
condition|)
block|{
if|if
condition|(
name|isUpdate
condition|)
block|{
name|flushPolicy
operator|.
name|onUpdate
argument_list|(
name|this
argument_list|,
name|perThread
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flushPolicy
operator|.
name|onInsert
argument_list|(
name|this
argument_list|,
name|perThread
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perThread
operator|.
name|flushPending
operator|&&
name|perThread
operator|.
name|bytesUsed
operator|>
name|hardMaxBytesPerDWPT
condition|)
block|{
comment|// Safety check to prevent a single DWPT exceeding its RAM limit. This
comment|// is super important since we can not address more than 2048 MB per DWPT
name|setFlushPending
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|DocumentsWriterPerThread
name|flushingDWPT
decl_stmt|;
if|if
condition|(
name|fullFlush
condition|)
block|{
if|if
condition|(
name|perThread
operator|.
name|flushPending
condition|)
block|{
name|checkoutAndBlock
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
name|flushingDWPT
operator|=
name|nextPendingFlush
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|flushingDWPT
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|flushingDWPT
operator|=
name|tryCheckoutForFlush
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
block|}
return|return
name|flushingDWPT
return|;
block|}
finally|finally
block|{
name|boolean
name|stalled
init|=
name|updateStallState
argument_list|()
decl_stmt|;
assert|assert
name|assertNumDocsSinceStalled
argument_list|(
name|stalled
argument_list|)
operator|&&
name|assertMemory
argument_list|()
assert|;
block|}
block|}
DECL|method|assertNumDocsSinceStalled
specifier|private
name|boolean
name|assertNumDocsSinceStalled
parameter_list|(
name|boolean
name|stalled
parameter_list|)
block|{
comment|/*      *  updates the number of documents "finished" while we are in a stalled state.      *  this is important for asserting memory upper bounds since it corresponds       *  to the number of threads that are in-flight and crossed the stall control      *  check before we actually stalled.      *  see #assertMemory()      */
if|if
condition|(
name|stalled
condition|)
block|{
name|numDocsSinceStalled
operator|++
expr_stmt|;
block|}
else|else
block|{
name|numDocsSinceStalled
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|doAfterFlush
specifier|synchronized
name|void
name|doAfterFlush
parameter_list|(
name|DocumentsWriterPerThread
name|dwpt
parameter_list|)
block|{
assert|assert
name|flushingWriters
operator|.
name|containsKey
argument_list|(
name|dwpt
argument_list|)
assert|;
try|try
block|{
name|Long
name|bytes
init|=
name|flushingWriters
operator|.
name|remove
argument_list|(
name|dwpt
argument_list|)
decl_stmt|;
name|flushBytes
operator|-=
name|bytes
operator|.
name|longValue
argument_list|()
expr_stmt|;
name|perThreadPool
operator|.
name|recycle
argument_list|(
name|dwpt
argument_list|)
expr_stmt|;
assert|assert
name|assertMemory
argument_list|()
assert|;
block|}
finally|finally
block|{
try|try
block|{
name|updateStallState
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|updateStallState
specifier|private
name|boolean
name|updateStallState
parameter_list|()
block|{
assert|assert
name|Thread
operator|.
name|holdsLock
argument_list|(
name|this
argument_list|)
assert|;
specifier|final
name|long
name|limit
init|=
name|stallLimitBytes
argument_list|()
decl_stmt|;
comment|/*      * we block indexing threads if net byte grows due to slow flushes      * yet, for small ram buffers and large documents we can easily      * reach the limit without any ongoing flushes. we need to ensure      * that we don't stall/block if an ongoing or pending flush can      * not free up enough memory to release the stall lock.      */
specifier|final
name|boolean
name|stall
init|=
operator|(
name|activeBytes
operator|+
name|flushBytes
operator|)
operator|>
name|limit
operator|&&
name|activeBytes
operator|<
name|limit
operator|&&
operator|!
name|closed
decl_stmt|;
name|stallControl
operator|.
name|updateStalled
argument_list|(
name|stall
argument_list|)
expr_stmt|;
return|return
name|stall
return|;
block|}
DECL|method|waitForFlush
specifier|public
specifier|synchronized
name|void
name|waitForFlush
parameter_list|()
block|{
while|while
condition|(
name|flushingWriters
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
try|try
block|{
name|this
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ThreadInterruptedException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Sets flush pending state on the given {@link ThreadState}. The    * {@link ThreadState} must have indexed at least on Document and must not be    * already pending.    */
DECL|method|setFlushPending
specifier|public
specifier|synchronized
name|void
name|setFlushPending
parameter_list|(
name|ThreadState
name|perThread
parameter_list|)
block|{
assert|assert
operator|!
name|perThread
operator|.
name|flushPending
assert|;
if|if
condition|(
name|perThread
operator|.
name|dwpt
operator|.
name|getNumDocsInRAM
argument_list|()
operator|>
literal|0
condition|)
block|{
name|perThread
operator|.
name|flushPending
operator|=
literal|true
expr_stmt|;
comment|// write access synced
specifier|final
name|long
name|bytes
init|=
name|perThread
operator|.
name|bytesUsed
decl_stmt|;
name|flushBytes
operator|+=
name|bytes
expr_stmt|;
name|activeBytes
operator|-=
name|bytes
expr_stmt|;
name|numPending
operator|++
expr_stmt|;
comment|// write access synced
assert|assert
name|assertMemory
argument_list|()
assert|;
block|}
comment|// don't assert on numDocs since we could hit an abort excp. while selecting that dwpt for flushing
block|}
DECL|method|doOnAbort
specifier|synchronized
name|void
name|doOnAbort
parameter_list|(
name|ThreadState
name|state
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|state
operator|.
name|flushPending
condition|)
block|{
name|flushBytes
operator|-=
name|state
operator|.
name|bytesUsed
expr_stmt|;
block|}
else|else
block|{
name|activeBytes
operator|-=
name|state
operator|.
name|bytesUsed
expr_stmt|;
block|}
assert|assert
name|assertMemory
argument_list|()
assert|;
comment|// Take it out of the loop this DWPT is stale
name|perThreadPool
operator|.
name|reset
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|updateStallState
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|tryCheckoutForFlush
specifier|synchronized
name|DocumentsWriterPerThread
name|tryCheckoutForFlush
parameter_list|(
name|ThreadState
name|perThread
parameter_list|)
block|{
return|return
name|perThread
operator|.
name|flushPending
condition|?
name|internalTryCheckOutForFlush
argument_list|(
name|perThread
argument_list|)
else|:
literal|null
return|;
block|}
DECL|method|checkoutAndBlock
specifier|private
name|void
name|checkoutAndBlock
parameter_list|(
name|ThreadState
name|perThread
parameter_list|)
block|{
name|perThread
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
assert|assert
name|perThread
operator|.
name|flushPending
operator|:
literal|"can not block non-pending threadstate"
assert|;
assert|assert
name|fullFlush
operator|:
literal|"can not block if fullFlush == false"
assert|;
specifier|final
name|DocumentsWriterPerThread
name|dwpt
decl_stmt|;
specifier|final
name|long
name|bytes
init|=
name|perThread
operator|.
name|bytesUsed
decl_stmt|;
name|dwpt
operator|=
name|perThreadPool
operator|.
name|reset
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
name|numPending
operator|--
expr_stmt|;
name|blockedFlushes
operator|.
name|add
argument_list|(
operator|new
name|BlockedFlush
argument_list|(
name|dwpt
argument_list|,
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|perThread
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|internalTryCheckOutForFlush
specifier|private
name|DocumentsWriterPerThread
name|internalTryCheckOutForFlush
parameter_list|(
name|ThreadState
name|perThread
parameter_list|)
block|{
assert|assert
name|Thread
operator|.
name|holdsLock
argument_list|(
name|this
argument_list|)
assert|;
assert|assert
name|perThread
operator|.
name|flushPending
assert|;
try|try
block|{
comment|// We are pending so all memory is already moved to flushBytes
if|if
condition|(
name|perThread
operator|.
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
if|if
condition|(
name|perThread
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
assert|assert
name|perThread
operator|.
name|isHeldByCurrentThread
argument_list|()
assert|;
specifier|final
name|DocumentsWriterPerThread
name|dwpt
decl_stmt|;
specifier|final
name|long
name|bytes
init|=
name|perThread
operator|.
name|bytesUsed
decl_stmt|;
comment|// do that before
comment|// replace!
name|dwpt
operator|=
name|perThreadPool
operator|.
name|reset
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|flushingWriters
operator|.
name|containsKey
argument_list|(
name|dwpt
argument_list|)
operator|:
literal|"DWPT is already flushing"
assert|;
comment|// Record the flushing DWPT to reduce flushBytes in doAfterFlush
name|flushingWriters
operator|.
name|put
argument_list|(
name|dwpt
argument_list|,
name|Long
operator|.
name|valueOf
argument_list|(
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
name|numPending
operator|--
expr_stmt|;
comment|// write access synced
return|return
name|dwpt
return|;
block|}
block|}
finally|finally
block|{
name|perThread
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|updateStallState
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"DocumentsWriterFlushControl [activeBytes="
operator|+
name|activeBytes
operator|+
literal|", flushBytes="
operator|+
name|flushBytes
operator|+
literal|"]"
return|;
block|}
DECL|method|nextPendingFlush
name|DocumentsWriterPerThread
name|nextPendingFlush
parameter_list|()
block|{
name|int
name|numPending
decl_stmt|;
name|boolean
name|fullFlush
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
specifier|final
name|DocumentsWriterPerThread
name|poll
decl_stmt|;
if|if
condition|(
operator|(
name|poll
operator|=
name|flushQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|updateStallState
argument_list|()
expr_stmt|;
return|return
name|poll
return|;
block|}
name|fullFlush
operator|=
name|this
operator|.
name|fullFlush
expr_stmt|;
name|numPending
operator|=
name|this
operator|.
name|numPending
expr_stmt|;
block|}
if|if
condition|(
name|numPending
operator|>
literal|0
operator|&&
operator|!
name|fullFlush
condition|)
block|{
comment|// don't check if we are doing a full flush
specifier|final
name|int
name|limit
init|=
name|perThreadPool
operator|.
name|getActiveThreadStateCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
argument_list|<
name|limit
operator|&&
name|numPending
argument_list|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ThreadState
name|next
init|=
name|perThreadPool
operator|.
name|getThreadState
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|.
name|flushPending
condition|)
block|{
specifier|final
name|DocumentsWriterPerThread
name|dwpt
init|=
name|tryCheckoutForFlush
argument_list|(
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|dwpt
operator|!=
literal|null
condition|)
block|{
return|return
name|dwpt
return|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|setClosed
specifier|synchronized
name|void
name|setClosed
parameter_list|()
block|{
comment|// set by DW to signal that we should not release new DWPT after close
name|this
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Returns an iterator that provides access to all currently active {@link ThreadState}s     */
DECL|method|allActiveThreadStates
specifier|public
name|Iterator
argument_list|<
name|ThreadState
argument_list|>
name|allActiveThreadStates
parameter_list|()
block|{
return|return
name|getPerThreadsIterator
argument_list|(
name|perThreadPool
operator|.
name|getActiveThreadStateCount
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getPerThreadsIterator
specifier|private
name|Iterator
argument_list|<
name|ThreadState
argument_list|>
name|getPerThreadsIterator
parameter_list|(
specifier|final
name|int
name|upto
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|ThreadState
argument_list|>
argument_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|i
operator|<
name|upto
return|;
block|}
annotation|@
name|Override
specifier|public
name|ThreadState
name|next
parameter_list|()
block|{
return|return
name|perThreadPool
operator|.
name|getThreadState
argument_list|(
name|i
operator|++
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"remove() not supported."
argument_list|)
throw|;
block|}
block|}
return|;
block|}
DECL|method|doOnDelete
specifier|synchronized
name|void
name|doOnDelete
parameter_list|()
block|{
comment|// pass null this is a global delete no update
name|flushPolicy
operator|.
name|onDelete
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the number of delete terms in the global pool    */
DECL|method|getNumGlobalTermDeletes
specifier|public
name|int
name|getNumGlobalTermDeletes
parameter_list|()
block|{
return|return
name|documentsWriter
operator|.
name|deleteQueue
operator|.
name|numGlobalTermDeletes
argument_list|()
operator|+
name|bufferedUpdatesStream
operator|.
name|numTerms
argument_list|()
return|;
block|}
DECL|method|getDeleteBytesUsed
specifier|public
name|long
name|getDeleteBytesUsed
parameter_list|()
block|{
return|return
name|documentsWriter
operator|.
name|deleteQueue
operator|.
name|ramBytesUsed
argument_list|()
operator|+
name|bufferedUpdatesStream
operator|.
name|ramBytesUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
comment|// TODO: improve this to return more detailed info?
return|return
name|getDeleteBytesUsed
argument_list|()
operator|+
name|netBytes
argument_list|()
return|;
block|}
DECL|method|numFlushingDWPT
specifier|synchronized
name|int
name|numFlushingDWPT
parameter_list|()
block|{
return|return
name|flushingWriters
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getAndResetApplyAllDeletes
specifier|public
name|boolean
name|getAndResetApplyAllDeletes
parameter_list|()
block|{
return|return
name|flushDeletes
operator|.
name|getAndSet
argument_list|(
literal|false
argument_list|)
return|;
block|}
DECL|method|setApplyAllDeletes
specifier|public
name|void
name|setApplyAllDeletes
parameter_list|()
block|{
name|flushDeletes
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|numActiveDWPT
name|int
name|numActiveDWPT
parameter_list|()
block|{
return|return
name|this
operator|.
name|perThreadPool
operator|.
name|getActiveThreadStateCount
argument_list|()
return|;
block|}
DECL|method|obtainAndLock
name|ThreadState
name|obtainAndLock
parameter_list|()
block|{
specifier|final
name|ThreadState
name|perThread
init|=
name|perThreadPool
operator|.
name|getAndLock
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|,
name|documentsWriter
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|perThread
operator|.
name|isInitialized
argument_list|()
operator|&&
name|perThread
operator|.
name|dwpt
operator|.
name|deleteQueue
operator|!=
name|documentsWriter
operator|.
name|deleteQueue
condition|)
block|{
comment|// There is a flush-all in process and this DWPT is
comment|// now stale -- enroll it for flush and try for
comment|// another DWPT:
name|addFlushableState
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
comment|// simply return the ThreadState even in a flush all case sine we already hold the lock
return|return
name|perThread
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// make sure we unlock if this fails
name|perThreadPool
operator|.
name|release
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|markForFullFlush
name|long
name|markForFullFlush
parameter_list|()
block|{
specifier|final
name|DocumentsWriterDeleteQueue
name|flushingQueue
decl_stmt|;
name|long
name|seqNo
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
assert|assert
operator|!
name|fullFlush
operator|:
literal|"called DWFC#markForFullFlush() while full flush is still running"
assert|;
assert|assert
name|fullFlushBuffer
operator|.
name|isEmpty
argument_list|()
operator|:
literal|"full flush buffer should be empty: "
operator|+
name|fullFlushBuffer
assert|;
name|fullFlush
operator|=
literal|true
expr_stmt|;
name|flushingQueue
operator|=
name|documentsWriter
operator|.
name|deleteQueue
expr_stmt|;
comment|// Set a new delete queue - all subsequent DWPT will use this queue until
comment|// we do another full flush
comment|// Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine
comment|// if we have some sequence numbers that were never assigned:
name|seqNo
operator|=
name|documentsWriter
operator|.
name|deleteQueue
operator|.
name|getLastSequenceNumber
argument_list|()
operator|+
name|perThreadPool
operator|.
name|getActiveThreadStateCount
argument_list|()
operator|+
literal|2
expr_stmt|;
name|flushingQueue
operator|.
name|maxSeqNo
operator|=
name|seqNo
operator|+
literal|1
expr_stmt|;
name|DocumentsWriterDeleteQueue
name|newQueue
init|=
operator|new
name|DocumentsWriterDeleteQueue
argument_list|(
name|flushingQueue
operator|.
name|generation
operator|+
literal|1
argument_list|,
name|seqNo
operator|+
literal|1
argument_list|)
decl_stmt|;
name|documentsWriter
operator|.
name|deleteQueue
operator|=
name|newQueue
expr_stmt|;
block|}
specifier|final
name|int
name|limit
init|=
name|perThreadPool
operator|.
name|getActiveThreadStateCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ThreadState
name|next
init|=
name|perThreadPool
operator|.
name|getThreadState
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|next
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|next
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
continue|continue;
block|}
assert|assert
name|next
operator|.
name|dwpt
operator|.
name|deleteQueue
operator|==
name|flushingQueue
operator|||
name|next
operator|.
name|dwpt
operator|.
name|deleteQueue
operator|==
name|documentsWriter
operator|.
name|deleteQueue
operator|:
literal|" flushingQueue: "
operator|+
name|flushingQueue
operator|+
literal|" currentqueue: "
operator|+
name|documentsWriter
operator|.
name|deleteQueue
operator|+
literal|" perThread queue: "
operator|+
name|next
operator|.
name|dwpt
operator|.
name|deleteQueue
operator|+
literal|" numDocsInRam: "
operator|+
name|next
operator|.
name|dwpt
operator|.
name|getNumDocsInRAM
argument_list|()
assert|;
if|if
condition|(
name|next
operator|.
name|dwpt
operator|.
name|deleteQueue
operator|!=
name|flushingQueue
condition|)
block|{
comment|// this one is already a new DWPT
continue|continue;
block|}
name|addFlushableState
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|next
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|/* make sure we move all DWPT that are where concurrently marked as        * pending and moved to blocked are moved over to the flushQueue. There is        * a chance that this happens since we marking DWPT for full flush without        * blocking indexing.*/
name|pruneBlockedQueue
argument_list|(
name|flushingQueue
argument_list|)
expr_stmt|;
assert|assert
name|assertBlockedFlushes
argument_list|(
name|documentsWriter
operator|.
name|deleteQueue
argument_list|)
assert|;
name|flushQueue
operator|.
name|addAll
argument_list|(
name|fullFlushBuffer
argument_list|)
expr_stmt|;
name|fullFlushBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|updateStallState
argument_list|()
expr_stmt|;
block|}
assert|assert
name|assertActiveDeleteQueue
argument_list|(
name|documentsWriter
operator|.
name|deleteQueue
argument_list|)
assert|;
return|return
name|seqNo
return|;
block|}
DECL|method|assertActiveDeleteQueue
specifier|private
name|boolean
name|assertActiveDeleteQueue
parameter_list|(
name|DocumentsWriterDeleteQueue
name|queue
parameter_list|)
block|{
specifier|final
name|int
name|limit
init|=
name|perThreadPool
operator|.
name|getActiveThreadStateCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ThreadState
name|next
init|=
name|perThreadPool
operator|.
name|getThreadState
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|next
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
assert|assert
operator|!
name|next
operator|.
name|isInitialized
argument_list|()
operator|||
name|next
operator|.
name|dwpt
operator|.
name|deleteQueue
operator|==
name|queue
operator|:
literal|"isInitialized: "
operator|+
name|next
operator|.
name|isInitialized
argument_list|()
operator|+
literal|" numDocs: "
operator|+
operator|(
name|next
operator|.
name|isInitialized
argument_list|()
condition|?
name|next
operator|.
name|dwpt
operator|.
name|getNumDocsInRAM
argument_list|()
else|:
literal|0
operator|)
assert|;
block|}
finally|finally
block|{
name|next
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|field|fullFlushBuffer
specifier|private
specifier|final
name|List
argument_list|<
name|DocumentsWriterPerThread
argument_list|>
name|fullFlushBuffer
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|addFlushableState
name|void
name|addFlushableState
parameter_list|(
name|ThreadState
name|perThread
parameter_list|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DWFC"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DWFC"
argument_list|,
literal|"addFlushableState "
operator|+
name|perThread
operator|.
name|dwpt
argument_list|)
expr_stmt|;
block|}
specifier|final
name|DocumentsWriterPerThread
name|dwpt
init|=
name|perThread
operator|.
name|dwpt
decl_stmt|;
assert|assert
name|perThread
operator|.
name|isHeldByCurrentThread
argument_list|()
assert|;
assert|assert
name|perThread
operator|.
name|isInitialized
argument_list|()
assert|;
assert|assert
name|fullFlush
assert|;
assert|assert
name|dwpt
operator|.
name|deleteQueue
operator|!=
name|documentsWriter
operator|.
name|deleteQueue
assert|;
if|if
condition|(
name|dwpt
operator|.
name|getNumDocsInRAM
argument_list|()
operator|>
literal|0
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|perThread
operator|.
name|flushPending
condition|)
block|{
name|setFlushPending
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
block|}
specifier|final
name|DocumentsWriterPerThread
name|flushingDWPT
init|=
name|internalTryCheckOutForFlush
argument_list|(
name|perThread
argument_list|)
decl_stmt|;
assert|assert
name|flushingDWPT
operator|!=
literal|null
operator|:
literal|"DWPT must never be null here since we hold the lock and it holds documents"
assert|;
assert|assert
name|dwpt
operator|==
name|flushingDWPT
operator|:
literal|"flushControl returned different DWPT"
assert|;
name|fullFlushBuffer
operator|.
name|add
argument_list|(
name|flushingDWPT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|perThreadPool
operator|.
name|reset
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
comment|// make this state inactive
block|}
block|}
comment|/**    * Prunes the blockedQueue by removing all DWPT that are associated with the given flush queue.     */
DECL|method|pruneBlockedQueue
specifier|private
name|void
name|pruneBlockedQueue
parameter_list|(
specifier|final
name|DocumentsWriterDeleteQueue
name|flushingQueue
parameter_list|)
block|{
name|Iterator
argument_list|<
name|BlockedFlush
argument_list|>
name|iterator
init|=
name|blockedFlushes
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BlockedFlush
name|blockedFlush
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|blockedFlush
operator|.
name|dwpt
operator|.
name|deleteQueue
operator|==
name|flushingQueue
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
assert|assert
operator|!
name|flushingWriters
operator|.
name|containsKey
argument_list|(
name|blockedFlush
operator|.
name|dwpt
argument_list|)
operator|:
literal|"DWPT is already flushing"
assert|;
comment|// Record the flushing DWPT to reduce flushBytes in doAfterFlush
name|flushingWriters
operator|.
name|put
argument_list|(
name|blockedFlush
operator|.
name|dwpt
argument_list|,
name|Long
operator|.
name|valueOf
argument_list|(
name|blockedFlush
operator|.
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
comment|// don't decr pending here - it's already done when DWPT is blocked
name|flushQueue
operator|.
name|add
argument_list|(
name|blockedFlush
operator|.
name|dwpt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|finishFullFlush
specifier|synchronized
name|void
name|finishFullFlush
parameter_list|()
block|{
assert|assert
name|fullFlush
assert|;
assert|assert
name|flushQueue
operator|.
name|isEmpty
argument_list|()
assert|;
assert|assert
name|flushingWriters
operator|.
name|isEmpty
argument_list|()
assert|;
try|try
block|{
if|if
condition|(
operator|!
name|blockedFlushes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
assert|assert
name|assertBlockedFlushes
argument_list|(
name|documentsWriter
operator|.
name|deleteQueue
argument_list|)
assert|;
name|pruneBlockedQueue
argument_list|(
name|documentsWriter
operator|.
name|deleteQueue
argument_list|)
expr_stmt|;
assert|assert
name|blockedFlushes
operator|.
name|isEmpty
argument_list|()
assert|;
block|}
block|}
finally|finally
block|{
name|fullFlush
operator|=
literal|false
expr_stmt|;
name|updateStallState
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|assertBlockedFlushes
name|boolean
name|assertBlockedFlushes
parameter_list|(
name|DocumentsWriterDeleteQueue
name|flushingQueue
parameter_list|)
block|{
for|for
control|(
name|BlockedFlush
name|blockedFlush
range|:
name|blockedFlushes
control|)
block|{
assert|assert
name|blockedFlush
operator|.
name|dwpt
operator|.
name|deleteQueue
operator|==
name|flushingQueue
assert|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|abortFullFlushes
specifier|synchronized
name|void
name|abortFullFlushes
parameter_list|()
block|{
try|try
block|{
name|abortPendingFlushes
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|fullFlush
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|method|abortPendingFlushes
specifier|synchronized
name|void
name|abortPendingFlushes
parameter_list|()
block|{
try|try
block|{
for|for
control|(
name|DocumentsWriterPerThread
name|dwpt
range|:
name|flushQueue
control|)
block|{
try|try
block|{
name|documentsWriter
operator|.
name|subtractFlushedNumDocs
argument_list|(
name|dwpt
operator|.
name|getNumDocsInRAM
argument_list|()
argument_list|)
expr_stmt|;
name|dwpt
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
comment|// ignore - keep on aborting the flush queue
block|}
finally|finally
block|{
name|doAfterFlush
argument_list|(
name|dwpt
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|BlockedFlush
name|blockedFlush
range|:
name|blockedFlushes
control|)
block|{
try|try
block|{
name|flushingWriters
operator|.
name|put
argument_list|(
name|blockedFlush
operator|.
name|dwpt
argument_list|,
name|Long
operator|.
name|valueOf
argument_list|(
name|blockedFlush
operator|.
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
name|documentsWriter
operator|.
name|subtractFlushedNumDocs
argument_list|(
name|blockedFlush
operator|.
name|dwpt
operator|.
name|getNumDocsInRAM
argument_list|()
argument_list|)
expr_stmt|;
name|blockedFlush
operator|.
name|dwpt
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
comment|// ignore - keep on aborting the blocked queue
block|}
finally|finally
block|{
name|doAfterFlush
argument_list|(
name|blockedFlush
operator|.
name|dwpt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|flushQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|blockedFlushes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|updateStallState
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns<code>true</code> if a full flush is currently running    */
DECL|method|isFullFlush
specifier|synchronized
name|boolean
name|isFullFlush
parameter_list|()
block|{
return|return
name|fullFlush
return|;
block|}
comment|/**    * Returns the number of flushes that are already checked out but not yet    * actively flushing    */
DECL|method|numQueuedFlushes
specifier|synchronized
name|int
name|numQueuedFlushes
parameter_list|()
block|{
return|return
name|flushQueue
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Returns the number of flushes that are checked out but not yet available    * for flushing. This only applies during a full flush if a DWPT needs    * flushing but must not be flushed until the full flush has finished.    */
DECL|method|numBlockedFlushes
specifier|synchronized
name|int
name|numBlockedFlushes
parameter_list|()
block|{
return|return
name|blockedFlushes
operator|.
name|size
argument_list|()
return|;
block|}
DECL|class|BlockedFlush
specifier|private
specifier|static
class|class
name|BlockedFlush
block|{
DECL|field|dwpt
specifier|final
name|DocumentsWriterPerThread
name|dwpt
decl_stmt|;
DECL|field|bytes
specifier|final
name|long
name|bytes
decl_stmt|;
DECL|method|BlockedFlush
name|BlockedFlush
parameter_list|(
name|DocumentsWriterPerThread
name|dwpt
parameter_list|,
name|long
name|bytes
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|dwpt
operator|=
name|dwpt
expr_stmt|;
name|this
operator|.
name|bytes
operator|=
name|bytes
expr_stmt|;
block|}
block|}
comment|/**    * This method will block if too many DWPT are currently flushing and no    * checked out DWPT are available    */
DECL|method|waitIfStalled
name|void
name|waitIfStalled
parameter_list|()
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DWFC"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DWFC"
argument_list|,
literal|"waitIfStalled: numFlushesPending: "
operator|+
name|flushQueue
operator|.
name|size
argument_list|()
operator|+
literal|" netBytes: "
operator|+
name|netBytes
argument_list|()
operator|+
literal|" flushBytes: "
operator|+
name|flushBytes
argument_list|()
operator|+
literal|" fullFlush: "
operator|+
name|fullFlush
argument_list|)
expr_stmt|;
block|}
name|stallControl
operator|.
name|waitIfStalled
argument_list|()
expr_stmt|;
block|}
comment|/**    * Returns<code>true</code> iff stalled    */
DECL|method|anyStalledThreads
name|boolean
name|anyStalledThreads
parameter_list|()
block|{
return|return
name|stallControl
operator|.
name|anyStalledThreads
argument_list|()
return|;
block|}
comment|/**    * Returns the {@link IndexWriter} {@link InfoStream}    */
DECL|method|getInfoStream
specifier|public
name|InfoStream
name|getInfoStream
parameter_list|()
block|{
return|return
name|infoStream
return|;
block|}
block|}
end_class
end_unit
