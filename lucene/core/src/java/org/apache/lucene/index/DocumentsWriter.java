begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedQueue
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocumentsWriterFlushQueue
operator|.
name|SegmentFlushTicket
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocumentsWriterPerThread
operator|.
name|FlushedSegment
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocumentsWriterPerThreadPool
operator|.
name|ThreadState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
operator|.
name|Event
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|InfoStream
import|;
end_import
begin_comment
comment|/**  * This class accepts multiple added documents and directly  * writes segment files.  *  * Each added document is passed to the {@link DocConsumer},  * which in turn processes the document and interacts with  * other consumers in the indexing chain.  Certain  * consumers, like {@link StoredFieldsConsumer} and {@link  * TermVectorsConsumer}, digest a document and  * immediately write bytes to the "doc store" files (ie,  * they do not consume RAM per document, except while they  * are processing the document).  *  * Other consumers, eg {@link FreqProxTermsWriter} and  * {@link NormsConsumer}, buffer bytes in RAM and flush only  * when a new segment is produced.   * Once we have used our allowed RAM buffer, or the number  * of added docs is large enough (in the case we are  * flushing by doc count instead of RAM usage), we create a  * real segment and flush it to the Directory.  *  * Threads:  *  * Multiple threads are allowed into addDocument at once.  * There is an initial synchronized call to getThreadState  * which allocates a ThreadState for this thread.  The same  * thread will get the same ThreadState over time (thread  * affinity) so that if there are consistent patterns (for  * example each thread is indexing a different content  * source) then we make better use of RAM.  Then  * processDocument is called on that ThreadState without  * synchronization (most of the "heavy lifting" is in this  * call).  Finally the synchronized "finishDocument" is  * called to flush changes to the directory.  *  * When flush is called by IndexWriter we forcefully idle  * all threads and flush only once they are all idle.  This  * means you can call flush with a given thread even while  * other threads are actively adding/deleting documents.  *  *  * Exceptions:  *  * Because this class directly updates in-memory posting  * lists, and flushes stored fields and term vectors  * directly to files in the directory, there are certain  * limited times when an exception can corrupt this state.  * For example, a disk full while flushing stored fields  * leaves this file in a corrupt state.  Or, an OOM  * exception while appending to the in-memory posting lists  * can corrupt that posting list.  We call such exceptions  * "aborting exceptions".  In these cases we must call  * abort() to discard all docs added since the last flush.  *  * All other exceptions ("non-aborting exceptions") can  * still partially update the index structures.  These  * updates are consistent, but, they represent only a part  * of the document seen up until the exception was hit.  * When this happens, we immediately mark the document as  * deleted so that the document is always atomically ("all  * or none") added to the index.  */
end_comment
begin_class
DECL|class|DocumentsWriter
specifier|final
class|class
name|DocumentsWriter
block|{
DECL|field|directory
specifier|private
specifier|final
name|Directory
name|directory
decl_stmt|;
DECL|field|closed
specifier|private
specifier|volatile
name|boolean
name|closed
decl_stmt|;
DECL|field|infoStream
specifier|private
specifier|final
name|InfoStream
name|infoStream
decl_stmt|;
DECL|field|config
specifier|private
specifier|final
name|LiveIndexWriterConfig
name|config
decl_stmt|;
DECL|field|numDocsInRAM
specifier|private
specifier|final
name|AtomicInteger
name|numDocsInRAM
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// TODO: cut over to BytesRefHash in BufferedDeletes
DECL|field|deleteQueue
specifier|volatile
name|DocumentsWriterDeleteQueue
name|deleteQueue
init|=
operator|new
name|DocumentsWriterDeleteQueue
argument_list|()
decl_stmt|;
DECL|field|ticketQueue
specifier|private
specifier|final
name|DocumentsWriterFlushQueue
name|ticketQueue
init|=
operator|new
name|DocumentsWriterFlushQueue
argument_list|()
decl_stmt|;
comment|/*    * we preserve changes during a full flush since IW might not checkout before    * we release all changes. NRT Readers otherwise suddenly return true from    * isCurrent while there are actually changes currently committed. See also    * #anyChanges()& #flushAllThreads    */
DECL|field|pendingChangesInCurrentFullFlush
specifier|private
specifier|volatile
name|boolean
name|pendingChangesInCurrentFullFlush
decl_stmt|;
DECL|field|perThreadPool
specifier|final
name|DocumentsWriterPerThreadPool
name|perThreadPool
decl_stmt|;
DECL|field|flushPolicy
specifier|final
name|FlushPolicy
name|flushPolicy
decl_stmt|;
DECL|field|flushControl
specifier|final
name|DocumentsWriterFlushControl
name|flushControl
decl_stmt|;
DECL|field|writer
specifier|private
specifier|final
name|IndexWriter
name|writer
decl_stmt|;
DECL|field|events
specifier|private
specifier|final
name|Queue
argument_list|<
name|Event
argument_list|>
name|events
decl_stmt|;
DECL|method|DocumentsWriter
name|DocumentsWriter
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|LiveIndexWriterConfig
name|config
parameter_list|,
name|Directory
name|directory
parameter_list|)
block|{
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
name|this
operator|.
name|infoStream
operator|=
name|config
operator|.
name|getInfoStream
argument_list|()
expr_stmt|;
name|this
operator|.
name|perThreadPool
operator|=
name|config
operator|.
name|getIndexerThreadPool
argument_list|()
expr_stmt|;
name|flushPolicy
operator|=
name|config
operator|.
name|getFlushPolicy
argument_list|()
expr_stmt|;
name|this
operator|.
name|writer
operator|=
name|writer
expr_stmt|;
name|this
operator|.
name|events
operator|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<>
argument_list|()
expr_stmt|;
name|flushControl
operator|=
operator|new
name|DocumentsWriterFlushControl
argument_list|(
name|this
argument_list|,
name|config
argument_list|,
name|writer
operator|.
name|bufferedUpdatesStream
argument_list|)
expr_stmt|;
block|}
DECL|method|deleteQueries
specifier|synchronized
name|boolean
name|deleteQueries
parameter_list|(
specifier|final
name|Query
modifier|...
name|queries
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO why is this synchronized?
specifier|final
name|DocumentsWriterDeleteQueue
name|deleteQueue
init|=
name|this
operator|.
name|deleteQueue
decl_stmt|;
name|deleteQueue
operator|.
name|addDelete
argument_list|(
name|queries
argument_list|)
expr_stmt|;
name|flushControl
operator|.
name|doOnDelete
argument_list|()
expr_stmt|;
return|return
name|applyAllDeletes
argument_list|(
name|deleteQueue
argument_list|)
return|;
block|}
comment|// TODO: we could check w/ FreqProxTermsWriter: if the
comment|// term doesn't exist, don't bother buffering into the
comment|// per-DWPT map (but still must go into the global map)
DECL|method|deleteTerms
specifier|synchronized
name|boolean
name|deleteTerms
parameter_list|(
specifier|final
name|Term
modifier|...
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO why is this synchronized?
specifier|final
name|DocumentsWriterDeleteQueue
name|deleteQueue
init|=
name|this
operator|.
name|deleteQueue
decl_stmt|;
name|deleteQueue
operator|.
name|addDelete
argument_list|(
name|terms
argument_list|)
expr_stmt|;
name|flushControl
operator|.
name|doOnDelete
argument_list|()
expr_stmt|;
return|return
name|applyAllDeletes
argument_list|(
name|deleteQueue
argument_list|)
return|;
block|}
DECL|method|updateNumericDocValue
specifier|synchronized
name|boolean
name|updateNumericDocValue
parameter_list|(
name|Term
name|term
parameter_list|,
name|String
name|field
parameter_list|,
name|Long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DocumentsWriterDeleteQueue
name|deleteQueue
init|=
name|this
operator|.
name|deleteQueue
decl_stmt|;
name|deleteQueue
operator|.
name|addNumericUpdate
argument_list|(
operator|new
name|NumericUpdate
argument_list|(
name|term
argument_list|,
name|field
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|flushControl
operator|.
name|doOnDelete
argument_list|()
expr_stmt|;
return|return
name|applyAllDeletes
argument_list|(
name|deleteQueue
argument_list|)
return|;
block|}
DECL|method|currentDeleteSession
name|DocumentsWriterDeleteQueue
name|currentDeleteSession
parameter_list|()
block|{
return|return
name|deleteQueue
return|;
block|}
DECL|method|applyAllDeletes
specifier|private
specifier|final
name|boolean
name|applyAllDeletes
parameter_list|(
name|DocumentsWriterDeleteQueue
name|deleteQueue
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|flushControl
operator|.
name|getAndResetApplyAllDeletes
argument_list|()
condition|)
block|{
if|if
condition|(
name|deleteQueue
operator|!=
literal|null
operator|&&
operator|!
name|flushControl
operator|.
name|isFullFlush
argument_list|()
condition|)
block|{
name|ticketQueue
operator|.
name|addDeletes
argument_list|(
name|deleteQueue
argument_list|)
expr_stmt|;
block|}
name|putEvent
argument_list|(
name|ApplyDeletesEvent
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|// apply deletes event forces a purge
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|purgeBuffer
specifier|final
name|int
name|purgeBuffer
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|boolean
name|forced
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|forced
condition|)
block|{
return|return
name|ticketQueue
operator|.
name|forcePurge
argument_list|(
name|writer
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|ticketQueue
operator|.
name|tryPurge
argument_list|(
name|writer
argument_list|)
return|;
block|}
block|}
comment|/** Returns how many docs are currently buffered in RAM. */
DECL|method|getNumDocs
name|int
name|getNumDocs
parameter_list|()
block|{
return|return
name|numDocsInRAM
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|ensureOpen
specifier|private
name|void
name|ensureOpen
parameter_list|()
throws|throws
name|AlreadyClosedException
block|{
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|AlreadyClosedException
argument_list|(
literal|"this IndexWriter is closed"
argument_list|)
throw|;
block|}
block|}
comment|/** Called if we hit an exception at a bad time (when    *  updating the index files) and must discard all    *  currently buffered docs.  This resets our state,    *  discarding any docs added since last flush. */
DECL|method|abort
specifier|synchronized
name|void
name|abort
parameter_list|(
name|IndexWriter
name|writer
parameter_list|)
block|{
assert|assert
operator|!
name|Thread
operator|.
name|holdsLock
argument_list|(
name|writer
argument_list|)
operator|:
literal|"IndexWriter lock should never be hold when aborting"
assert|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|newFilesSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
name|deleteQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"abort"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|limit
init|=
name|perThreadPool
operator|.
name|getActiveThreadState
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ThreadState
name|perThread
init|=
name|perThreadPool
operator|.
name|getThreadState
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|perThread
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|abortThreadState
argument_list|(
name|perThread
argument_list|,
name|newFilesSet
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|perThread
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
name|flushControl
operator|.
name|abortPendingFlushes
argument_list|(
name|newFilesSet
argument_list|)
expr_stmt|;
name|putEvent
argument_list|(
operator|new
name|DeleteNewFilesEvent
argument_list|(
name|newFilesSet
argument_list|)
argument_list|)
expr_stmt|;
name|flushControl
operator|.
name|waitForFlush
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"done abort; abortedFiles="
operator|+
name|newFilesSet
operator|+
literal|" success="
operator|+
name|success
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|lockAndAbortAll
specifier|synchronized
name|void
name|lockAndAbortAll
parameter_list|(
name|IndexWriter
name|indexWriter
parameter_list|)
block|{
assert|assert
name|indexWriter
operator|.
name|holdsFullFlushLock
argument_list|()
assert|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"lockAndAbortAll"
argument_list|)
expr_stmt|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|deleteQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|final
name|int
name|limit
init|=
name|perThreadPool
operator|.
name|getMaxThreadStates
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|newFilesSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ThreadState
name|perThread
init|=
name|perThreadPool
operator|.
name|getThreadState
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|perThread
operator|.
name|lock
argument_list|()
expr_stmt|;
name|abortThreadState
argument_list|(
name|perThread
argument_list|,
name|newFilesSet
argument_list|)
expr_stmt|;
block|}
name|deleteQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|flushControl
operator|.
name|abortPendingFlushes
argument_list|(
name|newFilesSet
argument_list|)
expr_stmt|;
name|putEvent
argument_list|(
operator|new
name|DeleteNewFilesEvent
argument_list|(
name|newFilesSet
argument_list|)
argument_list|)
expr_stmt|;
name|flushControl
operator|.
name|waitForFlush
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"finished lockAndAbortAll success="
operator|+
name|success
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// if something happens here we unlock all states again
name|unlockAllAfterAbortAll
argument_list|(
name|indexWriter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|abortThreadState
specifier|private
specifier|final
name|void
name|abortThreadState
parameter_list|(
specifier|final
name|ThreadState
name|perThread
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|newFiles
parameter_list|)
block|{
assert|assert
name|perThread
operator|.
name|isHeldByCurrentThread
argument_list|()
assert|;
if|if
condition|(
name|perThread
operator|.
name|isActive
argument_list|()
condition|)
block|{
comment|// we might be closed
if|if
condition|(
name|perThread
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
try|try
block|{
name|subtractFlushedNumDocs
argument_list|(
name|perThread
operator|.
name|dwpt
operator|.
name|getNumDocsInRAM
argument_list|()
argument_list|)
expr_stmt|;
name|perThread
operator|.
name|dwpt
operator|.
name|abort
argument_list|(
name|newFiles
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|perThread
operator|.
name|dwpt
operator|.
name|checkAndResetHasAborted
argument_list|()
expr_stmt|;
name|flushControl
operator|.
name|doOnAbort
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|flushControl
operator|.
name|doOnAbort
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|closed
assert|;
block|}
block|}
DECL|method|unlockAllAfterAbortAll
specifier|final
specifier|synchronized
name|void
name|unlockAllAfterAbortAll
parameter_list|(
name|IndexWriter
name|indexWriter
parameter_list|)
block|{
assert|assert
name|indexWriter
operator|.
name|holdsFullFlushLock
argument_list|()
assert|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"unlockAll"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|limit
init|=
name|perThreadPool
operator|.
name|getMaxThreadStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
specifier|final
name|ThreadState
name|perThread
init|=
name|perThreadPool
operator|.
name|getThreadState
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|perThread
operator|.
name|isHeldByCurrentThread
argument_list|()
condition|)
block|{
name|perThread
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"unlockAll: could not unlock state: "
operator|+
name|i
operator|+
literal|" msg:"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// ignore& keep on unlocking
block|}
block|}
block|}
DECL|method|anyChanges
name|boolean
name|anyChanges
parameter_list|()
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"anyChanges? numDocsInRam="
operator|+
name|numDocsInRAM
operator|.
name|get
argument_list|()
operator|+
literal|" deletes="
operator|+
name|anyDeletions
argument_list|()
operator|+
literal|" hasTickets:"
operator|+
name|ticketQueue
operator|.
name|hasTickets
argument_list|()
operator|+
literal|" pendingChangesInFullFlush: "
operator|+
name|pendingChangesInCurrentFullFlush
argument_list|)
expr_stmt|;
block|}
comment|/*      * changes are either in a DWPT or in the deleteQueue.      * yet if we currently flush deletes and / or dwpt there      * could be a window where all changes are in the ticket queue      * before they are published to the IW. ie we need to check if the       * ticket queue has any tickets.      */
return|return
name|numDocsInRAM
operator|.
name|get
argument_list|()
operator|!=
literal|0
operator|||
name|anyDeletions
argument_list|()
operator|||
name|ticketQueue
operator|.
name|hasTickets
argument_list|()
operator|||
name|pendingChangesInCurrentFullFlush
return|;
block|}
DECL|method|getBufferedDeleteTermsSize
specifier|public
name|int
name|getBufferedDeleteTermsSize
parameter_list|()
block|{
return|return
name|deleteQueue
operator|.
name|getBufferedUpdatesTermsSize
argument_list|()
return|;
block|}
comment|//for testing
DECL|method|getNumBufferedDeleteTerms
specifier|public
name|int
name|getNumBufferedDeleteTerms
parameter_list|()
block|{
return|return
name|deleteQueue
operator|.
name|numGlobalTermDeletes
argument_list|()
return|;
block|}
DECL|method|anyDeletions
specifier|public
name|boolean
name|anyDeletions
parameter_list|()
block|{
return|return
name|deleteQueue
operator|.
name|anyChanges
argument_list|()
return|;
block|}
DECL|method|close
name|void
name|close
parameter_list|()
block|{
name|closed
operator|=
literal|true
expr_stmt|;
name|flushControl
operator|.
name|setClosed
argument_list|()
expr_stmt|;
block|}
DECL|method|preUpdate
specifier|private
name|boolean
name|preUpdate
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|boolean
name|hasEvents
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|flushControl
operator|.
name|anyStalledThreads
argument_list|()
operator|||
name|flushControl
operator|.
name|numQueuedFlushes
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Help out flushing any queued DWPTs so we can un-stall:
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)"
argument_list|)
expr_stmt|;
block|}
do|do
block|{
comment|// Try pick up pending threads here if possible
name|DocumentsWriterPerThread
name|flushingDWPT
decl_stmt|;
while|while
condition|(
operator|(
name|flushingDWPT
operator|=
name|flushControl
operator|.
name|nextPendingFlush
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// Don't push the delete here since the update could fail!
name|hasEvents
operator||=
name|doFlush
argument_list|(
name|flushingDWPT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
if|if
condition|(
name|flushControl
operator|.
name|anyStalledThreads
argument_list|()
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"WARNING DocumentsWriter has stalled threads; waiting"
argument_list|)
expr_stmt|;
block|}
block|}
name|flushControl
operator|.
name|waitIfStalled
argument_list|()
expr_stmt|;
comment|// block if stalled
block|}
do|while
condition|(
name|flushControl
operator|.
name|numQueuedFlushes
argument_list|()
operator|!=
literal|0
condition|)
do|;
comment|// still queued DWPTs try help flushing
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"continue indexing after helping out flushing DocumentsWriter is healthy"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|hasEvents
return|;
block|}
DECL|method|postUpdate
specifier|private
name|boolean
name|postUpdate
parameter_list|(
name|DocumentsWriterPerThread
name|flushingDWPT
parameter_list|,
name|boolean
name|hasEvents
parameter_list|)
throws|throws
name|IOException
block|{
name|hasEvents
operator||=
name|applyAllDeletes
argument_list|(
name|deleteQueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|flushingDWPT
operator|!=
literal|null
condition|)
block|{
name|hasEvents
operator||=
name|doFlush
argument_list|(
name|flushingDWPT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|DocumentsWriterPerThread
name|nextPendingFlush
init|=
name|flushControl
operator|.
name|nextPendingFlush
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextPendingFlush
operator|!=
literal|null
condition|)
block|{
name|hasEvents
operator||=
name|doFlush
argument_list|(
name|nextPendingFlush
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|hasEvents
return|;
block|}
DECL|method|ensureInitialized
specifier|private
specifier|final
name|void
name|ensureInitialized
parameter_list|(
name|ThreadState
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|.
name|isActive
argument_list|()
operator|&&
name|state
operator|.
name|dwpt
operator|==
literal|null
condition|)
block|{
specifier|final
name|FieldInfos
operator|.
name|Builder
name|infos
init|=
operator|new
name|FieldInfos
operator|.
name|Builder
argument_list|(
name|writer
operator|.
name|globalFieldNumberMap
argument_list|)
decl_stmt|;
name|state
operator|.
name|dwpt
operator|=
operator|new
name|DocumentsWriterPerThread
argument_list|(
name|writer
operator|.
name|newSegmentName
argument_list|()
argument_list|,
name|directory
argument_list|,
name|config
argument_list|,
name|infoStream
argument_list|,
name|deleteQueue
argument_list|,
name|infos
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateDocuments
name|boolean
name|updateDocuments
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|?
extends|extends
name|IndexDocument
argument_list|>
name|docs
parameter_list|,
specifier|final
name|Analyzer
name|analyzer
parameter_list|,
specifier|final
name|Term
name|delTerm
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|hasEvents
init|=
name|preUpdate
argument_list|()
decl_stmt|;
specifier|final
name|ThreadState
name|perThread
init|=
name|flushControl
operator|.
name|obtainAndLock
argument_list|()
decl_stmt|;
specifier|final
name|DocumentsWriterPerThread
name|flushingDWPT
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|perThread
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
assert|assert
literal|false
operator|:
literal|"perThread is not active but we are still open"
assert|;
block|}
name|ensureInitialized
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
assert|assert
name|perThread
operator|.
name|isInitialized
argument_list|()
assert|;
specifier|final
name|DocumentsWriterPerThread
name|dwpt
init|=
name|perThread
operator|.
name|dwpt
decl_stmt|;
specifier|final
name|int
name|dwptNumDocs
init|=
name|dwpt
operator|.
name|getNumDocsInRAM
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|int
name|docCount
init|=
name|dwpt
operator|.
name|updateDocuments
argument_list|(
name|docs
argument_list|,
name|analyzer
argument_list|,
name|delTerm
argument_list|)
decl_stmt|;
name|numDocsInRAM
operator|.
name|addAndGet
argument_list|(
name|docCount
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|dwpt
operator|.
name|checkAndResetHasAborted
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|dwpt
operator|.
name|pendingFilesToDelete
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|putEvent
argument_list|(
operator|new
name|DeleteNewFilesEvent
argument_list|(
name|dwpt
operator|.
name|pendingFilesToDelete
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|subtractFlushedNumDocs
argument_list|(
name|dwptNumDocs
argument_list|)
expr_stmt|;
name|flushControl
operator|.
name|doOnAbort
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|boolean
name|isUpdate
init|=
name|delTerm
operator|!=
literal|null
decl_stmt|;
name|flushingDWPT
operator|=
name|flushControl
operator|.
name|doAfterDocument
argument_list|(
name|perThread
argument_list|,
name|isUpdate
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|perThread
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|postUpdate
argument_list|(
name|flushingDWPT
argument_list|,
name|hasEvents
argument_list|)
return|;
block|}
DECL|method|updateDocument
name|boolean
name|updateDocument
parameter_list|(
specifier|final
name|IndexDocument
name|doc
parameter_list|,
specifier|final
name|Analyzer
name|analyzer
parameter_list|,
specifier|final
name|Term
name|delTerm
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|hasEvents
init|=
name|preUpdate
argument_list|()
decl_stmt|;
specifier|final
name|ThreadState
name|perThread
init|=
name|flushControl
operator|.
name|obtainAndLock
argument_list|()
decl_stmt|;
specifier|final
name|DocumentsWriterPerThread
name|flushingDWPT
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|perThread
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
assert|assert
literal|false
operator|:
literal|"perThread is not active but we are still open"
assert|;
block|}
name|ensureInitialized
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
assert|assert
name|perThread
operator|.
name|isInitialized
argument_list|()
assert|;
specifier|final
name|DocumentsWriterPerThread
name|dwpt
init|=
name|perThread
operator|.
name|dwpt
decl_stmt|;
specifier|final
name|int
name|dwptNumDocs
init|=
name|dwpt
operator|.
name|getNumDocsInRAM
argument_list|()
decl_stmt|;
try|try
block|{
name|dwpt
operator|.
name|updateDocument
argument_list|(
name|doc
argument_list|,
name|analyzer
argument_list|,
name|delTerm
argument_list|)
expr_stmt|;
name|numDocsInRAM
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|dwpt
operator|.
name|checkAndResetHasAborted
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|dwpt
operator|.
name|pendingFilesToDelete
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|putEvent
argument_list|(
operator|new
name|DeleteNewFilesEvent
argument_list|(
name|dwpt
operator|.
name|pendingFilesToDelete
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|subtractFlushedNumDocs
argument_list|(
name|dwptNumDocs
argument_list|)
expr_stmt|;
name|flushControl
operator|.
name|doOnAbort
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|boolean
name|isUpdate
init|=
name|delTerm
operator|!=
literal|null
decl_stmt|;
name|flushingDWPT
operator|=
name|flushControl
operator|.
name|doAfterDocument
argument_list|(
name|perThread
argument_list|,
name|isUpdate
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|perThread
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|postUpdate
argument_list|(
name|flushingDWPT
argument_list|,
name|hasEvents
argument_list|)
return|;
block|}
DECL|method|doFlush
specifier|private
name|boolean
name|doFlush
parameter_list|(
name|DocumentsWriterPerThread
name|flushingDWPT
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|hasEvents
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|flushingDWPT
operator|!=
literal|null
condition|)
block|{
name|hasEvents
operator|=
literal|true
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|SegmentFlushTicket
name|ticket
init|=
literal|null
decl_stmt|;
try|try
block|{
assert|assert
name|currentFullFlushDelQueue
operator|==
literal|null
operator|||
name|flushingDWPT
operator|.
name|deleteQueue
operator|==
name|currentFullFlushDelQueue
operator|:
literal|"expected: "
operator|+
name|currentFullFlushDelQueue
operator|+
literal|"but was: "
operator|+
name|flushingDWPT
operator|.
name|deleteQueue
operator|+
literal|" "
operator|+
name|flushControl
operator|.
name|isFullFlush
argument_list|()
assert|;
comment|/*          * Since with DWPT the flush process is concurrent and several DWPT          * could flush at the same time we must maintain the order of the          * flushes before we can apply the flushed segment and the frozen global          * deletes it is buffering. The reason for this is that the global          * deletes mark a certain point in time where we took a DWPT out of          * rotation and freeze the global deletes.          *           * Example: A flush 'A' starts and freezes the global deletes, then          * flush 'B' starts and freezes all deletes occurred since 'A' has          * started. if 'B' finishes before 'A' we need to wait until 'A' is done          * otherwise the deletes frozen by 'B' are not applied to 'A' and we          * might miss to deletes documents in 'A'.          */
try|try
block|{
comment|// Each flush is assigned a ticket in the order they acquire the ticketQueue lock
name|ticket
operator|=
name|ticketQueue
operator|.
name|addFlushTicket
argument_list|(
name|flushingDWPT
argument_list|)
expr_stmt|;
specifier|final
name|int
name|flushingDocsInRam
init|=
name|flushingDWPT
operator|.
name|getNumDocsInRAM
argument_list|()
decl_stmt|;
name|boolean
name|dwptSuccess
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// flush concurrently without locking
specifier|final
name|FlushedSegment
name|newSegment
init|=
name|flushingDWPT
operator|.
name|flush
argument_list|()
decl_stmt|;
name|ticketQueue
operator|.
name|addSegment
argument_list|(
name|ticket
argument_list|,
name|newSegment
argument_list|)
expr_stmt|;
name|dwptSuccess
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|subtractFlushedNumDocs
argument_list|(
name|flushingDocsInRam
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flushingDWPT
operator|.
name|pendingFilesToDelete
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|putEvent
argument_list|(
operator|new
name|DeleteNewFilesEvent
argument_list|(
name|flushingDWPT
operator|.
name|pendingFilesToDelete
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|hasEvents
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dwptSuccess
condition|)
block|{
name|putEvent
argument_list|(
operator|new
name|FlushFailedEvent
argument_list|(
name|flushingDWPT
operator|.
name|getSegmentInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|hasEvents
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// flush was successful once we reached this point - new seg. has been assigned to the ticket!
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
operator|&&
name|ticket
operator|!=
literal|null
condition|)
block|{
comment|// In the case of a failure make sure we are making progress and
comment|// apply all the deletes since the segment flush failed since the flush
comment|// ticket could hold global deletes see FlushTicket#canPublish()
name|ticketQueue
operator|.
name|markTicketFailed
argument_list|(
name|ticket
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*          * Now we are done and try to flush the ticket queue if the head of the          * queue has already finished the flush.          */
if|if
condition|(
name|ticketQueue
operator|.
name|getTicketCount
argument_list|()
operator|>=
name|perThreadPool
operator|.
name|getActiveThreadState
argument_list|()
condition|)
block|{
comment|// This means there is a backlog: the one
comment|// thread in innerPurge can't keep up with all
comment|// other threads flushing segments.  In this case
comment|// we forcefully stall the producers.
name|putEvent
argument_list|(
name|ForcedPurgeEvent
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
finally|finally
block|{
name|flushControl
operator|.
name|doAfterFlush
argument_list|(
name|flushingDWPT
argument_list|)
expr_stmt|;
name|flushingDWPT
operator|.
name|checkAndResetHasAborted
argument_list|()
expr_stmt|;
block|}
name|flushingDWPT
operator|=
name|flushControl
operator|.
name|nextPendingFlush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|hasEvents
condition|)
block|{
name|putEvent
argument_list|(
name|MergePendingEvent
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
comment|// If deletes alone are consuming> 1/2 our RAM
comment|// buffer, force them all to apply now. This is to
comment|// prevent too-frequent flushing of a long tail of
comment|// tiny segments:
specifier|final
name|double
name|ramBufferSizeMB
init|=
name|config
operator|.
name|getRAMBufferSizeMB
argument_list|()
decl_stmt|;
if|if
condition|(
name|ramBufferSizeMB
operator|!=
name|IndexWriterConfig
operator|.
name|DISABLE_AUTO_FLUSH
operator|&&
name|flushControl
operator|.
name|getDeleteBytesUsed
argument_list|()
operator|>
operator|(
literal|1024
operator|*
literal|1024
operator|*
name|ramBufferSizeMB
operator|/
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"force apply deletes bytesUsed="
operator|+
name|flushControl
operator|.
name|getDeleteBytesUsed
argument_list|()
operator|+
literal|" vs ramBuffer="
operator|+
operator|(
literal|1024
operator|*
literal|1024
operator|*
name|ramBufferSizeMB
operator|)
argument_list|)
expr_stmt|;
block|}
name|hasEvents
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|applyAllDeletes
argument_list|(
name|deleteQueue
argument_list|)
condition|)
block|{
name|putEvent
argument_list|(
name|ApplyDeletesEvent
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|hasEvents
return|;
block|}
DECL|method|subtractFlushedNumDocs
specifier|final
name|void
name|subtractFlushedNumDocs
parameter_list|(
name|int
name|numFlushed
parameter_list|)
block|{
name|int
name|oldValue
init|=
name|numDocsInRAM
operator|.
name|get
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|numDocsInRAM
operator|.
name|compareAndSet
argument_list|(
name|oldValue
argument_list|,
name|oldValue
operator|-
name|numFlushed
argument_list|)
condition|)
block|{
name|oldValue
operator|=
name|numDocsInRAM
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
block|}
comment|// for asserts
DECL|field|currentFullFlushDelQueue
specifier|private
specifier|volatile
name|DocumentsWriterDeleteQueue
name|currentFullFlushDelQueue
init|=
literal|null
decl_stmt|;
comment|// for asserts
DECL|method|setFlushingDeleteQueue
specifier|private
specifier|synchronized
name|boolean
name|setFlushingDeleteQueue
parameter_list|(
name|DocumentsWriterDeleteQueue
name|session
parameter_list|)
block|{
name|currentFullFlushDelQueue
operator|=
name|session
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/*    * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a    * two stage operation; the caller must ensure (in try/finally) that finishFlush    * is called after this method, to release the flush lock in DWFlushControl    */
DECL|method|flushAllThreads
specifier|final
name|boolean
name|flushAllThreads
parameter_list|(
specifier|final
name|IndexWriter
name|indexWriter
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DocumentsWriterDeleteQueue
name|flushingDeleteQueue
decl_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" startFullFlush"
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
name|pendingChangesInCurrentFullFlush
operator|=
name|anyChanges
argument_list|()
expr_stmt|;
name|flushingDeleteQueue
operator|=
name|deleteQueue
expr_stmt|;
comment|/* Cutover to a new delete queue.  This must be synced on the flush control        * otherwise a new DWPT could sneak into the loop with an already flushing        * delete queue */
name|flushControl
operator|.
name|markForFullFlush
argument_list|()
expr_stmt|;
comment|// swaps the delQueue synced on FlushControl
assert|assert
name|setFlushingDeleteQueue
argument_list|(
name|flushingDeleteQueue
argument_list|)
assert|;
block|}
assert|assert
name|currentFullFlushDelQueue
operator|!=
literal|null
assert|;
assert|assert
name|currentFullFlushDelQueue
operator|!=
name|deleteQueue
assert|;
name|boolean
name|anythingFlushed
init|=
literal|false
decl_stmt|;
try|try
block|{
name|DocumentsWriterPerThread
name|flushingDWPT
decl_stmt|;
comment|// Help out with flushing:
while|while
condition|(
operator|(
name|flushingDWPT
operator|=
name|flushControl
operator|.
name|nextPendingFlush
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|anythingFlushed
operator||=
name|doFlush
argument_list|(
name|flushingDWPT
argument_list|)
expr_stmt|;
block|}
comment|// If a concurrent flush is still in flight wait for it
name|flushControl
operator|.
name|waitForFlush
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|anythingFlushed
operator|&&
name|flushingDeleteQueue
operator|.
name|anyChanges
argument_list|()
condition|)
block|{
comment|// apply deletes if we did not flush any document
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": flush naked frozen global deletes"
argument_list|)
expr_stmt|;
block|}
name|ticketQueue
operator|.
name|addDeletes
argument_list|(
name|flushingDeleteQueue
argument_list|)
expr_stmt|;
block|}
name|ticketQueue
operator|.
name|forcePurge
argument_list|(
name|indexWriter
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|flushingDeleteQueue
operator|.
name|anyChanges
argument_list|()
operator|&&
operator|!
name|ticketQueue
operator|.
name|hasTickets
argument_list|()
assert|;
block|}
finally|finally
block|{
assert|assert
name|flushingDeleteQueue
operator|==
name|currentFullFlushDelQueue
assert|;
block|}
return|return
name|anythingFlushed
return|;
block|}
DECL|method|finishFullFlush
specifier|final
name|void
name|finishFullFlush
parameter_list|(
name|boolean
name|success
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" finishFullFlush success="
operator|+
name|success
argument_list|)
expr_stmt|;
block|}
assert|assert
name|setFlushingDeleteQueue
argument_list|(
literal|null
argument_list|)
assert|;
if|if
condition|(
name|success
condition|)
block|{
comment|// Release the flush lock
name|flushControl
operator|.
name|finishFullFlush
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|newFilesSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|flushControl
operator|.
name|abortFullFlushes
argument_list|(
name|newFilesSet
argument_list|)
expr_stmt|;
name|putEvent
argument_list|(
operator|new
name|DeleteNewFilesEvent
argument_list|(
name|newFilesSet
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|pendingChangesInCurrentFullFlush
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|method|getIndexWriterConfig
specifier|public
name|LiveIndexWriterConfig
name|getIndexWriterConfig
parameter_list|()
block|{
return|return
name|config
return|;
block|}
DECL|method|putEvent
specifier|private
name|void
name|putEvent
parameter_list|(
name|Event
name|event
parameter_list|)
block|{
name|events
operator|.
name|add
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
DECL|class|ApplyDeletesEvent
specifier|static
specifier|final
class|class
name|ApplyDeletesEvent
implements|implements
name|Event
block|{
DECL|field|INSTANCE
specifier|static
specifier|final
name|Event
name|INSTANCE
init|=
operator|new
name|ApplyDeletesEvent
argument_list|()
decl_stmt|;
DECL|field|instCount
specifier|private
name|int
name|instCount
init|=
literal|0
decl_stmt|;
DECL|method|ApplyDeletesEvent
specifier|private
name|ApplyDeletesEvent
parameter_list|()
block|{
assert|assert
name|instCount
operator|==
literal|0
assert|;
name|instCount
operator|++
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|process
specifier|public
name|void
name|process
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|boolean
name|triggerMerge
parameter_list|,
name|boolean
name|forcePurge
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|applyDeletesAndPurge
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// we always purge!
block|}
block|}
DECL|class|MergePendingEvent
specifier|static
specifier|final
class|class
name|MergePendingEvent
implements|implements
name|Event
block|{
DECL|field|INSTANCE
specifier|static
specifier|final
name|Event
name|INSTANCE
init|=
operator|new
name|MergePendingEvent
argument_list|()
decl_stmt|;
DECL|field|instCount
specifier|private
name|int
name|instCount
init|=
literal|0
decl_stmt|;
DECL|method|MergePendingEvent
specifier|private
name|MergePendingEvent
parameter_list|()
block|{
assert|assert
name|instCount
operator|==
literal|0
assert|;
name|instCount
operator|++
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|process
specifier|public
name|void
name|process
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|boolean
name|triggerMerge
parameter_list|,
name|boolean
name|forcePurge
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|doAfterSegmentFlushed
argument_list|(
name|triggerMerge
argument_list|,
name|forcePurge
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|ForcedPurgeEvent
specifier|static
specifier|final
class|class
name|ForcedPurgeEvent
implements|implements
name|Event
block|{
DECL|field|INSTANCE
specifier|static
specifier|final
name|Event
name|INSTANCE
init|=
operator|new
name|ForcedPurgeEvent
argument_list|()
decl_stmt|;
DECL|field|instCount
specifier|private
name|int
name|instCount
init|=
literal|0
decl_stmt|;
DECL|method|ForcedPurgeEvent
specifier|private
name|ForcedPurgeEvent
parameter_list|()
block|{
assert|assert
name|instCount
operator|==
literal|0
assert|;
name|instCount
operator|++
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|process
specifier|public
name|void
name|process
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|boolean
name|triggerMerge
parameter_list|,
name|boolean
name|forcePurge
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|purge
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|FlushFailedEvent
specifier|static
class|class
name|FlushFailedEvent
implements|implements
name|Event
block|{
DECL|field|info
specifier|private
specifier|final
name|SegmentInfo
name|info
decl_stmt|;
DECL|method|FlushFailedEvent
specifier|public
name|FlushFailedEvent
parameter_list|(
name|SegmentInfo
name|info
parameter_list|)
block|{
name|this
operator|.
name|info
operator|=
name|info
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|process
specifier|public
name|void
name|process
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|boolean
name|triggerMerge
parameter_list|,
name|boolean
name|forcePurge
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|flushFailed
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|DeleteNewFilesEvent
specifier|static
class|class
name|DeleteNewFilesEvent
implements|implements
name|Event
block|{
DECL|field|files
specifier|private
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|files
decl_stmt|;
DECL|method|DeleteNewFilesEvent
specifier|public
name|DeleteNewFilesEvent
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
block|{
name|this
operator|.
name|files
operator|=
name|files
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|process
specifier|public
name|void
name|process
parameter_list|(
name|IndexWriter
name|writer
parameter_list|,
name|boolean
name|triggerMerge
parameter_list|,
name|boolean
name|forcePurge
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|deleteNewFiles
argument_list|(
name|files
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|eventQueue
specifier|public
name|Queue
argument_list|<
name|Event
argument_list|>
name|eventQueue
parameter_list|()
block|{
return|return
name|events
return|;
block|}
block|}
end_class
end_unit
