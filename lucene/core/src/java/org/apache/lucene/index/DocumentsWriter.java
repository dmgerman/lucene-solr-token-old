begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocumentsWriterFlushQueue
operator|.
name|SegmentFlushTicket
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocumentsWriterPerThread
operator|.
name|FlushedSegment
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocumentsWriterPerThread
operator|.
name|IndexingChain
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocumentsWriterPerThreadPool
operator|.
name|ThreadState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
operator|.
name|FieldNumbers
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|similarities
operator|.
name|Similarity
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FlushInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|InfoStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|MutableBits
import|;
end_import
begin_comment
comment|/**  * This class accepts multiple added documents and directly  * writes segment files.  *  * Each added document is passed to the {@link DocConsumer},  * which in turn processes the document and interacts with  * other consumers in the indexing chain.  Certain  * consumers, like {@link StoredFieldsConsumer} and {@link  * TermVectorsConsumer}, digest a document and  * immediately write bytes to the "doc store" files (ie,  * they do not consume RAM per document, except while they  * are processing the document).  *  * Other consumers, eg {@link FreqProxTermsWriter} and  * {@link NormsConsumer}, buffer bytes in RAM and flush only  * when a new segment is produced.   * Once we have used our allowed RAM buffer, or the number  * of added docs is large enough (in the case we are  * flushing by doc count instead of RAM usage), we create a  * real segment and flush it to the Directory.  *  * Threads:  *  * Multiple threads are allowed into addDocument at once.  * There is an initial synchronized call to getThreadState  * which allocates a ThreadState for this thread.  The same  * thread will get the same ThreadState over time (thread  * affinity) so that if there are consistent patterns (for  * example each thread is indexing a different content  * source) then we make better use of RAM.  Then  * processDocument is called on that ThreadState without  * synchronization (most of the "heavy lifting" is in this  * call).  Finally the synchronized "finishDocument" is  * called to flush changes to the directory.  *  * When flush is called by IndexWriter we forcefully idle  * all threads and flush only once they are all idle.  This  * means you can call flush with a given thread even while  * other threads are actively adding/deleting documents.  *  *  * Exceptions:  *  * Because this class directly updates in-memory posting  * lists, and flushes stored fields and term vectors  * directly to files in the directory, there are certain  * limited times when an exception can corrupt this state.  * For example, a disk full while flushing stored fields  * leaves this file in a corrupt state.  Or, an OOM  * exception while appending to the in-memory posting lists  * can corrupt that posting list.  We call such exceptions  * "aborting exceptions".  In these cases we must call  * abort() to discard all docs added since the last flush.  *  * All other exceptions ("non-aborting exceptions") can  * still partially update the index structures.  These  * updates are consistent, but, they represent only a part  * of the document seen up until the exception was hit.  * When this happens, we immediately mark the document as  * deleted so that the document is always atomically ("all  * or none") added to the index.  */
end_comment
begin_class
DECL|class|DocumentsWriter
specifier|final
class|class
name|DocumentsWriter
block|{
DECL|field|directory
name|Directory
name|directory
decl_stmt|;
DECL|field|closed
specifier|private
specifier|volatile
name|boolean
name|closed
decl_stmt|;
DECL|field|infoStream
specifier|final
name|InfoStream
name|infoStream
decl_stmt|;
DECL|field|similarity
name|Similarity
name|similarity
decl_stmt|;
DECL|field|newFiles
name|List
argument_list|<
name|String
argument_list|>
name|newFiles
decl_stmt|;
DECL|field|indexWriter
specifier|final
name|IndexWriter
name|indexWriter
decl_stmt|;
DECL|field|numDocsInRAM
specifier|private
name|AtomicInteger
name|numDocsInRAM
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// TODO: cut over to BytesRefHash in BufferedDeletes
DECL|field|deleteQueue
specifier|volatile
name|DocumentsWriterDeleteQueue
name|deleteQueue
init|=
operator|new
name|DocumentsWriterDeleteQueue
argument_list|()
decl_stmt|;
DECL|field|ticketQueue
specifier|private
specifier|final
name|DocumentsWriterFlushQueue
name|ticketQueue
init|=
operator|new
name|DocumentsWriterFlushQueue
argument_list|()
decl_stmt|;
comment|/*    * we preserve changes during a full flush since IW might not checkout before    * we release all changes. NRT Readers otherwise suddenly return true from    * isCurrent while there are actually changes currently committed. See also    * #anyChanges()& #flushAllThreads    */
DECL|field|pendingChangesInCurrentFullFlush
specifier|private
specifier|volatile
name|boolean
name|pendingChangesInCurrentFullFlush
decl_stmt|;
DECL|field|abortedFiles
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|abortedFiles
decl_stmt|;
comment|// List of files that were written before last abort()
DECL|field|chain
specifier|final
name|IndexingChain
name|chain
decl_stmt|;
DECL|field|perThreadPool
specifier|final
name|DocumentsWriterPerThreadPool
name|perThreadPool
decl_stmt|;
DECL|field|flushPolicy
specifier|final
name|FlushPolicy
name|flushPolicy
decl_stmt|;
DECL|field|flushControl
specifier|final
name|DocumentsWriterFlushControl
name|flushControl
decl_stmt|;
DECL|field|codec
specifier|final
name|Codec
name|codec
decl_stmt|;
DECL|method|DocumentsWriter
name|DocumentsWriter
parameter_list|(
name|Codec
name|codec
parameter_list|,
name|LiveIndexWriterConfig
name|config
parameter_list|,
name|Directory
name|directory
parameter_list|,
name|IndexWriter
name|writer
parameter_list|,
name|FieldNumbers
name|globalFieldNumbers
parameter_list|,
name|BufferedDeletesStream
name|bufferedDeletesStream
parameter_list|)
block|{
name|this
operator|.
name|codec
operator|=
name|codec
expr_stmt|;
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
name|this
operator|.
name|indexWriter
operator|=
name|writer
expr_stmt|;
name|this
operator|.
name|infoStream
operator|=
name|config
operator|.
name|getInfoStream
argument_list|()
expr_stmt|;
name|this
operator|.
name|similarity
operator|=
name|config
operator|.
name|getSimilarity
argument_list|()
expr_stmt|;
name|this
operator|.
name|perThreadPool
operator|=
name|config
operator|.
name|getIndexerThreadPool
argument_list|()
expr_stmt|;
name|this
operator|.
name|chain
operator|=
name|config
operator|.
name|getIndexingChain
argument_list|()
expr_stmt|;
name|this
operator|.
name|perThreadPool
operator|.
name|initialize
argument_list|(
name|this
argument_list|,
name|globalFieldNumbers
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|flushPolicy
operator|=
name|config
operator|.
name|getFlushPolicy
argument_list|()
expr_stmt|;
assert|assert
name|flushPolicy
operator|!=
literal|null
assert|;
name|flushPolicy
operator|.
name|init
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|flushControl
operator|=
operator|new
name|DocumentsWriterFlushControl
argument_list|(
name|this
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
DECL|method|deleteQueries
specifier|synchronized
name|void
name|deleteQueries
parameter_list|(
specifier|final
name|Query
modifier|...
name|queries
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteQueue
operator|.
name|addDelete
argument_list|(
name|queries
argument_list|)
expr_stmt|;
name|flushControl
operator|.
name|doOnDelete
argument_list|()
expr_stmt|;
if|if
condition|(
name|flushControl
operator|.
name|doApplyAllDeletes
argument_list|()
condition|)
block|{
name|applyAllDeletes
argument_list|(
name|deleteQueue
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: we could check w/ FreqProxTermsWriter: if the
comment|// term doesn't exist, don't bother buffering into the
comment|// per-DWPT map (but still must go into the global map)
DECL|method|deleteTerms
specifier|synchronized
name|void
name|deleteTerms
parameter_list|(
specifier|final
name|Term
modifier|...
name|terms
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DocumentsWriterDeleteQueue
name|deleteQueue
init|=
name|this
operator|.
name|deleteQueue
decl_stmt|;
name|deleteQueue
operator|.
name|addDelete
argument_list|(
name|terms
argument_list|)
expr_stmt|;
name|flushControl
operator|.
name|doOnDelete
argument_list|()
expr_stmt|;
if|if
condition|(
name|flushControl
operator|.
name|doApplyAllDeletes
argument_list|()
condition|)
block|{
name|applyAllDeletes
argument_list|(
name|deleteQueue
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|currentDeleteSession
name|DocumentsWriterDeleteQueue
name|currentDeleteSession
parameter_list|()
block|{
return|return
name|deleteQueue
return|;
block|}
DECL|method|applyAllDeletes
specifier|private
name|void
name|applyAllDeletes
parameter_list|(
name|DocumentsWriterDeleteQueue
name|deleteQueue
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|deleteQueue
operator|!=
literal|null
operator|&&
operator|!
name|flushControl
operator|.
name|isFullFlush
argument_list|()
condition|)
block|{
name|ticketQueue
operator|.
name|addDeletesAndPurge
argument_list|(
name|this
argument_list|,
name|deleteQueue
argument_list|)
expr_stmt|;
block|}
name|indexWriter
operator|.
name|applyAllDeletes
argument_list|()
expr_stmt|;
name|indexWriter
operator|.
name|flushCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/** Returns how many docs are currently buffered in RAM. */
DECL|method|getNumDocs
name|int
name|getNumDocs
parameter_list|()
block|{
return|return
name|numDocsInRAM
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|abortedFiles
name|Collection
argument_list|<
name|String
argument_list|>
name|abortedFiles
parameter_list|()
block|{
return|return
name|abortedFiles
return|;
block|}
DECL|method|ensureOpen
specifier|private
name|void
name|ensureOpen
parameter_list|()
throws|throws
name|AlreadyClosedException
block|{
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|AlreadyClosedException
argument_list|(
literal|"this IndexWriter is closed"
argument_list|)
throw|;
block|}
block|}
comment|/** Called if we hit an exception at a bad time (when    *  updating the index files) and must discard all    *  currently buffered docs.  This resets our state,    *  discarding any docs added since last flush. */
DECL|method|abort
specifier|synchronized
name|void
name|abort
parameter_list|()
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|deleteQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"abort"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|limit
init|=
name|perThreadPool
operator|.
name|getActiveThreadState
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ThreadState
name|perThread
init|=
name|perThreadPool
operator|.
name|getThreadState
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|perThread
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|perThread
operator|.
name|isActive
argument_list|()
condition|)
block|{
comment|// we might be closed
try|try
block|{
name|perThread
operator|.
name|dwpt
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|perThread
operator|.
name|dwpt
operator|.
name|checkAndResetHasAborted
argument_list|()
expr_stmt|;
name|flushControl
operator|.
name|doOnAbort
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|closed
assert|;
block|}
block|}
finally|finally
block|{
name|perThread
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
name|flushControl
operator|.
name|abortPendingFlushes
argument_list|()
expr_stmt|;
name|flushControl
operator|.
name|waitForFlush
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"done abort; abortedFiles="
operator|+
name|abortedFiles
operator|+
literal|" success="
operator|+
name|success
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|anyChanges
name|boolean
name|anyChanges
parameter_list|()
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"anyChanges? numDocsInRam="
operator|+
name|numDocsInRAM
operator|.
name|get
argument_list|()
operator|+
literal|" deletes="
operator|+
name|anyDeletions
argument_list|()
operator|+
literal|" hasTickets:"
operator|+
name|ticketQueue
operator|.
name|hasTickets
argument_list|()
operator|+
literal|" pendingChangesInFullFlush: "
operator|+
name|pendingChangesInCurrentFullFlush
argument_list|)
expr_stmt|;
block|}
comment|/*      * changes are either in a DWPT or in the deleteQueue.      * yet if we currently flush deletes and / or dwpt there      * could be a window where all changes are in the ticket queue      * before they are published to the IW. ie we need to check if the       * ticket queue has any tickets.      */
return|return
name|numDocsInRAM
operator|.
name|get
argument_list|()
operator|!=
literal|0
operator|||
name|anyDeletions
argument_list|()
operator|||
name|ticketQueue
operator|.
name|hasTickets
argument_list|()
operator|||
name|pendingChangesInCurrentFullFlush
return|;
block|}
DECL|method|getBufferedDeleteTermsSize
specifier|public
name|int
name|getBufferedDeleteTermsSize
parameter_list|()
block|{
return|return
name|deleteQueue
operator|.
name|getBufferedDeleteTermsSize
argument_list|()
return|;
block|}
comment|//for testing
DECL|method|getNumBufferedDeleteTerms
specifier|public
name|int
name|getNumBufferedDeleteTerms
parameter_list|()
block|{
return|return
name|deleteQueue
operator|.
name|numGlobalTermDeletes
argument_list|()
return|;
block|}
DECL|method|anyDeletions
specifier|public
name|boolean
name|anyDeletions
parameter_list|()
block|{
return|return
name|deleteQueue
operator|.
name|anyChanges
argument_list|()
return|;
block|}
DECL|method|close
name|void
name|close
parameter_list|()
block|{
name|closed
operator|=
literal|true
expr_stmt|;
name|flushControl
operator|.
name|setClosed
argument_list|()
expr_stmt|;
block|}
DECL|method|preUpdate
specifier|private
name|boolean
name|preUpdate
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
name|boolean
name|maybeMerge
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|flushControl
operator|.
name|anyStalledThreads
argument_list|()
operator|||
name|flushControl
operator|.
name|numQueuedFlushes
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Help out flushing any queued DWPTs so we can un-stall:
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)"
argument_list|)
expr_stmt|;
block|}
do|do
block|{
comment|// Try pick up pending threads here if possible
name|DocumentsWriterPerThread
name|flushingDWPT
decl_stmt|;
while|while
condition|(
operator|(
name|flushingDWPT
operator|=
name|flushControl
operator|.
name|nextPendingFlush
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// Don't push the delete here since the update could fail!
name|maybeMerge
operator||=
name|doFlush
argument_list|(
name|flushingDWPT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
if|if
condition|(
name|flushControl
operator|.
name|anyStalledThreads
argument_list|()
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"WARNING DocumentsWriter has stalled threads; waiting"
argument_list|)
expr_stmt|;
block|}
block|}
name|flushControl
operator|.
name|waitIfStalled
argument_list|()
expr_stmt|;
comment|// block if stalled
block|}
do|while
condition|(
name|flushControl
operator|.
name|numQueuedFlushes
argument_list|()
operator|!=
literal|0
condition|)
do|;
comment|// still queued DWPTs try help flushing
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"continue indexing after helping out flushing DocumentsWriter is healthy"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|maybeMerge
return|;
block|}
DECL|method|postUpdate
specifier|private
name|boolean
name|postUpdate
parameter_list|(
name|DocumentsWriterPerThread
name|flushingDWPT
parameter_list|,
name|boolean
name|maybeMerge
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|flushControl
operator|.
name|doApplyAllDeletes
argument_list|()
condition|)
block|{
name|applyAllDeletes
argument_list|(
name|deleteQueue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flushingDWPT
operator|!=
literal|null
condition|)
block|{
name|maybeMerge
operator||=
name|doFlush
argument_list|(
name|flushingDWPT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|DocumentsWriterPerThread
name|nextPendingFlush
init|=
name|flushControl
operator|.
name|nextPendingFlush
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextPendingFlush
operator|!=
literal|null
condition|)
block|{
name|maybeMerge
operator||=
name|doFlush
argument_list|(
name|nextPendingFlush
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|maybeMerge
return|;
block|}
DECL|method|updateDocuments
name|boolean
name|updateDocuments
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|?
extends|extends
name|IndexDocument
argument_list|>
name|docs
parameter_list|,
specifier|final
name|Analyzer
name|analyzer
parameter_list|,
specifier|final
name|Term
name|delTerm
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|maybeMerge
init|=
name|preUpdate
argument_list|()
decl_stmt|;
specifier|final
name|ThreadState
name|perThread
init|=
name|flushControl
operator|.
name|obtainAndLock
argument_list|()
decl_stmt|;
specifier|final
name|DocumentsWriterPerThread
name|flushingDWPT
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|perThread
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
assert|assert
literal|false
operator|:
literal|"perThread is not active but we are still open"
assert|;
block|}
specifier|final
name|DocumentsWriterPerThread
name|dwpt
init|=
name|perThread
operator|.
name|dwpt
decl_stmt|;
try|try
block|{
specifier|final
name|int
name|docCount
init|=
name|dwpt
operator|.
name|updateDocuments
argument_list|(
name|docs
argument_list|,
name|analyzer
argument_list|,
name|delTerm
argument_list|)
decl_stmt|;
name|numDocsInRAM
operator|.
name|addAndGet
argument_list|(
name|docCount
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|dwpt
operator|.
name|checkAndResetHasAborted
argument_list|()
condition|)
block|{
name|flushControl
operator|.
name|doOnAbort
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|boolean
name|isUpdate
init|=
name|delTerm
operator|!=
literal|null
decl_stmt|;
name|flushingDWPT
operator|=
name|flushControl
operator|.
name|doAfterDocument
argument_list|(
name|perThread
argument_list|,
name|isUpdate
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|perThread
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|postUpdate
argument_list|(
name|flushingDWPT
argument_list|,
name|maybeMerge
argument_list|)
return|;
block|}
DECL|method|updateDocument
name|boolean
name|updateDocument
parameter_list|(
specifier|final
name|IndexDocument
name|doc
parameter_list|,
specifier|final
name|Analyzer
name|analyzer
parameter_list|,
specifier|final
name|Term
name|delTerm
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|maybeMerge
init|=
name|preUpdate
argument_list|()
decl_stmt|;
specifier|final
name|ThreadState
name|perThread
init|=
name|flushControl
operator|.
name|obtainAndLock
argument_list|()
decl_stmt|;
specifier|final
name|DocumentsWriterPerThread
name|flushingDWPT
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|perThread
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"perThread is not active but we are still open"
argument_list|)
throw|;
block|}
specifier|final
name|DocumentsWriterPerThread
name|dwpt
init|=
name|perThread
operator|.
name|dwpt
decl_stmt|;
try|try
block|{
name|dwpt
operator|.
name|updateDocument
argument_list|(
name|doc
argument_list|,
name|analyzer
argument_list|,
name|delTerm
argument_list|)
expr_stmt|;
name|numDocsInRAM
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|dwpt
operator|.
name|checkAndResetHasAborted
argument_list|()
condition|)
block|{
name|flushControl
operator|.
name|doOnAbort
argument_list|(
name|perThread
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|boolean
name|isUpdate
init|=
name|delTerm
operator|!=
literal|null
decl_stmt|;
name|flushingDWPT
operator|=
name|flushControl
operator|.
name|doAfterDocument
argument_list|(
name|perThread
argument_list|,
name|isUpdate
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|perThread
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|postUpdate
argument_list|(
name|flushingDWPT
argument_list|,
name|maybeMerge
argument_list|)
return|;
block|}
DECL|method|doFlush
specifier|private
name|boolean
name|doFlush
parameter_list|(
name|DocumentsWriterPerThread
name|flushingDWPT
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|maybeMerge
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|flushingDWPT
operator|!=
literal|null
condition|)
block|{
name|maybeMerge
operator|=
literal|true
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|SegmentFlushTicket
name|ticket
init|=
literal|null
decl_stmt|;
try|try
block|{
assert|assert
name|currentFullFlushDelQueue
operator|==
literal|null
operator|||
name|flushingDWPT
operator|.
name|deleteQueue
operator|==
name|currentFullFlushDelQueue
operator|:
literal|"expected: "
operator|+
name|currentFullFlushDelQueue
operator|+
literal|"but was: "
operator|+
name|flushingDWPT
operator|.
name|deleteQueue
operator|+
literal|" "
operator|+
name|flushControl
operator|.
name|isFullFlush
argument_list|()
assert|;
comment|/*          * Since with DWPT the flush process is concurrent and several DWPT          * could flush at the same time we must maintain the order of the          * flushes before we can apply the flushed segment and the frozen global          * deletes it is buffering. The reason for this is that the global          * deletes mark a certain point in time where we took a DWPT out of          * rotation and freeze the global deletes.          *           * Example: A flush 'A' starts and freezes the global deletes, then          * flush 'B' starts and freezes all deletes occurred since 'A' has          * started. if 'B' finishes before 'A' we need to wait until 'A' is done          * otherwise the deletes frozen by 'B' are not applied to 'A' and we          * might miss to deletes documents in 'A'.          */
try|try
block|{
comment|// Each flush is assigned a ticket in the order they acquire the ticketQueue lock
name|ticket
operator|=
name|ticketQueue
operator|.
name|addFlushTicket
argument_list|(
name|flushingDWPT
argument_list|)
expr_stmt|;
comment|// flush concurrently without locking
specifier|final
name|FlushedSegment
name|newSegment
init|=
name|flushingDWPT
operator|.
name|flush
argument_list|()
decl_stmt|;
name|ticketQueue
operator|.
name|addSegment
argument_list|(
name|ticket
argument_list|,
name|newSegment
argument_list|)
expr_stmt|;
comment|// flush was successful once we reached this point - new seg. has been assigned to the ticket!
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
operator|&&
name|ticket
operator|!=
literal|null
condition|)
block|{
comment|// In the case of a failure make sure we are making progress and
comment|// apply all the deletes since the segment flush failed since the flush
comment|// ticket could hold global deletes see FlushTicket#canPublish()
name|ticketQueue
operator|.
name|markTicketFailed
argument_list|(
name|ticket
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*          * Now we are done and try to flush the ticket queue if the head of the          * queue has already finished the flush.          */
if|if
condition|(
name|ticketQueue
operator|.
name|getTicketCount
argument_list|()
operator|>=
name|perThreadPool
operator|.
name|getActiveThreadState
argument_list|()
condition|)
block|{
comment|// This means there is a backlog: the one
comment|// thread in innerPurge can't keep up with all
comment|// other threads flushing segments.  In this case
comment|// we forcefully stall the producers.
name|ticketQueue
operator|.
name|forcePurge
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ticketQueue
operator|.
name|tryPurge
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|flushControl
operator|.
name|doAfterFlush
argument_list|(
name|flushingDWPT
argument_list|)
expr_stmt|;
name|flushingDWPT
operator|.
name|checkAndResetHasAborted
argument_list|()
expr_stmt|;
name|indexWriter
operator|.
name|flushCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|indexWriter
operator|.
name|doAfterFlush
argument_list|()
expr_stmt|;
block|}
name|flushingDWPT
operator|=
name|flushControl
operator|.
name|nextPendingFlush
argument_list|()
expr_stmt|;
block|}
comment|// If deletes alone are consuming> 1/2 our RAM
comment|// buffer, force them all to apply now. This is to
comment|// prevent too-frequent flushing of a long tail of
comment|// tiny segments:
specifier|final
name|double
name|ramBufferSizeMB
init|=
name|indexWriter
operator|.
name|getConfig
argument_list|()
operator|.
name|getRAMBufferSizeMB
argument_list|()
decl_stmt|;
if|if
condition|(
name|ramBufferSizeMB
operator|!=
name|IndexWriterConfig
operator|.
name|DISABLE_AUTO_FLUSH
operator|&&
name|flushControl
operator|.
name|getDeleteBytesUsed
argument_list|()
operator|>
operator|(
literal|1024
operator|*
literal|1024
operator|*
name|ramBufferSizeMB
operator|/
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"force apply deletes bytesUsed="
operator|+
name|flushControl
operator|.
name|getDeleteBytesUsed
argument_list|()
operator|+
literal|" vs ramBuffer="
operator|+
operator|(
literal|1024
operator|*
literal|1024
operator|*
name|ramBufferSizeMB
operator|)
argument_list|)
expr_stmt|;
block|}
name|applyAllDeletes
argument_list|(
name|deleteQueue
argument_list|)
expr_stmt|;
block|}
return|return
name|maybeMerge
return|;
block|}
DECL|method|finishFlush
name|void
name|finishFlush
parameter_list|(
name|FlushedSegment
name|newSegment
parameter_list|,
name|FrozenBufferedDeletes
name|bufferedDeletes
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Finish the flushed segment and publish it to IndexWriter
if|if
condition|(
name|newSegment
operator|==
literal|null
condition|)
block|{
assert|assert
name|bufferedDeletes
operator|!=
literal|null
assert|;
if|if
condition|(
name|bufferedDeletes
operator|!=
literal|null
operator|&&
name|bufferedDeletes
operator|.
name|any
argument_list|()
condition|)
block|{
name|indexWriter
operator|.
name|publishFrozenDeletes
argument_list|(
name|bufferedDeletes
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"flush: push buffered deletes: "
operator|+
name|bufferedDeletes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|publishFlushedSegment
argument_list|(
name|newSegment
argument_list|,
name|bufferedDeletes
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|subtractFlushedNumDocs
specifier|final
name|void
name|subtractFlushedNumDocs
parameter_list|(
name|int
name|numFlushed
parameter_list|)
block|{
name|int
name|oldValue
init|=
name|numDocsInRAM
operator|.
name|get
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|numDocsInRAM
operator|.
name|compareAndSet
argument_list|(
name|oldValue
argument_list|,
name|oldValue
operator|-
name|numFlushed
argument_list|)
condition|)
block|{
name|oldValue
operator|=
name|numDocsInRAM
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Publishes the flushed segment, segment private deletes (if any) and its    * associated global delete (if present) to IndexWriter.  The actual    * publishing operation is synced on IW -> BDS so that the {@link SegmentInfo}'s    * delete generation is always GlobalPacket_deleteGeneration + 1    */
DECL|method|publishFlushedSegment
specifier|private
name|void
name|publishFlushedSegment
parameter_list|(
name|FlushedSegment
name|newSegment
parameter_list|,
name|FrozenBufferedDeletes
name|globalPacket
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|newSegment
operator|!=
literal|null
assert|;
assert|assert
name|newSegment
operator|.
name|segmentInfo
operator|!=
literal|null
assert|;
specifier|final
name|FrozenBufferedDeletes
name|segmentDeletes
init|=
name|newSegment
operator|.
name|segmentDeletes
decl_stmt|;
comment|//System.out.println("FLUSH: " + newSegment.segmentInfo.info.name);
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"publishFlushedSegment seg-private deletes="
operator|+
name|segmentDeletes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|segmentDeletes
operator|!=
literal|null
operator|&&
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
literal|"flush: push buffered seg private deletes: "
operator|+
name|segmentDeletes
argument_list|)
expr_stmt|;
block|}
comment|// now publish!
name|indexWriter
operator|.
name|publishFlushedSegment
argument_list|(
name|newSegment
operator|.
name|segmentInfo
argument_list|,
name|segmentDeletes
argument_list|,
name|globalPacket
argument_list|)
expr_stmt|;
block|}
comment|// for asserts
DECL|field|currentFullFlushDelQueue
specifier|private
specifier|volatile
name|DocumentsWriterDeleteQueue
name|currentFullFlushDelQueue
init|=
literal|null
decl_stmt|;
comment|// for asserts
DECL|method|setFlushingDeleteQueue
specifier|private
specifier|synchronized
name|boolean
name|setFlushingDeleteQueue
parameter_list|(
name|DocumentsWriterDeleteQueue
name|session
parameter_list|)
block|{
name|currentFullFlushDelQueue
operator|=
name|session
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/*    * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a    * two stage operation; the caller must ensure (in try/finally) that finishFlush    * is called after this method, to release the flush lock in DWFlushControl    */
DECL|method|flushAllThreads
specifier|final
name|boolean
name|flushAllThreads
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|DocumentsWriterDeleteQueue
name|flushingDeleteQueue
decl_stmt|;
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" startFullFlush"
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
name|pendingChangesInCurrentFullFlush
operator|=
name|anyChanges
argument_list|()
expr_stmt|;
name|flushingDeleteQueue
operator|=
name|deleteQueue
expr_stmt|;
comment|/* Cutover to a new delete queue.  This must be synced on the flush control        * otherwise a new DWPT could sneak into the loop with an already flushing        * delete queue */
name|flushControl
operator|.
name|markForFullFlush
argument_list|()
expr_stmt|;
comment|// swaps the delQueue synced on FlushControl
assert|assert
name|setFlushingDeleteQueue
argument_list|(
name|flushingDeleteQueue
argument_list|)
assert|;
block|}
assert|assert
name|currentFullFlushDelQueue
operator|!=
literal|null
assert|;
assert|assert
name|currentFullFlushDelQueue
operator|!=
name|deleteQueue
assert|;
name|boolean
name|anythingFlushed
init|=
literal|false
decl_stmt|;
try|try
block|{
name|DocumentsWriterPerThread
name|flushingDWPT
decl_stmt|;
comment|// Help out with flushing:
while|while
condition|(
operator|(
name|flushingDWPT
operator|=
name|flushControl
operator|.
name|nextPendingFlush
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|anythingFlushed
operator||=
name|doFlush
argument_list|(
name|flushingDWPT
argument_list|)
expr_stmt|;
block|}
comment|// If a concurrent flush is still in flight wait for it
name|flushControl
operator|.
name|waitForFlush
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|anythingFlushed
operator|&&
name|flushingDeleteQueue
operator|.
name|anyChanges
argument_list|()
condition|)
block|{
comment|// apply deletes if we did not flush any document
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": flush naked frozen global deletes"
argument_list|)
expr_stmt|;
block|}
name|ticketQueue
operator|.
name|addDeletesAndPurge
argument_list|(
name|this
argument_list|,
name|flushingDeleteQueue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ticketQueue
operator|.
name|forcePurge
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
assert|assert
operator|!
name|flushingDeleteQueue
operator|.
name|anyChanges
argument_list|()
operator|&&
operator|!
name|ticketQueue
operator|.
name|hasTickets
argument_list|()
assert|;
block|}
finally|finally
block|{
assert|assert
name|flushingDeleteQueue
operator|==
name|currentFullFlushDelQueue
assert|;
block|}
return|return
name|anythingFlushed
return|;
block|}
DECL|method|finishFullFlush
specifier|final
name|void
name|finishFullFlush
parameter_list|(
name|boolean
name|success
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|infoStream
operator|.
name|isEnabled
argument_list|(
literal|"DW"
argument_list|)
condition|)
block|{
name|infoStream
operator|.
name|message
argument_list|(
literal|"DW"
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" finishFullFlush success="
operator|+
name|success
argument_list|)
expr_stmt|;
block|}
assert|assert
name|setFlushingDeleteQueue
argument_list|(
literal|null
argument_list|)
assert|;
if|if
condition|(
name|success
condition|)
block|{
comment|// Release the flush lock
name|flushControl
operator|.
name|finishFullFlush
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|flushControl
operator|.
name|abortFullFlushes
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|pendingChangesInCurrentFullFlush
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
