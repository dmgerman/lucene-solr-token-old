begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharacterCodingException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharsetDecoder
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CodingErrorAction
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import
begin_comment
comment|/**   A Term represents a word from text.  This is the unit of search.  It is   composed of two elements, the text of the word, as a string, and the name of   the field that the text occurred in.    Note that terms may represent more than words from text fields, but also   things like dates, email addresses, urls, etc.  */
end_comment
begin_class
DECL|class|Term
specifier|public
specifier|final
class|class
name|Term
implements|implements
name|Comparable
argument_list|<
name|Term
argument_list|>
block|{
DECL|field|field
name|String
name|field
decl_stmt|;
DECL|field|bytes
name|BytesRef
name|bytes
decl_stmt|;
comment|/** Constructs a Term with the given field and bytes.    *<p>Note that a null field or null bytes value results in undefined    * behavior for most Lucene APIs that accept a Term parameter.    *    *<p>The provided BytesRef is copied when it is non null.    */
DECL|method|Term
specifier|public
name|Term
parameter_list|(
name|String
name|fld
parameter_list|,
name|BytesRef
name|bytes
parameter_list|)
block|{
name|field
operator|=
name|fld
expr_stmt|;
name|this
operator|.
name|bytes
operator|=
name|bytes
operator|==
literal|null
condition|?
literal|null
else|:
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
comment|/** Constructs a Term with the given field and the bytes from a builder.    *<p>Note that a null field value results in undefined    * behavior for most Lucene APIs that accept a Term parameter.    */
DECL|method|Term
specifier|public
name|Term
parameter_list|(
name|String
name|fld
parameter_list|,
name|BytesRefBuilder
name|bytesBuilder
parameter_list|)
block|{
name|field
operator|=
name|fld
expr_stmt|;
name|this
operator|.
name|bytes
operator|=
name|bytesBuilder
operator|.
name|toBytesRef
argument_list|()
expr_stmt|;
block|}
comment|/** Constructs a Term with the given field and text.    *<p>Note that a null field or null text value results in undefined    * behavior for most Lucene APIs that accept a Term parameter. */
DECL|method|Term
specifier|public
name|Term
parameter_list|(
name|String
name|fld
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|this
argument_list|(
name|fld
argument_list|,
operator|new
name|BytesRef
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Constructs a Term with the given field and empty text.    * This serves two purposes: 1) reuse of a Term with the same field.    * 2) pattern for a query.    *    * @param fld field's name    */
DECL|method|Term
specifier|public
name|Term
parameter_list|(
name|String
name|fld
parameter_list|)
block|{
name|this
argument_list|(
name|fld
argument_list|,
operator|new
name|BytesRef
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Returns the field of this term.   The field indicates     the part of a document which this term came from. */
DECL|method|field
specifier|public
specifier|final
name|String
name|field
parameter_list|()
block|{
return|return
name|field
return|;
block|}
comment|/** Returns the text of this term.  In the case of words, this is simply the     text of the word.  In the case of dates and other types, this is an     encoding of the object as a string.  */
DECL|method|text
specifier|public
specifier|final
name|String
name|text
parameter_list|()
block|{
return|return
name|toString
argument_list|(
name|bytes
argument_list|)
return|;
block|}
comment|/** Returns human-readable form of the term text. If the term is not unicode,    * the raw bytes will be printed instead. */
DECL|method|toString
specifier|public
specifier|static
specifier|final
name|String
name|toString
parameter_list|(
name|BytesRef
name|termText
parameter_list|)
block|{
comment|// the term might not be text, but usually is. so we make a best effort
name|CharsetDecoder
name|decoder
init|=
name|StandardCharsets
operator|.
name|UTF_8
operator|.
name|newDecoder
argument_list|()
operator|.
name|onMalformedInput
argument_list|(
name|CodingErrorAction
operator|.
name|REPORT
argument_list|)
operator|.
name|onUnmappableCharacter
argument_list|(
name|CodingErrorAction
operator|.
name|REPORT
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|decoder
operator|.
name|decode
argument_list|(
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|termText
operator|.
name|bytes
argument_list|,
name|termText
operator|.
name|offset
argument_list|,
name|termText
operator|.
name|length
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|CharacterCodingException
name|e
parameter_list|)
block|{
return|return
name|termText
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** Returns the bytes of this term, these should not be modified. */
DECL|method|bytes
specifier|public
specifier|final
name|BytesRef
name|bytes
parameter_list|()
block|{
return|return
name|bytes
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|getClass
argument_list|()
operator|!=
name|obj
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
name|Term
name|other
init|=
operator|(
name|Term
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|field
operator|!=
literal|null
condition|)
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|field
operator|.
name|equals
argument_list|(
name|other
operator|.
name|field
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|bytes
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|bytes
operator|!=
literal|null
condition|)
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bytes
operator|.
name|equals
argument_list|(
name|other
operator|.
name|bytes
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|int
name|prime
init|=
literal|31
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
operator|(
operator|(
name|field
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|field
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
operator|(
operator|(
name|bytes
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|bytes
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/** Compares two terms, returning a negative integer if this     term belongs before the argument, zero if this term is equal to the     argument, and a positive integer if this term belongs after the argument.      The ordering of terms is first by field, then by text.*/
annotation|@
name|Override
DECL|method|compareTo
specifier|public
specifier|final
name|int
name|compareTo
parameter_list|(
name|Term
name|other
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|equals
argument_list|(
name|other
operator|.
name|field
argument_list|)
condition|)
block|{
return|return
name|bytes
operator|.
name|compareTo
argument_list|(
name|other
operator|.
name|bytes
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|field
operator|.
name|compareTo
argument_list|(
name|other
operator|.
name|field
argument_list|)
return|;
block|}
block|}
comment|/**    * Resets the field and text of a Term.    *<p>WARNING: the provided BytesRef is not copied, but used directly.    * Therefore the bytes should not be modified after construction, for    * example, you should clone a copy rather than pass reused bytes from    * a TermsEnum.    */
DECL|method|set
specifier|final
name|void
name|set
parameter_list|(
name|String
name|fld
parameter_list|,
name|BytesRef
name|bytes
parameter_list|)
block|{
name|field
operator|=
name|fld
expr_stmt|;
name|this
operator|.
name|bytes
operator|=
name|bytes
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
specifier|final
name|String
name|toString
parameter_list|()
block|{
return|return
name|field
operator|+
literal|":"
operator|+
name|text
argument_list|()
return|;
block|}
block|}
end_class
end_unit
