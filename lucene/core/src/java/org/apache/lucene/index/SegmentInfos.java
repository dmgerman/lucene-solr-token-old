begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|DocValuesFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|FieldInfosFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|LiveDocsFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ChecksumIndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import
begin_comment
comment|/**  * A collection of segmentInfo objects with methods for operating on those  * segments in relation to the file system.  *<p>  * The active segments in the index are stored in the segment info file,  *<tt>segments_N</tt>. There may be one or more<tt>segments_N</tt> files in  * the index; however, the one with the largest generation is the active one  * (when older segments_N files are present it's because they temporarily cannot  * be deleted, or a custom {@link IndexDeletionPolicy} is in  * use). This file lists each segment by name and has details about the codec  * and generation of deletes.  *</p>  *<p>  * Files:  *<ul>  *<li><tt>segments_N</tt>: Header, Version, NameCounter, SegCount,&lt;SegName,  * HasSegID, SegID, SegCodec, DelGen, DeletionCount, FieldInfosGen, DocValuesGen,  * UpdatesFiles&gt;<sup>SegCount</sup>, CommitUserData, Footer  *</ul>  * Data types:  *<ul>  *<li>Header --&gt; {@link CodecUtil#writeIndexHeader IndexHeader}</li>  *<li>NameCounter, SegCount, DeletionCount --&gt;  * {@link DataOutput#writeInt Int32}</li>  *<li>Generation, Version, DelGen, Checksum, FieldInfosGen, DocValuesGen --&gt;  * {@link DataOutput#writeLong Int64}</li>  *<li>HasSegID --&gt; {@link DataOutput#writeByte Int8}</li>  *<li>SegID --&gt; {@link DataOutput#writeByte Int8<sup>ID_LENGTH</sup>}</li>  *<li>SegName, SegCodec --&gt; {@link DataOutput#writeString String}</li>  *<li>CommitUserData --&gt; {@link DataOutput#writeMapOfStrings  * Map&lt;String,String&gt;}</li>  *<li>UpdatesFiles --&gt; Map&lt;{@link DataOutput#writeInt Int32},  * {@link DataOutput#writeSetOfStrings(Set) Set&lt;String&gt;}&gt;</li>  *<li>Footer --&gt; {@link CodecUtil#writeFooter CodecFooter}</li>  *</ul>  * Field Descriptions:  *<ul>  *<li>Version counts how often the index has been changed by adding or deleting  * documents.</li>  *<li>NameCounter is used to generate names for new segment files.</li>  *<li>SegName is the name of the segment, and is used as the file name prefix  * for all of the files that compose the segment's index.</li>  *<li>DelGen is the generation count of the deletes file. If this is -1, there  * are no deletes. Anything above zero means there are deletes stored by  * {@link LiveDocsFormat}.</li>  *<li>DeletionCount records the number of deleted documents in this segment.</li>  *<li>SegCodec is the {@link Codec#getName() name} of the Codec that encoded  * this segment.</li>  *<li>HasSegID is nonzero if the segment has an identifier. Otherwise, when it is 0  * the identifier is {@code null} and no SegID is written. Null only happens for Lucene  * 4.x segments referenced in commits.</li>  *<li>SegID is the identifier of the Codec that encoded this segment.</li>  *<li>CommitUserData stores an optional user-supplied opaque  * Map&lt;String,String&gt; that was passed to  * {@link IndexWriter#setCommitData(java.util.Map)}.</li>  *<li>FieldInfosGen is the generation count of the fieldInfos file. If this is  * -1, there are no updates to the fieldInfos in that segment. Anything above  * zero means there are updates to fieldInfos stored by {@link FieldInfosFormat}  * .</li>  *<li>DocValuesGen is the generation count of the updatable DocValues. If this  * is -1, there are no updates to DocValues in that segment. Anything above zero  * means there are updates to DocValues stored by {@link DocValuesFormat}.</li>  *<li>UpdatesFiles stores the set of files that were updated in that segment  * per field.</li>  *</ul>  *   * @lucene.experimental  */
end_comment
begin_class
DECL|class|SegmentInfos
specifier|public
specifier|final
class|class
name|SegmentInfos
implements|implements
name|Cloneable
implements|,
name|Iterable
argument_list|<
name|SegmentCommitInfo
argument_list|>
block|{
comment|/** The file format version for the segments_N codec header, since 5.0+ */
DECL|field|VERSION_50
specifier|public
specifier|static
specifier|final
name|int
name|VERSION_50
init|=
literal|4
decl_stmt|;
comment|/** The file format version for the segments_N codec header, since 5.1+ */
DECL|field|VERSION_51
specifier|public
specifier|static
specifier|final
name|int
name|VERSION_51
init|=
literal|5
decl_stmt|;
comment|// use safe maps
DECL|field|VERSION_CURRENT
specifier|static
specifier|final
name|int
name|VERSION_CURRENT
init|=
name|VERSION_51
decl_stmt|;
comment|/** Used to name new segments. */
comment|// TODO: should this be a long ...?
DECL|field|counter
specifier|public
name|int
name|counter
decl_stmt|;
comment|/** Counts how often the index has been changed.  */
DECL|field|version
specifier|public
name|long
name|version
decl_stmt|;
DECL|field|generation
specifier|private
name|long
name|generation
decl_stmt|;
comment|// generation of the "segments_N" for the next commit
DECL|field|lastGeneration
specifier|private
name|long
name|lastGeneration
decl_stmt|;
comment|// generation of the "segments_N" file we last successfully read
comment|// or wrote; this is normally the same as generation except if
comment|// there was an IOException that had interrupted a commit
comment|/** Opaque Map&lt;String, String&gt; that user can specify during IndexWriter.commit */
DECL|field|userData
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|userData
init|=
name|Collections
operator|.
name|emptyMap
argument_list|()
decl_stmt|;
DECL|field|segments
specifier|private
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|segments
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * If non-null, information about loading segments_N files    * will be printed here.  @see #setInfoStream.    */
DECL|field|infoStream
specifier|private
specifier|static
name|PrintStream
name|infoStream
init|=
literal|null
decl_stmt|;
comment|/** Id for this commit; only written starting with Lucene 5.0 */
DECL|field|id
specifier|private
name|byte
index|[]
name|id
decl_stmt|;
comment|/** Sole constructor. Typically you call this and then    *  use {@link #readLatestCommit(Directory) or    *  #readCommit(Directory,String)} to populate each {@link    *  SegmentCommitInfo}.  Alternatively, you can add/remove your    *  own {@link SegmentCommitInfo}s. */
DECL|method|SegmentInfos
specifier|public
name|SegmentInfos
parameter_list|()
block|{   }
comment|/** Returns {@link SegmentCommitInfo} at the provided    *  index. */
DECL|method|info
specifier|public
name|SegmentCommitInfo
name|info
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|segments
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/**    * Get the generation of the most recent commit to the    * list of index files (N in the segments_N file).    *    * @param files -- array of file names to check    */
DECL|method|getLastCommitGeneration
specifier|public
specifier|static
name|long
name|getLastCommitGeneration
parameter_list|(
name|String
index|[]
name|files
parameter_list|)
block|{
name|long
name|max
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|files
control|)
block|{
if|if
condition|(
name|file
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|)
operator|&&
operator|!
name|file
operator|.
name|equals
argument_list|(
name|IndexFileNames
operator|.
name|OLD_SEGMENTS_GEN
argument_list|)
condition|)
block|{
name|long
name|gen
init|=
name|generationFromSegmentsFileName
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|gen
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|gen
expr_stmt|;
block|}
block|}
block|}
return|return
name|max
return|;
block|}
comment|/**    * Get the generation of the most recent commit to the    * index in this directory (N in the segments_N file).    *    * @param directory -- directory to search for the latest segments_N file    */
DECL|method|getLastCommitGeneration
specifier|public
specifier|static
name|long
name|getLastCommitGeneration
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getLastCommitGeneration
argument_list|(
name|directory
operator|.
name|listAll
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get the filename of the segments_N file for the most    * recent commit in the list of index files.    *    * @param files -- array of file names to check    */
DECL|method|getLastCommitSegmentsFileName
specifier|public
specifier|static
name|String
name|getLastCommitSegmentsFileName
parameter_list|(
name|String
index|[]
name|files
parameter_list|)
block|{
return|return
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|getLastCommitGeneration
argument_list|(
name|files
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the filename of the segments_N file for the most    * recent commit to the index in this Directory.    *    * @param directory -- directory to search for the latest segments_N file    */
DECL|method|getLastCommitSegmentsFileName
specifier|public
specifier|static
name|String
name|getLastCommitSegmentsFileName
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|getLastCommitGeneration
argument_list|(
name|directory
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the segments_N filename in use by this segment infos.    */
DECL|method|getSegmentsFileName
specifier|public
name|String
name|getSegmentsFileName
parameter_list|()
block|{
return|return
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|lastGeneration
argument_list|)
return|;
block|}
comment|/**    * Parse the generation off the segments file name and    * return it.    */
DECL|method|generationFromSegmentsFileName
specifier|public
specifier|static
name|long
name|generationFromSegmentsFileName
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
if|if
condition|(
name|fileName
operator|.
name|equals
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fileName
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|)
condition|)
block|{
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|fileName
operator|.
name|substring
argument_list|(
literal|1
operator|+
name|IndexFileNames
operator|.
name|SEGMENTS
operator|.
name|length
argument_list|()
argument_list|)
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"fileName \""
operator|+
name|fileName
operator|+
literal|"\" is not a segments file"
argument_list|)
throw|;
block|}
block|}
comment|/** return generation of the next pending_segments_N that will be written */
DECL|method|getNextPendingGeneration
specifier|private
name|long
name|getNextPendingGeneration
parameter_list|()
block|{
if|if
condition|(
name|generation
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
name|generation
operator|+
literal|1
return|;
block|}
block|}
comment|/** Since Lucene 5.0, every commit (segments_N) writes a unique id.  This will    *  return that id */
DECL|method|getId
specifier|public
name|byte
index|[]
name|getId
parameter_list|()
block|{
return|return
name|id
operator|.
name|clone
argument_list|()
return|;
block|}
comment|/**    * Read a particular segmentFileName.  Note that this may    * throw an IOException if a commit is in process.    *    * @param directory -- directory containing the segments file    * @param segmentFileName -- segment file to load    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|readCommit
specifier|public
specifier|static
specifier|final
name|SegmentInfos
name|readCommit
parameter_list|(
name|Directory
name|directory
parameter_list|,
name|String
name|segmentFileName
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|generation
init|=
name|generationFromSegmentsFileName
argument_list|(
name|segmentFileName
argument_list|)
decl_stmt|;
try|try
init|(
name|ChecksumIndexInput
name|input
init|=
name|directory
operator|.
name|openChecksumInput
argument_list|(
name|segmentFileName
argument_list|,
name|IOContext
operator|.
name|READ
argument_list|)
init|)
block|{
comment|// NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need
comment|// to read the magic ourselves.
name|int
name|magic
init|=
name|input
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|magic
operator|!=
name|CodecUtil
operator|.
name|CODEC_MAGIC
condition|)
block|{
throw|throw
operator|new
name|IndexFormatTooOldException
argument_list|(
name|input
argument_list|,
name|magic
argument_list|,
name|CodecUtil
operator|.
name|CODEC_MAGIC
argument_list|,
name|CodecUtil
operator|.
name|CODEC_MAGIC
argument_list|)
throw|;
block|}
name|int
name|format
init|=
name|CodecUtil
operator|.
name|checkHeaderNoMagic
argument_list|(
name|input
argument_list|,
literal|"segments"
argument_list|,
name|VERSION_50
argument_list|,
name|VERSION_CURRENT
argument_list|)
decl_stmt|;
name|byte
name|id
index|[]
init|=
operator|new
name|byte
index|[
name|StringHelper
operator|.
name|ID_LENGTH
index|]
decl_stmt|;
name|input
operator|.
name|readBytes
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
name|id
operator|.
name|length
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|checkIndexHeaderSuffix
argument_list|(
name|input
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|generation
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
argument_list|)
expr_stmt|;
name|SegmentInfos
name|infos
init|=
operator|new
name|SegmentInfos
argument_list|()
decl_stmt|;
name|infos
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|infos
operator|.
name|generation
operator|=
name|generation
expr_stmt|;
name|infos
operator|.
name|lastGeneration
operator|=
name|generation
expr_stmt|;
name|infos
operator|.
name|version
operator|=
name|input
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|infos
operator|.
name|counter
operator|=
name|input
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|int
name|numSegments
init|=
name|input
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|numSegments
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|CorruptIndexException
argument_list|(
literal|"invalid segment count: "
operator|+
name|numSegments
argument_list|,
name|input
argument_list|)
throw|;
block|}
name|long
name|totalDocs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|seg
init|=
literal|0
init|;
name|seg
operator|<
name|numSegments
condition|;
name|seg
operator|++
control|)
block|{
name|String
name|segName
init|=
name|input
operator|.
name|readString
argument_list|()
decl_stmt|;
specifier|final
name|byte
name|segmentID
index|[]
decl_stmt|;
name|byte
name|hasID
init|=
name|input
operator|.
name|readByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasID
operator|==
literal|1
condition|)
block|{
name|segmentID
operator|=
operator|new
name|byte
index|[
name|StringHelper
operator|.
name|ID_LENGTH
index|]
expr_stmt|;
name|input
operator|.
name|readBytes
argument_list|(
name|segmentID
argument_list|,
literal|0
argument_list|,
name|segmentID
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|CorruptIndexException
argument_list|(
literal|"invalid hasID byte, got: "
operator|+
name|hasID
argument_list|,
name|input
argument_list|)
throw|;
block|}
name|Codec
name|codec
init|=
name|Codec
operator|.
name|forName
argument_list|(
name|input
operator|.
name|readString
argument_list|()
argument_list|)
decl_stmt|;
name|SegmentInfo
name|info
init|=
name|codec
operator|.
name|segmentInfoFormat
argument_list|()
operator|.
name|read
argument_list|(
name|directory
argument_list|,
name|segName
argument_list|,
name|segmentID
argument_list|,
name|IOContext
operator|.
name|READ
argument_list|)
decl_stmt|;
name|info
operator|.
name|setCodec
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|totalDocs
operator|+=
name|info
operator|.
name|getDocCount
argument_list|()
expr_stmt|;
name|long
name|delGen
init|=
name|input
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|int
name|delCount
init|=
name|input
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|delCount
argument_list|<
literal|0
operator|||
name|delCount
argument_list|>
name|info
operator|.
name|getDocCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|CorruptIndexException
argument_list|(
literal|"invalid deletion count: "
operator|+
name|delCount
operator|+
literal|" vs docCount="
operator|+
name|info
operator|.
name|getDocCount
argument_list|()
argument_list|,
name|input
argument_list|)
throw|;
block|}
name|long
name|fieldInfosGen
init|=
name|input
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|long
name|dvGen
init|=
name|input
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|SegmentCommitInfo
name|siPerCommit
init|=
operator|new
name|SegmentCommitInfo
argument_list|(
name|info
argument_list|,
name|delCount
argument_list|,
name|delGen
argument_list|,
name|fieldInfosGen
argument_list|,
name|dvGen
argument_list|)
decl_stmt|;
if|if
condition|(
name|format
operator|>=
name|VERSION_51
condition|)
block|{
name|siPerCommit
operator|.
name|setFieldInfosFiles
argument_list|(
name|input
operator|.
name|readSetOfStrings
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|siPerCommit
operator|.
name|setFieldInfosFiles
argument_list|(
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|input
operator|.
name|readStringSet
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|dvUpdateFiles
decl_stmt|;
specifier|final
name|int
name|numDVFields
init|=
name|input
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|numDVFields
operator|==
literal|0
condition|)
block|{
name|dvUpdateFiles
operator|=
name|Collections
operator|.
name|emptyMap
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|numDVFields
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numDVFields
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|format
operator|>=
name|VERSION_51
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|input
operator|.
name|readInt
argument_list|()
argument_list|,
name|input
operator|.
name|readSetOfStrings
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|map
operator|.
name|put
argument_list|(
name|input
operator|.
name|readInt
argument_list|()
argument_list|,
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|input
operator|.
name|readStringSet
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|dvUpdateFiles
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
name|siPerCommit
operator|.
name|setDocValuesUpdatesFiles
argument_list|(
name|dvUpdateFiles
argument_list|)
expr_stmt|;
name|infos
operator|.
name|add
argument_list|(
name|siPerCommit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|>=
name|VERSION_51
condition|)
block|{
name|infos
operator|.
name|userData
operator|=
name|input
operator|.
name|readMapOfStrings
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|infos
operator|.
name|userData
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|input
operator|.
name|readStringStringMap
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|CodecUtil
operator|.
name|checkFooter
argument_list|(
name|input
argument_list|)
expr_stmt|;
comment|// LUCENE-6299: check we are in bounds
if|if
condition|(
name|totalDocs
operator|>
name|IndexWriter
operator|.
name|getActualMaxDocs
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|CorruptIndexException
argument_list|(
literal|"Too many documents: an index cannot exceed "
operator|+
name|IndexWriter
operator|.
name|getActualMaxDocs
argument_list|()
operator|+
literal|" but readers have total maxDoc="
operator|+
name|totalDocs
argument_list|,
name|input
argument_list|)
throw|;
block|}
return|return
name|infos
return|;
block|}
block|}
comment|/** Find the latest commit ({@code segments_N file}) and    *  load all {@link SegmentCommitInfo}s. */
DECL|method|readLatestCommit
specifier|public
specifier|static
specifier|final
name|SegmentInfos
name|readLatestCommit
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|FindSegmentsFile
argument_list|<
name|SegmentInfos
argument_list|>
argument_list|(
name|directory
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|SegmentInfos
name|doBody
parameter_list|(
name|String
name|segmentFileName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|readCommit
argument_list|(
name|directory
argument_list|,
name|segmentFileName
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|()
return|;
block|}
comment|// Only true after prepareCommit has been called and
comment|// before finishCommit is called
DECL|field|pendingCommit
name|boolean
name|pendingCommit
decl_stmt|;
DECL|method|write
specifier|private
name|void
name|write
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|nextGeneration
init|=
name|getNextPendingGeneration
argument_list|()
decl_stmt|;
name|String
name|segmentFileName
init|=
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|PENDING_SEGMENTS
argument_list|,
literal|""
argument_list|,
name|nextGeneration
argument_list|)
decl_stmt|;
comment|// Always advance the generation on write:
name|generation
operator|=
name|nextGeneration
expr_stmt|;
name|IndexOutput
name|segnOutput
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|segnOutput
operator|=
name|directory
operator|.
name|createOutput
argument_list|(
name|segmentFileName
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|writeIndexHeader
argument_list|(
name|segnOutput
argument_list|,
literal|"segments"
argument_list|,
name|VERSION_CURRENT
argument_list|,
name|StringHelper
operator|.
name|randomId
argument_list|()
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|nextGeneration
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeLong
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeInt
argument_list|(
name|counter
argument_list|)
expr_stmt|;
comment|// write counter
name|segnOutput
operator|.
name|writeInt
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// write infos
for|for
control|(
name|SegmentCommitInfo
name|siPerCommit
range|:
name|this
control|)
block|{
name|SegmentInfo
name|si
init|=
name|siPerCommit
operator|.
name|info
decl_stmt|;
name|segnOutput
operator|.
name|writeString
argument_list|(
name|si
operator|.
name|name
argument_list|)
expr_stmt|;
name|byte
name|segmentID
index|[]
init|=
name|si
operator|.
name|getId
argument_list|()
decl_stmt|;
comment|// TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore
if|if
condition|(
name|segmentID
operator|==
literal|null
condition|)
block|{
name|segnOutput
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|segmentID
operator|.
name|length
operator|!=
name|StringHelper
operator|.
name|ID_LENGTH
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"cannot write segment: invalid id segment="
operator|+
name|si
operator|.
name|name
operator|+
literal|"id="
operator|+
name|StringHelper
operator|.
name|idToString
argument_list|(
name|segmentID
argument_list|)
argument_list|)
throw|;
block|}
name|segnOutput
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|1
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeBytes
argument_list|(
name|segmentID
argument_list|,
name|segmentID
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|segnOutput
operator|.
name|writeString
argument_list|(
name|si
operator|.
name|getCodec
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeLong
argument_list|(
name|siPerCommit
operator|.
name|getDelGen
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|delCount
init|=
name|siPerCommit
operator|.
name|getDelCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|delCount
argument_list|<
literal|0
operator|||
name|delCount
argument_list|>
name|si
operator|.
name|getDocCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"cannot write segment: invalid docCount segment="
operator|+
name|si
operator|.
name|name
operator|+
literal|" docCount="
operator|+
name|si
operator|.
name|getDocCount
argument_list|()
operator|+
literal|" delCount="
operator|+
name|delCount
argument_list|)
throw|;
block|}
name|segnOutput
operator|.
name|writeInt
argument_list|(
name|delCount
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeLong
argument_list|(
name|siPerCommit
operator|.
name|getFieldInfosGen
argument_list|()
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeLong
argument_list|(
name|siPerCommit
operator|.
name|getDocValuesGen
argument_list|()
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeSetOfStrings
argument_list|(
name|siPerCommit
operator|.
name|getFieldInfosFiles
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|dvUpdatesFiles
init|=
name|siPerCommit
operator|.
name|getDocValuesUpdatesFiles
argument_list|()
decl_stmt|;
name|segnOutput
operator|.
name|writeInt
argument_list|(
name|dvUpdatesFiles
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|e
range|:
name|dvUpdatesFiles
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|segnOutput
operator|.
name|writeInt
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeSetOfStrings
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|si
operator|.
name|dir
operator|==
name|directory
assert|;
block|}
name|segnOutput
operator|.
name|writeMapOfStrings
argument_list|(
name|userData
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|writeFooter
argument_list|(
name|segnOutput
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|directory
operator|.
name|sync
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|segmentFileName
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|pendingCommit
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// We hit an exception above; try to close the file
comment|// but suppress any exception:
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|segnOutput
argument_list|)
expr_stmt|;
comment|// Try not to leave a truncated segments_N file in
comment|// the index:
name|IOUtils
operator|.
name|deleteFilesIgnoringExceptions
argument_list|(
name|directory
argument_list|,
name|segmentFileName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns a copy of this instance, also copying each    * SegmentInfo.    */
annotation|@
name|Override
DECL|method|clone
specifier|public
name|SegmentInfos
name|clone
parameter_list|()
block|{
try|try
block|{
specifier|final
name|SegmentInfos
name|sis
init|=
operator|(
name|SegmentInfos
operator|)
name|super
operator|.
name|clone
argument_list|()
decl_stmt|;
comment|// deep clone, first recreate all collections:
name|sis
operator|.
name|segments
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|SegmentCommitInfo
name|info
range|:
name|this
control|)
block|{
assert|assert
name|info
operator|.
name|info
operator|.
name|getCodec
argument_list|()
operator|!=
literal|null
assert|;
comment|// dont directly access segments, use add method!!!
name|sis
operator|.
name|add
argument_list|(
name|info
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sis
operator|.
name|userData
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|userData
argument_list|)
expr_stmt|;
return|return
name|sis
return|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"should not happen"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * version number when this SegmentInfos was generated.    */
DECL|method|getVersion
specifier|public
name|long
name|getVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
comment|/** Returns current generation. */
DECL|method|getGeneration
specifier|public
name|long
name|getGeneration
parameter_list|()
block|{
return|return
name|generation
return|;
block|}
comment|/** Returns last succesfully read or written generation. */
DECL|method|getLastGeneration
specifier|public
name|long
name|getLastGeneration
parameter_list|()
block|{
return|return
name|lastGeneration
return|;
block|}
comment|/** If non-null, information about retries when loading    * the segments file will be printed to this.    */
DECL|method|setInfoStream
specifier|public
specifier|static
name|void
name|setInfoStream
parameter_list|(
name|PrintStream
name|infoStream
parameter_list|)
block|{
name|SegmentInfos
operator|.
name|infoStream
operator|=
name|infoStream
expr_stmt|;
block|}
comment|/**    * Returns {@code infoStream}.    *    * @see #setInfoStream    */
DECL|method|getInfoStream
specifier|public
specifier|static
name|PrintStream
name|getInfoStream
parameter_list|()
block|{
return|return
name|infoStream
return|;
block|}
comment|/**    * Prints the given message to the infoStream. Note, this method does not    * check for null infoStream. It assumes this check has been performed by the    * caller, which is recommended to avoid the (usually) expensive message    * creation.    */
DECL|method|message
specifier|private
specifier|static
name|void
name|message
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|infoStream
operator|.
name|println
argument_list|(
literal|"SIS ["
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"]: "
operator|+
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**    * Utility class for executing code that needs to do    * something with the current segments file.  This is    * necessary with lock-less commits because from the time    * you locate the current segments file name, until you    * actually open it, read its contents, or check modified    * time, etc., it could have been deleted due to a writer    * commit finishing.    */
DECL|class|FindSegmentsFile
specifier|public
specifier|abstract
specifier|static
class|class
name|FindSegmentsFile
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|directory
specifier|final
name|Directory
name|directory
decl_stmt|;
comment|/** Sole constructor. */
DECL|method|FindSegmentsFile
specifier|public
name|FindSegmentsFile
parameter_list|(
name|Directory
name|directory
parameter_list|)
block|{
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
block|}
comment|/** Locate the most recent {@code segments} file and      *  run {@link #doBody} on it. */
DECL|method|run
specifier|public
name|T
name|run
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|run
argument_list|(
literal|null
argument_list|)
return|;
block|}
comment|/** Run {@link #doBody} on the provided commit. */
DECL|method|run
specifier|public
name|T
name|run
parameter_list|(
name|IndexCommit
name|commit
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|commit
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|directory
operator|!=
name|commit
operator|.
name|getDirectory
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"the specified commit does not match the specified Directory"
argument_list|)
throw|;
return|return
name|doBody
argument_list|(
name|commit
operator|.
name|getSegmentsFileName
argument_list|()
argument_list|)
return|;
block|}
name|long
name|lastGen
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|gen
init|=
operator|-
literal|1
decl_stmt|;
name|IOException
name|exc
init|=
literal|null
decl_stmt|;
comment|// Loop until we succeed in calling doBody() without
comment|// hitting an IOException.  An IOException most likely
comment|// means an IW deleted our commit while opening
comment|// the time it took us to load the now-old infos files
comment|// (and segments files).  It's also possible it's a
comment|// true error (corrupt index).  To distinguish these,
comment|// on each retry we must see "forward progress" on
comment|// which generation we are trying to load.  If we
comment|// don't, then the original error is real and we throw
comment|// it.
for|for
control|(
init|;
condition|;
control|)
block|{
name|lastGen
operator|=
name|gen
expr_stmt|;
name|String
name|files
index|[]
init|=
name|directory
operator|.
name|listAll
argument_list|()
decl_stmt|;
name|String
name|files2
index|[]
init|=
name|directory
operator|.
name|listAll
argument_list|()
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|files
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|files2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|files
argument_list|,
name|files2
argument_list|)
condition|)
block|{
comment|// listAll() is weakly consistent, this means we hit "concurrent modification exception"
continue|continue;
block|}
name|gen
operator|=
name|getLastCommitGeneration
argument_list|(
name|files
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"directory listing gen="
operator|+
name|gen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gen
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IndexNotFoundException
argument_list|(
literal|"no segments* file found in "
operator|+
name|directory
operator|+
literal|": files: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|files
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|gen
operator|>
name|lastGen
condition|)
block|{
name|String
name|segmentFileName
init|=
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|gen
argument_list|)
decl_stmt|;
try|try
block|{
name|T
name|t
init|=
name|doBody
argument_list|(
name|segmentFileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"success on "
operator|+
name|segmentFileName
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|err
parameter_list|)
block|{
comment|// Save the original root cause:
if|if
condition|(
name|exc
operator|==
literal|null
condition|)
block|{
name|exc
operator|=
name|err
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"primary Exception on '"
operator|+
name|segmentFileName
operator|+
literal|"': "
operator|+
name|err
operator|+
literal|"'; will retry: gen = "
operator|+
name|gen
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
throw|throw
name|exc
throw|;
block|}
block|}
block|}
comment|/**      * Subclass must implement this.  The assumption is an      * IOException will be thrown if something goes wrong      * during the processing that could have been caused by      * a writer committing.      */
DECL|method|doBody
specifier|protected
specifier|abstract
name|T
name|doBody
parameter_list|(
name|String
name|segmentFileName
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
comment|// Carry over generation numbers from another SegmentInfos
DECL|method|updateGeneration
name|void
name|updateGeneration
parameter_list|(
name|SegmentInfos
name|other
parameter_list|)
block|{
name|lastGeneration
operator|=
name|other
operator|.
name|lastGeneration
expr_stmt|;
name|generation
operator|=
name|other
operator|.
name|generation
expr_stmt|;
block|}
DECL|method|setGeneration
name|void
name|setGeneration
parameter_list|(
name|long
name|generation
parameter_list|)
block|{
name|this
operator|.
name|generation
operator|=
name|generation
expr_stmt|;
name|this
operator|.
name|lastGeneration
operator|=
name|generation
expr_stmt|;
block|}
DECL|method|rollbackCommit
specifier|final
name|void
name|rollbackCommit
parameter_list|(
name|Directory
name|dir
parameter_list|)
block|{
if|if
condition|(
name|pendingCommit
condition|)
block|{
name|pendingCommit
operator|=
literal|false
expr_stmt|;
comment|// we try to clean up our pending_segments_N
comment|// Must carefully compute fileName from "generation"
comment|// since lastGeneration isn't incremented:
specifier|final
name|String
name|pending
init|=
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|PENDING_SEGMENTS
argument_list|,
literal|""
argument_list|,
name|generation
argument_list|)
decl_stmt|;
comment|// Suppress so we keep throwing the original exception
comment|// in our caller
name|IOUtils
operator|.
name|deleteFilesIgnoringExceptions
argument_list|(
name|dir
argument_list|,
name|pending
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Call this to start a commit.  This writes the new    *  segments file, but writes an invalid checksum at the    *  end, so that it is not visible to readers.  Once this    *  is called you must call {@link #finishCommit} to complete    *  the commit or {@link #rollbackCommit} to abort it.    *<p>    *  Note: {@link #changed()} should be called prior to this    *  method if changes have been made to this {@link SegmentInfos} instance    *</p>      **/
DECL|method|prepareCommit
specifier|final
name|void
name|prepareCommit
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pendingCommit
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"prepareCommit was already called"
argument_list|)
throw|;
block|}
name|write
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
comment|/** Returns all file names referenced by SegmentInfo.    *  The returned collection is recomputed on each    *  invocation.  */
DECL|method|files
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|files
parameter_list|(
name|boolean
name|includeSegmentsFile
parameter_list|)
throws|throws
name|IOException
block|{
name|HashSet
argument_list|<
name|String
argument_list|>
name|files
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|includeSegmentsFile
condition|)
block|{
specifier|final
name|String
name|segmentFileName
init|=
name|getSegmentsFileName
argument_list|()
decl_stmt|;
if|if
condition|(
name|segmentFileName
operator|!=
literal|null
condition|)
block|{
name|files
operator|.
name|add
argument_list|(
name|segmentFileName
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|size
init|=
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentCommitInfo
name|info
init|=
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|files
operator|.
name|addAll
argument_list|(
name|info
operator|.
name|files
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|files
return|;
block|}
comment|/** Returns the committed segments_N filename. */
DECL|method|finishCommit
specifier|final
name|String
name|finishCommit
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pendingCommit
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"prepareCommit was not called"
argument_list|)
throw|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
specifier|final
name|String
name|dest
decl_stmt|;
try|try
block|{
specifier|final
name|String
name|src
init|=
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|PENDING_SEGMENTS
argument_list|,
literal|""
argument_list|,
name|generation
argument_list|)
decl_stmt|;
name|dest
operator|=
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|generation
argument_list|)
expr_stmt|;
name|dir
operator|.
name|renameFile
argument_list|(
name|src
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// deletes pending_segments_N:
name|rollbackCommit
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
name|pendingCommit
operator|=
literal|false
expr_stmt|;
name|lastGeneration
operator|=
name|generation
expr_stmt|;
return|return
name|dest
return|;
block|}
comment|/** Writes and syncs to the Directory dir, taking care to    *  remove the segments file on exception    *<p>    *  Note: {@link #changed()} should be called prior to this    *  method if changes have been made to this {@link SegmentInfos} instance    *</p>      **/
DECL|method|commit
specifier|final
name|void
name|commit
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
name|prepareCommit
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|finishCommit
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
comment|/** Returns readable description of this segment. */
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|getSegmentsFileName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
specifier|final
name|int
name|count
init|=
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SegmentCommitInfo
name|info
init|=
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|info
operator|.
name|toString
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Return {@code userData} saved with this commit.    *     * @see IndexWriter#commit()    */
DECL|method|getUserData
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getUserData
parameter_list|()
block|{
return|return
name|userData
return|;
block|}
DECL|method|setUserData
name|void
name|setUserData
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|userData
operator|=
name|Collections
operator|.
expr|<
name|String
operator|,
name|String
operator|>
name|emptyMap
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|userData
operator|=
name|data
expr_stmt|;
block|}
block|}
comment|/** Replaces all segments in this instance, but keeps    *  generation, version, counter so that future commits    *  remain write once.    */
DECL|method|replace
name|void
name|replace
parameter_list|(
name|SegmentInfos
name|other
parameter_list|)
block|{
name|rollbackSegmentInfos
argument_list|(
name|other
operator|.
name|asList
argument_list|()
argument_list|)
expr_stmt|;
name|lastGeneration
operator|=
name|other
operator|.
name|lastGeneration
expr_stmt|;
block|}
comment|/** Returns sum of all segment's docCounts.  Note that    *  this does not include deletions */
DECL|method|totalDocCount
specifier|public
name|int
name|totalDocCount
parameter_list|()
block|{
name|long
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|this
control|)
block|{
name|count
operator|+=
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
expr_stmt|;
block|}
comment|// we should never hit this, checks should happen elsewhere...
assert|assert
name|count
operator|<=
name|IndexWriter
operator|.
name|getActualMaxDocs
argument_list|()
assert|;
return|return
name|Math
operator|.
name|toIntExact
argument_list|(
name|count
argument_list|)
return|;
block|}
comment|/** Call this before committing if changes have been made to the    *  segments. */
DECL|method|changed
specifier|public
name|void
name|changed
parameter_list|()
block|{
name|version
operator|++
expr_stmt|;
block|}
comment|/** applies all changes caused by committing a merge to this SegmentInfos */
DECL|method|applyMergeChanges
name|void
name|applyMergeChanges
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|,
name|boolean
name|dropSegment
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|mergedAway
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
decl_stmt|;
name|boolean
name|inserted
init|=
literal|false
decl_stmt|;
name|int
name|newSegIdx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|segIdx
init|=
literal|0
init|,
name|cnt
init|=
name|segments
operator|.
name|size
argument_list|()
init|;
name|segIdx
operator|<
name|cnt
condition|;
name|segIdx
operator|++
control|)
block|{
assert|assert
name|segIdx
operator|>=
name|newSegIdx
assert|;
specifier|final
name|SegmentCommitInfo
name|info
init|=
name|segments
operator|.
name|get
argument_list|(
name|segIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergedAway
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inserted
operator|&&
operator|!
name|dropSegment
condition|)
block|{
name|segments
operator|.
name|set
argument_list|(
name|segIdx
argument_list|,
name|merge
operator|.
name|info
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|true
expr_stmt|;
name|newSegIdx
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|segments
operator|.
name|set
argument_list|(
name|newSegIdx
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|newSegIdx
operator|++
expr_stmt|;
block|}
block|}
comment|// the rest of the segments in list are duplicates, so don't remove from map, only list!
name|segments
operator|.
name|subList
argument_list|(
name|newSegIdx
argument_list|,
name|segments
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Either we found place to insert segment, or, we did
comment|// not, but only because all segments we merged becamee
comment|// deleted while we are merging, in which case it should
comment|// be the case that the new segment is also all deleted,
comment|// we insert it at the beginning if it should not be dropped:
if|if
condition|(
operator|!
name|inserted
operator|&&
operator|!
name|dropSegment
condition|)
block|{
name|segments
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|merge
operator|.
name|info
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|createBackupSegmentInfos
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|createBackupSegmentInfos
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|SegmentCommitInfo
name|info
range|:
name|this
control|)
block|{
assert|assert
name|info
operator|.
name|info
operator|.
name|getCodec
argument_list|()
operator|!=
literal|null
assert|;
name|list
operator|.
name|add
argument_list|(
name|info
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
DECL|method|rollbackSegmentInfos
name|void
name|rollbackSegmentInfos
parameter_list|(
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|infos
parameter_list|)
block|{
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|addAll
argument_list|(
name|infos
argument_list|)
expr_stmt|;
block|}
comment|/** Returns an<b>unmodifiable</b> {@link Iterator} of contained segments in order. */
comment|// @Override (comment out until Java 6)
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|asList
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/** Returns all contained segments as an<b>unmodifiable</b> {@link List} view. */
DECL|method|asList
specifier|public
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|asList
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|segments
argument_list|)
return|;
block|}
comment|/** Returns number of {@link SegmentCommitInfo}s. */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|segments
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** Appends the provided {@link SegmentCommitInfo}. */
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|SegmentCommitInfo
name|si
parameter_list|)
block|{
name|segments
operator|.
name|add
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
comment|/** Appends the provided {@link SegmentCommitInfo}s. */
DECL|method|addAll
specifier|public
name|void
name|addAll
parameter_list|(
name|Iterable
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|sis
parameter_list|)
block|{
for|for
control|(
specifier|final
name|SegmentCommitInfo
name|si
range|:
name|sis
control|)
block|{
name|this
operator|.
name|add
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Clear all {@link SegmentCommitInfo}s. */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|segments
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/** Remove the provided {@link SegmentCommitInfo}.    *    *<p><b>WARNING</b>: O(N) cost */
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|(
name|SegmentCommitInfo
name|si
parameter_list|)
block|{
name|segments
operator|.
name|remove
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
comment|/** Remove the {@link SegmentCommitInfo} at the    * provided index.    *    *<p><b>WARNING</b>: O(N) cost */
DECL|method|remove
name|void
name|remove
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|segments
operator|.
name|remove
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
comment|/** Return true if the provided {@link    *  SegmentCommitInfo} is contained.    *    *<p><b>WARNING</b>: O(N) cost */
DECL|method|contains
name|boolean
name|contains
parameter_list|(
name|SegmentCommitInfo
name|si
parameter_list|)
block|{
return|return
name|segments
operator|.
name|contains
argument_list|(
name|si
argument_list|)
return|;
block|}
comment|/** Returns index of the provided {@link    *  SegmentCommitInfo}.    *    *<p><b>WARNING</b>: O(N) cost */
DECL|method|indexOf
name|int
name|indexOf
parameter_list|(
name|SegmentCommitInfo
name|si
parameter_list|)
block|{
return|return
name|segments
operator|.
name|indexOf
argument_list|(
name|si
argument_list|)
return|;
block|}
block|}
end_class
end_unit
