begin_unit
begin_package
DECL|package|org.apache.lucene.index
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|NoSuchFileException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|Codec
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|DocValuesFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|FieldInfosFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|LiveDocsFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ChecksumIndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import
begin_comment
comment|/**  * A collection of segmentInfo objects with methods for operating on those  * segments in relation to the file system.  *<p>  * The active segments in the index are stored in the segment info file,  *<tt>segments_N</tt>. There may be one or more<tt>segments_N</tt> files in  * the index; however, the one with the largest generation is the active one  * (when older segments_N files are present it's because they temporarily cannot  * be deleted, or a custom {@link IndexDeletionPolicy} is in  * use). This file lists each segment by name and has details about the codec  * and generation of deletes.  *</p>  *<p>  * Files:  *<ul>  *<li><tt>segments_N</tt>: Header, Version, NameCounter, SegCount,&lt;SegName,  * SegCodec, DelGen, DeletionCount, FieldInfosGen, DocValuesGen,  * UpdatesFiles&gt;<sup>SegCount</sup>, CommitUserData, Footer  *</ul>  *</p>  * Data types:  *<p>  *<ul>  *<li>Header --&gt; {@link CodecUtil#writeHeader CodecHeader}</li>  *<li>GenHeader, NameCounter, SegCount, DeletionCount --&gt;  * {@link DataOutput#writeInt Int32}</li>  *<li>Generation, Version, DelGen, Checksum, FieldInfosGen, DocValuesGen --&gt;  * {@link DataOutput#writeLong Int64}</li>  *<li>SegName, SegCodec --&gt; {@link DataOutput#writeString String}</li>  *<li>CommitUserData --&gt; {@link DataOutput#writeStringStringMap  * Map&lt;String,String&gt;}</li>  *<li>UpdatesFiles --&gt; Map&lt;{@link DataOutput#writeInt Int32},  * {@link DataOutput#writeStringSet(Set) Set&lt;String&gt;}&gt;</li>  *<li>Footer --&gt; {@link CodecUtil#writeFooter CodecFooter}</li>  *</ul>  *</p>  * Field Descriptions:  *<p>  *<ul>  *<li>Version counts how often the index has been changed by adding or deleting  * documents.</li>  *<li>NameCounter is used to generate names for new segment files.</li>  *<li>SegName is the name of the segment, and is used as the file name prefix  * for all of the files that compose the segment's index.</li>  *<li>DelGen is the generation count of the deletes file. If this is -1, there  * are no deletes. Anything above zero means there are deletes stored by  * {@link LiveDocsFormat}.</li>  *<li>DeletionCount records the number of deleted documents in this segment.</li>  *<li>SegCodec is the {@link Codec#getName() name} of the Codec that encoded  * this segment.</li>  *<li>CommitUserData stores an optional user-supplied opaque  * Map&lt;String,String&gt; that was passed to  * {@link IndexWriter#setCommitData(java.util.Map)}.</li>  *<li>FieldInfosGen is the generation count of the fieldInfos file. If this is  * -1, there are no updates to the fieldInfos in that segment. Anything above  * zero means there are updates to fieldInfos stored by {@link FieldInfosFormat}  * .</li>  *<li>DocValuesGen is the generation count of the updatable DocValues. If this  * is -1, there are no updates to DocValues in that segment. Anything above zero  * means there are updates to DocValues stored by {@link DocValuesFormat}.</li>  *<li>UpdatesFiles stores the set of files that were updated in that segment  * per field.</li>  *</ul>  *</p>  *   * @lucene.experimental  */
end_comment
begin_class
DECL|class|SegmentInfos
specifier|public
specifier|final
class|class
name|SegmentInfos
implements|implements
name|Cloneable
implements|,
name|Iterable
argument_list|<
name|SegmentCommitInfo
argument_list|>
block|{
comment|/** The file format version for the segments_N codec header, up to 4.5. */
DECL|field|VERSION_40
specifier|public
specifier|static
specifier|final
name|int
name|VERSION_40
init|=
literal|0
decl_stmt|;
comment|/** The file format version for the segments_N codec header, since 4.6+. */
DECL|field|VERSION_46
specifier|public
specifier|static
specifier|final
name|int
name|VERSION_46
init|=
literal|1
decl_stmt|;
comment|/** The file format version for the segments_N codec header, since 4.8+ */
DECL|field|VERSION_48
specifier|public
specifier|static
specifier|final
name|int
name|VERSION_48
init|=
literal|2
decl_stmt|;
comment|/** The file format version for the segments_N codec header, since 4.9+ */
DECL|field|VERSION_49
specifier|public
specifier|static
specifier|final
name|int
name|VERSION_49
init|=
literal|3
decl_stmt|;
comment|/** The file format version for the segments_N codec header, since 4.11+ */
DECL|field|VERSION_411
specifier|public
specifier|static
specifier|final
name|int
name|VERSION_411
init|=
literal|4
decl_stmt|;
comment|/** Used to name new segments. */
comment|// TODO: should this be a long ...?
DECL|field|counter
specifier|public
name|int
name|counter
decl_stmt|;
comment|/** Counts how often the index has been changed.  */
DECL|field|version
specifier|public
name|long
name|version
decl_stmt|;
DECL|field|generation
specifier|private
name|long
name|generation
decl_stmt|;
comment|// generation of the "segments_N" for the next commit
DECL|field|lastGeneration
specifier|private
name|long
name|lastGeneration
decl_stmt|;
comment|// generation of the "segments_N" file we last successfully read
comment|// or wrote; this is normally the same as generation except if
comment|// there was an IOException that had interrupted a commit
comment|/** Opaque Map&lt;String, String&gt; that user can specify during IndexWriter.commit */
DECL|field|userData
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|userData
init|=
name|Collections
operator|.
name|emptyMap
argument_list|()
decl_stmt|;
DECL|field|segments
specifier|private
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|segments
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * If non-null, information about loading segments_N files    * will be printed here.  @see #setInfoStream.    */
DECL|field|infoStream
specifier|private
specifier|static
name|PrintStream
name|infoStream
init|=
literal|null
decl_stmt|;
comment|/** Id for this commit; only written starting with Lucene 4.11 */
DECL|field|id
specifier|private
name|String
name|id
decl_stmt|;
comment|/** Sole constructor. Typically you call this and then    *  use {@link #read(Directory) or    *  #read(Directory,String)} to populate each {@link    *  SegmentCommitInfo}.  Alternatively, you can add/remove your    *  own {@link SegmentCommitInfo}s. */
DECL|method|SegmentInfos
specifier|public
name|SegmentInfos
parameter_list|()
block|{   }
comment|/** Returns {@link SegmentCommitInfo} at the provided    *  index. */
DECL|method|info
specifier|public
name|SegmentCommitInfo
name|info
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|segments
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/**    * Get the generation of the most recent commit to the    * list of index files (N in the segments_N file).    *    * @param files -- array of file names to check    */
DECL|method|getLastCommitGeneration
specifier|public
specifier|static
name|long
name|getLastCommitGeneration
parameter_list|(
name|String
index|[]
name|files
parameter_list|)
block|{
name|long
name|max
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|files
control|)
block|{
if|if
condition|(
name|file
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|)
operator|&&
operator|!
name|file
operator|.
name|equals
argument_list|(
name|IndexFileNames
operator|.
name|OLD_SEGMENTS_GEN
argument_list|)
condition|)
block|{
name|long
name|gen
init|=
name|generationFromSegmentsFileName
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|gen
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|gen
expr_stmt|;
block|}
block|}
block|}
return|return
name|max
return|;
block|}
comment|/**    * Get the generation of the most recent commit to the    * index in this directory (N in the segments_N file).    *    * @param directory -- directory to search for the latest segments_N file    */
DECL|method|getLastCommitGeneration
specifier|public
specifier|static
name|long
name|getLastCommitGeneration
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getLastCommitGeneration
argument_list|(
name|directory
operator|.
name|listAll
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get the filename of the segments_N file for the most    * recent commit in the list of index files.    *    * @param files -- array of file names to check    */
DECL|method|getLastCommitSegmentsFileName
specifier|public
specifier|static
name|String
name|getLastCommitSegmentsFileName
parameter_list|(
name|String
index|[]
name|files
parameter_list|)
block|{
return|return
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|getLastCommitGeneration
argument_list|(
name|files
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the filename of the segments_N file for the most    * recent commit to the index in this Directory.    *    * @param directory -- directory to search for the latest segments_N file    */
DECL|method|getLastCommitSegmentsFileName
specifier|public
specifier|static
name|String
name|getLastCommitSegmentsFileName
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|getLastCommitGeneration
argument_list|(
name|directory
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the segments_N filename in use by this segment infos.    */
DECL|method|getSegmentsFileName
specifier|public
name|String
name|getSegmentsFileName
parameter_list|()
block|{
return|return
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|lastGeneration
argument_list|)
return|;
block|}
comment|/**    * Parse the generation off the segments file name and    * return it.    */
DECL|method|generationFromSegmentsFileName
specifier|public
specifier|static
name|long
name|generationFromSegmentsFileName
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
if|if
condition|(
name|fileName
operator|.
name|equals
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fileName
operator|.
name|startsWith
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|)
condition|)
block|{
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|fileName
operator|.
name|substring
argument_list|(
literal|1
operator|+
name|IndexFileNames
operator|.
name|SEGMENTS
operator|.
name|length
argument_list|()
argument_list|)
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"fileName \""
operator|+
name|fileName
operator|+
literal|"\" is not a segments file"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the next pending_segments_N filename that will be written.    */
DECL|method|getNextPendingSegmentFileName
specifier|public
name|String
name|getNextPendingSegmentFileName
parameter_list|()
block|{
name|long
name|nextGeneration
decl_stmt|;
if|if
condition|(
name|generation
operator|==
operator|-
literal|1
condition|)
block|{
name|nextGeneration
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nextGeneration
operator|=
name|generation
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|PENDING_SEGMENTS
argument_list|,
literal|""
argument_list|,
name|nextGeneration
argument_list|)
return|;
block|}
comment|/** Since Lucene 4.11, every commit (segments_N) writes a unique id.  This will    *  return that id, or null if this commit was pre-4.11. */
DECL|method|getId
specifier|public
name|String
name|getId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
comment|/**    * Read a particular segmentFileName.  Note that this may    * throw an IOException if a commit is in process.    *    * @param directory -- directory containing the segments file    * @param segmentFileName -- segment file to load    * @throws CorruptIndexException if the index is corrupt    * @throws IOException if there is a low-level IO error    */
DECL|method|read
specifier|public
specifier|final
name|void
name|read
parameter_list|(
name|Directory
name|directory
parameter_list|,
name|String
name|segmentFileName
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
comment|// Clear any previous segments:
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
name|generation
operator|=
name|generationFromSegmentsFileName
argument_list|(
name|segmentFileName
argument_list|)
expr_stmt|;
name|lastGeneration
operator|=
name|generation
expr_stmt|;
name|ChecksumIndexInput
name|input
init|=
name|directory
operator|.
name|openChecksumInput
argument_list|(
name|segmentFileName
argument_list|,
name|IOContext
operator|.
name|READ
argument_list|)
decl_stmt|;
try|try
block|{
comment|// NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need
comment|// to read the magic ourselves.
name|int
name|magic
init|=
name|input
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|magic
operator|!=
name|CodecUtil
operator|.
name|CODEC_MAGIC
condition|)
block|{
throw|throw
operator|new
name|IndexFormatTooOldException
argument_list|(
name|input
argument_list|,
name|magic
argument_list|,
name|CodecUtil
operator|.
name|CODEC_MAGIC
argument_list|,
name|CodecUtil
operator|.
name|CODEC_MAGIC
argument_list|)
throw|;
block|}
comment|// 4.0+
name|int
name|format
init|=
name|CodecUtil
operator|.
name|checkHeaderNoMagic
argument_list|(
name|input
argument_list|,
literal|"segments"
argument_list|,
name|VERSION_40
argument_list|,
name|VERSION_411
argument_list|)
decl_stmt|;
name|version
operator|=
name|input
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|counter
operator|=
name|input
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|int
name|numSegments
init|=
name|input
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|numSegments
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|CorruptIndexException
argument_list|(
literal|"invalid segment count: "
operator|+
name|numSegments
operator|+
literal|" (resource: "
operator|+
name|input
operator|+
literal|")"
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|seg
init|=
literal|0
init|;
name|seg
operator|<
name|numSegments
condition|;
name|seg
operator|++
control|)
block|{
name|String
name|segName
init|=
name|input
operator|.
name|readString
argument_list|()
decl_stmt|;
name|Codec
name|codec
init|=
name|Codec
operator|.
name|forName
argument_list|(
name|input
operator|.
name|readString
argument_list|()
argument_list|)
decl_stmt|;
comment|//System.out.println("SIS.read seg=" + seg + " codec=" + codec);
name|SegmentInfo
name|info
init|=
name|codec
operator|.
name|segmentInfoFormat
argument_list|()
operator|.
name|getSegmentInfoReader
argument_list|()
operator|.
name|read
argument_list|(
name|directory
argument_list|,
name|segName
argument_list|,
name|IOContext
operator|.
name|READ
argument_list|)
decl_stmt|;
name|info
operator|.
name|setCodec
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|long
name|delGen
init|=
name|input
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|int
name|delCount
init|=
name|input
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|delCount
argument_list|<
literal|0
operator|||
name|delCount
argument_list|>
name|info
operator|.
name|getDocCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|CorruptIndexException
argument_list|(
literal|"invalid deletion count: "
operator|+
name|delCount
operator|+
literal|" vs docCount="
operator|+
name|info
operator|.
name|getDocCount
argument_list|()
operator|+
literal|" (resource: "
operator|+
name|input
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|long
name|fieldInfosGen
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|format
operator|>=
name|VERSION_46
condition|)
block|{
name|fieldInfosGen
operator|=
name|input
operator|.
name|readLong
argument_list|()
expr_stmt|;
block|}
name|long
name|dvGen
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|format
operator|>=
name|VERSION_49
condition|)
block|{
name|dvGen
operator|=
name|input
operator|.
name|readLong
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dvGen
operator|=
name|fieldInfosGen
expr_stmt|;
block|}
name|SegmentCommitInfo
name|siPerCommit
init|=
operator|new
name|SegmentCommitInfo
argument_list|(
name|info
argument_list|,
name|delCount
argument_list|,
name|delGen
argument_list|,
name|fieldInfosGen
argument_list|,
name|dvGen
argument_list|)
decl_stmt|;
if|if
condition|(
name|format
operator|>=
name|VERSION_46
condition|)
block|{
if|if
condition|(
name|format
operator|<
name|VERSION_49
condition|)
block|{
comment|// Recorded per-generation files, which were buggy (see
comment|// LUCENE-5636). We need to read and keep them so we continue to
comment|// reference those files. Unfortunately it means that the files will
comment|// be referenced even if the fields are updated again, until the
comment|// segment is merged.
specifier|final
name|int
name|numGensUpdatesFiles
init|=
name|input
operator|.
name|readInt
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Long
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|genUpdatesFiles
decl_stmt|;
if|if
condition|(
name|numGensUpdatesFiles
operator|==
literal|0
condition|)
block|{
name|genUpdatesFiles
operator|=
name|Collections
operator|.
name|emptyMap
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|genUpdatesFiles
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|numGensUpdatesFiles
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numGensUpdatesFiles
condition|;
name|i
operator|++
control|)
block|{
name|genUpdatesFiles
operator|.
name|put
argument_list|(
name|input
operator|.
name|readLong
argument_list|()
argument_list|,
name|input
operator|.
name|readStringSet
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|siPerCommit
operator|.
name|setGenUpdatesFiles
argument_list|(
name|genUpdatesFiles
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|siPerCommit
operator|.
name|setFieldInfosFiles
argument_list|(
name|input
operator|.
name|readStringSet
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|dvUpdateFiles
decl_stmt|;
specifier|final
name|int
name|numDVFields
init|=
name|input
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|numDVFields
operator|==
literal|0
condition|)
block|{
name|dvUpdateFiles
operator|=
name|Collections
operator|.
name|emptyMap
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dvUpdateFiles
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|numDVFields
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numDVFields
condition|;
name|i
operator|++
control|)
block|{
name|dvUpdateFiles
operator|.
name|put
argument_list|(
name|input
operator|.
name|readInt
argument_list|()
argument_list|,
name|input
operator|.
name|readStringSet
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|siPerCommit
operator|.
name|setDocValuesUpdatesFiles
argument_list|(
name|dvUpdateFiles
argument_list|)
expr_stmt|;
block|}
block|}
name|add
argument_list|(
name|siPerCommit
argument_list|)
expr_stmt|;
block|}
name|userData
operator|=
name|input
operator|.
name|readStringStringMap
argument_list|()
expr_stmt|;
if|if
condition|(
name|format
operator|>=
name|VERSION_411
condition|)
block|{
name|id
operator|=
name|input
operator|.
name|readString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|>=
name|VERSION_48
condition|)
block|{
name|CodecUtil
operator|.
name|checkFooter
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|long
name|checksumNow
init|=
name|input
operator|.
name|getChecksum
argument_list|()
decl_stmt|;
specifier|final
name|long
name|checksumThen
init|=
name|input
operator|.
name|readLong
argument_list|()
decl_stmt|;
if|if
condition|(
name|checksumNow
operator|!=
name|checksumThen
condition|)
block|{
throw|throw
operator|new
name|CorruptIndexException
argument_list|(
literal|"checksum mismatch in segments file (resource: "
operator|+
name|input
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|CodecUtil
operator|.
name|checkEOF
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// Clear any segment infos we had loaded so we
comment|// have a clean slate on retry:
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Find the latest commit ({@code segments_N file}) and    *  load all {@link SegmentCommitInfo}s. */
DECL|method|read
specifier|public
specifier|final
name|void
name|read
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
name|generation
operator|=
name|lastGeneration
operator|=
operator|-
literal|1
expr_stmt|;
operator|new
name|FindSegmentsFile
argument_list|(
name|directory
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|Object
name|doBody
parameter_list|(
name|String
name|segmentFileName
parameter_list|)
throws|throws
name|IOException
block|{
name|read
argument_list|(
name|directory
argument_list|,
name|segmentFileName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
comment|// Only true after prepareCommit has been called and
comment|// before finishCommit is called
DECL|field|pendingCommit
name|boolean
name|pendingCommit
decl_stmt|;
DECL|method|write
specifier|private
name|void
name|write
parameter_list|(
name|Directory
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|segmentFileName
init|=
name|getNextPendingSegmentFileName
argument_list|()
decl_stmt|;
comment|// Always advance the generation on write:
if|if
condition|(
name|generation
operator|==
operator|-
literal|1
condition|)
block|{
name|generation
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|generation
operator|++
expr_stmt|;
block|}
name|IndexOutput
name|segnOutput
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|segnOutput
operator|=
name|directory
operator|.
name|createOutput
argument_list|(
name|segmentFileName
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|writeHeader
argument_list|(
name|segnOutput
argument_list|,
literal|"segments"
argument_list|,
name|VERSION_411
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeLong
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeInt
argument_list|(
name|counter
argument_list|)
expr_stmt|;
comment|// write counter
name|segnOutput
operator|.
name|writeInt
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// write infos
for|for
control|(
name|SegmentCommitInfo
name|siPerCommit
range|:
name|this
control|)
block|{
name|SegmentInfo
name|si
init|=
name|siPerCommit
operator|.
name|info
decl_stmt|;
name|segnOutput
operator|.
name|writeString
argument_list|(
name|si
operator|.
name|name
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeString
argument_list|(
name|si
operator|.
name|getCodec
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeLong
argument_list|(
name|siPerCommit
operator|.
name|getDelGen
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|delCount
init|=
name|siPerCommit
operator|.
name|getDelCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|delCount
argument_list|<
literal|0
operator|||
name|delCount
argument_list|>
name|si
operator|.
name|getDocCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"cannot write segment: invalid docCount segment="
operator|+
name|si
operator|.
name|name
operator|+
literal|" docCount="
operator|+
name|si
operator|.
name|getDocCount
argument_list|()
operator|+
literal|" delCount="
operator|+
name|delCount
argument_list|)
throw|;
block|}
name|segnOutput
operator|.
name|writeInt
argument_list|(
name|delCount
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeLong
argument_list|(
name|siPerCommit
operator|.
name|getFieldInfosGen
argument_list|()
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeLong
argument_list|(
name|siPerCommit
operator|.
name|getDocValuesGen
argument_list|()
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeStringSet
argument_list|(
name|siPerCommit
operator|.
name|getFieldInfosFiles
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|dvUpdatesFiles
init|=
name|siPerCommit
operator|.
name|getDocValuesUpdatesFiles
argument_list|()
decl_stmt|;
name|segnOutput
operator|.
name|writeInt
argument_list|(
name|dvUpdatesFiles
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|e
range|:
name|dvUpdatesFiles
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|segnOutput
operator|.
name|writeInt
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeStringSet
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|si
operator|.
name|dir
operator|==
name|directory
assert|;
block|}
name|segnOutput
operator|.
name|writeStringStringMap
argument_list|(
name|userData
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|writeString
argument_list|(
name|StringHelper
operator|.
name|randomId
argument_list|()
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|writeFooter
argument_list|(
name|segnOutput
argument_list|)
expr_stmt|;
name|segnOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|directory
operator|.
name|sync
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|segmentFileName
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|pendingCommit
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// We hit an exception above; try to close the file
comment|// but suppress any exception:
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|segnOutput
argument_list|)
expr_stmt|;
comment|// Try not to leave a truncated segments_N file in
comment|// the index:
name|IOUtils
operator|.
name|deleteFilesIgnoringExceptions
argument_list|(
name|directory
argument_list|,
name|segmentFileName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns a copy of this instance, also copying each    * SegmentInfo.    */
annotation|@
name|Override
DECL|method|clone
specifier|public
name|SegmentInfos
name|clone
parameter_list|()
block|{
try|try
block|{
specifier|final
name|SegmentInfos
name|sis
init|=
operator|(
name|SegmentInfos
operator|)
name|super
operator|.
name|clone
argument_list|()
decl_stmt|;
comment|// deep clone, first recreate all collections:
name|sis
operator|.
name|segments
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|SegmentCommitInfo
name|info
range|:
name|this
control|)
block|{
assert|assert
name|info
operator|.
name|info
operator|.
name|getCodec
argument_list|()
operator|!=
literal|null
assert|;
comment|// dont directly access segments, use add method!!!
name|sis
operator|.
name|add
argument_list|(
name|info
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sis
operator|.
name|userData
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|userData
argument_list|)
expr_stmt|;
return|return
name|sis
return|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"should not happen"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * version number when this SegmentInfos was generated.    */
DECL|method|getVersion
specifier|public
name|long
name|getVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
comment|/** Returns current generation. */
DECL|method|getGeneration
specifier|public
name|long
name|getGeneration
parameter_list|()
block|{
return|return
name|generation
return|;
block|}
comment|/** Returns last succesfully read or written generation. */
DECL|method|getLastGeneration
specifier|public
name|long
name|getLastGeneration
parameter_list|()
block|{
return|return
name|lastGeneration
return|;
block|}
comment|/** If non-null, information about retries when loading    * the segments file will be printed to this.    */
DECL|method|setInfoStream
specifier|public
specifier|static
name|void
name|setInfoStream
parameter_list|(
name|PrintStream
name|infoStream
parameter_list|)
block|{
name|SegmentInfos
operator|.
name|infoStream
operator|=
name|infoStream
expr_stmt|;
block|}
comment|/**    * Returns {@code infoStream}.    *    * @see #setInfoStream    */
DECL|method|getInfoStream
specifier|public
specifier|static
name|PrintStream
name|getInfoStream
parameter_list|()
block|{
return|return
name|infoStream
return|;
block|}
comment|/**    * Prints the given message to the infoStream. Note, this method does not    * check for null infoStream. It assumes this check has been performed by the    * caller, which is recommended to avoid the (usually) expensive message    * creation.    */
DECL|method|message
specifier|private
specifier|static
name|void
name|message
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|infoStream
operator|.
name|println
argument_list|(
literal|"SIS ["
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"]: "
operator|+
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**    * Utility class for executing code that needs to do    * something with the current segments file.  This is    * necessary with lock-less commits because from the time    * you locate the current segments file name, until you    * actually open it, read its contents, or check modified    * time, etc., it could have been deleted due to a writer    * commit finishing.    */
DECL|class|FindSegmentsFile
specifier|public
specifier|abstract
specifier|static
class|class
name|FindSegmentsFile
block|{
DECL|field|directory
specifier|final
name|Directory
name|directory
decl_stmt|;
comment|/** Sole constructor. */
DECL|method|FindSegmentsFile
specifier|public
name|FindSegmentsFile
parameter_list|(
name|Directory
name|directory
parameter_list|)
block|{
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
block|}
comment|/** Locate the most recent {@code segments} file and      *  run {@link #doBody} on it. */
DECL|method|run
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|run
argument_list|(
literal|null
argument_list|)
return|;
block|}
comment|/** Run {@link #doBody} on the provided commit. */
DECL|method|run
specifier|public
name|Object
name|run
parameter_list|(
name|IndexCommit
name|commit
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|commit
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|directory
operator|!=
name|commit
operator|.
name|getDirectory
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"the specified commit does not match the specified Directory"
argument_list|)
throw|;
return|return
name|doBody
argument_list|(
name|commit
operator|.
name|getSegmentsFileName
argument_list|()
argument_list|)
return|;
block|}
name|long
name|lastGen
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|gen
init|=
operator|-
literal|1
decl_stmt|;
name|IOException
name|exc
init|=
literal|null
decl_stmt|;
comment|// Loop until we succeed in calling doBody() without
comment|// hitting an IOException.  An IOException most likely
comment|// means an IW deleted our commit while opening
comment|// the time it took us to load the now-old infos files
comment|// (and segments files).  It's also possible it's a
comment|// true error (corrupt index).  To distinguish these,
comment|// on each retry we must see "forward progress" on
comment|// which generation we are trying to load.  If we
comment|// don't, then the original error is real and we throw
comment|// it.
for|for
control|(
init|;
condition|;
control|)
block|{
name|lastGen
operator|=
name|gen
expr_stmt|;
name|String
name|files
index|[]
init|=
name|directory
operator|.
name|listAll
argument_list|()
decl_stmt|;
name|String
name|files2
index|[]
init|=
name|directory
operator|.
name|listAll
argument_list|()
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|files
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|files2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|files
argument_list|,
name|files2
argument_list|)
condition|)
block|{
comment|// listAll() is weakly consistent, this means we hit "concurrent modification exception"
continue|continue;
block|}
name|gen
operator|=
name|getLastCommitGeneration
argument_list|(
name|files
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"directory listing gen="
operator|+
name|gen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gen
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IndexNotFoundException
argument_list|(
literal|"no segments* file found in "
operator|+
name|directory
operator|+
literal|": files: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|files
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|gen
operator|>
name|lastGen
condition|)
block|{
name|String
name|segmentFileName
init|=
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|gen
argument_list|)
decl_stmt|;
try|try
block|{
name|Object
name|v
init|=
name|doBody
argument_list|(
name|segmentFileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"success on "
operator|+
name|segmentFileName
argument_list|)
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|err
parameter_list|)
block|{
comment|// Save the original root cause:
if|if
condition|(
name|exc
operator|==
literal|null
condition|)
block|{
name|exc
operator|=
name|err
expr_stmt|;
block|}
if|if
condition|(
name|infoStream
operator|!=
literal|null
condition|)
block|{
name|message
argument_list|(
literal|"primary Exception on '"
operator|+
name|segmentFileName
operator|+
literal|"': "
operator|+
name|err
operator|+
literal|"'; will retry: gen = "
operator|+
name|gen
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
throw|throw
name|exc
throw|;
block|}
block|}
block|}
comment|/**      * Subclass must implement this.  The assumption is an      * IOException will be thrown if something goes wrong      * during the processing that could have been caused by      * a writer committing.      */
DECL|method|doBody
specifier|protected
specifier|abstract
name|Object
name|doBody
parameter_list|(
name|String
name|segmentFileName
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
comment|// Carry over generation numbers from another SegmentInfos
DECL|method|updateGeneration
name|void
name|updateGeneration
parameter_list|(
name|SegmentInfos
name|other
parameter_list|)
block|{
name|lastGeneration
operator|=
name|other
operator|.
name|lastGeneration
expr_stmt|;
name|generation
operator|=
name|other
operator|.
name|generation
expr_stmt|;
block|}
DECL|method|setGeneration
name|void
name|setGeneration
parameter_list|(
name|long
name|generation
parameter_list|)
block|{
name|this
operator|.
name|generation
operator|=
name|generation
expr_stmt|;
name|this
operator|.
name|lastGeneration
operator|=
name|generation
expr_stmt|;
block|}
DECL|method|rollbackCommit
specifier|final
name|void
name|rollbackCommit
parameter_list|(
name|Directory
name|dir
parameter_list|)
block|{
if|if
condition|(
name|pendingCommit
condition|)
block|{
name|pendingCommit
operator|=
literal|false
expr_stmt|;
comment|// we try to clean up our pending_segments_N
comment|// Must carefully compute fileName from "generation"
comment|// since lastGeneration isn't incremented:
specifier|final
name|String
name|pending
init|=
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|PENDING_SEGMENTS
argument_list|,
literal|""
argument_list|,
name|generation
argument_list|)
decl_stmt|;
comment|// Suppress so we keep throwing the original exception
comment|// in our caller
name|IOUtils
operator|.
name|deleteFilesIgnoringExceptions
argument_list|(
name|dir
argument_list|,
name|pending
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Call this to start a commit.  This writes the new    *  segments file, but writes an invalid checksum at the    *  end, so that it is not visible to readers.  Once this    *  is called you must call {@link #finishCommit} to complete    *  the commit or {@link #rollbackCommit} to abort it.    *<p>    *  Note: {@link #changed()} should be called prior to this    *  method if changes have been made to this {@link SegmentInfos} instance    *</p>      **/
DECL|method|prepareCommit
specifier|final
name|void
name|prepareCommit
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pendingCommit
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"prepareCommit was already called"
argument_list|)
throw|;
block|}
name|write
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
comment|/** Returns all file names referenced by SegmentInfo    *  instances matching the provided Directory (ie files    *  associated with any "external" segments are skipped).    *  The returned collection is recomputed on each    *  invocation.  */
DECL|method|files
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|files
parameter_list|(
name|Directory
name|dir
parameter_list|,
name|boolean
name|includeSegmentsFile
parameter_list|)
throws|throws
name|IOException
block|{
name|HashSet
argument_list|<
name|String
argument_list|>
name|files
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|includeSegmentsFile
condition|)
block|{
specifier|final
name|String
name|segmentFileName
init|=
name|getSegmentsFileName
argument_list|()
decl_stmt|;
if|if
condition|(
name|segmentFileName
operator|!=
literal|null
condition|)
block|{
name|files
operator|.
name|add
argument_list|(
name|segmentFileName
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|size
init|=
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SegmentCommitInfo
name|info
init|=
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
assert|assert
name|info
operator|.
name|info
operator|.
name|dir
operator|==
name|dir
assert|;
if|if
condition|(
name|info
operator|.
name|info
operator|.
name|dir
operator|==
name|dir
condition|)
block|{
name|files
operator|.
name|addAll
argument_list|(
name|info
operator|.
name|files
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|files
return|;
block|}
DECL|method|finishCommit
specifier|final
name|void
name|finishCommit
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pendingCommit
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"prepareCommit was not called"
argument_list|)
throw|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
specifier|final
name|String
name|src
init|=
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|PENDING_SEGMENTS
argument_list|,
literal|""
argument_list|,
name|generation
argument_list|)
decl_stmt|;
specifier|final
name|String
name|dest
init|=
name|IndexFileNames
operator|.
name|fileNameFromGeneration
argument_list|(
name|IndexFileNames
operator|.
name|SEGMENTS
argument_list|,
literal|""
argument_list|,
name|generation
argument_list|)
decl_stmt|;
name|dir
operator|.
name|renameFile
argument_list|(
name|src
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// deletes pending_segments_N:
name|rollbackCommit
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
name|pendingCommit
operator|=
literal|false
expr_stmt|;
name|lastGeneration
operator|=
name|generation
expr_stmt|;
block|}
comment|/** Writes& syncs to the Directory dir, taking care to    *  remove the segments file on exception    *<p>    *  Note: {@link #changed()} should be called prior to this    *  method if changes have been made to this {@link SegmentInfos} instance    *</p>      **/
DECL|method|commit
specifier|final
name|void
name|commit
parameter_list|(
name|Directory
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
name|prepareCommit
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|finishCommit
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
comment|/** Returns readable description of this segment. */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|(
name|Directory
name|directory
parameter_list|)
block|{
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|getSegmentsFileName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
specifier|final
name|int
name|count
init|=
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SegmentCommitInfo
name|info
init|=
name|info
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|info
operator|.
name|toString
argument_list|(
name|directory
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Return {@code userData} saved with this commit.    *     * @see IndexWriter#commit()    */
DECL|method|getUserData
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getUserData
parameter_list|()
block|{
return|return
name|userData
return|;
block|}
DECL|method|setUserData
name|void
name|setUserData
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|userData
operator|=
name|Collections
operator|.
expr|<
name|String
operator|,
name|String
operator|>
name|emptyMap
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|userData
operator|=
name|data
expr_stmt|;
block|}
block|}
comment|/** Replaces all segments in this instance, but keeps    *  generation, version, counter so that future commits    *  remain write once.    */
DECL|method|replace
name|void
name|replace
parameter_list|(
name|SegmentInfos
name|other
parameter_list|)
block|{
name|rollbackSegmentInfos
argument_list|(
name|other
operator|.
name|asList
argument_list|()
argument_list|)
expr_stmt|;
name|lastGeneration
operator|=
name|other
operator|.
name|lastGeneration
expr_stmt|;
block|}
comment|/** Returns sum of all segment's docCounts.  Note that    *  this does not include deletions */
DECL|method|totalDocCount
specifier|public
name|int
name|totalDocCount
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|this
control|)
block|{
name|count
operator|+=
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/** Call this before committing if changes have been made to the    *  segments. */
DECL|method|changed
specifier|public
name|void
name|changed
parameter_list|()
block|{
name|version
operator|++
expr_stmt|;
block|}
comment|/** applies all changes caused by committing a merge to this SegmentInfos */
DECL|method|applyMergeChanges
name|void
name|applyMergeChanges
parameter_list|(
name|MergePolicy
operator|.
name|OneMerge
name|merge
parameter_list|,
name|boolean
name|dropSegment
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|mergedAway
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
decl_stmt|;
name|boolean
name|inserted
init|=
literal|false
decl_stmt|;
name|int
name|newSegIdx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|segIdx
init|=
literal|0
init|,
name|cnt
init|=
name|segments
operator|.
name|size
argument_list|()
init|;
name|segIdx
operator|<
name|cnt
condition|;
name|segIdx
operator|++
control|)
block|{
assert|assert
name|segIdx
operator|>=
name|newSegIdx
assert|;
specifier|final
name|SegmentCommitInfo
name|info
init|=
name|segments
operator|.
name|get
argument_list|(
name|segIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergedAway
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inserted
operator|&&
operator|!
name|dropSegment
condition|)
block|{
name|segments
operator|.
name|set
argument_list|(
name|segIdx
argument_list|,
name|merge
operator|.
name|info
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|true
expr_stmt|;
name|newSegIdx
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|segments
operator|.
name|set
argument_list|(
name|newSegIdx
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|newSegIdx
operator|++
expr_stmt|;
block|}
block|}
comment|// the rest of the segments in list are duplicates, so don't remove from map, only list!
name|segments
operator|.
name|subList
argument_list|(
name|newSegIdx
argument_list|,
name|segments
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Either we found place to insert segment, or, we did
comment|// not, but only because all segments we merged becamee
comment|// deleted while we are merging, in which case it should
comment|// be the case that the new segment is also all deleted,
comment|// we insert it at the beginning if it should not be dropped:
if|if
condition|(
operator|!
name|inserted
operator|&&
operator|!
name|dropSegment
condition|)
block|{
name|segments
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|merge
operator|.
name|info
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|createBackupSegmentInfos
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|createBackupSegmentInfos
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|SegmentCommitInfo
name|info
range|:
name|this
control|)
block|{
assert|assert
name|info
operator|.
name|info
operator|.
name|getCodec
argument_list|()
operator|!=
literal|null
assert|;
name|list
operator|.
name|add
argument_list|(
name|info
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
DECL|method|rollbackSegmentInfos
name|void
name|rollbackSegmentInfos
parameter_list|(
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|infos
parameter_list|)
block|{
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|addAll
argument_list|(
name|infos
argument_list|)
expr_stmt|;
block|}
comment|/** Returns an<b>unmodifiable</b> {@link Iterator} of contained segments in order. */
comment|// @Override (comment out until Java 6)
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|asList
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/** Returns all contained segments as an<b>unmodifiable</b> {@link List} view. */
DECL|method|asList
specifier|public
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|asList
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|segments
argument_list|)
return|;
block|}
comment|/** Returns number of {@link SegmentCommitInfo}s. */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|segments
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** Appends the provided {@link SegmentCommitInfo}. */
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|SegmentCommitInfo
name|si
parameter_list|)
block|{
name|segments
operator|.
name|add
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
comment|/** Appends the provided {@link SegmentCommitInfo}s. */
DECL|method|addAll
specifier|public
name|void
name|addAll
parameter_list|(
name|Iterable
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|sis
parameter_list|)
block|{
for|for
control|(
specifier|final
name|SegmentCommitInfo
name|si
range|:
name|sis
control|)
block|{
name|this
operator|.
name|add
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Clear all {@link SegmentCommitInfo}s. */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|segments
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/** Remove the provided {@link SegmentCommitInfo}.    *    *<p><b>WARNING</b>: O(N) cost */
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|(
name|SegmentCommitInfo
name|si
parameter_list|)
block|{
name|segments
operator|.
name|remove
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
comment|/** Remove the {@link SegmentCommitInfo} at the    * provided index.    *    *<p><b>WARNING</b>: O(N) cost */
DECL|method|remove
name|void
name|remove
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|segments
operator|.
name|remove
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
comment|/** Return true if the provided {@link    *  SegmentCommitInfo} is contained.    *    *<p><b>WARNING</b>: O(N) cost */
DECL|method|contains
name|boolean
name|contains
parameter_list|(
name|SegmentCommitInfo
name|si
parameter_list|)
block|{
return|return
name|segments
operator|.
name|contains
argument_list|(
name|si
argument_list|)
return|;
block|}
comment|/** Returns index of the provided {@link    *  SegmentCommitInfo}.    *    *<p><b>WARNING</b>: O(N) cost */
DECL|method|indexOf
name|int
name|indexOf
parameter_list|(
name|SegmentCommitInfo
name|si
parameter_list|)
block|{
return|return
name|segments
operator|.
name|indexOf
argument_list|(
name|si
argument_list|)
return|;
block|}
block|}
end_class
end_unit
