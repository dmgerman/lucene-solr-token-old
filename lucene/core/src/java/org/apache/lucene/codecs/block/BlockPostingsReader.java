begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.block
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|block
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|IntBuffer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|BlockTermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|PostingsReaderBase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFileNames
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_comment
comment|/**  * Concrete class that reads docId(maybe frq,pos,offset,payloads) list  * with postings format.  *  * @see BlockSkipReader for details  *  */
end_comment
begin_class
DECL|class|BlockPostingsReader
specifier|public
specifier|final
class|class
name|BlockPostingsReader
extends|extends
name|PostingsReaderBase
block|{
DECL|field|docIn
specifier|private
specifier|final
name|IndexInput
name|docIn
decl_stmt|;
DECL|field|posIn
specifier|private
specifier|final
name|IndexInput
name|posIn
decl_stmt|;
DECL|field|payIn
specifier|private
specifier|final
name|IndexInput
name|payIn
decl_stmt|;
DECL|field|DEBUG
specifier|public
specifier|static
name|boolean
name|DEBUG
init|=
literal|false
decl_stmt|;
comment|// nocommit
DECL|field|segment
specifier|final
name|String
name|segment
decl_stmt|;
comment|// NOTE: not private to avoid access$NNN methods:
DECL|field|blockSize
specifier|final
specifier|static
name|int
name|blockSize
init|=
name|BlockPostingsFormat
operator|.
name|BLOCK_SIZE
decl_stmt|;
DECL|method|BlockPostingsReader
specifier|public
name|BlockPostingsReader
parameter_list|(
name|Directory
name|dir
parameter_list|,
name|FieldInfos
name|fieldInfos
parameter_list|,
name|SegmentInfo
name|segmentInfo
parameter_list|,
name|IOContext
name|ioContext
parameter_list|,
name|String
name|segmentSuffix
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|segment
operator|=
name|segmentInfo
operator|.
name|name
expr_stmt|;
name|IndexInput
name|docIn
init|=
literal|null
decl_stmt|;
name|IndexInput
name|posIn
init|=
literal|null
decl_stmt|;
name|IndexInput
name|payIn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|docIn
operator|=
name|dir
operator|.
name|openInput
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segmentInfo
operator|.
name|name
argument_list|,
name|segmentSuffix
argument_list|,
name|BlockPostingsFormat
operator|.
name|DOC_EXTENSION
argument_list|)
argument_list|,
name|ioContext
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|docIn
argument_list|,
name|BlockPostingsWriter
operator|.
name|DOC_CODEC
argument_list|,
name|BlockPostingsWriter
operator|.
name|VERSION_START
argument_list|,
name|BlockPostingsWriter
operator|.
name|VERSION_START
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldInfos
operator|.
name|hasProx
argument_list|()
condition|)
block|{
name|posIn
operator|=
name|dir
operator|.
name|openInput
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segmentInfo
operator|.
name|name
argument_list|,
name|segmentSuffix
argument_list|,
name|BlockPostingsFormat
operator|.
name|POS_EXTENSION
argument_list|)
argument_list|,
name|ioContext
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|posIn
argument_list|,
name|BlockPostingsWriter
operator|.
name|POS_CODEC
argument_list|,
name|BlockPostingsWriter
operator|.
name|VERSION_START
argument_list|,
name|BlockPostingsWriter
operator|.
name|VERSION_START
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldInfos
operator|.
name|hasPayloads
argument_list|()
operator|||
name|fieldInfos
operator|.
name|hasOffsets
argument_list|()
condition|)
block|{
name|payIn
operator|=
name|dir
operator|.
name|openInput
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segmentInfo
operator|.
name|name
argument_list|,
name|segmentSuffix
argument_list|,
name|BlockPostingsFormat
operator|.
name|PAY_EXTENSION
argument_list|)
argument_list|,
name|ioContext
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|payIn
argument_list|,
name|BlockPostingsWriter
operator|.
name|PAY_CODEC
argument_list|,
name|BlockPostingsWriter
operator|.
name|VERSION_START
argument_list|,
name|BlockPostingsWriter
operator|.
name|VERSION_START
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|docIn
operator|=
name|docIn
expr_stmt|;
name|this
operator|.
name|posIn
operator|=
name|posIn
expr_stmt|;
name|this
operator|.
name|payIn
operator|=
name|payIn
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|docIn
argument_list|,
name|posIn
argument_list|,
name|payIn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
name|IndexInput
name|termsIn
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Make sure we are talking to the matching past writer
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|termsIn
argument_list|,
name|BlockPostingsWriter
operator|.
name|TERMS_CODEC
argument_list|,
name|BlockPostingsWriter
operator|.
name|VERSION_START
argument_list|,
name|BlockPostingsWriter
operator|.
name|VERSION_START
argument_list|)
expr_stmt|;
specifier|final
name|int
name|indexBlockSize
init|=
name|termsIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexBlockSize
operator|!=
name|blockSize
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"index-time blockSize ("
operator|+
name|indexBlockSize
operator|+
literal|") != read-time blockSize ("
operator|+
name|blockSize
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
DECL|method|readVIntBlock
specifier|static
name|void
name|readVIntBlock
parameter_list|(
name|IndexInput
name|docIn
parameter_list|,
name|int
index|[]
name|docBuffer
parameter_list|,
name|int
index|[]
name|freqBuffer
parameter_list|,
name|int
name|num
parameter_list|,
name|boolean
name|indexHasFreq
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|indexHasFreq
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|code
init|=
name|docIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|docBuffer
index|[
name|i
index|]
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|freqBuffer
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|freqBuffer
index|[
name|i
index|]
operator|=
name|docIn
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|docBuffer
index|[
name|i
index|]
operator|=
name|docIn
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|readBlock
specifier|static
name|void
name|readBlock
parameter_list|(
name|IndexInput
name|in
parameter_list|,
name|byte
index|[]
name|encoded
parameter_list|,
name|IntBuffer
name|encodedBuffer
parameter_list|,
name|int
index|[]
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|header
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|in
operator|.
name|readBytes
argument_list|(
name|encoded
argument_list|,
literal|0
argument_list|,
name|ForUtil
operator|.
name|getEncodedSize
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|ForUtil
operator|.
name|decompress
argument_list|(
name|encodedBuffer
argument_list|,
name|buffer
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
DECL|method|skipBlock
specifier|static
name|void
name|skipBlock
parameter_list|(
name|IndexInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|header
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|in
operator|.
name|seek
argument_list|(
name|in
operator|.
name|getFilePointer
argument_list|()
operator|+
name|ForUtil
operator|.
name|getEncodedSize
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Must keep final because we do non-standard clone
DECL|class|IntBlockTermState
specifier|private
specifier|final
specifier|static
class|class
name|IntBlockTermState
extends|extends
name|BlockTermState
block|{
DECL|field|docStartFP
name|long
name|docStartFP
decl_stmt|;
DECL|field|posStartFP
name|long
name|posStartFP
decl_stmt|;
DECL|field|payStartFP
name|long
name|payStartFP
decl_stmt|;
DECL|field|skipOffset
name|int
name|skipOffset
decl_stmt|;
DECL|field|lastPosBlockOffset
name|int
name|lastPosBlockOffset
decl_stmt|;
comment|// Only used by the "primary" TermState -- clones don't
comment|// copy this (basically they are "transient"):
DECL|field|bytesReader
name|ByteArrayDataInput
name|bytesReader
decl_stmt|;
comment|// TODO: should this NOT be in the TermState...?
DECL|field|bytes
name|byte
index|[]
name|bytes
decl_stmt|;
annotation|@
name|Override
DECL|method|clone
specifier|public
name|IntBlockTermState
name|clone
parameter_list|()
block|{
name|IntBlockTermState
name|other
init|=
operator|new
name|IntBlockTermState
argument_list|()
decl_stmt|;
name|other
operator|.
name|copyFrom
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|other
return|;
block|}
annotation|@
name|Override
DECL|method|copyFrom
specifier|public
name|void
name|copyFrom
parameter_list|(
name|TermState
name|_other
parameter_list|)
block|{
name|super
operator|.
name|copyFrom
argument_list|(
name|_other
argument_list|)
expr_stmt|;
name|IntBlockTermState
name|other
init|=
operator|(
name|IntBlockTermState
operator|)
name|_other
decl_stmt|;
name|docStartFP
operator|=
name|other
operator|.
name|docStartFP
expr_stmt|;
name|posStartFP
operator|=
name|other
operator|.
name|posStartFP
expr_stmt|;
name|payStartFP
operator|=
name|other
operator|.
name|payStartFP
expr_stmt|;
name|lastPosBlockOffset
operator|=
name|other
operator|.
name|lastPosBlockOffset
expr_stmt|;
name|skipOffset
operator|=
name|other
operator|.
name|skipOffset
expr_stmt|;
comment|// Do not copy bytes, bytesReader (else TermState is
comment|// very heavy, ie drags around the entire block's
comment|// byte[]).  On seek back, if next() is in fact used
comment|// (rare!), they will be re-read from disk.
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|" docStartFP="
operator|+
name|docStartFP
operator|+
literal|" posStartFP="
operator|+
name|posStartFP
operator|+
literal|" payStartFP="
operator|+
name|payStartFP
operator|+
literal|" lastPosBlockOffset="
operator|+
name|lastPosBlockOffset
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|newTermState
specifier|public
name|IntBlockTermState
name|newTermState
parameter_list|()
block|{
return|return
operator|new
name|IntBlockTermState
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|docIn
argument_list|,
name|posIn
argument_list|,
name|payIn
argument_list|)
expr_stmt|;
block|}
comment|/* Reads but does not decode the byte[] blob holding      metadata for the current terms block */
annotation|@
name|Override
DECL|method|readTermsBlock
specifier|public
name|void
name|readTermsBlock
parameter_list|(
name|IndexInput
name|termsIn
parameter_list|,
name|FieldInfo
name|fieldInfo
parameter_list|,
name|BlockTermState
name|_termState
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|IntBlockTermState
name|termState
init|=
operator|(
name|IntBlockTermState
operator|)
name|_termState
decl_stmt|;
specifier|final
name|int
name|numBytes
init|=
name|termsIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|termState
operator|.
name|bytes
operator|==
literal|null
condition|)
block|{
name|termState
operator|.
name|bytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
name|termState
operator|.
name|bytesReader
operator|=
operator|new
name|ByteArrayDataInput
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|termState
operator|.
name|bytes
operator|.
name|length
operator|<
name|numBytes
condition|)
block|{
name|termState
operator|.
name|bytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|termsIn
operator|.
name|readBytes
argument_list|(
name|termState
operator|.
name|bytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|termState
operator|.
name|bytesReader
operator|.
name|reset
argument_list|(
name|termState
operator|.
name|bytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|nextTerm
specifier|public
name|void
name|nextTerm
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|BlockTermState
name|_termState
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|IntBlockTermState
name|termState
init|=
operator|(
name|IntBlockTermState
operator|)
name|_termState
decl_stmt|;
specifier|final
name|boolean
name|isFirstTerm
init|=
name|termState
operator|.
name|termBlockOrd
operator|==
literal|0
decl_stmt|;
specifier|final
name|boolean
name|fieldHasPositions
init|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|>=
literal|0
decl_stmt|;
specifier|final
name|boolean
name|fieldHasOffsets
init|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
decl_stmt|;
specifier|final
name|boolean
name|fieldHasPayloads
init|=
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
decl_stmt|;
specifier|final
name|DataInput
name|in
init|=
name|termState
operator|.
name|bytesReader
decl_stmt|;
if|if
condition|(
name|isFirstTerm
condition|)
block|{
name|termState
operator|.
name|docStartFP
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
if|if
condition|(
name|fieldHasPositions
condition|)
block|{
name|termState
operator|.
name|posStartFP
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
if|if
condition|(
name|termState
operator|.
name|totalTermFreq
operator|>
name|blockSize
condition|)
block|{
name|termState
operator|.
name|lastPosBlockOffset
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|termState
operator|.
name|lastPosBlockOffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fieldHasPayloads
operator|||
name|fieldHasOffsets
operator|)
operator|&&
name|termState
operator|.
name|totalTermFreq
operator|>=
name|blockSize
condition|)
block|{
name|termState
operator|.
name|payStartFP
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|termState
operator|.
name|payStartFP
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|termState
operator|.
name|docStartFP
operator|+=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
if|if
condition|(
name|fieldHasPositions
condition|)
block|{
name|termState
operator|.
name|posStartFP
operator|+=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
if|if
condition|(
name|termState
operator|.
name|totalTermFreq
operator|>
name|blockSize
condition|)
block|{
name|termState
operator|.
name|lastPosBlockOffset
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|termState
operator|.
name|lastPosBlockOffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fieldHasPayloads
operator|||
name|fieldHasOffsets
operator|)
operator|&&
name|termState
operator|.
name|totalTermFreq
operator|>=
name|blockSize
condition|)
block|{
name|long
name|delta
init|=
name|in
operator|.
name|readVLong
argument_list|()
decl_stmt|;
if|if
condition|(
name|termState
operator|.
name|payStartFP
operator|==
operator|-
literal|1
condition|)
block|{
name|termState
operator|.
name|payStartFP
operator|=
name|delta
expr_stmt|;
block|}
else|else
block|{
name|termState
operator|.
name|payStartFP
operator|+=
name|delta
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|termState
operator|.
name|docFreq
operator|>
name|blockSize
condition|)
block|{
name|termState
operator|.
name|skipOffset
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|termState
operator|.
name|skipOffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|BlockTermState
name|termState
parameter_list|,
name|Bits
name|liveDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockDocsEnum
name|docsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|instanceof
name|BlockDocsEnum
condition|)
block|{
name|docsEnum
operator|=
operator|(
name|BlockDocsEnum
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
operator|!
name|docsEnum
operator|.
name|canReuse
argument_list|(
name|docIn
argument_list|,
name|fieldInfo
argument_list|)
condition|)
block|{
name|docsEnum
operator|=
operator|new
name|BlockDocsEnum
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|docsEnum
operator|=
operator|new
name|BlockDocsEnum
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|docsEnum
operator|.
name|reset
argument_list|(
name|liveDocs
argument_list|,
operator|(
name|IntBlockTermState
operator|)
name|termState
argument_list|)
return|;
block|}
comment|// TODO: specialize to liveDocs vs not, and freqs vs not
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|BlockTermState
name|termState
parameter_list|,
name|Bits
name|liveDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|indexHasOffsets
init|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
decl_stmt|;
name|boolean
name|indexHasPayloads
init|=
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|indexHasOffsets
operator|||
operator|(
name|flags
operator|&
name|DocsAndPositionsEnum
operator|.
name|FLAG_OFFSETS
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|indexHasPayloads
operator|||
operator|(
name|flags
operator|&
name|DocsAndPositionsEnum
operator|.
name|FLAG_PAYLOADS
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|BlockDocsAndPositionsEnum
name|docsAndPositionsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|instanceof
name|BlockDocsAndPositionsEnum
condition|)
block|{
name|docsAndPositionsEnum
operator|=
operator|(
name|BlockDocsAndPositionsEnum
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
operator|!
name|docsAndPositionsEnum
operator|.
name|canReuse
argument_list|(
name|docIn
argument_list|,
name|fieldInfo
argument_list|)
condition|)
block|{
name|docsAndPositionsEnum
operator|=
operator|new
name|BlockDocsAndPositionsEnum
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|docsAndPositionsEnum
operator|=
operator|new
name|BlockDocsAndPositionsEnum
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|docsAndPositionsEnum
operator|.
name|reset
argument_list|(
name|liveDocs
argument_list|,
operator|(
name|IntBlockTermState
operator|)
name|termState
argument_list|)
return|;
block|}
else|else
block|{
name|EverythingEnum
name|everythingEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|instanceof
name|EverythingEnum
condition|)
block|{
name|everythingEnum
operator|=
operator|(
name|EverythingEnum
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
operator|!
name|everythingEnum
operator|.
name|canReuse
argument_list|(
name|docIn
argument_list|,
name|fieldInfo
argument_list|)
condition|)
block|{
name|everythingEnum
operator|=
operator|new
name|EverythingEnum
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|everythingEnum
operator|=
operator|new
name|EverythingEnum
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|everythingEnum
operator|.
name|reset
argument_list|(
name|liveDocs
argument_list|,
operator|(
name|IntBlockTermState
operator|)
name|termState
argument_list|)
return|;
block|}
block|}
DECL|class|BlockDocsEnum
specifier|final
class|class
name|BlockDocsEnum
extends|extends
name|DocsEnum
block|{
DECL|field|encoded
specifier|private
specifier|final
name|byte
index|[]
name|encoded
decl_stmt|;
DECL|field|encodedBuffer
specifier|private
specifier|final
name|IntBuffer
name|encodedBuffer
decl_stmt|;
DECL|field|docDeltaBuffer
specifier|private
specifier|final
name|int
index|[]
name|docDeltaBuffer
init|=
operator|new
name|int
index|[
name|blockSize
index|]
decl_stmt|;
DECL|field|freqBuffer
specifier|private
specifier|final
name|int
index|[]
name|freqBuffer
init|=
operator|new
name|int
index|[
name|blockSize
index|]
decl_stmt|;
DECL|field|docBufferUpto
specifier|private
name|int
name|docBufferUpto
decl_stmt|;
DECL|field|skipper
specifier|private
name|BlockSkipReader
name|skipper
decl_stmt|;
DECL|field|skipped
specifier|private
name|boolean
name|skipped
decl_stmt|;
DECL|field|startDocIn
specifier|final
name|IndexInput
name|startDocIn
decl_stmt|;
DECL|field|docIn
specifier|final
name|IndexInput
name|docIn
decl_stmt|;
DECL|field|indexHasFreq
specifier|final
name|boolean
name|indexHasFreq
decl_stmt|;
DECL|field|indexHasPos
specifier|final
name|boolean
name|indexHasPos
decl_stmt|;
DECL|field|indexHasOffsets
specifier|final
name|boolean
name|indexHasOffsets
decl_stmt|;
DECL|field|indexHasPayloads
specifier|final
name|boolean
name|indexHasPayloads
decl_stmt|;
DECL|field|docFreq
specifier|private
name|int
name|docFreq
decl_stmt|;
comment|// number of docs in this posting list
DECL|field|docUpto
specifier|private
name|int
name|docUpto
decl_stmt|;
comment|// how many docs we've read
DECL|field|doc
specifier|private
name|int
name|doc
decl_stmt|;
comment|// doc we last read
DECL|field|accum
specifier|private
name|int
name|accum
decl_stmt|;
comment|// accumulator for doc deltas
DECL|field|freq
specifier|private
name|int
name|freq
decl_stmt|;
comment|// freq we last read
comment|// Where this term's postings start in the .doc file:
DECL|field|docTermStartFP
specifier|private
name|long
name|docTermStartFP
decl_stmt|;
comment|// Where this term's skip data starts (after
comment|// docTermStartFP) in the .doc file (or -1 if there is
comment|// no skip data for this term):
DECL|field|skipOffset
specifier|private
name|int
name|skipOffset
decl_stmt|;
DECL|field|liveDocs
specifier|private
name|Bits
name|liveDocs
decl_stmt|;
DECL|method|BlockDocsEnum
specifier|public
name|BlockDocsEnum
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|startDocIn
operator|=
name|BlockPostingsReader
operator|.
name|this
operator|.
name|docIn
expr_stmt|;
name|this
operator|.
name|docIn
operator|=
operator|(
name|IndexInput
operator|)
name|startDocIn
operator|.
name|clone
argument_list|()
expr_stmt|;
name|indexHasFreq
operator|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS
argument_list|)
operator|>=
literal|0
expr_stmt|;
name|indexHasPos
operator|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|>=
literal|0
expr_stmt|;
name|indexHasOffsets
operator|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
expr_stmt|;
name|indexHasPayloads
operator|=
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
expr_stmt|;
name|encoded
operator|=
operator|new
name|byte
index|[
name|blockSize
operator|*
literal|4
index|]
expr_stmt|;
name|encodedBuffer
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|encoded
argument_list|)
operator|.
name|asIntBuffer
argument_list|()
expr_stmt|;
block|}
DECL|method|canReuse
specifier|public
name|boolean
name|canReuse
parameter_list|(
name|IndexInput
name|docIn
parameter_list|,
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
return|return
name|docIn
operator|==
name|startDocIn
operator|&&
name|indexHasFreq
operator|==
operator|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
name|indexHasPos
operator|==
operator|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
name|indexHasPayloads
operator|==
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
return|;
block|}
DECL|method|reset
specifier|public
name|DocsEnum
name|reset
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|IntBlockTermState
name|termState
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  FPR.reset: seg="
operator|+
name|segment
operator|+
literal|" termState="
operator|+
name|termState
argument_list|)
expr_stmt|;
block|}
name|docFreq
operator|=
name|termState
operator|.
name|docFreq
expr_stmt|;
name|docTermStartFP
operator|=
name|termState
operator|.
name|docStartFP
expr_stmt|;
name|docIn
operator|.
name|seek
argument_list|(
name|docTermStartFP
argument_list|)
expr_stmt|;
name|skipOffset
operator|=
name|termState
operator|.
name|skipOffset
expr_stmt|;
name|doc
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|indexHasFreq
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|freqBuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|accum
operator|=
literal|0
expr_stmt|;
name|docUpto
operator|=
literal|0
expr_stmt|;
name|docBufferUpto
operator|=
name|blockSize
expr_stmt|;
name|skipped
operator|=
literal|false
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|freq
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
DECL|method|refillDocs
specifier|private
name|void
name|refillDocs
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.out.println("["+docFreq+"]"+" refillDoc");
specifier|final
name|int
name|left
init|=
name|docFreq
operator|-
name|docUpto
decl_stmt|;
assert|assert
name|left
operator|>
literal|0
assert|;
if|if
condition|(
name|left
operator|>=
name|blockSize
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    fill doc block from fp="
operator|+
name|docIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|readBlock
argument_list|(
name|docIn
argument_list|,
name|encoded
argument_list|,
name|encodedBuffer
argument_list|,
name|docDeltaBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexHasFreq
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    fill freq block from fp="
operator|+
name|docIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|readBlock
argument_list|(
name|docIn
argument_list|,
name|encoded
argument_list|,
name|encodedBuffer
argument_list|,
name|freqBuffer
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    fill last vInt block from fp="
operator|+
name|docIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|readVIntBlock
argument_list|(
name|docIn
argument_list|,
name|docDeltaBuffer
argument_list|,
name|freqBuffer
argument_list|,
name|left
argument_list|,
name|indexHasFreq
argument_list|)
expr_stmt|;
block|}
name|docBufferUpto
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nFPR.nextDoc"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  docUpto="
operator|+
name|docUpto
operator|+
literal|" (of df="
operator|+
name|docFreq
operator|+
literal|") docBufferUpto="
operator|+
name|docBufferUpto
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|docUpto
operator|==
name|docFreq
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  return doc=END"
argument_list|)
expr_stmt|;
block|}
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
comment|//System.out.println("["+docFreq+"]"+" nextDoc");
if|if
condition|(
name|docBufferUpto
operator|==
name|blockSize
condition|)
block|{
name|refillDocs
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    accum="
operator|+
name|accum
operator|+
literal|" docDeltaBuffer["
operator|+
name|docBufferUpto
operator|+
literal|"]="
operator|+
name|docDeltaBuffer
index|[
name|docBufferUpto
index|]
argument_list|)
expr_stmt|;
block|}
name|accum
operator|+=
name|docDeltaBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|docUpto
operator|++
expr_stmt|;
if|if
condition|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
name|accum
argument_list|)
condition|)
block|{
name|doc
operator|=
name|accum
expr_stmt|;
name|freq
operator|=
name|freqBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|docBufferUpto
operator|++
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  return doc="
operator|+
name|doc
operator|+
literal|" freq="
operator|+
name|freq
argument_list|)
expr_stmt|;
block|}
return|return
name|doc
return|;
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  doc="
operator|+
name|accum
operator|+
literal|" is deleted; try next doc"
argument_list|)
expr_stmt|;
block|}
name|docBufferUpto
operator|++
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
comment|// nocommit make frq block load lazy/skippable
comment|// nocommit use skipper!!!  it has next last doc id!!
if|if
condition|(
name|docFreq
operator|>
name|blockSize
operator|&&
name|target
operator|-
name|accum
operator|>
name|blockSize
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"load skipper"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|skipper
operator|==
literal|null
condition|)
block|{
comment|// Lazy init: first time this enum has ever been used for skipping
name|skipper
operator|=
operator|new
name|BlockSkipReader
argument_list|(
operator|(
name|IndexInput
operator|)
name|docIn
operator|.
name|clone
argument_list|()
argument_list|,
name|BlockPostingsWriter
operator|.
name|maxSkipLevels
argument_list|,
name|blockSize
argument_list|,
name|indexHasPos
argument_list|,
name|indexHasOffsets
argument_list|,
name|indexHasPayloads
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skipped
condition|)
block|{
assert|assert
name|skipOffset
operator|!=
operator|-
literal|1
assert|;
comment|// This is the first time this enum has skipped
comment|// since reset() was called; load the skip data:
name|skipper
operator|.
name|init
argument_list|(
name|docTermStartFP
operator|+
name|skipOffset
argument_list|,
name|docTermStartFP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|docFreq
argument_list|)
expr_stmt|;
name|skipped
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|int
name|newDocUpto
init|=
name|skipper
operator|.
name|skipTo
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDocUpto
operator|>
name|docUpto
condition|)
block|{
comment|// Skipper moved
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"skipper moved to docUpto="
operator|+
name|newDocUpto
operator|+
literal|" vs current="
operator|+
name|docUpto
operator|+
literal|"; docID="
operator|+
name|skipper
operator|.
name|getDoc
argument_list|()
operator|+
literal|" fp="
operator|+
name|skipper
operator|.
name|getDocPointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|newDocUpto
operator|%
name|blockSize
operator|==
operator|(
name|blockSize
operator|-
literal|1
operator|)
operator|:
literal|"got "
operator|+
name|newDocUpto
assert|;
name|docUpto
operator|=
name|newDocUpto
operator|+
literal|1
expr_stmt|;
comment|// Force to read next block
name|docBufferUpto
operator|=
name|blockSize
expr_stmt|;
name|accum
operator|=
name|skipper
operator|.
name|getDoc
argument_list|()
expr_stmt|;
comment|// actually, this is just lastSkipEntry
name|docIn
operator|.
name|seek
argument_list|(
name|skipper
operator|.
name|getDocPointer
argument_list|()
argument_list|)
expr_stmt|;
comment|// now point to the block we want to search
block|}
block|}
comment|// Now scan... this is an inlined/pared down version
comment|// of nextDoc():
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  scan doc="
operator|+
name|accum
operator|+
literal|" docBufferUpto="
operator|+
name|docBufferUpto
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|docUpto
operator|==
name|docFreq
condition|)
block|{
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
comment|// nocommit: in theory we should not hit this?  ie
comment|// skipper should already have moved us to the block
comment|// containing the doc?  yet assert false trips ... i
comment|// think because if you advance w/o having done a
comment|// nextDoc yet()... can we assert/remove this?
if|if
condition|(
name|docBufferUpto
operator|==
name|blockSize
condition|)
block|{
name|refillDocs
argument_list|()
expr_stmt|;
block|}
name|accum
operator|+=
name|docDeltaBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|docUpto
operator|++
expr_stmt|;
if|if
condition|(
name|accum
operator|>=
name|target
condition|)
block|{
break|break;
block|}
name|docBufferUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
name|accum
argument_list|)
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  return doc="
operator|+
name|accum
argument_list|)
expr_stmt|;
block|}
name|freq
operator|=
name|freqBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|docBufferUpto
operator|++
expr_stmt|;
return|return
name|doc
operator|=
name|accum
return|;
block|}
else|else
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  now do nextDoc()"
argument_list|)
expr_stmt|;
block|}
name|docBufferUpto
operator|++
expr_stmt|;
return|return
name|nextDoc
argument_list|()
return|;
block|}
block|}
block|}
DECL|class|BlockDocsAndPositionsEnum
specifier|final
class|class
name|BlockDocsAndPositionsEnum
extends|extends
name|DocsAndPositionsEnum
block|{
DECL|field|encoded
specifier|private
specifier|final
name|byte
index|[]
name|encoded
decl_stmt|;
DECL|field|encodedBuffer
specifier|private
specifier|final
name|IntBuffer
name|encodedBuffer
decl_stmt|;
DECL|field|docDeltaBuffer
specifier|private
specifier|final
name|int
index|[]
name|docDeltaBuffer
init|=
operator|new
name|int
index|[
name|blockSize
index|]
decl_stmt|;
DECL|field|freqBuffer
specifier|private
specifier|final
name|int
index|[]
name|freqBuffer
init|=
operator|new
name|int
index|[
name|blockSize
index|]
decl_stmt|;
DECL|field|posDeltaBuffer
specifier|private
specifier|final
name|int
index|[]
name|posDeltaBuffer
init|=
operator|new
name|int
index|[
name|blockSize
index|]
decl_stmt|;
DECL|field|docBufferUpto
specifier|private
name|int
name|docBufferUpto
decl_stmt|;
DECL|field|posBufferUpto
specifier|private
name|int
name|posBufferUpto
decl_stmt|;
DECL|field|skipper
specifier|private
name|BlockSkipReader
name|skipper
decl_stmt|;
DECL|field|skipped
specifier|private
name|boolean
name|skipped
decl_stmt|;
DECL|field|startDocIn
specifier|final
name|IndexInput
name|startDocIn
decl_stmt|;
DECL|field|docIn
specifier|final
name|IndexInput
name|docIn
decl_stmt|;
DECL|field|posIn
specifier|final
name|IndexInput
name|posIn
decl_stmt|;
DECL|field|indexHasOffsets
specifier|final
name|boolean
name|indexHasOffsets
decl_stmt|;
DECL|field|indexHasPayloads
specifier|final
name|boolean
name|indexHasPayloads
decl_stmt|;
DECL|field|docFreq
specifier|private
name|int
name|docFreq
decl_stmt|;
comment|// number of docs in this posting list
DECL|field|docUpto
specifier|private
name|int
name|docUpto
decl_stmt|;
comment|// how many docs we've read
DECL|field|doc
specifier|private
name|int
name|doc
decl_stmt|;
comment|// doc we last read
DECL|field|accum
specifier|private
name|int
name|accum
decl_stmt|;
comment|// accumulator for doc deltas
DECL|field|freq
specifier|private
name|int
name|freq
decl_stmt|;
comment|// freq we last read
DECL|field|position
specifier|private
name|int
name|position
decl_stmt|;
comment|// current position
comment|// how many positions "behind" we are; nextPosition must
comment|// skip these to "catch up":
DECL|field|posPendingCount
specifier|private
name|int
name|posPendingCount
decl_stmt|;
comment|// Lazy pos seek: if != -1 then we must seek to this FP
comment|// before reading positions:
DECL|field|posPendingFP
specifier|private
name|long
name|posPendingFP
decl_stmt|;
comment|// Where this term's postings start in the .doc file:
DECL|field|docTermStartFP
specifier|private
name|long
name|docTermStartFP
decl_stmt|;
comment|// Where this term's postings start in the .pos file:
DECL|field|posTermStartFP
specifier|private
name|long
name|posTermStartFP
decl_stmt|;
comment|// Where this term's payloads/offsets start in the .pay
comment|// file:
DECL|field|payTermStartFP
specifier|private
name|long
name|payTermStartFP
decl_stmt|;
comment|// File pointer where the last (vInt encoded) pos delta
comment|// block is.  We need this to know whether to bulk
comment|// decode vs vInt decode the block:
DECL|field|lastPosBlockFP
specifier|private
name|long
name|lastPosBlockFP
decl_stmt|;
comment|// Where this term's skip data starts (after
comment|// docTermStartFP) in the .doc file (or -1 if there is
comment|// no skip data for this term):
DECL|field|skipOffset
specifier|private
name|int
name|skipOffset
decl_stmt|;
DECL|field|liveDocs
specifier|private
name|Bits
name|liveDocs
decl_stmt|;
DECL|method|BlockDocsAndPositionsEnum
specifier|public
name|BlockDocsAndPositionsEnum
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|startDocIn
operator|=
name|BlockPostingsReader
operator|.
name|this
operator|.
name|docIn
expr_stmt|;
name|this
operator|.
name|docIn
operator|=
operator|(
name|IndexInput
operator|)
name|startDocIn
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|posIn
operator|=
operator|(
name|IndexInput
operator|)
name|BlockPostingsReader
operator|.
name|this
operator|.
name|posIn
operator|.
name|clone
argument_list|()
expr_stmt|;
name|encoded
operator|=
operator|new
name|byte
index|[
name|blockSize
operator|*
literal|4
index|]
expr_stmt|;
name|encodedBuffer
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|encoded
argument_list|)
operator|.
name|asIntBuffer
argument_list|()
expr_stmt|;
name|indexHasOffsets
operator|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
expr_stmt|;
name|indexHasPayloads
operator|=
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
expr_stmt|;
block|}
DECL|method|canReuse
specifier|public
name|boolean
name|canReuse
parameter_list|(
name|IndexInput
name|docIn
parameter_list|,
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
return|return
name|docIn
operator|==
name|startDocIn
operator|&&
name|indexHasOffsets
operator|==
operator|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
name|indexHasPayloads
operator|==
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
return|;
block|}
DECL|method|reset
specifier|public
name|DocsAndPositionsEnum
name|reset
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|IntBlockTermState
name|termState
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  FPR.reset: termState="
operator|+
name|termState
argument_list|)
expr_stmt|;
block|}
name|docFreq
operator|=
name|termState
operator|.
name|docFreq
expr_stmt|;
name|docTermStartFP
operator|=
name|termState
operator|.
name|docStartFP
expr_stmt|;
name|posTermStartFP
operator|=
name|termState
operator|.
name|posStartFP
expr_stmt|;
name|payTermStartFP
operator|=
name|termState
operator|.
name|payStartFP
expr_stmt|;
name|docIn
operator|.
name|seek
argument_list|(
name|docTermStartFP
argument_list|)
expr_stmt|;
name|skipOffset
operator|=
name|termState
operator|.
name|skipOffset
expr_stmt|;
name|posPendingFP
operator|=
name|posTermStartFP
expr_stmt|;
name|posPendingCount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|termState
operator|.
name|totalTermFreq
operator|<
name|blockSize
condition|)
block|{
name|lastPosBlockFP
operator|=
name|posTermStartFP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|termState
operator|.
name|totalTermFreq
operator|==
name|blockSize
condition|)
block|{
name|lastPosBlockFP
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lastPosBlockFP
operator|=
name|posTermStartFP
operator|+
name|termState
operator|.
name|lastPosBlockOffset
expr_stmt|;
block|}
name|doc
operator|=
operator|-
literal|1
expr_stmt|;
name|accum
operator|=
literal|0
expr_stmt|;
name|docUpto
operator|=
literal|0
expr_stmt|;
name|docBufferUpto
operator|=
name|blockSize
expr_stmt|;
name|skipped
operator|=
literal|false
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|freq
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
DECL|method|refillDocs
specifier|private
name|void
name|refillDocs
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.out.println("["+docFreq+"]"+" refillDoc");
specifier|final
name|int
name|left
init|=
name|docFreq
operator|-
name|docUpto
decl_stmt|;
assert|assert
name|left
operator|>
literal|0
assert|;
if|if
condition|(
name|left
operator|>=
name|blockSize
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    fill doc block from fp="
operator|+
name|docIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|readBlock
argument_list|(
name|docIn
argument_list|,
name|encoded
argument_list|,
name|encodedBuffer
argument_list|,
name|docDeltaBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    fill freq block from fp="
operator|+
name|docIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|readBlock
argument_list|(
name|docIn
argument_list|,
name|encoded
argument_list|,
name|encodedBuffer
argument_list|,
name|freqBuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    fill last vInt doc block from fp="
operator|+
name|docIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|readVIntBlock
argument_list|(
name|docIn
argument_list|,
name|docDeltaBuffer
argument_list|,
name|freqBuffer
argument_list|,
name|left
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|docBufferUpto
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|refillPositions
specifier|private
name|void
name|refillPositions
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      refillPositions"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|posIn
operator|.
name|getFilePointer
argument_list|()
operator|==
name|lastPosBlockFP
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"        vInt pos block @ fp="
operator|+
name|posIn
operator|.
name|getFilePointer
argument_list|()
operator|+
literal|" hasPayloads="
operator|+
name|indexHasPayloads
operator|+
literal|" hasOffsets="
operator|+
name|indexHasOffsets
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|count
init|=
name|posIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|int
name|payloadLength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|code
init|=
name|posIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|payloadLength
operator|=
name|posIn
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
name|posDeltaBuffer
index|[
name|i
index|]
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
if|if
condition|(
name|payloadLength
operator|!=
literal|0
condition|)
block|{
name|posIn
operator|.
name|seek
argument_list|(
name|posIn
operator|.
name|getFilePointer
argument_list|()
operator|+
name|payloadLength
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|posDeltaBuffer
index|[
name|i
index|]
operator|=
name|code
expr_stmt|;
block|}
if|if
condition|(
name|indexHasOffsets
condition|)
block|{
name|posIn
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|posIn
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"        bulk pos block @ fp="
operator|+
name|posIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|readBlock
argument_list|(
name|posIn
argument_list|,
name|encoded
argument_list|,
name|encodedBuffer
argument_list|,
name|posDeltaBuffer
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  FPR.nextDoc"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    docUpto="
operator|+
name|docUpto
operator|+
literal|" (of df="
operator|+
name|docFreq
operator|+
literal|") docBufferUpto="
operator|+
name|docBufferUpto
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|docUpto
operator|==
name|docFreq
condition|)
block|{
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
comment|//System.out.println("["+docFreq+"]"+" nextDoc");
if|if
condition|(
name|docBufferUpto
operator|==
name|blockSize
condition|)
block|{
name|refillDocs
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    accum="
operator|+
name|accum
operator|+
literal|" docDeltaBuffer["
operator|+
name|docBufferUpto
operator|+
literal|"]="
operator|+
name|docDeltaBuffer
index|[
name|docBufferUpto
index|]
argument_list|)
expr_stmt|;
block|}
name|accum
operator|+=
name|docDeltaBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|freq
operator|=
name|freqBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|posPendingCount
operator|+=
name|freq
expr_stmt|;
name|docBufferUpto
operator|++
expr_stmt|;
name|docUpto
operator|++
expr_stmt|;
if|if
condition|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
name|accum
argument_list|)
condition|)
block|{
name|doc
operator|=
name|accum
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    return doc="
operator|+
name|doc
operator|+
literal|" freq="
operator|+
name|freq
operator|+
literal|" posPendingCount="
operator|+
name|posPendingCount
argument_list|)
expr_stmt|;
block|}
return|return
name|doc
return|;
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    doc="
operator|+
name|accum
operator|+
literal|" is deleted; try next doc"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
comment|// nocommit make frq block load lazy/skippable
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  FPR.advance target="
operator|+
name|target
argument_list|)
expr_stmt|;
block|}
comment|// nocommit 2 is heuristic guess!!
comment|// nocommit put cheating back!  does it help?
comment|// nocommit use skipper!!!  it has next last doc id!!
comment|//if (docFreq> blockSize&& target - (blockSize - docBufferUpto) - 2*blockSize> accum) {
if|if
condition|(
name|docFreq
operator|>
name|blockSize
operator|&&
name|target
operator|-
name|accum
operator|>
name|blockSize
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    try skipper"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|skipper
operator|==
literal|null
condition|)
block|{
comment|// Lazy init: first time this enum has ever been used for skipping
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    create skipper"
argument_list|)
expr_stmt|;
block|}
name|skipper
operator|=
operator|new
name|BlockSkipReader
argument_list|(
operator|(
name|IndexInput
operator|)
name|docIn
operator|.
name|clone
argument_list|()
argument_list|,
name|BlockPostingsWriter
operator|.
name|maxSkipLevels
argument_list|,
name|blockSize
argument_list|,
literal|true
argument_list|,
name|indexHasOffsets
argument_list|,
name|indexHasPayloads
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skipped
condition|)
block|{
assert|assert
name|skipOffset
operator|!=
operator|-
literal|1
assert|;
comment|// This is the first time this enum has skipped
comment|// since reset() was called; load the skip data:
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    init skipper"
argument_list|)
expr_stmt|;
block|}
name|skipper
operator|.
name|init
argument_list|(
name|docTermStartFP
operator|+
name|skipOffset
argument_list|,
name|docTermStartFP
argument_list|,
name|posTermStartFP
argument_list|,
name|payTermStartFP
argument_list|,
name|docFreq
argument_list|)
expr_stmt|;
name|skipped
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|int
name|newDocUpto
init|=
name|skipper
operator|.
name|skipTo
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDocUpto
operator|>
name|docUpto
condition|)
block|{
comment|// Skipper moved
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    skipper moved to docUpto="
operator|+
name|newDocUpto
operator|+
literal|" vs current="
operator|+
name|docUpto
operator|+
literal|"; docID="
operator|+
name|skipper
operator|.
name|getDoc
argument_list|()
operator|+
literal|" fp="
operator|+
name|skipper
operator|.
name|getDocPointer
argument_list|()
operator|+
literal|" pos.fp="
operator|+
name|skipper
operator|.
name|getPosPointer
argument_list|()
operator|+
literal|" pos.bufferUpto="
operator|+
name|skipper
operator|.
name|getPosBufferUpto
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|newDocUpto
operator|%
name|blockSize
operator|==
operator|(
name|blockSize
operator|-
literal|1
operator|)
operator|:
literal|"got "
operator|+
name|newDocUpto
assert|;
name|docUpto
operator|=
name|newDocUpto
operator|+
literal|1
expr_stmt|;
comment|// Force to read next block
name|docBufferUpto
operator|=
name|blockSize
expr_stmt|;
name|accum
operator|=
name|skipper
operator|.
name|getDoc
argument_list|()
expr_stmt|;
name|docIn
operator|.
name|seek
argument_list|(
name|skipper
operator|.
name|getDocPointer
argument_list|()
argument_list|)
expr_stmt|;
name|posPendingFP
operator|=
name|skipper
operator|.
name|getPosPointer
argument_list|()
expr_stmt|;
name|posPendingCount
operator|=
name|skipper
operator|.
name|getPosBufferUpto
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Now scan... this is an inlined/pared down version
comment|// of nextDoc():
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  scan doc="
operator|+
name|accum
operator|+
literal|" docBufferUpto="
operator|+
name|docBufferUpto
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|docUpto
operator|==
name|docFreq
condition|)
block|{
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
comment|// nocommit: in theory we should not hit this?  ie
comment|// skipper should already have moved us to the block
comment|// containing the doc?  yet assert false trips ... i
comment|// think because if you advance w/o having done a
comment|// nextDoc yet()... can we assert/remove this?
if|if
condition|(
name|docBufferUpto
operator|==
name|blockSize
condition|)
block|{
comment|// nocommit hmm skip freq?  but: we don't ever
comment|// scan over more than one block?
name|refillDocs
argument_list|()
expr_stmt|;
block|}
name|accum
operator|+=
name|docDeltaBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|freq
operator|=
name|freqBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|posPendingCount
operator|+=
name|freq
expr_stmt|;
name|docBufferUpto
operator|++
expr_stmt|;
name|docUpto
operator|++
expr_stmt|;
if|if
condition|(
name|accum
operator|>=
name|target
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
name|accum
argument_list|)
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  return doc="
operator|+
name|accum
argument_list|)
expr_stmt|;
block|}
name|position
operator|=
literal|0
expr_stmt|;
return|return
name|doc
operator|=
name|accum
return|;
block|}
else|else
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  now do nextDoc()"
argument_list|)
expr_stmt|;
block|}
return|return
name|nextDoc
argument_list|()
return|;
block|}
block|}
comment|// nocommit in theory we could avoid loading frq block
comment|// when not needed, ie, use skip data to load how far to
comment|// seek the pos pointe ... instead of having to load frq
comment|// blocks only to sum up how many positions to skip
DECL|method|skipPositions
specifier|private
name|void
name|skipPositions
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Skip positions now:
name|int
name|toSkip
init|=
name|posPendingCount
operator|-
name|freq
decl_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      FPR.skipPositions: toSkip="
operator|+
name|toSkip
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|leftInBlock
init|=
name|blockSize
operator|-
name|posBufferUpto
decl_stmt|;
if|if
condition|(
name|toSkip
operator|<
name|leftInBlock
condition|)
block|{
name|posBufferUpto
operator|+=
name|toSkip
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"        skip w/in block to posBufferUpto="
operator|+
name|posBufferUpto
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|toSkip
operator|-=
name|leftInBlock
expr_stmt|;
while|while
condition|(
name|toSkip
operator|>=
name|blockSize
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"        skip whole block @ fp="
operator|+
name|posIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|posIn
operator|.
name|getFilePointer
argument_list|()
operator|!=
name|lastPosBlockFP
assert|;
name|skipBlock
argument_list|(
name|posIn
argument_list|)
expr_stmt|;
name|toSkip
operator|-=
name|blockSize
expr_stmt|;
block|}
name|refillPositions
argument_list|()
expr_stmt|;
name|posBufferUpto
operator|=
name|toSkip
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"        skip w/in block to posBufferUpto="
operator|+
name|posBufferUpto
argument_list|)
expr_stmt|;
block|}
block|}
name|position
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|nextPosition
specifier|public
name|int
name|nextPosition
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    FPR.nextPosition posPendingCount="
operator|+
name|posPendingCount
operator|+
literal|" posBufferUpto="
operator|+
name|posBufferUpto
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|posPendingFP
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      seek to pendingFP="
operator|+
name|posPendingFP
argument_list|)
expr_stmt|;
block|}
name|posIn
operator|.
name|seek
argument_list|(
name|posPendingFP
argument_list|)
expr_stmt|;
name|posPendingFP
operator|=
operator|-
literal|1
expr_stmt|;
comment|// Force buffer refill:
name|posBufferUpto
operator|=
name|blockSize
expr_stmt|;
block|}
if|if
condition|(
name|posPendingCount
operator|>
name|freq
condition|)
block|{
name|skipPositions
argument_list|()
expr_stmt|;
name|posPendingCount
operator|=
name|freq
expr_stmt|;
block|}
if|if
condition|(
name|posBufferUpto
operator|==
name|blockSize
condition|)
block|{
name|refillPositions
argument_list|()
expr_stmt|;
name|posBufferUpto
operator|=
literal|0
expr_stmt|;
block|}
name|position
operator|+=
name|posDeltaBuffer
index|[
name|posBufferUpto
operator|++
index|]
expr_stmt|;
name|posPendingCount
operator|--
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      return pos="
operator|+
name|position
argument_list|)
expr_stmt|;
block|}
return|return
name|position
return|;
block|}
annotation|@
name|Override
DECL|method|startOffset
specifier|public
name|int
name|startOffset
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|endOffset
specifier|public
name|int
name|endOffset
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|hasPayload
specifier|public
name|boolean
name|hasPayload
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|getPayload
specifier|public
name|BytesRef
name|getPayload
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// Also handles payloads + offsets
DECL|class|EverythingEnum
specifier|final
class|class
name|EverythingEnum
extends|extends
name|DocsAndPositionsEnum
block|{
DECL|field|encoded
specifier|private
specifier|final
name|byte
index|[]
name|encoded
decl_stmt|;
DECL|field|encodedBuffer
specifier|private
specifier|final
name|IntBuffer
name|encodedBuffer
decl_stmt|;
DECL|field|docDeltaBuffer
specifier|private
specifier|final
name|int
index|[]
name|docDeltaBuffer
init|=
operator|new
name|int
index|[
name|blockSize
index|]
decl_stmt|;
DECL|field|freqBuffer
specifier|private
specifier|final
name|int
index|[]
name|freqBuffer
init|=
operator|new
name|int
index|[
name|blockSize
index|]
decl_stmt|;
DECL|field|posDeltaBuffer
specifier|private
specifier|final
name|int
index|[]
name|posDeltaBuffer
init|=
operator|new
name|int
index|[
name|blockSize
index|]
decl_stmt|;
DECL|field|payloadLengthBuffer
specifier|private
specifier|final
name|int
index|[]
name|payloadLengthBuffer
decl_stmt|;
DECL|field|offsetStartDeltaBuffer
specifier|private
specifier|final
name|int
index|[]
name|offsetStartDeltaBuffer
decl_stmt|;
DECL|field|offsetLengthBuffer
specifier|private
specifier|final
name|int
index|[]
name|offsetLengthBuffer
decl_stmt|;
DECL|field|payloadBytes
specifier|private
name|byte
index|[]
name|payloadBytes
decl_stmt|;
DECL|field|payloadByteUpto
specifier|private
name|int
name|payloadByteUpto
decl_stmt|;
DECL|field|payloadLength
specifier|private
name|int
name|payloadLength
decl_stmt|;
DECL|field|lastStartOffset
specifier|private
name|int
name|lastStartOffset
decl_stmt|;
DECL|field|startOffset
specifier|private
name|int
name|startOffset
decl_stmt|;
DECL|field|endOffset
specifier|private
name|int
name|endOffset
decl_stmt|;
DECL|field|docBufferUpto
specifier|private
name|int
name|docBufferUpto
decl_stmt|;
DECL|field|posBufferUpto
specifier|private
name|int
name|posBufferUpto
decl_stmt|;
DECL|field|skipper
specifier|private
name|BlockSkipReader
name|skipper
decl_stmt|;
DECL|field|skipped
specifier|private
name|boolean
name|skipped
decl_stmt|;
DECL|field|startDocIn
specifier|final
name|IndexInput
name|startDocIn
decl_stmt|;
DECL|field|docIn
specifier|final
name|IndexInput
name|docIn
decl_stmt|;
DECL|field|posIn
specifier|final
name|IndexInput
name|posIn
decl_stmt|;
DECL|field|payIn
specifier|final
name|IndexInput
name|payIn
decl_stmt|;
DECL|field|payload
specifier|final
name|BytesRef
name|payload
decl_stmt|;
DECL|field|indexHasOffsets
specifier|final
name|boolean
name|indexHasOffsets
decl_stmt|;
DECL|field|indexHasPayloads
specifier|final
name|boolean
name|indexHasPayloads
decl_stmt|;
DECL|field|docFreq
specifier|private
name|int
name|docFreq
decl_stmt|;
comment|// number of docs in this posting list
DECL|field|docUpto
specifier|private
name|int
name|docUpto
decl_stmt|;
comment|// how many docs we've read
DECL|field|doc
specifier|private
name|int
name|doc
decl_stmt|;
comment|// doc we last read
DECL|field|accum
specifier|private
name|int
name|accum
decl_stmt|;
comment|// accumulator for doc deltas
DECL|field|freq
specifier|private
name|int
name|freq
decl_stmt|;
comment|// freq we last read
DECL|field|position
specifier|private
name|int
name|position
decl_stmt|;
comment|// current position
comment|// how many positions "behind" we are; nextPosition must
comment|// skip these to "catch up":
DECL|field|posPendingCount
specifier|private
name|int
name|posPendingCount
decl_stmt|;
comment|// Lazy pos seek: if != -1 then we must seek to this FP
comment|// before reading positions:
DECL|field|posPendingFP
specifier|private
name|long
name|posPendingFP
decl_stmt|;
comment|// Lazy pay seek: if != -1 then we must seek to this FP
comment|// before reading payloads/offsets:
DECL|field|payPendingFP
specifier|private
name|long
name|payPendingFP
decl_stmt|;
comment|// Where this term's postings start in the .doc file:
DECL|field|docTermStartFP
specifier|private
name|long
name|docTermStartFP
decl_stmt|;
comment|// Where this term's postings start in the .pos file:
DECL|field|posTermStartFP
specifier|private
name|long
name|posTermStartFP
decl_stmt|;
comment|// Where this term's payloads/offsets start in the .pay
comment|// file:
DECL|field|payTermStartFP
specifier|private
name|long
name|payTermStartFP
decl_stmt|;
comment|// File pointer where the last (vInt encoded) pos delta
comment|// block is.  We need this to know whether to bulk
comment|// decode vs vInt decode the block:
DECL|field|lastPosBlockFP
specifier|private
name|long
name|lastPosBlockFP
decl_stmt|;
comment|// Where this term's skip data starts (after
comment|// docTermStartFP) in the .doc file (or -1 if there is
comment|// no skip data for this term):
DECL|field|skipOffset
specifier|private
name|int
name|skipOffset
decl_stmt|;
DECL|field|liveDocs
specifier|private
name|Bits
name|liveDocs
decl_stmt|;
DECL|method|EverythingEnum
specifier|public
name|EverythingEnum
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|startDocIn
operator|=
name|BlockPostingsReader
operator|.
name|this
operator|.
name|docIn
expr_stmt|;
name|this
operator|.
name|docIn
operator|=
operator|(
name|IndexInput
operator|)
name|startDocIn
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|posIn
operator|=
operator|(
name|IndexInput
operator|)
name|BlockPostingsReader
operator|.
name|this
operator|.
name|posIn
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|payIn
operator|=
operator|(
name|IndexInput
operator|)
name|BlockPostingsReader
operator|.
name|this
operator|.
name|payIn
operator|.
name|clone
argument_list|()
expr_stmt|;
name|encoded
operator|=
operator|new
name|byte
index|[
name|blockSize
operator|*
literal|4
index|]
expr_stmt|;
name|encodedBuffer
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|encoded
argument_list|)
operator|.
name|asIntBuffer
argument_list|()
expr_stmt|;
name|indexHasOffsets
operator|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|indexHasOffsets
condition|)
block|{
name|offsetStartDeltaBuffer
operator|=
operator|new
name|int
index|[
name|blockSize
index|]
expr_stmt|;
name|offsetLengthBuffer
operator|=
operator|new
name|int
index|[
name|blockSize
index|]
expr_stmt|;
block|}
else|else
block|{
name|offsetStartDeltaBuffer
operator|=
literal|null
expr_stmt|;
name|offsetLengthBuffer
operator|=
literal|null
expr_stmt|;
name|startOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|endOffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|indexHasPayloads
operator|=
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
expr_stmt|;
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
name|payloadLengthBuffer
operator|=
operator|new
name|int
index|[
name|blockSize
index|]
expr_stmt|;
name|payloadBytes
operator|=
operator|new
name|byte
index|[
literal|128
index|]
expr_stmt|;
name|payload
operator|=
operator|new
name|BytesRef
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|payloadLengthBuffer
operator|=
literal|null
expr_stmt|;
name|payloadBytes
operator|=
literal|null
expr_stmt|;
name|payload
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|canReuse
specifier|public
name|boolean
name|canReuse
parameter_list|(
name|IndexInput
name|docIn
parameter_list|,
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
return|return
name|docIn
operator|==
name|startDocIn
operator|&&
name|indexHasOffsets
operator|==
operator|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
name|indexHasPayloads
operator|==
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
return|;
block|}
DECL|method|reset
specifier|public
name|EverythingEnum
name|reset
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|IntBlockTermState
name|termState
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  FPR.reset: termState="
operator|+
name|termState
argument_list|)
expr_stmt|;
block|}
name|docFreq
operator|=
name|termState
operator|.
name|docFreq
expr_stmt|;
name|docTermStartFP
operator|=
name|termState
operator|.
name|docStartFP
expr_stmt|;
name|posTermStartFP
operator|=
name|termState
operator|.
name|posStartFP
expr_stmt|;
name|payTermStartFP
operator|=
name|termState
operator|.
name|payStartFP
expr_stmt|;
name|docIn
operator|.
name|seek
argument_list|(
name|docTermStartFP
argument_list|)
expr_stmt|;
name|skipOffset
operator|=
name|termState
operator|.
name|skipOffset
expr_stmt|;
name|posPendingFP
operator|=
name|posTermStartFP
expr_stmt|;
name|payPendingFP
operator|=
name|payTermStartFP
expr_stmt|;
name|posPendingCount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|termState
operator|.
name|totalTermFreq
operator|<
name|blockSize
condition|)
block|{
name|lastPosBlockFP
operator|=
name|posTermStartFP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|termState
operator|.
name|totalTermFreq
operator|==
name|blockSize
condition|)
block|{
name|lastPosBlockFP
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lastPosBlockFP
operator|=
name|posTermStartFP
operator|+
name|termState
operator|.
name|lastPosBlockOffset
expr_stmt|;
block|}
name|doc
operator|=
operator|-
literal|1
expr_stmt|;
name|accum
operator|=
literal|0
expr_stmt|;
name|docUpto
operator|=
literal|0
expr_stmt|;
name|docBufferUpto
operator|=
name|blockSize
expr_stmt|;
name|skipped
operator|=
literal|false
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|freq
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
DECL|method|refillDocs
specifier|private
name|void
name|refillDocs
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.out.println("["+docFreq+"]"+" refillDoc");
specifier|final
name|int
name|left
init|=
name|docFreq
operator|-
name|docUpto
decl_stmt|;
assert|assert
name|left
operator|>
literal|0
assert|;
if|if
condition|(
name|left
operator|>=
name|blockSize
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    fill doc block from fp="
operator|+
name|docIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|readBlock
argument_list|(
name|docIn
argument_list|,
name|encoded
argument_list|,
name|encodedBuffer
argument_list|,
name|docDeltaBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    fill freq block from fp="
operator|+
name|docIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|readBlock
argument_list|(
name|docIn
argument_list|,
name|encoded
argument_list|,
name|encodedBuffer
argument_list|,
name|freqBuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    fill last vInt doc block from fp="
operator|+
name|docIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|readVIntBlock
argument_list|(
name|docIn
argument_list|,
name|docDeltaBuffer
argument_list|,
name|freqBuffer
argument_list|,
name|left
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|docBufferUpto
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|refillPositions
specifier|private
name|void
name|refillPositions
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      refillPositions"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|posIn
operator|.
name|getFilePointer
argument_list|()
operator|==
name|lastPosBlockFP
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"        vInt pos block @ fp="
operator|+
name|posIn
operator|.
name|getFilePointer
argument_list|()
operator|+
literal|" hasPayloads="
operator|+
name|indexHasPayloads
operator|+
literal|" hasOffsets="
operator|+
name|indexHasOffsets
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|count
init|=
name|posIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|int
name|payloadLength
init|=
literal|0
decl_stmt|;
name|payloadByteUpto
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|code
init|=
name|posIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|payloadLength
operator|=
name|posIn
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"        i="
operator|+
name|i
operator|+
literal|" payloadLen="
operator|+
name|payloadLength
argument_list|)
expr_stmt|;
block|}
name|payloadLengthBuffer
index|[
name|i
index|]
operator|=
name|payloadLength
expr_stmt|;
name|posDeltaBuffer
index|[
name|i
index|]
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
if|if
condition|(
name|payloadLength
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|payloadByteUpto
operator|+
name|payloadLength
operator|>
name|payloadBytes
operator|.
name|length
condition|)
block|{
name|payloadBytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|payloadBytes
argument_list|,
name|payloadByteUpto
operator|+
name|payloadLength
argument_list|)
expr_stmt|;
block|}
comment|//System.out.println("          read payload @ pos.fp=" + posIn.getFilePointer());
name|posIn
operator|.
name|readBytes
argument_list|(
name|payloadBytes
argument_list|,
name|payloadByteUpto
argument_list|,
name|payloadLength
argument_list|)
expr_stmt|;
name|payloadByteUpto
operator|+=
name|payloadLength
expr_stmt|;
block|}
block|}
else|else
block|{
name|posDeltaBuffer
index|[
name|i
index|]
operator|=
name|code
expr_stmt|;
block|}
if|if
condition|(
name|indexHasOffsets
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"        i="
operator|+
name|i
operator|+
literal|" read offsets from posIn.fp="
operator|+
name|posIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|offsetStartDeltaBuffer
index|[
name|i
index|]
operator|=
name|posIn
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|offsetLengthBuffer
index|[
name|i
index|]
operator|=
name|posIn
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"          startOffDelta="
operator|+
name|offsetStartDeltaBuffer
index|[
name|i
index|]
operator|+
literal|" offsetLen="
operator|+
name|offsetLengthBuffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|payloadByteUpto
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"        bulk pos block @ fp="
operator|+
name|posIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|readBlock
argument_list|(
name|posIn
argument_list|,
name|encoded
argument_list|,
name|encodedBuffer
argument_list|,
name|posDeltaBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"        bulk payload block @ pay.fp="
operator|+
name|payIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|readBlock
argument_list|(
name|payIn
argument_list|,
name|encoded
argument_list|,
name|encodedBuffer
argument_list|,
name|payloadLengthBuffer
argument_list|)
expr_stmt|;
name|int
name|numBytes
init|=
name|payIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"        "
operator|+
name|numBytes
operator|+
literal|" payload bytes @ pay.fp="
operator|+
name|payIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numBytes
operator|>
name|payloadBytes
operator|.
name|length
condition|)
block|{
name|payloadBytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|payloadBytes
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
block|}
name|payIn
operator|.
name|readBytes
argument_list|(
name|payloadBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|payloadByteUpto
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|indexHasOffsets
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"        bulk offset block @ pay.fp="
operator|+
name|payIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|readBlock
argument_list|(
name|payIn
argument_list|,
name|encoded
argument_list|,
name|encodedBuffer
argument_list|,
name|offsetStartDeltaBuffer
argument_list|)
expr_stmt|;
name|readBlock
argument_list|(
name|payIn
argument_list|,
name|encoded
argument_list|,
name|encodedBuffer
argument_list|,
name|offsetLengthBuffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  FPR.nextDoc"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
name|payloadByteUpto
operator|+=
name|payloadLength
expr_stmt|;
name|payloadLength
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    docUpto="
operator|+
name|docUpto
operator|+
literal|" (of df="
operator|+
name|docFreq
operator|+
literal|") docBufferUpto="
operator|+
name|docBufferUpto
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|docUpto
operator|==
name|docFreq
condition|)
block|{
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
comment|//System.out.println("["+docFreq+"]"+" nextDoc");
if|if
condition|(
name|docBufferUpto
operator|==
name|blockSize
condition|)
block|{
name|refillDocs
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    accum="
operator|+
name|accum
operator|+
literal|" docDeltaBuffer["
operator|+
name|docBufferUpto
operator|+
literal|"]="
operator|+
name|docDeltaBuffer
index|[
name|docBufferUpto
index|]
argument_list|)
expr_stmt|;
block|}
name|accum
operator|+=
name|docDeltaBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|freq
operator|=
name|freqBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|posPendingCount
operator|+=
name|freq
expr_stmt|;
name|docBufferUpto
operator|++
expr_stmt|;
name|docUpto
operator|++
expr_stmt|;
if|if
condition|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
name|accum
argument_list|)
condition|)
block|{
name|doc
operator|=
name|accum
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    return doc="
operator|+
name|doc
operator|+
literal|" freq="
operator|+
name|freq
operator|+
literal|" posPendingCount="
operator|+
name|posPendingCount
argument_list|)
expr_stmt|;
block|}
name|position
operator|=
literal|0
expr_stmt|;
name|payloadLength
operator|=
literal|0
expr_stmt|;
name|lastStartOffset
operator|=
literal|0
expr_stmt|;
return|return
name|doc
return|;
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    doc="
operator|+
name|accum
operator|+
literal|" is deleted; try next doc"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
comment|// nocommit make frq block load lazy/skippable
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  FPR.advance target="
operator|+
name|target
argument_list|)
expr_stmt|;
block|}
comment|// nocommit 2 is heuristic guess!!
comment|// nocommit put cheating back!  does it help?
comment|// nocommit use skipper!!!  it has next last doc id!!
comment|//if (docFreq> blockSize&& target - (blockSize - docBufferUpto) - 2*blockSize> accum) {
if|if
condition|(
name|docFreq
operator|>
name|blockSize
operator|&&
name|target
operator|-
name|accum
operator|>
name|blockSize
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    try skipper"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|skipper
operator|==
literal|null
condition|)
block|{
comment|// Lazy init: first time this enum has ever been used for skipping
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    create skipper"
argument_list|)
expr_stmt|;
block|}
name|skipper
operator|=
operator|new
name|BlockSkipReader
argument_list|(
operator|(
name|IndexInput
operator|)
name|docIn
operator|.
name|clone
argument_list|()
argument_list|,
name|BlockPostingsWriter
operator|.
name|maxSkipLevels
argument_list|,
name|blockSize
argument_list|,
literal|true
argument_list|,
name|indexHasOffsets
argument_list|,
name|indexHasPayloads
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skipped
condition|)
block|{
assert|assert
name|skipOffset
operator|!=
operator|-
literal|1
assert|;
comment|// This is the first time this enum has skipped
comment|// since reset() was called; load the skip data:
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    init skipper"
argument_list|)
expr_stmt|;
block|}
name|skipper
operator|.
name|init
argument_list|(
name|docTermStartFP
operator|+
name|skipOffset
argument_list|,
name|docTermStartFP
argument_list|,
name|posTermStartFP
argument_list|,
name|payTermStartFP
argument_list|,
name|docFreq
argument_list|)
expr_stmt|;
name|skipped
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|int
name|newDocUpto
init|=
name|skipper
operator|.
name|skipTo
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDocUpto
operator|>
name|docUpto
condition|)
block|{
comment|// Skipper moved
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    skipper moved to docUpto="
operator|+
name|newDocUpto
operator|+
literal|" vs current="
operator|+
name|docUpto
operator|+
literal|"; docID="
operator|+
name|skipper
operator|.
name|getDoc
argument_list|()
operator|+
literal|" fp="
operator|+
name|skipper
operator|.
name|getDocPointer
argument_list|()
operator|+
literal|" pos.fp="
operator|+
name|skipper
operator|.
name|getPosPointer
argument_list|()
operator|+
literal|" pos.bufferUpto="
operator|+
name|skipper
operator|.
name|getPosBufferUpto
argument_list|()
operator|+
literal|" pay.fp="
operator|+
name|skipper
operator|.
name|getPayPointer
argument_list|()
operator|+
literal|" lastStartOffset="
operator|+
name|lastStartOffset
argument_list|)
expr_stmt|;
block|}
assert|assert
name|newDocUpto
operator|%
name|blockSize
operator|==
operator|(
name|blockSize
operator|-
literal|1
operator|)
operator|:
literal|"got "
operator|+
name|newDocUpto
assert|;
name|docUpto
operator|=
name|newDocUpto
operator|+
literal|1
expr_stmt|;
comment|// Force to read next block
name|docBufferUpto
operator|=
name|blockSize
expr_stmt|;
name|accum
operator|=
name|skipper
operator|.
name|getDoc
argument_list|()
expr_stmt|;
name|docIn
operator|.
name|seek
argument_list|(
name|skipper
operator|.
name|getDocPointer
argument_list|()
argument_list|)
expr_stmt|;
name|posPendingFP
operator|=
name|skipper
operator|.
name|getPosPointer
argument_list|()
expr_stmt|;
name|payPendingFP
operator|=
name|skipper
operator|.
name|getPayPointer
argument_list|()
expr_stmt|;
name|posPendingCount
operator|=
name|skipper
operator|.
name|getPosBufferUpto
argument_list|()
expr_stmt|;
name|lastStartOffset
operator|=
name|skipper
operator|.
name|getStartOffset
argument_list|()
expr_stmt|;
name|payloadByteUpto
operator|=
name|skipper
operator|.
name|getPayloadByteUpto
argument_list|()
expr_stmt|;
block|}
block|}
comment|// nocommit inline nextDoc here
comment|// Now scan:
while|while
condition|(
name|nextDoc
argument_list|()
operator|!=
name|NO_MORE_DOCS
condition|)
block|{
if|if
condition|(
name|doc
operator|>=
name|target
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  advance return doc="
operator|+
name|doc
argument_list|)
expr_stmt|;
block|}
return|return
name|doc
return|;
block|}
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  advance return doc=END"
argument_list|)
expr_stmt|;
block|}
return|return
name|NO_MORE_DOCS
return|;
block|}
comment|// nocommit in theory we could avoid loading frq block
comment|// when not needed, ie, use skip data to load how far to
comment|// seek the pos pointe ... instead of having to load frq
comment|// blocks only to sum up how many positions to skip
DECL|method|skipPositions
specifier|private
name|void
name|skipPositions
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Skip positions now:
name|int
name|toSkip
init|=
name|posPendingCount
operator|-
name|freq
decl_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      FPR.skipPositions: toSkip="
operator|+
name|toSkip
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|leftInBlock
init|=
name|blockSize
operator|-
name|posBufferUpto
decl_stmt|;
if|if
condition|(
name|toSkip
operator|<
name|leftInBlock
condition|)
block|{
name|int
name|end
init|=
name|posBufferUpto
operator|+
name|toSkip
decl_stmt|;
while|while
condition|(
name|posBufferUpto
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
name|payloadByteUpto
operator|+=
name|payloadLengthBuffer
index|[
name|posBufferUpto
index|]
expr_stmt|;
block|}
if|if
condition|(
name|indexHasOffsets
condition|)
block|{
name|lastStartOffset
operator|+=
name|offsetStartDeltaBuffer
index|[
name|posBufferUpto
index|]
operator|+
name|offsetLengthBuffer
index|[
name|posBufferUpto
index|]
expr_stmt|;
block|}
name|posBufferUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"        skip w/in block to posBufferUpto="
operator|+
name|posBufferUpto
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|toSkip
operator|-=
name|leftInBlock
expr_stmt|;
while|while
condition|(
name|toSkip
operator|>=
name|blockSize
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"        skip whole block @ fp="
operator|+
name|posIn
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|posIn
operator|.
name|getFilePointer
argument_list|()
operator|!=
name|lastPosBlockFP
assert|;
name|skipBlock
argument_list|(
name|posIn
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
comment|// Skip payloadLength block:
name|skipBlock
argument_list|(
name|payIn
argument_list|)
expr_stmt|;
comment|// Skip payloadBytes block:
name|int
name|numBytes
init|=
name|payIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|payIn
operator|.
name|seek
argument_list|(
name|payIn
operator|.
name|getFilePointer
argument_list|()
operator|+
name|numBytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indexHasOffsets
condition|)
block|{
comment|// Must load offset blocks merely to sum
comment|// up into lastStartOffset:
name|readBlock
argument_list|(
name|payIn
argument_list|,
name|encoded
argument_list|,
name|encodedBuffer
argument_list|,
name|offsetStartDeltaBuffer
argument_list|)
expr_stmt|;
name|readBlock
argument_list|(
name|payIn
argument_list|,
name|encoded
argument_list|,
name|encodedBuffer
argument_list|,
name|offsetLengthBuffer
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockSize
condition|;
name|i
operator|++
control|)
block|{
name|lastStartOffset
operator|+=
name|offsetStartDeltaBuffer
index|[
name|i
index|]
operator|+
name|offsetLengthBuffer
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|toSkip
operator|-=
name|blockSize
expr_stmt|;
block|}
name|refillPositions
argument_list|()
expr_stmt|;
name|payloadByteUpto
operator|=
literal|0
expr_stmt|;
name|posBufferUpto
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|posBufferUpto
operator|<
name|toSkip
condition|)
block|{
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
name|payloadByteUpto
operator|+=
name|payloadLengthBuffer
index|[
name|posBufferUpto
index|]
expr_stmt|;
block|}
if|if
condition|(
name|indexHasOffsets
condition|)
block|{
name|lastStartOffset
operator|+=
name|offsetStartDeltaBuffer
index|[
name|posBufferUpto
index|]
operator|+
name|offsetLengthBuffer
index|[
name|posBufferUpto
index|]
expr_stmt|;
block|}
name|posBufferUpto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"        skip w/in block to posBufferUpto="
operator|+
name|posBufferUpto
argument_list|)
expr_stmt|;
block|}
block|}
name|position
operator|=
literal|0
expr_stmt|;
name|payloadLength
operator|=
literal|0
expr_stmt|;
comment|// nocommit why carefully sum up lastStartOffset above
comment|// only to set it to 0 now?
name|lastStartOffset
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|nextPosition
specifier|public
name|int
name|nextPosition
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    FPR.nextPosition posPendingCount="
operator|+
name|posPendingCount
operator|+
literal|" posBufferUpto="
operator|+
name|posBufferUpto
operator|+
literal|" payloadByteUpto="
operator|+
name|payloadByteUpto
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|posPendingFP
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      seek pos to pendingFP="
operator|+
name|posPendingFP
argument_list|)
expr_stmt|;
block|}
name|posIn
operator|.
name|seek
argument_list|(
name|posPendingFP
argument_list|)
expr_stmt|;
name|posPendingFP
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|payPendingFP
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      seek pay to pendingFP="
operator|+
name|payPendingFP
argument_list|)
expr_stmt|;
block|}
name|payIn
operator|.
name|seek
argument_list|(
name|payPendingFP
argument_list|)
expr_stmt|;
name|payPendingFP
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|// Force buffer refill:
name|posBufferUpto
operator|=
name|blockSize
expr_stmt|;
block|}
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
if|if
condition|(
name|payloadLength
operator|!=
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      skip unread payload length="
operator|+
name|payloadLength
argument_list|)
expr_stmt|;
block|}
block|}
name|payloadByteUpto
operator|+=
name|payloadLength
expr_stmt|;
name|payloadLength
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|posPendingCount
operator|>
name|freq
condition|)
block|{
name|skipPositions
argument_list|()
expr_stmt|;
name|posPendingCount
operator|=
name|freq
expr_stmt|;
block|}
if|if
condition|(
name|posBufferUpto
operator|==
name|blockSize
condition|)
block|{
name|refillPositions
argument_list|()
expr_stmt|;
name|posBufferUpto
operator|=
literal|0
expr_stmt|;
block|}
name|position
operator|+=
name|posDeltaBuffer
index|[
name|posBufferUpto
index|]
expr_stmt|;
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
name|payloadLength
operator|=
name|payloadLengthBuffer
index|[
name|posBufferUpto
index|]
expr_stmt|;
block|}
if|if
condition|(
name|indexHasOffsets
condition|)
block|{
name|startOffset
operator|=
name|lastStartOffset
operator|+
name|offsetStartDeltaBuffer
index|[
name|posBufferUpto
index|]
expr_stmt|;
name|endOffset
operator|=
name|startOffset
operator|+
name|offsetLengthBuffer
index|[
name|posBufferUpto
index|]
expr_stmt|;
name|lastStartOffset
operator|=
name|startOffset
expr_stmt|;
block|}
name|posBufferUpto
operator|++
expr_stmt|;
name|posPendingCount
operator|--
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      return pos="
operator|+
name|position
argument_list|)
expr_stmt|;
block|}
return|return
name|position
return|;
block|}
annotation|@
name|Override
DECL|method|startOffset
specifier|public
name|int
name|startOffset
parameter_list|()
block|{
return|return
name|startOffset
return|;
block|}
annotation|@
name|Override
DECL|method|endOffset
specifier|public
name|int
name|endOffset
parameter_list|()
block|{
return|return
name|endOffset
return|;
block|}
annotation|@
name|Override
DECL|method|hasPayload
specifier|public
name|boolean
name|hasPayload
parameter_list|()
block|{
return|return
name|payloadLength
operator|!=
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|getPayload
specifier|public
name|BytesRef
name|getPayload
parameter_list|()
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    FPR.getPayload payloadLength="
operator|+
name|payloadLength
operator|+
literal|" payloadByteUpto="
operator|+
name|payloadByteUpto
argument_list|)
expr_stmt|;
block|}
name|payload
operator|.
name|bytes
operator|=
name|payloadBytes
expr_stmt|;
name|payload
operator|.
name|offset
operator|=
name|payloadByteUpto
expr_stmt|;
name|payload
operator|.
name|length
operator|=
name|payloadLength
expr_stmt|;
name|payloadByteUpto
operator|+=
name|payloadLength
expr_stmt|;
name|payloadLength
operator|=
literal|0
expr_stmt|;
return|return
name|payload
return|;
block|}
block|}
block|}
end_class
end_unit
