begin_unit
begin_package
DECL|package|org.apache.lucene.codecs
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFileNames
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentWriteState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RAMOutputStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Builder
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|ByteSequenceOutputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|BytesRefFSTEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FST
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|NoOutputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Util
import|;
end_import
begin_comment
comment|/*   TODO:        - Currently there is a one-to-one mapping of indexed       term to term block, but we could decouple the two, ie,       put more terms into the index than there are blocks.       The index would take up more RAM but then it'd be able       to avoid seeking more often and could make PK/FuzzyQ       faster if the additional indexed terms could store       the offset into the terms block.      - The blocks are not written in true depth-first       order, meaning if you just next() the file pointer will       sometimes jump backwards.  For example, block foo* will       be written before block f* because it finished before.       This could possibly hurt performance if the terms dict is       not hot, since OSs anticipate sequential file access.  We       could fix the writer to re-order the blocks as a 2nd       pass.      - Each block encodes the term suffixes packed       sequentially using a separate vInt per term, which is       1) wasteful and 2) slow (must linear scan to find a       particular suffix).  We should instead 1) make       random-access array so we can directly access the Nth       suffix, and 2) bulk-encode this array using bulk int[]       codecs; then at search time we can binary search when       we seek a particular term. */
end_comment
begin_comment
comment|/**  * block-based terms index and dictionary writer.  *<p>  * Writes terms dict and index, block-encoding (column  * stride) each term's metadata for each set of terms  * between two index terms.  *  * @see BlockTreeTermsReader  * @lucene.experimental  */
end_comment
begin_class
DECL|class|BlockTreeTermsWriter
specifier|public
class|class
name|BlockTreeTermsWriter
extends|extends
name|FieldsConsumer
block|{
DECL|field|DEFAULT_MIN_BLOCK_SIZE
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MIN_BLOCK_SIZE
init|=
literal|25
decl_stmt|;
DECL|field|DEFAULT_MAX_BLOCK_SIZE
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_BLOCK_SIZE
init|=
literal|48
decl_stmt|;
comment|//public final static boolean DEBUG = false;
DECL|field|SAVE_DOT_FILES
specifier|public
specifier|final
specifier|static
name|boolean
name|SAVE_DOT_FILES
init|=
literal|false
decl_stmt|;
DECL|field|OUTPUT_FLAGS_NUM_BITS
specifier|static
specifier|final
name|int
name|OUTPUT_FLAGS_NUM_BITS
init|=
literal|2
decl_stmt|;
DECL|field|OUTPUT_FLAGS_MASK
specifier|static
specifier|final
name|int
name|OUTPUT_FLAGS_MASK
init|=
literal|0x3
decl_stmt|;
DECL|field|OUTPUT_FLAG_IS_FLOOR
specifier|static
specifier|final
name|int
name|OUTPUT_FLAG_IS_FLOOR
init|=
literal|0x1
decl_stmt|;
DECL|field|OUTPUT_FLAG_HAS_TERMS
specifier|static
specifier|final
name|int
name|OUTPUT_FLAG_HAS_TERMS
init|=
literal|0x2
decl_stmt|;
comment|/** Extension of terms file */
DECL|field|TERMS_EXTENSION
specifier|static
specifier|final
name|String
name|TERMS_EXTENSION
init|=
literal|"tim"
decl_stmt|;
DECL|field|TERMS_CODEC_NAME
specifier|final
specifier|static
name|String
name|TERMS_CODEC_NAME
init|=
literal|"BLOCK_TREE_TERMS_DICT"
decl_stmt|;
comment|// Initial format
DECL|field|TERMS_VERSION_START
specifier|public
specifier|static
specifier|final
name|int
name|TERMS_VERSION_START
init|=
literal|0
decl_stmt|;
DECL|field|TERMS_VERSION_CURRENT
specifier|public
specifier|static
specifier|final
name|int
name|TERMS_VERSION_CURRENT
init|=
name|TERMS_VERSION_START
decl_stmt|;
comment|/** Extension of terms index file */
DECL|field|TERMS_INDEX_EXTENSION
specifier|static
specifier|final
name|String
name|TERMS_INDEX_EXTENSION
init|=
literal|"tip"
decl_stmt|;
DECL|field|TERMS_INDEX_CODEC_NAME
specifier|final
specifier|static
name|String
name|TERMS_INDEX_CODEC_NAME
init|=
literal|"BLOCK_TREE_TERMS_INDEX"
decl_stmt|;
comment|// Initial format
DECL|field|TERMS_INDEX_VERSION_START
specifier|public
specifier|static
specifier|final
name|int
name|TERMS_INDEX_VERSION_START
init|=
literal|0
decl_stmt|;
DECL|field|TERMS_INDEX_VERSION_CURRENT
specifier|public
specifier|static
specifier|final
name|int
name|TERMS_INDEX_VERSION_CURRENT
init|=
name|TERMS_INDEX_VERSION_START
decl_stmt|;
DECL|field|out
specifier|private
specifier|final
name|IndexOutput
name|out
decl_stmt|;
DECL|field|indexOut
specifier|private
specifier|final
name|IndexOutput
name|indexOut
decl_stmt|;
DECL|field|minItemsInBlock
specifier|final
name|int
name|minItemsInBlock
decl_stmt|;
DECL|field|maxItemsInBlock
specifier|final
name|int
name|maxItemsInBlock
decl_stmt|;
DECL|field|postingsWriter
specifier|final
name|PostingsWriterBase
name|postingsWriter
decl_stmt|;
DECL|field|fieldInfos
specifier|final
name|FieldInfos
name|fieldInfos
decl_stmt|;
DECL|field|currentField
name|FieldInfo
name|currentField
decl_stmt|;
DECL|field|fields
specifier|private
specifier|final
name|List
argument_list|<
name|TermsWriter
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<
name|TermsWriter
argument_list|>
argument_list|()
decl_stmt|;
comment|// private final String segment;
comment|/** Create a new writer.  The number of items (terms or    *  sub-blocks) per block will aim to be between    *  minItemsPerBlock and maxItemsPerBlock, though in some    *  cases the blocks may be smaller than the min. */
DECL|method|BlockTreeTermsWriter
specifier|public
name|BlockTreeTermsWriter
parameter_list|(
name|SegmentWriteState
name|state
parameter_list|,
name|PostingsWriterBase
name|postingsWriter
parameter_list|,
name|int
name|minItemsInBlock
parameter_list|,
name|int
name|maxItemsInBlock
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|minItemsInBlock
operator|<=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"minItemsInBlock must be>= 2; got "
operator|+
name|minItemsInBlock
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxItemsInBlock
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxItemsInBlock must be>= 1; got "
operator|+
name|maxItemsInBlock
argument_list|)
throw|;
block|}
if|if
condition|(
name|minItemsInBlock
operator|>
name|maxItemsInBlock
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxItemsInBlock must be>= minItemsInBlock; got maxItemsInBlock="
operator|+
name|maxItemsInBlock
operator|+
literal|" minItemsInBlock="
operator|+
name|minItemsInBlock
argument_list|)
throw|;
block|}
if|if
condition|(
literal|2
operator|*
operator|(
name|minItemsInBlock
operator|-
literal|1
operator|)
operator|>
name|maxItemsInBlock
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxItemsInBlock must be at least 2*(minItemsInBlock-1); got maxItemsInBlock="
operator|+
name|maxItemsInBlock
operator|+
literal|" minItemsInBlock="
operator|+
name|minItemsInBlock
argument_list|)
throw|;
block|}
specifier|final
name|String
name|termsFileName
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|state
operator|.
name|segmentInfo
operator|.
name|name
argument_list|,
name|state
operator|.
name|segmentSuffix
argument_list|,
name|TERMS_EXTENSION
argument_list|)
decl_stmt|;
name|out
operator|=
name|state
operator|.
name|directory
operator|.
name|createOutput
argument_list|(
name|termsFileName
argument_list|,
name|state
operator|.
name|context
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|IndexOutput
name|indexOut
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fieldInfos
operator|=
name|state
operator|.
name|fieldInfos
expr_stmt|;
name|this
operator|.
name|minItemsInBlock
operator|=
name|minItemsInBlock
expr_stmt|;
name|this
operator|.
name|maxItemsInBlock
operator|=
name|maxItemsInBlock
expr_stmt|;
name|writeHeader
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|//DEBUG = state.segmentName.equals("_4a");
specifier|final
name|String
name|termsIndexFileName
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|state
operator|.
name|segmentInfo
operator|.
name|name
argument_list|,
name|state
operator|.
name|segmentSuffix
argument_list|,
name|TERMS_INDEX_EXTENSION
argument_list|)
decl_stmt|;
name|indexOut
operator|=
name|state
operator|.
name|directory
operator|.
name|createOutput
argument_list|(
name|termsIndexFileName
argument_list|,
name|state
operator|.
name|context
argument_list|)
expr_stmt|;
name|writeIndexHeader
argument_list|(
name|indexOut
argument_list|)
expr_stmt|;
name|currentField
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|postingsWriter
operator|=
name|postingsWriter
expr_stmt|;
comment|// segment = state.segmentName;
comment|// System.out.println("BTW.init seg=" + state.segmentName);
name|postingsWriter
operator|.
name|start
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// have consumer write its format/header
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|out
argument_list|,
name|indexOut
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|indexOut
operator|=
name|indexOut
expr_stmt|;
block|}
DECL|method|writeHeader
specifier|protected
name|void
name|writeHeader
parameter_list|(
name|IndexOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|CodecUtil
operator|.
name|writeHeader
argument_list|(
name|out
argument_list|,
name|TERMS_CODEC_NAME
argument_list|,
name|TERMS_VERSION_CURRENT
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// leave space for end index pointer
block|}
DECL|method|writeIndexHeader
specifier|protected
name|void
name|writeIndexHeader
parameter_list|(
name|IndexOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|CodecUtil
operator|.
name|writeHeader
argument_list|(
name|out
argument_list|,
name|TERMS_INDEX_CODEC_NAME
argument_list|,
name|TERMS_INDEX_VERSION_CURRENT
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// leave space for end index pointer
block|}
DECL|method|writeTrailer
specifier|protected
name|void
name|writeTrailer
parameter_list|(
name|IndexOutput
name|out
parameter_list|,
name|long
name|dirStart
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|seek
argument_list|(
name|CodecUtil
operator|.
name|headerLength
argument_list|(
name|TERMS_CODEC_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeLong
argument_list|(
name|dirStart
argument_list|)
expr_stmt|;
block|}
DECL|method|writeIndexTrailer
specifier|protected
name|void
name|writeIndexTrailer
parameter_list|(
name|IndexOutput
name|indexOut
parameter_list|,
name|long
name|dirStart
parameter_list|)
throws|throws
name|IOException
block|{
name|indexOut
operator|.
name|seek
argument_list|(
name|CodecUtil
operator|.
name|headerLength
argument_list|(
name|TERMS_INDEX_CODEC_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|indexOut
operator|.
name|writeLong
argument_list|(
name|dirStart
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|addField
specifier|public
name|TermsConsumer
name|addField
parameter_list|(
name|FieldInfo
name|field
parameter_list|)
throws|throws
name|IOException
block|{
comment|//DEBUG = field.name.equals("id");
comment|//if (DEBUG) System.out.println("\nBTTW.addField seg=" + segment + " field=" + field.name);
assert|assert
name|currentField
operator|==
literal|null
operator|||
name|currentField
operator|.
name|name
operator|.
name|compareTo
argument_list|(
name|field
operator|.
name|name
argument_list|)
operator|<
literal|0
assert|;
name|currentField
operator|=
name|field
expr_stmt|;
specifier|final
name|TermsWriter
name|terms
init|=
operator|new
name|TermsWriter
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|fields
operator|.
name|add
argument_list|(
name|terms
argument_list|)
expr_stmt|;
return|return
name|terms
return|;
block|}
DECL|method|encodeOutput
specifier|static
name|long
name|encodeOutput
parameter_list|(
name|long
name|fp
parameter_list|,
name|boolean
name|hasTerms
parameter_list|,
name|boolean
name|isFloor
parameter_list|)
block|{
assert|assert
name|fp
operator|<
operator|(
literal|1L
operator|<<
literal|62
operator|)
assert|;
return|return
operator|(
name|fp
operator|<<
literal|2
operator|)
operator||
operator|(
name|hasTerms
condition|?
name|OUTPUT_FLAG_HAS_TERMS
else|:
literal|0
operator|)
operator||
operator|(
name|isFloor
condition|?
name|OUTPUT_FLAG_IS_FLOOR
else|:
literal|0
operator|)
return|;
block|}
DECL|class|PendingEntry
specifier|private
specifier|static
class|class
name|PendingEntry
block|{
DECL|field|isTerm
specifier|public
specifier|final
name|boolean
name|isTerm
decl_stmt|;
DECL|method|PendingEntry
specifier|protected
name|PendingEntry
parameter_list|(
name|boolean
name|isTerm
parameter_list|)
block|{
name|this
operator|.
name|isTerm
operator|=
name|isTerm
expr_stmt|;
block|}
block|}
DECL|class|PendingTerm
specifier|private
specifier|static
specifier|final
class|class
name|PendingTerm
extends|extends
name|PendingEntry
block|{
DECL|field|term
specifier|public
specifier|final
name|BytesRef
name|term
decl_stmt|;
DECL|field|stats
specifier|public
specifier|final
name|TermStats
name|stats
decl_stmt|;
DECL|method|PendingTerm
specifier|public
name|PendingTerm
parameter_list|(
name|BytesRef
name|term
parameter_list|,
name|TermStats
name|stats
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|term
operator|=
name|term
expr_stmt|;
name|this
operator|.
name|stats
operator|=
name|stats
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|term
operator|.
name|utf8ToString
argument_list|()
return|;
block|}
block|}
DECL|class|PendingBlock
specifier|private
specifier|static
specifier|final
class|class
name|PendingBlock
extends|extends
name|PendingEntry
block|{
DECL|field|prefix
specifier|public
specifier|final
name|BytesRef
name|prefix
decl_stmt|;
DECL|field|fp
specifier|public
specifier|final
name|long
name|fp
decl_stmt|;
DECL|field|index
specifier|public
name|FST
argument_list|<
name|BytesRef
argument_list|>
name|index
decl_stmt|;
DECL|field|subIndices
specifier|public
name|List
argument_list|<
name|FST
argument_list|<
name|BytesRef
argument_list|>
argument_list|>
name|subIndices
decl_stmt|;
DECL|field|hasTerms
specifier|public
specifier|final
name|boolean
name|hasTerms
decl_stmt|;
DECL|field|isFloor
specifier|public
specifier|final
name|boolean
name|isFloor
decl_stmt|;
DECL|field|floorLeadByte
specifier|public
specifier|final
name|int
name|floorLeadByte
decl_stmt|;
DECL|field|scratchIntsRef
specifier|private
specifier|final
name|IntsRef
name|scratchIntsRef
init|=
operator|new
name|IntsRef
argument_list|()
decl_stmt|;
DECL|method|PendingBlock
specifier|public
name|PendingBlock
parameter_list|(
name|BytesRef
name|prefix
parameter_list|,
name|long
name|fp
parameter_list|,
name|boolean
name|hasTerms
parameter_list|,
name|boolean
name|isFloor
parameter_list|,
name|int
name|floorLeadByte
parameter_list|,
name|List
argument_list|<
name|FST
argument_list|<
name|BytesRef
argument_list|>
argument_list|>
name|subIndices
parameter_list|)
block|{
name|super
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|prefix
operator|=
name|prefix
expr_stmt|;
name|this
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|this
operator|.
name|hasTerms
operator|=
name|hasTerms
expr_stmt|;
name|this
operator|.
name|isFloor
operator|=
name|isFloor
expr_stmt|;
name|this
operator|.
name|floorLeadByte
operator|=
name|floorLeadByte
expr_stmt|;
name|this
operator|.
name|subIndices
operator|=
name|subIndices
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"BLOCK: "
operator|+
name|prefix
operator|.
name|utf8ToString
argument_list|()
return|;
block|}
DECL|method|compileIndex
specifier|public
name|void
name|compileIndex
parameter_list|(
name|List
argument_list|<
name|PendingBlock
argument_list|>
name|floorBlocks
parameter_list|,
name|RAMOutputStream
name|scratchBytes
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|(
name|isFloor
operator|&&
name|floorBlocks
operator|!=
literal|null
operator|&&
name|floorBlocks
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|!
name|isFloor
operator|&&
name|floorBlocks
operator|==
literal|null
operator|)
operator|:
literal|"isFloor="
operator|+
name|isFloor
operator|+
literal|" floorBlocks="
operator|+
name|floorBlocks
assert|;
assert|assert
name|scratchBytes
operator|.
name|getFilePointer
argument_list|()
operator|==
literal|0
assert|;
comment|// TODO: try writing the leading vLong in MSB order
comment|// (opposite of what Lucene does today), for better
comment|// outputs sharing in the FST
name|scratchBytes
operator|.
name|writeVLong
argument_list|(
name|encodeOutput
argument_list|(
name|fp
argument_list|,
name|hasTerms
argument_list|,
name|isFloor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFloor
condition|)
block|{
name|scratchBytes
operator|.
name|writeVInt
argument_list|(
name|floorBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|PendingBlock
name|sub
range|:
name|floorBlocks
control|)
block|{
assert|assert
name|sub
operator|.
name|floorLeadByte
operator|!=
operator|-
literal|1
assert|;
comment|//if (DEBUG) {
comment|//  System.out.println("    write floorLeadByte=" + Integer.toHexString(sub.floorLeadByte&0xff));
comment|//}
name|scratchBytes
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
name|sub
operator|.
name|floorLeadByte
argument_list|)
expr_stmt|;
assert|assert
name|sub
operator|.
name|fp
operator|>
name|fp
assert|;
name|scratchBytes
operator|.
name|writeVLong
argument_list|(
operator|(
name|sub
operator|.
name|fp
operator|-
name|fp
operator|)
operator|<<
literal|1
operator||
operator|(
name|sub
operator|.
name|hasTerms
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|ByteSequenceOutputs
name|outputs
init|=
name|ByteSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
specifier|final
name|Builder
argument_list|<
name|BytesRef
argument_list|>
name|indexBuilder
init|=
operator|new
name|Builder
argument_list|<
name|BytesRef
argument_list|>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|outputs
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|//if (DEBUG) {
comment|//  System.out.println("  compile index for prefix=" + prefix);
comment|//}
comment|//indexBuilder.DEBUG = false;
specifier|final
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|scratchBytes
operator|.
name|getFilePointer
argument_list|()
index|]
decl_stmt|;
assert|assert
name|bytes
operator|.
name|length
operator|>
literal|0
assert|;
name|scratchBytes
operator|.
name|writeTo
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|indexBuilder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|prefix
argument_list|,
name|scratchIntsRef
argument_list|)
argument_list|,
operator|new
name|BytesRef
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|scratchBytes
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Copy over index for all sub-blocks
if|if
condition|(
name|subIndices
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|FST
argument_list|<
name|BytesRef
argument_list|>
name|subIndex
range|:
name|subIndices
control|)
block|{
name|append
argument_list|(
name|indexBuilder
argument_list|,
name|subIndex
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|floorBlocks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|PendingBlock
name|sub
range|:
name|floorBlocks
control|)
block|{
if|if
condition|(
name|sub
operator|.
name|subIndices
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|FST
argument_list|<
name|BytesRef
argument_list|>
name|subIndex
range|:
name|sub
operator|.
name|subIndices
control|)
block|{
name|append
argument_list|(
name|indexBuilder
argument_list|,
name|subIndex
argument_list|)
expr_stmt|;
block|}
block|}
name|sub
operator|.
name|subIndices
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|index
operator|=
name|indexBuilder
operator|.
name|finish
argument_list|()
expr_stmt|;
name|subIndices
operator|=
literal|null
expr_stmt|;
comment|/*       Writer w = new OutputStreamWriter(new FileOutputStream("out.dot"));       Util.toDot(index, w, false, false);       System.out.println("SAVED to out.dot");       w.close();       */
block|}
comment|// TODO: maybe we could add bulk-add method to
comment|// Builder?  Takes FST and unions it w/ current
comment|// FST.
DECL|method|append
specifier|private
name|void
name|append
parameter_list|(
name|Builder
argument_list|<
name|BytesRef
argument_list|>
name|builder
parameter_list|,
name|FST
argument_list|<
name|BytesRef
argument_list|>
name|subIndex
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|BytesRefFSTEnum
argument_list|<
name|BytesRef
argument_list|>
name|subIndexEnum
init|=
operator|new
name|BytesRefFSTEnum
argument_list|<
name|BytesRef
argument_list|>
argument_list|(
name|subIndex
argument_list|)
decl_stmt|;
name|BytesRefFSTEnum
operator|.
name|InputOutput
argument_list|<
name|BytesRef
argument_list|>
name|indexEnt
decl_stmt|;
while|while
condition|(
operator|(
name|indexEnt
operator|=
name|subIndexEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
comment|//if (DEBUG) {
comment|//  System.out.println("      add sub=" + indexEnt.input + " " + indexEnt.input + " output=" + indexEnt.output);
comment|//}
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|indexEnt
operator|.
name|input
argument_list|,
name|scratchIntsRef
argument_list|)
argument_list|,
name|indexEnt
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|field|scratchBytes
specifier|final
name|RAMOutputStream
name|scratchBytes
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
DECL|class|TermsWriter
class|class
name|TermsWriter
extends|extends
name|TermsConsumer
block|{
DECL|field|fieldInfo
specifier|private
specifier|final
name|FieldInfo
name|fieldInfo
decl_stmt|;
DECL|field|numTerms
specifier|private
name|long
name|numTerms
decl_stmt|;
DECL|field|sumTotalTermFreq
name|long
name|sumTotalTermFreq
decl_stmt|;
DECL|field|sumDocFreq
name|long
name|sumDocFreq
decl_stmt|;
DECL|field|docCount
name|int
name|docCount
decl_stmt|;
DECL|field|indexStartFP
name|long
name|indexStartFP
decl_stmt|;
comment|// Used only to partition terms into the block tree; we
comment|// don't pull an FST from this builder:
DECL|field|noOutputs
specifier|private
specifier|final
name|NoOutputs
name|noOutputs
decl_stmt|;
DECL|field|blockBuilder
specifier|private
specifier|final
name|Builder
argument_list|<
name|Object
argument_list|>
name|blockBuilder
decl_stmt|;
comment|// PendingTerm or PendingBlock:
DECL|field|pending
specifier|private
specifier|final
name|List
argument_list|<
name|PendingEntry
argument_list|>
name|pending
init|=
operator|new
name|ArrayList
argument_list|<
name|PendingEntry
argument_list|>
argument_list|()
decl_stmt|;
comment|// Index into pending of most recently written block
DECL|field|lastBlockIndex
specifier|private
name|int
name|lastBlockIndex
init|=
operator|-
literal|1
decl_stmt|;
comment|// Re-used when segmenting a too-large block into floor
comment|// blocks:
DECL|field|subBytes
specifier|private
name|int
index|[]
name|subBytes
init|=
operator|new
name|int
index|[
literal|10
index|]
decl_stmt|;
DECL|field|subTermCounts
specifier|private
name|int
index|[]
name|subTermCounts
init|=
operator|new
name|int
index|[
literal|10
index|]
decl_stmt|;
DECL|field|subTermCountSums
specifier|private
name|int
index|[]
name|subTermCountSums
init|=
operator|new
name|int
index|[
literal|10
index|]
decl_stmt|;
DECL|field|subSubCounts
specifier|private
name|int
index|[]
name|subSubCounts
init|=
operator|new
name|int
index|[
literal|10
index|]
decl_stmt|;
comment|// This class assigns terms to blocks "naturally", ie,
comment|// according to the number of terms under a given prefix
comment|// that we encounter:
DECL|class|FindBlocks
specifier|private
class|class
name|FindBlocks
extends|extends
name|Builder
operator|.
name|FreezeTail
argument_list|<
name|Object
argument_list|>
block|{
annotation|@
name|Override
DECL|method|freeze
specifier|public
name|void
name|freeze
parameter_list|(
specifier|final
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Object
argument_list|>
index|[]
name|frontier
parameter_list|,
name|int
name|prefixLenPlus1
parameter_list|,
specifier|final
name|IntsRef
name|lastInput
parameter_list|)
throws|throws
name|IOException
block|{
comment|//if (DEBUG) System.out.println("  freeze prefixLenPlus1=" + prefixLenPlus1);
for|for
control|(
name|int
name|idx
init|=
name|lastInput
operator|.
name|length
init|;
name|idx
operator|>=
name|prefixLenPlus1
condition|;
name|idx
operator|--
control|)
block|{
specifier|final
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Object
argument_list|>
name|node
init|=
name|frontier
index|[
name|idx
index|]
decl_stmt|;
name|long
name|totCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|isFinal
condition|)
block|{
name|totCount
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|node
operator|.
name|numArcs
condition|;
name|arcIdx
operator|++
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Object
argument_list|>
name|target
init|=
operator|(
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Object
argument_list|>
operator|)
name|node
operator|.
name|arcs
index|[
name|arcIdx
index|]
operator|.
name|target
decl_stmt|;
name|totCount
operator|+=
name|target
operator|.
name|inputCount
expr_stmt|;
name|target
operator|.
name|clear
argument_list|()
expr_stmt|;
name|node
operator|.
name|arcs
index|[
name|arcIdx
index|]
operator|.
name|target
operator|=
literal|null
expr_stmt|;
block|}
name|node
operator|.
name|numArcs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|totCount
operator|>=
name|minItemsInBlock
operator|||
name|idx
operator|==
literal|0
condition|)
block|{
comment|// We are on a prefix node that has enough
comment|// entries (terms or sub-blocks) under it to let
comment|// us write a new block or multiple blocks (main
comment|// block + follow on floor blocks):
comment|//if (DEBUG) {
comment|//  if (totCount< minItemsInBlock&& idx != 0) {
comment|//    System.out.println("  force block has terms");
comment|//  }
comment|//}
name|writeBlocks
argument_list|(
name|lastInput
argument_list|,
name|idx
argument_list|,
operator|(
name|int
operator|)
name|totCount
argument_list|)
expr_stmt|;
name|node
operator|.
name|inputCount
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// stragglers!  carry count upwards
name|node
operator|.
name|inputCount
operator|=
name|totCount
expr_stmt|;
block|}
name|frontier
index|[
name|idx
index|]
operator|=
operator|new
name|Builder
operator|.
name|UnCompiledNode
argument_list|<
name|Object
argument_list|>
argument_list|(
name|blockBuilder
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Write the top count entries on the pending stack as
comment|// one or more blocks.  Returns how many blocks were
comment|// written.  If the entry count is<= maxItemsPerBlock
comment|// we just write a single block; else we break into
comment|// primary (initial) block and then one or more
comment|// following floor blocks:
DECL|method|writeBlocks
name|void
name|writeBlocks
parameter_list|(
name|IntsRef
name|prevTerm
parameter_list|,
name|int
name|prefixLength
parameter_list|,
name|int
name|count
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|prefixLength
operator|==
literal|0
operator|||
name|count
operator|<=
name|maxItemsInBlock
condition|)
block|{
comment|// Easy case: not floor block.  Eg, prefix is "foo",
comment|// and we found 30 terms/sub-blocks starting w/ that
comment|// prefix, and minItemsInBlock<= 30<=
comment|// maxItemsInBlock.
specifier|final
name|PendingBlock
name|nonFloorBlock
init|=
name|writeBlock
argument_list|(
name|prevTerm
argument_list|,
name|prefixLength
argument_list|,
name|prefixLength
argument_list|,
name|count
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|nonFloorBlock
operator|.
name|compileIndex
argument_list|(
literal|null
argument_list|,
name|scratchBytes
argument_list|)
expr_stmt|;
name|pending
operator|.
name|add
argument_list|(
name|nonFloorBlock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Floor block case.  Eg, prefix is "foo" but we
comment|// have 100 terms/sub-blocks starting w/ that
comment|// prefix.  We segment the entries into a primary
comment|// block and following floor blocks using the first
comment|// label in the suffix to assign to floor blocks.
comment|// TODO: we could store min& max suffix start byte
comment|// in each block, to make floor blocks authoritative
comment|//if (DEBUG) {
comment|//  final BytesRef prefix = new BytesRef(prefixLength);
comment|//  for(int m=0;m<prefixLength;m++) {
comment|//    prefix.bytes[m] = (byte) prevTerm.ints[m];
comment|//  }
comment|//  prefix.length = prefixLength;
comment|//  //System.out.println("\nWBS count=" + count + " prefix=" + prefix.utf8ToString() + " " + prefix);
comment|//  System.out.println("writeBlocks: prefix=" + prefix + " " + prefix + " count=" + count + " pending.size()=" + pending.size());
comment|//}
comment|//System.out.println("\nwbs count=" + count);
specifier|final
name|int
name|savLabel
init|=
name|prevTerm
operator|.
name|ints
index|[
name|prevTerm
operator|.
name|offset
operator|+
name|prefixLength
index|]
decl_stmt|;
comment|// Count up how many items fall under
comment|// each unique label after the prefix.
comment|// TODO: this is wasteful since the builder had
comment|// already done this (partitioned these sub-terms
comment|// according to their leading prefix byte)
specifier|final
name|List
argument_list|<
name|PendingEntry
argument_list|>
name|slice
init|=
name|pending
operator|.
name|subList
argument_list|(
name|pending
operator|.
name|size
argument_list|()
operator|-
name|count
argument_list|,
name|pending
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|lastSuffixLeadLabel
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|termCount
init|=
literal|0
decl_stmt|;
name|int
name|subCount
init|=
literal|0
decl_stmt|;
name|int
name|numSubs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|PendingEntry
name|ent
range|:
name|slice
control|)
block|{
comment|// First byte in the suffix of this term
specifier|final
name|int
name|suffixLeadLabel
decl_stmt|;
if|if
condition|(
name|ent
operator|.
name|isTerm
condition|)
block|{
name|PendingTerm
name|term
init|=
operator|(
name|PendingTerm
operator|)
name|ent
decl_stmt|;
if|if
condition|(
name|term
operator|.
name|term
operator|.
name|length
operator|==
name|prefixLength
condition|)
block|{
comment|// Suffix is 0, ie prefix 'foo' and term is
comment|// 'foo' so the term has empty string suffix
comment|// in this block
assert|assert
name|lastSuffixLeadLabel
operator|==
operator|-
literal|1
assert|;
assert|assert
name|numSubs
operator|==
literal|0
assert|;
name|suffixLeadLabel
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|suffixLeadLabel
operator|=
name|term
operator|.
name|term
operator|.
name|bytes
index|[
name|term
operator|.
name|term
operator|.
name|offset
operator|+
name|prefixLength
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
else|else
block|{
name|PendingBlock
name|block
init|=
operator|(
name|PendingBlock
operator|)
name|ent
decl_stmt|;
assert|assert
name|block
operator|.
name|prefix
operator|.
name|length
operator|>
name|prefixLength
assert|;
name|suffixLeadLabel
operator|=
name|block
operator|.
name|prefix
operator|.
name|bytes
index|[
name|block
operator|.
name|prefix
operator|.
name|offset
operator|+
name|prefixLength
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
if|if
condition|(
name|suffixLeadLabel
operator|!=
name|lastSuffixLeadLabel
operator|&&
operator|(
name|termCount
operator|+
name|subCount
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|subBytes
operator|.
name|length
operator|==
name|numSubs
condition|)
block|{
name|subBytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|subBytes
argument_list|)
expr_stmt|;
name|subTermCounts
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|subTermCounts
argument_list|)
expr_stmt|;
name|subSubCounts
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|subSubCounts
argument_list|)
expr_stmt|;
block|}
name|subBytes
index|[
name|numSubs
index|]
operator|=
name|lastSuffixLeadLabel
expr_stmt|;
name|lastSuffixLeadLabel
operator|=
name|suffixLeadLabel
expr_stmt|;
name|subTermCounts
index|[
name|numSubs
index|]
operator|=
name|termCount
expr_stmt|;
name|subSubCounts
index|[
name|numSubs
index|]
operator|=
name|subCount
expr_stmt|;
comment|/*             if (suffixLeadLabel == -1) {               System.out.println("  sub " + -1 + " termCount=" + termCount + " subCount=" + subCount);             } else {               System.out.println("  sub " + Integer.toHexString(suffixLeadLabel) + " termCount=" + termCount + " subCount=" + subCount);             }             */
name|termCount
operator|=
name|subCount
operator|=
literal|0
expr_stmt|;
name|numSubs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|.
name|isTerm
condition|)
block|{
name|termCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|subCount
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|subBytes
operator|.
name|length
operator|==
name|numSubs
condition|)
block|{
name|subBytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|subBytes
argument_list|)
expr_stmt|;
name|subTermCounts
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|subTermCounts
argument_list|)
expr_stmt|;
name|subSubCounts
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|subSubCounts
argument_list|)
expr_stmt|;
block|}
name|subBytes
index|[
name|numSubs
index|]
operator|=
name|lastSuffixLeadLabel
expr_stmt|;
name|subTermCounts
index|[
name|numSubs
index|]
operator|=
name|termCount
expr_stmt|;
name|subSubCounts
index|[
name|numSubs
index|]
operator|=
name|subCount
expr_stmt|;
name|numSubs
operator|++
expr_stmt|;
comment|/*         if (lastSuffixLeadLabel == -1) {           System.out.println("  sub " + -1 + " termCount=" + termCount + " subCount=" + subCount);         } else {           System.out.println("  sub " + Integer.toHexString(lastSuffixLeadLabel) + " termCount=" + termCount + " subCount=" + subCount);         }         */
if|if
condition|(
name|subTermCountSums
operator|.
name|length
operator|<
name|numSubs
condition|)
block|{
name|subTermCountSums
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|subTermCountSums
argument_list|,
name|numSubs
argument_list|)
expr_stmt|;
block|}
comment|// Roll up (backwards) the termCounts; postings impl
comment|// needs this to know where to pull the term slice
comment|// from its pending terms stack:
name|int
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
name|numSubs
operator|-
literal|1
init|;
name|idx
operator|>=
literal|0
condition|;
name|idx
operator|--
control|)
block|{
name|sum
operator|+=
name|subTermCounts
index|[
name|idx
index|]
expr_stmt|;
name|subTermCountSums
index|[
name|idx
index|]
operator|=
name|sum
expr_stmt|;
block|}
comment|// TODO: make a better segmenter?  It'd have to
comment|// absorb the too-small end blocks backwards into
comment|// the previous blocks
comment|// Naive greedy segmentation; this is not always
comment|// best (it can produce a too-small block as the
comment|// last block):
name|int
name|pendingCount
init|=
literal|0
decl_stmt|;
name|int
name|startLabel
init|=
name|subBytes
index|[
literal|0
index|]
decl_stmt|;
name|int
name|curStart
init|=
name|count
decl_stmt|;
name|subCount
operator|=
literal|0
expr_stmt|;
specifier|final
name|List
argument_list|<
name|PendingBlock
argument_list|>
name|floorBlocks
init|=
operator|new
name|ArrayList
argument_list|<
name|PendingBlock
argument_list|>
argument_list|()
decl_stmt|;
name|PendingBlock
name|firstBlock
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|sub
init|=
literal|0
init|;
name|sub
operator|<
name|numSubs
condition|;
name|sub
operator|++
control|)
block|{
name|pendingCount
operator|+=
name|subTermCounts
index|[
name|sub
index|]
operator|+
name|subSubCounts
index|[
name|sub
index|]
expr_stmt|;
comment|//System.out.println("  " + (subTermCounts[sub] + subSubCounts[sub]));
name|subCount
operator|++
expr_stmt|;
comment|// Greedily make a floor block as soon as we've
comment|// crossed the min count
if|if
condition|(
name|pendingCount
operator|>=
name|minItemsInBlock
condition|)
block|{
specifier|final
name|int
name|curPrefixLength
decl_stmt|;
if|if
condition|(
name|startLabel
operator|==
operator|-
literal|1
condition|)
block|{
name|curPrefixLength
operator|=
name|prefixLength
expr_stmt|;
block|}
else|else
block|{
name|curPrefixLength
operator|=
literal|1
operator|+
name|prefixLength
expr_stmt|;
comment|// floor term:
name|prevTerm
operator|.
name|ints
index|[
name|prevTerm
operator|.
name|offset
operator|+
name|prefixLength
index|]
operator|=
name|startLabel
expr_stmt|;
block|}
comment|//System.out.println("  " + subCount + " subs");
specifier|final
name|PendingBlock
name|floorBlock
init|=
name|writeBlock
argument_list|(
name|prevTerm
argument_list|,
name|prefixLength
argument_list|,
name|curPrefixLength
argument_list|,
name|curStart
argument_list|,
name|pendingCount
argument_list|,
name|subTermCountSums
index|[
literal|1
operator|+
name|sub
index|]
argument_list|,
literal|true
argument_list|,
name|startLabel
argument_list|,
name|curStart
operator|==
name|pendingCount
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstBlock
operator|==
literal|null
condition|)
block|{
name|firstBlock
operator|=
name|floorBlock
expr_stmt|;
block|}
else|else
block|{
name|floorBlocks
operator|.
name|add
argument_list|(
name|floorBlock
argument_list|)
expr_stmt|;
block|}
name|curStart
operator|-=
name|pendingCount
expr_stmt|;
comment|//System.out.println("    = " + pendingCount);
name|pendingCount
operator|=
literal|0
expr_stmt|;
assert|assert
name|minItemsInBlock
operator|==
literal|1
operator|||
name|subCount
operator|>
literal|1
operator|:
literal|"minItemsInBlock="
operator|+
name|minItemsInBlock
operator|+
literal|" subCount="
operator|+
name|subCount
operator|+
literal|" sub="
operator|+
name|sub
operator|+
literal|" of "
operator|+
name|numSubs
operator|+
literal|" subTermCount="
operator|+
name|subTermCountSums
index|[
name|sub
index|]
operator|+
literal|" subSubCount="
operator|+
name|subSubCounts
index|[
name|sub
index|]
operator|+
literal|" depth="
operator|+
name|prefixLength
assert|;
name|subCount
operator|=
literal|0
expr_stmt|;
name|startLabel
operator|=
name|subBytes
index|[
name|sub
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|curStart
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|curStart
operator|<=
name|maxItemsInBlock
condition|)
block|{
comment|// remainder is small enough to fit into a
comment|// block.  NOTE that this may be too small (<
comment|// minItemsInBlock); need a true segmenter
comment|// here
assert|assert
name|startLabel
operator|!=
operator|-
literal|1
assert|;
assert|assert
name|firstBlock
operator|!=
literal|null
assert|;
name|prevTerm
operator|.
name|ints
index|[
name|prevTerm
operator|.
name|offset
operator|+
name|prefixLength
index|]
operator|=
name|startLabel
expr_stmt|;
comment|//System.out.println("  final " + (numSubs-sub-1) + " subs");
comment|/*               for(sub++;sub< numSubs;sub++) {                 System.out.println("  " + (subTermCounts[sub] + subSubCounts[sub]));               }               System.out.println("    = " + curStart);               if (curStart< minItemsInBlock) {                 System.out.println("      **");               }               */
name|floorBlocks
operator|.
name|add
argument_list|(
name|writeBlock
argument_list|(
name|prevTerm
argument_list|,
name|prefixLength
argument_list|,
name|prefixLength
operator|+
literal|1
argument_list|,
name|curStart
argument_list|,
name|curStart
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
name|startLabel
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|prevTerm
operator|.
name|ints
index|[
name|prevTerm
operator|.
name|offset
operator|+
name|prefixLength
index|]
operator|=
name|savLabel
expr_stmt|;
assert|assert
name|firstBlock
operator|!=
literal|null
assert|;
name|firstBlock
operator|.
name|compileIndex
argument_list|(
name|floorBlocks
argument_list|,
name|scratchBytes
argument_list|)
expr_stmt|;
name|pending
operator|.
name|add
argument_list|(
name|firstBlock
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("  done pending.size()=" + pending.size());
block|}
name|lastBlockIndex
operator|=
name|pending
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
comment|// for debugging
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
DECL|method|toString
specifier|private
name|String
name|toString
parameter_list|(
name|BytesRef
name|b
parameter_list|)
block|{
try|try
block|{
return|return
name|b
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" "
operator|+
name|b
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// If BytesRef isn't actually UTF8, or it's eg a
comment|// prefix of UTF8 that ends mid-unicode-char, we
comment|// fallback to hex:
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|// Writes all entries in the pending slice as a single
comment|// block:
DECL|method|writeBlock
specifier|private
name|PendingBlock
name|writeBlock
parameter_list|(
name|IntsRef
name|prevTerm
parameter_list|,
name|int
name|prefixLength
parameter_list|,
name|int
name|indexPrefixLength
parameter_list|,
name|int
name|startBackwards
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|futureTermCount
parameter_list|,
name|boolean
name|isFloor
parameter_list|,
name|int
name|floorLeadByte
parameter_list|,
name|boolean
name|isLastInFloor
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|length
operator|>
literal|0
assert|;
specifier|final
name|int
name|start
init|=
name|pending
operator|.
name|size
argument_list|()
operator|-
name|startBackwards
decl_stmt|;
assert|assert
name|start
operator|>=
literal|0
operator|:
literal|"pending.size()="
operator|+
name|pending
operator|.
name|size
argument_list|()
operator|+
literal|" startBackwards="
operator|+
name|startBackwards
operator|+
literal|" length="
operator|+
name|length
assert|;
specifier|final
name|List
argument_list|<
name|PendingEntry
argument_list|>
name|slice
init|=
name|pending
operator|.
name|subList
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|length
argument_list|)
decl_stmt|;
specifier|final
name|long
name|startFP
init|=
name|out
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
specifier|final
name|BytesRef
name|prefix
init|=
operator|new
name|BytesRef
argument_list|(
name|indexPrefixLength
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|m
init|=
literal|0
init|;
name|m
operator|<
name|indexPrefixLength
condition|;
name|m
operator|++
control|)
block|{
name|prefix
operator|.
name|bytes
index|[
name|m
index|]
operator|=
operator|(
name|byte
operator|)
name|prevTerm
operator|.
name|ints
index|[
name|m
index|]
expr_stmt|;
block|}
name|prefix
operator|.
name|length
operator|=
name|indexPrefixLength
expr_stmt|;
comment|// Write block header:
name|out
operator|.
name|writeVInt
argument_list|(
operator|(
name|length
operator|<<
literal|1
operator|)
operator||
operator|(
name|isLastInFloor
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  writeBlock " + (isFloor ? "(floor) " : "") + "seg=" + segment + " pending.size()=" + pending.size() + " prefixLength=" + prefixLength + " indexPrefix=" + toString(prefix) + " entCount=" + length + " startFP=" + startFP + " futureTermCount=" + futureTermCount + (isFloor ? (" floorLeadByte=" + Integer.toHexString(floorLeadByte&0xff)) : "") + " isLastInFloor=" + isLastInFloor);
comment|// }
comment|// 1st pass: pack term suffix bytes into byte[] blob
comment|// TODO: cutover to bulk int codec... simple64?
specifier|final
name|boolean
name|isLeafBlock
decl_stmt|;
if|if
condition|(
name|lastBlockIndex
operator|<
name|start
condition|)
block|{
comment|// This block definitely does not contain sub-blocks:
name|isLeafBlock
operator|=
literal|true
expr_stmt|;
comment|//System.out.println("no scan true isFloor=" + isFloor);
block|}
elseif|else
if|if
condition|(
operator|!
name|isFloor
condition|)
block|{
comment|// This block definitely does contain at least one sub-block:
name|isLeafBlock
operator|=
literal|false
expr_stmt|;
comment|//System.out.println("no scan false " + lastBlockIndex + " vs start=" + start + " len=" + length);
block|}
else|else
block|{
comment|// Must scan up-front to see if there is a sub-block
name|boolean
name|v
init|=
literal|true
decl_stmt|;
comment|//System.out.println("scan " + lastBlockIndex + " vs start=" + start + " len=" + length);
for|for
control|(
name|PendingEntry
name|ent
range|:
name|slice
control|)
block|{
if|if
condition|(
operator|!
name|ent
operator|.
name|isTerm
condition|)
block|{
name|v
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
name|isLeafBlock
operator|=
name|v
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|FST
argument_list|<
name|BytesRef
argument_list|>
argument_list|>
name|subIndices
decl_stmt|;
name|int
name|termCount
decl_stmt|;
if|if
condition|(
name|isLeafBlock
condition|)
block|{
name|subIndices
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|PendingEntry
name|ent
range|:
name|slice
control|)
block|{
assert|assert
name|ent
operator|.
name|isTerm
assert|;
name|PendingTerm
name|term
init|=
operator|(
name|PendingTerm
operator|)
name|ent
decl_stmt|;
specifier|final
name|int
name|suffix
init|=
name|term
operator|.
name|term
operator|.
name|length
operator|-
name|prefixLength
decl_stmt|;
comment|// if (DEBUG) {
comment|//   BytesRef suffixBytes = new BytesRef(suffix);
comment|//   System.arraycopy(term.term.bytes, prefixLength, suffixBytes.bytes, 0, suffix);
comment|//   suffixBytes.length = suffix;
comment|//   System.out.println("    write term suffix=" + suffixBytes);
comment|// }
comment|// For leaf block we write suffix straight
name|bytesWriter
operator|.
name|writeVInt
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
name|bytesWriter
operator|.
name|writeBytes
argument_list|(
name|term
operator|.
name|term
operator|.
name|bytes
argument_list|,
name|prefixLength
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
comment|// Write term stats, to separate byte[] blob:
name|bytesWriter2
operator|.
name|writeVInt
argument_list|(
name|term
operator|.
name|stats
operator|.
name|docFreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|!=
name|IndexOptions
operator|.
name|DOCS_ONLY
condition|)
block|{
assert|assert
name|term
operator|.
name|stats
operator|.
name|totalTermFreq
operator|>=
name|term
operator|.
name|stats
operator|.
name|docFreq
assert|;
name|bytesWriter2
operator|.
name|writeVLong
argument_list|(
name|term
operator|.
name|stats
operator|.
name|totalTermFreq
operator|-
name|term
operator|.
name|stats
operator|.
name|docFreq
argument_list|)
expr_stmt|;
block|}
block|}
name|termCount
operator|=
name|length
expr_stmt|;
block|}
else|else
block|{
name|subIndices
operator|=
operator|new
name|ArrayList
argument_list|<
name|FST
argument_list|<
name|BytesRef
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|termCount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|PendingEntry
name|ent
range|:
name|slice
control|)
block|{
if|if
condition|(
name|ent
operator|.
name|isTerm
condition|)
block|{
name|PendingTerm
name|term
init|=
operator|(
name|PendingTerm
operator|)
name|ent
decl_stmt|;
specifier|final
name|int
name|suffix
init|=
name|term
operator|.
name|term
operator|.
name|length
operator|-
name|prefixLength
decl_stmt|;
comment|// if (DEBUG) {
comment|//   BytesRef suffixBytes = new BytesRef(suffix);
comment|//   System.arraycopy(term.term.bytes, prefixLength, suffixBytes.bytes, 0, suffix);
comment|//   suffixBytes.length = suffix;
comment|//   System.out.println("    write term suffix=" + suffixBytes);
comment|// }
comment|// For non-leaf block we borrow 1 bit to record
comment|// if entry is term or sub-block
name|bytesWriter
operator|.
name|writeVInt
argument_list|(
name|suffix
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|bytesWriter
operator|.
name|writeBytes
argument_list|(
name|term
operator|.
name|term
operator|.
name|bytes
argument_list|,
name|prefixLength
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
comment|// Write term stats, to separate byte[] blob:
name|bytesWriter2
operator|.
name|writeVInt
argument_list|(
name|term
operator|.
name|stats
operator|.
name|docFreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|!=
name|IndexOptions
operator|.
name|DOCS_ONLY
condition|)
block|{
assert|assert
name|term
operator|.
name|stats
operator|.
name|totalTermFreq
operator|>=
name|term
operator|.
name|stats
operator|.
name|docFreq
assert|;
name|bytesWriter2
operator|.
name|writeVLong
argument_list|(
name|term
operator|.
name|stats
operator|.
name|totalTermFreq
operator|-
name|term
operator|.
name|stats
operator|.
name|docFreq
argument_list|)
expr_stmt|;
block|}
name|termCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|PendingBlock
name|block
init|=
operator|(
name|PendingBlock
operator|)
name|ent
decl_stmt|;
specifier|final
name|int
name|suffix
init|=
name|block
operator|.
name|prefix
operator|.
name|length
operator|-
name|prefixLength
decl_stmt|;
assert|assert
name|suffix
operator|>
literal|0
assert|;
comment|// For non-leaf block we borrow 1 bit to record
comment|// if entry is term or sub-block
name|bytesWriter
operator|.
name|writeVInt
argument_list|(
operator|(
name|suffix
operator|<<
literal|1
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|bytesWriter
operator|.
name|writeBytes
argument_list|(
name|block
operator|.
name|prefix
operator|.
name|bytes
argument_list|,
name|prefixLength
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
assert|assert
name|block
operator|.
name|fp
operator|<
name|startFP
assert|;
comment|// if (DEBUG) {
comment|//   BytesRef suffixBytes = new BytesRef(suffix);
comment|//   System.arraycopy(block.prefix.bytes, prefixLength, suffixBytes.bytes, 0, suffix);
comment|//   suffixBytes.length = suffix;
comment|//   System.out.println("    write sub-block suffix=" + toString(suffixBytes) + " subFP=" + block.fp + " subCode=" + (startFP-block.fp) + " floor=" + block.isFloor);
comment|// }
name|bytesWriter
operator|.
name|writeVLong
argument_list|(
name|startFP
operator|-
name|block
operator|.
name|fp
argument_list|)
expr_stmt|;
name|subIndices
operator|.
name|add
argument_list|(
name|block
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|subIndices
operator|.
name|size
argument_list|()
operator|!=
literal|0
assert|;
block|}
comment|// TODO: we could block-write the term suffix pointers;
comment|// this would take more space but would enable binary
comment|// search on lookup
comment|// Write suffixes byte[] blob to terms dict output:
name|out
operator|.
name|writeVInt
argument_list|(
call|(
name|int
call|)
argument_list|(
name|bytesWriter
operator|.
name|getFilePointer
argument_list|()
operator|<<
literal|1
argument_list|)
operator||
operator|(
name|isLeafBlock
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|bytesWriter
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|bytesWriter
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Write term stats byte[] blob
name|out
operator|.
name|writeVInt
argument_list|(
operator|(
name|int
operator|)
name|bytesWriter2
operator|.
name|getFilePointer
argument_list|()
argument_list|)
expr_stmt|;
name|bytesWriter2
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|bytesWriter2
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Have postings writer write block
name|postingsWriter
operator|.
name|flushTermsBlock
argument_list|(
name|futureTermCount
operator|+
name|termCount
argument_list|,
name|termCount
argument_list|)
expr_stmt|;
comment|// Remove slice replaced by block:
name|slice
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|lastBlockIndex
operator|>=
name|start
condition|)
block|{
if|if
condition|(
name|lastBlockIndex
operator|<
name|start
operator|+
name|length
condition|)
block|{
name|lastBlockIndex
operator|=
name|start
expr_stmt|;
block|}
else|else
block|{
name|lastBlockIndex
operator|-=
name|length
expr_stmt|;
block|}
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("      fpEnd=" + out.getFilePointer());
comment|// }
return|return
operator|new
name|PendingBlock
argument_list|(
name|prefix
argument_list|,
name|startFP
argument_list|,
name|termCount
operator|!=
literal|0
argument_list|,
name|isFloor
argument_list|,
name|floorLeadByte
argument_list|,
name|subIndices
argument_list|)
return|;
block|}
DECL|method|TermsWriter
name|TermsWriter
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
name|this
operator|.
name|fieldInfo
operator|=
name|fieldInfo
expr_stmt|;
name|noOutputs
operator|=
name|NoOutputs
operator|.
name|getSingleton
argument_list|()
expr_stmt|;
comment|// This Builder is just used transiently to fragment
comment|// terms into "good" blocks; we don't save the
comment|// resulting FST:
name|blockBuilder
operator|=
operator|new
name|Builder
argument_list|<
name|Object
argument_list|>
argument_list|(
name|FST
operator|.
name|INPUT_TYPE
operator|.
name|BYTE1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|noOutputs
argument_list|,
operator|new
name|FindBlocks
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|postingsWriter
operator|.
name|setField
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|startTerm
specifier|public
name|PostingsConsumer
name|startTerm
parameter_list|(
name|BytesRef
name|text
parameter_list|)
throws|throws
name|IOException
block|{
comment|//if (DEBUG) System.out.println("\nBTTW.startTerm term=" + fieldInfo.name + ":" + toString(text) + " seg=" + segment);
name|postingsWriter
operator|.
name|startTerm
argument_list|()
expr_stmt|;
comment|/*       if (fieldInfo.name.equals("id")) {         postingsWriter.termID = Integer.parseInt(text.utf8ToString());       } else {         postingsWriter.termID = -1;       }       */
return|return
name|postingsWriter
return|;
block|}
DECL|field|scratchIntsRef
specifier|private
specifier|final
name|IntsRef
name|scratchIntsRef
init|=
operator|new
name|IntsRef
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|finishTerm
specifier|public
name|void
name|finishTerm
parameter_list|(
name|BytesRef
name|text
parameter_list|,
name|TermStats
name|stats
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|stats
operator|.
name|docFreq
operator|>
literal|0
assert|;
comment|//if (DEBUG) System.out.println("BTTW.finishTerm term=" + fieldInfo.name + ":" + toString(text) + " seg=" + segment + " df=" + stats.docFreq);
name|blockBuilder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toIntsRef
argument_list|(
name|text
argument_list|,
name|scratchIntsRef
argument_list|)
argument_list|,
name|noOutputs
operator|.
name|getNoOutput
argument_list|()
argument_list|)
expr_stmt|;
name|pending
operator|.
name|add
argument_list|(
operator|new
name|PendingTerm
argument_list|(
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|text
argument_list|)
argument_list|,
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|postingsWriter
operator|.
name|finishTerm
argument_list|(
name|stats
argument_list|)
expr_stmt|;
name|numTerms
operator|++
expr_stmt|;
block|}
comment|// Finishes all terms in this field
annotation|@
name|Override
DECL|method|finish
specifier|public
name|void
name|finish
parameter_list|(
name|long
name|sumTotalTermFreq
parameter_list|,
name|long
name|sumDocFreq
parameter_list|,
name|int
name|docCount
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|numTerms
operator|>
literal|0
condition|)
block|{
name|blockBuilder
operator|.
name|finish
argument_list|()
expr_stmt|;
comment|// We better have one final "root" block:
assert|assert
name|pending
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|!
name|pending
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|isTerm
operator|:
literal|"pending.size()="
operator|+
name|pending
operator|.
name|size
argument_list|()
operator|+
literal|" pending="
operator|+
name|pending
assert|;
specifier|final
name|PendingBlock
name|root
init|=
operator|(
name|PendingBlock
operator|)
name|pending
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
name|root
operator|.
name|prefix
operator|.
name|length
operator|==
literal|0
assert|;
assert|assert
name|root
operator|.
name|index
operator|.
name|getEmptyOutput
argument_list|()
operator|!=
literal|null
assert|;
name|this
operator|.
name|sumTotalTermFreq
operator|=
name|sumTotalTermFreq
expr_stmt|;
name|this
operator|.
name|sumDocFreq
operator|=
name|sumDocFreq
expr_stmt|;
name|this
operator|.
name|docCount
operator|=
name|docCount
expr_stmt|;
comment|// Write FST to index
name|indexStartFP
operator|=
name|indexOut
operator|.
name|getFilePointer
argument_list|()
expr_stmt|;
name|root
operator|.
name|index
operator|.
name|save
argument_list|(
name|indexOut
argument_list|)
expr_stmt|;
comment|//System.out.println("  write FST " + indexStartFP + " field=" + fieldInfo.name);
comment|// if (SAVE_DOT_FILES || DEBUG) {
comment|//   final String dotFileName = segment + "_" + fieldInfo.name + ".dot";
comment|//   Writer w = new OutputStreamWriter(new FileOutputStream(dotFileName));
comment|//   Util.toDot(root.index, w, false, false);
comment|//   System.out.println("SAVED to " + dotFileName);
comment|//   w.close();
comment|// }
block|}
else|else
block|{
assert|assert
name|sumTotalTermFreq
operator|==
literal|0
assert|;
assert|assert
name|sumDocFreq
operator|==
literal|0
assert|;
assert|assert
name|docCount
operator|==
literal|0
assert|;
block|}
block|}
DECL|field|bytesWriter
specifier|private
specifier|final
name|RAMOutputStream
name|bytesWriter
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
DECL|field|bytesWriter2
specifier|private
specifier|final
name|RAMOutputStream
name|bytesWriter2
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|IOException
name|ioe
init|=
literal|null
decl_stmt|;
try|try
block|{
name|int
name|nonZeroCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|TermsWriter
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|field
operator|.
name|numTerms
operator|>
literal|0
condition|)
block|{
name|nonZeroCount
operator|++
expr_stmt|;
block|}
block|}
specifier|final
name|long
name|dirStart
init|=
name|out
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
specifier|final
name|long
name|indexDirStart
init|=
name|indexOut
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|nonZeroCount
argument_list|)
expr_stmt|;
for|for
control|(
name|TermsWriter
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|field
operator|.
name|numTerms
operator|>
literal|0
condition|)
block|{
comment|//System.out.println("  field " + field.fieldInfo.name + " " + field.numTerms + " terms");
name|out
operator|.
name|writeVInt
argument_list|(
name|field
operator|.
name|fieldInfo
operator|.
name|number
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|field
operator|.
name|numTerms
argument_list|)
expr_stmt|;
specifier|final
name|BytesRef
name|rootCode
init|=
operator|(
operator|(
name|PendingBlock
operator|)
name|field
operator|.
name|pending
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|index
operator|.
name|getEmptyOutput
argument_list|()
decl_stmt|;
assert|assert
name|rootCode
operator|!=
literal|null
operator|:
literal|"field="
operator|+
name|field
operator|.
name|fieldInfo
operator|.
name|name
operator|+
literal|" numTerms="
operator|+
name|field
operator|.
name|numTerms
assert|;
name|out
operator|.
name|writeVInt
argument_list|(
name|rootCode
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
name|rootCode
operator|.
name|bytes
argument_list|,
name|rootCode
operator|.
name|offset
argument_list|,
name|rootCode
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|.
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|!=
name|IndexOptions
operator|.
name|DOCS_ONLY
condition|)
block|{
name|out
operator|.
name|writeVLong
argument_list|(
name|field
operator|.
name|sumTotalTermFreq
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeVLong
argument_list|(
name|field
operator|.
name|sumDocFreq
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|field
operator|.
name|docCount
argument_list|)
expr_stmt|;
name|indexOut
operator|.
name|writeVLong
argument_list|(
name|field
operator|.
name|indexStartFP
argument_list|)
expr_stmt|;
block|}
block|}
name|writeTrailer
argument_list|(
name|out
argument_list|,
name|dirStart
argument_list|)
expr_stmt|;
name|writeIndexTrailer
argument_list|(
name|indexOut
argument_list|,
name|indexDirStart
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe2
parameter_list|)
block|{
name|ioe
operator|=
name|ioe2
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|ioe
argument_list|,
name|out
argument_list|,
name|indexOut
argument_list|,
name|postingsWriter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class
end_unit
