begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.compressing
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|compressing
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|compressing
operator|.
name|CompressingTermVectorsWriter
operator|.
name|BLOCK_SIZE
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|compressing
operator|.
name|CompressingTermVectorsWriter
operator|.
name|CODEC_SFX_DAT
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|compressing
operator|.
name|CompressingTermVectorsWriter
operator|.
name|CODEC_SFX_IDX
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|compressing
operator|.
name|CompressingTermVectorsWriter
operator|.
name|FLAGS_BITS
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|compressing
operator|.
name|CompressingTermVectorsWriter
operator|.
name|OFFSETS
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|compressing
operator|.
name|CompressingTermVectorsWriter
operator|.
name|PAYLOADS
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|compressing
operator|.
name|CompressingTermVectorsWriter
operator|.
name|POSITIONS
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|compressing
operator|.
name|CompressingTermVectorsWriter
operator|.
name|VECTORS_EXTENSION
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|compressing
operator|.
name|CompressingTermVectorsWriter
operator|.
name|VECTORS_INDEX_EXTENSION
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|compressing
operator|.
name|CompressingTermVectorsWriter
operator|.
name|VERSION_CURRENT
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|compressing
operator|.
name|CompressingTermVectorsWriter
operator|.
name|VERSION_START
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|TermVectorsReader
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CorruptIndexException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Fields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFileNames
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LongsRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|BlockPackedReaderIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|packed
operator|.
name|PackedInts
import|;
end_import
begin_comment
comment|/**  * {@link TermVectorsReader} for {@link CompressingTermVectorsFormat}.  * @lucene.experimental  */
end_comment
begin_class
DECL|class|CompressingTermVectorsReader
specifier|public
specifier|final
class|class
name|CompressingTermVectorsReader
extends|extends
name|TermVectorsReader
implements|implements
name|Closeable
block|{
DECL|field|fieldInfos
specifier|private
specifier|final
name|FieldInfos
name|fieldInfos
decl_stmt|;
DECL|field|indexReader
specifier|final
name|CompressingStoredFieldsIndexReader
name|indexReader
decl_stmt|;
DECL|field|vectorsStream
specifier|final
name|IndexInput
name|vectorsStream
decl_stmt|;
DECL|field|packedIntsVersion
specifier|private
specifier|final
name|int
name|packedIntsVersion
decl_stmt|;
DECL|field|compressionMode
specifier|private
specifier|final
name|CompressionMode
name|compressionMode
decl_stmt|;
DECL|field|decompressor
specifier|private
specifier|final
name|Decompressor
name|decompressor
decl_stmt|;
DECL|field|chunkSize
specifier|private
specifier|final
name|int
name|chunkSize
decl_stmt|;
DECL|field|numDocs
specifier|private
specifier|final
name|int
name|numDocs
decl_stmt|;
DECL|field|closed
specifier|private
name|boolean
name|closed
decl_stmt|;
DECL|field|reader
specifier|private
specifier|final
name|BlockPackedReaderIterator
name|reader
decl_stmt|;
comment|// used by clone
DECL|method|CompressingTermVectorsReader
specifier|private
name|CompressingTermVectorsReader
parameter_list|(
name|CompressingTermVectorsReader
name|reader
parameter_list|)
block|{
name|this
operator|.
name|fieldInfos
operator|=
name|reader
operator|.
name|fieldInfos
expr_stmt|;
name|this
operator|.
name|vectorsStream
operator|=
name|reader
operator|.
name|vectorsStream
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|indexReader
operator|=
name|reader
operator|.
name|indexReader
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|packedIntsVersion
operator|=
name|reader
operator|.
name|packedIntsVersion
expr_stmt|;
name|this
operator|.
name|compressionMode
operator|=
name|reader
operator|.
name|compressionMode
expr_stmt|;
name|this
operator|.
name|decompressor
operator|=
name|reader
operator|.
name|decompressor
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|chunkSize
operator|=
name|reader
operator|.
name|chunkSize
expr_stmt|;
name|this
operator|.
name|numDocs
operator|=
name|reader
operator|.
name|numDocs
expr_stmt|;
name|this
operator|.
name|reader
operator|=
operator|new
name|BlockPackedReaderIterator
argument_list|(
name|vectorsStream
argument_list|,
name|packedIntsVersion
argument_list|,
name|BLOCK_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|closed
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Sole constructor. */
DECL|method|CompressingTermVectorsReader
specifier|public
name|CompressingTermVectorsReader
parameter_list|(
name|Directory
name|d
parameter_list|,
name|SegmentInfo
name|si
parameter_list|,
name|String
name|segmentSuffix
parameter_list|,
name|FieldInfos
name|fn
parameter_list|,
name|IOContext
name|context
parameter_list|,
name|String
name|formatName
parameter_list|,
name|CompressionMode
name|compressionMode
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|compressionMode
operator|=
name|compressionMode
expr_stmt|;
specifier|final
name|String
name|segment
init|=
name|si
operator|.
name|name
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|fieldInfos
operator|=
name|fn
expr_stmt|;
name|numDocs
operator|=
name|si
operator|.
name|getDocCount
argument_list|()
expr_stmt|;
name|IndexInput
name|indexStream
init|=
literal|null
decl_stmt|;
try|try
block|{
name|vectorsStream
operator|=
name|d
operator|.
name|openInput
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segment
argument_list|,
name|segmentSuffix
argument_list|,
name|VECTORS_EXTENSION
argument_list|)
argument_list|,
name|context
argument_list|)
expr_stmt|;
specifier|final
name|String
name|indexStreamFN
init|=
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segment
argument_list|,
name|segmentSuffix
argument_list|,
name|VECTORS_INDEX_EXTENSION
argument_list|)
decl_stmt|;
name|indexStream
operator|=
name|d
operator|.
name|openInput
argument_list|(
name|indexStreamFN
argument_list|,
name|context
argument_list|)
expr_stmt|;
specifier|final
name|String
name|codecNameIdx
init|=
name|formatName
operator|+
name|CODEC_SFX_IDX
decl_stmt|;
specifier|final
name|String
name|codecNameDat
init|=
name|formatName
operator|+
name|CODEC_SFX_DAT
decl_stmt|;
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|indexStream
argument_list|,
name|codecNameIdx
argument_list|,
name|VERSION_START
argument_list|,
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|vectorsStream
argument_list|,
name|codecNameDat
argument_list|,
name|VERSION_START
argument_list|,
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
assert|assert
name|CodecUtil
operator|.
name|headerLength
argument_list|(
name|codecNameDat
argument_list|)
operator|==
name|vectorsStream
operator|.
name|getFilePointer
argument_list|()
assert|;
assert|assert
name|CodecUtil
operator|.
name|headerLength
argument_list|(
name|codecNameIdx
argument_list|)
operator|==
name|indexStream
operator|.
name|getFilePointer
argument_list|()
assert|;
name|indexReader
operator|=
operator|new
name|CompressingStoredFieldsIndexReader
argument_list|(
name|indexStream
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|indexStream
operator|=
literal|null
expr_stmt|;
name|packedIntsVersion
operator|=
name|vectorsStream
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|chunkSize
operator|=
name|vectorsStream
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|decompressor
operator|=
name|compressionMode
operator|.
name|newDecompressor
argument_list|()
expr_stmt|;
name|this
operator|.
name|reader
operator|=
operator|new
name|BlockPackedReaderIterator
argument_list|(
name|vectorsStream
argument_list|,
name|packedIntsVersion
argument_list|,
name|BLOCK_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|this
argument_list|,
name|indexStream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getCompressionMode
name|CompressionMode
name|getCompressionMode
parameter_list|()
block|{
return|return
name|compressionMode
return|;
block|}
DECL|method|getChunkSize
name|int
name|getChunkSize
parameter_list|()
block|{
return|return
name|chunkSize
return|;
block|}
DECL|method|getPackedIntsVersion
name|int
name|getPackedIntsVersion
parameter_list|()
block|{
return|return
name|packedIntsVersion
return|;
block|}
DECL|method|getIndex
name|CompressingStoredFieldsIndexReader
name|getIndex
parameter_list|()
block|{
return|return
name|indexReader
return|;
block|}
DECL|method|getVectorsStream
name|IndexInput
name|getVectorsStream
parameter_list|()
block|{
return|return
name|vectorsStream
return|;
block|}
comment|/**    * @throws AlreadyClosedException if this TermVectorsReader is closed    */
DECL|method|ensureOpen
specifier|private
name|void
name|ensureOpen
parameter_list|()
throws|throws
name|AlreadyClosedException
block|{
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|AlreadyClosedException
argument_list|(
literal|"this FieldsReader is closed"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|vectorsStream
argument_list|,
name|indexReader
argument_list|)
expr_stmt|;
name|closed
operator|=
literal|true
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|clone
specifier|public
name|TermVectorsReader
name|clone
parameter_list|()
block|{
return|return
operator|new
name|CompressingTermVectorsReader
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|get
specifier|public
name|Fields
name|get
parameter_list|(
name|int
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
comment|// seek to the right place
block|{
specifier|final
name|long
name|startPointer
init|=
name|indexReader
operator|.
name|getStartPointer
argument_list|(
name|doc
argument_list|)
decl_stmt|;
name|vectorsStream
operator|.
name|seek
argument_list|(
name|startPointer
argument_list|)
expr_stmt|;
block|}
comment|// decode
comment|// - docBase: first doc ID of the chunk
comment|// - chunkDocs: number of docs of the chunk
specifier|final
name|int
name|docBase
init|=
name|vectorsStream
operator|.
name|readVInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|chunkDocs
init|=
name|vectorsStream
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|doc
argument_list|<
name|docBase
operator|||
name|doc
operator|>=
name|docBase
operator|+
name|chunkDocs
operator|||
name|docBase
operator|+
name|chunkDocs
argument_list|>
name|numDocs
condition|)
block|{
throw|throw
operator|new
name|CorruptIndexException
argument_list|(
literal|"docBase="
operator|+
name|docBase
operator|+
literal|",chunkDocs="
operator|+
name|chunkDocs
operator|+
literal|",doc="
operator|+
name|doc
argument_list|)
throw|;
block|}
specifier|final
name|int
name|skip
decl_stmt|;
comment|// number of fields to skip
specifier|final
name|int
name|numFields
decl_stmt|;
comment|// number of fields of the document we're looking for
specifier|final
name|int
name|totalFields
decl_stmt|;
comment|// total number of fields of the chunk (sum for all docs)
if|if
condition|(
name|chunkDocs
operator|==
literal|1
condition|)
block|{
name|skip
operator|=
literal|0
expr_stmt|;
name|numFields
operator|=
name|totalFields
operator|=
name|vectorsStream
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|reader
operator|.
name|reset
argument_list|(
name|vectorsStream
argument_list|,
name|chunkDocs
argument_list|)
expr_stmt|;
name|int
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|docBase
init|;
name|i
operator|<
name|doc
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|+=
name|reader
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
name|skip
operator|=
name|sum
expr_stmt|;
name|numFields
operator|=
operator|(
name|int
operator|)
name|reader
operator|.
name|next
argument_list|()
expr_stmt|;
name|sum
operator|+=
name|numFields
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|doc
operator|+
literal|1
init|;
name|i
operator|<
name|docBase
operator|+
name|chunkDocs
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|+=
name|reader
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
name|totalFields
operator|=
name|sum
expr_stmt|;
block|}
if|if
condition|(
name|numFields
operator|==
literal|0
condition|)
block|{
comment|// no vectors
return|return
literal|null
return|;
block|}
comment|// read field numbers that have term vectors
specifier|final
name|int
index|[]
name|fieldNums
decl_stmt|;
block|{
specifier|final
name|int
name|token
init|=
name|vectorsStream
operator|.
name|readByte
argument_list|()
operator|&
literal|0xFF
decl_stmt|;
assert|assert
name|token
operator|!=
literal|0
assert|;
comment|// means no term vectors, cannot happen since we checked for numFields == 0
specifier|final
name|int
name|bitsPerFieldNum
init|=
name|token
operator|&
literal|0x1F
decl_stmt|;
name|int
name|totalDistinctFields
init|=
name|token
operator|>>>
literal|5
decl_stmt|;
if|if
condition|(
name|totalDistinctFields
operator|==
literal|0x07
condition|)
block|{
name|totalDistinctFields
operator|+=
name|vectorsStream
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
operator|++
name|totalDistinctFields
expr_stmt|;
specifier|final
name|PackedInts
operator|.
name|ReaderIterator
name|it
init|=
name|PackedInts
operator|.
name|getReaderIteratorNoHeader
argument_list|(
name|vectorsStream
argument_list|,
name|PackedInts
operator|.
name|Format
operator|.
name|PACKED
argument_list|,
name|packedIntsVersion
argument_list|,
name|totalDistinctFields
argument_list|,
name|bitsPerFieldNum
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|fieldNums
operator|=
operator|new
name|int
index|[
name|totalDistinctFields
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|totalDistinctFields
condition|;
operator|++
name|i
control|)
block|{
name|fieldNums
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
comment|// read field numbers and flags
specifier|final
name|int
index|[]
name|fieldNumOffs
init|=
operator|new
name|int
index|[
name|numFields
index|]
decl_stmt|;
specifier|final
name|PackedInts
operator|.
name|Reader
name|flags
decl_stmt|;
block|{
specifier|final
name|int
name|bitsPerOff
init|=
name|PackedInts
operator|.
name|bitsRequired
argument_list|(
name|fieldNums
operator|.
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|PackedInts
operator|.
name|Reader
name|allFieldNumOffs
init|=
name|PackedInts
operator|.
name|getReaderNoHeader
argument_list|(
name|vectorsStream
argument_list|,
name|PackedInts
operator|.
name|Format
operator|.
name|PACKED
argument_list|,
name|packedIntsVersion
argument_list|,
name|totalFields
argument_list|,
name|bitsPerOff
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|vectorsStream
operator|.
name|readVInt
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
specifier|final
name|PackedInts
operator|.
name|Reader
name|fieldFlags
init|=
name|PackedInts
operator|.
name|getReaderNoHeader
argument_list|(
name|vectorsStream
argument_list|,
name|PackedInts
operator|.
name|Format
operator|.
name|PACKED
argument_list|,
name|packedIntsVersion
argument_list|,
name|fieldNums
operator|.
name|length
argument_list|,
name|FLAGS_BITS
argument_list|)
decl_stmt|;
name|PackedInts
operator|.
name|Mutable
name|f
init|=
name|PackedInts
operator|.
name|getMutable
argument_list|(
name|totalFields
argument_list|,
name|FLAGS_BITS
argument_list|,
name|PackedInts
operator|.
name|COMPACT
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|totalFields
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
name|fieldNumOff
init|=
operator|(
name|int
operator|)
name|allFieldNumOffs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
assert|assert
name|fieldNumOff
operator|>=
literal|0
operator|&&
name|fieldNumOff
operator|<
name|fieldNums
operator|.
name|length
assert|;
specifier|final
name|int
name|fgs
init|=
operator|(
name|int
operator|)
name|fieldFlags
operator|.
name|get
argument_list|(
name|fieldNumOff
argument_list|)
decl_stmt|;
name|f
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|fgs
argument_list|)
expr_stmt|;
block|}
name|flags
operator|=
name|f
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|flags
operator|=
name|PackedInts
operator|.
name|getReaderNoHeader
argument_list|(
name|vectorsStream
argument_list|,
name|PackedInts
operator|.
name|Format
operator|.
name|PACKED
argument_list|,
name|packedIntsVersion
argument_list|,
name|totalFields
argument_list|,
name|FLAGS_BITS
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
operator|++
name|i
control|)
block|{
name|fieldNumOffs
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|allFieldNumOffs
operator|.
name|get
argument_list|(
name|skip
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|// number of terms per field for all fields
specifier|final
name|PackedInts
operator|.
name|Reader
name|numTerms
decl_stmt|;
specifier|final
name|int
name|totalTerms
decl_stmt|;
block|{
specifier|final
name|int
name|bitsRequired
init|=
name|vectorsStream
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|numTerms
operator|=
name|PackedInts
operator|.
name|getReaderNoHeader
argument_list|(
name|vectorsStream
argument_list|,
name|PackedInts
operator|.
name|Format
operator|.
name|PACKED
argument_list|,
name|packedIntsVersion
argument_list|,
name|totalFields
argument_list|,
name|bitsRequired
argument_list|)
expr_stmt|;
name|int
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|totalFields
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|+=
name|numTerms
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|totalTerms
operator|=
name|sum
expr_stmt|;
block|}
comment|// term lengths
name|int
name|docOff
init|=
literal|0
decl_stmt|,
name|docLen
init|=
literal|0
decl_stmt|,
name|totalLen
decl_stmt|;
specifier|final
name|int
index|[]
name|fieldLengths
init|=
operator|new
name|int
index|[
name|numFields
index|]
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|prefixLengths
init|=
operator|new
name|int
index|[
name|numFields
index|]
index|[]
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|suffixLengths
init|=
operator|new
name|int
index|[
name|numFields
index|]
index|[]
decl_stmt|;
block|{
name|reader
operator|.
name|reset
argument_list|(
name|vectorsStream
argument_list|,
name|totalTerms
argument_list|)
expr_stmt|;
comment|// skip
name|int
name|toSkip
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|skip
condition|;
operator|++
name|i
control|)
block|{
name|toSkip
operator|+=
name|numTerms
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|reader
operator|.
name|skip
argument_list|(
name|toSkip
argument_list|)
expr_stmt|;
comment|// read prefix lengths
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
name|termCount
init|=
operator|(
name|int
operator|)
name|numTerms
operator|.
name|get
argument_list|(
name|skip
operator|+
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
index|[]
name|fieldPrefixLengths
init|=
operator|new
name|int
index|[
name|termCount
index|]
decl_stmt|;
name|prefixLengths
index|[
name|i
index|]
operator|=
name|fieldPrefixLengths
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|termCount
condition|;
control|)
block|{
specifier|final
name|LongsRef
name|next
init|=
name|reader
operator|.
name|next
argument_list|(
name|termCount
operator|-
name|j
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|next
operator|.
name|length
condition|;
operator|++
name|k
control|)
block|{
name|fieldPrefixLengths
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|int
operator|)
name|next
operator|.
name|longs
index|[
name|next
operator|.
name|offset
operator|+
name|k
index|]
expr_stmt|;
block|}
block|}
block|}
name|reader
operator|.
name|skip
argument_list|(
name|totalTerms
operator|-
name|reader
operator|.
name|ord
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|reset
argument_list|(
name|vectorsStream
argument_list|,
name|totalTerms
argument_list|)
expr_stmt|;
comment|// skip
name|toSkip
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|skip
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numTerms
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
name|docOff
operator|+=
name|reader
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
name|termCount
init|=
operator|(
name|int
operator|)
name|numTerms
operator|.
name|get
argument_list|(
name|skip
operator|+
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
index|[]
name|fieldSuffixLengths
init|=
operator|new
name|int
index|[
name|termCount
index|]
decl_stmt|;
name|suffixLengths
index|[
name|i
index|]
operator|=
name|fieldSuffixLengths
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|termCount
condition|;
control|)
block|{
specifier|final
name|LongsRef
name|next
init|=
name|reader
operator|.
name|next
argument_list|(
name|termCount
operator|-
name|j
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|next
operator|.
name|length
condition|;
operator|++
name|k
control|)
block|{
name|fieldSuffixLengths
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|int
operator|)
name|next
operator|.
name|longs
index|[
name|next
operator|.
name|offset
operator|+
name|k
index|]
expr_stmt|;
block|}
block|}
name|fieldLengths
index|[
name|i
index|]
operator|=
name|sum
argument_list|(
name|suffixLengths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|docLen
operator|+=
name|fieldLengths
index|[
name|i
index|]
expr_stmt|;
block|}
name|totalLen
operator|=
name|docOff
operator|+
name|docLen
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|skip
operator|+
name|numFields
init|;
name|i
operator|<
name|totalFields
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numTerms
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
name|totalLen
operator|+=
name|reader
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// term freqs
specifier|final
name|int
index|[]
name|termFreqs
init|=
operator|new
name|int
index|[
name|totalTerms
index|]
decl_stmt|;
block|{
name|reader
operator|.
name|reset
argument_list|(
name|vectorsStream
argument_list|,
name|totalTerms
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|totalTerms
condition|;
control|)
block|{
specifier|final
name|LongsRef
name|next
init|=
name|reader
operator|.
name|next
argument_list|(
name|totalTerms
operator|-
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|next
operator|.
name|length
condition|;
operator|++
name|k
control|)
block|{
name|termFreqs
index|[
name|i
operator|++
index|]
operator|=
literal|1
operator|+
operator|(
name|int
operator|)
name|next
operator|.
name|longs
index|[
name|next
operator|.
name|offset
operator|+
name|k
index|]
expr_stmt|;
block|}
block|}
block|}
comment|// total number of positions, offsets and payloads
name|int
name|totalPositions
init|=
literal|0
decl_stmt|,
name|totalOffsets
init|=
literal|0
decl_stmt|,
name|totalPayloads
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|termIndex
init|=
literal|0
init|;
name|i
operator|<
name|totalFields
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
name|f
init|=
operator|(
name|int
operator|)
name|flags
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|termCount
init|=
operator|(
name|int
operator|)
name|numTerms
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|termCount
condition|;
operator|++
name|j
control|)
block|{
specifier|final
name|int
name|freq
init|=
name|termFreqs
index|[
name|termIndex
operator|++
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|&
name|POSITIONS
operator|)
operator|!=
literal|0
condition|)
block|{
name|totalPositions
operator|+=
name|freq
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|f
operator|&
name|OFFSETS
operator|)
operator|!=
literal|0
condition|)
block|{
name|totalOffsets
operator|+=
name|freq
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|f
operator|&
name|PAYLOADS
operator|)
operator|!=
literal|0
condition|)
block|{
name|totalPayloads
operator|+=
name|freq
expr_stmt|;
block|}
block|}
assert|assert
name|i
operator|!=
name|totalFields
operator|-
literal|1
operator|||
name|termIndex
operator|==
name|totalTerms
operator|:
name|termIndex
operator|+
literal|" "
operator|+
name|totalTerms
assert|;
block|}
specifier|final
name|int
index|[]
index|[]
name|positionIndex
init|=
name|positionIndex
argument_list|(
name|skip
argument_list|,
name|numFields
argument_list|,
name|numTerms
argument_list|,
name|termFreqs
argument_list|)
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|positions
decl_stmt|,
name|startOffsets
decl_stmt|,
name|lengths
decl_stmt|;
if|if
condition|(
name|totalPositions
operator|>
literal|0
condition|)
block|{
name|positions
operator|=
name|readPositions
argument_list|(
name|skip
argument_list|,
name|numFields
argument_list|,
name|flags
argument_list|,
name|numTerms
argument_list|,
name|termFreqs
argument_list|,
name|POSITIONS
argument_list|,
name|totalPositions
argument_list|,
name|positionIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|positions
operator|=
operator|new
name|int
index|[
name|numFields
index|]
index|[]
expr_stmt|;
block|}
if|if
condition|(
name|totalOffsets
operator|>
literal|0
condition|)
block|{
comment|// average number of chars per term
specifier|final
name|float
index|[]
name|charsPerTerm
init|=
operator|new
name|float
index|[
name|fieldNums
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|charsPerTerm
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|charsPerTerm
index|[
name|i
index|]
operator|=
name|Float
operator|.
name|intBitsToFloat
argument_list|(
name|vectorsStream
operator|.
name|readInt
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|startOffsets
operator|=
name|readPositions
argument_list|(
name|skip
argument_list|,
name|numFields
argument_list|,
name|flags
argument_list|,
name|numTerms
argument_list|,
name|termFreqs
argument_list|,
name|OFFSETS
argument_list|,
name|totalOffsets
argument_list|,
name|positionIndex
argument_list|)
expr_stmt|;
name|lengths
operator|=
name|readPositions
argument_list|(
name|skip
argument_list|,
name|numFields
argument_list|,
name|flags
argument_list|,
name|numTerms
argument_list|,
name|termFreqs
argument_list|,
name|OFFSETS
argument_list|,
name|totalOffsets
argument_list|,
name|positionIndex
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
index|[]
name|fStartOffsets
init|=
name|startOffsets
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|int
index|[]
name|fPositions
init|=
name|positions
index|[
name|i
index|]
decl_stmt|;
comment|// patch offsets from positions
if|if
condition|(
name|fStartOffsets
operator|!=
literal|null
operator|&&
name|fPositions
operator|!=
literal|null
condition|)
block|{
specifier|final
name|float
name|fieldCharsPerTerm
init|=
name|charsPerTerm
index|[
name|fieldNumOffs
index|[
name|i
index|]
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|startOffsets
index|[
name|i
index|]
operator|.
name|length
condition|;
operator|++
name|j
control|)
block|{
name|fStartOffsets
index|[
name|j
index|]
operator|+=
call|(
name|int
call|)
argument_list|(
name|fieldCharsPerTerm
operator|*
name|fPositions
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fStartOffsets
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
index|[]
name|fPrefixLengths
init|=
name|prefixLengths
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|int
index|[]
name|fSuffixLengths
init|=
name|suffixLengths
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|int
index|[]
name|fLengths
init|=
name|lengths
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|,
name|end
init|=
operator|(
name|int
operator|)
name|numTerms
operator|.
name|get
argument_list|(
name|skip
operator|+
name|i
argument_list|)
init|;
name|j
operator|<
name|end
condition|;
operator|++
name|j
control|)
block|{
comment|// delta-decode start offsets and  patch lengths using term lengths
specifier|final
name|int
name|termLength
init|=
name|fPrefixLengths
index|[
name|j
index|]
operator|+
name|fSuffixLengths
index|[
name|j
index|]
decl_stmt|;
name|lengths
index|[
name|i
index|]
index|[
name|positionIndex
index|[
name|i
index|]
index|[
name|j
index|]
index|]
operator|+=
name|termLength
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
name|positionIndex
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
literal|1
init|;
name|k
operator|<
name|positionIndex
index|[
name|i
index|]
index|[
name|j
operator|+
literal|1
index|]
condition|;
operator|++
name|k
control|)
block|{
name|fStartOffsets
index|[
name|k
index|]
operator|+=
name|fStartOffsets
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
name|fLengths
index|[
name|k
index|]
operator|+=
name|termLength
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|startOffsets
operator|=
name|lengths
operator|=
operator|new
name|int
index|[
name|numFields
index|]
index|[]
expr_stmt|;
block|}
if|if
condition|(
name|totalPositions
operator|>
literal|0
condition|)
block|{
comment|// delta-decode positions
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
index|[]
name|fPositions
init|=
name|positions
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|int
index|[]
name|fpositionIndex
init|=
name|positionIndex
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|fPositions
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|,
name|end
init|=
operator|(
name|int
operator|)
name|numTerms
operator|.
name|get
argument_list|(
name|skip
operator|+
name|i
argument_list|)
init|;
name|j
operator|<
name|end
condition|;
operator|++
name|j
control|)
block|{
comment|// delta-decode start offsets
for|for
control|(
name|int
name|k
init|=
name|fpositionIndex
index|[
name|j
index|]
operator|+
literal|1
init|;
name|k
operator|<
name|fpositionIndex
index|[
name|j
operator|+
literal|1
index|]
condition|;
operator|++
name|k
control|)
block|{
name|fPositions
index|[
name|k
index|]
operator|+=
name|fPositions
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// payload lengths
specifier|final
name|int
index|[]
index|[]
name|payloadIndex
init|=
operator|new
name|int
index|[
name|numFields
index|]
index|[]
decl_stmt|;
name|int
name|totalPayloadLength
init|=
literal|0
decl_stmt|;
name|int
name|payloadOff
init|=
literal|0
decl_stmt|;
name|int
name|payloadLen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|totalPayloads
operator|>
literal|0
condition|)
block|{
name|reader
operator|.
name|reset
argument_list|(
name|vectorsStream
argument_list|,
name|totalPayloads
argument_list|)
expr_stmt|;
comment|// skip
name|int
name|termIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|skip
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
name|f
init|=
operator|(
name|int
operator|)
name|flags
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|termCount
init|=
operator|(
name|int
operator|)
name|numTerms
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|&
name|PAYLOADS
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|termCount
condition|;
operator|++
name|j
control|)
block|{
specifier|final
name|int
name|freq
init|=
name|termFreqs
index|[
name|termIndex
operator|+
name|j
index|]
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|freq
condition|;
operator|++
name|k
control|)
block|{
specifier|final
name|int
name|l
init|=
operator|(
name|int
operator|)
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
name|payloadOff
operator|+=
name|l
expr_stmt|;
block|}
block|}
block|}
name|termIndex
operator|+=
name|termCount
expr_stmt|;
block|}
name|totalPayloadLength
operator|=
name|payloadOff
expr_stmt|;
comment|// read doc payload lengths
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
name|f
init|=
operator|(
name|int
operator|)
name|flags
operator|.
name|get
argument_list|(
name|skip
operator|+
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|termCount
init|=
operator|(
name|int
operator|)
name|numTerms
operator|.
name|get
argument_list|(
name|skip
operator|+
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|&
name|PAYLOADS
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|final
name|int
name|totalFreq
init|=
name|positionIndex
index|[
name|i
index|]
index|[
name|termCount
index|]
decl_stmt|;
name|payloadIndex
index|[
name|i
index|]
operator|=
operator|new
name|int
index|[
name|totalFreq
operator|+
literal|1
index|]
expr_stmt|;
name|int
name|posIdx
init|=
literal|0
decl_stmt|;
name|payloadIndex
index|[
name|i
index|]
index|[
name|posIdx
index|]
operator|=
name|payloadLen
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|termCount
condition|;
operator|++
name|j
control|)
block|{
specifier|final
name|int
name|freq
init|=
name|termFreqs
index|[
name|termIndex
operator|+
name|j
index|]
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|freq
condition|;
operator|++
name|k
control|)
block|{
specifier|final
name|int
name|payloadLength
init|=
operator|(
name|int
operator|)
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
name|payloadLen
operator|+=
name|payloadLength
expr_stmt|;
name|payloadIndex
index|[
name|i
index|]
index|[
name|posIdx
operator|+
literal|1
index|]
operator|=
name|payloadLen
expr_stmt|;
operator|++
name|posIdx
expr_stmt|;
block|}
block|}
assert|assert
name|posIdx
operator|==
name|totalFreq
assert|;
block|}
name|termIndex
operator|+=
name|termCount
expr_stmt|;
block|}
name|totalPayloadLength
operator|+=
name|payloadLen
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|skip
operator|+
name|numFields
init|;
name|i
operator|<
name|totalFields
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
name|f
init|=
operator|(
name|int
operator|)
name|flags
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|termCount
init|=
operator|(
name|int
operator|)
name|numTerms
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|&
name|PAYLOADS
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|termCount
condition|;
operator|++
name|j
control|)
block|{
specifier|final
name|int
name|freq
init|=
name|termFreqs
index|[
name|termIndex
operator|+
name|j
index|]
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|freq
condition|;
operator|++
name|k
control|)
block|{
name|totalPayloadLength
operator|+=
name|reader
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|termIndex
operator|+=
name|termCount
expr_stmt|;
block|}
assert|assert
name|termIndex
operator|==
name|totalTerms
operator|:
name|termIndex
operator|+
literal|" "
operator|+
name|totalTerms
assert|;
block|}
comment|// decompress data
specifier|final
name|BytesRef
name|suffixBytes
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
name|decompressor
operator|.
name|decompress
argument_list|(
name|vectorsStream
argument_list|,
name|totalLen
operator|+
name|totalPayloadLength
argument_list|,
name|docOff
operator|+
name|payloadOff
argument_list|,
name|docLen
operator|+
name|payloadLen
argument_list|,
name|suffixBytes
argument_list|)
expr_stmt|;
name|suffixBytes
operator|.
name|length
operator|=
name|docLen
expr_stmt|;
specifier|final
name|BytesRef
name|payloadBytes
init|=
operator|new
name|BytesRef
argument_list|(
name|suffixBytes
operator|.
name|bytes
argument_list|,
name|suffixBytes
operator|.
name|offset
operator|+
name|docLen
argument_list|,
name|payloadLen
argument_list|)
decl_stmt|;
specifier|final
name|int
index|[]
name|fieldFlags
init|=
operator|new
name|int
index|[
name|numFields
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
operator|++
name|i
control|)
block|{
name|fieldFlags
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|flags
operator|.
name|get
argument_list|(
name|skip
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
index|[]
name|fieldNumTerms
init|=
operator|new
name|int
index|[
name|numFields
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
operator|++
name|i
control|)
block|{
name|fieldNumTerms
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|numTerms
operator|.
name|get
argument_list|(
name|skip
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
index|[]
index|[]
name|fieldTermFreqs
init|=
operator|new
name|int
index|[
name|numFields
index|]
index|[]
decl_stmt|;
block|{
name|int
name|termIdx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|skip
condition|;
operator|++
name|i
control|)
block|{
name|termIdx
operator|+=
name|numTerms
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
name|termCount
init|=
operator|(
name|int
operator|)
name|numTerms
operator|.
name|get
argument_list|(
name|skip
operator|+
name|i
argument_list|)
decl_stmt|;
name|fieldTermFreqs
index|[
name|i
index|]
operator|=
operator|new
name|int
index|[
name|termCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|termCount
condition|;
operator|++
name|j
control|)
block|{
name|fieldTermFreqs
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|termFreqs
index|[
name|termIdx
operator|++
index|]
expr_stmt|;
block|}
block|}
block|}
assert|assert
name|sum
argument_list|(
name|fieldLengths
argument_list|)
operator|==
name|docLen
operator|:
name|sum
argument_list|(
name|fieldLengths
argument_list|)
operator|+
literal|" != "
operator|+
name|docLen
assert|;
return|return
operator|new
name|TVFields
argument_list|(
name|fieldNums
argument_list|,
name|fieldFlags
argument_list|,
name|fieldNumOffs
argument_list|,
name|fieldNumTerms
argument_list|,
name|fieldLengths
argument_list|,
name|prefixLengths
argument_list|,
name|suffixLengths
argument_list|,
name|fieldTermFreqs
argument_list|,
name|positionIndex
argument_list|,
name|positions
argument_list|,
name|startOffsets
argument_list|,
name|lengths
argument_list|,
name|payloadBytes
argument_list|,
name|payloadIndex
argument_list|,
name|suffixBytes
argument_list|)
return|;
block|}
comment|// field -> term index -> position index
DECL|method|positionIndex
specifier|private
name|int
index|[]
index|[]
name|positionIndex
parameter_list|(
name|int
name|skip
parameter_list|,
name|int
name|numFields
parameter_list|,
name|PackedInts
operator|.
name|Reader
name|numTerms
parameter_list|,
name|int
index|[]
name|termFreqs
parameter_list|)
block|{
specifier|final
name|int
index|[]
index|[]
name|positionIndex
init|=
operator|new
name|int
index|[
name|numFields
index|]
index|[]
decl_stmt|;
name|int
name|termIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|skip
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
name|termCount
init|=
operator|(
name|int
operator|)
name|numTerms
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|termIndex
operator|+=
name|termCount
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
name|termCount
init|=
operator|(
name|int
operator|)
name|numTerms
operator|.
name|get
argument_list|(
name|skip
operator|+
name|i
argument_list|)
decl_stmt|;
name|positionIndex
index|[
name|i
index|]
operator|=
operator|new
name|int
index|[
name|termCount
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|termCount
condition|;
operator|++
name|j
control|)
block|{
specifier|final
name|int
name|freq
init|=
name|termFreqs
index|[
name|termIndex
operator|+
name|j
index|]
decl_stmt|;
name|positionIndex
index|[
name|i
index|]
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|positionIndex
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
name|freq
expr_stmt|;
block|}
name|termIndex
operator|+=
name|termCount
expr_stmt|;
block|}
return|return
name|positionIndex
return|;
block|}
DECL|method|readPositions
specifier|private
name|int
index|[]
index|[]
name|readPositions
parameter_list|(
name|int
name|skip
parameter_list|,
name|int
name|numFields
parameter_list|,
name|PackedInts
operator|.
name|Reader
name|flags
parameter_list|,
name|PackedInts
operator|.
name|Reader
name|numTerms
parameter_list|,
name|int
index|[]
name|termFreqs
parameter_list|,
name|int
name|flag
parameter_list|,
specifier|final
name|int
name|totalPositions
parameter_list|,
name|int
index|[]
index|[]
name|positionIndex
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
index|[]
index|[]
name|positions
init|=
operator|new
name|int
index|[
name|numFields
index|]
index|[]
decl_stmt|;
name|reader
operator|.
name|reset
argument_list|(
name|vectorsStream
argument_list|,
name|totalPositions
argument_list|)
expr_stmt|;
comment|// skip
name|int
name|toSkip
init|=
literal|0
decl_stmt|;
name|int
name|termIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|skip
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
name|f
init|=
operator|(
name|int
operator|)
name|flags
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|termCount
init|=
operator|(
name|int
operator|)
name|numTerms
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|&
name|flag
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|termCount
condition|;
operator|++
name|j
control|)
block|{
specifier|final
name|int
name|freq
init|=
name|termFreqs
index|[
name|termIndex
operator|+
name|j
index|]
decl_stmt|;
name|toSkip
operator|+=
name|freq
expr_stmt|;
block|}
block|}
name|termIndex
operator|+=
name|termCount
expr_stmt|;
block|}
name|reader
operator|.
name|skip
argument_list|(
name|toSkip
argument_list|)
expr_stmt|;
comment|// read doc positions
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
name|f
init|=
operator|(
name|int
operator|)
name|flags
operator|.
name|get
argument_list|(
name|skip
operator|+
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|termCount
init|=
operator|(
name|int
operator|)
name|numTerms
operator|.
name|get
argument_list|(
name|skip
operator|+
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|&
name|flag
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|final
name|int
name|totalFreq
init|=
name|positionIndex
index|[
name|i
index|]
index|[
name|termCount
index|]
decl_stmt|;
specifier|final
name|int
index|[]
name|fieldPositions
init|=
operator|new
name|int
index|[
name|totalFreq
index|]
decl_stmt|;
name|positions
index|[
name|i
index|]
operator|=
name|fieldPositions
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|totalFreq
condition|;
control|)
block|{
specifier|final
name|LongsRef
name|nextPositions
init|=
name|reader
operator|.
name|next
argument_list|(
name|totalFreq
operator|-
name|j
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|nextPositions
operator|.
name|length
condition|;
operator|++
name|k
control|)
block|{
name|fieldPositions
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|int
operator|)
name|nextPositions
operator|.
name|longs
index|[
name|nextPositions
operator|.
name|offset
operator|+
name|k
index|]
expr_stmt|;
block|}
block|}
block|}
name|termIndex
operator|+=
name|termCount
expr_stmt|;
block|}
name|reader
operator|.
name|skip
argument_list|(
name|totalPositions
operator|-
name|reader
operator|.
name|ord
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|positions
return|;
block|}
DECL|class|TVFields
specifier|private
class|class
name|TVFields
extends|extends
name|Fields
block|{
DECL|field|fieldNums
DECL|field|fieldFlags
DECL|field|fieldNumOffs
DECL|field|numTerms
DECL|field|fieldLengths
specifier|private
specifier|final
name|int
index|[]
name|fieldNums
decl_stmt|,
name|fieldFlags
decl_stmt|,
name|fieldNumOffs
decl_stmt|,
name|numTerms
decl_stmt|,
name|fieldLengths
decl_stmt|;
DECL|field|prefixLengths
DECL|field|suffixLengths
DECL|field|termFreqs
DECL|field|positionIndex
DECL|field|positions
DECL|field|startOffsets
DECL|field|lengths
DECL|field|payloadIndex
specifier|private
specifier|final
name|int
index|[]
index|[]
name|prefixLengths
decl_stmt|,
name|suffixLengths
decl_stmt|,
name|termFreqs
decl_stmt|,
name|positionIndex
decl_stmt|,
name|positions
decl_stmt|,
name|startOffsets
decl_stmt|,
name|lengths
decl_stmt|,
name|payloadIndex
decl_stmt|;
DECL|field|suffixBytes
DECL|field|payloadBytes
specifier|private
specifier|final
name|BytesRef
name|suffixBytes
decl_stmt|,
name|payloadBytes
decl_stmt|;
DECL|method|TVFields
specifier|public
name|TVFields
parameter_list|(
name|int
index|[]
name|fieldNums
parameter_list|,
name|int
index|[]
name|fieldFlags
parameter_list|,
name|int
index|[]
name|fieldNumOffs
parameter_list|,
name|int
index|[]
name|numTerms
parameter_list|,
name|int
index|[]
name|fieldLengths
parameter_list|,
name|int
index|[]
index|[]
name|prefixLengths
parameter_list|,
name|int
index|[]
index|[]
name|suffixLengths
parameter_list|,
name|int
index|[]
index|[]
name|termFreqs
parameter_list|,
name|int
index|[]
index|[]
name|positionIndex
parameter_list|,
name|int
index|[]
index|[]
name|positions
parameter_list|,
name|int
index|[]
index|[]
name|startOffsets
parameter_list|,
name|int
index|[]
index|[]
name|lengths
parameter_list|,
name|BytesRef
name|payloadBytes
parameter_list|,
name|int
index|[]
index|[]
name|payloadIndex
parameter_list|,
name|BytesRef
name|suffixBytes
parameter_list|)
block|{
name|this
operator|.
name|fieldNums
operator|=
name|fieldNums
expr_stmt|;
name|this
operator|.
name|fieldFlags
operator|=
name|fieldFlags
expr_stmt|;
name|this
operator|.
name|fieldNumOffs
operator|=
name|fieldNumOffs
expr_stmt|;
name|this
operator|.
name|numTerms
operator|=
name|numTerms
expr_stmt|;
name|this
operator|.
name|fieldLengths
operator|=
name|fieldLengths
expr_stmt|;
name|this
operator|.
name|prefixLengths
operator|=
name|prefixLengths
expr_stmt|;
name|this
operator|.
name|suffixLengths
operator|=
name|suffixLengths
expr_stmt|;
name|this
operator|.
name|termFreqs
operator|=
name|termFreqs
expr_stmt|;
name|this
operator|.
name|positionIndex
operator|=
name|positionIndex
expr_stmt|;
name|this
operator|.
name|positions
operator|=
name|positions
expr_stmt|;
name|this
operator|.
name|startOffsets
operator|=
name|startOffsets
expr_stmt|;
name|this
operator|.
name|lengths
operator|=
name|lengths
expr_stmt|;
name|this
operator|.
name|payloadBytes
operator|=
name|payloadBytes
expr_stmt|;
name|this
operator|.
name|payloadIndex
operator|=
name|payloadIndex
expr_stmt|;
name|this
operator|.
name|suffixBytes
operator|=
name|suffixBytes
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|i
operator|<
name|fieldNumOffs
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
specifier|final
name|int
name|fieldNum
init|=
name|fieldNums
index|[
name|fieldNumOffs
index|[
name|i
operator|++
index|]
index|]
decl_stmt|;
return|return
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|fieldNum
argument_list|)
operator|.
name|name
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|terms
specifier|public
name|Terms
name|terms
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FieldInfo
name|fieldInfo
init|=
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldInfo
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|idx
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldNumOffs
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fieldNums
index|[
name|fieldNumOffs
index|[
name|i
index|]
index|]
operator|==
name|fieldInfo
operator|.
name|number
condition|)
block|{
name|idx
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|numTerms
index|[
name|idx
index|]
operator|==
literal|0
condition|)
block|{
comment|// no term
return|return
literal|null
return|;
block|}
name|int
name|fieldOff
init|=
literal|0
decl_stmt|,
name|fieldLen
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldNumOffs
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|<
name|idx
condition|)
block|{
name|fieldOff
operator|+=
name|fieldLengths
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|fieldLen
operator|=
name|fieldLengths
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
assert|assert
name|fieldLen
operator|>=
literal|0
assert|;
return|return
operator|new
name|TVTerms
argument_list|(
name|numTerms
index|[
name|idx
index|]
argument_list|,
name|fieldFlags
index|[
name|idx
index|]
argument_list|,
name|prefixLengths
index|[
name|idx
index|]
argument_list|,
name|suffixLengths
index|[
name|idx
index|]
argument_list|,
name|termFreqs
index|[
name|idx
index|]
argument_list|,
name|positionIndex
index|[
name|idx
index|]
argument_list|,
name|positions
index|[
name|idx
index|]
argument_list|,
name|startOffsets
index|[
name|idx
index|]
argument_list|,
name|lengths
index|[
name|idx
index|]
argument_list|,
name|payloadIndex
index|[
name|idx
index|]
argument_list|,
name|payloadBytes
argument_list|,
operator|new
name|BytesRef
argument_list|(
name|suffixBytes
operator|.
name|bytes
argument_list|,
name|suffixBytes
operator|.
name|offset
operator|+
name|fieldOff
argument_list|,
name|fieldLen
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fieldNumOffs
operator|.
name|length
return|;
block|}
block|}
DECL|class|TVTerms
specifier|private
class|class
name|TVTerms
extends|extends
name|Terms
block|{
DECL|field|numTerms
DECL|field|flags
specifier|private
specifier|final
name|int
name|numTerms
decl_stmt|,
name|flags
decl_stmt|;
DECL|field|prefixLengths
DECL|field|suffixLengths
DECL|field|termFreqs
DECL|field|positionIndex
DECL|field|positions
DECL|field|startOffsets
DECL|field|lengths
DECL|field|payloadIndex
specifier|private
specifier|final
name|int
index|[]
name|prefixLengths
decl_stmt|,
name|suffixLengths
decl_stmt|,
name|termFreqs
decl_stmt|,
name|positionIndex
decl_stmt|,
name|positions
decl_stmt|,
name|startOffsets
decl_stmt|,
name|lengths
decl_stmt|,
name|payloadIndex
decl_stmt|;
DECL|field|termBytes
DECL|field|payloadBytes
specifier|private
specifier|final
name|BytesRef
name|termBytes
decl_stmt|,
name|payloadBytes
decl_stmt|;
DECL|method|TVTerms
name|TVTerms
parameter_list|(
name|int
name|numTerms
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
index|[]
name|prefixLengths
parameter_list|,
name|int
index|[]
name|suffixLengths
parameter_list|,
name|int
index|[]
name|termFreqs
parameter_list|,
name|int
index|[]
name|positionIndex
parameter_list|,
name|int
index|[]
name|positions
parameter_list|,
name|int
index|[]
name|startOffsets
parameter_list|,
name|int
index|[]
name|lengths
parameter_list|,
name|int
index|[]
name|payloadIndex
parameter_list|,
name|BytesRef
name|payloadBytes
parameter_list|,
name|BytesRef
name|termBytes
parameter_list|)
block|{
name|this
operator|.
name|numTerms
operator|=
name|numTerms
expr_stmt|;
name|this
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|this
operator|.
name|prefixLengths
operator|=
name|prefixLengths
expr_stmt|;
name|this
operator|.
name|suffixLengths
operator|=
name|suffixLengths
expr_stmt|;
name|this
operator|.
name|termFreqs
operator|=
name|termFreqs
expr_stmt|;
name|this
operator|.
name|positionIndex
operator|=
name|positionIndex
expr_stmt|;
name|this
operator|.
name|positions
operator|=
name|positions
expr_stmt|;
name|this
operator|.
name|startOffsets
operator|=
name|startOffsets
expr_stmt|;
name|this
operator|.
name|lengths
operator|=
name|lengths
expr_stmt|;
name|this
operator|.
name|payloadIndex
operator|=
name|payloadIndex
expr_stmt|;
name|this
operator|.
name|payloadBytes
operator|=
name|payloadBytes
expr_stmt|;
name|this
operator|.
name|termBytes
operator|=
name|termBytes
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|TermsEnum
name|iterator
parameter_list|(
name|TermsEnum
name|reuse
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|TVTermsEnum
name|termsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|!=
literal|null
operator|&&
name|reuse
operator|instanceof
name|TVTermsEnum
condition|)
block|{
name|termsEnum
operator|=
operator|(
name|TVTermsEnum
operator|)
name|reuse
expr_stmt|;
block|}
else|else
block|{
name|termsEnum
operator|=
operator|new
name|TVTermsEnum
argument_list|()
expr_stmt|;
block|}
name|termsEnum
operator|.
name|reset
argument_list|(
name|numTerms
argument_list|,
name|flags
argument_list|,
name|prefixLengths
argument_list|,
name|suffixLengths
argument_list|,
name|termFreqs
argument_list|,
name|positionIndex
argument_list|,
name|positions
argument_list|,
name|startOffsets
argument_list|,
name|lengths
argument_list|,
name|payloadIndex
argument_list|,
name|payloadBytes
argument_list|,
operator|new
name|ByteArrayDataInput
argument_list|(
name|termBytes
operator|.
name|bytes
argument_list|,
name|termBytes
operator|.
name|offset
argument_list|,
name|termBytes
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|termsEnum
return|;
block|}
annotation|@
name|Override
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|long
name|size
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|numTerms
return|;
block|}
annotation|@
name|Override
DECL|method|getSumTotalTermFreq
specifier|public
name|long
name|getSumTotalTermFreq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|-
literal|1L
return|;
block|}
annotation|@
name|Override
DECL|method|getSumDocFreq
specifier|public
name|long
name|getSumDocFreq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|numTerms
return|;
block|}
annotation|@
name|Override
DECL|method|getDocCount
specifier|public
name|int
name|getDocCount
parameter_list|()
throws|throws
name|IOException
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|hasOffsets
specifier|public
name|boolean
name|hasOffsets
parameter_list|()
block|{
return|return
operator|(
name|flags
operator|&
name|OFFSETS
operator|)
operator|!=
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|hasPositions
specifier|public
name|boolean
name|hasPositions
parameter_list|()
block|{
return|return
operator|(
name|flags
operator|&
name|POSITIONS
operator|)
operator|!=
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|hasPayloads
specifier|public
name|boolean
name|hasPayloads
parameter_list|()
block|{
return|return
operator|(
name|flags
operator|&
name|PAYLOADS
operator|)
operator|!=
literal|0
return|;
block|}
block|}
DECL|class|TVTermsEnum
specifier|private
specifier|static
class|class
name|TVTermsEnum
extends|extends
name|TermsEnum
block|{
DECL|field|numTerms
DECL|field|startPos
DECL|field|ord
specifier|private
name|int
name|numTerms
decl_stmt|,
name|startPos
decl_stmt|,
name|ord
decl_stmt|;
DECL|field|prefixLengths
DECL|field|suffixLengths
DECL|field|termFreqs
DECL|field|positionIndex
DECL|field|positions
DECL|field|startOffsets
DECL|field|lengths
DECL|field|payloadIndex
specifier|private
name|int
index|[]
name|prefixLengths
decl_stmt|,
name|suffixLengths
decl_stmt|,
name|termFreqs
decl_stmt|,
name|positionIndex
decl_stmt|,
name|positions
decl_stmt|,
name|startOffsets
decl_stmt|,
name|lengths
decl_stmt|,
name|payloadIndex
decl_stmt|;
DECL|field|in
specifier|private
name|ByteArrayDataInput
name|in
decl_stmt|;
DECL|field|payloads
specifier|private
name|BytesRef
name|payloads
decl_stmt|;
DECL|field|term
specifier|private
specifier|final
name|BytesRef
name|term
decl_stmt|;
DECL|method|TVTermsEnum
specifier|private
name|TVTermsEnum
parameter_list|()
block|{
name|term
operator|=
operator|new
name|BytesRef
argument_list|(
literal|16
argument_list|)
expr_stmt|;
block|}
DECL|method|reset
name|void
name|reset
parameter_list|(
name|int
name|numTerms
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
index|[]
name|prefixLengths
parameter_list|,
name|int
index|[]
name|suffixLengths
parameter_list|,
name|int
index|[]
name|termFreqs
parameter_list|,
name|int
index|[]
name|positionIndex
parameter_list|,
name|int
index|[]
name|positions
parameter_list|,
name|int
index|[]
name|startOffsets
parameter_list|,
name|int
index|[]
name|lengths
parameter_list|,
name|int
index|[]
name|payloadIndex
parameter_list|,
name|BytesRef
name|payloads
parameter_list|,
name|ByteArrayDataInput
name|in
parameter_list|)
block|{
name|this
operator|.
name|numTerms
operator|=
name|numTerms
expr_stmt|;
name|this
operator|.
name|prefixLengths
operator|=
name|prefixLengths
expr_stmt|;
name|this
operator|.
name|suffixLengths
operator|=
name|suffixLengths
expr_stmt|;
name|this
operator|.
name|termFreqs
operator|=
name|termFreqs
expr_stmt|;
name|this
operator|.
name|positionIndex
operator|=
name|positionIndex
expr_stmt|;
name|this
operator|.
name|positions
operator|=
name|positions
expr_stmt|;
name|this
operator|.
name|startOffsets
operator|=
name|startOffsets
expr_stmt|;
name|this
operator|.
name|lengths
operator|=
name|lengths
expr_stmt|;
name|this
operator|.
name|payloadIndex
operator|=
name|payloadIndex
expr_stmt|;
name|this
operator|.
name|payloads
operator|=
name|payloads
expr_stmt|;
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|startPos
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
DECL|method|reset
name|void
name|reset
parameter_list|()
block|{
name|term
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|in
operator|.
name|setPosition
argument_list|(
name|startPos
argument_list|)
expr_stmt|;
name|ord
operator|=
operator|-
literal|1
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|ord
operator|==
name|numTerms
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
assert|assert
name|ord
operator|<
name|numTerms
assert|;
operator|++
name|ord
expr_stmt|;
block|}
comment|// read term
name|term
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|term
operator|.
name|length
operator|=
name|prefixLengths
index|[
name|ord
index|]
operator|+
name|suffixLengths
index|[
name|ord
index|]
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|length
operator|>
name|term
operator|.
name|bytes
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|in
operator|.
name|readBytes
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|prefixLengths
index|[
name|ord
index|]
argument_list|,
name|suffixLengths
index|[
name|ord
index|]
argument_list|)
expr_stmt|;
return|return
name|term
return|;
block|}
annotation|@
name|Override
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
name|BytesRef
name|text
parameter_list|,
name|boolean
name|useCache
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ord
operator|<
name|numTerms
operator|&&
name|ord
operator|>=
literal|0
condition|)
block|{
specifier|final
name|int
name|cmp
init|=
name|term
argument_list|()
operator|.
name|compareTo
argument_list|(
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
comment|// linear scan
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|BytesRef
name|term
init|=
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|term
operator|==
literal|null
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
specifier|final
name|int
name|cmp
init|=
name|term
operator|.
name|compareTo
argument_list|(
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ord
operator|<
operator|-
literal|1
operator|||
name|ord
operator|>=
name|numTerms
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"ord is out of range: ord="
operator|+
name|ord
operator|+
literal|", numTerms="
operator|+
name|numTerms
argument_list|)
throw|;
block|}
if|if
condition|(
name|ord
operator|<
name|this
operator|.
name|ord
condition|)
block|{
name|reset
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|this
operator|.
name|ord
init|;
name|i
operator|<
name|ord
condition|;
operator|++
name|i
control|)
block|{
name|next
argument_list|()
expr_stmt|;
block|}
assert|assert
name|ord
operator|==
name|this
operator|.
name|ord
argument_list|()
assert|;
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|term
return|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|ord
return|;
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|termFreqs
index|[
name|ord
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
specifier|final
name|DocsEnum
name|docs
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|TVDocsEnum
name|docsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|!=
literal|null
operator|&&
name|reuse
operator|instanceof
name|TVDocsEnum
condition|)
block|{
name|docsEnum
operator|=
operator|(
name|TVDocsEnum
operator|)
name|reuse
expr_stmt|;
block|}
else|else
block|{
name|docsEnum
operator|=
operator|new
name|TVDocsEnum
argument_list|()
expr_stmt|;
block|}
name|docsEnum
operator|.
name|reset
argument_list|(
name|liveDocs
argument_list|,
name|termFreqs
index|[
name|ord
index|]
argument_list|,
name|positionIndex
index|[
name|ord
index|]
argument_list|,
name|positions
argument_list|,
name|startOffsets
argument_list|,
name|lengths
argument_list|,
name|payloads
argument_list|,
name|payloadIndex
argument_list|)
expr_stmt|;
return|return
name|docsEnum
return|;
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|positions
operator|==
literal|null
operator|&&
name|startOffsets
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// TODO: slightly sheisty
return|return
operator|(
name|DocsAndPositionsEnum
operator|)
name|docs
argument_list|(
name|liveDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
block|}
DECL|class|TVDocsEnum
specifier|private
specifier|static
class|class
name|TVDocsEnum
extends|extends
name|DocsAndPositionsEnum
block|{
DECL|field|liveDocs
specifier|private
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|doc
specifier|private
name|int
name|doc
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|termFreq
specifier|private
name|int
name|termFreq
decl_stmt|;
DECL|field|positionIndex
specifier|private
name|int
name|positionIndex
decl_stmt|;
DECL|field|positions
specifier|private
name|int
index|[]
name|positions
decl_stmt|;
DECL|field|startOffsets
specifier|private
name|int
index|[]
name|startOffsets
decl_stmt|;
DECL|field|lengths
specifier|private
name|int
index|[]
name|lengths
decl_stmt|;
DECL|field|payload
specifier|private
specifier|final
name|BytesRef
name|payload
decl_stmt|;
DECL|field|payloadIndex
specifier|private
name|int
index|[]
name|payloadIndex
decl_stmt|;
DECL|field|basePayloadOffset
specifier|private
name|int
name|basePayloadOffset
decl_stmt|;
DECL|field|i
specifier|private
name|int
name|i
decl_stmt|;
DECL|method|TVDocsEnum
name|TVDocsEnum
parameter_list|()
block|{
name|payload
operator|=
operator|new
name|BytesRef
argument_list|()
expr_stmt|;
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|int
name|freq
parameter_list|,
name|int
name|positionIndex
parameter_list|,
name|int
index|[]
name|positions
parameter_list|,
name|int
index|[]
name|startOffsets
parameter_list|,
name|int
index|[]
name|lengths
parameter_list|,
name|BytesRef
name|payloads
parameter_list|,
name|int
index|[]
name|payloadIndex
parameter_list|)
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
name|this
operator|.
name|termFreq
operator|=
name|freq
expr_stmt|;
name|this
operator|.
name|positionIndex
operator|=
name|positionIndex
expr_stmt|;
name|this
operator|.
name|positions
operator|=
name|positions
expr_stmt|;
name|this
operator|.
name|startOffsets
operator|=
name|startOffsets
expr_stmt|;
name|this
operator|.
name|lengths
operator|=
name|lengths
expr_stmt|;
name|this
operator|.
name|basePayloadOffset
operator|=
name|payloads
operator|.
name|offset
expr_stmt|;
name|this
operator|.
name|payload
operator|.
name|bytes
operator|=
name|payloads
operator|.
name|bytes
expr_stmt|;
name|payload
operator|.
name|offset
operator|=
name|payload
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|payloadIndex
operator|=
name|payloadIndex
expr_stmt|;
name|doc
operator|=
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
DECL|method|checkDoc
specifier|private
name|void
name|checkDoc
parameter_list|()
block|{
if|if
condition|(
name|doc
operator|==
name|NO_MORE_DOCS
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"DocsEnum exhausted"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|doc
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"DocsEnum not started"
argument_list|)
throw|;
block|}
block|}
DECL|method|checkPosition
specifier|private
name|void
name|checkPosition
parameter_list|()
block|{
name|checkDoc
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Position enum not started"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
name|termFreq
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Read past last position"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|nextPosition
specifier|public
name|int
name|nextPosition
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|doc
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
name|termFreq
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Read past last position"
argument_list|)
throw|;
block|}
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|payloadIndex
operator|!=
literal|null
condition|)
block|{
name|payload
operator|.
name|offset
operator|=
name|basePayloadOffset
operator|+
name|payloadIndex
index|[
name|positionIndex
operator|+
name|i
index|]
expr_stmt|;
name|payload
operator|.
name|length
operator|=
name|payloadIndex
index|[
name|positionIndex
operator|+
name|i
operator|+
literal|1
index|]
operator|-
name|payloadIndex
index|[
name|positionIndex
operator|+
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|positions
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|positions
index|[
name|positionIndex
operator|+
name|i
index|]
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|startOffset
specifier|public
name|int
name|startOffset
parameter_list|()
throws|throws
name|IOException
block|{
name|checkPosition
argument_list|()
expr_stmt|;
if|if
condition|(
name|startOffsets
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|startOffsets
index|[
name|positionIndex
operator|+
name|i
index|]
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|endOffset
specifier|public
name|int
name|endOffset
parameter_list|()
throws|throws
name|IOException
block|{
name|checkPosition
argument_list|()
expr_stmt|;
if|if
condition|(
name|startOffsets
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|startOffsets
index|[
name|positionIndex
operator|+
name|i
index|]
operator|+
name|lengths
index|[
name|positionIndex
operator|+
name|i
index|]
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getPayload
specifier|public
name|BytesRef
name|getPayload
parameter_list|()
throws|throws
name|IOException
block|{
name|checkPosition
argument_list|()
expr_stmt|;
if|if
condition|(
name|payloadIndex
operator|==
literal|null
operator|||
name|payload
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|payload
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
throws|throws
name|IOException
block|{
name|checkDoc
argument_list|()
expr_stmt|;
return|return
name|termFreq
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|doc
operator|==
operator|-
literal|1
operator|&&
operator|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|doc
operator|=
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|doc
operator|=
name|NO_MORE_DOCS
operator|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|doc
operator|==
operator|-
literal|1
operator|&&
name|target
operator|==
literal|0
operator|&&
operator|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|doc
operator|=
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|doc
operator|=
name|NO_MORE_DOCS
operator|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
block|}
DECL|method|sum
specifier|private
specifier|static
name|int
name|sum
parameter_list|(
name|int
index|[]
name|arr
parameter_list|)
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|el
range|:
name|arr
control|)
block|{
name|sum
operator|+=
name|el
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
block|}
end_class
end_unit
