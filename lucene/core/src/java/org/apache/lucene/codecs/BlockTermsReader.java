begin_unit
begin_package
DECL|package|org.apache.lucene.codecs
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFileNames
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|DoubleBarrelLRUCache
import|;
end_import
begin_comment
comment|/** Handles a terms dict, but decouples all details of  *  doc/freqs/positions reading to an instance of {@link  *  PostingsReaderBase}.  This class is reusable for  *  codecs that use a different format for  *  docs/freqs/positions (though codecs are also free to  *  make their own terms dict impl).  *  *<p>This class also interacts with an instance of {@link  * TermsIndexReaderBase}, to abstract away the specific  * implementation of the terms dict index.   * @lucene.experimental */
end_comment
begin_class
DECL|class|BlockTermsReader
specifier|public
class|class
name|BlockTermsReader
extends|extends
name|FieldsProducer
block|{
comment|// Open input to the main terms dict file (_X.tis)
DECL|field|in
specifier|private
specifier|final
name|IndexInput
name|in
decl_stmt|;
comment|// Reads the terms dict entries, to gather state to
comment|// produce DocsEnum on demand
DECL|field|postingsReader
specifier|private
specifier|final
name|PostingsReaderBase
name|postingsReader
decl_stmt|;
DECL|field|fields
specifier|private
specifier|final
name|TreeMap
argument_list|<
name|String
argument_list|,
name|FieldReader
argument_list|>
name|fields
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|FieldReader
argument_list|>
argument_list|()
decl_stmt|;
comment|// Caches the most recently looked-up field + terms:
DECL|field|termsCache
specifier|private
specifier|final
name|DoubleBarrelLRUCache
argument_list|<
name|FieldAndTerm
argument_list|,
name|BlockTermState
argument_list|>
name|termsCache
decl_stmt|;
comment|// Reads the terms index
DECL|field|indexReader
specifier|private
name|TermsIndexReaderBase
name|indexReader
decl_stmt|;
comment|// keeps the dirStart offset
DECL|field|dirOffset
specifier|protected
name|long
name|dirOffset
decl_stmt|;
comment|// Used as key for the terms cache
DECL|class|FieldAndTerm
specifier|private
specifier|static
class|class
name|FieldAndTerm
extends|extends
name|DoubleBarrelLRUCache
operator|.
name|CloneableKey
block|{
DECL|field|field
name|String
name|field
decl_stmt|;
DECL|field|term
name|BytesRef
name|term
decl_stmt|;
DECL|method|FieldAndTerm
specifier|public
name|FieldAndTerm
parameter_list|()
block|{     }
DECL|method|FieldAndTerm
specifier|public
name|FieldAndTerm
parameter_list|(
name|FieldAndTerm
name|other
parameter_list|)
block|{
name|field
operator|=
name|other
operator|.
name|field
expr_stmt|;
name|term
operator|=
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|other
operator|.
name|term
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|_other
parameter_list|)
block|{
name|FieldAndTerm
name|other
init|=
operator|(
name|FieldAndTerm
operator|)
name|_other
decl_stmt|;
return|return
name|other
operator|.
name|field
operator|.
name|equals
argument_list|(
name|field
argument_list|)
operator|&&
name|term
operator|.
name|bytesEquals
argument_list|(
name|other
operator|.
name|term
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|clone
specifier|public
name|FieldAndTerm
name|clone
parameter_list|()
block|{
return|return
operator|new
name|FieldAndTerm
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|field
operator|.
name|hashCode
argument_list|()
operator|*
literal|31
operator|+
name|term
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
comment|// private String segment;
DECL|method|BlockTermsReader
specifier|public
name|BlockTermsReader
parameter_list|(
name|TermsIndexReaderBase
name|indexReader
parameter_list|,
name|Directory
name|dir
parameter_list|,
name|FieldInfos
name|fieldInfos
parameter_list|,
name|String
name|segment
parameter_list|,
name|PostingsReaderBase
name|postingsReader
parameter_list|,
name|IOContext
name|context
parameter_list|,
name|int
name|termsCacheSize
parameter_list|,
name|String
name|segmentSuffix
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|postingsReader
operator|=
name|postingsReader
expr_stmt|;
name|termsCache
operator|=
operator|new
name|DoubleBarrelLRUCache
argument_list|<
name|FieldAndTerm
argument_list|,
name|BlockTermState
argument_list|>
argument_list|(
name|termsCacheSize
argument_list|)
expr_stmt|;
comment|// this.segment = segment;
name|in
operator|=
name|dir
operator|.
name|openInput
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segment
argument_list|,
name|segmentSuffix
argument_list|,
name|BlockTermsWriter
operator|.
name|TERMS_EXTENSION
argument_list|)
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|readHeader
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|// Have PostingsReader init itself
name|postingsReader
operator|.
name|init
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|// Read per-field details
name|seekDir
argument_list|(
name|in
argument_list|,
name|dirOffset
argument_list|)
expr_stmt|;
specifier|final
name|int
name|numFields
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFields
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|field
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
specifier|final
name|long
name|numTerms
init|=
name|in
operator|.
name|readVLong
argument_list|()
decl_stmt|;
assert|assert
name|numTerms
operator|>=
literal|0
assert|;
specifier|final
name|long
name|termsStartPointer
init|=
name|in
operator|.
name|readVLong
argument_list|()
decl_stmt|;
specifier|final
name|FieldInfo
name|fieldInfo
init|=
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|field
argument_list|)
decl_stmt|;
specifier|final
name|long
name|sumTotalTermFreq
init|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|==
name|IndexOptions
operator|.
name|DOCS_ONLY
condition|?
operator|-
literal|1
else|:
name|in
operator|.
name|readVLong
argument_list|()
decl_stmt|;
specifier|final
name|long
name|sumDocFreq
init|=
name|in
operator|.
name|readVLong
argument_list|()
decl_stmt|;
specifier|final
name|int
name|docCount
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
assert|assert
operator|!
name|fields
operator|.
name|containsKey
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|)
assert|;
name|fields
operator|.
name|put
argument_list|(
name|fieldInfo
operator|.
name|name
argument_list|,
operator|new
name|FieldReader
argument_list|(
name|fieldInfo
argument_list|,
name|numTerms
argument_list|,
name|termsStartPointer
argument_list|,
name|sumTotalTermFreq
argument_list|,
name|sumDocFreq
argument_list|,
name|docCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|this
operator|.
name|indexReader
operator|=
name|indexReader
expr_stmt|;
block|}
DECL|method|readHeader
specifier|protected
name|void
name|readHeader
parameter_list|(
name|IndexInput
name|input
parameter_list|)
throws|throws
name|IOException
block|{
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|input
argument_list|,
name|BlockTermsWriter
operator|.
name|CODEC_NAME
argument_list|,
name|BlockTermsWriter
operator|.
name|VERSION_START
argument_list|,
name|BlockTermsWriter
operator|.
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
name|dirOffset
operator|=
name|input
operator|.
name|readLong
argument_list|()
expr_stmt|;
block|}
DECL|method|seekDir
specifier|protected
name|void
name|seekDir
parameter_list|(
name|IndexInput
name|input
parameter_list|,
name|long
name|dirOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|input
operator|.
name|seek
argument_list|(
name|dirOffset
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
try|try
block|{
if|if
condition|(
name|indexReader
operator|!=
literal|null
condition|)
block|{
name|indexReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// null so if an app hangs on to us (ie, we are not
comment|// GCable, despite being closed) we still free most
comment|// ram
name|indexReader
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|postingsReader
operator|!=
literal|null
condition|)
block|{
name|postingsReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|fields
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|terms
specifier|public
name|Terms
name|terms
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|field
operator|!=
literal|null
assert|;
return|return
name|fields
operator|.
name|get
argument_list|(
name|field
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fields
operator|.
name|size
argument_list|()
return|;
block|}
DECL|class|FieldReader
specifier|private
class|class
name|FieldReader
extends|extends
name|Terms
block|{
DECL|field|numTerms
specifier|final
name|long
name|numTerms
decl_stmt|;
DECL|field|fieldInfo
specifier|final
name|FieldInfo
name|fieldInfo
decl_stmt|;
DECL|field|termsStartPointer
specifier|final
name|long
name|termsStartPointer
decl_stmt|;
DECL|field|sumTotalTermFreq
specifier|final
name|long
name|sumTotalTermFreq
decl_stmt|;
DECL|field|sumDocFreq
specifier|final
name|long
name|sumDocFreq
decl_stmt|;
DECL|field|docCount
specifier|final
name|int
name|docCount
decl_stmt|;
DECL|method|FieldReader
name|FieldReader
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|long
name|numTerms
parameter_list|,
name|long
name|termsStartPointer
parameter_list|,
name|long
name|sumTotalTermFreq
parameter_list|,
name|long
name|sumDocFreq
parameter_list|,
name|int
name|docCount
parameter_list|)
block|{
assert|assert
name|numTerms
operator|>
literal|0
assert|;
name|this
operator|.
name|fieldInfo
operator|=
name|fieldInfo
expr_stmt|;
name|this
operator|.
name|numTerms
operator|=
name|numTerms
expr_stmt|;
name|this
operator|.
name|termsStartPointer
operator|=
name|termsStartPointer
expr_stmt|;
name|this
operator|.
name|sumTotalTermFreq
operator|=
name|sumTotalTermFreq
expr_stmt|;
name|this
operator|.
name|sumDocFreq
operator|=
name|sumDocFreq
expr_stmt|;
name|this
operator|.
name|docCount
operator|=
name|docCount
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|TermsEnum
name|iterator
parameter_list|(
name|TermsEnum
name|reuse
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|SegmentTermsEnum
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hasOffsets
specifier|public
name|boolean
name|hasOffsets
parameter_list|()
block|{
return|return
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|hasPositions
specifier|public
name|boolean
name|hasPositions
parameter_list|()
block|{
return|return
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|>=
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|hasPayloads
specifier|public
name|boolean
name|hasPayloads
parameter_list|()
block|{
return|return
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|long
name|size
parameter_list|()
block|{
return|return
name|numTerms
return|;
block|}
annotation|@
name|Override
DECL|method|getSumTotalTermFreq
specifier|public
name|long
name|getSumTotalTermFreq
parameter_list|()
block|{
return|return
name|sumTotalTermFreq
return|;
block|}
annotation|@
name|Override
DECL|method|getSumDocFreq
specifier|public
name|long
name|getSumDocFreq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|sumDocFreq
return|;
block|}
annotation|@
name|Override
DECL|method|getDocCount
specifier|public
name|int
name|getDocCount
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|docCount
return|;
block|}
comment|// Iterates through terms in this field
DECL|class|SegmentTermsEnum
specifier|private
specifier|final
class|class
name|SegmentTermsEnum
extends|extends
name|TermsEnum
block|{
DECL|field|in
specifier|private
specifier|final
name|IndexInput
name|in
decl_stmt|;
DECL|field|state
specifier|private
specifier|final
name|BlockTermState
name|state
decl_stmt|;
DECL|field|doOrd
specifier|private
specifier|final
name|boolean
name|doOrd
decl_stmt|;
DECL|field|fieldTerm
specifier|private
specifier|final
name|FieldAndTerm
name|fieldTerm
init|=
operator|new
name|FieldAndTerm
argument_list|()
decl_stmt|;
DECL|field|indexEnum
specifier|private
specifier|final
name|TermsIndexReaderBase
operator|.
name|FieldIndexEnum
name|indexEnum
decl_stmt|;
DECL|field|term
specifier|private
specifier|final
name|BytesRef
name|term
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
comment|/* This is true if indexEnum is "still" seek'd to the index term          for the current term. We set it to true on seeking, and then it          remains valid until next() is called enough times to load another          terms block: */
DECL|field|indexIsCurrent
specifier|private
name|boolean
name|indexIsCurrent
decl_stmt|;
comment|/* True if we've already called .next() on the indexEnum, to "bracket"          the current block of terms: */
DECL|field|didIndexNext
specifier|private
name|boolean
name|didIndexNext
decl_stmt|;
comment|/* Next index term, bracketing the current block of terms; this is          only valid if didIndexNext is true: */
DECL|field|nextIndexTerm
specifier|private
name|BytesRef
name|nextIndexTerm
decl_stmt|;
comment|/* True after seekExact(TermState), do defer seeking.  If the app then          calls next() (which is not "typical"), then we'll do the real seek */
DECL|field|seekPending
specifier|private
name|boolean
name|seekPending
decl_stmt|;
comment|/* How many blocks we've read since last seek.  Once this          is>= indexEnum.getDivisor() we set indexIsCurrent to false (since          the index can no long bracket seek-within-block). */
DECL|field|blocksSinceSeek
specifier|private
name|int
name|blocksSinceSeek
decl_stmt|;
DECL|field|termSuffixes
specifier|private
name|byte
index|[]
name|termSuffixes
decl_stmt|;
DECL|field|termSuffixesReader
specifier|private
name|ByteArrayDataInput
name|termSuffixesReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
comment|/* Common prefix used for all terms in this block. */
DECL|field|termBlockPrefix
specifier|private
name|int
name|termBlockPrefix
decl_stmt|;
comment|/* How many terms in current block */
DECL|field|blockTermCount
specifier|private
name|int
name|blockTermCount
decl_stmt|;
DECL|field|docFreqBytes
specifier|private
name|byte
index|[]
name|docFreqBytes
decl_stmt|;
DECL|field|freqReader
specifier|private
specifier|final
name|ByteArrayDataInput
name|freqReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
DECL|field|metaDataUpto
specifier|private
name|int
name|metaDataUpto
decl_stmt|;
DECL|method|SegmentTermsEnum
specifier|public
name|SegmentTermsEnum
parameter_list|()
throws|throws
name|IOException
block|{
name|in
operator|=
name|BlockTermsReader
operator|.
name|this
operator|.
name|in
operator|.
name|clone
argument_list|()
expr_stmt|;
name|in
operator|.
name|seek
argument_list|(
name|termsStartPointer
argument_list|)
expr_stmt|;
name|indexEnum
operator|=
name|indexReader
operator|.
name|getFieldEnum
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
name|doOrd
operator|=
name|indexReader
operator|.
name|supportsOrd
argument_list|()
expr_stmt|;
name|fieldTerm
operator|.
name|field
operator|=
name|fieldInfo
operator|.
name|name
expr_stmt|;
name|state
operator|=
name|postingsReader
operator|.
name|newTermState
argument_list|()
expr_stmt|;
name|state
operator|.
name|totalTermFreq
operator|=
operator|-
literal|1
expr_stmt|;
name|state
operator|.
name|ord
operator|=
operator|-
literal|1
expr_stmt|;
name|termSuffixes
operator|=
operator|new
name|byte
index|[
literal|128
index|]
expr_stmt|;
name|docFreqBytes
operator|=
operator|new
name|byte
index|[
literal|64
index|]
expr_stmt|;
comment|//System.out.println("BTR.enum init this=" + this + " postingsReader=" + postingsReader);
block|}
annotation|@
name|Override
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
comment|// TODO: we may want an alternate mode here which is
comment|// "if you are about to return NOT_FOUND I won't use
comment|// the terms data from that"; eg FuzzyTermsEnum will
comment|// (usually) just immediately call seek again if we
comment|// return NOT_FOUND so it's a waste for us to fill in
comment|// the term that was actually NOT_FOUND
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
specifier|final
name|BytesRef
name|target
parameter_list|,
specifier|final
name|boolean
name|useCache
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|indexEnum
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"terms index was not loaded"
argument_list|)
throw|;
block|}
comment|//System.out.println("BTR.seek seg=" + segment + " target=" + fieldInfo.name + ":" + target.utf8ToString() + " " + target + " current=" + term().utf8ToString() + " " + term() + " useCache=" + useCache + " indexIsCurrent=" + indexIsCurrent + " didIndexNext=" + didIndexNext + " seekPending=" + seekPending + " divisor=" + indexReader.getDivisor() + " this="  + this);
if|if
condition|(
name|didIndexNext
condition|)
block|{
if|if
condition|(
name|nextIndexTerm
operator|==
literal|null
condition|)
block|{
comment|//System.out.println("  nextIndexTerm=null");
block|}
else|else
block|{
comment|//System.out.println("  nextIndexTerm=" + nextIndexTerm.utf8ToString());
block|}
block|}
comment|// Check cache
if|if
condition|(
name|useCache
condition|)
block|{
name|fieldTerm
operator|.
name|term
operator|=
name|target
expr_stmt|;
comment|// TODO: should we differentiate "frozen"
comment|// TermState (ie one that was cloned and
comment|// cached/returned by termState()) from the
comment|// malleable (primary) one?
specifier|final
name|TermState
name|cachedState
init|=
name|termsCache
operator|.
name|get
argument_list|(
name|fieldTerm
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedState
operator|!=
literal|null
condition|)
block|{
name|seekPending
operator|=
literal|true
expr_stmt|;
comment|//System.out.println("  cached!");
name|seekExact
argument_list|(
name|target
argument_list|,
name|cachedState
argument_list|)
expr_stmt|;
comment|//System.out.println("  term=" + term.utf8ToString());
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
block|}
name|boolean
name|doSeek
init|=
literal|true
decl_stmt|;
comment|// See if we can avoid seeking, because target term
comment|// is after current term but before next index term:
if|if
condition|(
name|indexIsCurrent
condition|)
block|{
specifier|final
name|int
name|cmp
init|=
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
operator|.
name|compare
argument_list|(
name|term
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
comment|// Already at the requested term
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// Target term is after current term
if|if
condition|(
operator|!
name|didIndexNext
condition|)
block|{
if|if
condition|(
name|indexEnum
operator|.
name|next
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|nextIndexTerm
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|nextIndexTerm
operator|=
name|indexEnum
operator|.
name|term
argument_list|()
expr_stmt|;
block|}
comment|//System.out.println("  now do index next() nextIndexTerm=" + (nextIndexTerm == null ? "null" : nextIndexTerm.utf8ToString()));
name|didIndexNext
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|nextIndexTerm
operator|==
literal|null
operator|||
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
operator|.
name|compare
argument_list|(
name|target
argument_list|,
name|nextIndexTerm
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Optimization: requested term is within the
comment|// same term block we are now in; skip seeking
comment|// (but do scanning):
name|doSeek
operator|=
literal|false
expr_stmt|;
comment|//System.out.println("  skip seek: nextIndexTerm=" + (nextIndexTerm == null ? "null" : nextIndexTerm.utf8ToString()));
block|}
block|}
block|}
if|if
condition|(
name|doSeek
condition|)
block|{
comment|//System.out.println("  seek");
comment|// Ask terms index to find biggest indexed term (=
comment|// first term in a block) that's<= our text:
name|in
operator|.
name|seek
argument_list|(
name|indexEnum
operator|.
name|seek
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|result
init|=
name|nextBlock
argument_list|()
decl_stmt|;
comment|// Block must exist since, at least, the indexed term
comment|// is in the block:
assert|assert
name|result
assert|;
name|indexIsCurrent
operator|=
literal|true
expr_stmt|;
name|didIndexNext
operator|=
literal|false
expr_stmt|;
name|blocksSinceSeek
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|doOrd
condition|)
block|{
name|state
operator|.
name|ord
operator|=
name|indexEnum
operator|.
name|ord
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
name|term
operator|.
name|copyBytes
argument_list|(
name|indexEnum
operator|.
name|term
argument_list|()
argument_list|)
expr_stmt|;
comment|//System.out.println("  seek: term=" + term.utf8ToString());
block|}
else|else
block|{
comment|//System.out.println("  skip seek");
if|if
condition|(
name|state
operator|.
name|termBlockOrd
operator|==
name|blockTermCount
operator|&&
operator|!
name|nextBlock
argument_list|()
condition|)
block|{
name|indexIsCurrent
operator|=
literal|false
expr_stmt|;
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
block|}
name|seekPending
operator|=
literal|false
expr_stmt|;
name|int
name|common
init|=
literal|0
decl_stmt|;
comment|// Scan within block.  We could do this by calling
comment|// _next() and testing the resulting term, but this
comment|// is wasteful.  Instead, we first confirm the
comment|// target matches the common prefix of this block,
comment|// and then we scan the term bytes directly from the
comment|// termSuffixesreader's byte[], saving a copy into
comment|// the BytesRef term per term.  Only when we return
comment|// do we then copy the bytes into the term.
while|while
condition|(
literal|true
condition|)
block|{
comment|// First, see if target term matches common prefix
comment|// in this block:
if|if
condition|(
name|common
operator|<
name|termBlockPrefix
condition|)
block|{
specifier|final
name|int
name|cmp
init|=
operator|(
name|term
operator|.
name|bytes
index|[
name|common
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|common
index|]
operator|&
literal|0xFF
operator|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// TODO: maybe we should store common prefix
comment|// in block header?  (instead of relying on
comment|// last term of previous block)
comment|// Target's prefix is after the common block
comment|// prefix, so term cannot be in this block
comment|// but it could be in next block.  We
comment|// must scan to end-of-block to set common
comment|// prefix for next block:
if|if
condition|(
name|state
operator|.
name|termBlockOrd
operator|<
name|blockTermCount
condition|)
block|{
while|while
condition|(
name|state
operator|.
name|termBlockOrd
operator|<
name|blockTermCount
operator|-
literal|1
condition|)
block|{
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
name|state
operator|.
name|ord
operator|++
expr_stmt|;
name|termSuffixesReader
operator|.
name|skipBytes
argument_list|(
name|termSuffixesReader
operator|.
name|readVInt
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|suffix
init|=
name|termSuffixesReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|termBlockPrefix
operator|+
name|suffix
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|term
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|grow
argument_list|(
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|termSuffixesReader
operator|.
name|readBytes
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|termBlockPrefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
name|state
operator|.
name|ord
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|nextBlock
argument_list|()
condition|)
block|{
name|indexIsCurrent
operator|=
literal|false
expr_stmt|;
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
name|common
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// Target's prefix is before the common prefix
comment|// of this block, so we position to start of
comment|// block and return NOT_FOUND:
assert|assert
name|state
operator|.
name|termBlockOrd
operator|==
literal|0
assert|;
specifier|final
name|int
name|suffix
init|=
name|termSuffixesReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|termBlockPrefix
operator|+
name|suffix
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|term
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|grow
argument_list|(
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|termSuffixesReader
operator|.
name|readBytes
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|termBlockPrefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
else|else
block|{
name|common
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
comment|// Test every term in this block
while|while
condition|(
literal|true
condition|)
block|{
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
name|state
operator|.
name|ord
operator|++
expr_stmt|;
specifier|final
name|int
name|suffix
init|=
name|termSuffixesReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
comment|// We know the prefix matches, so just compare the new suffix:
specifier|final
name|int
name|termLen
init|=
name|termBlockPrefix
operator|+
name|suffix
decl_stmt|;
name|int
name|bytePos
init|=
name|termSuffixesReader
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|boolean
name|next
init|=
literal|false
decl_stmt|;
specifier|final
name|int
name|limit
init|=
name|target
operator|.
name|offset
operator|+
operator|(
name|termLen
operator|<
name|target
operator|.
name|length
condition|?
name|termLen
else|:
name|target
operator|.
name|length
operator|)
decl_stmt|;
name|int
name|targetPos
init|=
name|target
operator|.
name|offset
operator|+
name|termBlockPrefix
decl_stmt|;
while|while
condition|(
name|targetPos
operator|<
name|limit
condition|)
block|{
specifier|final
name|int
name|cmp
init|=
operator|(
name|termSuffixes
index|[
name|bytePos
operator|++
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|targetPos
operator|++
index|]
operator|&
literal|0xFF
operator|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// Current term is still before the target;
comment|// keep scanning
name|next
operator|=
literal|true
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// Done!  Current term is after target. Stop
comment|// here, fill in real term, return NOT_FOUND.
name|term
operator|.
name|length
operator|=
name|termBlockPrefix
operator|+
name|suffix
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|term
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|grow
argument_list|(
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|termSuffixesReader
operator|.
name|readBytes
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|termBlockPrefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
comment|//System.out.println("  NOT_FOUND");
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
block|}
if|if
condition|(
operator|!
name|next
operator|&&
name|target
operator|.
name|length
operator|<=
name|termLen
condition|)
block|{
name|term
operator|.
name|length
operator|=
name|termBlockPrefix
operator|+
name|suffix
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|term
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|grow
argument_list|(
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|termSuffixesReader
operator|.
name|readBytes
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|termBlockPrefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|.
name|length
operator|==
name|termLen
condition|)
block|{
comment|// Done!  Exact match.  Stop here, fill in
comment|// real term, return FOUND.
comment|//System.out.println("  FOUND");
if|if
condition|(
name|useCache
condition|)
block|{
comment|// Store in cache
name|decodeMetaData
argument_list|()
expr_stmt|;
comment|//System.out.println("  cache! state=" + state);
name|termsCache
operator|.
name|put
argument_list|(
operator|new
name|FieldAndTerm
argument_list|(
name|fieldTerm
argument_list|)
argument_list|,
operator|(
name|BlockTermState
operator|)
name|state
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
else|else
block|{
comment|//System.out.println("  NOT_FOUND");
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
block|}
if|if
condition|(
name|state
operator|.
name|termBlockOrd
operator|==
name|blockTermCount
condition|)
block|{
comment|// Must pre-fill term for next block's common prefix
name|term
operator|.
name|length
operator|=
name|termBlockPrefix
operator|+
name|suffix
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|term
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|grow
argument_list|(
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|termSuffixesReader
operator|.
name|readBytes
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|termBlockPrefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|termSuffixesReader
operator|.
name|skipBytes
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
block|}
block|}
comment|// The purpose of the terms dict index is to seek
comment|// the enum to the closest index term before the
comment|// term we are looking for.  So, we should never
comment|// cross another index term (besides the first
comment|// one) while we are scanning:
assert|assert
name|indexIsCurrent
assert|;
if|if
condition|(
operator|!
name|nextBlock
argument_list|()
condition|)
block|{
comment|//System.out.println("  END");
name|indexIsCurrent
operator|=
literal|false
expr_stmt|;
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
name|common
operator|=
literal|0
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.out.println("BTR.next() seekPending=" + seekPending + " pendingSeekCount=" + state.termBlockOrd);
comment|// If seek was previously called and the term was cached,
comment|// usually caller is just going to pull a D/&PEnum or get
comment|// docFreq, etc.  But, if they then call next(),
comment|// this method catches up all internal state so next()
comment|// works properly:
if|if
condition|(
name|seekPending
condition|)
block|{
assert|assert
operator|!
name|indexIsCurrent
assert|;
name|in
operator|.
name|seek
argument_list|(
name|state
operator|.
name|blockFilePointer
argument_list|)
expr_stmt|;
specifier|final
name|int
name|pendingSeekCount
init|=
name|state
operator|.
name|termBlockOrd
decl_stmt|;
name|boolean
name|result
init|=
name|nextBlock
argument_list|()
decl_stmt|;
specifier|final
name|long
name|savOrd
init|=
name|state
operator|.
name|ord
decl_stmt|;
comment|// Block must exist since seek(TermState) was called w/ a
comment|// TermState previously returned by this enum when positioned
comment|// on a real term:
assert|assert
name|result
assert|;
while|while
condition|(
name|state
operator|.
name|termBlockOrd
operator|<
name|pendingSeekCount
condition|)
block|{
name|BytesRef
name|nextResult
init|=
name|_next
argument_list|()
decl_stmt|;
assert|assert
name|nextResult
operator|!=
literal|null
assert|;
block|}
name|seekPending
operator|=
literal|false
expr_stmt|;
name|state
operator|.
name|ord
operator|=
name|savOrd
expr_stmt|;
block|}
return|return
name|_next
argument_list|()
return|;
block|}
comment|/* Decodes only the term bytes of the next term.  If caller then asks for          metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)          decode all metadata up to the current term. */
DECL|method|_next
specifier|private
name|BytesRef
name|_next
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.out.println("BTR._next seg=" + segment + " this=" + this + " termCount=" + state.termBlockOrd + " (vs " + blockTermCount + ")");
if|if
condition|(
name|state
operator|.
name|termBlockOrd
operator|==
name|blockTermCount
operator|&&
operator|!
name|nextBlock
argument_list|()
condition|)
block|{
comment|//System.out.println("  eof");
name|indexIsCurrent
operator|=
literal|false
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// TODO: cutover to something better for these ints!  simple64?
specifier|final
name|int
name|suffix
init|=
name|termSuffixesReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
comment|//System.out.println("  suffix=" + suffix);
name|term
operator|.
name|length
operator|=
name|termBlockPrefix
operator|+
name|suffix
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|term
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|grow
argument_list|(
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|termSuffixesReader
operator|.
name|readBytes
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|termBlockPrefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
comment|// NOTE: meaningless in the non-ord case
name|state
operator|.
name|ord
operator|++
expr_stmt|;
comment|//System.out.println("  return term=" + fieldInfo.name + ":" + term.utf8ToString() + " " + term + " tbOrd=" + state.termBlockOrd);
return|return
name|term
return|;
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
block|{
return|return
name|term
return|;
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.out.println("BTR.docFreq");
name|decodeMetaData
argument_list|()
expr_stmt|;
comment|//System.out.println("  return " + state.docFreq);
return|return
name|state
operator|.
name|docFreq
return|;
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
throws|throws
name|IOException
block|{
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|state
operator|.
name|totalTermFreq
return|;
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("BTR.docs this=" + this);
name|decodeMetaData
argument_list|()
expr_stmt|;
comment|//System.out.println("BTR.docs:  state.docFreq=" + state.docFreq);
return|return
name|postingsReader
operator|.
name|docs
argument_list|(
name|fieldInfo
argument_list|,
name|state
argument_list|,
name|liveDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Positions were not indexed:
return|return
literal|null
return|;
block|}
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|postingsReader
operator|.
name|docsAndPositions
argument_list|(
name|fieldInfo
argument_list|,
name|state
argument_list|,
name|liveDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|BytesRef
name|target
parameter_list|,
name|TermState
name|otherState
parameter_list|)
block|{
comment|//System.out.println("BTR.seekExact termState target=" + target.utf8ToString() + " " + target + " this=" + this);
assert|assert
name|otherState
operator|!=
literal|null
operator|&&
name|otherState
operator|instanceof
name|BlockTermState
assert|;
assert|assert
operator|!
name|doOrd
operator|||
operator|(
operator|(
name|BlockTermState
operator|)
name|otherState
operator|)
operator|.
name|ord
operator|<
name|numTerms
assert|;
name|state
operator|.
name|copyFrom
argument_list|(
name|otherState
argument_list|)
expr_stmt|;
name|seekPending
operator|=
literal|true
expr_stmt|;
name|indexIsCurrent
operator|=
literal|false
expr_stmt|;
name|term
operator|.
name|copyBytes
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|termState
specifier|public
name|TermState
name|termState
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.out.println("BTR.termState this=" + this);
name|decodeMetaData
argument_list|()
expr_stmt|;
name|TermState
name|ts
init|=
name|state
operator|.
name|clone
argument_list|()
decl_stmt|;
comment|//System.out.println("  return ts=" + ts);
return|return
name|ts
return|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
comment|//System.out.println("BTR.seek by ord ord=" + ord);
if|if
condition|(
name|indexEnum
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"terms index was not loaded"
argument_list|)
throw|;
block|}
assert|assert
name|ord
operator|<
name|numTerms
assert|;
comment|// TODO: if ord is in same terms block and
comment|// after current ord, we should avoid this seek just
comment|// like we do in the seek(BytesRef) case
name|in
operator|.
name|seek
argument_list|(
name|indexEnum
operator|.
name|seek
argument_list|(
name|ord
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|result
init|=
name|nextBlock
argument_list|()
decl_stmt|;
comment|// Block must exist since ord< numTerms:
assert|assert
name|result
assert|;
name|indexIsCurrent
operator|=
literal|true
expr_stmt|;
name|didIndexNext
operator|=
literal|false
expr_stmt|;
name|blocksSinceSeek
operator|=
literal|0
expr_stmt|;
name|seekPending
operator|=
literal|false
expr_stmt|;
name|state
operator|.
name|ord
operator|=
name|indexEnum
operator|.
name|ord
argument_list|()
operator|-
literal|1
expr_stmt|;
assert|assert
name|state
operator|.
name|ord
operator|>=
operator|-
literal|1
operator|:
literal|"ord="
operator|+
name|state
operator|.
name|ord
assert|;
name|term
operator|.
name|copyBytes
argument_list|(
name|indexEnum
operator|.
name|term
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now, scan:
name|int
name|left
init|=
call|(
name|int
call|)
argument_list|(
name|ord
operator|-
name|state
operator|.
name|ord
argument_list|)
decl_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
specifier|final
name|BytesRef
name|term
init|=
name|_next
argument_list|()
decl_stmt|;
assert|assert
name|term
operator|!=
literal|null
assert|;
name|left
operator|--
expr_stmt|;
assert|assert
name|indexIsCurrent
assert|;
block|}
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
block|{
if|if
condition|(
operator|!
name|doOrd
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
return|return
name|state
operator|.
name|ord
return|;
block|}
comment|/* Does initial decode of next block of terms; this          doesn't actually decode the docFreq, totalTermFreq,          postings details (frq/prx offset, etc.) metadata;          it just loads them as byte[] blobs which are then                decoded on-demand if the metadata is ever requested          for any term in this block.  This enables terms-only          intensive consumes (eg certain MTQs, respelling) to          not pay the price of decoding metadata they won't          use. */
DECL|method|nextBlock
specifier|private
name|boolean
name|nextBlock
parameter_list|()
throws|throws
name|IOException
block|{
comment|// TODO: we still lazy-decode the byte[] for each
comment|// term (the suffix), but, if we decoded
comment|// all N terms up front then seeking could do a fast
comment|// bsearch w/in the block...
comment|//System.out.println("BTR.nextBlock() fp=" + in.getFilePointer() + " this=" + this);
name|state
operator|.
name|blockFilePointer
operator|=
name|in
operator|.
name|getFilePointer
argument_list|()
expr_stmt|;
name|blockTermCount
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|//System.out.println("  blockTermCount=" + blockTermCount);
if|if
condition|(
name|blockTermCount
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|termBlockPrefix
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|// term suffixes:
name|int
name|len
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|termSuffixes
operator|.
name|length
operator|<
name|len
condition|)
block|{
name|termSuffixes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
comment|//System.out.println("  termSuffixes len=" + len);
name|in
operator|.
name|readBytes
argument_list|(
name|termSuffixes
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|termSuffixesReader
operator|.
name|reset
argument_list|(
name|termSuffixes
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|// docFreq, totalTermFreq
name|len
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|docFreqBytes
operator|.
name|length
operator|<
name|len
condition|)
block|{
name|docFreqBytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
comment|//System.out.println("  freq bytes len=" + len);
name|in
operator|.
name|readBytes
argument_list|(
name|docFreqBytes
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|freqReader
operator|.
name|reset
argument_list|(
name|docFreqBytes
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|metaDataUpto
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termBlockOrd
operator|=
literal|0
expr_stmt|;
name|postingsReader
operator|.
name|readTermsBlock
argument_list|(
name|in
argument_list|,
name|fieldInfo
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|blocksSinceSeek
operator|++
expr_stmt|;
name|indexIsCurrent
operator|=
name|indexIsCurrent
operator|&&
operator|(
name|blocksSinceSeek
operator|<
name|indexReader
operator|.
name|getDivisor
argument_list|()
operator|)
expr_stmt|;
comment|//System.out.println("  indexIsCurrent=" + indexIsCurrent);
return|return
literal|true
return|;
block|}
DECL|method|decodeMetaData
specifier|private
name|void
name|decodeMetaData
parameter_list|()
throws|throws
name|IOException
block|{
comment|//System.out.println("BTR.decodeMetadata mdUpto=" + metaDataUpto + " vs termCount=" + state.termBlockOrd + " state=" + state);
if|if
condition|(
operator|!
name|seekPending
condition|)
block|{
comment|// TODO: cutover to random-access API
comment|// here.... really stupid that we have to decode N
comment|// wasted term metadata just to get to the N+1th
comment|// that we really need...
comment|// lazily catch up on metadata decode:
specifier|final
name|int
name|limit
init|=
name|state
operator|.
name|termBlockOrd
decl_stmt|;
comment|// We must set/incr state.termCount because
comment|// postings impl can look at this
name|state
operator|.
name|termBlockOrd
operator|=
name|metaDataUpto
expr_stmt|;
comment|// TODO: better API would be "jump straight to term=N"???
while|while
condition|(
name|metaDataUpto
operator|<
name|limit
condition|)
block|{
comment|//System.out.println("  decode mdUpto=" + metaDataUpto);
comment|// TODO: we could make "tiers" of metadata, ie,
comment|// decode docFreq/totalTF but don't decode postings
comment|// metadata; this way caller could get
comment|// docFreq/totalTF w/o paying decode cost for
comment|// postings
comment|// TODO: if docFreq were bulk decoded we could
comment|// just skipN here:
name|state
operator|.
name|docFreq
operator|=
name|freqReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|//System.out.println("    dF=" + state.docFreq);
if|if
condition|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|!=
name|IndexOptions
operator|.
name|DOCS_ONLY
condition|)
block|{
name|state
operator|.
name|totalTermFreq
operator|=
name|state
operator|.
name|docFreq
operator|+
name|freqReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
comment|//System.out.println("    totTF=" + state.totalTermFreq);
block|}
name|postingsReader
operator|.
name|nextTerm
argument_list|(
name|fieldInfo
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|metaDataUpto
operator|++
expr_stmt|;
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//System.out.println("  skip! seekPending");
block|}
block|}
block|}
block|}
block|}
end_class
end_unit
