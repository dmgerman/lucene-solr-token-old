begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.blocktree
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|blocktree
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|BlockTermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|CompiledAutomaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|RunAutomaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|Transition
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FST
import|;
end_import
begin_comment
comment|// NOTE: cannot seek!
end_comment
begin_class
DECL|class|IntersectTermsEnum
specifier|final
class|class
name|IntersectTermsEnum
extends|extends
name|TermsEnum
block|{
DECL|field|in
specifier|private
specifier|final
name|IndexInput
name|in
decl_stmt|;
DECL|field|stack
specifier|private
name|Frame
index|[]
name|stack
decl_stmt|;
DECL|field|arcs
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|private
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
index|[]
name|arcs
init|=
operator|new
name|FST
operator|.
name|Arc
index|[
literal|5
index|]
decl_stmt|;
DECL|field|runAutomaton
specifier|private
specifier|final
name|RunAutomaton
name|runAutomaton
decl_stmt|;
DECL|field|compiledAutomaton
specifier|private
specifier|final
name|CompiledAutomaton
name|compiledAutomaton
decl_stmt|;
DECL|field|currentFrame
specifier|private
name|Frame
name|currentFrame
decl_stmt|;
DECL|field|term
specifier|private
specifier|final
name|BytesRef
name|term
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
DECL|field|fstReader
specifier|private
specifier|final
name|FST
operator|.
name|BytesReader
name|fstReader
decl_stmt|;
DECL|field|fr
specifier|private
specifier|final
name|FieldReader
name|fr
decl_stmt|;
comment|// TODO: can we share this with the frame in STE?
DECL|class|Frame
specifier|private
specifier|final
class|class
name|Frame
block|{
DECL|field|ord
specifier|final
name|int
name|ord
decl_stmt|;
DECL|field|fp
name|long
name|fp
decl_stmt|;
DECL|field|fpOrig
name|long
name|fpOrig
decl_stmt|;
DECL|field|fpEnd
name|long
name|fpEnd
decl_stmt|;
DECL|field|lastSubFP
name|long
name|lastSubFP
decl_stmt|;
comment|// State in automaton
DECL|field|state
name|int
name|state
decl_stmt|;
DECL|field|metaDataUpto
name|int
name|metaDataUpto
decl_stmt|;
DECL|field|suffixBytes
name|byte
index|[]
name|suffixBytes
init|=
operator|new
name|byte
index|[
literal|128
index|]
decl_stmt|;
DECL|field|suffixesReader
specifier|final
name|ByteArrayDataInput
name|suffixesReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
DECL|field|statBytes
name|byte
index|[]
name|statBytes
init|=
operator|new
name|byte
index|[
literal|64
index|]
decl_stmt|;
DECL|field|statsReader
specifier|final
name|ByteArrayDataInput
name|statsReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
DECL|field|floorData
name|byte
index|[]
name|floorData
init|=
operator|new
name|byte
index|[
literal|32
index|]
decl_stmt|;
DECL|field|floorDataReader
specifier|final
name|ByteArrayDataInput
name|floorDataReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
comment|// Length of prefix shared by all terms in this block
DECL|field|prefix
name|int
name|prefix
decl_stmt|;
comment|// Number of entries (term or sub-block) in this block
DECL|field|entCount
name|int
name|entCount
decl_stmt|;
comment|// Which term we will next read
DECL|field|nextEnt
name|int
name|nextEnt
decl_stmt|;
comment|// True if this block is either not a floor block,
comment|// or, it's the last sub-block of a floor block
DECL|field|isLastInFloor
name|boolean
name|isLastInFloor
decl_stmt|;
comment|// True if all entries are terms
DECL|field|isLeafBlock
name|boolean
name|isLeafBlock
decl_stmt|;
DECL|field|numFollowFloorBlocks
name|int
name|numFollowFloorBlocks
decl_stmt|;
DECL|field|nextFloorLabel
name|int
name|nextFloorLabel
decl_stmt|;
DECL|field|transitions
name|Transition
index|[]
name|transitions
decl_stmt|;
DECL|field|curTransitionMax
name|int
name|curTransitionMax
decl_stmt|;
DECL|field|transitionIndex
name|int
name|transitionIndex
decl_stmt|;
DECL|field|arc
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
DECL|field|termState
specifier|final
name|BlockTermState
name|termState
decl_stmt|;
comment|// metadata buffer, holding monotonic values
DECL|field|longs
specifier|public
name|long
index|[]
name|longs
decl_stmt|;
comment|// metadata buffer, holding general values
DECL|field|bytes
specifier|public
name|byte
index|[]
name|bytes
decl_stmt|;
DECL|field|bytesReader
name|ByteArrayDataInput
name|bytesReader
decl_stmt|;
comment|// Cumulative output so far
DECL|field|outputPrefix
name|BytesRef
name|outputPrefix
decl_stmt|;
DECL|field|startBytePos
specifier|private
name|int
name|startBytePos
decl_stmt|;
DECL|field|suffix
specifier|private
name|int
name|suffix
decl_stmt|;
DECL|method|Frame
specifier|public
name|Frame
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|ord
operator|=
name|ord
expr_stmt|;
name|this
operator|.
name|termState
operator|=
name|fr
operator|.
name|parent
operator|.
name|postingsReader
operator|.
name|newTermState
argument_list|()
expr_stmt|;
name|this
operator|.
name|termState
operator|.
name|totalTermFreq
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|longs
operator|=
operator|new
name|long
index|[
name|fr
operator|.
name|longsSize
index|]
expr_stmt|;
block|}
DECL|method|loadNextFloorBlock
name|void
name|loadNextFloorBlock
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|numFollowFloorBlocks
operator|>
literal|0
assert|;
comment|//if (DEBUG) System.out.println("    loadNextFoorBlock trans=" + transitions[transitionIndex]);
do|do
block|{
name|fp
operator|=
name|fpOrig
operator|+
operator|(
name|floorDataReader
operator|.
name|readVLong
argument_list|()
operator|>>>
literal|1
operator|)
expr_stmt|;
name|numFollowFloorBlocks
operator|--
expr_stmt|;
comment|// if (DEBUG) System.out.println("    skip floor block2!  nextFloorLabel=" + (char) nextFloorLabel + " vs target=" + (char) transitions[transitionIndex].getMin() + " newFP=" + fp + " numFollowFloorBlocks=" + numFollowFloorBlocks);
if|if
condition|(
name|numFollowFloorBlocks
operator|!=
literal|0
condition|)
block|{
name|nextFloorLabel
operator|=
name|floorDataReader
operator|.
name|readByte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|nextFloorLabel
operator|=
literal|256
expr_stmt|;
block|}
comment|// if (DEBUG) System.out.println("    nextFloorLabel=" + (char) nextFloorLabel);
block|}
do|while
condition|(
name|numFollowFloorBlocks
operator|!=
literal|0
operator|&&
name|nextFloorLabel
operator|<=
name|transitions
index|[
name|transitionIndex
index|]
operator|.
name|getMin
argument_list|()
condition|)
do|;
name|load
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|setState
specifier|public
name|void
name|setState
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|transitionIndex
operator|=
literal|0
expr_stmt|;
name|transitions
operator|=
name|compiledAutomaton
operator|.
name|sortedTransitions
index|[
name|state
index|]
expr_stmt|;
if|if
condition|(
name|transitions
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|curTransitionMax
operator|=
name|transitions
index|[
literal|0
index|]
operator|.
name|getMax
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|curTransitionMax
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
DECL|method|load
name|void
name|load
parameter_list|(
name|BytesRef
name|frameIndexData
parameter_list|)
throws|throws
name|IOException
block|{
comment|// if (DEBUG) System.out.println("    load fp=" + fp + " fpOrig=" + fpOrig + " frameIndexData=" + frameIndexData + " trans=" + (transitions.length != 0 ? transitions[0] : "n/a" + " state=" + state));
if|if
condition|(
name|frameIndexData
operator|!=
literal|null
operator|&&
name|transitions
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
comment|// Floor frame
if|if
condition|(
name|floorData
operator|.
name|length
operator|<
name|frameIndexData
operator|.
name|length
condition|)
block|{
name|this
operator|.
name|floorData
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|frameIndexData
operator|.
name|length
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|frameIndexData
operator|.
name|bytes
argument_list|,
name|frameIndexData
operator|.
name|offset
argument_list|,
name|floorData
argument_list|,
literal|0
argument_list|,
name|frameIndexData
operator|.
name|length
argument_list|)
expr_stmt|;
name|floorDataReader
operator|.
name|reset
argument_list|(
name|floorData
argument_list|,
literal|0
argument_list|,
name|frameIndexData
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// Skip first long -- has redundant fp, hasTerms
comment|// flag, isFloor flag
specifier|final
name|long
name|code
init|=
name|floorDataReader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
name|BlockTreeTermsWriter
operator|.
name|OUTPUT_FLAG_IS_FLOOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|numFollowFloorBlocks
operator|=
name|floorDataReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|nextFloorLabel
operator|=
name|floorDataReader
operator|.
name|readByte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
comment|// if (DEBUG) System.out.println("    numFollowFloorBlocks=" + numFollowFloorBlocks + " nextFloorLabel=" + nextFloorLabel);
comment|// If current state is accept, we must process
comment|// first block in case it has empty suffix:
if|if
condition|(
operator|!
name|runAutomaton
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
condition|)
block|{
comment|// Maybe skip floor blocks:
while|while
condition|(
name|numFollowFloorBlocks
operator|!=
literal|0
operator|&&
name|nextFloorLabel
operator|<=
name|transitions
index|[
literal|0
index|]
operator|.
name|getMin
argument_list|()
condition|)
block|{
name|fp
operator|=
name|fpOrig
operator|+
operator|(
name|floorDataReader
operator|.
name|readVLong
argument_list|()
operator|>>>
literal|1
operator|)
expr_stmt|;
name|numFollowFloorBlocks
operator|--
expr_stmt|;
comment|// if (DEBUG) System.out.println("    skip floor block!  nextFloorLabel=" + (char) nextFloorLabel + " vs target=" + (char) transitions[0].getMin() + " newFP=" + fp + " numFollowFloorBlocks=" + numFollowFloorBlocks);
if|if
condition|(
name|numFollowFloorBlocks
operator|!=
literal|0
condition|)
block|{
name|nextFloorLabel
operator|=
name|floorDataReader
operator|.
name|readByte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|nextFloorLabel
operator|=
literal|256
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|in
operator|.
name|seek
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|int
name|code
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|entCount
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
assert|assert
name|entCount
operator|>
literal|0
assert|;
name|isLastInFloor
operator|=
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
comment|// term suffixes:
name|code
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|isLeafBlock
operator|=
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
name|int
name|numBytes
init|=
name|code
operator|>>>
literal|1
decl_stmt|;
comment|// if (DEBUG) System.out.println("      entCount=" + entCount + " lastInFloor?=" + isLastInFloor + " leafBlock?=" + isLeafBlock + " numSuffixBytes=" + numBytes);
if|if
condition|(
name|suffixBytes
operator|.
name|length
operator|<
name|numBytes
condition|)
block|{
name|suffixBytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|in
operator|.
name|readBytes
argument_list|(
name|suffixBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|suffixesReader
operator|.
name|reset
argument_list|(
name|suffixBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
comment|// stats
name|numBytes
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|statBytes
operator|.
name|length
operator|<
name|numBytes
condition|)
block|{
name|statBytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|in
operator|.
name|readBytes
argument_list|(
name|statBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|statsReader
operator|.
name|reset
argument_list|(
name|statBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|metaDataUpto
operator|=
literal|0
expr_stmt|;
name|termState
operator|.
name|termBlockOrd
operator|=
literal|0
expr_stmt|;
name|nextEnt
operator|=
literal|0
expr_stmt|;
comment|// metadata
name|numBytes
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|null
condition|)
block|{
name|bytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
name|bytesReader
operator|=
operator|new
name|ByteArrayDataInput
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|.
name|length
operator|<
name|numBytes
condition|)
block|{
name|bytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|in
operator|.
name|readBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|bytesReader
operator|.
name|reset
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isLastInFloor
condition|)
block|{
comment|// Sub-blocks of a single floor block are always
comment|// written one after another -- tail recurse:
name|fpEnd
operator|=
name|in
operator|.
name|getFilePointer
argument_list|()
expr_stmt|;
block|}
block|}
comment|// TODO: maybe add scanToLabel; should give perf boost
DECL|method|next
specifier|public
name|boolean
name|next
parameter_list|()
block|{
return|return
name|isLeafBlock
condition|?
name|nextLeaf
argument_list|()
else|:
name|nextNonLeaf
argument_list|()
return|;
block|}
comment|// Decodes next entry; returns true if it's a sub-block
DECL|method|nextLeaf
specifier|public
name|boolean
name|nextLeaf
parameter_list|()
block|{
comment|//if (DEBUG) System.out.println("  frame.next ord=" + ord + " nextEnt=" + nextEnt + " entCount=" + entCount);
assert|assert
name|nextEnt
operator|!=
operator|-
literal|1
operator|&&
name|nextEnt
operator|<
name|entCount
operator|:
literal|"nextEnt="
operator|+
name|nextEnt
operator|+
literal|" entCount="
operator|+
name|entCount
operator|+
literal|" fp="
operator|+
name|fp
assert|;
name|nextEnt
operator|++
expr_stmt|;
name|suffix
operator|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|suffixesReader
operator|.
name|skipBytes
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|method|nextNonLeaf
specifier|public
name|boolean
name|nextNonLeaf
parameter_list|()
block|{
comment|//if (DEBUG) System.out.println("  frame.next ord=" + ord + " nextEnt=" + nextEnt + " entCount=" + entCount);
assert|assert
name|nextEnt
operator|!=
operator|-
literal|1
operator|&&
name|nextEnt
operator|<
name|entCount
operator|:
literal|"nextEnt="
operator|+
name|nextEnt
operator|+
literal|" entCount="
operator|+
name|entCount
operator|+
literal|" fp="
operator|+
name|fp
assert|;
name|nextEnt
operator|++
expr_stmt|;
specifier|final
name|int
name|code
init|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|suffix
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|suffixesReader
operator|.
name|skipBytes
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|// A normal term
name|termState
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// A sub-block; make sub-FP absolute:
name|lastSubFP
operator|=
name|fp
operator|-
name|suffixesReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
DECL|method|getTermBlockOrd
specifier|public
name|int
name|getTermBlockOrd
parameter_list|()
block|{
return|return
name|isLeafBlock
condition|?
name|nextEnt
else|:
name|termState
operator|.
name|termBlockOrd
return|;
block|}
DECL|method|decodeMetaData
specifier|public
name|void
name|decodeMetaData
parameter_list|()
throws|throws
name|IOException
block|{
comment|// lazily catch up on metadata decode:
specifier|final
name|int
name|limit
init|=
name|getTermBlockOrd
argument_list|()
decl_stmt|;
name|boolean
name|absolute
init|=
name|metaDataUpto
operator|==
literal|0
decl_stmt|;
assert|assert
name|limit
operator|>
literal|0
assert|;
comment|// TODO: better API would be "jump straight to term=N"???
while|while
condition|(
name|metaDataUpto
operator|<
name|limit
condition|)
block|{
comment|// TODO: we could make "tiers" of metadata, ie,
comment|// decode docFreq/totalTF but don't decode postings
comment|// metadata; this way caller could get
comment|// docFreq/totalTF w/o paying decode cost for
comment|// postings
comment|// TODO: if docFreq were bulk decoded we could
comment|// just skipN here:
comment|// stats
name|termState
operator|.
name|docFreq
operator|=
name|statsReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("    dF=" + state.docFreq);
if|if
condition|(
name|fr
operator|.
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|!=
name|IndexOptions
operator|.
name|DOCS_ONLY
condition|)
block|{
name|termState
operator|.
name|totalTermFreq
operator|=
name|termState
operator|.
name|docFreq
operator|+
name|statsReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("    totTF=" + state.totalTermFreq);
block|}
comment|// metadata
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fr
operator|.
name|longsSize
condition|;
name|i
operator|++
control|)
block|{
name|longs
index|[
name|i
index|]
operator|=
name|bytesReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
block|}
name|fr
operator|.
name|parent
operator|.
name|postingsReader
operator|.
name|decodeTerm
argument_list|(
name|longs
argument_list|,
name|bytesReader
argument_list|,
name|fr
operator|.
name|fieldInfo
argument_list|,
name|termState
argument_list|,
name|absolute
argument_list|)
expr_stmt|;
name|metaDataUpto
operator|++
expr_stmt|;
name|absolute
operator|=
literal|false
expr_stmt|;
block|}
name|termState
operator|.
name|termBlockOrd
operator|=
name|metaDataUpto
expr_stmt|;
block|}
block|}
DECL|field|savedStartTerm
specifier|private
name|BytesRef
name|savedStartTerm
decl_stmt|;
comment|// TODO: in some cases we can filter by length?  eg
comment|// regexp foo*bar must be at least length 6 bytes
DECL|method|IntersectTermsEnum
specifier|public
name|IntersectTermsEnum
parameter_list|(
name|FieldReader
name|fr
parameter_list|,
name|CompiledAutomaton
name|compiled
parameter_list|,
name|BytesRef
name|startTerm
parameter_list|)
throws|throws
name|IOException
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("\nintEnum.init seg=" + segment + " commonSuffix=" + brToString(compiled.commonSuffixRef));
comment|// }
name|this
operator|.
name|fr
operator|=
name|fr
expr_stmt|;
name|runAutomaton
operator|=
name|compiled
operator|.
name|runAutomaton
expr_stmt|;
name|compiledAutomaton
operator|=
name|compiled
expr_stmt|;
name|in
operator|=
name|fr
operator|.
name|parent
operator|.
name|in
operator|.
name|clone
argument_list|()
expr_stmt|;
name|stack
operator|=
operator|new
name|Frame
index|[
literal|5
index|]
expr_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|stack
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|stack
index|[
name|idx
index|]
operator|=
operator|new
name|Frame
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|arcs
operator|.
name|length
condition|;
name|arcIdx
operator|++
control|)
block|{
name|arcs
index|[
name|arcIdx
index|]
operator|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<>
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fr
operator|.
name|index
operator|==
literal|null
condition|)
block|{
name|fstReader
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|fstReader
operator|=
name|fr
operator|.
name|index
operator|.
name|getBytesReader
argument_list|()
expr_stmt|;
block|}
comment|// TODO: if the automaton is "smallish" we really
comment|// should use the terms index to seek at least to
comment|// the initial term and likely to subsequent terms
comment|// (or, maybe just fallback to ATE for such cases).
comment|// Else the seek cost of loading the frames will be
comment|// too costly.
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
init|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
comment|// Special pushFrame since it's the first one:
specifier|final
name|Frame
name|f
init|=
name|stack
index|[
literal|0
index|]
decl_stmt|;
name|f
operator|.
name|fp
operator|=
name|f
operator|.
name|fpOrig
operator|=
name|fr
operator|.
name|rootBlockFP
expr_stmt|;
name|f
operator|.
name|prefix
operator|=
literal|0
expr_stmt|;
name|f
operator|.
name|setState
argument_list|(
name|runAutomaton
operator|.
name|getInitialState
argument_list|()
argument_list|)
expr_stmt|;
name|f
operator|.
name|arc
operator|=
name|arc
expr_stmt|;
name|f
operator|.
name|outputPrefix
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|f
operator|.
name|load
argument_list|(
name|fr
operator|.
name|rootCode
argument_list|)
expr_stmt|;
comment|// for assert:
assert|assert
name|setSavedStartTerm
argument_list|(
name|startTerm
argument_list|)
assert|;
name|currentFrame
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|startTerm
operator|!=
literal|null
condition|)
block|{
name|seekToStartTerm
argument_list|(
name|startTerm
argument_list|)
expr_stmt|;
block|}
block|}
comment|// only for assert:
DECL|method|setSavedStartTerm
specifier|private
name|boolean
name|setSavedStartTerm
parameter_list|(
name|BytesRef
name|startTerm
parameter_list|)
block|{
name|savedStartTerm
operator|=
name|startTerm
operator|==
literal|null
condition|?
literal|null
else|:
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|startTerm
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|termState
specifier|public
name|TermState
name|termState
parameter_list|()
throws|throws
name|IOException
block|{
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|currentFrame
operator|.
name|termState
operator|.
name|clone
argument_list|()
return|;
block|}
DECL|method|getFrame
specifier|private
name|Frame
name|getFrame
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ord
operator|>=
name|stack
operator|.
name|length
condition|)
block|{
specifier|final
name|Frame
index|[]
name|next
init|=
operator|new
name|Frame
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|ord
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|stack
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|stackOrd
init|=
name|stack
operator|.
name|length
init|;
name|stackOrd
operator|<
name|next
operator|.
name|length
condition|;
name|stackOrd
operator|++
control|)
block|{
name|next
index|[
name|stackOrd
index|]
operator|=
operator|new
name|Frame
argument_list|(
name|stackOrd
argument_list|)
expr_stmt|;
block|}
name|stack
operator|=
name|next
expr_stmt|;
block|}
assert|assert
name|stack
index|[
name|ord
index|]
operator|.
name|ord
operator|==
name|ord
assert|;
return|return
name|stack
index|[
name|ord
index|]
return|;
block|}
DECL|method|getArc
specifier|private
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|getArc
parameter_list|(
name|int
name|ord
parameter_list|)
block|{
if|if
condition|(
name|ord
operator|>=
name|arcs
operator|.
name|length
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
index|[]
name|next
init|=
operator|new
name|FST
operator|.
name|Arc
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|ord
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|arcs
argument_list|,
literal|0
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|arcs
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|arcOrd
init|=
name|arcs
operator|.
name|length
init|;
name|arcOrd
operator|<
name|next
operator|.
name|length
condition|;
name|arcOrd
operator|++
control|)
block|{
name|next
index|[
name|arcOrd
index|]
operator|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|arcs
operator|=
name|next
expr_stmt|;
block|}
return|return
name|arcs
index|[
name|ord
index|]
return|;
block|}
DECL|method|pushFrame
specifier|private
name|Frame
name|pushFrame
parameter_list|(
name|int
name|state
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Frame
name|f
init|=
name|getFrame
argument_list|(
name|currentFrame
operator|==
literal|null
condition|?
literal|0
else|:
literal|1
operator|+
name|currentFrame
operator|.
name|ord
argument_list|)
decl_stmt|;
name|f
operator|.
name|fp
operator|=
name|f
operator|.
name|fpOrig
operator|=
name|currentFrame
operator|.
name|lastSubFP
expr_stmt|;
name|f
operator|.
name|prefix
operator|=
name|currentFrame
operator|.
name|prefix
operator|+
name|currentFrame
operator|.
name|suffix
expr_stmt|;
comment|// if (DEBUG) System.out.println("    pushFrame state=" + state + " prefix=" + f.prefix);
name|f
operator|.
name|setState
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|// Walk the arc through the index -- we only
comment|// "bother" with this so we can get the floor data
comment|// from the index and skip floor blocks when
comment|// possible:
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
init|=
name|currentFrame
operator|.
name|arc
decl_stmt|;
name|int
name|idx
init|=
name|currentFrame
operator|.
name|prefix
decl_stmt|;
assert|assert
name|currentFrame
operator|.
name|suffix
operator|>
literal|0
assert|;
name|BytesRef
name|output
init|=
name|currentFrame
operator|.
name|outputPrefix
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|f
operator|.
name|prefix
condition|)
block|{
specifier|final
name|int
name|target
init|=
name|term
operator|.
name|bytes
index|[
name|idx
index|]
operator|&
literal|0xff
decl_stmt|;
comment|// TODO: we could be more efficient for the next()
comment|// case by using current arc as starting point,
comment|// passed to findTargetArc
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|findTargetArc
argument_list|(
name|target
argument_list|,
name|arc
argument_list|,
name|getArc
argument_list|(
literal|1
operator|+
name|idx
argument_list|)
argument_list|,
name|fstReader
argument_list|)
expr_stmt|;
assert|assert
name|arc
operator|!=
literal|null
assert|;
name|output
operator|=
name|fr
operator|.
name|parent
operator|.
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
name|f
operator|.
name|arc
operator|=
name|arc
expr_stmt|;
name|f
operator|.
name|outputPrefix
operator|=
name|output
expr_stmt|;
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
name|f
operator|.
name|load
argument_list|(
name|fr
operator|.
name|parent
operator|.
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
block|{
return|return
name|term
return|;
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
throws|throws
name|IOException
block|{
comment|//if (DEBUG) System.out.println("BTIR.docFreq");
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("  return " + currentFrame.termState.docFreq);
return|return
name|currentFrame
operator|.
name|termState
operator|.
name|docFreq
return|;
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
throws|throws
name|IOException
block|{
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|currentFrame
operator|.
name|termState
operator|.
name|totalTermFreq
return|;
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|fr
operator|.
name|parent
operator|.
name|postingsReader
operator|.
name|docs
argument_list|(
name|fr
operator|.
name|fieldInfo
argument_list|,
name|currentFrame
operator|.
name|termState
argument_list|,
name|skipDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fr
operator|.
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Positions were not indexed:
return|return
literal|null
return|;
block|}
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|fr
operator|.
name|parent
operator|.
name|postingsReader
operator|.
name|docsAndPositions
argument_list|(
name|fr
operator|.
name|fieldInfo
argument_list|,
name|currentFrame
operator|.
name|termState
argument_list|,
name|skipDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
DECL|method|getState
specifier|private
name|int
name|getState
parameter_list|()
block|{
name|int
name|state
init|=
name|currentFrame
operator|.
name|state
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|currentFrame
operator|.
name|suffix
condition|;
name|idx
operator|++
control|)
block|{
name|state
operator|=
name|runAutomaton
operator|.
name|step
argument_list|(
name|state
argument_list|,
name|currentFrame
operator|.
name|suffixBytes
index|[
name|currentFrame
operator|.
name|startBytePos
operator|+
name|idx
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
assert|assert
name|state
operator|!=
operator|-
literal|1
assert|;
block|}
return|return
name|state
return|;
block|}
comment|// NOTE: specialized to only doing the first-time
comment|// seek, but we could generalize it to allow
comment|// arbitrary seekExact/Ceil.  Note that this is a
comment|// seekFloor!
DECL|method|seekToStartTerm
specifier|private
name|void
name|seekToStartTerm
parameter_list|(
name|BytesRef
name|target
parameter_list|)
throws|throws
name|IOException
block|{
comment|//if (DEBUG) System.out.println("seek to startTerm=" + target.utf8ToString());
assert|assert
name|currentFrame
operator|.
name|ord
operator|==
literal|0
assert|;
if|if
condition|(
name|term
operator|.
name|length
operator|<
name|target
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|target
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
init|=
name|arcs
index|[
literal|0
index|]
decl_stmt|;
assert|assert
name|arc
operator|==
name|currentFrame
operator|.
name|arc
assert|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<=
name|target
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|savePos
init|=
name|currentFrame
operator|.
name|suffixesReader
operator|.
name|getPosition
argument_list|()
decl_stmt|;
specifier|final
name|int
name|saveStartBytePos
init|=
name|currentFrame
operator|.
name|startBytePos
decl_stmt|;
specifier|final
name|int
name|saveSuffix
init|=
name|currentFrame
operator|.
name|suffix
decl_stmt|;
specifier|final
name|long
name|saveLastSubFP
init|=
name|currentFrame
operator|.
name|lastSubFP
decl_stmt|;
specifier|final
name|int
name|saveTermBlockOrd
init|=
name|currentFrame
operator|.
name|termState
operator|.
name|termBlockOrd
decl_stmt|;
specifier|final
name|boolean
name|isSubBlock
init|=
name|currentFrame
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//if (DEBUG) System.out.println("    cycle ent=" + currentFrame.nextEnt + " (of " + currentFrame.entCount + ") prefix=" + currentFrame.prefix + " suffix=" + currentFrame.suffix + " isBlock=" + isSubBlock + " firstLabel=" + (currentFrame.suffix == 0 ? "" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));
name|term
operator|.
name|length
operator|=
name|currentFrame
operator|.
name|prefix
operator|+
name|currentFrame
operator|.
name|suffix
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|term
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|currentFrame
operator|.
name|suffixBytes
argument_list|,
name|currentFrame
operator|.
name|startBytePos
argument_list|,
name|term
operator|.
name|bytes
argument_list|,
name|currentFrame
operator|.
name|prefix
argument_list|,
name|currentFrame
operator|.
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSubBlock
operator|&&
name|StringHelper
operator|.
name|startsWith
argument_list|(
name|target
argument_list|,
name|term
argument_list|)
condition|)
block|{
comment|// Recurse
comment|//if (DEBUG) System.out.println("      recurse!");
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|getState
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
specifier|final
name|int
name|cmp
init|=
name|term
operator|.
name|compareTo
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
name|currentFrame
operator|.
name|entCount
condition|)
block|{
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|isLastInFloor
condition|)
block|{
comment|//if (DEBUG) System.out.println("  load floorBlock");
name|currentFrame
operator|.
name|loadNextFloorBlock
argument_list|()
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|//if (DEBUG) System.out.println("  return term=" + brToString(term));
return|return;
block|}
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
comment|//if (DEBUG) System.out.println("  return term=" + brToString(term));
return|return;
block|}
else|else
block|{
comment|// Fallback to prior entry: the semantics of
comment|// this method is that the first call to
comment|// next() will return the term after the
comment|// requested term
name|currentFrame
operator|.
name|nextEnt
operator|--
expr_stmt|;
name|currentFrame
operator|.
name|lastSubFP
operator|=
name|saveLastSubFP
expr_stmt|;
name|currentFrame
operator|.
name|startBytePos
operator|=
name|saveStartBytePos
expr_stmt|;
name|currentFrame
operator|.
name|suffix
operator|=
name|saveSuffix
expr_stmt|;
name|currentFrame
operator|.
name|suffixesReader
operator|.
name|setPosition
argument_list|(
name|savePos
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|termState
operator|.
name|termBlockOrd
operator|=
name|saveTermBlockOrd
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|currentFrame
operator|.
name|suffixBytes
argument_list|,
name|currentFrame
operator|.
name|startBytePos
argument_list|,
name|term
operator|.
name|bytes
argument_list|,
name|currentFrame
operator|.
name|prefix
argument_list|,
name|currentFrame
operator|.
name|suffix
argument_list|)
expr_stmt|;
name|term
operator|.
name|length
operator|=
name|currentFrame
operator|.
name|prefix
operator|+
name|currentFrame
operator|.
name|suffix
expr_stmt|;
comment|// If the last entry was a block we don't
comment|// need to bother recursing and pushing to
comment|// the last term under it because the first
comment|// next() will simply skip the frame anyway
return|return;
block|}
block|}
block|}
block|}
assert|assert
literal|false
assert|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
throws|throws
name|IOException
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("\nintEnum.next seg=" + segment);
comment|//   System.out.println("  frame ord=" + currentFrame.ord + " prefix=" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + " state=" + currentFrame.state + " lastInFloor?=" + currentFrame.isLastInFloor + " fp=" + currentFrame.fp + " trans=" + (currentFrame.transitions.length == 0 ? "n/a" : currentFrame.transitions[currentFrame.transitionIndex]) + " outputPrefix=" + currentFrame.outputPrefix);
comment|// }
name|nextTerm
label|:
while|while
condition|(
literal|true
condition|)
block|{
comment|// Pop finished frames
while|while
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
name|currentFrame
operator|.
name|entCount
condition|)
block|{
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|isLastInFloor
condition|)
block|{
comment|//if (DEBUG) System.out.println("    next-floor-block");
name|currentFrame
operator|.
name|loadNextFloorBlock
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("\n  frame ord=" + currentFrame.ord + " prefix=" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + " state=" + currentFrame.state + " lastInFloor?=" + currentFrame.isLastInFloor + " fp=" + currentFrame.fp + " trans=" + (currentFrame.transitions.length == 0 ? "n/a" : currentFrame.transitions[currentFrame.transitionIndex]) + " outputPrefix=" + currentFrame.outputPrefix);
block|}
else|else
block|{
comment|//if (DEBUG) System.out.println("  pop frame");
if|if
condition|(
name|currentFrame
operator|.
name|ord
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|long
name|lastFP
init|=
name|currentFrame
operator|.
name|fpOrig
decl_stmt|;
name|currentFrame
operator|=
name|stack
index|[
name|currentFrame
operator|.
name|ord
operator|-
literal|1
index|]
expr_stmt|;
assert|assert
name|currentFrame
operator|.
name|lastSubFP
operator|==
name|lastFP
assert|;
comment|//if (DEBUG) System.out.println("\n  frame ord=" + currentFrame.ord + " prefix=" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + " state=" + currentFrame.state + " lastInFloor?=" + currentFrame.isLastInFloor + " fp=" + currentFrame.fp + " trans=" + (currentFrame.transitions.length == 0 ? "n/a" : currentFrame.transitions[currentFrame.transitionIndex]) + " outputPrefix=" + currentFrame.outputPrefix);
block|}
block|}
specifier|final
name|boolean
name|isSubBlock
init|=
name|currentFrame
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// if (DEBUG) {
comment|//   final BytesRef suffixRef = new BytesRef();
comment|//   suffixRef.bytes = currentFrame.suffixBytes;
comment|//   suffixRef.offset = currentFrame.startBytePos;
comment|//   suffixRef.length = currentFrame.suffix;
comment|//   System.out.println("    " + (isSubBlock ? "sub-block" : "term") + " " + currentFrame.nextEnt + " (of " + currentFrame.entCount + ") suffix=" + brToString(suffixRef));
comment|// }
if|if
condition|(
name|currentFrame
operator|.
name|suffix
operator|!=
literal|0
condition|)
block|{
specifier|final
name|int
name|label
init|=
name|currentFrame
operator|.
name|suffixBytes
index|[
name|currentFrame
operator|.
name|startBytePos
index|]
operator|&
literal|0xff
decl_stmt|;
while|while
condition|(
name|label
operator|>
name|currentFrame
operator|.
name|curTransitionMax
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|transitionIndex
operator|>=
name|currentFrame
operator|.
name|transitions
operator|.
name|length
operator|-
literal|1
condition|)
block|{
comment|// Stop processing this frame -- no further
comment|// matches are possible because we've moved
comment|// beyond what the max transition will allow
comment|//if (DEBUG) System.out.println("      break: trans=" + (currentFrame.transitions.length == 0 ? "n/a" : currentFrame.transitions[currentFrame.transitionIndex]));
comment|// sneaky!  forces a pop above
name|currentFrame
operator|.
name|isLastInFloor
operator|=
literal|true
expr_stmt|;
name|currentFrame
operator|.
name|nextEnt
operator|=
name|currentFrame
operator|.
name|entCount
expr_stmt|;
continue|continue
name|nextTerm
continue|;
block|}
name|currentFrame
operator|.
name|transitionIndex
operator|++
expr_stmt|;
name|currentFrame
operator|.
name|curTransitionMax
operator|=
name|currentFrame
operator|.
name|transitions
index|[
name|currentFrame
operator|.
name|transitionIndex
index|]
operator|.
name|getMax
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("      next trans=" + currentFrame.transitions[currentFrame.transitionIndex]);
block|}
block|}
comment|// First test the common suffix, if set:
if|if
condition|(
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|!=
literal|null
operator|&&
operator|!
name|isSubBlock
condition|)
block|{
specifier|final
name|int
name|termLen
init|=
name|currentFrame
operator|.
name|prefix
operator|+
name|currentFrame
operator|.
name|suffix
decl_stmt|;
if|if
condition|(
name|termLen
operator|<
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|length
condition|)
block|{
comment|// No match
comment|// if (DEBUG) {
comment|//   System.out.println("      skip: common suffix length");
comment|// }
continue|continue
name|nextTerm
continue|;
block|}
specifier|final
name|byte
index|[]
name|suffixBytes
init|=
name|currentFrame
operator|.
name|suffixBytes
decl_stmt|;
specifier|final
name|byte
index|[]
name|commonSuffixBytes
init|=
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|bytes
decl_stmt|;
specifier|final
name|int
name|lenInPrefix
init|=
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|length
operator|-
name|currentFrame
operator|.
name|suffix
decl_stmt|;
assert|assert
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|offset
operator|==
literal|0
assert|;
name|int
name|suffixBytesPos
decl_stmt|;
name|int
name|commonSuffixBytesPos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lenInPrefix
operator|>
literal|0
condition|)
block|{
comment|// A prefix of the common suffix overlaps with
comment|// the suffix of the block prefix so we first
comment|// test whether the prefix part matches:
specifier|final
name|byte
index|[]
name|termBytes
init|=
name|term
operator|.
name|bytes
decl_stmt|;
name|int
name|termBytesPos
init|=
name|currentFrame
operator|.
name|prefix
operator|-
name|lenInPrefix
decl_stmt|;
assert|assert
name|termBytesPos
operator|>=
literal|0
assert|;
specifier|final
name|int
name|termBytesPosEnd
init|=
name|currentFrame
operator|.
name|prefix
decl_stmt|;
while|while
condition|(
name|termBytesPos
operator|<
name|termBytesPosEnd
condition|)
block|{
if|if
condition|(
name|termBytes
index|[
name|termBytesPos
operator|++
index|]
operator|!=
name|commonSuffixBytes
index|[
name|commonSuffixBytesPos
operator|++
index|]
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("      skip: common suffix mismatch (in prefix)");
comment|// }
continue|continue
name|nextTerm
continue|;
block|}
block|}
name|suffixBytesPos
operator|=
name|currentFrame
operator|.
name|startBytePos
expr_stmt|;
block|}
else|else
block|{
name|suffixBytesPos
operator|=
name|currentFrame
operator|.
name|startBytePos
operator|+
name|currentFrame
operator|.
name|suffix
operator|-
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|length
expr_stmt|;
block|}
comment|// Test overlapping suffix part:
specifier|final
name|int
name|commonSuffixBytesPosEnd
init|=
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|length
decl_stmt|;
while|while
condition|(
name|commonSuffixBytesPos
operator|<
name|commonSuffixBytesPosEnd
condition|)
block|{
if|if
condition|(
name|suffixBytes
index|[
name|suffixBytesPos
operator|++
index|]
operator|!=
name|commonSuffixBytes
index|[
name|commonSuffixBytesPos
operator|++
index|]
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("      skip: common suffix mismatch");
comment|// }
continue|continue
name|nextTerm
continue|;
block|}
block|}
block|}
comment|// TODO: maybe we should do the same linear test
comment|// that AutomatonTermsEnum does, so that if we
comment|// reach a part of the automaton where .* is
comment|// "temporarily" accepted, we just blindly .next()
comment|// until the limit
comment|// See if the term prefix matches the automaton:
name|int
name|state
init|=
name|currentFrame
operator|.
name|state
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|currentFrame
operator|.
name|suffix
condition|;
name|idx
operator|++
control|)
block|{
name|state
operator|=
name|runAutomaton
operator|.
name|step
argument_list|(
name|state
argument_list|,
name|currentFrame
operator|.
name|suffixBytes
index|[
name|currentFrame
operator|.
name|startBytePos
operator|+
name|idx
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
operator|-
literal|1
condition|)
block|{
comment|// No match
comment|//System.out.println("    no s=" + state);
continue|continue
name|nextTerm
continue|;
block|}
else|else
block|{
comment|//System.out.println("    c s=" + state);
block|}
block|}
if|if
condition|(
name|isSubBlock
condition|)
block|{
comment|// Match!  Recurse:
comment|//if (DEBUG) System.out.println("      sub-block match to state=" + state + "; recurse fp=" + currentFrame.lastSubFP);
name|copyTerm
argument_list|()
expr_stmt|;
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("\n  frame ord=" + currentFrame.ord + " prefix=" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + " state=" + currentFrame.state + " lastInFloor?=" + currentFrame.isLastInFloor + " fp=" + currentFrame.fp + " trans=" + (currentFrame.transitions.length == 0 ? "n/a" : currentFrame.transitions[currentFrame.transitionIndex]) + " outputPrefix=" + currentFrame.outputPrefix);
block|}
elseif|else
if|if
condition|(
name|runAutomaton
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|copyTerm
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("      term match to state=" + state + "; return term=" + brToString(term));
assert|assert
name|savedStartTerm
operator|==
literal|null
operator|||
name|term
operator|.
name|compareTo
argument_list|(
name|savedStartTerm
argument_list|)
operator|>
literal|0
operator|:
literal|"saveStartTerm="
operator|+
name|savedStartTerm
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" term="
operator|+
name|term
operator|.
name|utf8ToString
argument_list|()
assert|;
return|return
name|term
return|;
block|}
else|else
block|{
comment|//System.out.println("    no s=" + state);
block|}
block|}
block|}
DECL|method|copyTerm
specifier|private
name|void
name|copyTerm
parameter_list|()
block|{
comment|//System.out.println("      copyTerm cur.prefix=" + currentFrame.prefix + " cur.suffix=" + currentFrame.suffix + " first=" + (char) currentFrame.suffixBytes[currentFrame.startBytePos]);
specifier|final
name|int
name|len
init|=
name|currentFrame
operator|.
name|prefix
operator|+
name|currentFrame
operator|.
name|suffix
decl_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|len
condition|)
block|{
name|term
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|currentFrame
operator|.
name|suffixBytes
argument_list|,
name|currentFrame
operator|.
name|startBytePos
argument_list|,
name|term
operator|.
name|bytes
argument_list|,
name|currentFrame
operator|.
name|prefix
argument_list|,
name|currentFrame
operator|.
name|suffix
argument_list|)
expr_stmt|;
name|term
operator|.
name|length
operator|=
name|len
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|boolean
name|seekExact
parameter_list|(
name|BytesRef
name|text
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|ord
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
name|BytesRef
name|text
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
end_class
end_unit
