begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.blocktree
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|blocktree
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|PostingsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|Automaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|RunAutomaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|Transition
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|ByteSequenceOutputs
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FST
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|Outputs
import|;
end_import
begin_comment
comment|/** This is used to implement efficient {@link Terms#intersect} for  *  block-tree.  Note that it cannot seek, except for the initial term on  *  init.  It just "nexts" through the intersection of the automaton and  *  the terms.  It does not use the terms index at all: on init, it  *  loads the root block, and scans its way to the initial term.  *  Likewise, in next it scans until it finds a term that matches the  *  current automaton transition.  If the index has auto-prefix terms  *  (only for DOCS_ONLY fields currently) it will visit these terms  *  when possible and then skip the real terms that auto-prefix term  *  matched. */
end_comment
begin_class
DECL|class|IntersectTermsEnum
specifier|final
class|class
name|IntersectTermsEnum
extends|extends
name|TermsEnum
block|{
comment|//static boolean DEBUG = BlockTreeTermsWriter.DEBUG;
DECL|field|in
specifier|final
name|IndexInput
name|in
decl_stmt|;
DECL|field|fstOutputs
specifier|final
specifier|static
name|Outputs
argument_list|<
name|BytesRef
argument_list|>
name|fstOutputs
init|=
name|ByteSequenceOutputs
operator|.
name|getSingleton
argument_list|()
decl_stmt|;
DECL|field|stack
name|IntersectTermsEnumFrame
index|[]
name|stack
decl_stmt|;
DECL|field|arcs
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|private
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
index|[]
name|arcs
init|=
operator|new
name|FST
operator|.
name|Arc
index|[
literal|5
index|]
decl_stmt|;
DECL|field|runAutomaton
specifier|final
name|RunAutomaton
name|runAutomaton
decl_stmt|;
DECL|field|automaton
specifier|final
name|Automaton
name|automaton
decl_stmt|;
DECL|field|commonSuffix
specifier|final
name|BytesRef
name|commonSuffix
decl_stmt|;
DECL|field|currentFrame
specifier|private
name|IntersectTermsEnumFrame
name|currentFrame
decl_stmt|;
DECL|field|currentTransition
specifier|private
name|Transition
name|currentTransition
decl_stmt|;
DECL|field|term
specifier|private
specifier|final
name|BytesRef
name|term
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
DECL|field|fstReader
specifier|private
specifier|final
name|FST
operator|.
name|BytesReader
name|fstReader
decl_stmt|;
DECL|field|allowAutoPrefixTerms
specifier|private
specifier|final
name|boolean
name|allowAutoPrefixTerms
decl_stmt|;
DECL|field|fr
specifier|final
name|FieldReader
name|fr
decl_stmt|;
comment|/** Which state in the automaton accepts all possible suffixes. */
DECL|field|sinkState
specifier|private
specifier|final
name|int
name|sinkState
decl_stmt|;
DECL|field|savedStartTerm
specifier|private
name|BytesRef
name|savedStartTerm
decl_stmt|;
comment|/** True if we did return the current auto-prefix term */
DECL|field|useAutoPrefixTerm
specifier|private
name|boolean
name|useAutoPrefixTerm
decl_stmt|;
comment|// TODO: in some cases we can filter by length?  eg
comment|// regexp foo*bar must be at least length 6 bytes
DECL|method|IntersectTermsEnum
specifier|public
name|IntersectTermsEnum
parameter_list|(
name|FieldReader
name|fr
parameter_list|,
name|Automaton
name|automaton
parameter_list|,
name|RunAutomaton
name|runAutomaton
parameter_list|,
name|BytesRef
name|commonSuffix
parameter_list|,
name|BytesRef
name|startTerm
parameter_list|,
name|int
name|sinkState
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|fr
operator|=
name|fr
expr_stmt|;
name|this
operator|.
name|sinkState
operator|=
name|sinkState
expr_stmt|;
assert|assert
name|automaton
operator|!=
literal|null
assert|;
assert|assert
name|runAutomaton
operator|!=
literal|null
assert|;
name|this
operator|.
name|runAutomaton
operator|=
name|runAutomaton
expr_stmt|;
name|this
operator|.
name|allowAutoPrefixTerms
operator|=
name|sinkState
operator|!=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|automaton
operator|=
name|automaton
expr_stmt|;
name|this
operator|.
name|commonSuffix
operator|=
name|commonSuffix
expr_stmt|;
name|in
operator|=
name|fr
operator|.
name|parent
operator|.
name|termsIn
operator|.
name|clone
argument_list|()
expr_stmt|;
name|stack
operator|=
operator|new
name|IntersectTermsEnumFrame
index|[
literal|5
index|]
expr_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|stack
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|stack
index|[
name|idx
index|]
operator|=
operator|new
name|IntersectTermsEnumFrame
argument_list|(
name|this
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|arcIdx
init|=
literal|0
init|;
name|arcIdx
operator|<
name|arcs
operator|.
name|length
condition|;
name|arcIdx
operator|++
control|)
block|{
name|arcs
index|[
name|arcIdx
index|]
operator|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<>
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fr
operator|.
name|index
operator|==
literal|null
condition|)
block|{
name|fstReader
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|fstReader
operator|=
name|fr
operator|.
name|index
operator|.
name|getBytesReader
argument_list|()
expr_stmt|;
block|}
comment|// TODO: if the automaton is "smallish" we really
comment|// should use the terms index to seek at least to
comment|// the initial term and likely to subsequent terms
comment|// (or, maybe just fallback to ATE for such cases).
comment|// Else the seek cost of loading the frames will be
comment|// too costly.
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
init|=
name|fr
operator|.
name|index
operator|.
name|getFirstArc
argument_list|(
name|arcs
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|// Empty string prefix must have an output in the index!
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
comment|// Special pushFrame since it's the first one:
specifier|final
name|IntersectTermsEnumFrame
name|f
init|=
name|stack
index|[
literal|0
index|]
decl_stmt|;
name|f
operator|.
name|fp
operator|=
name|f
operator|.
name|fpOrig
operator|=
name|fr
operator|.
name|rootBlockFP
expr_stmt|;
name|f
operator|.
name|prefix
operator|=
literal|0
expr_stmt|;
name|f
operator|.
name|setState
argument_list|(
name|runAutomaton
operator|.
name|getInitialState
argument_list|()
argument_list|)
expr_stmt|;
name|f
operator|.
name|arc
operator|=
name|arc
expr_stmt|;
name|f
operator|.
name|outputPrefix
operator|=
name|arc
operator|.
name|output
expr_stmt|;
name|f
operator|.
name|load
argument_list|(
name|fr
operator|.
name|rootCode
argument_list|)
expr_stmt|;
comment|// for assert:
assert|assert
name|setSavedStartTerm
argument_list|(
name|startTerm
argument_list|)
assert|;
name|currentFrame
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|startTerm
operator|!=
literal|null
condition|)
block|{
name|seekToStartTerm
argument_list|(
name|startTerm
argument_list|)
expr_stmt|;
block|}
name|currentTransition
operator|=
name|currentFrame
operator|.
name|transition
expr_stmt|;
block|}
comment|// only for assert:
DECL|method|setSavedStartTerm
specifier|private
name|boolean
name|setSavedStartTerm
parameter_list|(
name|BytesRef
name|startTerm
parameter_list|)
block|{
name|savedStartTerm
operator|=
name|startTerm
operator|==
literal|null
condition|?
literal|null
else|:
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|startTerm
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|termState
specifier|public
name|TermState
name|termState
parameter_list|()
throws|throws
name|IOException
block|{
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|currentFrame
operator|.
name|termState
operator|.
name|clone
argument_list|()
return|;
block|}
DECL|method|getFrame
specifier|private
name|IntersectTermsEnumFrame
name|getFrame
parameter_list|(
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ord
operator|>=
name|stack
operator|.
name|length
condition|)
block|{
specifier|final
name|IntersectTermsEnumFrame
index|[]
name|next
init|=
operator|new
name|IntersectTermsEnumFrame
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|ord
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|stack
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|stackOrd
init|=
name|stack
operator|.
name|length
init|;
name|stackOrd
operator|<
name|next
operator|.
name|length
condition|;
name|stackOrd
operator|++
control|)
block|{
name|next
index|[
name|stackOrd
index|]
operator|=
operator|new
name|IntersectTermsEnumFrame
argument_list|(
name|this
argument_list|,
name|stackOrd
argument_list|)
expr_stmt|;
block|}
name|stack
operator|=
name|next
expr_stmt|;
block|}
assert|assert
name|stack
index|[
name|ord
index|]
operator|.
name|ord
operator|==
name|ord
assert|;
return|return
name|stack
index|[
name|ord
index|]
return|;
block|}
DECL|method|getArc
specifier|private
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|getArc
parameter_list|(
name|int
name|ord
parameter_list|)
block|{
if|if
condition|(
name|ord
operator|>=
name|arcs
operator|.
name|length
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|final
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
index|[]
name|next
init|=
operator|new
name|FST
operator|.
name|Arc
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
literal|1
operator|+
name|ord
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|arcs
argument_list|,
literal|0
argument_list|,
name|next
argument_list|,
literal|0
argument_list|,
name|arcs
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|arcOrd
init|=
name|arcs
operator|.
name|length
init|;
name|arcOrd
operator|<
name|next
operator|.
name|length
condition|;
name|arcOrd
operator|++
control|)
block|{
name|next
index|[
name|arcOrd
index|]
operator|=
operator|new
name|FST
operator|.
name|Arc
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|arcs
operator|=
name|next
expr_stmt|;
block|}
return|return
name|arcs
index|[
name|ord
index|]
return|;
block|}
DECL|method|pushFrame
specifier|private
name|IntersectTermsEnumFrame
name|pushFrame
parameter_list|(
name|int
name|state
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|currentFrame
operator|!=
literal|null
assert|;
specifier|final
name|IntersectTermsEnumFrame
name|f
init|=
name|getFrame
argument_list|(
name|currentFrame
operator|==
literal|null
condition|?
literal|0
else|:
literal|1
operator|+
name|currentFrame
operator|.
name|ord
argument_list|)
decl_stmt|;
name|f
operator|.
name|fp
operator|=
name|f
operator|.
name|fpOrig
operator|=
name|currentFrame
operator|.
name|lastSubFP
expr_stmt|;
name|f
operator|.
name|prefix
operator|=
name|currentFrame
operator|.
name|prefix
operator|+
name|currentFrame
operator|.
name|suffix
expr_stmt|;
name|f
operator|.
name|setState
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|// Walk the arc through the index -- we only
comment|// "bother" with this so we can get the floor data
comment|// from the index and skip floor blocks when
comment|// possible:
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
init|=
name|currentFrame
operator|.
name|arc
decl_stmt|;
name|int
name|idx
init|=
name|currentFrame
operator|.
name|prefix
decl_stmt|;
assert|assert
name|currentFrame
operator|.
name|suffix
operator|>
literal|0
assert|;
name|BytesRef
name|output
init|=
name|currentFrame
operator|.
name|outputPrefix
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|f
operator|.
name|prefix
condition|)
block|{
specifier|final
name|int
name|target
init|=
name|term
operator|.
name|bytes
index|[
name|idx
index|]
operator|&
literal|0xff
decl_stmt|;
comment|// TODO: we could be more efficient for the next()
comment|// case by using current arc as starting point,
comment|// passed to findTargetArc
name|arc
operator|=
name|fr
operator|.
name|index
operator|.
name|findTargetArc
argument_list|(
name|target
argument_list|,
name|arc
argument_list|,
name|getArc
argument_list|(
literal|1
operator|+
name|idx
argument_list|)
argument_list|,
name|fstReader
argument_list|)
expr_stmt|;
assert|assert
name|arc
operator|!=
literal|null
assert|;
name|output
operator|=
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|output
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
name|f
operator|.
name|arc
operator|=
name|arc
expr_stmt|;
name|f
operator|.
name|outputPrefix
operator|=
name|output
expr_stmt|;
assert|assert
name|arc
operator|.
name|isFinal
argument_list|()
assert|;
name|f
operator|.
name|load
argument_list|(
name|fstOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|,
name|arc
operator|.
name|nextFinalOutput
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
block|{
return|return
name|term
return|;
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
throws|throws
name|IOException
block|{
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|currentFrame
operator|.
name|termState
operator|.
name|docFreq
return|;
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
throws|throws
name|IOException
block|{
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|currentFrame
operator|.
name|termState
operator|.
name|totalTermFreq
return|;
block|}
annotation|@
name|Override
DECL|method|postings
specifier|public
name|PostingsEnum
name|postings
parameter_list|(
name|Bits
name|skipDocs
parameter_list|,
name|PostingsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|currentFrame
operator|.
name|decodeMetaData
argument_list|()
expr_stmt|;
return|return
name|fr
operator|.
name|parent
operator|.
name|postingsReader
operator|.
name|postings
argument_list|(
name|fr
operator|.
name|fieldInfo
argument_list|,
name|currentFrame
operator|.
name|termState
argument_list|,
name|skipDocs
argument_list|,
name|reuse
argument_list|,
name|flags
argument_list|)
return|;
block|}
DECL|method|getState
specifier|private
name|int
name|getState
parameter_list|()
block|{
name|int
name|state
init|=
name|currentFrame
operator|.
name|state
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|currentFrame
operator|.
name|suffix
condition|;
name|idx
operator|++
control|)
block|{
name|state
operator|=
name|runAutomaton
operator|.
name|step
argument_list|(
name|state
argument_list|,
name|currentFrame
operator|.
name|suffixBytes
index|[
name|currentFrame
operator|.
name|startBytePos
operator|+
name|idx
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
assert|assert
name|state
operator|!=
operator|-
literal|1
assert|;
block|}
return|return
name|state
return|;
block|}
comment|// NOTE: specialized to only doing the first-time
comment|// seek, but we could generalize it to allow
comment|// arbitrary seekExact/Ceil.  Note that this is a
comment|// seekFloor!
DECL|method|seekToStartTerm
specifier|private
name|void
name|seekToStartTerm
parameter_list|(
name|BytesRef
name|target
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|currentFrame
operator|.
name|ord
operator|==
literal|0
assert|;
if|if
condition|(
name|term
operator|.
name|length
operator|<
name|target
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|target
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
init|=
name|arcs
index|[
literal|0
index|]
decl_stmt|;
assert|assert
name|arc
operator|==
name|currentFrame
operator|.
name|arc
assert|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<=
name|target
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|savNextEnt
init|=
name|currentFrame
operator|.
name|nextEnt
decl_stmt|;
specifier|final
name|int
name|savePos
init|=
name|currentFrame
operator|.
name|suffixesReader
operator|.
name|getPosition
argument_list|()
decl_stmt|;
specifier|final
name|int
name|saveStartBytePos
init|=
name|currentFrame
operator|.
name|startBytePos
decl_stmt|;
specifier|final
name|int
name|saveSuffix
init|=
name|currentFrame
operator|.
name|suffix
decl_stmt|;
specifier|final
name|long
name|saveLastSubFP
init|=
name|currentFrame
operator|.
name|lastSubFP
decl_stmt|;
specifier|final
name|int
name|saveTermBlockOrd
init|=
name|currentFrame
operator|.
name|termState
operator|.
name|termBlockOrd
decl_stmt|;
specifier|final
name|boolean
name|saveIsAutoPrefixTerm
init|=
name|currentFrame
operator|.
name|isAutoPrefixTerm
decl_stmt|;
specifier|final
name|boolean
name|isSubBlock
init|=
name|currentFrame
operator|.
name|next
argument_list|()
decl_stmt|;
name|term
operator|.
name|length
operator|=
name|currentFrame
operator|.
name|prefix
operator|+
name|currentFrame
operator|.
name|suffix
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|term
operator|.
name|length
condition|)
block|{
name|term
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|currentFrame
operator|.
name|suffixBytes
argument_list|,
name|currentFrame
operator|.
name|startBytePos
argument_list|,
name|term
operator|.
name|bytes
argument_list|,
name|currentFrame
operator|.
name|prefix
argument_list|,
name|currentFrame
operator|.
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSubBlock
operator|&&
name|StringHelper
operator|.
name|startsWith
argument_list|(
name|target
argument_list|,
name|term
argument_list|)
condition|)
block|{
comment|// Recurse
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|getState
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
specifier|final
name|int
name|cmp
init|=
name|term
operator|.
name|compareTo
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
name|currentFrame
operator|.
name|entCount
condition|)
block|{
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|isLastInFloor
condition|)
block|{
comment|// Advance to next floor block
name|currentFrame
operator|.
name|loadNextFloorBlock
argument_list|()
expr_stmt|;
continue|continue;
block|}
else|else
block|{
return|return;
block|}
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|allowAutoPrefixTerms
operator|==
literal|false
operator|&&
name|currentFrame
operator|.
name|isAutoPrefixTerm
condition|)
block|{
continue|continue;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|allowAutoPrefixTerms
operator|||
name|currentFrame
operator|.
name|isAutoPrefixTerm
operator|==
literal|false
condition|)
block|{
comment|// Fallback to prior entry: the semantics of
comment|// this method is that the first call to
comment|// next() will return the term after the
comment|// requested term
name|currentFrame
operator|.
name|nextEnt
operator|=
name|savNextEnt
expr_stmt|;
name|currentFrame
operator|.
name|lastSubFP
operator|=
name|saveLastSubFP
expr_stmt|;
name|currentFrame
operator|.
name|startBytePos
operator|=
name|saveStartBytePos
expr_stmt|;
name|currentFrame
operator|.
name|suffix
operator|=
name|saveSuffix
expr_stmt|;
name|currentFrame
operator|.
name|suffixesReader
operator|.
name|setPosition
argument_list|(
name|savePos
argument_list|)
expr_stmt|;
name|currentFrame
operator|.
name|termState
operator|.
name|termBlockOrd
operator|=
name|saveTermBlockOrd
expr_stmt|;
name|currentFrame
operator|.
name|isAutoPrefixTerm
operator|=
name|saveIsAutoPrefixTerm
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|currentFrame
operator|.
name|suffixBytes
argument_list|,
name|currentFrame
operator|.
name|startBytePos
argument_list|,
name|term
operator|.
name|bytes
argument_list|,
name|currentFrame
operator|.
name|prefix
argument_list|,
name|currentFrame
operator|.
name|suffix
argument_list|)
expr_stmt|;
name|term
operator|.
name|length
operator|=
name|currentFrame
operator|.
name|prefix
operator|+
name|currentFrame
operator|.
name|suffix
expr_stmt|;
comment|// If the last entry was a block we don't
comment|// need to bother recursing and pushing to
comment|// the last term under it because the first
comment|// next() will simply skip the frame anyway
return|return;
block|}
block|}
block|}
block|}
assert|assert
literal|false
assert|;
block|}
DECL|method|popPushNext
specifier|private
name|boolean
name|popPushNext
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Pop finished frames
while|while
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
name|currentFrame
operator|.
name|entCount
condition|)
block|{
if|if
condition|(
operator|!
name|currentFrame
operator|.
name|isLastInFloor
condition|)
block|{
comment|// Advance to next floor block
name|currentFrame
operator|.
name|loadNextFloorBlock
argument_list|()
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|currentFrame
operator|.
name|ord
operator|==
literal|0
condition|)
block|{
throw|throw
name|NoMoreTermsException
operator|.
name|INSTANCE
throw|;
block|}
specifier|final
name|long
name|lastFP
init|=
name|currentFrame
operator|.
name|fpOrig
decl_stmt|;
name|currentFrame
operator|=
name|stack
index|[
name|currentFrame
operator|.
name|ord
operator|-
literal|1
index|]
expr_stmt|;
name|currentTransition
operator|=
name|currentFrame
operator|.
name|transition
expr_stmt|;
assert|assert
name|currentFrame
operator|.
name|lastSubFP
operator|==
name|lastFP
assert|;
block|}
block|}
return|return
name|currentFrame
operator|.
name|next
argument_list|()
return|;
block|}
DECL|method|skipPastLastAutoPrefixTerm
specifier|private
name|boolean
name|skipPastLastAutoPrefixTerm
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|currentFrame
operator|.
name|isAutoPrefixTerm
assert|;
name|useAutoPrefixTerm
operator|=
literal|false
expr_stmt|;
name|currentFrame
operator|.
name|termState
operator|.
name|isRealTerm
operator|=
literal|true
expr_stmt|;
comment|// If we last returned an auto-prefix term, we must now skip all
comment|// actual terms sharing that prefix.  At most, that skipping
comment|// requires popping one frame, but it can also require simply
comment|// scanning ahead within the current frame.  This scanning will
comment|// skip sub-blocks that contain many terms, which is why the
comment|// optimization "works":
name|int
name|floorSuffixLeadEnd
init|=
name|currentFrame
operator|.
name|floorSuffixLeadEnd
decl_stmt|;
name|boolean
name|isSubBlock
decl_stmt|;
if|if
condition|(
name|floorSuffixLeadEnd
operator|==
operator|-
literal|1
condition|)
block|{
comment|// An ordinary prefix, e.g. foo*
name|int
name|prefix
init|=
name|currentFrame
operator|.
name|prefix
decl_stmt|;
name|int
name|suffix
init|=
name|currentFrame
operator|.
name|suffix
decl_stmt|;
if|if
condition|(
name|suffix
operator|==
literal|0
condition|)
block|{
comment|// Easy case: the prefix term's suffix is the empty string,
comment|// meaning the prefix corresponds to all terms in the
comment|// current block, so we just pop this entire block:
if|if
condition|(
name|currentFrame
operator|.
name|ord
operator|==
literal|0
condition|)
block|{
throw|throw
name|NoMoreTermsException
operator|.
name|INSTANCE
throw|;
block|}
name|currentFrame
operator|=
name|stack
index|[
name|currentFrame
operator|.
name|ord
operator|-
literal|1
index|]
expr_stmt|;
name|currentTransition
operator|=
name|currentFrame
operator|.
name|transition
expr_stmt|;
return|return
name|popPushNext
argument_list|()
return|;
block|}
else|else
block|{
comment|// Just next() until we hit an entry that doesn't share this
comment|// prefix.  The first next should be a sub-block sharing the
comment|// same prefix, because if there are enough terms matching a
comment|// given prefix to warrant an auto-prefix term, then there
comment|// must also be enough to make a sub-block (assuming
comment|// minItemsInPrefix> minItemsInBlock):
name|scanPrefix
label|:
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
name|currentFrame
operator|.
name|entCount
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|isLastInFloor
operator|==
literal|false
condition|)
block|{
name|currentFrame
operator|.
name|loadNextFloorBlock
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentFrame
operator|.
name|ord
operator|==
literal|0
condition|)
block|{
throw|throw
name|NoMoreTermsException
operator|.
name|INSTANCE
throw|;
block|}
else|else
block|{
comment|// Pop frame, which also means we've moved beyond this
comment|// auto-prefix term:
name|currentFrame
operator|=
name|stack
index|[
name|currentFrame
operator|.
name|ord
operator|-
literal|1
index|]
expr_stmt|;
name|currentTransition
operator|=
name|currentFrame
operator|.
name|transition
expr_stmt|;
return|return
name|popPushNext
argument_list|()
return|;
block|}
block|}
name|isSubBlock
operator|=
name|currentFrame
operator|.
name|next
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|suffix
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|term
operator|.
name|bytes
index|[
name|prefix
operator|+
name|i
index|]
operator|!=
name|currentFrame
operator|.
name|suffixBytes
index|[
name|currentFrame
operator|.
name|startBytePos
operator|+
name|i
index|]
condition|)
block|{
break|break
name|scanPrefix
break|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
comment|// Floor'd auto-prefix term; in this case we must skip all
comment|// terms e.g. matching foo[a-m]*.  We are currently "on" fooa,
comment|// which the automaton accepted (fooa* through foom*), and
comment|// floorSuffixLeadEnd is m, so we must now scan to foon:
name|int
name|prefix
init|=
name|currentFrame
operator|.
name|prefix
decl_stmt|;
name|int
name|suffix
init|=
name|currentFrame
operator|.
name|suffix
decl_stmt|;
if|if
condition|(
name|currentFrame
operator|.
name|floorSuffixLeadStart
operator|==
operator|-
literal|1
condition|)
block|{
name|suffix
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|suffix
operator|==
literal|0
condition|)
block|{
comment|// This means current frame is fooa*, so we have to first
comment|// pop the current frame, then scan in parent frame:
if|if
condition|(
name|currentFrame
operator|.
name|ord
operator|==
literal|0
condition|)
block|{
throw|throw
name|NoMoreTermsException
operator|.
name|INSTANCE
throw|;
block|}
name|currentFrame
operator|=
name|stack
index|[
name|currentFrame
operator|.
name|ord
operator|-
literal|1
index|]
expr_stmt|;
name|currentTransition
operator|=
name|currentFrame
operator|.
name|transition
expr_stmt|;
comment|// Current (parent) frame is now foo*, so now we just scan
comment|// until the lead suffix byte is> floorSuffixLeadEnd
comment|//assert currentFrame.prefix == prefix-1;
comment|//prefix = currentFrame.prefix;
comment|// In case when we pop, and the parent block is not just prefix-1, e.g. in block 417* on
comment|// its first term = floor prefix term 41[7-9], popping to block 4*:
name|prefix
operator|=
name|currentFrame
operator|.
name|prefix
expr_stmt|;
name|suffix
operator|=
name|term
operator|.
name|length
operator|-
name|currentFrame
operator|.
name|prefix
expr_stmt|;
block|}
else|else
block|{
comment|// No need to pop; just scan in currentFrame:
block|}
comment|// Now we scan until the lead suffix byte is> floorSuffixLeadEnd
name|scanFloor
label|:
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|==
name|currentFrame
operator|.
name|entCount
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|isLastInFloor
operator|==
literal|false
condition|)
block|{
name|currentFrame
operator|.
name|loadNextFloorBlock
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentFrame
operator|.
name|ord
operator|==
literal|0
condition|)
block|{
throw|throw
name|NoMoreTermsException
operator|.
name|INSTANCE
throw|;
block|}
else|else
block|{
comment|// Pop frame, which also means we've moved beyond this
comment|// auto-prefix term:
name|currentFrame
operator|=
name|stack
index|[
name|currentFrame
operator|.
name|ord
operator|-
literal|1
index|]
expr_stmt|;
name|currentTransition
operator|=
name|currentFrame
operator|.
name|transition
expr_stmt|;
return|return
name|popPushNext
argument_list|()
return|;
block|}
block|}
name|isSubBlock
operator|=
name|currentFrame
operator|.
name|next
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|suffix
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|term
operator|.
name|bytes
index|[
name|prefix
operator|+
name|i
index|]
operator|!=
name|currentFrame
operator|.
name|suffixBytes
index|[
name|currentFrame
operator|.
name|startBytePos
operator|+
name|i
index|]
condition|)
block|{
break|break
name|scanFloor
break|;
block|}
block|}
if|if
condition|(
name|currentFrame
operator|.
name|suffix
operator|>=
name|suffix
operator|&&
operator|(
name|currentFrame
operator|.
name|suffixBytes
index|[
name|currentFrame
operator|.
name|startBytePos
operator|+
name|suffix
operator|-
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|>
name|floorSuffixLeadEnd
condition|)
block|{
comment|// Done scanning: we are now on the first term after all
comment|// terms matched by this auto-prefix term
break|break;
block|}
block|}
block|}
return|return
name|isSubBlock
return|;
block|}
comment|// Only used internally when there are no more terms in next():
DECL|class|NoMoreTermsException
specifier|private
specifier|static
specifier|final
class|class
name|NoMoreTermsException
extends|extends
name|RuntimeException
block|{
comment|// Only used internally when there are no more terms in next():
DECL|field|INSTANCE
specifier|public
specifier|static
specifier|final
name|NoMoreTermsException
name|INSTANCE
init|=
operator|new
name|NoMoreTermsException
argument_list|()
decl_stmt|;
DECL|method|NoMoreTermsException
specifier|private
name|NoMoreTermsException
parameter_list|()
block|{     }
annotation|@
name|Override
DECL|method|fillInStackTrace
specifier|public
name|Throwable
name|fillInStackTrace
parameter_list|()
block|{
comment|// Do nothing:
return|return
name|this
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|_next
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NoMoreTermsException
name|eoi
parameter_list|)
block|{
comment|// Provoke NPE if we are (illegally!) called again:
name|currentFrame
operator|=
literal|null
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
DECL|method|_next
specifier|private
name|BytesRef
name|_next
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|isSubBlock
decl_stmt|;
if|if
condition|(
name|useAutoPrefixTerm
condition|)
block|{
comment|// If the current term was an auto-prefix term, we have to skip past it:
name|isSubBlock
operator|=
name|skipPastLastAutoPrefixTerm
argument_list|()
expr_stmt|;
assert|assert
name|useAutoPrefixTerm
operator|==
literal|false
assert|;
block|}
else|else
block|{
name|isSubBlock
operator|=
name|popPushNext
argument_list|()
expr_stmt|;
block|}
name|nextTerm
label|:
while|while
condition|(
literal|true
condition|)
block|{
assert|assert
name|currentFrame
operator|.
name|transition
operator|==
name|currentTransition
assert|;
name|int
name|state
decl_stmt|;
name|int
name|lastState
decl_stmt|;
comment|// NOTE: suffix == 0 can only happen on the first term in a block, when
comment|// there is a term exactly matching a prefix in the index.  If we
comment|// could somehow re-org the code so we only checked this case immediately
comment|// after pushing a frame...
if|if
condition|(
name|currentFrame
operator|.
name|suffix
operator|!=
literal|0
condition|)
block|{
specifier|final
name|byte
index|[]
name|suffixBytes
init|=
name|currentFrame
operator|.
name|suffixBytes
decl_stmt|;
comment|// This is the first byte of the suffix of the term we are now on:
specifier|final
name|int
name|label
init|=
name|suffixBytes
index|[
name|currentFrame
operator|.
name|startBytePos
index|]
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|label
operator|<
name|currentTransition
operator|.
name|min
condition|)
block|{
comment|// Common case: we are scanning terms in this block to "catch up" to
comment|// current transition in the automaton:
name|int
name|minTrans
init|=
name|currentTransition
operator|.
name|min
decl_stmt|;
while|while
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|<
name|currentFrame
operator|.
name|entCount
condition|)
block|{
name|isSubBlock
operator|=
name|currentFrame
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|suffixBytes
index|[
name|currentFrame
operator|.
name|startBytePos
index|]
operator|&
literal|0xff
operator|)
operator|>=
name|minTrans
condition|)
block|{
continue|continue
name|nextTerm
continue|;
block|}
block|}
comment|// End of frame:
name|isSubBlock
operator|=
name|popPushNext
argument_list|()
expr_stmt|;
continue|continue
name|nextTerm
continue|;
block|}
comment|// Advance where we are in the automaton to match this label:
while|while
condition|(
name|label
operator|>
name|currentTransition
operator|.
name|max
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|transitionIndex
operator|>=
name|currentFrame
operator|.
name|transitionCount
operator|-
literal|1
condition|)
block|{
comment|// Pop this frame: no further matches are possible because
comment|// we've moved beyond what the max transition will allow
if|if
condition|(
name|currentFrame
operator|.
name|ord
operator|==
literal|0
condition|)
block|{
comment|// Provoke NPE if we are (illegally!) called again:
name|currentFrame
operator|=
literal|null
expr_stmt|;
return|return
literal|null
return|;
block|}
name|currentFrame
operator|=
name|stack
index|[
name|currentFrame
operator|.
name|ord
operator|-
literal|1
index|]
expr_stmt|;
name|currentTransition
operator|=
name|currentFrame
operator|.
name|transition
expr_stmt|;
name|isSubBlock
operator|=
name|popPushNext
argument_list|()
expr_stmt|;
continue|continue
name|nextTerm
continue|;
block|}
name|currentFrame
operator|.
name|transitionIndex
operator|++
expr_stmt|;
name|automaton
operator|.
name|getNextTransition
argument_list|(
name|currentTransition
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|<
name|currentTransition
operator|.
name|min
condition|)
block|{
name|int
name|minTrans
init|=
name|currentTransition
operator|.
name|min
decl_stmt|;
while|while
condition|(
name|currentFrame
operator|.
name|nextEnt
operator|<
name|currentFrame
operator|.
name|entCount
condition|)
block|{
name|isSubBlock
operator|=
name|currentFrame
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|suffixBytes
index|[
name|currentFrame
operator|.
name|startBytePos
index|]
operator|&
literal|0xff
operator|)
operator|>=
name|minTrans
condition|)
block|{
continue|continue
name|nextTerm
continue|;
block|}
block|}
comment|// End of frame:
name|isSubBlock
operator|=
name|popPushNext
argument_list|()
expr_stmt|;
continue|continue
name|nextTerm
continue|;
block|}
block|}
if|if
condition|(
name|commonSuffix
operator|!=
literal|null
operator|&&
operator|!
name|isSubBlock
condition|)
block|{
specifier|final
name|int
name|termLen
init|=
name|currentFrame
operator|.
name|prefix
operator|+
name|currentFrame
operator|.
name|suffix
decl_stmt|;
if|if
condition|(
name|termLen
operator|<
name|commonSuffix
operator|.
name|length
condition|)
block|{
comment|// No match
name|isSubBlock
operator|=
name|popPushNext
argument_list|()
expr_stmt|;
continue|continue
name|nextTerm
continue|;
block|}
specifier|final
name|byte
index|[]
name|commonSuffixBytes
init|=
name|commonSuffix
operator|.
name|bytes
decl_stmt|;
specifier|final
name|int
name|lenInPrefix
init|=
name|commonSuffix
operator|.
name|length
operator|-
name|currentFrame
operator|.
name|suffix
decl_stmt|;
assert|assert
name|commonSuffix
operator|.
name|offset
operator|==
literal|0
assert|;
name|int
name|suffixBytesPos
decl_stmt|;
name|int
name|commonSuffixBytesPos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lenInPrefix
operator|>
literal|0
condition|)
block|{
comment|// A prefix of the common suffix overlaps with
comment|// the suffix of the block prefix so we first
comment|// test whether the prefix part matches:
specifier|final
name|byte
index|[]
name|termBytes
init|=
name|term
operator|.
name|bytes
decl_stmt|;
name|int
name|termBytesPos
init|=
name|currentFrame
operator|.
name|prefix
operator|-
name|lenInPrefix
decl_stmt|;
assert|assert
name|termBytesPos
operator|>=
literal|0
assert|;
specifier|final
name|int
name|termBytesPosEnd
init|=
name|currentFrame
operator|.
name|prefix
decl_stmt|;
while|while
condition|(
name|termBytesPos
operator|<
name|termBytesPosEnd
condition|)
block|{
if|if
condition|(
name|termBytes
index|[
name|termBytesPos
operator|++
index|]
operator|!=
name|commonSuffixBytes
index|[
name|commonSuffixBytesPos
operator|++
index|]
condition|)
block|{
name|isSubBlock
operator|=
name|popPushNext
argument_list|()
expr_stmt|;
continue|continue
name|nextTerm
continue|;
block|}
block|}
name|suffixBytesPos
operator|=
name|currentFrame
operator|.
name|startBytePos
expr_stmt|;
block|}
else|else
block|{
name|suffixBytesPos
operator|=
name|currentFrame
operator|.
name|startBytePos
operator|+
name|currentFrame
operator|.
name|suffix
operator|-
name|commonSuffix
operator|.
name|length
expr_stmt|;
block|}
comment|// Test overlapping suffix part:
specifier|final
name|int
name|commonSuffixBytesPosEnd
init|=
name|commonSuffix
operator|.
name|length
decl_stmt|;
while|while
condition|(
name|commonSuffixBytesPos
operator|<
name|commonSuffixBytesPosEnd
condition|)
block|{
if|if
condition|(
name|suffixBytes
index|[
name|suffixBytesPos
operator|++
index|]
operator|!=
name|commonSuffixBytes
index|[
name|commonSuffixBytesPos
operator|++
index|]
condition|)
block|{
name|isSubBlock
operator|=
name|popPushNext
argument_list|()
expr_stmt|;
continue|continue
name|nextTerm
continue|;
block|}
block|}
block|}
comment|// TODO: maybe we should do the same linear test
comment|// that AutomatonTermsEnum does, so that if we
comment|// reach a part of the automaton where .* is
comment|// "temporarily" accepted, we just blindly .next()
comment|// until the limit
comment|// See if the term suffix matches the automaton:
comment|// We know from above that the first byte in our suffix (label) matches
comment|// the current transition, so we step from the 2nd byte
comment|// in the suffix:
name|lastState
operator|=
name|currentFrame
operator|.
name|state
expr_stmt|;
name|state
operator|=
name|currentTransition
operator|.
name|dest
expr_stmt|;
name|int
name|end
init|=
name|currentFrame
operator|.
name|startBytePos
operator|+
name|currentFrame
operator|.
name|suffix
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
name|currentFrame
operator|.
name|startBytePos
operator|+
literal|1
init|;
name|idx
operator|<
name|end
condition|;
name|idx
operator|++
control|)
block|{
name|lastState
operator|=
name|state
expr_stmt|;
name|state
operator|=
name|runAutomaton
operator|.
name|step
argument_list|(
name|state
argument_list|,
name|suffixBytes
index|[
name|idx
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
operator|-
literal|1
condition|)
block|{
comment|// No match
name|isSubBlock
operator|=
name|popPushNext
argument_list|()
expr_stmt|;
continue|continue
name|nextTerm
continue|;
block|}
block|}
block|}
else|else
block|{
name|state
operator|=
name|currentFrame
operator|.
name|state
expr_stmt|;
name|lastState
operator|=
name|currentFrame
operator|.
name|lastState
expr_stmt|;
block|}
if|if
condition|(
name|isSubBlock
condition|)
block|{
comment|// Match!  Recurse:
name|copyTerm
argument_list|()
expr_stmt|;
name|currentFrame
operator|=
name|pushFrame
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|currentTransition
operator|=
name|currentFrame
operator|.
name|transition
expr_stmt|;
name|currentFrame
operator|.
name|lastState
operator|=
name|lastState
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentFrame
operator|.
name|isAutoPrefixTerm
condition|)
block|{
comment|// We are on an auto-prefix term, meaning this term was compiled
comment|// at indexing time, matching all terms sharing this prefix (or,
comment|// a floor'd subset of them if that count was too high).  A
comment|// prefix term represents a range of terms, so we now need to
comment|// test whether, from the current state in the automaton, it
comment|// accepts all terms in that range.  As long as it does, we can
comment|// use this term and then later skip ahead past all terms in
comment|// this range:
if|if
condition|(
name|allowAutoPrefixTerms
condition|)
block|{
if|if
condition|(
name|currentFrame
operator|.
name|floorSuffixLeadEnd
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Simple prefix case
name|useAutoPrefixTerm
operator|=
name|state
operator|==
name|sinkState
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currentFrame
operator|.
name|floorSuffixLeadStart
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Must also accept the empty string in this case
if|if
condition|(
name|automaton
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|useAutoPrefixTerm
operator|=
name|acceptsSuffixRange
argument_list|(
name|state
argument_list|,
literal|0
argument_list|,
name|currentFrame
operator|.
name|floorSuffixLeadEnd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|useAutoPrefixTerm
operator|=
name|acceptsSuffixRange
argument_list|(
name|lastState
argument_list|,
name|currentFrame
operator|.
name|floorSuffixLeadStart
argument_list|,
name|currentFrame
operator|.
name|floorSuffixLeadEnd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|useAutoPrefixTerm
condition|)
block|{
comment|// All suffixes of this auto-prefix term are accepted by the automaton, so we can use it:
name|copyTerm
argument_list|()
expr_stmt|;
name|currentFrame
operator|.
name|termState
operator|.
name|isRealTerm
operator|=
literal|false
expr_stmt|;
return|return
name|term
return|;
block|}
else|else
block|{
comment|// We move onto the next term
block|}
block|}
else|else
block|{
comment|// We are not allowed to use auto-prefix terms, so we just skip it
block|}
block|}
elseif|else
if|if
condition|(
name|runAutomaton
operator|.
name|isAccept
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|copyTerm
argument_list|()
expr_stmt|;
assert|assert
name|savedStartTerm
operator|==
literal|null
operator|||
name|term
operator|.
name|compareTo
argument_list|(
name|savedStartTerm
argument_list|)
operator|>
literal|0
operator|:
literal|"saveStartTerm="
operator|+
name|savedStartTerm
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" term="
operator|+
name|term
operator|.
name|utf8ToString
argument_list|()
assert|;
return|return
name|term
return|;
block|}
else|else
block|{
comment|// This term is a prefix of a term accepted by the automaton, but is not itself acceptd
block|}
name|isSubBlock
operator|=
name|popPushNext
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|scratchTransition
specifier|private
specifier|final
name|Transition
name|scratchTransition
init|=
operator|new
name|Transition
argument_list|()
decl_stmt|;
comment|/** Returns true if, from this state, the automaton accepts any suffix    *  starting with a label between start and end, inclusive.  We just    *  look for a transition, matching this range, to the sink state.  */
DECL|method|acceptsSuffixRange
specifier|private
name|boolean
name|acceptsSuffixRange
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|int
name|count
init|=
name|automaton
operator|.
name|initTransition
argument_list|(
name|state
argument_list|,
name|scratchTransition
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|automaton
operator|.
name|getNextTransition
argument_list|(
name|scratchTransition
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|>=
name|scratchTransition
operator|.
name|min
operator|&&
name|end
operator|<=
name|scratchTransition
operator|.
name|max
operator|&&
name|scratchTransition
operator|.
name|dest
operator|==
name|sinkState
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// for debugging
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
DECL|method|brToString
specifier|static
name|String
name|brToString
parameter_list|(
name|BytesRef
name|b
parameter_list|)
block|{
try|try
block|{
return|return
name|b
operator|.
name|utf8ToString
argument_list|()
operator|+
literal|" "
operator|+
name|b
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// If BytesRef isn't actually UTF8, or it's eg a
comment|// prefix of UTF8 that ends mid-unicode-char, we
comment|// fallback to hex:
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|method|copyTerm
specifier|private
name|void
name|copyTerm
parameter_list|()
block|{
specifier|final
name|int
name|len
init|=
name|currentFrame
operator|.
name|prefix
operator|+
name|currentFrame
operator|.
name|suffix
decl_stmt|;
if|if
condition|(
name|term
operator|.
name|bytes
operator|.
name|length
operator|<
name|len
condition|)
block|{
name|term
operator|.
name|bytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|currentFrame
operator|.
name|suffixBytes
argument_list|,
name|currentFrame
operator|.
name|startBytePos
argument_list|,
name|term
operator|.
name|bytes
argument_list|,
name|currentFrame
operator|.
name|prefix
argument_list|,
name|currentFrame
operator|.
name|suffix
argument_list|)
expr_stmt|;
name|term
operator|.
name|length
operator|=
name|len
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|boolean
name|seekExact
parameter_list|(
name|BytesRef
name|text
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|ord
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
name|BytesRef
name|text
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
end_class
end_unit
