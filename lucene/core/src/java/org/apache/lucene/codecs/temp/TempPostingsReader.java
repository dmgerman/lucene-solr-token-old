begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.temp
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|temp
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene41
operator|.
name|Lucene41PostingsFormat
operator|.
name|BLOCK_SIZE
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene41
operator|.
name|ForUtil
operator|.
name|MAX_DATA_SIZE
import|;
end_import
begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene41
operator|.
name|ForUtil
operator|.
name|MAX_ENCODED_SIZE
import|;
end_import
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|BlockTermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|CodecUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|TempPostingsReaderBase
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfos
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFileNames
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|DataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene41
operator|.
name|ForUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene41
operator|.
name|Lucene41SkipReader
import|;
end_import
begin_comment
comment|/**  * Concrete class that reads docId(maybe frq,pos,offset,payloads) list  * with postings format.  *  * @see Lucene41SkipReader for details  * @lucene.experimental  */
end_comment
begin_class
DECL|class|TempPostingsReader
specifier|public
specifier|final
class|class
name|TempPostingsReader
extends|extends
name|TempPostingsReaderBase
block|{
DECL|field|docIn
specifier|private
specifier|final
name|IndexInput
name|docIn
decl_stmt|;
DECL|field|posIn
specifier|private
specifier|final
name|IndexInput
name|posIn
decl_stmt|;
DECL|field|payIn
specifier|private
specifier|final
name|IndexInput
name|payIn
decl_stmt|;
DECL|field|forUtil
specifier|private
specifier|final
name|ForUtil
name|forUtil
decl_stmt|;
comment|// public static boolean DEBUG = false;
comment|/** Sole constructor. */
DECL|method|TempPostingsReader
specifier|public
name|TempPostingsReader
parameter_list|(
name|Directory
name|dir
parameter_list|,
name|FieldInfos
name|fieldInfos
parameter_list|,
name|SegmentInfo
name|segmentInfo
parameter_list|,
name|IOContext
name|ioContext
parameter_list|,
name|String
name|segmentSuffix
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|IndexInput
name|docIn
init|=
literal|null
decl_stmt|;
name|IndexInput
name|posIn
init|=
literal|null
decl_stmt|;
name|IndexInput
name|payIn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|docIn
operator|=
name|dir
operator|.
name|openInput
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segmentInfo
operator|.
name|name
argument_list|,
name|segmentSuffix
argument_list|,
name|TempBlockTreePostingsFormat
operator|.
name|DOC_EXTENSION
argument_list|)
argument_list|,
name|ioContext
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|docIn
argument_list|,
name|TempPostingsWriter
operator|.
name|DOC_CODEC
argument_list|,
name|TempPostingsWriter
operator|.
name|VERSION_CURRENT
argument_list|,
name|TempPostingsWriter
operator|.
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
name|forUtil
operator|=
operator|new
name|ForUtil
argument_list|(
name|docIn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldInfos
operator|.
name|hasProx
argument_list|()
condition|)
block|{
name|posIn
operator|=
name|dir
operator|.
name|openInput
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segmentInfo
operator|.
name|name
argument_list|,
name|segmentSuffix
argument_list|,
name|TempBlockTreePostingsFormat
operator|.
name|POS_EXTENSION
argument_list|)
argument_list|,
name|ioContext
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|posIn
argument_list|,
name|TempPostingsWriter
operator|.
name|POS_CODEC
argument_list|,
name|TempPostingsWriter
operator|.
name|VERSION_CURRENT
argument_list|,
name|TempPostingsWriter
operator|.
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldInfos
operator|.
name|hasPayloads
argument_list|()
operator|||
name|fieldInfos
operator|.
name|hasOffsets
argument_list|()
condition|)
block|{
name|payIn
operator|=
name|dir
operator|.
name|openInput
argument_list|(
name|IndexFileNames
operator|.
name|segmentFileName
argument_list|(
name|segmentInfo
operator|.
name|name
argument_list|,
name|segmentSuffix
argument_list|,
name|TempBlockTreePostingsFormat
operator|.
name|PAY_EXTENSION
argument_list|)
argument_list|,
name|ioContext
argument_list|)
expr_stmt|;
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|payIn
argument_list|,
name|TempPostingsWriter
operator|.
name|PAY_CODEC
argument_list|,
name|TempPostingsWriter
operator|.
name|VERSION_CURRENT
argument_list|,
name|TempPostingsWriter
operator|.
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|docIn
operator|=
name|docIn
expr_stmt|;
name|this
operator|.
name|posIn
operator|=
name|posIn
expr_stmt|;
name|this
operator|.
name|payIn
operator|=
name|payIn
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|docIn
argument_list|,
name|posIn
argument_list|,
name|payIn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|init
specifier|public
name|void
name|init
parameter_list|(
name|IndexInput
name|termsIn
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Make sure we are talking to the matching postings writer
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|termsIn
argument_list|,
name|TempPostingsWriter
operator|.
name|TERMS_CODEC
argument_list|,
name|TempPostingsWriter
operator|.
name|VERSION_CURRENT
argument_list|,
name|TempPostingsWriter
operator|.
name|VERSION_CURRENT
argument_list|)
expr_stmt|;
specifier|final
name|int
name|indexBlockSize
init|=
name|termsIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexBlockSize
operator|!=
name|BLOCK_SIZE
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"index-time BLOCK_SIZE ("
operator|+
name|indexBlockSize
operator|+
literal|") != read-time BLOCK_SIZE ("
operator|+
name|BLOCK_SIZE
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Read values that have been written using variable-length encoding instead of bit-packing.    */
DECL|method|readVIntBlock
specifier|static
name|void
name|readVIntBlock
parameter_list|(
name|IndexInput
name|docIn
parameter_list|,
name|int
index|[]
name|docBuffer
parameter_list|,
name|int
index|[]
name|freqBuffer
parameter_list|,
name|int
name|num
parameter_list|,
name|boolean
name|indexHasFreq
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|indexHasFreq
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|code
init|=
name|docIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|docBuffer
index|[
name|i
index|]
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|freqBuffer
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|freqBuffer
index|[
name|i
index|]
operator|=
name|docIn
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|docBuffer
index|[
name|i
index|]
operator|=
name|docIn
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// Must keep final because we do non-standard clone
DECL|class|IntBlockTermState
specifier|private
specifier|final
specifier|static
class|class
name|IntBlockTermState
extends|extends
name|BlockTermState
block|{
DECL|field|docStartFP
name|long
name|docStartFP
decl_stmt|;
DECL|field|posStartFP
name|long
name|posStartFP
decl_stmt|;
DECL|field|payStartFP
name|long
name|payStartFP
decl_stmt|;
DECL|field|skipOffset
name|long
name|skipOffset
decl_stmt|;
DECL|field|lastPosBlockOffset
name|long
name|lastPosBlockOffset
decl_stmt|;
comment|// docid when there is a single pulsed posting, otherwise -1
comment|// freq is always implicitly totalTermFreq in this case.
DECL|field|singletonDocID
name|int
name|singletonDocID
decl_stmt|;
annotation|@
name|Override
DECL|method|clone
specifier|public
name|IntBlockTermState
name|clone
parameter_list|()
block|{
name|IntBlockTermState
name|other
init|=
operator|new
name|IntBlockTermState
argument_list|()
decl_stmt|;
name|other
operator|.
name|copyFrom
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|other
return|;
block|}
annotation|@
name|Override
DECL|method|copyFrom
specifier|public
name|void
name|copyFrom
parameter_list|(
name|TermState
name|_other
parameter_list|)
block|{
name|super
operator|.
name|copyFrom
argument_list|(
name|_other
argument_list|)
expr_stmt|;
name|IntBlockTermState
name|other
init|=
operator|(
name|IntBlockTermState
operator|)
name|_other
decl_stmt|;
name|docStartFP
operator|=
name|other
operator|.
name|docStartFP
expr_stmt|;
name|posStartFP
operator|=
name|other
operator|.
name|posStartFP
expr_stmt|;
name|payStartFP
operator|=
name|other
operator|.
name|payStartFP
expr_stmt|;
name|lastPosBlockOffset
operator|=
name|other
operator|.
name|lastPosBlockOffset
expr_stmt|;
name|skipOffset
operator|=
name|other
operator|.
name|skipOffset
expr_stmt|;
name|singletonDocID
operator|=
name|other
operator|.
name|singletonDocID
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|" docStartFP="
operator|+
name|docStartFP
operator|+
literal|" posStartFP="
operator|+
name|posStartFP
operator|+
literal|" payStartFP="
operator|+
name|payStartFP
operator|+
literal|" lastPosBlockOffset="
operator|+
name|lastPosBlockOffset
operator|+
literal|" singletonDocID="
operator|+
name|singletonDocID
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|newTermState
specifier|public
name|IntBlockTermState
name|newTermState
parameter_list|()
block|{
return|return
operator|new
name|IntBlockTermState
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|docIn
argument_list|,
name|posIn
argument_list|,
name|payIn
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|decodeTerm
specifier|public
name|void
name|decodeTerm
parameter_list|(
name|long
index|[]
name|longs
parameter_list|,
name|DataInput
name|in
parameter_list|,
name|FieldInfo
name|fieldInfo
parameter_list|,
name|BlockTermState
name|_termState
parameter_list|,
name|boolean
name|absolute
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|IntBlockTermState
name|termState
init|=
operator|(
name|IntBlockTermState
operator|)
name|_termState
decl_stmt|;
specifier|final
name|boolean
name|fieldHasPositions
init|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|>=
literal|0
decl_stmt|;
specifier|final
name|boolean
name|fieldHasOffsets
init|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
decl_stmt|;
specifier|final
name|boolean
name|fieldHasPayloads
init|=
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
decl_stmt|;
if|if
condition|(
name|absolute
condition|)
block|{
name|termState
operator|.
name|docStartFP
operator|=
literal|0
expr_stmt|;
name|termState
operator|.
name|posStartFP
operator|=
literal|0
expr_stmt|;
name|termState
operator|.
name|payStartFP
operator|=
literal|0
expr_stmt|;
block|}
name|termState
operator|.
name|docStartFP
operator|+=
name|longs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|fieldHasPositions
condition|)
block|{
name|termState
operator|.
name|posStartFP
operator|+=
name|longs
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|fieldHasOffsets
operator|||
name|fieldHasPayloads
condition|)
block|{
name|termState
operator|.
name|payStartFP
operator|+=
name|longs
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|termState
operator|.
name|docFreq
operator|==
literal|1
condition|)
block|{
name|termState
operator|.
name|singletonDocID
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|termState
operator|.
name|singletonDocID
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fieldHasPositions
condition|)
block|{
if|if
condition|(
name|termState
operator|.
name|totalTermFreq
operator|>
name|BLOCK_SIZE
condition|)
block|{
name|termState
operator|.
name|lastPosBlockOffset
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|termState
operator|.
name|lastPosBlockOffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|termState
operator|.
name|docFreq
operator|>
name|BLOCK_SIZE
condition|)
block|{
name|termState
operator|.
name|skipOffset
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|termState
operator|.
name|skipOffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|BlockTermState
name|termState
parameter_list|,
name|Bits
name|liveDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockDocsEnum
name|docsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|instanceof
name|BlockDocsEnum
condition|)
block|{
name|docsEnum
operator|=
operator|(
name|BlockDocsEnum
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
operator|!
name|docsEnum
operator|.
name|canReuse
argument_list|(
name|docIn
argument_list|,
name|fieldInfo
argument_list|)
condition|)
block|{
name|docsEnum
operator|=
operator|new
name|BlockDocsEnum
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|docsEnum
operator|=
operator|new
name|BlockDocsEnum
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|docsEnum
operator|.
name|reset
argument_list|(
name|liveDocs
argument_list|,
operator|(
name|IntBlockTermState
operator|)
name|termState
argument_list|,
name|flags
argument_list|)
return|;
block|}
comment|// TODO: specialize to liveDocs vs not
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|,
name|BlockTermState
name|termState
parameter_list|,
name|Bits
name|liveDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|indexHasOffsets
init|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
decl_stmt|;
name|boolean
name|indexHasPayloads
init|=
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|indexHasOffsets
operator|||
operator|(
name|flags
operator|&
name|DocsAndPositionsEnum
operator|.
name|FLAG_OFFSETS
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|indexHasPayloads
operator|||
operator|(
name|flags
operator|&
name|DocsAndPositionsEnum
operator|.
name|FLAG_PAYLOADS
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|BlockDocsAndPositionsEnum
name|docsAndPositionsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|instanceof
name|BlockDocsAndPositionsEnum
condition|)
block|{
name|docsAndPositionsEnum
operator|=
operator|(
name|BlockDocsAndPositionsEnum
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
operator|!
name|docsAndPositionsEnum
operator|.
name|canReuse
argument_list|(
name|docIn
argument_list|,
name|fieldInfo
argument_list|)
condition|)
block|{
name|docsAndPositionsEnum
operator|=
operator|new
name|BlockDocsAndPositionsEnum
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|docsAndPositionsEnum
operator|=
operator|new
name|BlockDocsAndPositionsEnum
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|docsAndPositionsEnum
operator|.
name|reset
argument_list|(
name|liveDocs
argument_list|,
operator|(
name|IntBlockTermState
operator|)
name|termState
argument_list|)
return|;
block|}
else|else
block|{
name|EverythingEnum
name|everythingEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|instanceof
name|EverythingEnum
condition|)
block|{
name|everythingEnum
operator|=
operator|(
name|EverythingEnum
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
operator|!
name|everythingEnum
operator|.
name|canReuse
argument_list|(
name|docIn
argument_list|,
name|fieldInfo
argument_list|)
condition|)
block|{
name|everythingEnum
operator|=
operator|new
name|EverythingEnum
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|everythingEnum
operator|=
operator|new
name|EverythingEnum
argument_list|(
name|fieldInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|everythingEnum
operator|.
name|reset
argument_list|(
name|liveDocs
argument_list|,
operator|(
name|IntBlockTermState
operator|)
name|termState
argument_list|,
name|flags
argument_list|)
return|;
block|}
block|}
DECL|class|BlockDocsEnum
specifier|final
class|class
name|BlockDocsEnum
extends|extends
name|DocsEnum
block|{
DECL|field|encoded
specifier|private
specifier|final
name|byte
index|[]
name|encoded
decl_stmt|;
DECL|field|docDeltaBuffer
specifier|private
specifier|final
name|int
index|[]
name|docDeltaBuffer
init|=
operator|new
name|int
index|[
name|MAX_DATA_SIZE
index|]
decl_stmt|;
DECL|field|freqBuffer
specifier|private
specifier|final
name|int
index|[]
name|freqBuffer
init|=
operator|new
name|int
index|[
name|MAX_DATA_SIZE
index|]
decl_stmt|;
DECL|field|docBufferUpto
specifier|private
name|int
name|docBufferUpto
decl_stmt|;
DECL|field|skipper
specifier|private
name|Lucene41SkipReader
name|skipper
decl_stmt|;
DECL|field|skipped
specifier|private
name|boolean
name|skipped
decl_stmt|;
DECL|field|startDocIn
specifier|final
name|IndexInput
name|startDocIn
decl_stmt|;
DECL|field|docIn
name|IndexInput
name|docIn
decl_stmt|;
DECL|field|indexHasFreq
specifier|final
name|boolean
name|indexHasFreq
decl_stmt|;
DECL|field|indexHasPos
specifier|final
name|boolean
name|indexHasPos
decl_stmt|;
DECL|field|indexHasOffsets
specifier|final
name|boolean
name|indexHasOffsets
decl_stmt|;
DECL|field|indexHasPayloads
specifier|final
name|boolean
name|indexHasPayloads
decl_stmt|;
DECL|field|docFreq
specifier|private
name|int
name|docFreq
decl_stmt|;
comment|// number of docs in this posting list
DECL|field|totalTermFreq
specifier|private
name|long
name|totalTermFreq
decl_stmt|;
comment|// sum of freqs in this posting list (or docFreq when omitted)
DECL|field|docUpto
specifier|private
name|int
name|docUpto
decl_stmt|;
comment|// how many docs we've read
DECL|field|doc
specifier|private
name|int
name|doc
decl_stmt|;
comment|// doc we last read
DECL|field|accum
specifier|private
name|int
name|accum
decl_stmt|;
comment|// accumulator for doc deltas
DECL|field|freq
specifier|private
name|int
name|freq
decl_stmt|;
comment|// freq we last read
comment|// Where this term's postings start in the .doc file:
DECL|field|docTermStartFP
specifier|private
name|long
name|docTermStartFP
decl_stmt|;
comment|// Where this term's skip data starts (after
comment|// docTermStartFP) in the .doc file (or -1 if there is
comment|// no skip data for this term):
DECL|field|skipOffset
specifier|private
name|long
name|skipOffset
decl_stmt|;
comment|// docID for next skip point, we won't use skipper if
comment|// target docID is not larger than this
DECL|field|nextSkipDoc
specifier|private
name|int
name|nextSkipDoc
decl_stmt|;
DECL|field|liveDocs
specifier|private
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|needsFreq
specifier|private
name|boolean
name|needsFreq
decl_stmt|;
comment|// true if the caller actually needs frequencies
DECL|field|singletonDocID
specifier|private
name|int
name|singletonDocID
decl_stmt|;
comment|// docid when there is a single pulsed posting, otherwise -1
DECL|method|BlockDocsEnum
specifier|public
name|BlockDocsEnum
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|startDocIn
operator|=
name|TempPostingsReader
operator|.
name|this
operator|.
name|docIn
expr_stmt|;
name|this
operator|.
name|docIn
operator|=
literal|null
expr_stmt|;
name|indexHasFreq
operator|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS
argument_list|)
operator|>=
literal|0
expr_stmt|;
name|indexHasPos
operator|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|>=
literal|0
expr_stmt|;
name|indexHasOffsets
operator|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
expr_stmt|;
name|indexHasPayloads
operator|=
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
expr_stmt|;
name|encoded
operator|=
operator|new
name|byte
index|[
name|MAX_ENCODED_SIZE
index|]
expr_stmt|;
block|}
DECL|method|canReuse
specifier|public
name|boolean
name|canReuse
parameter_list|(
name|IndexInput
name|docIn
parameter_list|,
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
return|return
name|docIn
operator|==
name|startDocIn
operator|&&
name|indexHasFreq
operator|==
operator|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
name|indexHasPos
operator|==
operator|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
name|indexHasPayloads
operator|==
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
return|;
block|}
DECL|method|reset
specifier|public
name|DocsEnum
name|reset
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|IntBlockTermState
name|termState
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  FPR.reset: termState=" + termState);
comment|// }
name|docFreq
operator|=
name|termState
operator|.
name|docFreq
expr_stmt|;
name|totalTermFreq
operator|=
name|indexHasFreq
condition|?
name|termState
operator|.
name|totalTermFreq
else|:
name|docFreq
expr_stmt|;
name|docTermStartFP
operator|=
name|termState
operator|.
name|docStartFP
expr_stmt|;
name|skipOffset
operator|=
name|termState
operator|.
name|skipOffset
expr_stmt|;
name|singletonDocID
operator|=
name|termState
operator|.
name|singletonDocID
expr_stmt|;
if|if
condition|(
name|docFreq
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|docIn
operator|==
literal|null
condition|)
block|{
comment|// lazy init
name|docIn
operator|=
name|startDocIn
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
name|docIn
operator|.
name|seek
argument_list|(
name|docTermStartFP
argument_list|)
expr_stmt|;
block|}
name|doc
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|needsFreq
operator|=
operator|(
name|flags
operator|&
name|DocsEnum
operator|.
name|FLAG_FREQS
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|indexHasFreq
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|freqBuffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|accum
operator|=
literal|0
expr_stmt|;
name|docUpto
operator|=
literal|0
expr_stmt|;
name|nextSkipDoc
operator|=
name|BLOCK_SIZE
operator|-
literal|1
expr_stmt|;
comment|// we won't skip if target is found in first block
name|docBufferUpto
operator|=
name|BLOCK_SIZE
expr_stmt|;
name|skipped
operator|=
literal|false
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|freq
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
DECL|method|refillDocs
specifier|private
name|void
name|refillDocs
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|left
init|=
name|docFreq
operator|-
name|docUpto
decl_stmt|;
assert|assert
name|left
operator|>
literal|0
assert|;
if|if
condition|(
name|left
operator|>=
name|BLOCK_SIZE
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    fill doc block from fp=" + docIn.getFilePointer());
comment|// }
name|forUtil
operator|.
name|readBlock
argument_list|(
name|docIn
argument_list|,
name|encoded
argument_list|,
name|docDeltaBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexHasFreq
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    fill freq block from fp=" + docIn.getFilePointer());
comment|// }
if|if
condition|(
name|needsFreq
condition|)
block|{
name|forUtil
operator|.
name|readBlock
argument_list|(
name|docIn
argument_list|,
name|encoded
argument_list|,
name|freqBuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|forUtil
operator|.
name|skipBlock
argument_list|(
name|docIn
argument_list|)
expr_stmt|;
comment|// skip over freqs
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|docFreq
operator|==
literal|1
condition|)
block|{
name|docDeltaBuffer
index|[
literal|0
index|]
operator|=
name|singletonDocID
expr_stmt|;
name|freqBuffer
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|totalTermFreq
expr_stmt|;
block|}
else|else
block|{
comment|// Read vInts:
comment|// if (DEBUG) {
comment|//   System.out.println("    fill last vInt block from fp=" + docIn.getFilePointer());
comment|// }
name|readVIntBlock
argument_list|(
name|docIn
argument_list|,
name|docDeltaBuffer
argument_list|,
name|freqBuffer
argument_list|,
name|left
argument_list|,
name|indexHasFreq
argument_list|)
expr_stmt|;
block|}
name|docBufferUpto
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("\nFPR.nextDoc");
comment|// }
while|while
condition|(
literal|true
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  docUpto=" + docUpto + " (of df=" + docFreq + ") docBufferUpto=" + docBufferUpto);
comment|// }
if|if
condition|(
name|docUpto
operator|==
name|docFreq
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  return doc=END");
comment|// }
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
if|if
condition|(
name|docBufferUpto
operator|==
name|BLOCK_SIZE
condition|)
block|{
name|refillDocs
argument_list|()
expr_stmt|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto + "]=" + docDeltaBuffer[docBufferUpto]);
comment|// }
name|accum
operator|+=
name|docDeltaBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|docUpto
operator|++
expr_stmt|;
if|if
condition|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
name|accum
argument_list|)
condition|)
block|{
name|doc
operator|=
name|accum
expr_stmt|;
name|freq
operator|=
name|freqBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|docBufferUpto
operator|++
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  return doc=" + doc + " freq=" + freq);
comment|// }
return|return
name|doc
return|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("  doc=" + accum + " is deleted; try next doc");
comment|// }
name|docBufferUpto
operator|++
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: make frq block load lazy/skippable
comment|// if (DEBUG) {
comment|//   System.out.println("  FPR.advance target=" + target);
comment|// }
comment|// current skip docID< docIDs generated from current buffer<= next skip docID
comment|// we don't need to skip if target is buffered already
if|if
condition|(
name|docFreq
operator|>
name|BLOCK_SIZE
operator|&&
name|target
operator|>
name|nextSkipDoc
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("load skipper");
comment|// }
if|if
condition|(
name|skipper
operator|==
literal|null
condition|)
block|{
comment|// Lazy init: first time this enum has ever been used for skipping
name|skipper
operator|=
operator|new
name|Lucene41SkipReader
argument_list|(
name|docIn
operator|.
name|clone
argument_list|()
argument_list|,
name|TempPostingsWriter
operator|.
name|maxSkipLevels
argument_list|,
name|BLOCK_SIZE
argument_list|,
name|indexHasPos
argument_list|,
name|indexHasOffsets
argument_list|,
name|indexHasPayloads
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skipped
condition|)
block|{
assert|assert
name|skipOffset
operator|!=
operator|-
literal|1
assert|;
comment|// This is the first time this enum has skipped
comment|// since reset() was called; load the skip data:
name|skipper
operator|.
name|init
argument_list|(
name|docTermStartFP
operator|+
name|skipOffset
argument_list|,
name|docTermStartFP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|docFreq
argument_list|)
expr_stmt|;
name|skipped
operator|=
literal|true
expr_stmt|;
block|}
comment|// always plus one to fix the result, since skip position in Lucene41SkipReader
comment|// is a little different from MultiLevelSkipListReader
specifier|final
name|int
name|newDocUpto
init|=
name|skipper
operator|.
name|skipTo
argument_list|(
name|target
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|newDocUpto
operator|>
name|docUpto
condition|)
block|{
comment|// Skipper moved
comment|// if (DEBUG) {
comment|//   System.out.println("skipper moved to docUpto=" + newDocUpto + " vs current=" + docUpto + "; docID=" + skipper.getDoc() + " fp=" + skipper.getDocPointer());
comment|// }
assert|assert
name|newDocUpto
operator|%
name|BLOCK_SIZE
operator|==
literal|0
operator|:
literal|"got "
operator|+
name|newDocUpto
assert|;
name|docUpto
operator|=
name|newDocUpto
expr_stmt|;
comment|// Force to read next block
name|docBufferUpto
operator|=
name|BLOCK_SIZE
expr_stmt|;
name|accum
operator|=
name|skipper
operator|.
name|getDoc
argument_list|()
expr_stmt|;
comment|// actually, this is just lastSkipEntry
name|docIn
operator|.
name|seek
argument_list|(
name|skipper
operator|.
name|getDocPointer
argument_list|()
argument_list|)
expr_stmt|;
comment|// now point to the block we want to search
block|}
comment|// next time we call advance, this is used to
comment|// foresee whether skipper is necessary.
name|nextSkipDoc
operator|=
name|skipper
operator|.
name|getNextSkipDoc
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|docUpto
operator|==
name|docFreq
condition|)
block|{
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
if|if
condition|(
name|docBufferUpto
operator|==
name|BLOCK_SIZE
condition|)
block|{
name|refillDocs
argument_list|()
expr_stmt|;
block|}
comment|// Now scan... this is an inlined/pared down version
comment|// of nextDoc():
while|while
condition|(
literal|true
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  scan doc=" + accum + " docBufferUpto=" + docBufferUpto);
comment|// }
name|accum
operator|+=
name|docDeltaBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|docUpto
operator|++
expr_stmt|;
if|if
condition|(
name|accum
operator|>=
name|target
condition|)
block|{
break|break;
block|}
name|docBufferUpto
operator|++
expr_stmt|;
if|if
condition|(
name|docUpto
operator|==
name|docFreq
condition|)
block|{
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
block|}
if|if
condition|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
name|accum
argument_list|)
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  return doc=" + accum);
comment|// }
name|freq
operator|=
name|freqBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|docBufferUpto
operator|++
expr_stmt|;
return|return
name|doc
operator|=
name|accum
return|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  now do nextDoc()");
comment|// }
name|docBufferUpto
operator|++
expr_stmt|;
return|return
name|nextDoc
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|docFreq
return|;
block|}
block|}
DECL|class|BlockDocsAndPositionsEnum
specifier|final
class|class
name|BlockDocsAndPositionsEnum
extends|extends
name|DocsAndPositionsEnum
block|{
DECL|field|encoded
specifier|private
specifier|final
name|byte
index|[]
name|encoded
decl_stmt|;
DECL|field|docDeltaBuffer
specifier|private
specifier|final
name|int
index|[]
name|docDeltaBuffer
init|=
operator|new
name|int
index|[
name|MAX_DATA_SIZE
index|]
decl_stmt|;
DECL|field|freqBuffer
specifier|private
specifier|final
name|int
index|[]
name|freqBuffer
init|=
operator|new
name|int
index|[
name|MAX_DATA_SIZE
index|]
decl_stmt|;
DECL|field|posDeltaBuffer
specifier|private
specifier|final
name|int
index|[]
name|posDeltaBuffer
init|=
operator|new
name|int
index|[
name|MAX_DATA_SIZE
index|]
decl_stmt|;
DECL|field|docBufferUpto
specifier|private
name|int
name|docBufferUpto
decl_stmt|;
DECL|field|posBufferUpto
specifier|private
name|int
name|posBufferUpto
decl_stmt|;
DECL|field|skipper
specifier|private
name|Lucene41SkipReader
name|skipper
decl_stmt|;
DECL|field|skipped
specifier|private
name|boolean
name|skipped
decl_stmt|;
DECL|field|startDocIn
specifier|final
name|IndexInput
name|startDocIn
decl_stmt|;
DECL|field|docIn
name|IndexInput
name|docIn
decl_stmt|;
DECL|field|posIn
specifier|final
name|IndexInput
name|posIn
decl_stmt|;
DECL|field|indexHasOffsets
specifier|final
name|boolean
name|indexHasOffsets
decl_stmt|;
DECL|field|indexHasPayloads
specifier|final
name|boolean
name|indexHasPayloads
decl_stmt|;
DECL|field|docFreq
specifier|private
name|int
name|docFreq
decl_stmt|;
comment|// number of docs in this posting list
DECL|field|totalTermFreq
specifier|private
name|long
name|totalTermFreq
decl_stmt|;
comment|// number of positions in this posting list
DECL|field|docUpto
specifier|private
name|int
name|docUpto
decl_stmt|;
comment|// how many docs we've read
DECL|field|doc
specifier|private
name|int
name|doc
decl_stmt|;
comment|// doc we last read
DECL|field|accum
specifier|private
name|int
name|accum
decl_stmt|;
comment|// accumulator for doc deltas
DECL|field|freq
specifier|private
name|int
name|freq
decl_stmt|;
comment|// freq we last read
DECL|field|position
specifier|private
name|int
name|position
decl_stmt|;
comment|// current position
comment|// how many positions "behind" we are; nextPosition must
comment|// skip these to "catch up":
DECL|field|posPendingCount
specifier|private
name|int
name|posPendingCount
decl_stmt|;
comment|// Lazy pos seek: if != -1 then we must seek to this FP
comment|// before reading positions:
DECL|field|posPendingFP
specifier|private
name|long
name|posPendingFP
decl_stmt|;
comment|// Where this term's postings start in the .doc file:
DECL|field|docTermStartFP
specifier|private
name|long
name|docTermStartFP
decl_stmt|;
comment|// Where this term's postings start in the .pos file:
DECL|field|posTermStartFP
specifier|private
name|long
name|posTermStartFP
decl_stmt|;
comment|// Where this term's payloads/offsets start in the .pay
comment|// file:
DECL|field|payTermStartFP
specifier|private
name|long
name|payTermStartFP
decl_stmt|;
comment|// File pointer where the last (vInt encoded) pos delta
comment|// block is.  We need this to know whether to bulk
comment|// decode vs vInt decode the block:
DECL|field|lastPosBlockFP
specifier|private
name|long
name|lastPosBlockFP
decl_stmt|;
comment|// Where this term's skip data starts (after
comment|// docTermStartFP) in the .doc file (or -1 if there is
comment|// no skip data for this term):
DECL|field|skipOffset
specifier|private
name|long
name|skipOffset
decl_stmt|;
DECL|field|nextSkipDoc
specifier|private
name|int
name|nextSkipDoc
decl_stmt|;
DECL|field|liveDocs
specifier|private
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|singletonDocID
specifier|private
name|int
name|singletonDocID
decl_stmt|;
comment|// docid when there is a single pulsed posting, otherwise -1
DECL|method|BlockDocsAndPositionsEnum
specifier|public
name|BlockDocsAndPositionsEnum
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|startDocIn
operator|=
name|TempPostingsReader
operator|.
name|this
operator|.
name|docIn
expr_stmt|;
name|this
operator|.
name|docIn
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|posIn
operator|=
name|TempPostingsReader
operator|.
name|this
operator|.
name|posIn
operator|.
name|clone
argument_list|()
expr_stmt|;
name|encoded
operator|=
operator|new
name|byte
index|[
name|MAX_ENCODED_SIZE
index|]
expr_stmt|;
name|indexHasOffsets
operator|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
expr_stmt|;
name|indexHasPayloads
operator|=
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
expr_stmt|;
block|}
DECL|method|canReuse
specifier|public
name|boolean
name|canReuse
parameter_list|(
name|IndexInput
name|docIn
parameter_list|,
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
return|return
name|docIn
operator|==
name|startDocIn
operator|&&
name|indexHasOffsets
operator|==
operator|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
name|indexHasPayloads
operator|==
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
return|;
block|}
DECL|method|reset
specifier|public
name|DocsAndPositionsEnum
name|reset
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|IntBlockTermState
name|termState
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  FPR.reset: termState=" + termState);
comment|// }
name|docFreq
operator|=
name|termState
operator|.
name|docFreq
expr_stmt|;
name|docTermStartFP
operator|=
name|termState
operator|.
name|docStartFP
expr_stmt|;
name|posTermStartFP
operator|=
name|termState
operator|.
name|posStartFP
expr_stmt|;
name|payTermStartFP
operator|=
name|termState
operator|.
name|payStartFP
expr_stmt|;
name|skipOffset
operator|=
name|termState
operator|.
name|skipOffset
expr_stmt|;
name|totalTermFreq
operator|=
name|termState
operator|.
name|totalTermFreq
expr_stmt|;
name|singletonDocID
operator|=
name|termState
operator|.
name|singletonDocID
expr_stmt|;
if|if
condition|(
name|docFreq
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|docIn
operator|==
literal|null
condition|)
block|{
comment|// lazy init
name|docIn
operator|=
name|startDocIn
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
name|docIn
operator|.
name|seek
argument_list|(
name|docTermStartFP
argument_list|)
expr_stmt|;
block|}
name|posPendingFP
operator|=
name|posTermStartFP
expr_stmt|;
name|posPendingCount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|termState
operator|.
name|totalTermFreq
operator|<
name|BLOCK_SIZE
condition|)
block|{
name|lastPosBlockFP
operator|=
name|posTermStartFP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|termState
operator|.
name|totalTermFreq
operator|==
name|BLOCK_SIZE
condition|)
block|{
name|lastPosBlockFP
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lastPosBlockFP
operator|=
name|posTermStartFP
operator|+
name|termState
operator|.
name|lastPosBlockOffset
expr_stmt|;
block|}
name|doc
operator|=
operator|-
literal|1
expr_stmt|;
name|accum
operator|=
literal|0
expr_stmt|;
name|docUpto
operator|=
literal|0
expr_stmt|;
name|nextSkipDoc
operator|=
name|BLOCK_SIZE
operator|-
literal|1
expr_stmt|;
name|docBufferUpto
operator|=
name|BLOCK_SIZE
expr_stmt|;
name|skipped
operator|=
literal|false
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|freq
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
DECL|method|refillDocs
specifier|private
name|void
name|refillDocs
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|left
init|=
name|docFreq
operator|-
name|docUpto
decl_stmt|;
assert|assert
name|left
operator|>
literal|0
assert|;
if|if
condition|(
name|left
operator|>=
name|BLOCK_SIZE
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    fill doc block from fp=" + docIn.getFilePointer());
comment|// }
name|forUtil
operator|.
name|readBlock
argument_list|(
name|docIn
argument_list|,
name|encoded
argument_list|,
name|docDeltaBuffer
argument_list|)
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("    fill freq block from fp=" + docIn.getFilePointer());
comment|// }
name|forUtil
operator|.
name|readBlock
argument_list|(
name|docIn
argument_list|,
name|encoded
argument_list|,
name|freqBuffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|docFreq
operator|==
literal|1
condition|)
block|{
name|docDeltaBuffer
index|[
literal|0
index|]
operator|=
name|singletonDocID
expr_stmt|;
name|freqBuffer
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|totalTermFreq
expr_stmt|;
block|}
else|else
block|{
comment|// Read vInts:
comment|// if (DEBUG) {
comment|//   System.out.println("    fill last vInt doc block from fp=" + docIn.getFilePointer());
comment|// }
name|readVIntBlock
argument_list|(
name|docIn
argument_list|,
name|docDeltaBuffer
argument_list|,
name|freqBuffer
argument_list|,
name|left
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|docBufferUpto
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|refillPositions
specifier|private
name|void
name|refillPositions
parameter_list|()
throws|throws
name|IOException
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("      refillPositions");
comment|// }
if|if
condition|(
name|posIn
operator|.
name|getFilePointer
argument_list|()
operator|==
name|lastPosBlockFP
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("        vInt pos block @ fp=" + posIn.getFilePointer() + " hasPayloads=" + indexHasPayloads + " hasOffsets=" + indexHasOffsets);
comment|// }
specifier|final
name|int
name|count
init|=
call|(
name|int
call|)
argument_list|(
name|totalTermFreq
operator|%
name|BLOCK_SIZE
argument_list|)
decl_stmt|;
name|int
name|payloadLength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|code
init|=
name|posIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|payloadLength
operator|=
name|posIn
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
name|posDeltaBuffer
index|[
name|i
index|]
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
if|if
condition|(
name|payloadLength
operator|!=
literal|0
condition|)
block|{
name|posIn
operator|.
name|seek
argument_list|(
name|posIn
operator|.
name|getFilePointer
argument_list|()
operator|+
name|payloadLength
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|posDeltaBuffer
index|[
name|i
index|]
operator|=
name|code
expr_stmt|;
block|}
if|if
condition|(
name|indexHasOffsets
condition|)
block|{
if|if
condition|(
operator|(
name|posIn
operator|.
name|readVInt
argument_list|()
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// offset length changed
name|posIn
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("        bulk pos block @ fp=" + posIn.getFilePointer());
comment|// }
name|forUtil
operator|.
name|readBlock
argument_list|(
name|posIn
argument_list|,
name|encoded
argument_list|,
name|posDeltaBuffer
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  FPR.nextDoc");
comment|// }
while|while
condition|(
literal|true
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    docUpto=" + docUpto + " (of df=" + docFreq + ") docBufferUpto=" + docBufferUpto);
comment|// }
if|if
condition|(
name|docUpto
operator|==
name|docFreq
condition|)
block|{
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
if|if
condition|(
name|docBufferUpto
operator|==
name|BLOCK_SIZE
condition|)
block|{
name|refillDocs
argument_list|()
expr_stmt|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto + "]=" + docDeltaBuffer[docBufferUpto]);
comment|// }
name|accum
operator|+=
name|docDeltaBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|freq
operator|=
name|freqBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|posPendingCount
operator|+=
name|freq
expr_stmt|;
name|docBufferUpto
operator|++
expr_stmt|;
name|docUpto
operator|++
expr_stmt|;
if|if
condition|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
name|accum
argument_list|)
condition|)
block|{
name|doc
operator|=
name|accum
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("    return doc=" + doc + " freq=" + freq + " posPendingCount=" + posPendingCount);
comment|// }
return|return
name|doc
return|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("    doc=" + accum + " is deleted; try next doc");
comment|// }
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: make frq block load lazy/skippable
comment|// if (DEBUG) {
comment|//   System.out.println("  FPR.advance target=" + target);
comment|// }
if|if
condition|(
name|docFreq
operator|>
name|BLOCK_SIZE
operator|&&
name|target
operator|>
name|nextSkipDoc
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    try skipper");
comment|// }
if|if
condition|(
name|skipper
operator|==
literal|null
condition|)
block|{
comment|// Lazy init: first time this enum has ever been used for skipping
comment|// if (DEBUG) {
comment|//   System.out.println("    create skipper");
comment|// }
name|skipper
operator|=
operator|new
name|Lucene41SkipReader
argument_list|(
name|docIn
operator|.
name|clone
argument_list|()
argument_list|,
name|TempPostingsWriter
operator|.
name|maxSkipLevels
argument_list|,
name|BLOCK_SIZE
argument_list|,
literal|true
argument_list|,
name|indexHasOffsets
argument_list|,
name|indexHasPayloads
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skipped
condition|)
block|{
assert|assert
name|skipOffset
operator|!=
operator|-
literal|1
assert|;
comment|// This is the first time this enum has skipped
comment|// since reset() was called; load the skip data:
comment|// if (DEBUG) {
comment|//   System.out.println("    init skipper");
comment|// }
name|skipper
operator|.
name|init
argument_list|(
name|docTermStartFP
operator|+
name|skipOffset
argument_list|,
name|docTermStartFP
argument_list|,
name|posTermStartFP
argument_list|,
name|payTermStartFP
argument_list|,
name|docFreq
argument_list|)
expr_stmt|;
name|skipped
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|int
name|newDocUpto
init|=
name|skipper
operator|.
name|skipTo
argument_list|(
name|target
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|newDocUpto
operator|>
name|docUpto
condition|)
block|{
comment|// Skipper moved
comment|// if (DEBUG) {
comment|//   System.out.println("    skipper moved to docUpto=" + newDocUpto + " vs current=" + docUpto + "; docID=" + skipper.getDoc() + " fp=" + skipper.getDocPointer() + " pos.fp=" + skipper.getPosPointer() + " pos.bufferUpto=" + skipper.getPosBufferUpto());
comment|// }
assert|assert
name|newDocUpto
operator|%
name|BLOCK_SIZE
operator|==
literal|0
operator|:
literal|"got "
operator|+
name|newDocUpto
assert|;
name|docUpto
operator|=
name|newDocUpto
expr_stmt|;
comment|// Force to read next block
name|docBufferUpto
operator|=
name|BLOCK_SIZE
expr_stmt|;
name|accum
operator|=
name|skipper
operator|.
name|getDoc
argument_list|()
expr_stmt|;
name|docIn
operator|.
name|seek
argument_list|(
name|skipper
operator|.
name|getDocPointer
argument_list|()
argument_list|)
expr_stmt|;
name|posPendingFP
operator|=
name|skipper
operator|.
name|getPosPointer
argument_list|()
expr_stmt|;
name|posPendingCount
operator|=
name|skipper
operator|.
name|getPosBufferUpto
argument_list|()
expr_stmt|;
block|}
name|nextSkipDoc
operator|=
name|skipper
operator|.
name|getNextSkipDoc
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|docUpto
operator|==
name|docFreq
condition|)
block|{
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
if|if
condition|(
name|docBufferUpto
operator|==
name|BLOCK_SIZE
condition|)
block|{
name|refillDocs
argument_list|()
expr_stmt|;
block|}
comment|// Now scan... this is an inlined/pared down version
comment|// of nextDoc():
while|while
condition|(
literal|true
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  scan doc=" + accum + " docBufferUpto=" + docBufferUpto);
comment|// }
name|accum
operator|+=
name|docDeltaBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|freq
operator|=
name|freqBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|posPendingCount
operator|+=
name|freq
expr_stmt|;
name|docBufferUpto
operator|++
expr_stmt|;
name|docUpto
operator|++
expr_stmt|;
if|if
condition|(
name|accum
operator|>=
name|target
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|docUpto
operator|==
name|docFreq
condition|)
block|{
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
block|}
if|if
condition|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
name|accum
argument_list|)
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  return doc=" + accum);
comment|// }
name|position
operator|=
literal|0
expr_stmt|;
return|return
name|doc
operator|=
name|accum
return|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  now do nextDoc()");
comment|// }
return|return
name|nextDoc
argument_list|()
return|;
block|}
block|}
comment|// TODO: in theory we could avoid loading frq block
comment|// when not needed, ie, use skip data to load how far to
comment|// seek the pos pointer ... instead of having to load frq
comment|// blocks only to sum up how many positions to skip
DECL|method|skipPositions
specifier|private
name|void
name|skipPositions
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Skip positions now:
name|int
name|toSkip
init|=
name|posPendingCount
operator|-
name|freq
decl_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("      FPR.skipPositions: toSkip=" + toSkip);
comment|// }
specifier|final
name|int
name|leftInBlock
init|=
name|BLOCK_SIZE
operator|-
name|posBufferUpto
decl_stmt|;
if|if
condition|(
name|toSkip
operator|<
name|leftInBlock
condition|)
block|{
name|posBufferUpto
operator|+=
name|toSkip
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("        skip w/in block to posBufferUpto=" + posBufferUpto);
comment|// }
block|}
else|else
block|{
name|toSkip
operator|-=
name|leftInBlock
expr_stmt|;
while|while
condition|(
name|toSkip
operator|>=
name|BLOCK_SIZE
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("        skip whole block @ fp=" + posIn.getFilePointer());
comment|// }
assert|assert
name|posIn
operator|.
name|getFilePointer
argument_list|()
operator|!=
name|lastPosBlockFP
assert|;
name|forUtil
operator|.
name|skipBlock
argument_list|(
name|posIn
argument_list|)
expr_stmt|;
name|toSkip
operator|-=
name|BLOCK_SIZE
expr_stmt|;
block|}
name|refillPositions
argument_list|()
expr_stmt|;
name|posBufferUpto
operator|=
name|toSkip
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("        skip w/in block to posBufferUpto=" + posBufferUpto);
comment|// }
block|}
name|position
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|nextPosition
specifier|public
name|int
name|nextPosition
parameter_list|()
throws|throws
name|IOException
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    FPR.nextPosition posPendingCount=" + posPendingCount + " posBufferUpto=" + posBufferUpto);
comment|// }
if|if
condition|(
name|posPendingFP
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("      seek to pendingFP=" + posPendingFP);
comment|// }
name|posIn
operator|.
name|seek
argument_list|(
name|posPendingFP
argument_list|)
expr_stmt|;
name|posPendingFP
operator|=
operator|-
literal|1
expr_stmt|;
comment|// Force buffer refill:
name|posBufferUpto
operator|=
name|BLOCK_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|posPendingCount
operator|>
name|freq
condition|)
block|{
name|skipPositions
argument_list|()
expr_stmt|;
name|posPendingCount
operator|=
name|freq
expr_stmt|;
block|}
if|if
condition|(
name|posBufferUpto
operator|==
name|BLOCK_SIZE
condition|)
block|{
name|refillPositions
argument_list|()
expr_stmt|;
name|posBufferUpto
operator|=
literal|0
expr_stmt|;
block|}
name|position
operator|+=
name|posDeltaBuffer
index|[
name|posBufferUpto
operator|++
index|]
expr_stmt|;
name|posPendingCount
operator|--
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("      return pos=" + position);
comment|// }
return|return
name|position
return|;
block|}
annotation|@
name|Override
DECL|method|startOffset
specifier|public
name|int
name|startOffset
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|endOffset
specifier|public
name|int
name|endOffset
parameter_list|()
block|{
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|getPayload
specifier|public
name|BytesRef
name|getPayload
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|docFreq
return|;
block|}
block|}
comment|// Also handles payloads + offsets
DECL|class|EverythingEnum
specifier|final
class|class
name|EverythingEnum
extends|extends
name|DocsAndPositionsEnum
block|{
DECL|field|encoded
specifier|private
specifier|final
name|byte
index|[]
name|encoded
decl_stmt|;
DECL|field|docDeltaBuffer
specifier|private
specifier|final
name|int
index|[]
name|docDeltaBuffer
init|=
operator|new
name|int
index|[
name|MAX_DATA_SIZE
index|]
decl_stmt|;
DECL|field|freqBuffer
specifier|private
specifier|final
name|int
index|[]
name|freqBuffer
init|=
operator|new
name|int
index|[
name|MAX_DATA_SIZE
index|]
decl_stmt|;
DECL|field|posDeltaBuffer
specifier|private
specifier|final
name|int
index|[]
name|posDeltaBuffer
init|=
operator|new
name|int
index|[
name|MAX_DATA_SIZE
index|]
decl_stmt|;
DECL|field|payloadLengthBuffer
specifier|private
specifier|final
name|int
index|[]
name|payloadLengthBuffer
decl_stmt|;
DECL|field|offsetStartDeltaBuffer
specifier|private
specifier|final
name|int
index|[]
name|offsetStartDeltaBuffer
decl_stmt|;
DECL|field|offsetLengthBuffer
specifier|private
specifier|final
name|int
index|[]
name|offsetLengthBuffer
decl_stmt|;
DECL|field|payloadBytes
specifier|private
name|byte
index|[]
name|payloadBytes
decl_stmt|;
DECL|field|payloadByteUpto
specifier|private
name|int
name|payloadByteUpto
decl_stmt|;
DECL|field|payloadLength
specifier|private
name|int
name|payloadLength
decl_stmt|;
DECL|field|lastStartOffset
specifier|private
name|int
name|lastStartOffset
decl_stmt|;
DECL|field|startOffset
specifier|private
name|int
name|startOffset
decl_stmt|;
DECL|field|endOffset
specifier|private
name|int
name|endOffset
decl_stmt|;
DECL|field|docBufferUpto
specifier|private
name|int
name|docBufferUpto
decl_stmt|;
DECL|field|posBufferUpto
specifier|private
name|int
name|posBufferUpto
decl_stmt|;
DECL|field|skipper
specifier|private
name|Lucene41SkipReader
name|skipper
decl_stmt|;
DECL|field|skipped
specifier|private
name|boolean
name|skipped
decl_stmt|;
DECL|field|startDocIn
specifier|final
name|IndexInput
name|startDocIn
decl_stmt|;
DECL|field|docIn
name|IndexInput
name|docIn
decl_stmt|;
DECL|field|posIn
specifier|final
name|IndexInput
name|posIn
decl_stmt|;
DECL|field|payIn
specifier|final
name|IndexInput
name|payIn
decl_stmt|;
DECL|field|payload
specifier|final
name|BytesRef
name|payload
decl_stmt|;
DECL|field|indexHasOffsets
specifier|final
name|boolean
name|indexHasOffsets
decl_stmt|;
DECL|field|indexHasPayloads
specifier|final
name|boolean
name|indexHasPayloads
decl_stmt|;
DECL|field|docFreq
specifier|private
name|int
name|docFreq
decl_stmt|;
comment|// number of docs in this posting list
DECL|field|totalTermFreq
specifier|private
name|long
name|totalTermFreq
decl_stmt|;
comment|// number of positions in this posting list
DECL|field|docUpto
specifier|private
name|int
name|docUpto
decl_stmt|;
comment|// how many docs we've read
DECL|field|doc
specifier|private
name|int
name|doc
decl_stmt|;
comment|// doc we last read
DECL|field|accum
specifier|private
name|int
name|accum
decl_stmt|;
comment|// accumulator for doc deltas
DECL|field|freq
specifier|private
name|int
name|freq
decl_stmt|;
comment|// freq we last read
DECL|field|position
specifier|private
name|int
name|position
decl_stmt|;
comment|// current position
comment|// how many positions "behind" we are; nextPosition must
comment|// skip these to "catch up":
DECL|field|posPendingCount
specifier|private
name|int
name|posPendingCount
decl_stmt|;
comment|// Lazy pos seek: if != -1 then we must seek to this FP
comment|// before reading positions:
DECL|field|posPendingFP
specifier|private
name|long
name|posPendingFP
decl_stmt|;
comment|// Lazy pay seek: if != -1 then we must seek to this FP
comment|// before reading payloads/offsets:
DECL|field|payPendingFP
specifier|private
name|long
name|payPendingFP
decl_stmt|;
comment|// Where this term's postings start in the .doc file:
DECL|field|docTermStartFP
specifier|private
name|long
name|docTermStartFP
decl_stmt|;
comment|// Where this term's postings start in the .pos file:
DECL|field|posTermStartFP
specifier|private
name|long
name|posTermStartFP
decl_stmt|;
comment|// Where this term's payloads/offsets start in the .pay
comment|// file:
DECL|field|payTermStartFP
specifier|private
name|long
name|payTermStartFP
decl_stmt|;
comment|// File pointer where the last (vInt encoded) pos delta
comment|// block is.  We need this to know whether to bulk
comment|// decode vs vInt decode the block:
DECL|field|lastPosBlockFP
specifier|private
name|long
name|lastPosBlockFP
decl_stmt|;
comment|// Where this term's skip data starts (after
comment|// docTermStartFP) in the .doc file (or -1 if there is
comment|// no skip data for this term):
DECL|field|skipOffset
specifier|private
name|long
name|skipOffset
decl_stmt|;
DECL|field|nextSkipDoc
specifier|private
name|int
name|nextSkipDoc
decl_stmt|;
DECL|field|liveDocs
specifier|private
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|needsOffsets
specifier|private
name|boolean
name|needsOffsets
decl_stmt|;
comment|// true if we actually need offsets
DECL|field|needsPayloads
specifier|private
name|boolean
name|needsPayloads
decl_stmt|;
comment|// true if we actually need payloads
DECL|field|singletonDocID
specifier|private
name|int
name|singletonDocID
decl_stmt|;
comment|// docid when there is a single pulsed posting, otherwise -1
DECL|method|EverythingEnum
specifier|public
name|EverythingEnum
parameter_list|(
name|FieldInfo
name|fieldInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|startDocIn
operator|=
name|TempPostingsReader
operator|.
name|this
operator|.
name|docIn
expr_stmt|;
name|this
operator|.
name|docIn
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|posIn
operator|=
name|TempPostingsReader
operator|.
name|this
operator|.
name|posIn
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|payIn
operator|=
name|TempPostingsReader
operator|.
name|this
operator|.
name|payIn
operator|.
name|clone
argument_list|()
expr_stmt|;
name|encoded
operator|=
operator|new
name|byte
index|[
name|MAX_ENCODED_SIZE
index|]
expr_stmt|;
name|indexHasOffsets
operator|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|indexHasOffsets
condition|)
block|{
name|offsetStartDeltaBuffer
operator|=
operator|new
name|int
index|[
name|MAX_DATA_SIZE
index|]
expr_stmt|;
name|offsetLengthBuffer
operator|=
operator|new
name|int
index|[
name|MAX_DATA_SIZE
index|]
expr_stmt|;
block|}
else|else
block|{
name|offsetStartDeltaBuffer
operator|=
literal|null
expr_stmt|;
name|offsetLengthBuffer
operator|=
literal|null
expr_stmt|;
name|startOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|endOffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|indexHasPayloads
operator|=
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
expr_stmt|;
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
name|payloadLengthBuffer
operator|=
operator|new
name|int
index|[
name|MAX_DATA_SIZE
index|]
expr_stmt|;
name|payloadBytes
operator|=
operator|new
name|byte
index|[
literal|128
index|]
expr_stmt|;
name|payload
operator|=
operator|new
name|BytesRef
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|payloadLengthBuffer
operator|=
literal|null
expr_stmt|;
name|payloadBytes
operator|=
literal|null
expr_stmt|;
name|payload
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|canReuse
specifier|public
name|boolean
name|canReuse
parameter_list|(
name|IndexInput
name|docIn
parameter_list|,
name|FieldInfo
name|fieldInfo
parameter_list|)
block|{
return|return
name|docIn
operator|==
name|startDocIn
operator|&&
name|indexHasOffsets
operator|==
operator|(
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
name|indexHasPayloads
operator|==
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
return|;
block|}
DECL|method|reset
specifier|public
name|EverythingEnum
name|reset
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|IntBlockTermState
name|termState
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  FPR.reset: termState=" + termState);
comment|// }
name|docFreq
operator|=
name|termState
operator|.
name|docFreq
expr_stmt|;
name|docTermStartFP
operator|=
name|termState
operator|.
name|docStartFP
expr_stmt|;
name|posTermStartFP
operator|=
name|termState
operator|.
name|posStartFP
expr_stmt|;
name|payTermStartFP
operator|=
name|termState
operator|.
name|payStartFP
expr_stmt|;
name|skipOffset
operator|=
name|termState
operator|.
name|skipOffset
expr_stmt|;
name|totalTermFreq
operator|=
name|termState
operator|.
name|totalTermFreq
expr_stmt|;
name|singletonDocID
operator|=
name|termState
operator|.
name|singletonDocID
expr_stmt|;
if|if
condition|(
name|docFreq
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|docIn
operator|==
literal|null
condition|)
block|{
comment|// lazy init
name|docIn
operator|=
name|startDocIn
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
name|docIn
operator|.
name|seek
argument_list|(
name|docTermStartFP
argument_list|)
expr_stmt|;
block|}
name|posPendingFP
operator|=
name|posTermStartFP
expr_stmt|;
name|payPendingFP
operator|=
name|payTermStartFP
expr_stmt|;
name|posPendingCount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|termState
operator|.
name|totalTermFreq
operator|<
name|BLOCK_SIZE
condition|)
block|{
name|lastPosBlockFP
operator|=
name|posTermStartFP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|termState
operator|.
name|totalTermFreq
operator|==
name|BLOCK_SIZE
condition|)
block|{
name|lastPosBlockFP
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lastPosBlockFP
operator|=
name|posTermStartFP
operator|+
name|termState
operator|.
name|lastPosBlockOffset
expr_stmt|;
block|}
name|this
operator|.
name|needsOffsets
operator|=
operator|(
name|flags
operator|&
name|DocsAndPositionsEnum
operator|.
name|FLAG_OFFSETS
operator|)
operator|!=
literal|0
expr_stmt|;
name|this
operator|.
name|needsPayloads
operator|=
operator|(
name|flags
operator|&
name|DocsAndPositionsEnum
operator|.
name|FLAG_PAYLOADS
operator|)
operator|!=
literal|0
expr_stmt|;
name|doc
operator|=
operator|-
literal|1
expr_stmt|;
name|accum
operator|=
literal|0
expr_stmt|;
name|docUpto
operator|=
literal|0
expr_stmt|;
name|nextSkipDoc
operator|=
name|BLOCK_SIZE
operator|-
literal|1
expr_stmt|;
name|docBufferUpto
operator|=
name|BLOCK_SIZE
expr_stmt|;
name|skipped
operator|=
literal|false
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|freq
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
DECL|method|refillDocs
specifier|private
name|void
name|refillDocs
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|left
init|=
name|docFreq
operator|-
name|docUpto
decl_stmt|;
assert|assert
name|left
operator|>
literal|0
assert|;
if|if
condition|(
name|left
operator|>=
name|BLOCK_SIZE
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    fill doc block from fp=" + docIn.getFilePointer());
comment|// }
name|forUtil
operator|.
name|readBlock
argument_list|(
name|docIn
argument_list|,
name|encoded
argument_list|,
name|docDeltaBuffer
argument_list|)
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("    fill freq block from fp=" + docIn.getFilePointer());
comment|// }
name|forUtil
operator|.
name|readBlock
argument_list|(
name|docIn
argument_list|,
name|encoded
argument_list|,
name|freqBuffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|docFreq
operator|==
literal|1
condition|)
block|{
name|docDeltaBuffer
index|[
literal|0
index|]
operator|=
name|singletonDocID
expr_stmt|;
name|freqBuffer
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|totalTermFreq
expr_stmt|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    fill last vInt doc block from fp=" + docIn.getFilePointer());
comment|// }
name|readVIntBlock
argument_list|(
name|docIn
argument_list|,
name|docDeltaBuffer
argument_list|,
name|freqBuffer
argument_list|,
name|left
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|docBufferUpto
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|refillPositions
specifier|private
name|void
name|refillPositions
parameter_list|()
throws|throws
name|IOException
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("      refillPositions");
comment|// }
if|if
condition|(
name|posIn
operator|.
name|getFilePointer
argument_list|()
operator|==
name|lastPosBlockFP
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("        vInt pos block @ fp=" + posIn.getFilePointer() + " hasPayloads=" + indexHasPayloads + " hasOffsets=" + indexHasOffsets);
comment|// }
specifier|final
name|int
name|count
init|=
call|(
name|int
call|)
argument_list|(
name|totalTermFreq
operator|%
name|BLOCK_SIZE
argument_list|)
decl_stmt|;
name|int
name|payloadLength
init|=
literal|0
decl_stmt|;
name|int
name|offsetLength
init|=
literal|0
decl_stmt|;
name|payloadByteUpto
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|code
init|=
name|posIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|payloadLength
operator|=
name|posIn
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("        i=" + i + " payloadLen=" + payloadLength);
comment|// }
name|payloadLengthBuffer
index|[
name|i
index|]
operator|=
name|payloadLength
expr_stmt|;
name|posDeltaBuffer
index|[
name|i
index|]
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
if|if
condition|(
name|payloadLength
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|payloadByteUpto
operator|+
name|payloadLength
operator|>
name|payloadBytes
operator|.
name|length
condition|)
block|{
name|payloadBytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|payloadBytes
argument_list|,
name|payloadByteUpto
operator|+
name|payloadLength
argument_list|)
expr_stmt|;
block|}
comment|//System.out.println("          read payload @ pos.fp=" + posIn.getFilePointer());
name|posIn
operator|.
name|readBytes
argument_list|(
name|payloadBytes
argument_list|,
name|payloadByteUpto
argument_list|,
name|payloadLength
argument_list|)
expr_stmt|;
name|payloadByteUpto
operator|+=
name|payloadLength
expr_stmt|;
block|}
block|}
else|else
block|{
name|posDeltaBuffer
index|[
name|i
index|]
operator|=
name|code
expr_stmt|;
block|}
if|if
condition|(
name|indexHasOffsets
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("        i=" + i + " read offsets from posIn.fp=" + posIn.getFilePointer());
comment|// }
name|int
name|deltaCode
init|=
name|posIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|deltaCode
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|offsetLength
operator|=
name|posIn
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
name|offsetStartDeltaBuffer
index|[
name|i
index|]
operator|=
name|deltaCode
operator|>>>
literal|1
expr_stmt|;
name|offsetLengthBuffer
index|[
name|i
index|]
operator|=
name|offsetLength
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("          startOffDelta=" + offsetStartDeltaBuffer[i] + " offsetLen=" + offsetLengthBuffer[i]);
comment|// }
block|}
block|}
name|payloadByteUpto
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("        bulk pos block @ fp=" + posIn.getFilePointer());
comment|// }
name|forUtil
operator|.
name|readBlock
argument_list|(
name|posIn
argument_list|,
name|encoded
argument_list|,
name|posDeltaBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("        bulk payload block @ pay.fp=" + payIn.getFilePointer());
comment|// }
if|if
condition|(
name|needsPayloads
condition|)
block|{
name|forUtil
operator|.
name|readBlock
argument_list|(
name|payIn
argument_list|,
name|encoded
argument_list|,
name|payloadLengthBuffer
argument_list|)
expr_stmt|;
name|int
name|numBytes
init|=
name|payIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("        " + numBytes + " payload bytes @ pay.fp=" + payIn.getFilePointer());
comment|// }
if|if
condition|(
name|numBytes
operator|>
name|payloadBytes
operator|.
name|length
condition|)
block|{
name|payloadBytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|payloadBytes
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
block|}
name|payIn
operator|.
name|readBytes
argument_list|(
name|payloadBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// this works, because when writing a vint block we always force the first length to be written
name|forUtil
operator|.
name|skipBlock
argument_list|(
name|payIn
argument_list|)
expr_stmt|;
comment|// skip over lengths
name|int
name|numBytes
init|=
name|payIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
comment|// read length of payloadBytes
name|payIn
operator|.
name|seek
argument_list|(
name|payIn
operator|.
name|getFilePointer
argument_list|()
operator|+
name|numBytes
argument_list|)
expr_stmt|;
comment|// skip over payloadBytes
block|}
name|payloadByteUpto
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|indexHasOffsets
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("        bulk offset block @ pay.fp=" + payIn.getFilePointer());
comment|// }
if|if
condition|(
name|needsOffsets
condition|)
block|{
name|forUtil
operator|.
name|readBlock
argument_list|(
name|payIn
argument_list|,
name|encoded
argument_list|,
name|offsetStartDeltaBuffer
argument_list|)
expr_stmt|;
name|forUtil
operator|.
name|readBlock
argument_list|(
name|payIn
argument_list|,
name|encoded
argument_list|,
name|offsetLengthBuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// this works, because when writing a vint block we always force the first length to be written
name|forUtil
operator|.
name|skipBlock
argument_list|(
name|payIn
argument_list|)
expr_stmt|;
comment|// skip over starts
name|forUtil
operator|.
name|skipBlock
argument_list|(
name|payIn
argument_list|)
expr_stmt|;
comment|// skip over lengths
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
throws|throws
name|IOException
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  FPR.nextDoc");
comment|// }
while|while
condition|(
literal|true
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    docUpto=" + docUpto + " (of df=" + docFreq + ") docBufferUpto=" + docBufferUpto);
comment|// }
if|if
condition|(
name|docUpto
operator|==
name|docFreq
condition|)
block|{
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
if|if
condition|(
name|docBufferUpto
operator|==
name|BLOCK_SIZE
condition|)
block|{
name|refillDocs
argument_list|()
expr_stmt|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto + "]=" + docDeltaBuffer[docBufferUpto]);
comment|// }
name|accum
operator|+=
name|docDeltaBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|freq
operator|=
name|freqBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|posPendingCount
operator|+=
name|freq
expr_stmt|;
name|docBufferUpto
operator|++
expr_stmt|;
name|docUpto
operator|++
expr_stmt|;
if|if
condition|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
name|accum
argument_list|)
condition|)
block|{
name|doc
operator|=
name|accum
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("    return doc=" + doc + " freq=" + freq + " posPendingCount=" + posPendingCount);
comment|// }
name|position
operator|=
literal|0
expr_stmt|;
name|lastStartOffset
operator|=
literal|0
expr_stmt|;
return|return
name|doc
return|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("    doc=" + accum + " is deleted; try next doc");
comment|// }
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: make frq block load lazy/skippable
comment|// if (DEBUG) {
comment|//   System.out.println("  FPR.advance target=" + target);
comment|// }
if|if
condition|(
name|docFreq
operator|>
name|BLOCK_SIZE
operator|&&
name|target
operator|>
name|nextSkipDoc
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    try skipper");
comment|// }
if|if
condition|(
name|skipper
operator|==
literal|null
condition|)
block|{
comment|// Lazy init: first time this enum has ever been used for skipping
comment|// if (DEBUG) {
comment|//   System.out.println("    create skipper");
comment|// }
name|skipper
operator|=
operator|new
name|Lucene41SkipReader
argument_list|(
name|docIn
operator|.
name|clone
argument_list|()
argument_list|,
name|TempPostingsWriter
operator|.
name|maxSkipLevels
argument_list|,
name|BLOCK_SIZE
argument_list|,
literal|true
argument_list|,
name|indexHasOffsets
argument_list|,
name|indexHasPayloads
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skipped
condition|)
block|{
assert|assert
name|skipOffset
operator|!=
operator|-
literal|1
assert|;
comment|// This is the first time this enum has skipped
comment|// since reset() was called; load the skip data:
comment|// if (DEBUG) {
comment|//   System.out.println("    init skipper");
comment|// }
name|skipper
operator|.
name|init
argument_list|(
name|docTermStartFP
operator|+
name|skipOffset
argument_list|,
name|docTermStartFP
argument_list|,
name|posTermStartFP
argument_list|,
name|payTermStartFP
argument_list|,
name|docFreq
argument_list|)
expr_stmt|;
name|skipped
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|int
name|newDocUpto
init|=
name|skipper
operator|.
name|skipTo
argument_list|(
name|target
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|newDocUpto
operator|>
name|docUpto
condition|)
block|{
comment|// Skipper moved
comment|// if (DEBUG) {
comment|//   System.out.println("    skipper moved to docUpto=" + newDocUpto + " vs current=" + docUpto + "; docID=" + skipper.getDoc() + " fp=" + skipper.getDocPointer() + " pos.fp=" + skipper.getPosPointer() + " pos.bufferUpto=" + skipper.getPosBufferUpto() + " pay.fp=" + skipper.getPayPointer() + " lastStartOffset=" + lastStartOffset);
comment|// }
assert|assert
name|newDocUpto
operator|%
name|BLOCK_SIZE
operator|==
literal|0
operator|:
literal|"got "
operator|+
name|newDocUpto
assert|;
name|docUpto
operator|=
name|newDocUpto
expr_stmt|;
comment|// Force to read next block
name|docBufferUpto
operator|=
name|BLOCK_SIZE
expr_stmt|;
name|accum
operator|=
name|skipper
operator|.
name|getDoc
argument_list|()
expr_stmt|;
name|docIn
operator|.
name|seek
argument_list|(
name|skipper
operator|.
name|getDocPointer
argument_list|()
argument_list|)
expr_stmt|;
name|posPendingFP
operator|=
name|skipper
operator|.
name|getPosPointer
argument_list|()
expr_stmt|;
name|payPendingFP
operator|=
name|skipper
operator|.
name|getPayPointer
argument_list|()
expr_stmt|;
name|posPendingCount
operator|=
name|skipper
operator|.
name|getPosBufferUpto
argument_list|()
expr_stmt|;
name|lastStartOffset
operator|=
literal|0
expr_stmt|;
comment|// new document
name|payloadByteUpto
operator|=
name|skipper
operator|.
name|getPayloadByteUpto
argument_list|()
expr_stmt|;
block|}
name|nextSkipDoc
operator|=
name|skipper
operator|.
name|getNextSkipDoc
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|docUpto
operator|==
name|docFreq
condition|)
block|{
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
if|if
condition|(
name|docBufferUpto
operator|==
name|BLOCK_SIZE
condition|)
block|{
name|refillDocs
argument_list|()
expr_stmt|;
block|}
comment|// Now scan:
while|while
condition|(
literal|true
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  scan doc=" + accum + " docBufferUpto=" + docBufferUpto);
comment|// }
name|accum
operator|+=
name|docDeltaBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|freq
operator|=
name|freqBuffer
index|[
name|docBufferUpto
index|]
expr_stmt|;
name|posPendingCount
operator|+=
name|freq
expr_stmt|;
name|docBufferUpto
operator|++
expr_stmt|;
name|docUpto
operator|++
expr_stmt|;
if|if
condition|(
name|accum
operator|>=
name|target
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|docUpto
operator|==
name|docFreq
condition|)
block|{
return|return
name|doc
operator|=
name|NO_MORE_DOCS
return|;
block|}
block|}
if|if
condition|(
name|liveDocs
operator|==
literal|null
operator|||
name|liveDocs
operator|.
name|get
argument_list|(
name|accum
argument_list|)
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  return doc=" + accum);
comment|// }
name|position
operator|=
literal|0
expr_stmt|;
name|lastStartOffset
operator|=
literal|0
expr_stmt|;
return|return
name|doc
operator|=
name|accum
return|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  now do nextDoc()");
comment|// }
return|return
name|nextDoc
argument_list|()
return|;
block|}
block|}
comment|// TODO: in theory we could avoid loading frq block
comment|// when not needed, ie, use skip data to load how far to
comment|// seek the pos pointer ... instead of having to load frq
comment|// blocks only to sum up how many positions to skip
DECL|method|skipPositions
specifier|private
name|void
name|skipPositions
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Skip positions now:
name|int
name|toSkip
init|=
name|posPendingCount
operator|-
name|freq
decl_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("      FPR.skipPositions: toSkip=" + toSkip);
comment|// }
specifier|final
name|int
name|leftInBlock
init|=
name|BLOCK_SIZE
operator|-
name|posBufferUpto
decl_stmt|;
if|if
condition|(
name|toSkip
operator|<
name|leftInBlock
condition|)
block|{
name|int
name|end
init|=
name|posBufferUpto
operator|+
name|toSkip
decl_stmt|;
while|while
condition|(
name|posBufferUpto
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
name|payloadByteUpto
operator|+=
name|payloadLengthBuffer
index|[
name|posBufferUpto
index|]
expr_stmt|;
block|}
name|posBufferUpto
operator|++
expr_stmt|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("        skip w/in block to posBufferUpto=" + posBufferUpto);
comment|// }
block|}
else|else
block|{
name|toSkip
operator|-=
name|leftInBlock
expr_stmt|;
while|while
condition|(
name|toSkip
operator|>=
name|BLOCK_SIZE
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("        skip whole block @ fp=" + posIn.getFilePointer());
comment|// }
assert|assert
name|posIn
operator|.
name|getFilePointer
argument_list|()
operator|!=
name|lastPosBlockFP
assert|;
name|forUtil
operator|.
name|skipBlock
argument_list|(
name|posIn
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
comment|// Skip payloadLength block:
name|forUtil
operator|.
name|skipBlock
argument_list|(
name|payIn
argument_list|)
expr_stmt|;
comment|// Skip payloadBytes block:
name|int
name|numBytes
init|=
name|payIn
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|payIn
operator|.
name|seek
argument_list|(
name|payIn
operator|.
name|getFilePointer
argument_list|()
operator|+
name|numBytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indexHasOffsets
condition|)
block|{
name|forUtil
operator|.
name|skipBlock
argument_list|(
name|payIn
argument_list|)
expr_stmt|;
name|forUtil
operator|.
name|skipBlock
argument_list|(
name|payIn
argument_list|)
expr_stmt|;
block|}
name|toSkip
operator|-=
name|BLOCK_SIZE
expr_stmt|;
block|}
name|refillPositions
argument_list|()
expr_stmt|;
name|payloadByteUpto
operator|=
literal|0
expr_stmt|;
name|posBufferUpto
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|posBufferUpto
operator|<
name|toSkip
condition|)
block|{
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
name|payloadByteUpto
operator|+=
name|payloadLengthBuffer
index|[
name|posBufferUpto
index|]
expr_stmt|;
block|}
name|posBufferUpto
operator|++
expr_stmt|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("        skip w/in block to posBufferUpto=" + posBufferUpto);
comment|// }
block|}
name|position
operator|=
literal|0
expr_stmt|;
name|lastStartOffset
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|nextPosition
specifier|public
name|int
name|nextPosition
parameter_list|()
throws|throws
name|IOException
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    FPR.nextPosition posPendingCount=" + posPendingCount + " posBufferUpto=" + posBufferUpto + " payloadByteUpto=" + payloadByteUpto)// ;
comment|// }
if|if
condition|(
name|posPendingFP
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("      seek pos to pendingFP=" + posPendingFP);
comment|// }
name|posIn
operator|.
name|seek
argument_list|(
name|posPendingFP
argument_list|)
expr_stmt|;
name|posPendingFP
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|payPendingFP
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("      seek pay to pendingFP=" + payPendingFP);
comment|// }
name|payIn
operator|.
name|seek
argument_list|(
name|payPendingFP
argument_list|)
expr_stmt|;
name|payPendingFP
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|// Force buffer refill:
name|posBufferUpto
operator|=
name|BLOCK_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|posPendingCount
operator|>
name|freq
condition|)
block|{
name|skipPositions
argument_list|()
expr_stmt|;
name|posPendingCount
operator|=
name|freq
expr_stmt|;
block|}
if|if
condition|(
name|posBufferUpto
operator|==
name|BLOCK_SIZE
condition|)
block|{
name|refillPositions
argument_list|()
expr_stmt|;
name|posBufferUpto
operator|=
literal|0
expr_stmt|;
block|}
name|position
operator|+=
name|posDeltaBuffer
index|[
name|posBufferUpto
index|]
expr_stmt|;
if|if
condition|(
name|indexHasPayloads
condition|)
block|{
name|payloadLength
operator|=
name|payloadLengthBuffer
index|[
name|posBufferUpto
index|]
expr_stmt|;
name|payload
operator|.
name|bytes
operator|=
name|payloadBytes
expr_stmt|;
name|payload
operator|.
name|offset
operator|=
name|payloadByteUpto
expr_stmt|;
name|payload
operator|.
name|length
operator|=
name|payloadLength
expr_stmt|;
name|payloadByteUpto
operator|+=
name|payloadLength
expr_stmt|;
block|}
if|if
condition|(
name|indexHasOffsets
condition|)
block|{
name|startOffset
operator|=
name|lastStartOffset
operator|+
name|offsetStartDeltaBuffer
index|[
name|posBufferUpto
index|]
expr_stmt|;
name|endOffset
operator|=
name|startOffset
operator|+
name|offsetLengthBuffer
index|[
name|posBufferUpto
index|]
expr_stmt|;
name|lastStartOffset
operator|=
name|startOffset
expr_stmt|;
block|}
name|posBufferUpto
operator|++
expr_stmt|;
name|posPendingCount
operator|--
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("      return pos=" + position);
comment|// }
return|return
name|position
return|;
block|}
annotation|@
name|Override
DECL|method|startOffset
specifier|public
name|int
name|startOffset
parameter_list|()
block|{
return|return
name|startOffset
return|;
block|}
annotation|@
name|Override
DECL|method|endOffset
specifier|public
name|int
name|endOffset
parameter_list|()
block|{
return|return
name|endOffset
return|;
block|}
annotation|@
name|Override
DECL|method|getPayload
specifier|public
name|BytesRef
name|getPayload
parameter_list|()
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    FPR.getPayload payloadLength=" + payloadLength + " payloadByteUpto=" + payloadByteUpto);
comment|// }
if|if
condition|(
name|payloadLength
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|payload
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|cost
specifier|public
name|long
name|cost
parameter_list|()
block|{
return|return
name|docFreq
return|;
block|}
block|}
block|}
end_class
end_unit
