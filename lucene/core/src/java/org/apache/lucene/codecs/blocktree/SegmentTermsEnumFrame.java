begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.blocktree
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|blocktree
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|BlockTermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
operator|.
name|SeekStatus
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|ByteArrayDataInput
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|fst
operator|.
name|FST
import|;
end_import
begin_class
DECL|class|SegmentTermsEnumFrame
specifier|final
class|class
name|SegmentTermsEnumFrame
block|{
comment|// Our index in stack[]:
DECL|field|ord
specifier|final
name|int
name|ord
decl_stmt|;
DECL|field|hasTerms
name|boolean
name|hasTerms
decl_stmt|;
DECL|field|hasTermsOrig
name|boolean
name|hasTermsOrig
decl_stmt|;
DECL|field|isFloor
name|boolean
name|isFloor
decl_stmt|;
DECL|field|arc
name|FST
operator|.
name|Arc
argument_list|<
name|BytesRef
argument_list|>
name|arc
decl_stmt|;
DECL|field|versionAutoPrefix
specifier|final
name|boolean
name|versionAutoPrefix
decl_stmt|;
comment|//static boolean DEBUG = BlockTreeTermsWriter.DEBUG;
comment|// File pointer where this block was loaded from
DECL|field|fp
name|long
name|fp
decl_stmt|;
DECL|field|fpOrig
name|long
name|fpOrig
decl_stmt|;
DECL|field|fpEnd
name|long
name|fpEnd
decl_stmt|;
DECL|field|suffixBytes
name|byte
index|[]
name|suffixBytes
init|=
operator|new
name|byte
index|[
literal|128
index|]
decl_stmt|;
DECL|field|suffixesReader
specifier|final
name|ByteArrayDataInput
name|suffixesReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
DECL|field|statBytes
name|byte
index|[]
name|statBytes
init|=
operator|new
name|byte
index|[
literal|64
index|]
decl_stmt|;
DECL|field|statsReader
specifier|final
name|ByteArrayDataInput
name|statsReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
DECL|field|floorData
name|byte
index|[]
name|floorData
init|=
operator|new
name|byte
index|[
literal|32
index|]
decl_stmt|;
DECL|field|floorDataReader
specifier|final
name|ByteArrayDataInput
name|floorDataReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
comment|// Length of prefix shared by all terms in this block
DECL|field|prefix
name|int
name|prefix
decl_stmt|;
comment|// Number of entries (term or sub-block) in this block
DECL|field|entCount
name|int
name|entCount
decl_stmt|;
comment|// Which term we will next read, or -1 if the block
comment|// isn't loaded yet
DECL|field|nextEnt
name|int
name|nextEnt
decl_stmt|;
comment|// True if this block is either not a floor block,
comment|// or, it's the last sub-block of a floor block
DECL|field|isLastInFloor
name|boolean
name|isLastInFloor
decl_stmt|;
comment|// True if all entries are terms
DECL|field|isLeafBlock
name|boolean
name|isLeafBlock
decl_stmt|;
DECL|field|lastSubFP
name|long
name|lastSubFP
decl_stmt|;
DECL|field|nextFloorLabel
name|int
name|nextFloorLabel
decl_stmt|;
DECL|field|numFollowFloorBlocks
name|int
name|numFollowFloorBlocks
decl_stmt|;
comment|// Next term to decode metaData; we decode metaData
comment|// lazily so that scanning to find the matching term is
comment|// fast and only if you find a match and app wants the
comment|// stats or docs/positions enums, will we decode the
comment|// metaData
DECL|field|metaDataUpto
name|int
name|metaDataUpto
decl_stmt|;
DECL|field|state
specifier|final
name|BlockTermState
name|state
decl_stmt|;
comment|// metadata buffer, holding monotonic values
DECL|field|longs
specifier|final
name|long
index|[]
name|longs
decl_stmt|;
comment|// metadata buffer, holding general values
DECL|field|bytes
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
literal|32
index|]
decl_stmt|;
DECL|field|bytesReader
specifier|final
name|ByteArrayDataInput
name|bytesReader
init|=
operator|new
name|ByteArrayDataInput
argument_list|()
decl_stmt|;
DECL|field|ste
specifier|private
specifier|final
name|SegmentTermsEnum
name|ste
decl_stmt|;
DECL|method|SegmentTermsEnumFrame
specifier|public
name|SegmentTermsEnumFrame
parameter_list|(
name|SegmentTermsEnum
name|ste
parameter_list|,
name|int
name|ord
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|ste
operator|=
name|ste
expr_stmt|;
name|this
operator|.
name|ord
operator|=
name|ord
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|ste
operator|.
name|fr
operator|.
name|parent
operator|.
name|postingsReader
operator|.
name|newTermState
argument_list|()
expr_stmt|;
name|this
operator|.
name|state
operator|.
name|totalTermFreq
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|longs
operator|=
operator|new
name|long
index|[
name|ste
operator|.
name|fr
operator|.
name|longsSize
index|]
expr_stmt|;
name|this
operator|.
name|versionAutoPrefix
operator|=
name|ste
operator|.
name|fr
operator|.
name|parent
operator|.
name|anyAutoPrefixTerms
expr_stmt|;
block|}
DECL|method|setFloorData
specifier|public
name|void
name|setFloorData
parameter_list|(
name|ByteArrayDataInput
name|in
parameter_list|,
name|BytesRef
name|source
parameter_list|)
block|{
specifier|final
name|int
name|numBytes
init|=
name|source
operator|.
name|length
operator|-
operator|(
name|in
operator|.
name|getPosition
argument_list|()
operator|-
name|source
operator|.
name|offset
operator|)
decl_stmt|;
if|if
condition|(
name|numBytes
operator|>
name|floorData
operator|.
name|length
condition|)
block|{
name|floorData
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|source
operator|.
name|bytes
argument_list|,
name|source
operator|.
name|offset
operator|+
name|in
operator|.
name|getPosition
argument_list|()
argument_list|,
name|floorData
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|floorDataReader
operator|.
name|reset
argument_list|(
name|floorData
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|numFollowFloorBlocks
operator|=
name|floorDataReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|nextFloorLabel
operator|=
name|floorDataReader
operator|.
name|readByte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("    setFloorData fpOrig=" + fpOrig + " bytes=" + new BytesRef(source.bytes, source.offset + in.getPosition(), numBytes) + " numFollowFloorBlocks=" + numFollowFloorBlocks + " nextFloorLabel=" + toHex(nextFloorLabel));
comment|//}
block|}
DECL|method|getTermBlockOrd
specifier|public
name|int
name|getTermBlockOrd
parameter_list|()
block|{
return|return
name|isLeafBlock
condition|?
name|nextEnt
else|:
name|state
operator|.
name|termBlockOrd
return|;
block|}
DECL|method|loadNextFloorBlock
name|void
name|loadNextFloorBlock
parameter_list|()
throws|throws
name|IOException
block|{
comment|//if (DEBUG) {
comment|//System.out.println("    loadNextFloorBlock fp=" + fp + " fpEnd=" + fpEnd);
comment|//}
assert|assert
name|arc
operator|==
literal|null
operator|||
name|isFloor
operator|:
literal|"arc="
operator|+
name|arc
operator|+
literal|" isFloor="
operator|+
name|isFloor
assert|;
name|fp
operator|=
name|fpEnd
expr_stmt|;
name|nextEnt
operator|=
operator|-
literal|1
expr_stmt|;
name|loadBlock
argument_list|()
expr_stmt|;
block|}
comment|/* Does initial decode of next block of terms; this      doesn't actually decode the docFreq, totalTermFreq,      postings details (frq/prx offset, etc.) metadata;      it just loads them as byte[] blobs which are then            decoded on-demand if the metadata is ever requested      for any term in this block.  This enables terms-only      intensive consumes (eg certain MTQs, respelling) to      not pay the price of decoding metadata they won't      use. */
DECL|method|loadBlock
name|void
name|loadBlock
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Clone the IndexInput lazily, so that consumers
comment|// that just pull a TermsEnum to
comment|// seekExact(TermState) don't pay this cost:
name|ste
operator|.
name|initIndexInput
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextEnt
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Already loaded
return|return;
block|}
comment|//System.out.println("blc=" + blockLoadCount);
name|ste
operator|.
name|in
operator|.
name|seek
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|int
name|code
init|=
name|ste
operator|.
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|entCount
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
assert|assert
name|entCount
operator|>
literal|0
assert|;
name|isLastInFloor
operator|=
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
assert|assert
name|arc
operator|==
literal|null
operator|||
operator|(
name|isLastInFloor
operator|||
name|isFloor
operator|)
operator|:
literal|"fp="
operator|+
name|fp
operator|+
literal|" arc="
operator|+
name|arc
operator|+
literal|" isFloor="
operator|+
name|isFloor
operator|+
literal|" isLastInFloor="
operator|+
name|isLastInFloor
assert|;
comment|// TODO: if suffixes were stored in random-access
comment|// array structure, then we could do binary search
comment|// instead of linear scan to find target term; eg
comment|// we could have simple array of offsets
comment|// term suffixes:
name|code
operator|=
name|ste
operator|.
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|isLeafBlock
operator|=
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
name|int
name|numBytes
init|=
name|code
operator|>>>
literal|1
decl_stmt|;
if|if
condition|(
name|suffixBytes
operator|.
name|length
operator|<
name|numBytes
condition|)
block|{
name|suffixBytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|ste
operator|.
name|in
operator|.
name|readBytes
argument_list|(
name|suffixBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|suffixesReader
operator|.
name|reset
argument_list|(
name|suffixBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
comment|/*if (DEBUG) {       if (arc == null) {       System.out.println("    loadBlock (next) fp=" + fp + " entCount=" + entCount + " prefixLen=" + prefix + " isLastInFloor=" + isLastInFloor + " leaf?=" + isLeafBlock);       } else {       System.out.println("    loadBlock (seek) fp=" + fp + " entCount=" + entCount + " prefixLen=" + prefix + " hasTerms?=" + hasTerms + " isFloor?=" + isFloor + " isLastInFloor=" + isLastInFloor + " leaf?=" + isLeafBlock);       }       }*/
comment|// stats
name|numBytes
operator|=
name|ste
operator|.
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|statBytes
operator|.
name|length
operator|<
name|numBytes
condition|)
block|{
name|statBytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|ste
operator|.
name|in
operator|.
name|readBytes
argument_list|(
name|statBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|statsReader
operator|.
name|reset
argument_list|(
name|statBytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|metaDataUpto
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termBlockOrd
operator|=
literal|0
expr_stmt|;
name|nextEnt
operator|=
literal|0
expr_stmt|;
name|lastSubFP
operator|=
operator|-
literal|1
expr_stmt|;
comment|// TODO: we could skip this if !hasTerms; but
comment|// that's rare so won't help much
comment|// metadata
name|numBytes
operator|=
name|ste
operator|.
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|bytes
operator|.
name|length
operator|<
name|numBytes
condition|)
block|{
name|bytes
operator|=
operator|new
name|byte
index|[
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|numBytes
argument_list|,
literal|1
argument_list|)
index|]
expr_stmt|;
block|}
name|ste
operator|.
name|in
operator|.
name|readBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|bytesReader
operator|.
name|reset
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
comment|// Sub-blocks of a single floor block are always
comment|// written one after another -- tail recurse:
name|fpEnd
operator|=
name|ste
operator|.
name|in
operator|.
name|getFilePointer
argument_list|()
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("      fpEnd=" + fpEnd);
comment|// }
block|}
DECL|method|rewind
name|void
name|rewind
parameter_list|()
block|{
comment|// Force reload:
name|fp
operator|=
name|fpOrig
expr_stmt|;
name|nextEnt
operator|=
operator|-
literal|1
expr_stmt|;
name|hasTerms
operator|=
name|hasTermsOrig
expr_stmt|;
if|if
condition|(
name|isFloor
condition|)
block|{
name|floorDataReader
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|numFollowFloorBlocks
operator|=
name|floorDataReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
assert|assert
name|numFollowFloorBlocks
operator|>
literal|0
assert|;
name|nextFloorLabel
operator|=
name|floorDataReader
operator|.
name|readByte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/*     //System.out.println("rewind");     // Keeps the block loaded, but rewinds its state:     if (nextEnt> 0 || fp != fpOrig) {     if (DEBUG) {     System.out.println("      rewind frame ord=" + ord + " fpOrig=" + fpOrig + " fp=" + fp + " hasTerms?=" + hasTerms + " isFloor?=" + isFloor + " nextEnt=" + nextEnt + " prefixLen=" + prefix);     }     if (fp != fpOrig) {     fp = fpOrig;     nextEnt = -1;     } else {     nextEnt = 0;     }     hasTerms = hasTermsOrig;     if (isFloor) {     floorDataReader.rewind();     numFollowFloorBlocks = floorDataReader.readVInt();     nextFloorLabel = floorDataReader.readByte()& 0xff;     }     assert suffixBytes != null;     suffixesReader.rewind();     assert statBytes != null;     statsReader.rewind();     metaDataUpto = 0;     state.termBlockOrd = 0;     // TODO: skip this if !hasTerms?  Then postings     // impl wouldn't have to write useless 0 byte     postingsReader.resetTermsBlock(fieldInfo, state);     lastSubFP = -1;     } else if (DEBUG) {     System.out.println("      skip rewind fp=" + fp + " fpOrig=" + fpOrig + " nextEnt=" + nextEnt + " ord=" + ord);     }     */
block|}
comment|// Decodes next entry; returns true if it's a sub-block
DECL|method|next
specifier|public
name|boolean
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isLeafBlock
condition|)
block|{
name|nextLeaf
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|nextNonLeaf
argument_list|()
return|;
block|}
block|}
DECL|method|nextLeaf
specifier|public
name|void
name|nextLeaf
parameter_list|()
block|{
comment|//if (DEBUG) System.out.println("  frame.next ord=" + ord + " nextEnt=" + nextEnt + " entCount=" + entCount);
assert|assert
name|nextEnt
operator|!=
operator|-
literal|1
operator|&&
name|nextEnt
operator|<
name|entCount
operator|:
literal|"nextEnt="
operator|+
name|nextEnt
operator|+
literal|" entCount="
operator|+
name|entCount
operator|+
literal|" fp="
operator|+
name|fp
assert|;
name|nextEnt
operator|++
expr_stmt|;
name|suffix
operator|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|ste
operator|.
name|term
operator|.
name|setLength
argument_list|(
name|prefix
operator|+
name|suffix
argument_list|)
expr_stmt|;
name|ste
operator|.
name|term
operator|.
name|grow
argument_list|(
name|ste
operator|.
name|term
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|suffixesReader
operator|.
name|readBytes
argument_list|(
name|ste
operator|.
name|term
operator|.
name|bytes
argument_list|()
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|ste
operator|.
name|termExists
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|nextNonLeaf
specifier|public
name|boolean
name|nextNonLeaf
parameter_list|()
throws|throws
name|IOException
block|{
comment|//if (DEBUG) System.out.println("  stef.next ord=" + ord + " nextEnt=" + nextEnt + " entCount=" + entCount + " fp=" + suffixesReader.getPosition());
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|nextEnt
operator|==
name|entCount
condition|)
block|{
assert|assert
name|arc
operator|==
literal|null
operator|||
operator|(
name|isFloor
operator|&&
name|isLastInFloor
operator|==
literal|false
operator|)
operator|:
literal|"isFloor="
operator|+
name|isFloor
operator|+
literal|" isLastInFloor="
operator|+
name|isLastInFloor
assert|;
name|loadNextFloorBlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|isLeafBlock
condition|)
block|{
name|nextLeaf
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
continue|continue;
block|}
block|}
assert|assert
name|nextEnt
operator|!=
operator|-
literal|1
operator|&&
name|nextEnt
operator|<
name|entCount
operator|:
literal|"nextEnt="
operator|+
name|nextEnt
operator|+
literal|" entCount="
operator|+
name|entCount
operator|+
literal|" fp="
operator|+
name|fp
assert|;
name|nextEnt
operator|++
expr_stmt|;
specifier|final
name|int
name|code
init|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|versionAutoPrefix
operator|==
literal|false
condition|)
block|{
name|suffix
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|ste
operator|.
name|term
operator|.
name|setLength
argument_list|(
name|prefix
operator|+
name|suffix
argument_list|)
expr_stmt|;
name|ste
operator|.
name|term
operator|.
name|grow
argument_list|(
name|ste
operator|.
name|term
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|suffixesReader
operator|.
name|readBytes
argument_list|(
name|ste
operator|.
name|term
operator|.
name|bytes
argument_list|()
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|// A normal term
name|ste
operator|.
name|termExists
operator|=
literal|true
expr_stmt|;
name|subCode
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// A sub-block; make sub-FP absolute:
name|ste
operator|.
name|termExists
operator|=
literal|false
expr_stmt|;
name|subCode
operator|=
name|suffixesReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|lastSubFP
operator|=
name|fp
operator|-
name|subCode
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("    lastSubFP=" + lastSubFP);
comment|//}
return|return
literal|true
return|;
block|}
block|}
else|else
block|{
name|suffix
operator|=
name|code
operator|>>>
literal|2
expr_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|ste
operator|.
name|term
operator|.
name|setLength
argument_list|(
name|prefix
operator|+
name|suffix
argument_list|)
expr_stmt|;
name|ste
operator|.
name|term
operator|.
name|grow
argument_list|(
name|ste
operator|.
name|term
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|suffixesReader
operator|.
name|readBytes
argument_list|(
name|ste
operator|.
name|term
operator|.
name|bytes
argument_list|()
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
comment|// A normal term
name|ste
operator|.
name|termExists
operator|=
literal|true
expr_stmt|;
name|subCode
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
return|return
literal|false
return|;
case|case
literal|1
case|:
comment|// A sub-block; make sub-FP absolute:
name|ste
operator|.
name|termExists
operator|=
literal|false
expr_stmt|;
name|subCode
operator|=
name|suffixesReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|lastSubFP
operator|=
name|fp
operator|-
name|subCode
expr_stmt|;
comment|//if (DEBUG) {
comment|//System.out.println("    lastSubFP=" + lastSubFP);
comment|//}
return|return
literal|true
return|;
case|case
literal|2
case|:
case|case
literal|3
case|:
comment|// A prefix term: skip it
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
name|suffixesReader
operator|.
name|readByte
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
comment|// TODO: make this array'd so we can do bin search?
comment|// likely not worth it?  need to measure how many
comment|// floor blocks we "typically" get
DECL|method|scanToFloorFrame
specifier|public
name|void
name|scanToFloorFrame
parameter_list|(
name|BytesRef
name|target
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isFloor
operator|||
name|target
operator|.
name|length
operator|<=
name|prefix
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    scanToFloorFrame skip: isFloor=" + isFloor + " target.length=" + target.length + " vs prefix=" + prefix);
comment|// }
return|return;
block|}
specifier|final
name|int
name|targetLabel
init|=
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|prefix
index|]
operator|&
literal|0xFF
decl_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("    scanToFloorFrame fpOrig=" + fpOrig + " targetLabel=" + toHex(targetLabel) + " vs nextFloorLabel=" + toHex(nextFloorLabel) + " numFollowFloorBlocks=" + numFollowFloorBlocks);
comment|// }
if|if
condition|(
name|targetLabel
operator|<
name|nextFloorLabel
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("      already on correct block");
comment|// }
return|return;
block|}
assert|assert
name|numFollowFloorBlocks
operator|!=
literal|0
assert|;
name|long
name|newFP
init|=
name|fpOrig
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|long
name|code
init|=
name|floorDataReader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
name|newFP
operator|=
name|fpOrig
operator|+
operator|(
name|code
operator|>>>
literal|1
operator|)
expr_stmt|;
name|hasTerms
operator|=
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("      label=" + toHex(nextFloorLabel) + " fp=" + newFP + " hasTerms?=" + hasTerms + " numFollowFloor=" + numFollowFloorBlocks);
comment|// }
name|isLastInFloor
operator|=
name|numFollowFloorBlocks
operator|==
literal|1
expr_stmt|;
name|numFollowFloorBlocks
operator|--
expr_stmt|;
if|if
condition|(
name|isLastInFloor
condition|)
block|{
name|nextFloorLabel
operator|=
literal|256
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("        stop!  last block nextFloorLabel=" + toHex(nextFloorLabel));
comment|// }
break|break;
block|}
else|else
block|{
name|nextFloorLabel
operator|=
name|floorDataReader
operator|.
name|readByte
argument_list|()
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|targetLabel
operator|<
name|nextFloorLabel
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("        stop!  nextFloorLabel=" + toHex(nextFloorLabel));
comment|// }
break|break;
block|}
block|}
block|}
if|if
condition|(
name|newFP
operator|!=
name|fp
condition|)
block|{
comment|// Force re-load of the block:
comment|// if (DEBUG) {
comment|//   System.out.println("      force switch to fp=" + newFP + " oldFP=" + fp);
comment|// }
name|nextEnt
operator|=
operator|-
literal|1
expr_stmt|;
name|fp
operator|=
name|newFP
expr_stmt|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("      stay on same fp=" + newFP);
comment|// }
block|}
block|}
DECL|method|decodeMetaData
specifier|public
name|void
name|decodeMetaData
parameter_list|()
throws|throws
name|IOException
block|{
comment|//if (DEBUG) System.out.println("\nBTTR.decodeMetadata seg=" + segment + " mdUpto=" + metaDataUpto + " vs termBlockOrd=" + state.termBlockOrd);
comment|// lazily catch up on metadata decode:
specifier|final
name|int
name|limit
init|=
name|getTermBlockOrd
argument_list|()
decl_stmt|;
name|boolean
name|absolute
init|=
name|metaDataUpto
operator|==
literal|0
decl_stmt|;
assert|assert
name|limit
operator|>
literal|0
assert|;
comment|// TODO: better API would be "jump straight to term=N"???
while|while
condition|(
name|metaDataUpto
operator|<
name|limit
condition|)
block|{
comment|// TODO: we could make "tiers" of metadata, ie,
comment|// decode docFreq/totalTF but don't decode postings
comment|// metadata; this way caller could get
comment|// docFreq/totalTF w/o paying decode cost for
comment|// postings
comment|// TODO: if docFreq were bulk decoded we could
comment|// just skipN here:
comment|// stats
name|state
operator|.
name|docFreq
operator|=
name|statsReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("    dF=" + state.docFreq);
if|if
condition|(
name|ste
operator|.
name|fr
operator|.
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|!=
name|IndexOptions
operator|.
name|DOCS
condition|)
block|{
name|state
operator|.
name|totalTermFreq
operator|=
name|state
operator|.
name|docFreq
operator|+
name|statsReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("    totTF=" + state.totalTermFreq);
block|}
comment|// metadata
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ste
operator|.
name|fr
operator|.
name|longsSize
condition|;
name|i
operator|++
control|)
block|{
name|longs
index|[
name|i
index|]
operator|=
name|bytesReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
block|}
name|ste
operator|.
name|fr
operator|.
name|parent
operator|.
name|postingsReader
operator|.
name|decodeTerm
argument_list|(
name|longs
argument_list|,
name|bytesReader
argument_list|,
name|ste
operator|.
name|fr
operator|.
name|fieldInfo
argument_list|,
name|state
argument_list|,
name|absolute
argument_list|)
expr_stmt|;
name|metaDataUpto
operator|++
expr_stmt|;
name|absolute
operator|=
literal|false
expr_stmt|;
block|}
name|state
operator|.
name|termBlockOrd
operator|=
name|metaDataUpto
expr_stmt|;
block|}
comment|// Used only by assert
DECL|method|prefixMatches
specifier|private
name|boolean
name|prefixMatches
parameter_list|(
name|BytesRef
name|target
parameter_list|)
block|{
for|for
control|(
name|int
name|bytePos
init|=
literal|0
init|;
name|bytePos
operator|<
name|prefix
condition|;
name|bytePos
operator|++
control|)
block|{
if|if
condition|(
name|target
operator|.
name|bytes
index|[
name|target
operator|.
name|offset
operator|+
name|bytePos
index|]
operator|!=
name|ste
operator|.
name|term
operator|.
name|byteAt
argument_list|(
name|bytePos
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// Scans to sub-block that has this target fp; only
comment|// called by next(); NOTE: does not set
comment|// startBytePos/suffix as a side effect
DECL|method|scanToSubBlock
specifier|public
name|void
name|scanToSubBlock
parameter_list|(
name|long
name|subFP
parameter_list|)
block|{
assert|assert
operator|!
name|isLeafBlock
assert|;
comment|//if (DEBUG) System.out.println("  scanToSubBlock fp=" + fp + " subFP=" + subFP + " entCount=" + entCount + " lastSubFP=" + lastSubFP);
comment|//assert nextEnt == 0;
if|if
condition|(
name|lastSubFP
operator|==
name|subFP
condition|)
block|{
comment|//if (DEBUG) System.out.println("    already positioned");
return|return;
block|}
assert|assert
name|subFP
operator|<
name|fp
operator|:
literal|"fp="
operator|+
name|fp
operator|+
literal|" subFP="
operator|+
name|subFP
assert|;
specifier|final
name|long
name|targetSubCode
init|=
name|fp
operator|-
name|subFP
decl_stmt|;
comment|//if (DEBUG) System.out.println("    targetSubCode=" + targetSubCode);
while|while
condition|(
literal|true
condition|)
block|{
assert|assert
name|nextEnt
operator|<
name|entCount
assert|;
name|nextEnt
operator|++
expr_stmt|;
specifier|final
name|int
name|code
init|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|versionAutoPrefix
operator|==
literal|false
condition|)
block|{
name|suffixesReader
operator|.
name|skipBytes
argument_list|(
name|code
operator|>>>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|final
name|long
name|subCode
init|=
name|suffixesReader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
if|if
condition|(
name|targetSubCode
operator|==
name|subCode
condition|)
block|{
comment|//if (DEBUG) System.out.println("        match!");
name|lastSubFP
operator|=
name|subFP
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|flag
init|=
name|code
operator|&
literal|3
decl_stmt|;
name|suffixesReader
operator|.
name|skipBytes
argument_list|(
name|code
operator|>>>
literal|2
argument_list|)
expr_stmt|;
comment|//if (DEBUG) System.out.println("    " + nextEnt + " (of " + entCount + ") ent isSubBlock=" + ((code&1)==1));
if|if
condition|(
name|flag
operator|==
literal|1
condition|)
block|{
comment|// Sub-block
specifier|final
name|long
name|subCode
init|=
name|suffixesReader
operator|.
name|readVLong
argument_list|()
decl_stmt|;
comment|//if (DEBUG) System.out.println("      subCode=" + subCode);
if|if
condition|(
name|targetSubCode
operator|==
name|subCode
condition|)
block|{
comment|//if (DEBUG) System.out.println("        match!");
name|lastSubFP
operator|=
name|subFP
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|2
operator|||
name|flag
operator|==
literal|3
condition|)
block|{
comment|// Floor'd prefix term
name|suffixesReader
operator|.
name|readByte
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// NOTE: sets startBytePos/suffix as a side effect
DECL|method|scanToTerm
specifier|public
name|SeekStatus
name|scanToTerm
parameter_list|(
name|BytesRef
name|target
parameter_list|,
name|boolean
name|exactOnly
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isLeafBlock
condition|?
name|scanToTermLeaf
argument_list|(
name|target
argument_list|,
name|exactOnly
argument_list|)
else|:
name|scanToTermNonLeaf
argument_list|(
name|target
argument_list|,
name|exactOnly
argument_list|)
return|;
block|}
DECL|field|startBytePos
specifier|private
name|int
name|startBytePos
decl_stmt|;
DECL|field|suffix
specifier|private
name|int
name|suffix
decl_stmt|;
DECL|field|subCode
specifier|private
name|long
name|subCode
decl_stmt|;
comment|// for debugging
comment|/*   @SuppressWarnings("unused")   static String brToString(BytesRef b) {     try {       return b.utf8ToString() + " " + b;     } catch (Throwable t) {       // If BytesRef isn't actually UTF8, or it's eg a       // prefix of UTF8 that ends mid-unicode-char, we       // fallback to hex:       return b.toString();     }   }   */
comment|// Target's prefix matches this block's prefix; we
comment|// scan the entries check if the suffix matches.
DECL|method|scanToTermLeaf
specifier|public
name|SeekStatus
name|scanToTermLeaf
parameter_list|(
name|BytesRef
name|target
parameter_list|,
name|boolean
name|exactOnly
parameter_list|)
throws|throws
name|IOException
block|{
comment|// if (DEBUG) System.out.println("    scanToTermLeaf: block fp=" + fp + " prefix=" + prefix + " nextEnt=" + nextEnt + " (of " + entCount + ") target=" + brToString(target) + " term=" + brToString(term));
assert|assert
name|nextEnt
operator|!=
operator|-
literal|1
assert|;
name|ste
operator|.
name|termExists
operator|=
literal|true
expr_stmt|;
name|subCode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nextEnt
operator|==
name|entCount
condition|)
block|{
if|if
condition|(
name|exactOnly
condition|)
block|{
name|fillTerm
argument_list|()
expr_stmt|;
block|}
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
assert|assert
name|prefixMatches
argument_list|(
name|target
argument_list|)
assert|;
comment|// Loop over each entry (term or sub-block) in this block:
comment|//nextTerm: while(nextEnt< entCount) {
name|nextTerm
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|nextEnt
operator|++
expr_stmt|;
name|suffix
operator|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
expr_stmt|;
comment|// if (DEBUG) {
comment|//   BytesRef suffixBytesRef = new BytesRef();
comment|//   suffixBytesRef.bytes = suffixBytes;
comment|//   suffixBytesRef.offset = suffixesReader.getPosition();
comment|//   suffixBytesRef.length = suffix;
comment|//   System.out.println("      cycle: term " + (nextEnt-1) + " (of " + entCount + ") suffix=" + brToString(suffixBytesRef));
comment|// }
specifier|final
name|int
name|termLen
init|=
name|prefix
operator|+
name|suffix
decl_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|suffixesReader
operator|.
name|skipBytes
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
specifier|final
name|int
name|targetLimit
init|=
name|target
operator|.
name|offset
operator|+
operator|(
name|target
operator|.
name|length
operator|<
name|termLen
condition|?
name|target
operator|.
name|length
else|:
name|termLen
operator|)
decl_stmt|;
name|int
name|targetPos
init|=
name|target
operator|.
name|offset
operator|+
name|prefix
decl_stmt|;
comment|// Loop over bytes in the suffix, comparing to
comment|// the target
name|int
name|bytePos
init|=
name|startBytePos
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|cmp
decl_stmt|;
specifier|final
name|boolean
name|stop
decl_stmt|;
if|if
condition|(
name|targetPos
operator|<
name|targetLimit
condition|)
block|{
name|cmp
operator|=
operator|(
name|suffixBytes
index|[
name|bytePos
operator|++
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|targetPos
operator|++
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|stop
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|targetPos
operator|==
name|targetLimit
assert|;
name|cmp
operator|=
name|termLen
operator|-
name|target
operator|.
name|length
expr_stmt|;
name|stop
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// Current entry is still before the target;
comment|// keep scanning
if|if
condition|(
name|nextEnt
operator|==
name|entCount
condition|)
block|{
comment|// We are done scanning this block
break|break
name|nextTerm
break|;
block|}
else|else
block|{
continue|continue
name|nextTerm
continue|;
block|}
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// Done!  Current entry is after target --
comment|// return NOT_FOUND:
name|fillTerm
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("        not found");
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
elseif|else
if|if
condition|(
name|stop
condition|)
block|{
comment|// Exact match!
comment|// This cannot be a sub-block because we
comment|// would have followed the index to this
comment|// sub-block from the start:
assert|assert
name|ste
operator|.
name|termExists
assert|;
name|fillTerm
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("        found!");
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
block|}
block|}
comment|// It is possible (and OK) that terms index pointed us
comment|// at this block, but, we scanned the entire block and
comment|// did not find the term to position to.  This happens
comment|// when the target is after the last term in the block
comment|// (but, before the next term in the index).  EG
comment|// target could be foozzz, and terms index pointed us
comment|// to the foo* block, but the last term in this block
comment|// was fooz (and, eg, first term in the next block will
comment|// bee fop).
comment|//if (DEBUG) System.out.println("      block end");
if|if
condition|(
name|exactOnly
condition|)
block|{
name|fillTerm
argument_list|()
expr_stmt|;
block|}
comment|// TODO: not consistent that in the
comment|// not-exact case we don't next() into the next
comment|// frame here
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
comment|// Target's prefix matches this block's prefix; we
comment|// scan the entries check if the suffix matches.
DECL|method|scanToTermNonLeaf
specifier|public
name|SeekStatus
name|scanToTermNonLeaf
parameter_list|(
name|BytesRef
name|target
parameter_list|,
name|boolean
name|exactOnly
parameter_list|)
throws|throws
name|IOException
block|{
comment|//if (DEBUG) System.out.println("    scanToTermNonLeaf: block fp=" + fp + " prefix=" + prefix + " nextEnt=" + nextEnt + " (of " + entCount + ") target=" + brToString(target) + " term=" + brToString(target));
assert|assert
name|nextEnt
operator|!=
operator|-
literal|1
assert|;
if|if
condition|(
name|nextEnt
operator|==
name|entCount
condition|)
block|{
if|if
condition|(
name|exactOnly
condition|)
block|{
name|fillTerm
argument_list|()
expr_stmt|;
name|ste
operator|.
name|termExists
operator|=
name|subCode
operator|==
literal|0
expr_stmt|;
block|}
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
assert|assert
name|prefixMatches
argument_list|(
name|target
argument_list|)
assert|;
comment|// Loop over each entry (term or sub-block) in this block:
name|nextTerm
label|:
while|while
condition|(
name|nextEnt
operator|<
name|entCount
condition|)
block|{
name|nextEnt
operator|++
expr_stmt|;
specifier|final
name|int
name|code
init|=
name|suffixesReader
operator|.
name|readVInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|versionAutoPrefix
operator|==
literal|false
condition|)
block|{
name|suffix
operator|=
name|code
operator|>>>
literal|1
expr_stmt|;
block|}
else|else
block|{
name|suffix
operator|=
name|code
operator|>>>
literal|2
expr_stmt|;
block|}
comment|//if (DEBUG) {
comment|//  BytesRef suffixBytesRef = new BytesRef();
comment|//  suffixBytesRef.bytes = suffixBytes;
comment|//  suffixBytesRef.offset = suffixesReader.getPosition();
comment|//  suffixBytesRef.length = suffix;
comment|//  System.out.println("      cycle: " + ((code&1)==1 ? "sub-block" : "term") + " " + (nextEnt-1) + " (of " + entCount + ") suffix=" + brToString(suffixBytesRef));
comment|//}
specifier|final
name|int
name|termLen
init|=
name|prefix
operator|+
name|suffix
decl_stmt|;
name|startBytePos
operator|=
name|suffixesReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|suffixesReader
operator|.
name|skipBytes
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|versionAutoPrefix
operator|==
literal|false
condition|)
block|{
name|ste
operator|.
name|termExists
operator|=
operator|(
name|code
operator|&
literal|1
operator|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|ste
operator|.
name|termExists
condition|)
block|{
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
name|subCode
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|subCode
operator|=
name|suffixesReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|lastSubFP
operator|=
name|fp
operator|-
name|subCode
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|code
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
comment|// Normal term
name|ste
operator|.
name|termExists
operator|=
literal|true
expr_stmt|;
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
name|subCode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|// Sub-block
name|ste
operator|.
name|termExists
operator|=
literal|false
expr_stmt|;
name|subCode
operator|=
name|suffixesReader
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|lastSubFP
operator|=
name|fp
operator|-
name|subCode
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
comment|// Floor prefix term: skip it
comment|//if (DEBUG) System.out.println("        skip floor prefix term");
name|suffixesReader
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|ste
operator|.
name|termExists
operator|=
literal|false
expr_stmt|;
name|state
operator|.
name|termBlockOrd
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
specifier|final
name|int
name|targetLimit
init|=
name|target
operator|.
name|offset
operator|+
operator|(
name|target
operator|.
name|length
operator|<
name|termLen
condition|?
name|target
operator|.
name|length
else|:
name|termLen
operator|)
decl_stmt|;
name|int
name|targetPos
init|=
name|target
operator|.
name|offset
operator|+
name|prefix
decl_stmt|;
comment|// Loop over bytes in the suffix, comparing to
comment|// the target
name|int
name|bytePos
init|=
name|startBytePos
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|cmp
decl_stmt|;
specifier|final
name|boolean
name|stop
decl_stmt|;
if|if
condition|(
name|targetPos
operator|<
name|targetLimit
condition|)
block|{
name|cmp
operator|=
operator|(
name|suffixBytes
index|[
name|bytePos
operator|++
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|target
operator|.
name|bytes
index|[
name|targetPos
operator|++
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|stop
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|targetPos
operator|==
name|targetLimit
assert|;
name|cmp
operator|=
name|termLen
operator|-
name|target
operator|.
name|length
expr_stmt|;
name|stop
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// Current entry is still before the target;
comment|// keep scanning
continue|continue
name|nextTerm
continue|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// Done!  Current entry is after target --
comment|// return NOT_FOUND:
name|fillTerm
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("        maybe done exactOnly=" + exactOnly + " ste.termExists=" + ste.termExists);
if|if
condition|(
operator|!
name|exactOnly
operator|&&
operator|!
name|ste
operator|.
name|termExists
condition|)
block|{
comment|//System.out.println("  now pushFrame");
comment|// TODO this
comment|// We are on a sub-block, and caller wants
comment|// us to position to the next term after
comment|// the target, so we must recurse into the
comment|// sub-frame(s):
name|ste
operator|.
name|currentFrame
operator|=
name|ste
operator|.
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|ste
operator|.
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|termLen
argument_list|)
expr_stmt|;
name|ste
operator|.
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
while|while
condition|(
name|ste
operator|.
name|currentFrame
operator|.
name|next
argument_list|()
condition|)
block|{
name|ste
operator|.
name|currentFrame
operator|=
name|ste
operator|.
name|pushFrame
argument_list|(
literal|null
argument_list|,
name|ste
operator|.
name|currentFrame
operator|.
name|lastSubFP
argument_list|,
name|ste
operator|.
name|term
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|ste
operator|.
name|currentFrame
operator|.
name|loadBlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|//if (DEBUG) System.out.println("        not found");
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
elseif|else
if|if
condition|(
name|stop
condition|)
block|{
comment|// Exact match!
comment|// This cannot be a sub-block because we
comment|// would have followed the index to this
comment|// sub-block from the start:
assert|assert
name|ste
operator|.
name|termExists
assert|;
name|fillTerm
argument_list|()
expr_stmt|;
comment|//if (DEBUG) System.out.println("        found!");
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
block|}
block|}
comment|// It is possible (and OK) that terms index pointed us
comment|// at this block, but, we scanned the entire block and
comment|// did not find the term to position to.  This happens
comment|// when the target is after the last term in the block
comment|// (but, before the next term in the index).  EG
comment|// target could be foozzz, and terms index pointed us
comment|// to the foo* block, but the last term in this block
comment|// was fooz (and, eg, first term in the next block will
comment|// bee fop).
comment|//if (DEBUG) System.out.println("      block end");
if|if
condition|(
name|exactOnly
condition|)
block|{
name|fillTerm
argument_list|()
expr_stmt|;
block|}
comment|// TODO: not consistent that in the
comment|// not-exact case we don't next() into the next
comment|// frame here
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
DECL|method|fillTerm
specifier|private
name|void
name|fillTerm
parameter_list|()
block|{
specifier|final
name|int
name|termLength
init|=
name|prefix
operator|+
name|suffix
decl_stmt|;
name|ste
operator|.
name|term
operator|.
name|setLength
argument_list|(
name|termLength
argument_list|)
expr_stmt|;
name|ste
operator|.
name|term
operator|.
name|grow
argument_list|(
name|termLength
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|suffixBytes
argument_list|,
name|startBytePos
argument_list|,
name|ste
operator|.
name|term
operator|.
name|bytes
argument_list|()
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
block|}
end_class
end_unit
