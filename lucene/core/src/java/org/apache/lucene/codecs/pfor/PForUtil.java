begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.pfor
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|pfor
package|;
end_package
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|IntBuffer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import
begin_comment
comment|/**  * Encode all small values and exception pointers in normal area;  * Encode large values in exception area;  * Size per exception is variable, possibly: 1byte, 2bytes, or 4bytes  */
end_comment
begin_class
DECL|class|PForUtil
specifier|public
specifier|final
class|class
name|PForUtil
extends|extends
name|ForUtil
block|{
DECL|field|PER_EXCEPTION_SIZE
specifier|protected
specifier|static
specifier|final
name|int
index|[]
name|PER_EXCEPTION_SIZE
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|}
decl_stmt|;
comment|/** Compress given int[] into Integer buffer, with PFor format    *    * @param data        uncompressed data    * @param size        num of ints to compress    * @param intBuffer   integer buffer to hold compressed data    */
DECL|method|compress
specifier|public
specifier|static
name|int
name|compress
parameter_list|(
specifier|final
name|int
index|[]
name|data
parameter_list|,
name|int
name|size
parameter_list|,
name|IntBuffer
name|intBuffer
parameter_list|)
block|{
comment|/** estimate minimum compress size to determine numFrameBits */
name|int
name|numBits
init|=
name|getNumBits
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|int
index|[]
name|excValues
init|=
operator|new
name|int
index|[
name|size
index|]
decl_stmt|;
name|int
name|excNum
init|=
literal|0
decl_stmt|,
name|excLastPos
init|=
operator|-
literal|1
decl_stmt|,
name|excFirstPos
init|=
operator|-
literal|1
decl_stmt|,
name|excLastNonForcePos
init|=
operator|-
literal|1
decl_stmt|;
comment|// num of exception until the last non-forced exception
name|int
name|excNumBase
init|=
literal|0
decl_stmt|;
comment|// bytes per exception
name|int
name|excBytes
init|=
literal|1
decl_stmt|;
comment|// bytes before exception area, e.g. header and normal area
name|int
name|excByteOffset
init|=
literal|0
decl_stmt|;
comment|// the max value possible for current exception pointer,
comment|// value of the first pointer is limited by header as 254
name|long
name|maxChain
init|=
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|-
literal|2
decl_stmt|;
name|boolean
name|conValue
decl_stmt|,
name|conForce
decl_stmt|,
name|conEnd
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/** estimate exceptions */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|conValue
operator|=
operator|(
operator|(
name|data
index|[
name|i
index|]
operator|&
name|MASK
index|[
name|numBits
index|]
operator|)
operator|!=
name|data
index|[
name|i
index|]
operator|)
expr_stmt|;
comment|// value exception
name|conForce
operator|=
operator|(
name|i
operator|>=
name|maxChain
operator|+
name|excLastPos
operator|)
expr_stmt|;
comment|// force exception
if|if
condition|(
name|conValue
operator|||
name|conForce
condition|)
block|{
name|excValues
index|[
name|excNum
operator|++
index|]
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|excLastPos
operator|==
operator|-
literal|1
condition|)
block|{
name|maxChain
operator|=
literal|1L
operator|<<
name|numBits
expr_stmt|;
name|excFirstPos
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|conValue
condition|)
block|{
name|excLastNonForcePos
operator|=
name|i
expr_stmt|;
name|excNumBase
operator|=
name|excNum
expr_stmt|;
block|}
name|excLastPos
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/** encode normal area, record exception positions */
name|i
operator|=
literal|0
expr_stmt|;
name|excNum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|excFirstPos
operator|<
literal|0
condition|)
block|{
comment|// no exception
for|for
control|(
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|encodeNormalValue
argument_list|(
name|intBuffer
argument_list|,
name|i
argument_list|,
name|data
index|[
name|i
index|]
argument_list|,
name|numBits
argument_list|)
expr_stmt|;
block|}
name|excLastPos
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|i
operator|<
name|excFirstPos
condition|;
operator|++
name|i
control|)
block|{
name|encodeNormalValue
argument_list|(
name|intBuffer
argument_list|,
name|i
argument_list|,
name|data
index|[
name|i
index|]
argument_list|,
name|numBits
argument_list|)
expr_stmt|;
block|}
name|maxChain
operator|=
literal|1L
operator|<<
name|numBits
expr_stmt|;
name|excLastPos
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|conValue
operator|=
operator|(
operator|(
name|data
index|[
name|i
index|]
operator|&
name|MASK
index|[
name|numBits
index|]
operator|)
operator|!=
name|data
index|[
name|i
index|]
operator|)
expr_stmt|;
comment|// value exception
name|conForce
operator|=
operator|(
name|i
operator|>=
name|maxChain
operator|+
name|excLastPos
operator|)
expr_stmt|;
comment|// force exception
name|conEnd
operator|=
operator|(
name|excNum
operator|==
name|excNumBase
operator|)
expr_stmt|;
comment|// following forced ignored
if|if
condition|(
operator|(
operator|!
name|conValue
operator|&&
operator|!
name|conForce
operator|)
operator|||
name|conEnd
condition|)
block|{
name|encodeNormalValue
argument_list|(
name|intBuffer
argument_list|,
name|i
argument_list|,
name|data
index|[
name|i
index|]
argument_list|,
name|numBits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|excLastPos
operator|>=
literal|0
condition|)
block|{
name|encodeNormalValue
argument_list|(
name|intBuffer
argument_list|,
name|excLastPos
argument_list|,
name|i
operator|-
name|excLastPos
operator|-
literal|1
argument_list|,
name|numBits
argument_list|)
expr_stmt|;
block|}
name|excNum
operator|++
expr_stmt|;
name|excLastPos
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|excLastPos
operator|>=
literal|0
condition|)
block|{
name|encodeNormalValue
argument_list|(
name|intBuffer
argument_list|,
name|excLastPos
argument_list|,
operator|(
name|i
operator|-
name|excLastPos
operator|-
literal|1
operator|)
operator|&
name|MASK
index|[
name|numBits
index|]
argument_list|,
name|numBits
argument_list|)
expr_stmt|;
comment|// mask out suppressed force exception
block|}
block|}
comment|/** encode exception area */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|excNum
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|excBytes
operator|<
literal|2
operator|&&
operator|(
name|excValues
index|[
name|i
index|]
operator|&
operator|~
name|MASK
index|[
literal|8
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|excBytes
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|excBytes
operator|<
literal|4
operator|&&
operator|(
name|excValues
index|[
name|i
index|]
operator|&
operator|~
name|MASK
index|[
literal|16
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|excBytes
operator|=
literal|4
expr_stmt|;
block|}
block|}
name|excByteOffset
operator|=
name|HEADER_INT_SIZE
operator|*
literal|4
operator|+
operator|(
name|size
operator|*
name|numBits
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|encodeExcValues
argument_list|(
name|intBuffer
argument_list|,
name|excValues
argument_list|,
name|excNum
argument_list|,
name|excBytes
argument_list|,
name|excByteOffset
argument_list|)
expr_stmt|;
comment|/** encode header */
name|encodeHeader
argument_list|(
name|intBuffer
argument_list|,
name|size
argument_list|,
name|numBits
argument_list|,
name|excNum
argument_list|,
name|excFirstPos
argument_list|,
name|excBytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|excByteOffset
operator|+
name|excBytes
operator|*
name|excNum
operator|+
literal|3
operator|)
operator|/
literal|4
operator|*
literal|4
return|;
block|}
comment|/** Decompress given Integer buffer into int array.    *    * @param intBuffer   integer buffer to hold compressed data    * @param data        int array to hold uncompressed data    */
DECL|method|decompress
specifier|public
specifier|static
name|int
name|decompress
parameter_list|(
name|IntBuffer
name|intBuffer
parameter_list|,
name|int
index|[]
name|data
parameter_list|)
block|{
comment|// since this buffer is reused at upper level, rewind first
name|intBuffer
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|int
name|header
init|=
name|intBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|int
name|numInts
init|=
operator|(
name|header
operator|&
name|MASK
index|[
literal|8
index|]
operator|)
operator|+
literal|1
decl_stmt|;
name|int
name|excNum
init|=
operator|(
operator|(
name|header
operator|>>
literal|8
operator|)
operator|&
name|MASK
index|[
literal|8
index|]
operator|)
operator|+
literal|1
decl_stmt|;
name|int
name|excFirstPos
init|=
operator|(
operator|(
name|header
operator|>>
literal|16
operator|)
operator|&
name|MASK
index|[
literal|8
index|]
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|excBytes
init|=
name|PER_EXCEPTION_SIZE
index|[
operator|(
name|header
operator|>>
literal|29
operator|)
operator|&
name|MASK
index|[
literal|2
index|]
index|]
decl_stmt|;
name|int
name|numBits
init|=
operator|(
operator|(
name|header
operator|>>
literal|24
operator|)
operator|&
name|MASK
index|[
literal|5
index|]
operator|)
operator|+
literal|1
decl_stmt|;
name|decompressCore
argument_list|(
name|intBuffer
argument_list|,
name|data
argument_list|,
name|numBits
argument_list|)
expr_stmt|;
name|patchException
argument_list|(
name|intBuffer
argument_list|,
name|data
argument_list|,
name|excNum
argument_list|,
name|excFirstPos
argument_list|,
name|excBytes
argument_list|)
expr_stmt|;
return|return
name|numInts
return|;
block|}
DECL|method|encodeHeader
specifier|static
name|void
name|encodeHeader
parameter_list|(
name|IntBuffer
name|intBuffer
parameter_list|,
name|int
name|numInts
parameter_list|,
name|int
name|numBits
parameter_list|,
name|int
name|excNum
parameter_list|,
name|int
name|excFirstPos
parameter_list|,
name|int
name|excBytes
parameter_list|)
block|{
name|int
name|header
init|=
name|getHeader
argument_list|(
name|numInts
argument_list|,
name|numBits
argument_list|,
name|excNum
argument_list|,
name|excFirstPos
argument_list|,
name|excBytes
argument_list|)
decl_stmt|;
name|intBuffer
operator|.
name|put
argument_list|(
literal|0
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
DECL|method|encodeExcValues
specifier|static
name|void
name|encodeExcValues
parameter_list|(
name|IntBuffer
name|intBuffer
parameter_list|,
name|int
index|[]
name|values
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|perbytes
parameter_list|,
name|int
name|byteOffset
parameter_list|)
block|{
if|if
condition|(
name|num
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|perbytes
operator|==
literal|1
condition|)
block|{
name|int
name|curBytePos
init|=
name|byteOffset
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
block|{
name|int
name|curIntPos
init|=
name|curBytePos
operator|/
literal|4
decl_stmt|;
name|setBufferIntBits
argument_list|(
name|intBuffer
argument_list|,
name|curIntPos
argument_list|,
operator|(
name|curBytePos
operator|&
literal|3
operator|)
operator|*
literal|8
argument_list|,
literal|8
argument_list|,
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|curBytePos
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|perbytes
operator|==
literal|2
condition|)
block|{
name|int
name|shortOffset
init|=
operator|(
name|byteOffset
operator|+
literal|1
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|curIntPos
init|=
name|shortOffset
operator|/
literal|2
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|shortOffset
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
block|{
comment|// cut head to ensure remaining fit ints
name|setBufferIntBits
argument_list|(
name|intBuffer
argument_list|,
name|curIntPos
operator|++
argument_list|,
literal|16
argument_list|,
literal|16
argument_list|,
name|values
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|num
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|intBuffer
operator|.
name|put
argument_list|(
name|curIntPos
operator|++
argument_list|,
operator|(
name|values
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|num
condition|)
block|{
name|intBuffer
operator|.
name|put
argument_list|(
name|curIntPos
argument_list|,
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|// cut tail, also clear high 16 bits
block|}
block|}
elseif|else
if|if
condition|(
name|perbytes
operator|==
literal|4
condition|)
block|{
name|int
name|curIntPos
init|=
operator|(
name|byteOffset
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
block|{
name|intBuffer
operator|.
name|put
argument_list|(
name|curIntPos
operator|++
argument_list|,
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Decode exception values base on the exception pointers in normal area,    * and values in exception area.    * As for current implementation, numInts is hardwired as 128, so the    * tail of normal area is naturally aligned to 32 bits, and we don't need to    * rewind intBuffer here.    * However, the normal area may share a same int with exception area,     * when numFrameBits * numInts % 32 != 0,    * In this case we should preprocess patch several heading exceptions,     * before calling this method.    *    * TODO: blockSize is hardewired to size==128 only    */
DECL|method|patchException
specifier|public
specifier|static
name|void
name|patchException
parameter_list|(
name|IntBuffer
name|intBuffer
parameter_list|,
name|int
index|[]
name|data
parameter_list|,
name|int
name|excNum
parameter_list|,
name|int
name|excFirstPos
parameter_list|,
name|int
name|excBytes
parameter_list|)
block|{
if|if
condition|(
name|excFirstPos
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
name|int
name|curPos
init|=
name|excFirstPos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|excBytes
operator|==
literal|1
condition|)
block|{
comment|// each exception consumes 1 byte
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
literal|3
operator|<
name|excNum
condition|;
name|i
operator|+=
literal|4
control|)
block|{
specifier|final
name|int
name|curInt
init|=
name|intBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|curPos
operator|=
name|patch
argument_list|(
name|data
argument_list|,
name|curPos
argument_list|,
operator|(
name|curInt
operator|)
operator|&
name|MASK
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|curPos
operator|=
name|patch
argument_list|(
name|data
argument_list|,
name|curPos
argument_list|,
operator|(
name|curInt
operator|>>>
literal|8
operator|)
operator|&
name|MASK
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|curPos
operator|=
name|patch
argument_list|(
name|data
argument_list|,
name|curPos
argument_list|,
operator|(
name|curInt
operator|>>>
literal|16
operator|)
operator|&
name|MASK
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|curPos
operator|=
name|patch
argument_list|(
name|data
argument_list|,
name|curPos
argument_list|,
operator|(
name|curInt
operator|>>>
literal|24
operator|)
operator|&
name|MASK
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|excNum
condition|)
block|{
specifier|final
name|int
name|curInt
init|=
name|intBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
operator|&&
name|i
operator|<
name|excNum
condition|;
name|j
operator|+=
literal|8
operator|,
name|i
operator|++
control|)
block|{
name|curPos
operator|=
name|patch
argument_list|(
name|data
argument_list|,
name|curPos
argument_list|,
operator|(
name|curInt
operator|>>>
name|j
operator|)
operator|&
name|MASK
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|excBytes
operator|==
literal|2
condition|)
block|{
comment|// each exception consumes 2 bytes
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
literal|1
operator|<
name|excNum
condition|;
name|i
operator|+=
literal|2
control|)
block|{
specifier|final
name|int
name|curInt
init|=
name|intBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|curPos
operator|=
name|patch
argument_list|(
name|data
argument_list|,
name|curPos
argument_list|,
operator|(
name|curInt
operator|)
operator|&
name|MASK
index|[
literal|16
index|]
argument_list|)
expr_stmt|;
name|curPos
operator|=
name|patch
argument_list|(
name|data
argument_list|,
name|curPos
argument_list|,
operator|(
name|curInt
operator|>>>
literal|16
operator|)
operator|&
name|MASK
index|[
literal|16
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|excNum
condition|)
block|{
specifier|final
name|int
name|curInt
init|=
name|intBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|curPos
operator|=
name|patch
argument_list|(
name|data
argument_list|,
name|curPos
argument_list|,
operator|(
name|curInt
operator|)
operator|&
name|MASK
index|[
literal|16
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|excBytes
operator|==
literal|4
condition|)
block|{
comment|// each exception consumes 4 bytes
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|excNum
condition|;
name|i
operator|++
control|)
block|{
name|curPos
operator|=
name|patch
argument_list|(
name|data
argument_list|,
name|curPos
argument_list|,
name|intBuffer
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|patch
specifier|static
name|int
name|patch
parameter_list|(
name|int
index|[]
name|data
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|int
name|nextPos
init|=
name|data
index|[
name|pos
index|]
operator|+
name|pos
operator|+
literal|1
decl_stmt|;
name|data
index|[
name|pos
index|]
operator|=
name|value
expr_stmt|;
assert|assert
name|nextPos
operator|>
name|pos
assert|;
return|return
name|nextPos
return|;
block|}
comment|/**    * Estimate best number of frame bits according to minimum compressed size.    * It will run 32 times.    */
DECL|method|getNumBits
specifier|static
name|int
name|getNumBits
parameter_list|(
specifier|final
name|int
index|[]
name|data
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|optBits
init|=
literal|1
decl_stmt|;
name|int
name|optSize
init|=
name|estimateCompressedSize
argument_list|(
name|data
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<=
literal|32
condition|;
operator|++
name|i
control|)
block|{
name|int
name|curSize
init|=
name|estimateCompressedSize
argument_list|(
name|data
argument_list|,
name|size
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|curSize
operator|<
name|optSize
condition|)
block|{
name|optSize
operator|=
name|curSize
expr_stmt|;
name|optBits
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|optBits
return|;
block|}
comment|/**    * Iterate the whole block to get maximum exception bits,     * and estimate compressed size without forced exception.    * TODO: foresee forced exception for better estimation    */
DECL|method|estimateCompressedSize
specifier|static
name|int
name|estimateCompressedSize
parameter_list|(
specifier|final
name|int
index|[]
name|data
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|numBits
parameter_list|)
block|{
name|int
name|totalBytes
init|=
operator|(
name|numBits
operator|*
name|size
operator|+
literal|7
operator|)
operator|/
literal|8
decl_stmt|;
comment|// always round to byte
name|int
name|excNum
init|=
literal|0
decl_stmt|;
name|int
name|curExcBytes
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|data
index|[
name|i
index|]
operator|&
operator|~
name|MASK
index|[
name|numBits
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// exception
name|excNum
operator|++
expr_stmt|;
if|if
condition|(
name|curExcBytes
operator|<
literal|2
operator|&&
operator|(
name|data
index|[
name|i
index|]
operator|&
operator|~
name|MASK
index|[
literal|8
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// exceed 1 byte exception
name|curExcBytes
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|curExcBytes
operator|<
literal|4
operator|&&
operator|(
name|data
index|[
name|i
index|]
operator|&
operator|~
name|MASK
index|[
literal|16
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// exceed 2 byte exception
name|curExcBytes
operator|=
literal|4
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|curExcBytes
operator|==
literal|2
condition|)
block|{
name|totalBytes
operator|=
operator|(
operator|(
name|totalBytes
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
operator|*
literal|2
expr_stmt|;
comment|// round up to 2x bytes before filling exceptions
block|}
elseif|else
if|if
condition|(
name|curExcBytes
operator|==
literal|4
condition|)
block|{
name|totalBytes
operator|=
operator|(
operator|(
name|totalBytes
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
operator|*
literal|4
expr_stmt|;
comment|// round up to 4x bytes
block|}
name|totalBytes
operator|+=
name|excNum
operator|*
name|curExcBytes
expr_stmt|;
return|return
name|totalBytes
operator|/
literal|4
operator|*
literal|4
operator|+
name|HEADER_INT_SIZE
return|;
comment|// round up to ints
block|}
comment|/**     * Generate the 4 byte header, which contains (from lsb to msb):    *    * 8 bits for uncompressed int num - 1 (use up to 7 bits i.e 128 actually)    *    * 8 bits for exception num - 1 (when no exceptions, this is undefined)    *    * 8 bits for the index of the first exception + 1 (when no exception, this is 0)    *    * 5 bits for num of frame bits - 1    * 2 bits for the exception code: 00: byte, 01: short, 10: int    * 1 bit unused    *    */
DECL|method|getHeader
specifier|static
name|int
name|getHeader
parameter_list|(
name|int
name|numInts
parameter_list|,
name|int
name|numBits
parameter_list|,
name|int
name|excNum
parameter_list|,
name|int
name|excFirstPos
parameter_list|,
name|int
name|excBytes
parameter_list|)
block|{
return|return
operator|(
name|numInts
operator|-
literal|1
operator|)
operator||
operator|(
operator|(
operator|(
name|excNum
operator|-
literal|1
operator|)
operator|&
name|MASK
index|[
literal|8
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|excFirstPos
operator|+
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|numBits
operator|-
literal|1
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|excBytes
operator|/
literal|2
operator|)
operator|<<
literal|29
operator|)
return|;
block|}
block|}
end_class
end_unit
