begin_unit
begin_package
DECL|package|org.apache.lucene.codecs.memory
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|memory
package|;
end_package
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment
begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import
begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|FieldsConsumer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|FieldsProducer
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|PostingsFormat
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|lucene40
operator|.
name|Lucene40PostingsFormat
import|;
end_import
begin_comment
comment|// javadocs
end_comment
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsAndPositionsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|DocsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
operator|.
name|IndexOptions
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|FieldInfo
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Fields
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|OrdTermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentReadState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentWriteState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermState
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Terms
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|TermsEnum
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RAMOutputStream
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|UnmodifiableIterator
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|CompiledAutomaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|RunAutomaton
import|;
end_import
begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|automaton
operator|.
name|Transition
import|;
end_import
begin_comment
comment|// TODO:
end_comment
begin_comment
comment|//   - build depth-N prefix hash?
end_comment
begin_comment
comment|//   - or: longer dense skip lists than just next byte?
end_comment
begin_comment
comment|/** Wraps {@link Lucene40PostingsFormat} format for on-disk  *  storage, but then at read time loads and stores all  *  terms& postings directly in RAM as byte[], int[].  *  *<p><b><font color=red>WARNING</font></b>: This is  *  exceptionally RAM intensive: it makes no effort to  *  compress the postings data, storing terms as separate  *  byte[] and postings as separate int[], but as a result it   *  gives substantial increase in search performance.  *  *<p>This postings format supports {@link TermsEnum#ord}  *  and {@link TermsEnum#seekExact(long)}.   *<p>Because this holds all term bytes as a single  *  byte[], you cannot have more than 2.1GB worth of term  *  bytes in a single segment.  *  * @lucene.experimental */
end_comment
begin_class
DECL|class|DirectPostingsFormat
specifier|public
class|class
name|DirectPostingsFormat
extends|extends
name|PostingsFormat
block|{
DECL|field|minSkipCount
specifier|private
specifier|final
name|int
name|minSkipCount
decl_stmt|;
DECL|field|lowFreqCutoff
specifier|private
specifier|final
name|int
name|lowFreqCutoff
decl_stmt|;
DECL|field|DEFAULT_MIN_SKIP_COUNT
specifier|private
specifier|final
specifier|static
name|int
name|DEFAULT_MIN_SKIP_COUNT
init|=
literal|8
decl_stmt|;
DECL|field|DEFAULT_LOW_FREQ_CUTOFF
specifier|private
specifier|final
specifier|static
name|int
name|DEFAULT_LOW_FREQ_CUTOFF
init|=
literal|32
decl_stmt|;
comment|//private static final boolean DEBUG = true;
comment|// TODO: allow passing/wrapping arbitrary postings format?
DECL|method|DirectPostingsFormat
specifier|public
name|DirectPostingsFormat
parameter_list|()
block|{
name|this
argument_list|(
name|DEFAULT_MIN_SKIP_COUNT
argument_list|,
name|DEFAULT_LOW_FREQ_CUTOFF
argument_list|)
expr_stmt|;
block|}
comment|/** minSkipCount is how many terms in a row must have the    *  same prefix before we put a skip pointer down.  Terms    *  with docFreq<= lowFreqCutoff will use a single int[]    *  to hold all docs, freqs, position and offsets; terms    *  with higher docFreq will use separate arrays. */
DECL|method|DirectPostingsFormat
specifier|public
name|DirectPostingsFormat
parameter_list|(
name|int
name|minSkipCount
parameter_list|,
name|int
name|lowFreqCutoff
parameter_list|)
block|{
name|super
argument_list|(
literal|"Direct"
argument_list|)
expr_stmt|;
name|this
operator|.
name|minSkipCount
operator|=
name|minSkipCount
expr_stmt|;
name|this
operator|.
name|lowFreqCutoff
operator|=
name|lowFreqCutoff
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|fieldsConsumer
specifier|public
name|FieldsConsumer
name|fieldsConsumer
parameter_list|(
name|SegmentWriteState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|PostingsFormat
operator|.
name|forName
argument_list|(
literal|"Lucene40"
argument_list|)
operator|.
name|fieldsConsumer
argument_list|(
name|state
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|fieldsProducer
specifier|public
name|FieldsProducer
name|fieldsProducer
parameter_list|(
name|SegmentReadState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
name|FieldsProducer
name|postings
init|=
name|PostingsFormat
operator|.
name|forName
argument_list|(
literal|"Lucene40"
argument_list|)
operator|.
name|fieldsProducer
argument_list|(
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|.
name|context
operator|.
name|context
operator|!=
name|IOContext
operator|.
name|Context
operator|.
name|MERGE
condition|)
block|{
name|FieldsProducer
name|loadedPostings
decl_stmt|;
try|try
block|{
name|loadedPostings
operator|=
operator|new
name|DirectFields
argument_list|(
name|state
argument_list|,
name|postings
argument_list|,
name|minSkipCount
argument_list|,
name|lowFreqCutoff
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|postings
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|loadedPostings
return|;
block|}
else|else
block|{
comment|// Don't load postings for merge:
return|return
name|postings
return|;
block|}
block|}
DECL|class|DirectFields
specifier|private
specifier|static
specifier|final
class|class
name|DirectFields
extends|extends
name|FieldsProducer
block|{
DECL|field|fields
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|DirectField
argument_list|>
name|fields
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|DirectField
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|DirectFields
specifier|public
name|DirectFields
parameter_list|(
name|SegmentReadState
name|state
parameter_list|,
name|Fields
name|fields
parameter_list|,
name|int
name|minSkipCount
parameter_list|,
name|int
name|lowFreqCutoff
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
name|this
operator|.
name|fields
operator|.
name|put
argument_list|(
name|field
argument_list|,
operator|new
name|DirectField
argument_list|(
name|state
argument_list|,
name|field
argument_list|,
name|fields
operator|.
name|terms
argument_list|(
name|field
argument_list|)
argument_list|,
name|minSkipCount
argument_list|,
name|lowFreqCutoff
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|String
argument_list|>
argument_list|(
name|fields
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|terms
specifier|public
name|Terms
name|terms
parameter_list|(
name|String
name|field
parameter_list|)
block|{
return|return
name|fields
operator|.
name|get
argument_list|(
name|field
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fields
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getUniqueTermCount
specifier|public
name|long
name|getUniqueTermCount
parameter_list|()
block|{
name|long
name|numTerms
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DirectField
name|field
range|:
name|fields
operator|.
name|values
argument_list|()
control|)
block|{
name|numTerms
operator|+=
name|field
operator|.
name|terms
operator|.
name|length
expr_stmt|;
block|}
return|return
name|numTerms
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{     }
block|}
DECL|class|DirectField
specifier|private
specifier|final
specifier|static
class|class
name|DirectField
extends|extends
name|Terms
block|{
DECL|class|TermAndSkip
specifier|private
specifier|static
specifier|abstract
class|class
name|TermAndSkip
block|{
DECL|field|skips
specifier|public
name|int
index|[]
name|skips
decl_stmt|;
block|}
DECL|class|LowFreqTerm
specifier|private
specifier|static
specifier|final
class|class
name|LowFreqTerm
extends|extends
name|TermAndSkip
block|{
DECL|field|postings
specifier|public
specifier|final
name|int
index|[]
name|postings
decl_stmt|;
DECL|field|payloads
specifier|public
specifier|final
name|byte
index|[]
name|payloads
decl_stmt|;
DECL|field|docFreq
specifier|public
specifier|final
name|int
name|docFreq
decl_stmt|;
DECL|field|totalTermFreq
specifier|public
specifier|final
name|int
name|totalTermFreq
decl_stmt|;
DECL|method|LowFreqTerm
specifier|public
name|LowFreqTerm
parameter_list|(
name|int
index|[]
name|postings
parameter_list|,
name|byte
index|[]
name|payloads
parameter_list|,
name|int
name|docFreq
parameter_list|,
name|int
name|totalTermFreq
parameter_list|)
block|{
name|this
operator|.
name|postings
operator|=
name|postings
expr_stmt|;
name|this
operator|.
name|payloads
operator|=
name|payloads
expr_stmt|;
name|this
operator|.
name|docFreq
operator|=
name|docFreq
expr_stmt|;
name|this
operator|.
name|totalTermFreq
operator|=
name|totalTermFreq
expr_stmt|;
block|}
block|}
comment|// TODO: maybe specialize into prx/no-prx/no-frq cases?
DECL|class|HighFreqTerm
specifier|private
specifier|static
specifier|final
class|class
name|HighFreqTerm
extends|extends
name|TermAndSkip
block|{
DECL|field|totalTermFreq
specifier|public
specifier|final
name|long
name|totalTermFreq
decl_stmt|;
DECL|field|docIDs
specifier|public
specifier|final
name|int
index|[]
name|docIDs
decl_stmt|;
DECL|field|freqs
specifier|public
specifier|final
name|int
index|[]
name|freqs
decl_stmt|;
DECL|field|positions
specifier|public
specifier|final
name|int
index|[]
index|[]
name|positions
decl_stmt|;
DECL|field|payloads
specifier|public
specifier|final
name|byte
index|[]
index|[]
index|[]
name|payloads
decl_stmt|;
DECL|method|HighFreqTerm
specifier|public
name|HighFreqTerm
parameter_list|(
name|int
index|[]
name|docIDs
parameter_list|,
name|int
index|[]
name|freqs
parameter_list|,
name|int
index|[]
index|[]
name|positions
parameter_list|,
name|byte
index|[]
index|[]
index|[]
name|payloads
parameter_list|,
name|long
name|totalTermFreq
parameter_list|)
block|{
name|this
operator|.
name|docIDs
operator|=
name|docIDs
expr_stmt|;
name|this
operator|.
name|freqs
operator|=
name|freqs
expr_stmt|;
name|this
operator|.
name|positions
operator|=
name|positions
expr_stmt|;
name|this
operator|.
name|payloads
operator|=
name|payloads
expr_stmt|;
name|this
operator|.
name|totalTermFreq
operator|=
name|totalTermFreq
expr_stmt|;
block|}
block|}
DECL|field|termBytes
specifier|private
specifier|final
name|byte
index|[]
name|termBytes
decl_stmt|;
DECL|field|termOffsets
specifier|private
specifier|final
name|int
index|[]
name|termOffsets
decl_stmt|;
DECL|field|skips
specifier|private
specifier|final
name|int
index|[]
name|skips
decl_stmt|;
DECL|field|skipOffsets
specifier|private
specifier|final
name|int
index|[]
name|skipOffsets
decl_stmt|;
DECL|field|terms
specifier|private
specifier|final
name|TermAndSkip
index|[]
name|terms
decl_stmt|;
DECL|field|hasFreq
specifier|private
specifier|final
name|boolean
name|hasFreq
decl_stmt|;
DECL|field|hasPos
specifier|private
specifier|final
name|boolean
name|hasPos
decl_stmt|;
DECL|field|hasOffsets
specifier|private
specifier|final
name|boolean
name|hasOffsets
decl_stmt|;
DECL|field|hasPayloads
specifier|private
specifier|final
name|boolean
name|hasPayloads
decl_stmt|;
DECL|field|sumTotalTermFreq
specifier|private
specifier|final
name|long
name|sumTotalTermFreq
decl_stmt|;
DECL|field|docCount
specifier|private
specifier|final
name|int
name|docCount
decl_stmt|;
DECL|field|sumDocFreq
specifier|private
specifier|final
name|long
name|sumDocFreq
decl_stmt|;
DECL|field|skipCount
specifier|private
name|int
name|skipCount
decl_stmt|;
comment|// TODO: maybe make a separate builder?  These are only
comment|// used during load:
DECL|field|count
specifier|private
name|int
name|count
decl_stmt|;
DECL|field|sameCounts
specifier|private
name|int
index|[]
name|sameCounts
init|=
operator|new
name|int
index|[
literal|10
index|]
decl_stmt|;
DECL|field|minSkipCount
specifier|private
specifier|final
name|int
name|minSkipCount
decl_stmt|;
DECL|class|IntArrayWriter
specifier|private
specifier|final
specifier|static
class|class
name|IntArrayWriter
block|{
DECL|field|ints
specifier|private
name|int
index|[]
name|ints
init|=
operator|new
name|int
index|[
literal|10
index|]
decl_stmt|;
DECL|field|upto
specifier|private
name|int
name|upto
decl_stmt|;
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|ints
operator|.
name|length
operator|==
name|upto
condition|)
block|{
name|ints
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|ints
argument_list|)
expr_stmt|;
block|}
name|ints
index|[
name|upto
operator|++
index|]
operator|=
name|value
expr_stmt|;
block|}
DECL|method|get
specifier|public
name|int
index|[]
name|get
parameter_list|()
block|{
specifier|final
name|int
index|[]
name|arr
init|=
operator|new
name|int
index|[
name|upto
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ints
argument_list|,
literal|0
argument_list|,
name|arr
argument_list|,
literal|0
argument_list|,
name|upto
argument_list|)
expr_stmt|;
name|upto
operator|=
literal|0
expr_stmt|;
return|return
name|arr
return|;
block|}
block|}
DECL|method|DirectField
specifier|public
name|DirectField
parameter_list|(
name|SegmentReadState
name|state
parameter_list|,
name|String
name|field
parameter_list|,
name|Terms
name|termsIn
parameter_list|,
name|int
name|minSkipCount
parameter_list|,
name|int
name|lowFreqCutoff
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FieldInfo
name|fieldInfo
init|=
name|state
operator|.
name|fieldInfos
operator|.
name|fieldInfo
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|sumTotalTermFreq
operator|=
name|termsIn
operator|.
name|getSumTotalTermFreq
argument_list|()
expr_stmt|;
name|sumDocFreq
operator|=
name|termsIn
operator|.
name|getSumDocFreq
argument_list|()
expr_stmt|;
name|docCount
operator|=
name|termsIn
operator|.
name|getDocCount
argument_list|()
expr_stmt|;
specifier|final
name|int
name|numTerms
init|=
operator|(
name|int
operator|)
name|termsIn
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numTerms
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"codec does not provide Terms.size()"
argument_list|)
throw|;
block|}
name|terms
operator|=
operator|new
name|TermAndSkip
index|[
name|numTerms
index|]
expr_stmt|;
name|termOffsets
operator|=
operator|new
name|int
index|[
literal|1
operator|+
name|numTerms
index|]
expr_stmt|;
name|byte
index|[]
name|termBytes
init|=
operator|new
name|byte
index|[
literal|1024
index|]
decl_stmt|;
name|this
operator|.
name|minSkipCount
operator|=
name|minSkipCount
expr_stmt|;
name|hasFreq
operator|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_ONLY
argument_list|)
operator|>
literal|0
expr_stmt|;
name|hasPos
operator|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS
argument_list|)
operator|>
literal|0
expr_stmt|;
name|hasOffsets
operator|=
name|fieldInfo
operator|.
name|getIndexOptions
argument_list|()
operator|.
name|compareTo
argument_list|(
name|IndexOptions
operator|.
name|DOCS_AND_FREQS_AND_POSITIONS
argument_list|)
operator|>
literal|0
expr_stmt|;
name|hasPayloads
operator|=
name|fieldInfo
operator|.
name|hasPayloads
argument_list|()
expr_stmt|;
name|BytesRef
name|term
decl_stmt|;
name|DocsEnum
name|docsEnum
init|=
literal|null
decl_stmt|;
name|DocsAndPositionsEnum
name|docsAndPositionsEnum
init|=
literal|null
decl_stmt|;
specifier|final
name|TermsEnum
name|termsEnum
init|=
name|termsIn
operator|.
name|iterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|int
name|termOffset
init|=
literal|0
decl_stmt|;
specifier|final
name|IntArrayWriter
name|scratch
init|=
operator|new
name|IntArrayWriter
argument_list|()
decl_stmt|;
comment|// Used for payloads, if any:
specifier|final
name|RAMOutputStream
name|ros
init|=
operator|new
name|RAMOutputStream
argument_list|()
decl_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("\nLOAD terms seg=" + state.segmentInfo.name + " field=" + field + " hasOffsets=" + hasOffsets + " hasFreq=" + hasFreq + " hasPos=" + hasPos + " hasPayloads=" + hasPayloads);
comment|// }
while|while
condition|(
operator|(
name|term
operator|=
name|termsEnum
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|docFreq
init|=
name|termsEnum
operator|.
name|docFreq
argument_list|()
decl_stmt|;
specifier|final
name|long
name|totalTermFreq
init|=
name|termsEnum
operator|.
name|totalTermFreq
argument_list|()
decl_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  term=" + term.utf8ToString());
comment|// }
name|termOffsets
index|[
name|count
index|]
operator|=
name|termOffset
expr_stmt|;
if|if
condition|(
name|termBytes
operator|.
name|length
operator|<
operator|(
name|termOffset
operator|+
name|term
operator|.
name|length
operator|)
condition|)
block|{
name|termBytes
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|termBytes
argument_list|,
name|termOffset
operator|+
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|term
operator|.
name|bytes
argument_list|,
name|term
operator|.
name|offset
argument_list|,
name|termBytes
argument_list|,
name|termOffset
argument_list|,
name|term
operator|.
name|length
argument_list|)
expr_stmt|;
name|termOffset
operator|+=
name|term
operator|.
name|length
expr_stmt|;
name|termOffsets
index|[
name|count
operator|+
literal|1
index|]
operator|=
name|termOffset
expr_stmt|;
if|if
condition|(
name|hasPos
condition|)
block|{
name|docsAndPositionsEnum
operator|=
name|termsEnum
operator|.
name|docsAndPositions
argument_list|(
literal|null
argument_list|,
name|docsAndPositionsEnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|docsEnum
operator|=
name|termsEnum
operator|.
name|docs
argument_list|(
literal|null
argument_list|,
name|docsEnum
argument_list|)
expr_stmt|;
block|}
specifier|final
name|TermAndSkip
name|ent
decl_stmt|;
specifier|final
name|DocsEnum
name|docsEnum2
decl_stmt|;
if|if
condition|(
name|hasPos
condition|)
block|{
name|docsEnum2
operator|=
name|docsAndPositionsEnum
expr_stmt|;
block|}
else|else
block|{
name|docsEnum2
operator|=
name|docsEnum
expr_stmt|;
block|}
name|int
name|docID
decl_stmt|;
if|if
condition|(
name|docFreq
operator|<=
name|lowFreqCutoff
condition|)
block|{
name|ros
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Pack postings for low-freq terms into a single int[]:
while|while
condition|(
operator|(
name|docID
operator|=
name|docsEnum2
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocsEnum
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|scratch
operator|.
name|add
argument_list|(
name|docID
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasFreq
condition|)
block|{
specifier|final
name|int
name|freq
init|=
name|docsEnum2
operator|.
name|freq
argument_list|()
decl_stmt|;
name|scratch
operator|.
name|add
argument_list|(
name|freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasPos
condition|)
block|{
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|freq
condition|;
name|pos
operator|++
control|)
block|{
name|scratch
operator|.
name|add
argument_list|(
name|docsAndPositionsEnum
operator|.
name|nextPosition
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasOffsets
condition|)
block|{
name|scratch
operator|.
name|add
argument_list|(
name|docsAndPositionsEnum
operator|.
name|startOffset
argument_list|()
argument_list|)
expr_stmt|;
name|scratch
operator|.
name|add
argument_list|(
name|docsAndPositionsEnum
operator|.
name|endOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasPayloads
condition|)
block|{
specifier|final
name|BytesRef
name|payload
init|=
name|docsAndPositionsEnum
operator|.
name|getPayload
argument_list|()
decl_stmt|;
if|if
condition|(
name|payload
operator|!=
literal|null
condition|)
block|{
name|scratch
operator|.
name|add
argument_list|(
name|payload
operator|.
name|length
argument_list|)
expr_stmt|;
name|ros
operator|.
name|writeBytes
argument_list|(
name|payload
operator|.
name|bytes
argument_list|,
name|payload
operator|.
name|offset
argument_list|,
name|payload
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scratch
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
specifier|final
name|byte
index|[]
name|payloads
decl_stmt|;
if|if
condition|(
name|hasPayloads
condition|)
block|{
name|ros
operator|.
name|flush
argument_list|()
expr_stmt|;
name|payloads
operator|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|ros
operator|.
name|length
argument_list|()
index|]
expr_stmt|;
name|ros
operator|.
name|writeTo
argument_list|(
name|payloads
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|payloads
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|int
index|[]
name|postings
init|=
name|scratch
operator|.
name|get
argument_list|()
decl_stmt|;
name|ent
operator|=
operator|new
name|LowFreqTerm
argument_list|(
name|postings
argument_list|,
name|payloads
argument_list|,
name|docFreq
argument_list|,
operator|(
name|int
operator|)
name|totalTermFreq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
index|[]
name|docs
init|=
operator|new
name|int
index|[
name|docFreq
index|]
decl_stmt|;
specifier|final
name|int
index|[]
name|freqs
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|positions
decl_stmt|;
specifier|final
name|byte
index|[]
index|[]
index|[]
name|payloads
decl_stmt|;
if|if
condition|(
name|hasFreq
condition|)
block|{
name|freqs
operator|=
operator|new
name|int
index|[
name|docFreq
index|]
expr_stmt|;
if|if
condition|(
name|hasPos
condition|)
block|{
name|positions
operator|=
operator|new
name|int
index|[
name|docFreq
index|]
index|[]
expr_stmt|;
if|if
condition|(
name|hasPayloads
condition|)
block|{
name|payloads
operator|=
operator|new
name|byte
index|[
name|docFreq
index|]
index|[]
index|[]
expr_stmt|;
block|}
else|else
block|{
name|payloads
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|positions
operator|=
literal|null
expr_stmt|;
name|payloads
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|freqs
operator|=
literal|null
expr_stmt|;
name|positions
operator|=
literal|null
expr_stmt|;
name|payloads
operator|=
literal|null
expr_stmt|;
block|}
comment|// Use separate int[] for the postings for high-freq
comment|// terms:
name|int
name|upto
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|docID
operator|=
name|docsEnum2
operator|.
name|nextDoc
argument_list|()
operator|)
operator|!=
name|DocsEnum
operator|.
name|NO_MORE_DOCS
condition|)
block|{
name|docs
index|[
name|upto
index|]
operator|=
name|docID
expr_stmt|;
if|if
condition|(
name|hasFreq
condition|)
block|{
specifier|final
name|int
name|freq
init|=
name|docsEnum2
operator|.
name|freq
argument_list|()
decl_stmt|;
name|freqs
index|[
name|upto
index|]
operator|=
name|freq
expr_stmt|;
if|if
condition|(
name|hasPos
condition|)
block|{
specifier|final
name|int
name|mult
decl_stmt|;
if|if
condition|(
name|hasOffsets
condition|)
block|{
name|mult
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|mult
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hasPayloads
condition|)
block|{
name|payloads
index|[
name|upto
index|]
operator|=
operator|new
name|byte
index|[
name|freq
index|]
index|[]
expr_stmt|;
block|}
name|positions
index|[
name|upto
index|]
operator|=
operator|new
name|int
index|[
name|mult
operator|*
name|freq
index|]
expr_stmt|;
name|int
name|posUpto
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|freq
condition|;
name|pos
operator|++
control|)
block|{
name|positions
index|[
name|upto
index|]
index|[
name|posUpto
index|]
operator|=
name|docsAndPositionsEnum
operator|.
name|nextPosition
argument_list|()
expr_stmt|;
if|if
condition|(
name|hasPayloads
condition|)
block|{
name|BytesRef
name|payload
init|=
name|docsAndPositionsEnum
operator|.
name|getPayload
argument_list|()
decl_stmt|;
if|if
condition|(
name|payload
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|payloadBytes
init|=
operator|new
name|byte
index|[
name|payload
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|payload
operator|.
name|bytes
argument_list|,
name|payload
operator|.
name|offset
argument_list|,
name|payloadBytes
argument_list|,
literal|0
argument_list|,
name|payload
operator|.
name|length
argument_list|)
expr_stmt|;
name|payloads
index|[
name|upto
index|]
index|[
name|pos
index|]
operator|=
name|payloadBytes
expr_stmt|;
block|}
block|}
name|posUpto
operator|++
expr_stmt|;
if|if
condition|(
name|hasOffsets
condition|)
block|{
name|positions
index|[
name|upto
index|]
index|[
name|posUpto
operator|++
index|]
operator|=
name|docsAndPositionsEnum
operator|.
name|startOffset
argument_list|()
expr_stmt|;
name|positions
index|[
name|upto
index|]
index|[
name|posUpto
operator|++
index|]
operator|=
name|docsAndPositionsEnum
operator|.
name|endOffset
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
name|upto
operator|++
expr_stmt|;
block|}
assert|assert
name|upto
operator|==
name|docFreq
assert|;
name|ent
operator|=
operator|new
name|HighFreqTerm
argument_list|(
name|docs
argument_list|,
name|freqs
argument_list|,
name|positions
argument_list|,
name|payloads
argument_list|,
name|totalTermFreq
argument_list|)
expr_stmt|;
block|}
name|terms
index|[
name|count
index|]
operator|=
name|ent
expr_stmt|;
name|setSkips
argument_list|(
name|count
argument_list|,
name|termBytes
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|// End sentinel:
name|termOffsets
index|[
name|count
index|]
operator|=
name|termOffset
expr_stmt|;
name|finishSkips
argument_list|()
expr_stmt|;
comment|//System.out.println(skipCount + " skips: " + field);
name|this
operator|.
name|termBytes
operator|=
operator|new
name|byte
index|[
name|termOffset
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|termBytes
argument_list|,
literal|0
argument_list|,
name|this
operator|.
name|termBytes
argument_list|,
literal|0
argument_list|,
name|termOffset
argument_list|)
expr_stmt|;
comment|// Pack skips:
name|this
operator|.
name|skips
operator|=
operator|new
name|int
index|[
name|skipCount
index|]
expr_stmt|;
name|this
operator|.
name|skipOffsets
operator|=
operator|new
name|int
index|[
literal|1
operator|+
name|numTerms
index|]
expr_stmt|;
name|int
name|skipOffset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTerms
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
index|[]
name|termSkips
init|=
name|terms
index|[
name|i
index|]
operator|.
name|skips
decl_stmt|;
name|skipOffsets
index|[
name|i
index|]
operator|=
name|skipOffset
expr_stmt|;
if|if
condition|(
name|termSkips
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|termSkips
argument_list|,
literal|0
argument_list|,
name|skips
argument_list|,
name|skipOffset
argument_list|,
name|termSkips
operator|.
name|length
argument_list|)
expr_stmt|;
name|skipOffset
operator|+=
name|termSkips
operator|.
name|length
expr_stmt|;
name|terms
index|[
name|i
index|]
operator|.
name|skips
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|this
operator|.
name|skipOffsets
index|[
name|numTerms
index|]
operator|=
name|skipOffset
expr_stmt|;
assert|assert
name|skipOffset
operator|==
name|skipCount
assert|;
block|}
comment|// Compares in unicode (UTF8) order:
DECL|method|compare
name|int
name|compare
parameter_list|(
name|int
name|ord
parameter_list|,
name|BytesRef
name|other
parameter_list|)
block|{
specifier|final
name|byte
index|[]
name|otherBytes
init|=
name|other
operator|.
name|bytes
decl_stmt|;
name|int
name|upto
init|=
name|termOffsets
index|[
name|ord
index|]
decl_stmt|;
specifier|final
name|int
name|termLen
init|=
name|termOffsets
index|[
literal|1
operator|+
name|ord
index|]
operator|-
name|upto
decl_stmt|;
name|int
name|otherUpto
init|=
name|other
operator|.
name|offset
decl_stmt|;
specifier|final
name|int
name|stop
init|=
name|upto
operator|+
name|Math
operator|.
name|min
argument_list|(
name|termLen
argument_list|,
name|other
operator|.
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|stop
condition|)
block|{
name|int
name|diff
init|=
operator|(
name|termBytes
index|[
name|upto
operator|++
index|]
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|otherBytes
index|[
name|otherUpto
operator|++
index|]
operator|&
literal|0xFF
operator|)
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
block|{
return|return
name|diff
return|;
block|}
block|}
comment|// One is a prefix of the other, or, they are equal:
return|return
name|termLen
operator|-
name|other
operator|.
name|length
return|;
block|}
DECL|method|setSkips
specifier|private
name|void
name|setSkips
parameter_list|(
name|int
name|termOrd
parameter_list|,
name|byte
index|[]
name|termBytes
parameter_list|)
block|{
specifier|final
name|int
name|termLength
init|=
name|termOffsets
index|[
name|termOrd
operator|+
literal|1
index|]
operator|-
name|termOffsets
index|[
name|termOrd
index|]
decl_stmt|;
if|if
condition|(
name|sameCounts
operator|.
name|length
operator|<
name|termLength
condition|)
block|{
name|sameCounts
operator|=
name|ArrayUtil
operator|.
name|grow
argument_list|(
name|sameCounts
argument_list|,
name|termLength
argument_list|)
expr_stmt|;
block|}
comment|// Update skip pointers:
if|if
condition|(
name|termOrd
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|lastTermLength
init|=
name|termOffsets
index|[
name|termOrd
index|]
operator|-
name|termOffsets
index|[
name|termOrd
operator|-
literal|1
index|]
decl_stmt|;
specifier|final
name|int
name|limit
init|=
name|Math
operator|.
name|min
argument_list|(
name|termLength
argument_list|,
name|lastTermLength
argument_list|)
decl_stmt|;
name|int
name|lastTermOffset
init|=
name|termOffsets
index|[
name|termOrd
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|termOffset
init|=
name|termOffsets
index|[
name|termOrd
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|termBytes
index|[
name|lastTermOffset
operator|++
index|]
operator|==
name|termBytes
index|[
name|termOffset
operator|++
index|]
condition|)
block|{
name|sameCounts
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sameCounts
index|[
name|i
index|]
operator|>=
name|minSkipCount
condition|)
block|{
comment|// Go back and add a skip pointer:
name|saveSkip
argument_list|(
name|termOrd
argument_list|,
name|sameCounts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sameCounts
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
for|for
control|(
init|;
name|i
operator|<
name|lastTermLength
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sameCounts
index|[
name|i
index|]
operator|>=
name|minSkipCount
condition|)
block|{
comment|// Go back and add a skip pointer:
name|saveSkip
argument_list|(
name|termOrd
argument_list|,
name|sameCounts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sameCounts
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
name|limit
init|;
name|j
operator|<
name|termLength
condition|;
name|j
operator|++
control|)
block|{
name|sameCounts
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|termLength
condition|;
name|i
operator|++
control|)
block|{
name|sameCounts
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
DECL|method|finishSkips
specifier|private
name|void
name|finishSkips
parameter_list|()
block|{
assert|assert
name|count
operator|==
name|terms
operator|.
name|length
assert|;
name|int
name|lastTermOffset
init|=
name|termOffsets
index|[
name|count
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|lastTermLength
init|=
name|termOffsets
index|[
name|count
index|]
operator|-
name|lastTermOffset
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lastTermLength
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sameCounts
index|[
name|i
index|]
operator|>=
name|minSkipCount
condition|)
block|{
comment|// Go back and add a skip pointer:
name|saveSkip
argument_list|(
name|count
argument_list|,
name|sameCounts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Reverse the skip pointers so they are "nested":
for|for
control|(
name|int
name|termID
init|=
literal|0
init|;
name|termID
operator|<
name|terms
operator|.
name|length
condition|;
name|termID
operator|++
control|)
block|{
name|TermAndSkip
name|term
init|=
name|terms
index|[
name|termID
index|]
decl_stmt|;
if|if
condition|(
name|term
operator|.
name|skips
operator|!=
literal|null
operator|&&
name|term
operator|.
name|skips
operator|.
name|length
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|term
operator|.
name|skips
operator|.
name|length
operator|/
literal|2
condition|;
name|pos
operator|++
control|)
block|{
specifier|final
name|int
name|otherPos
init|=
name|term
operator|.
name|skips
operator|.
name|length
operator|-
name|pos
operator|-
literal|1
decl_stmt|;
specifier|final
name|int
name|temp
init|=
name|term
operator|.
name|skips
index|[
name|pos
index|]
decl_stmt|;
name|term
operator|.
name|skips
index|[
name|pos
index|]
operator|=
name|term
operator|.
name|skips
index|[
name|otherPos
index|]
expr_stmt|;
name|term
operator|.
name|skips
index|[
name|otherPos
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|saveSkip
specifier|private
name|void
name|saveSkip
parameter_list|(
name|int
name|ord
parameter_list|,
name|int
name|backCount
parameter_list|)
block|{
specifier|final
name|TermAndSkip
name|term
init|=
name|terms
index|[
name|ord
operator|-
name|backCount
index|]
decl_stmt|;
name|skipCount
operator|++
expr_stmt|;
if|if
condition|(
name|term
operator|.
name|skips
operator|==
literal|null
condition|)
block|{
name|term
operator|.
name|skips
operator|=
operator|new
name|int
index|[]
block|{
name|ord
block|}
expr_stmt|;
block|}
else|else
block|{
comment|// Normally we'd grow at a slight exponential... but
comment|// given that the skips themselves are already log(N)
comment|// we can grow by only 1 and still have amortized
comment|// linear time:
specifier|final
name|int
index|[]
name|newSkips
init|=
operator|new
name|int
index|[
name|term
operator|.
name|skips
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|term
operator|.
name|skips
argument_list|,
literal|0
argument_list|,
name|newSkips
argument_list|,
literal|0
argument_list|,
name|term
operator|.
name|skips
operator|.
name|length
argument_list|)
expr_stmt|;
name|term
operator|.
name|skips
operator|=
name|newSkips
expr_stmt|;
name|term
operator|.
name|skips
index|[
name|term
operator|.
name|skips
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|ord
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|TermsEnum
name|iterator
parameter_list|(
name|TermsEnum
name|reuse
parameter_list|)
block|{
name|DirectTermsEnum
name|termsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|!=
literal|null
operator|&&
name|reuse
operator|instanceof
name|DirectTermsEnum
condition|)
block|{
name|termsEnum
operator|=
operator|(
name|DirectTermsEnum
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
operator|!
name|termsEnum
operator|.
name|canReuse
argument_list|(
name|terms
argument_list|)
condition|)
block|{
name|termsEnum
operator|=
operator|new
name|DirectTermsEnum
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|termsEnum
operator|=
operator|new
name|DirectTermsEnum
argument_list|()
expr_stmt|;
block|}
name|termsEnum
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
name|termsEnum
return|;
block|}
annotation|@
name|Override
DECL|method|intersect
specifier|public
name|TermsEnum
name|intersect
parameter_list|(
name|CompiledAutomaton
name|compiled
parameter_list|,
specifier|final
name|BytesRef
name|startTerm
parameter_list|)
block|{
return|return
operator|new
name|DirectIntersectTermsEnum
argument_list|(
name|compiled
argument_list|,
name|startTerm
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|long
name|size
parameter_list|()
block|{
return|return
name|terms
operator|.
name|length
return|;
block|}
annotation|@
name|Override
DECL|method|getSumTotalTermFreq
specifier|public
name|long
name|getSumTotalTermFreq
parameter_list|()
block|{
return|return
name|sumTotalTermFreq
return|;
block|}
annotation|@
name|Override
DECL|method|getSumDocFreq
specifier|public
name|long
name|getSumDocFreq
parameter_list|()
block|{
return|return
name|sumDocFreq
return|;
block|}
annotation|@
name|Override
DECL|method|getDocCount
specifier|public
name|int
name|getDocCount
parameter_list|()
block|{
return|return
name|docCount
return|;
block|}
annotation|@
name|Override
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hasOffsets
specifier|public
name|boolean
name|hasOffsets
parameter_list|()
block|{
return|return
name|hasOffsets
return|;
block|}
annotation|@
name|Override
DECL|method|hasPositions
specifier|public
name|boolean
name|hasPositions
parameter_list|()
block|{
return|return
name|hasPos
return|;
block|}
annotation|@
name|Override
DECL|method|hasPayloads
specifier|public
name|boolean
name|hasPayloads
parameter_list|()
block|{
return|return
name|hasPayloads
return|;
block|}
DECL|class|DirectTermsEnum
specifier|private
specifier|final
class|class
name|DirectTermsEnum
extends|extends
name|TermsEnum
block|{
DECL|field|scratch
specifier|private
specifier|final
name|BytesRef
name|scratch
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
DECL|field|termOrd
specifier|private
name|int
name|termOrd
decl_stmt|;
DECL|method|canReuse
name|boolean
name|canReuse
parameter_list|(
name|TermAndSkip
index|[]
name|other
parameter_list|)
block|{
return|return
name|DirectField
operator|.
name|this
operator|.
name|terms
operator|==
name|other
return|;
block|}
DECL|method|setTerm
specifier|private
name|BytesRef
name|setTerm
parameter_list|()
block|{
name|scratch
operator|.
name|bytes
operator|=
name|termBytes
expr_stmt|;
name|scratch
operator|.
name|offset
operator|=
name|termOffsets
index|[
name|termOrd
index|]
expr_stmt|;
name|scratch
operator|.
name|length
operator|=
name|termOffsets
index|[
name|termOrd
operator|+
literal|1
index|]
operator|-
name|termOffsets
index|[
name|termOrd
index|]
expr_stmt|;
return|return
name|scratch
return|;
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|termOrd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
block|{
name|termOrd
operator|++
expr_stmt|;
if|if
condition|(
name|termOrd
operator|<
name|terms
operator|.
name|length
condition|)
block|{
return|return
name|setTerm
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|termState
specifier|public
name|TermState
name|termState
parameter_list|()
block|{
name|OrdTermState
name|state
init|=
operator|new
name|OrdTermState
argument_list|()
decl_stmt|;
name|state
operator|.
name|ord
operator|=
name|termOrd
expr_stmt|;
return|return
name|state
return|;
block|}
comment|// If non-negative, exact match; else, -ord-1, where ord
comment|// is where you would insert the term.
DECL|method|findTerm
specifier|private
name|int
name|findTerm
parameter_list|(
name|BytesRef
name|term
parameter_list|)
block|{
comment|// Just do binary search: should be (constant factor)
comment|// faster than using the skip list:
name|int
name|low
init|=
literal|0
decl_stmt|;
name|int
name|high
init|=
name|terms
operator|.
name|length
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|int
name|cmp
init|=
name|compare
argument_list|(
name|mid
argument_list|,
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
name|mid
return|;
comment|// key found
block|}
block|}
return|return
operator|-
operator|(
name|low
operator|+
literal|1
operator|)
return|;
comment|// key not found.
block|}
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
name|BytesRef
name|term
parameter_list|,
name|boolean
name|useCache
parameter_list|)
block|{
comment|// TODO: we should use the skip pointers; should be
comment|// faster than bin search; we should also hold
comment|//& reuse current state so seeking forwards is
comment|// faster
specifier|final
name|int
name|ord
init|=
name|findTerm
argument_list|(
name|term
argument_list|)
decl_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  find term=" + term.utf8ToString() + " ord=" + ord);
comment|// }
if|if
condition|(
name|ord
operator|>=
literal|0
condition|)
block|{
name|termOrd
operator|=
name|ord
expr_stmt|;
name|setTerm
argument_list|()
expr_stmt|;
return|return
name|SeekStatus
operator|.
name|FOUND
return|;
block|}
elseif|else
if|if
condition|(
name|ord
operator|==
operator|-
name|terms
operator|.
name|length
operator|-
literal|1
condition|)
block|{
return|return
name|SeekStatus
operator|.
name|END
return|;
block|}
else|else
block|{
name|termOrd
operator|=
operator|-
name|ord
operator|-
literal|1
expr_stmt|;
name|setTerm
argument_list|()
expr_stmt|;
return|return
name|SeekStatus
operator|.
name|NOT_FOUND
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|boolean
name|seekExact
parameter_list|(
name|BytesRef
name|term
parameter_list|,
name|boolean
name|useCache
parameter_list|)
block|{
comment|// TODO: we should use the skip pointers; should be
comment|// faster than bin search; we should also hold
comment|//& reuse current state so seeking forwards is
comment|// faster
specifier|final
name|int
name|ord
init|=
name|findTerm
argument_list|(
name|term
argument_list|)
decl_stmt|;
if|if
condition|(
name|ord
operator|>=
literal|0
condition|)
block|{
name|termOrd
operator|=
name|ord
expr_stmt|;
name|setTerm
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|ord
parameter_list|)
block|{
name|termOrd
operator|=
operator|(
name|int
operator|)
name|ord
expr_stmt|;
name|setTerm
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|BytesRef
name|term
parameter_list|,
name|TermState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
name|termOrd
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|OrdTermState
operator|)
name|state
argument_list|)
operator|.
name|ord
expr_stmt|;
name|setTerm
argument_list|()
expr_stmt|;
assert|assert
name|term
operator|.
name|equals
argument_list|(
name|scratch
argument_list|)
assert|;
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
block|{
return|return
name|scratch
return|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
block|{
return|return
name|termOrd
return|;
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
block|{
if|if
condition|(
name|terms
index|[
name|termOrd
index|]
operator|instanceof
name|LowFreqTerm
condition|)
block|{
return|return
operator|(
operator|(
name|LowFreqTerm
operator|)
name|terms
index|[
name|termOrd
index|]
operator|)
operator|.
name|docFreq
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|HighFreqTerm
operator|)
name|terms
index|[
name|termOrd
index|]
operator|)
operator|.
name|docIDs
operator|.
name|length
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
block|{
if|if
condition|(
name|terms
index|[
name|termOrd
index|]
operator|instanceof
name|LowFreqTerm
condition|)
block|{
return|return
operator|(
operator|(
name|LowFreqTerm
operator|)
name|terms
index|[
name|termOrd
index|]
operator|)
operator|.
name|totalTermFreq
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|HighFreqTerm
operator|)
name|terms
index|[
name|termOrd
index|]
operator|)
operator|.
name|totalTermFreq
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|// TODO: implement reuse, something like Pulsing:
comment|// it's hairy!
if|if
condition|(
name|terms
index|[
name|termOrd
index|]
operator|instanceof
name|LowFreqTerm
condition|)
block|{
specifier|final
name|int
index|[]
name|postings
init|=
operator|(
operator|(
name|LowFreqTerm
operator|)
name|terms
index|[
name|termOrd
index|]
operator|)
operator|.
name|postings
decl_stmt|;
if|if
condition|(
name|hasFreq
condition|)
block|{
if|if
condition|(
name|hasPos
condition|)
block|{
name|int
name|posLen
decl_stmt|;
if|if
condition|(
name|hasOffsets
condition|)
block|{
name|posLen
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|posLen
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hasPayloads
condition|)
block|{
name|posLen
operator|++
expr_stmt|;
block|}
name|LowFreqDocsEnum
name|docsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|instanceof
name|LowFreqDocsEnum
condition|)
block|{
name|docsEnum
operator|=
operator|(
name|LowFreqDocsEnum
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
operator|!
name|docsEnum
operator|.
name|canReuse
argument_list|(
name|liveDocs
argument_list|,
name|posLen
argument_list|)
condition|)
block|{
name|docsEnum
operator|=
operator|new
name|LowFreqDocsEnum
argument_list|(
name|liveDocs
argument_list|,
name|posLen
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|docsEnum
operator|=
operator|new
name|LowFreqDocsEnum
argument_list|(
name|liveDocs
argument_list|,
name|posLen
argument_list|)
expr_stmt|;
block|}
return|return
name|docsEnum
operator|.
name|reset
argument_list|(
name|postings
argument_list|)
return|;
block|}
else|else
block|{
name|LowFreqDocsEnumNoPos
name|docsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|instanceof
name|LowFreqDocsEnumNoPos
condition|)
block|{
name|docsEnum
operator|=
operator|(
name|LowFreqDocsEnumNoPos
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
operator|!
name|docsEnum
operator|.
name|canReuse
argument_list|(
name|liveDocs
argument_list|)
condition|)
block|{
name|docsEnum
operator|=
operator|new
name|LowFreqDocsEnumNoPos
argument_list|(
name|liveDocs
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|docsEnum
operator|=
operator|new
name|LowFreqDocsEnumNoPos
argument_list|(
name|liveDocs
argument_list|)
expr_stmt|;
block|}
return|return
name|docsEnum
operator|.
name|reset
argument_list|(
name|postings
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|LowFreqDocsEnumNoTF
name|docsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|instanceof
name|LowFreqDocsEnumNoTF
condition|)
block|{
name|docsEnum
operator|=
operator|(
name|LowFreqDocsEnumNoTF
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
operator|!
name|docsEnum
operator|.
name|canReuse
argument_list|(
name|liveDocs
argument_list|)
condition|)
block|{
name|docsEnum
operator|=
operator|new
name|LowFreqDocsEnumNoTF
argument_list|(
name|liveDocs
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|docsEnum
operator|=
operator|new
name|LowFreqDocsEnumNoTF
argument_list|(
name|liveDocs
argument_list|)
expr_stmt|;
block|}
return|return
name|docsEnum
operator|.
name|reset
argument_list|(
name|postings
argument_list|)
return|;
block|}
block|}
else|else
block|{
specifier|final
name|HighFreqTerm
name|term
init|=
operator|(
name|HighFreqTerm
operator|)
name|terms
index|[
name|termOrd
index|]
decl_stmt|;
name|HighFreqDocsEnum
name|docsEnum
decl_stmt|;
if|if
condition|(
name|reuse
operator|instanceof
name|HighFreqDocsEnum
condition|)
block|{
name|docsEnum
operator|=
operator|(
name|HighFreqDocsEnum
operator|)
name|reuse
expr_stmt|;
if|if
condition|(
operator|!
name|docsEnum
operator|.
name|canReuse
argument_list|(
name|liveDocs
argument_list|)
condition|)
block|{
name|docsEnum
operator|=
operator|new
name|HighFreqDocsEnum
argument_list|(
name|liveDocs
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|docsEnum
operator|=
operator|new
name|HighFreqDocsEnum
argument_list|(
name|liveDocs
argument_list|)
expr_stmt|;
block|}
comment|//System.out.println("  DE for term=" + new BytesRef(terms[termOrd].term).utf8ToString() + ": " + term.docIDs.length + " docs");
return|return
name|docsEnum
operator|.
name|reset
argument_list|(
name|term
operator|.
name|docIDs
argument_list|,
name|term
operator|.
name|freqs
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasPos
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// TODO: implement reuse, something like Pulsing:
comment|// it's hairy!
if|if
condition|(
name|terms
index|[
name|termOrd
index|]
operator|instanceof
name|LowFreqTerm
condition|)
block|{
specifier|final
name|LowFreqTerm
name|term
init|=
operator|(
operator|(
name|LowFreqTerm
operator|)
name|terms
index|[
name|termOrd
index|]
operator|)
decl_stmt|;
specifier|final
name|int
index|[]
name|postings
init|=
name|term
operator|.
name|postings
decl_stmt|;
specifier|final
name|byte
index|[]
name|payloads
init|=
name|term
operator|.
name|payloads
decl_stmt|;
return|return
operator|new
name|LowFreqDocsAndPositionsEnum
argument_list|(
name|liveDocs
argument_list|,
name|hasOffsets
argument_list|,
name|hasPayloads
argument_list|)
operator|.
name|reset
argument_list|(
name|postings
argument_list|,
name|payloads
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|HighFreqTerm
name|term
init|=
operator|(
name|HighFreqTerm
operator|)
name|terms
index|[
name|termOrd
index|]
decl_stmt|;
return|return
operator|new
name|HighFreqDocsAndPositionsEnum
argument_list|(
name|liveDocs
argument_list|,
name|hasOffsets
argument_list|)
operator|.
name|reset
argument_list|(
name|term
operator|.
name|docIDs
argument_list|,
name|term
operator|.
name|freqs
argument_list|,
name|term
operator|.
name|positions
argument_list|,
name|term
operator|.
name|payloads
argument_list|)
return|;
block|}
block|}
block|}
DECL|class|DirectIntersectTermsEnum
specifier|private
specifier|final
class|class
name|DirectIntersectTermsEnum
extends|extends
name|TermsEnum
block|{
DECL|field|runAutomaton
specifier|private
specifier|final
name|RunAutomaton
name|runAutomaton
decl_stmt|;
DECL|field|compiledAutomaton
specifier|private
specifier|final
name|CompiledAutomaton
name|compiledAutomaton
decl_stmt|;
DECL|field|termOrd
specifier|private
name|int
name|termOrd
decl_stmt|;
DECL|field|scratch
specifier|private
specifier|final
name|BytesRef
name|scratch
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
DECL|class|State
specifier|private
specifier|final
class|class
name|State
block|{
DECL|field|changeOrd
name|int
name|changeOrd
decl_stmt|;
DECL|field|state
name|int
name|state
decl_stmt|;
DECL|field|transitions
name|Transition
index|[]
name|transitions
decl_stmt|;
DECL|field|transitionUpto
name|int
name|transitionUpto
decl_stmt|;
DECL|field|transitionMax
name|int
name|transitionMax
decl_stmt|;
DECL|field|transitionMin
name|int
name|transitionMin
decl_stmt|;
block|}
DECL|field|states
specifier|private
name|State
index|[]
name|states
decl_stmt|;
DECL|field|stateUpto
specifier|private
name|int
name|stateUpto
decl_stmt|;
DECL|method|DirectIntersectTermsEnum
specifier|public
name|DirectIntersectTermsEnum
parameter_list|(
name|CompiledAutomaton
name|compiled
parameter_list|,
name|BytesRef
name|startTerm
parameter_list|)
block|{
name|runAutomaton
operator|=
name|compiled
operator|.
name|runAutomaton
expr_stmt|;
name|compiledAutomaton
operator|=
name|compiled
expr_stmt|;
name|termOrd
operator|=
operator|-
literal|1
expr_stmt|;
name|states
operator|=
operator|new
name|State
index|[
literal|1
index|]
expr_stmt|;
name|states
index|[
literal|0
index|]
operator|=
operator|new
name|State
argument_list|()
expr_stmt|;
name|states
index|[
literal|0
index|]
operator|.
name|changeOrd
operator|=
name|terms
operator|.
name|length
expr_stmt|;
name|states
index|[
literal|0
index|]
operator|.
name|state
operator|=
name|runAutomaton
operator|.
name|getInitialState
argument_list|()
expr_stmt|;
name|states
index|[
literal|0
index|]
operator|.
name|transitions
operator|=
name|compiledAutomaton
operator|.
name|sortedTransitions
index|[
name|states
index|[
literal|0
index|]
operator|.
name|state
index|]
expr_stmt|;
name|states
index|[
literal|0
index|]
operator|.
name|transitionUpto
operator|=
operator|-
literal|1
expr_stmt|;
name|states
index|[
literal|0
index|]
operator|.
name|transitionMax
operator|=
operator|-
literal|1
expr_stmt|;
comment|//System.out.println("IE.init startTerm=" + startTerm);
if|if
condition|(
name|startTerm
operator|!=
literal|null
condition|)
block|{
name|int
name|skipUpto
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|startTerm
operator|.
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|terms
operator|.
name|length
operator|>
literal|0
operator|&&
name|termOffsets
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|termOrd
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|termOrd
operator|++
expr_stmt|;
name|nextLabel
label|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|startTerm
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|label
init|=
name|startTerm
operator|.
name|bytes
index|[
name|startTerm
operator|.
name|offset
operator|+
name|i
index|]
operator|&
literal|0xFF
decl_stmt|;
while|while
condition|(
name|label
operator|>
name|states
index|[
name|i
index|]
operator|.
name|transitionMax
condition|)
block|{
name|states
index|[
name|i
index|]
operator|.
name|transitionUpto
operator|++
expr_stmt|;
assert|assert
name|states
index|[
name|i
index|]
operator|.
name|transitionUpto
operator|<
name|states
index|[
name|i
index|]
operator|.
name|transitions
operator|.
name|length
assert|;
name|states
index|[
name|i
index|]
operator|.
name|transitionMin
operator|=
name|states
index|[
name|i
index|]
operator|.
name|transitions
index|[
name|states
index|[
name|i
index|]
operator|.
name|transitionUpto
index|]
operator|.
name|getMin
argument_list|()
expr_stmt|;
name|states
index|[
name|i
index|]
operator|.
name|transitionMax
operator|=
name|states
index|[
name|i
index|]
operator|.
name|transitions
index|[
name|states
index|[
name|i
index|]
operator|.
name|transitionUpto
index|]
operator|.
name|getMax
argument_list|()
expr_stmt|;
assert|assert
name|states
index|[
name|i
index|]
operator|.
name|transitionMin
operator|>=
literal|0
assert|;
assert|assert
name|states
index|[
name|i
index|]
operator|.
name|transitionMin
operator|<=
literal|255
assert|;
assert|assert
name|states
index|[
name|i
index|]
operator|.
name|transitionMax
operator|>=
literal|0
assert|;
assert|assert
name|states
index|[
name|i
index|]
operator|.
name|transitionMax
operator|<=
literal|255
assert|;
block|}
comment|// Skip forwards until we find a term matching
comment|// the label at this position:
while|while
condition|(
name|termOrd
operator|<
name|terms
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|skipOffset
init|=
name|skipOffsets
index|[
name|termOrd
index|]
decl_stmt|;
specifier|final
name|int
name|numSkips
init|=
name|skipOffsets
index|[
name|termOrd
operator|+
literal|1
index|]
operator|-
name|skipOffset
decl_stmt|;
specifier|final
name|int
name|termOffset
init|=
name|termOffsets
index|[
name|termOrd
index|]
decl_stmt|;
specifier|final
name|int
name|termLength
init|=
name|termOffsets
index|[
literal|1
operator|+
name|termOrd
index|]
operator|-
name|termOffset
decl_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  check termOrd=" + termOrd + " term=" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + " skips=" + Arrays.toString(skips) + " i=" + i);
comment|// }
if|if
condition|(
name|termOrd
operator|==
name|states
index|[
name|stateUpto
index|]
operator|.
name|changeOrd
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  end push return");
comment|// }
name|stateUpto
operator|--
expr_stmt|;
name|termOrd
operator|--
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|termLength
operator|==
name|i
condition|)
block|{
name|termOrd
operator|++
expr_stmt|;
name|skipUpto
operator|=
literal|0
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("    term too short; next term");
comment|// }
block|}
elseif|else
if|if
condition|(
name|label
operator|<
operator|(
name|termBytes
index|[
name|termOffset
operator|+
name|i
index|]
operator|&
literal|0xFF
operator|)
condition|)
block|{
name|termOrd
operator|--
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  no match; already beyond; return termOrd=" + termOrd);
comment|// }
name|stateUpto
operator|-=
name|skipUpto
expr_stmt|;
assert|assert
name|stateUpto
operator|>=
literal|0
assert|;
return|return;
block|}
elseif|else
if|if
condition|(
name|label
operator|==
operator|(
name|termBytes
index|[
name|termOffset
operator|+
name|i
index|]
operator|&
literal|0xFF
operator|)
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    label[" + i + "] matches");
comment|// }
if|if
condition|(
name|skipUpto
operator|<
name|numSkips
condition|)
block|{
name|grow
argument_list|()
expr_stmt|;
specifier|final
name|int
name|nextState
init|=
name|runAutomaton
operator|.
name|step
argument_list|(
name|states
index|[
name|stateUpto
index|]
operator|.
name|state
argument_list|,
name|label
argument_list|)
decl_stmt|;
comment|// Automaton is required to accept startTerm:
assert|assert
name|nextState
operator|!=
operator|-
literal|1
assert|;
name|stateUpto
operator|++
expr_stmt|;
name|states
index|[
name|stateUpto
index|]
operator|.
name|changeOrd
operator|=
name|skips
index|[
name|skipOffset
operator|+
name|skipUpto
operator|++
index|]
expr_stmt|;
name|states
index|[
name|stateUpto
index|]
operator|.
name|state
operator|=
name|nextState
expr_stmt|;
name|states
index|[
name|stateUpto
index|]
operator|.
name|transitions
operator|=
name|compiledAutomaton
operator|.
name|sortedTransitions
index|[
name|nextState
index|]
expr_stmt|;
name|states
index|[
name|stateUpto
index|]
operator|.
name|transitionUpto
operator|=
operator|-
literal|1
expr_stmt|;
name|states
index|[
name|stateUpto
index|]
operator|.
name|transitionMax
operator|=
operator|-
literal|1
expr_stmt|;
comment|//System.out.println("  push " + states[stateUpto].transitions.length + " trans");
comment|// if (DEBUG) {
comment|//   System.out.println("    push skip; changeOrd=" + states[stateUpto].changeOrd);
comment|// }
comment|// Match next label at this same term:
continue|continue
name|nextLabel
continue|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    linear scan");
comment|// }
comment|// Index exhausted: just scan now (the
comment|// number of scans required will be less
comment|// than the minSkipCount):
specifier|final
name|int
name|startTermOrd
init|=
name|termOrd
decl_stmt|;
while|while
condition|(
name|termOrd
operator|<
name|terms
operator|.
name|length
operator|&&
name|compare
argument_list|(
name|termOrd
argument_list|,
name|startTerm
argument_list|)
operator|<=
literal|0
condition|)
block|{
assert|assert
name|termOrd
operator|==
name|startTermOrd
operator|||
name|skipOffsets
index|[
name|termOrd
index|]
operator|==
name|skipOffsets
index|[
name|termOrd
operator|+
literal|1
index|]
assert|;
name|termOrd
operator|++
expr_stmt|;
block|}
assert|assert
name|termOrd
operator|-
name|startTermOrd
operator|<
name|minSkipCount
assert|;
name|termOrd
operator|--
expr_stmt|;
name|stateUpto
operator|-=
name|skipUpto
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  end termOrd=" + termOrd);
comment|// }
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|skipUpto
operator|<
name|numSkips
condition|)
block|{
name|termOrd
operator|=
name|skips
index|[
name|skipOffset
operator|+
name|skipUpto
index|]
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  no match; skip to termOrd=" + termOrd);
comment|// }
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  no match; next term");
comment|// }
name|termOrd
operator|++
expr_stmt|;
block|}
name|skipUpto
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// startTerm is>= last term so enum will not
comment|// return any terms:
name|termOrd
operator|--
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  beyond end; no terms will match");
comment|// }
return|return;
block|}
block|}
specifier|final
name|int
name|termOffset
init|=
name|termOffsets
index|[
name|termOrd
index|]
decl_stmt|;
specifier|final
name|int
name|termLen
init|=
name|termOffsets
index|[
literal|1
operator|+
name|termOrd
index|]
operator|-
name|termOffset
decl_stmt|;
if|if
condition|(
name|termOrd
operator|>=
literal|0
operator|&&
operator|!
name|startTerm
operator|.
name|equals
argument_list|(
operator|new
name|BytesRef
argument_list|(
name|termBytes
argument_list|,
name|termOffset
argument_list|,
name|termLen
argument_list|)
argument_list|)
condition|)
block|{
name|stateUpto
operator|-=
name|skipUpto
expr_stmt|;
name|termOrd
operator|--
expr_stmt|;
block|}
comment|// if (DEBUG) {
comment|//   System.out.println("  loop end; return termOrd=" + termOrd + " stateUpto=" + stateUpto);
comment|// }
block|}
block|}
DECL|method|getComparator
specifier|public
name|Comparator
argument_list|<
name|BytesRef
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|BytesRef
operator|.
name|getUTF8SortedAsUnicodeComparator
argument_list|()
return|;
block|}
DECL|method|grow
specifier|private
name|void
name|grow
parameter_list|()
block|{
if|if
condition|(
name|states
operator|.
name|length
operator|==
literal|1
operator|+
name|stateUpto
condition|)
block|{
specifier|final
name|State
index|[]
name|newStates
init|=
operator|new
name|State
index|[
name|states
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|states
argument_list|,
literal|0
argument_list|,
name|newStates
argument_list|,
literal|0
argument_list|,
name|states
operator|.
name|length
argument_list|)
expr_stmt|;
name|newStates
index|[
name|states
operator|.
name|length
index|]
operator|=
operator|new
name|State
argument_list|()
expr_stmt|;
name|states
operator|=
name|newStates
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|BytesRef
name|next
parameter_list|()
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("\nIE.next");
comment|// }
name|termOrd
operator|++
expr_stmt|;
name|int
name|skipUpto
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|termOrd
operator|==
literal|0
operator|&&
name|termOffsets
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
comment|// Special-case empty string:
assert|assert
name|stateUpto
operator|==
literal|0
assert|;
comment|// if (DEBUG) {
comment|//   System.out.println("  visit empty string");
comment|// }
if|if
condition|(
name|runAutomaton
operator|.
name|isAccept
argument_list|(
name|states
index|[
literal|0
index|]
operator|.
name|state
argument_list|)
condition|)
block|{
name|scratch
operator|.
name|bytes
operator|=
name|termBytes
expr_stmt|;
name|scratch
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|scratch
operator|.
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|scratch
return|;
block|}
name|termOrd
operator|++
expr_stmt|;
block|}
name|nextTerm
label|:
while|while
condition|(
literal|true
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  cycle termOrd=" + termOrd + " stateUpto=" + stateUpto + " skipUpto=" + skipUpto);
comment|// }
if|if
condition|(
name|termOrd
operator|==
name|terms
operator|.
name|length
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  return END");
comment|// }
return|return
literal|null
return|;
block|}
specifier|final
name|State
name|state
init|=
name|states
index|[
name|stateUpto
index|]
decl_stmt|;
if|if
condition|(
name|termOrd
operator|==
name|state
operator|.
name|changeOrd
condition|)
block|{
comment|// Pop:
comment|// if (DEBUG) {
comment|//   System.out.println("  pop stateUpto=" + stateUpto);
comment|// }
name|stateUpto
operator|--
expr_stmt|;
comment|/*             if (DEBUG) {               try {                 //System.out.println("    prefix pop " + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)).utf8ToString());                 System.out.println("    prefix pop " + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));               } catch (ArrayIndexOutOfBoundsException aioobe) {                 System.out.println("    prefix pop " + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));               }             }             */
continue|continue;
block|}
specifier|final
name|int
name|termOffset
init|=
name|termOffsets
index|[
name|termOrd
index|]
decl_stmt|;
specifier|final
name|int
name|termLength
init|=
name|termOffsets
index|[
name|termOrd
operator|+
literal|1
index|]
operator|-
name|termOffset
decl_stmt|;
specifier|final
name|int
name|skipOffset
init|=
name|skipOffsets
index|[
name|termOrd
index|]
decl_stmt|;
specifier|final
name|int
name|numSkips
init|=
name|skipOffsets
index|[
name|termOrd
operator|+
literal|1
index|]
operator|-
name|skipOffset
decl_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  term=" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + " skips=" + Arrays.toString(skips));
comment|// }
assert|assert
name|termOrd
operator|<
name|state
operator|.
name|changeOrd
assert|;
assert|assert
name|stateUpto
operator|<=
name|termLength
operator|:
literal|"term.length="
operator|+
name|termLength
operator|+
literal|"; stateUpto="
operator|+
name|stateUpto
assert|;
specifier|final
name|int
name|label
init|=
name|termBytes
index|[
name|termOffset
operator|+
name|stateUpto
index|]
operator|&
literal|0xFF
decl_stmt|;
while|while
condition|(
name|label
operator|>
name|state
operator|.
name|transitionMax
condition|)
block|{
comment|//System.out.println("  label=" + label + " vs max=" + state.transitionMax + " transUpto=" + state.transitionUpto + " vs " + state.transitions.length);
name|state
operator|.
name|transitionUpto
operator|++
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|transitionUpto
operator|==
name|state
operator|.
name|transitions
operator|.
name|length
condition|)
block|{
comment|// We've exhausted transitions leaving this
comment|// state; force pop+next/skip now:
comment|//System.out.println("forcepop: stateUpto=" + stateUpto);
if|if
condition|(
name|stateUpto
operator|==
literal|0
condition|)
block|{
name|termOrd
operator|=
name|terms
operator|.
name|length
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
assert|assert
name|state
operator|.
name|changeOrd
operator|>
name|termOrd
assert|;
comment|// if (DEBUG) {
comment|//   System.out.println("  jumpend " + (state.changeOrd - termOrd));
comment|// }
comment|//System.out.println("  jump to termOrd=" + states[stateUpto].changeOrd + " vs " + termOrd);
name|termOrd
operator|=
name|states
index|[
name|stateUpto
index|]
operator|.
name|changeOrd
expr_stmt|;
name|skipUpto
operator|=
literal|0
expr_stmt|;
name|stateUpto
operator|--
expr_stmt|;
block|}
continue|continue
name|nextTerm
continue|;
block|}
assert|assert
name|state
operator|.
name|transitionUpto
operator|<
name|state
operator|.
name|transitions
operator|.
name|length
operator|:
literal|" state.transitionUpto="
operator|+
name|state
operator|.
name|transitionUpto
operator|+
literal|" vs "
operator|+
name|state
operator|.
name|transitions
operator|.
name|length
assert|;
name|state
operator|.
name|transitionMin
operator|=
name|state
operator|.
name|transitions
index|[
name|state
operator|.
name|transitionUpto
index|]
operator|.
name|getMin
argument_list|()
expr_stmt|;
name|state
operator|.
name|transitionMax
operator|=
name|state
operator|.
name|transitions
index|[
name|state
operator|.
name|transitionUpto
index|]
operator|.
name|getMax
argument_list|()
expr_stmt|;
assert|assert
name|state
operator|.
name|transitionMin
operator|>=
literal|0
assert|;
assert|assert
name|state
operator|.
name|transitionMin
operator|<=
literal|255
assert|;
assert|assert
name|state
operator|.
name|transitionMax
operator|>=
literal|0
assert|;
assert|assert
name|state
operator|.
name|transitionMax
operator|<=
literal|255
assert|;
block|}
comment|/*           if (DEBUG) {             System.out.println("    check ord=" + termOrd + " term[" + stateUpto + "]=" + (char) label + "(" + label + ") term=" + new BytesRef(terms[termOrd].term).utf8ToString() + " trans " +                                (char) state.transitionMin + "(" + state.transitionMin + ")" + "-" + (char) state.transitionMax + "(" + state.transitionMax + ") nextChange=+" + (state.changeOrd - termOrd) + " skips=" + (skips == null ? "null" : Arrays.toString(skips)));             System.out.println("    check ord=" + termOrd + " term[" + stateUpto + "]=" + Integer.toHexString(label) + "(" + label + ") term=" + new BytesRef(termBytes, termOffset, termLength) + " trans " +                                Integer.toHexString(state.transitionMin) + "(" + state.transitionMin + ")" + "-" + Integer.toHexString(state.transitionMax) + "(" + state.transitionMax + ") nextChange=+" + (state.changeOrd - termOrd) + " skips=" + (skips == null ? "null" : Arrays.toString(skips)));           }           */
specifier|final
name|int
name|targetLabel
init|=
name|state
operator|.
name|transitionMin
decl_stmt|;
if|if
condition|(
operator|(
name|termBytes
index|[
name|termOffset
operator|+
name|stateUpto
index|]
operator|&
literal|0xFF
operator|)
operator|<
name|targetLabel
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("    do bin search");
comment|// }
comment|//int startTermOrd = termOrd;
name|int
name|low
init|=
name|termOrd
operator|+
literal|1
decl_stmt|;
name|int
name|high
init|=
name|state
operator|.
name|changeOrd
operator|-
literal|1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|low
operator|>
name|high
condition|)
block|{
comment|// Label not found
name|termOrd
operator|=
name|low
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("      advanced by " + (termOrd - startTermOrd));
comment|// }
comment|//System.out.println("  jump " + (termOrd - startTermOrd));
name|skipUpto
operator|=
literal|0
expr_stmt|;
continue|continue
name|nextTerm
continue|;
block|}
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|int
name|cmp
init|=
operator|(
name|termBytes
index|[
name|termOffsets
index|[
name|mid
index|]
operator|+
name|stateUpto
index|]
operator|&
literal|0xFF
operator|)
operator|-
name|targetLabel
decl_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("      bin: check label=" + (char) (termBytes[termOffsets[low] + stateUpto]& 0xFF) + " ord=" + mid);
comment|// }
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// Label found; walk backwards to first
comment|// occurrence:
while|while
condition|(
name|mid
operator|>
name|termOrd
operator|&&
operator|(
name|termBytes
index|[
name|termOffsets
index|[
name|mid
operator|-
literal|1
index|]
operator|+
name|stateUpto
index|]
operator|&
literal|0xFF
operator|)
operator|==
name|targetLabel
condition|)
block|{
name|mid
operator|--
expr_stmt|;
block|}
name|termOrd
operator|=
name|mid
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("      advanced by " + (termOrd - startTermOrd));
comment|// }
comment|//System.out.println("  jump " + (termOrd - startTermOrd));
name|skipUpto
operator|=
literal|0
expr_stmt|;
continue|continue
name|nextTerm
continue|;
block|}
block|}
block|}
name|int
name|nextState
init|=
name|runAutomaton
operator|.
name|step
argument_list|(
name|states
index|[
name|stateUpto
index|]
operator|.
name|state
argument_list|,
name|label
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextState
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Skip
comment|// if (DEBUG) {
comment|//   System.out.println("  automaton doesn't accept; skip");
comment|// }
if|if
condition|(
name|skipUpto
operator|<
name|numSkips
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  jump " + (skips[skipOffset+skipUpto]-1 - termOrd));
comment|// }
name|termOrd
operator|=
name|skips
index|[
name|skipOffset
operator|+
name|skipUpto
index|]
expr_stmt|;
block|}
else|else
block|{
name|termOrd
operator|++
expr_stmt|;
block|}
name|skipUpto
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skipUpto
operator|<
name|numSkips
condition|)
block|{
comment|// Push:
comment|// if (DEBUG) {
comment|//   System.out.println("  push");
comment|// }
comment|/*             if (DEBUG) {               try {                 //System.out.println("    prefix push " + new BytesRef(term, 0, stateUpto+1).utf8ToString());                 System.out.println("    prefix push " + new BytesRef(term, 0, stateUpto+1));               } catch (ArrayIndexOutOfBoundsException aioobe) {                 System.out.println("    prefix push " + new BytesRef(term, 0, stateUpto+1));               }             }             */
name|grow
argument_list|()
expr_stmt|;
name|stateUpto
operator|++
expr_stmt|;
name|states
index|[
name|stateUpto
index|]
operator|.
name|state
operator|=
name|nextState
expr_stmt|;
name|states
index|[
name|stateUpto
index|]
operator|.
name|changeOrd
operator|=
name|skips
index|[
name|skipOffset
operator|+
name|skipUpto
operator|++
index|]
expr_stmt|;
name|states
index|[
name|stateUpto
index|]
operator|.
name|transitions
operator|=
name|compiledAutomaton
operator|.
name|sortedTransitions
index|[
name|nextState
index|]
expr_stmt|;
name|states
index|[
name|stateUpto
index|]
operator|.
name|transitionUpto
operator|=
operator|-
literal|1
expr_stmt|;
name|states
index|[
name|stateUpto
index|]
operator|.
name|transitionMax
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|stateUpto
operator|==
name|termLength
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  term ends after push");
comment|// }
if|if
condition|(
name|runAutomaton
operator|.
name|isAccept
argument_list|(
name|nextState
argument_list|)
condition|)
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  automaton accepts: return");
comment|// }
name|scratch
operator|.
name|bytes
operator|=
name|termBytes
expr_stmt|;
name|scratch
operator|.
name|offset
operator|=
name|termOffsets
index|[
name|termOrd
index|]
expr_stmt|;
name|scratch
operator|.
name|length
operator|=
name|termOffsets
index|[
literal|1
operator|+
name|termOrd
index|]
operator|-
name|scratch
operator|.
name|offset
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  ret " + scratch.utf8ToString());
comment|// }
return|return
name|scratch
return|;
block|}
else|else
block|{
comment|// if (DEBUG) {
comment|//   System.out.println("  automaton rejects: nextTerm");
comment|// }
name|termOrd
operator|++
expr_stmt|;
name|skipUpto
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// Run the non-indexed tail of this term:
comment|// TODO: add assert that we don't inc too many times
if|if
condition|(
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|!=
literal|null
condition|)
block|{
comment|//System.out.println("suffix " + compiledAutomaton.commonSuffixRef.utf8ToString());
assert|assert
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|offset
operator|==
literal|0
assert|;
if|if
condition|(
name|termLength
operator|<
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|length
condition|)
block|{
name|termOrd
operator|++
expr_stmt|;
name|skipUpto
operator|=
literal|0
expr_stmt|;
continue|continue
name|nextTerm
continue|;
block|}
name|int
name|offset
init|=
name|termOffset
operator|+
name|termLength
operator|-
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|suffix
init|=
literal|0
init|;
name|suffix
operator|<
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|length
condition|;
name|suffix
operator|++
control|)
block|{
if|if
condition|(
name|termBytes
index|[
name|offset
operator|+
name|suffix
index|]
operator|!=
name|compiledAutomaton
operator|.
name|commonSuffixRef
operator|.
name|bytes
index|[
name|suffix
index|]
condition|)
block|{
name|termOrd
operator|++
expr_stmt|;
name|skipUpto
operator|=
literal|0
expr_stmt|;
continue|continue
name|nextTerm
continue|;
block|}
block|}
block|}
name|int
name|upto
init|=
name|stateUpto
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|upto
operator|<
name|termLength
condition|)
block|{
name|nextState
operator|=
name|runAutomaton
operator|.
name|step
argument_list|(
name|nextState
argument_list|,
name|termBytes
index|[
name|termOffset
operator|+
name|upto
index|]
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextState
operator|==
operator|-
literal|1
condition|)
block|{
name|termOrd
operator|++
expr_stmt|;
name|skipUpto
operator|=
literal|0
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  nomatch tail; next term");
comment|// }
continue|continue
name|nextTerm
continue|;
block|}
name|upto
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|runAutomaton
operator|.
name|isAccept
argument_list|(
name|nextState
argument_list|)
condition|)
block|{
name|scratch
operator|.
name|bytes
operator|=
name|termBytes
expr_stmt|;
name|scratch
operator|.
name|offset
operator|=
name|termOffsets
index|[
name|termOrd
index|]
expr_stmt|;
name|scratch
operator|.
name|length
operator|=
name|termOffsets
index|[
literal|1
operator|+
name|termOrd
index|]
operator|-
name|scratch
operator|.
name|offset
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  match tail; return " + scratch.utf8ToString());
comment|//   System.out.println("  ret2 " + scratch.utf8ToString());
comment|// }
return|return
name|scratch
return|;
block|}
else|else
block|{
name|termOrd
operator|++
expr_stmt|;
name|skipUpto
operator|=
literal|0
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  nomatch tail; next term");
comment|// }
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|termState
specifier|public
name|TermState
name|termState
parameter_list|()
block|{
name|OrdTermState
name|state
init|=
operator|new
name|OrdTermState
argument_list|()
decl_stmt|;
name|state
operator|.
name|ord
operator|=
name|termOrd
expr_stmt|;
return|return
name|state
return|;
block|}
annotation|@
name|Override
DECL|method|term
specifier|public
name|BytesRef
name|term
parameter_list|()
block|{
return|return
name|scratch
return|;
block|}
annotation|@
name|Override
DECL|method|ord
specifier|public
name|long
name|ord
parameter_list|()
block|{
return|return
name|termOrd
return|;
block|}
annotation|@
name|Override
DECL|method|docFreq
specifier|public
name|int
name|docFreq
parameter_list|()
block|{
if|if
condition|(
name|terms
index|[
name|termOrd
index|]
operator|instanceof
name|LowFreqTerm
condition|)
block|{
return|return
operator|(
operator|(
name|LowFreqTerm
operator|)
name|terms
index|[
name|termOrd
index|]
operator|)
operator|.
name|docFreq
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|HighFreqTerm
operator|)
name|terms
index|[
name|termOrd
index|]
operator|)
operator|.
name|docIDs
operator|.
name|length
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|totalTermFreq
specifier|public
name|long
name|totalTermFreq
parameter_list|()
block|{
if|if
condition|(
name|terms
index|[
name|termOrd
index|]
operator|instanceof
name|LowFreqTerm
condition|)
block|{
return|return
operator|(
operator|(
name|LowFreqTerm
operator|)
name|terms
index|[
name|termOrd
index|]
operator|)
operator|.
name|totalTermFreq
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|HighFreqTerm
operator|)
name|terms
index|[
name|termOrd
index|]
operator|)
operator|.
name|totalTermFreq
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|docs
specifier|public
name|DocsEnum
name|docs
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|DocsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|// TODO: implement reuse, something like Pulsing:
comment|// it's hairy!
if|if
condition|(
name|terms
index|[
name|termOrd
index|]
operator|instanceof
name|LowFreqTerm
condition|)
block|{
specifier|final
name|int
index|[]
name|postings
init|=
operator|(
operator|(
name|LowFreqTerm
operator|)
name|terms
index|[
name|termOrd
index|]
operator|)
operator|.
name|postings
decl_stmt|;
if|if
condition|(
name|hasFreq
condition|)
block|{
if|if
condition|(
name|hasPos
condition|)
block|{
name|int
name|posLen
decl_stmt|;
if|if
condition|(
name|hasOffsets
condition|)
block|{
name|posLen
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|posLen
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hasPayloads
condition|)
block|{
name|posLen
operator|++
expr_stmt|;
block|}
return|return
operator|new
name|LowFreqDocsEnum
argument_list|(
name|liveDocs
argument_list|,
name|posLen
argument_list|)
operator|.
name|reset
argument_list|(
name|postings
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|LowFreqDocsEnumNoPos
argument_list|(
name|liveDocs
argument_list|)
operator|.
name|reset
argument_list|(
name|postings
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|new
name|LowFreqDocsEnumNoTF
argument_list|(
name|liveDocs
argument_list|)
operator|.
name|reset
argument_list|(
name|postings
argument_list|)
return|;
block|}
block|}
else|else
block|{
specifier|final
name|HighFreqTerm
name|term
init|=
operator|(
name|HighFreqTerm
operator|)
name|terms
index|[
name|termOrd
index|]
decl_stmt|;
comment|//  System.out.println("DE for term=" + new BytesRef(terms[termOrd].term).utf8ToString() + ": " + term.docIDs.length + " docs");
return|return
operator|new
name|HighFreqDocsEnum
argument_list|(
name|liveDocs
argument_list|)
operator|.
name|reset
argument_list|(
name|term
operator|.
name|docIDs
argument_list|,
name|term
operator|.
name|freqs
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|docsAndPositions
specifier|public
name|DocsAndPositionsEnum
name|docsAndPositions
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|DocsAndPositionsEnum
name|reuse
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasPos
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// TODO: implement reuse, something like Pulsing:
comment|// it's hairy!
if|if
condition|(
name|terms
index|[
name|termOrd
index|]
operator|instanceof
name|LowFreqTerm
condition|)
block|{
specifier|final
name|LowFreqTerm
name|term
init|=
operator|(
operator|(
name|LowFreqTerm
operator|)
name|terms
index|[
name|termOrd
index|]
operator|)
decl_stmt|;
specifier|final
name|int
index|[]
name|postings
init|=
name|term
operator|.
name|postings
decl_stmt|;
specifier|final
name|byte
index|[]
name|payloads
init|=
name|term
operator|.
name|payloads
decl_stmt|;
return|return
operator|new
name|LowFreqDocsAndPositionsEnum
argument_list|(
name|liveDocs
argument_list|,
name|hasOffsets
argument_list|,
name|hasPayloads
argument_list|)
operator|.
name|reset
argument_list|(
name|postings
argument_list|,
name|payloads
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|HighFreqTerm
name|term
init|=
operator|(
name|HighFreqTerm
operator|)
name|terms
index|[
name|termOrd
index|]
decl_stmt|;
return|return
operator|new
name|HighFreqDocsAndPositionsEnum
argument_list|(
name|liveDocs
argument_list|,
name|hasOffsets
argument_list|)
operator|.
name|reset
argument_list|(
name|term
operator|.
name|docIDs
argument_list|,
name|term
operator|.
name|freqs
argument_list|,
name|term
operator|.
name|positions
argument_list|,
name|term
operator|.
name|payloads
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|seekCeil
specifier|public
name|SeekStatus
name|seekCeil
parameter_list|(
name|BytesRef
name|term
parameter_list|,
name|boolean
name|useCache
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|seekExact
specifier|public
name|void
name|seekExact
parameter_list|(
name|long
name|ord
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
block|}
comment|// Docs only:
DECL|class|LowFreqDocsEnumNoTF
specifier|private
specifier|final
specifier|static
class|class
name|LowFreqDocsEnumNoTF
extends|extends
name|DocsEnum
block|{
DECL|field|postings
specifier|private
name|int
index|[]
name|postings
decl_stmt|;
DECL|field|liveDocs
specifier|private
specifier|final
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|upto
specifier|private
name|int
name|upto
decl_stmt|;
DECL|method|LowFreqDocsEnumNoTF
specifier|public
name|LowFreqDocsEnumNoTF
parameter_list|(
name|Bits
name|liveDocs
parameter_list|)
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
block|}
DECL|method|canReuse
specifier|public
name|boolean
name|canReuse
parameter_list|(
name|Bits
name|liveDocs
parameter_list|)
block|{
return|return
name|liveDocs
operator|==
name|this
operator|.
name|liveDocs
return|;
block|}
DECL|method|reset
specifier|public
name|DocsEnum
name|reset
parameter_list|(
name|int
index|[]
name|postings
parameter_list|)
block|{
name|this
operator|.
name|postings
operator|=
name|postings
expr_stmt|;
name|upto
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|this
return|;
block|}
comment|// TODO: can do this w/o setting members?
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
block|{
name|upto
operator|++
expr_stmt|;
if|if
condition|(
name|liveDocs
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|upto
operator|<
name|postings
operator|.
name|length
condition|)
block|{
return|return
name|postings
index|[
name|upto
index|]
return|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|upto
operator|<
name|postings
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|liveDocs
operator|.
name|get
argument_list|(
name|postings
index|[
name|upto
index|]
argument_list|)
condition|)
block|{
return|return
name|postings
index|[
name|upto
index|]
return|;
block|}
name|upto
operator|++
expr_stmt|;
block|}
block|}
return|return
name|NO_MORE_DOCS
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
if|if
condition|(
name|upto
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|upto
operator|<
name|postings
operator|.
name|length
condition|)
block|{
return|return
name|postings
index|[
name|upto
index|]
return|;
block|}
else|else
block|{
return|return
name|NO_MORE_DOCS
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
block|{
comment|// Linear scan, but this is low-freq term so it won't
comment|// be costly:
while|while
condition|(
name|nextDoc
argument_list|()
operator|<
name|target
condition|)
block|{       }
return|return
name|docID
argument_list|()
return|;
block|}
block|}
comment|// Docs + freqs:
DECL|class|LowFreqDocsEnumNoPos
specifier|private
specifier|final
specifier|static
class|class
name|LowFreqDocsEnumNoPos
extends|extends
name|DocsEnum
block|{
DECL|field|postings
specifier|private
name|int
index|[]
name|postings
decl_stmt|;
DECL|field|liveDocs
specifier|private
specifier|final
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|upto
specifier|private
name|int
name|upto
decl_stmt|;
DECL|method|LowFreqDocsEnumNoPos
specifier|public
name|LowFreqDocsEnumNoPos
parameter_list|(
name|Bits
name|liveDocs
parameter_list|)
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
block|}
DECL|method|canReuse
specifier|public
name|boolean
name|canReuse
parameter_list|(
name|Bits
name|liveDocs
parameter_list|)
block|{
return|return
name|liveDocs
operator|==
name|this
operator|.
name|liveDocs
return|;
block|}
DECL|method|reset
specifier|public
name|DocsEnum
name|reset
parameter_list|(
name|int
index|[]
name|postings
parameter_list|)
block|{
name|this
operator|.
name|postings
operator|=
name|postings
expr_stmt|;
name|upto
operator|=
operator|-
literal|2
expr_stmt|;
return|return
name|this
return|;
block|}
comment|// TODO: can do this w/o setting members?
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
block|{
name|upto
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|liveDocs
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|upto
operator|<
name|postings
operator|.
name|length
condition|)
block|{
return|return
name|postings
index|[
name|upto
index|]
return|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|upto
operator|<
name|postings
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|liveDocs
operator|.
name|get
argument_list|(
name|postings
index|[
name|upto
index|]
argument_list|)
condition|)
block|{
return|return
name|postings
index|[
name|upto
index|]
return|;
block|}
name|upto
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|NO_MORE_DOCS
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
if|if
condition|(
name|upto
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|upto
operator|<
name|postings
operator|.
name|length
condition|)
block|{
return|return
name|postings
index|[
name|upto
index|]
return|;
block|}
else|else
block|{
return|return
name|NO_MORE_DOCS
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
block|{
return|return
name|postings
index|[
name|upto
operator|+
literal|1
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
block|{
comment|// Linear scan, but this is low-freq term so it won't
comment|// be costly:
while|while
condition|(
name|nextDoc
argument_list|()
operator|<
name|target
condition|)
block|{       }
return|return
name|docID
argument_list|()
return|;
block|}
block|}
comment|// Docs + freqs + positions/offets:
DECL|class|LowFreqDocsEnum
specifier|private
specifier|final
specifier|static
class|class
name|LowFreqDocsEnum
extends|extends
name|DocsEnum
block|{
DECL|field|postings
specifier|private
name|int
index|[]
name|postings
decl_stmt|;
DECL|field|liveDocs
specifier|private
specifier|final
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|posMult
specifier|private
specifier|final
name|int
name|posMult
decl_stmt|;
DECL|field|upto
specifier|private
name|int
name|upto
decl_stmt|;
DECL|field|freq
specifier|private
name|int
name|freq
decl_stmt|;
DECL|method|LowFreqDocsEnum
specifier|public
name|LowFreqDocsEnum
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|int
name|posMult
parameter_list|)
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
name|this
operator|.
name|posMult
operator|=
name|posMult
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("LowFreqDE: posMult=" + posMult);
comment|// }
block|}
DECL|method|canReuse
specifier|public
name|boolean
name|canReuse
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|int
name|posMult
parameter_list|)
block|{
return|return
name|liveDocs
operator|==
name|this
operator|.
name|liveDocs
operator|&&
name|posMult
operator|==
name|this
operator|.
name|posMult
return|;
block|}
DECL|method|reset
specifier|public
name|DocsEnum
name|reset
parameter_list|(
name|int
index|[]
name|postings
parameter_list|)
block|{
name|this
operator|.
name|postings
operator|=
name|postings
expr_stmt|;
name|upto
operator|=
operator|-
literal|2
expr_stmt|;
name|freq
operator|=
literal|0
expr_stmt|;
return|return
name|this
return|;
block|}
comment|// TODO: can do this w/o setting members?
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
block|{
name|upto
operator|+=
literal|2
operator|+
name|freq
operator|*
name|posMult
expr_stmt|;
comment|// if (DEBUG) {
comment|//   System.out.println("  nextDoc freq=" + freq + " upto=" + upto + " vs " + postings.length);
comment|// }
if|if
condition|(
name|liveDocs
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|upto
operator|<
name|postings
operator|.
name|length
condition|)
block|{
name|freq
operator|=
name|postings
index|[
name|upto
operator|+
literal|1
index|]
expr_stmt|;
assert|assert
name|freq
operator|>
literal|0
assert|;
return|return
name|postings
index|[
name|upto
index|]
return|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|upto
operator|<
name|postings
operator|.
name|length
condition|)
block|{
name|freq
operator|=
name|postings
index|[
name|upto
operator|+
literal|1
index|]
expr_stmt|;
assert|assert
name|freq
operator|>
literal|0
assert|;
if|if
condition|(
name|liveDocs
operator|.
name|get
argument_list|(
name|postings
index|[
name|upto
index|]
argument_list|)
condition|)
block|{
return|return
name|postings
index|[
name|upto
index|]
return|;
block|}
name|upto
operator|+=
literal|2
operator|+
name|freq
operator|*
name|posMult
expr_stmt|;
block|}
block|}
return|return
name|NO_MORE_DOCS
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
comment|// TODO: store docID member?
if|if
condition|(
name|upto
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|upto
operator|<
name|postings
operator|.
name|length
condition|)
block|{
return|return
name|postings
index|[
name|upto
index|]
return|;
block|}
else|else
block|{
return|return
name|NO_MORE_DOCS
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
block|{
comment|// TODO: can I do postings[upto+1]?
return|return
name|freq
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
block|{
comment|// Linear scan, but this is low-freq term so it won't
comment|// be costly:
while|while
condition|(
name|nextDoc
argument_list|()
operator|<
name|target
condition|)
block|{       }
return|return
name|docID
argument_list|()
return|;
block|}
block|}
DECL|class|LowFreqDocsAndPositionsEnum
specifier|private
specifier|final
specifier|static
class|class
name|LowFreqDocsAndPositionsEnum
extends|extends
name|DocsAndPositionsEnum
block|{
DECL|field|postings
specifier|private
name|int
index|[]
name|postings
decl_stmt|;
DECL|field|liveDocs
specifier|private
specifier|final
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|posMult
specifier|private
specifier|final
name|int
name|posMult
decl_stmt|;
DECL|field|hasOffsets
specifier|private
specifier|final
name|boolean
name|hasOffsets
decl_stmt|;
DECL|field|hasPayloads
specifier|private
specifier|final
name|boolean
name|hasPayloads
decl_stmt|;
DECL|field|payload
specifier|private
specifier|final
name|BytesRef
name|payload
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
DECL|field|upto
specifier|private
name|int
name|upto
decl_stmt|;
DECL|field|docID
specifier|private
name|int
name|docID
decl_stmt|;
DECL|field|freq
specifier|private
name|int
name|freq
decl_stmt|;
DECL|field|skipPositions
specifier|private
name|int
name|skipPositions
decl_stmt|;
DECL|field|startOffset
specifier|private
name|int
name|startOffset
decl_stmt|;
DECL|field|endOffset
specifier|private
name|int
name|endOffset
decl_stmt|;
DECL|field|lastPayloadOffset
specifier|private
name|int
name|lastPayloadOffset
decl_stmt|;
DECL|field|payloadOffset
specifier|private
name|int
name|payloadOffset
decl_stmt|;
DECL|field|payloadLength
specifier|private
name|int
name|payloadLength
decl_stmt|;
DECL|field|payloadBytes
specifier|private
name|byte
index|[]
name|payloadBytes
decl_stmt|;
DECL|method|LowFreqDocsAndPositionsEnum
specifier|public
name|LowFreqDocsAndPositionsEnum
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|boolean
name|hasOffsets
parameter_list|,
name|boolean
name|hasPayloads
parameter_list|)
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
name|this
operator|.
name|hasOffsets
operator|=
name|hasOffsets
expr_stmt|;
name|this
operator|.
name|hasPayloads
operator|=
name|hasPayloads
expr_stmt|;
if|if
condition|(
name|hasOffsets
condition|)
block|{
if|if
condition|(
name|hasPayloads
condition|)
block|{
name|posMult
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|posMult
operator|=
literal|3
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|hasPayloads
condition|)
block|{
name|posMult
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|posMult
operator|=
literal|1
expr_stmt|;
block|}
block|}
DECL|method|reset
specifier|public
name|DocsAndPositionsEnum
name|reset
parameter_list|(
name|int
index|[]
name|postings
parameter_list|,
name|byte
index|[]
name|payloadBytes
parameter_list|)
block|{
name|this
operator|.
name|postings
operator|=
name|postings
expr_stmt|;
name|upto
operator|=
literal|0
expr_stmt|;
name|skipPositions
operator|=
literal|0
expr_stmt|;
name|startOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|endOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|docID
operator|=
operator|-
literal|1
expr_stmt|;
name|payloadLength
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|payloadBytes
operator|=
name|payloadBytes
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
block|{
if|if
condition|(
name|hasPayloads
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|skipPositions
condition|;
name|i
operator|++
control|)
block|{
name|upto
operator|++
expr_stmt|;
if|if
condition|(
name|hasOffsets
condition|)
block|{
name|upto
operator|+=
literal|2
expr_stmt|;
block|}
name|payloadOffset
operator|+=
name|postings
index|[
name|upto
operator|++
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|upto
operator|+=
name|posMult
operator|*
name|skipPositions
expr_stmt|;
block|}
if|if
condition|(
name|liveDocs
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|upto
operator|<
name|postings
operator|.
name|length
condition|)
block|{
name|docID
operator|=
name|postings
index|[
name|upto
operator|++
index|]
expr_stmt|;
name|freq
operator|=
name|postings
index|[
name|upto
operator|++
index|]
expr_stmt|;
name|skipPositions
operator|=
name|freq
expr_stmt|;
return|return
name|docID
return|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|upto
operator|<
name|postings
operator|.
name|length
condition|)
block|{
name|docID
operator|=
name|postings
index|[
name|upto
operator|++
index|]
expr_stmt|;
name|freq
operator|=
name|postings
index|[
name|upto
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|liveDocs
operator|.
name|get
argument_list|(
name|docID
argument_list|)
condition|)
block|{
name|skipPositions
operator|=
name|freq
expr_stmt|;
return|return
name|docID
return|;
block|}
if|if
condition|(
name|hasPayloads
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|freq
condition|;
name|i
operator|++
control|)
block|{
name|upto
operator|++
expr_stmt|;
if|if
condition|(
name|hasOffsets
condition|)
block|{
name|upto
operator|+=
literal|2
expr_stmt|;
block|}
name|payloadOffset
operator|+=
name|postings
index|[
name|upto
operator|++
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|upto
operator|+=
name|posMult
operator|*
name|freq
expr_stmt|;
block|}
block|}
block|}
return|return
name|docID
operator|=
name|NO_MORE_DOCS
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|docID
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
block|{
return|return
name|freq
return|;
block|}
annotation|@
name|Override
DECL|method|nextPosition
specifier|public
name|int
name|nextPosition
parameter_list|()
block|{
assert|assert
name|skipPositions
operator|>
literal|0
assert|;
name|skipPositions
operator|--
expr_stmt|;
specifier|final
name|int
name|pos
init|=
name|postings
index|[
name|upto
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|hasOffsets
condition|)
block|{
name|startOffset
operator|=
name|postings
index|[
name|upto
operator|++
index|]
expr_stmt|;
name|endOffset
operator|=
name|postings
index|[
name|upto
operator|++
index|]
expr_stmt|;
block|}
if|if
condition|(
name|hasPayloads
condition|)
block|{
name|payloadLength
operator|=
name|postings
index|[
name|upto
operator|++
index|]
expr_stmt|;
name|lastPayloadOffset
operator|=
name|payloadOffset
expr_stmt|;
name|payloadOffset
operator|+=
name|payloadLength
expr_stmt|;
block|}
return|return
name|pos
return|;
block|}
annotation|@
name|Override
DECL|method|startOffset
specifier|public
name|int
name|startOffset
parameter_list|()
block|{
return|return
name|startOffset
return|;
block|}
annotation|@
name|Override
DECL|method|endOffset
specifier|public
name|int
name|endOffset
parameter_list|()
block|{
return|return
name|endOffset
return|;
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
block|{
comment|// Linear scan, but this is low-freq term so it won't
comment|// be costly:
while|while
condition|(
name|nextDoc
argument_list|()
operator|<
name|target
condition|)
block|{       }
return|return
name|docID
return|;
block|}
annotation|@
name|Override
DECL|method|getPayload
specifier|public
name|BytesRef
name|getPayload
parameter_list|()
block|{
if|if
condition|(
name|payloadLength
operator|>
literal|0
condition|)
block|{
name|payload
operator|.
name|bytes
operator|=
name|payloadBytes
expr_stmt|;
name|payload
operator|.
name|offset
operator|=
name|lastPayloadOffset
expr_stmt|;
name|payload
operator|.
name|length
operator|=
name|payloadLength
expr_stmt|;
return|return
name|payload
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
comment|// Docs + freqs:
DECL|class|HighFreqDocsEnum
specifier|private
specifier|final
specifier|static
class|class
name|HighFreqDocsEnum
extends|extends
name|DocsEnum
block|{
DECL|field|docIDs
specifier|private
name|int
index|[]
name|docIDs
decl_stmt|;
DECL|field|freqs
specifier|private
name|int
index|[]
name|freqs
decl_stmt|;
DECL|field|liveDocs
specifier|private
specifier|final
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|upto
specifier|private
name|int
name|upto
decl_stmt|;
DECL|field|docID
specifier|private
name|int
name|docID
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|HighFreqDocsEnum
specifier|public
name|HighFreqDocsEnum
parameter_list|(
name|Bits
name|liveDocs
parameter_list|)
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
block|}
DECL|method|canReuse
specifier|public
name|boolean
name|canReuse
parameter_list|(
name|Bits
name|liveDocs
parameter_list|)
block|{
return|return
name|liveDocs
operator|==
name|this
operator|.
name|liveDocs
return|;
block|}
DECL|method|getDocIDs
specifier|public
name|int
index|[]
name|getDocIDs
parameter_list|()
block|{
return|return
name|docIDs
return|;
block|}
DECL|method|getFreqs
specifier|public
name|int
index|[]
name|getFreqs
parameter_list|()
block|{
return|return
name|freqs
return|;
block|}
DECL|method|reset
specifier|public
name|DocsEnum
name|reset
parameter_list|(
name|int
index|[]
name|docIDs
parameter_list|,
name|int
index|[]
name|freqs
parameter_list|)
block|{
name|this
operator|.
name|docIDs
operator|=
name|docIDs
expr_stmt|;
name|this
operator|.
name|freqs
operator|=
name|freqs
expr_stmt|;
name|docID
operator|=
name|upto
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
block|{
name|upto
operator|++
expr_stmt|;
if|if
condition|(
name|liveDocs
operator|==
literal|null
condition|)
block|{
try|try
block|{
return|return
name|docID
operator|=
name|docIDs
index|[
name|upto
index|]
return|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{         }
block|}
else|else
block|{
while|while
condition|(
name|upto
operator|<
name|docIDs
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|liveDocs
operator|.
name|get
argument_list|(
name|docIDs
index|[
name|upto
index|]
argument_list|)
condition|)
block|{
return|return
name|docID
operator|=
name|docIDs
index|[
name|upto
index|]
return|;
block|}
name|upto
operator|++
expr_stmt|;
block|}
block|}
return|return
name|docID
operator|=
name|NO_MORE_DOCS
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|docID
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
block|{
if|if
condition|(
name|freqs
operator|==
literal|null
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
name|freqs
index|[
name|upto
index|]
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
block|{
comment|/*       upto++;       if (upto == docIDs.length) {         return docID = NO_MORE_DOCS;       }       final int index = Arrays.binarySearch(docIDs, upto, docIDs.length, target);       if (index< 0) {         upto = -index - 1;       } else {         upto = index;       }       if (liveDocs != null) {         while (upto< docIDs.length) {           if (liveDocs.get(docIDs[upto])) {             break;           }           upto++;         }       }       if (upto == docIDs.length) {         return NO_MORE_DOCS;       } else {         return docID = docIDs[upto];       }       */
comment|//System.out.println("  advance target=" + target + " cur=" + docID() + " upto=" + upto + " of " + docIDs.length);
comment|// if (DEBUG) {
comment|//   System.out.println("advance target=" + target + " len=" + docIDs.length);
comment|// }
name|upto
operator|++
expr_stmt|;
if|if
condition|(
name|upto
operator|==
name|docIDs
operator|.
name|length
condition|)
block|{
return|return
name|docID
operator|=
name|NO_MORE_DOCS
return|;
block|}
comment|// First "grow" outwards, since most advances are to
comment|// nearby docs:
name|int
name|inc
init|=
literal|10
decl_stmt|;
name|int
name|nextUpto
init|=
name|upto
operator|+
literal|10
decl_stmt|;
name|int
name|low
decl_stmt|;
name|int
name|high
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|//System.out.println("  grow nextUpto=" + nextUpto + " inc=" + inc);
if|if
condition|(
name|nextUpto
operator|>=
name|docIDs
operator|.
name|length
condition|)
block|{
name|low
operator|=
name|nextUpto
operator|-
name|inc
expr_stmt|;
name|high
operator|=
name|docIDs
operator|.
name|length
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|//System.out.println("    docID=" + docIDs[nextUpto]);
if|if
condition|(
name|target
operator|<=
name|docIDs
index|[
name|nextUpto
index|]
condition|)
block|{
name|low
operator|=
name|nextUpto
operator|-
name|inc
expr_stmt|;
name|high
operator|=
name|nextUpto
expr_stmt|;
break|break;
block|}
name|inc
operator|*=
literal|2
expr_stmt|;
name|nextUpto
operator|+=
name|inc
expr_stmt|;
block|}
comment|// Now do normal binary search
comment|//System.out.println("    after fwd: low=" + low + " high=" + high);
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|low
operator|>
name|high
condition|)
block|{
comment|// Not exactly found
comment|//System.out.println("    break: no match");
name|upto
operator|=
name|low
expr_stmt|;
break|break;
block|}
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|int
name|cmp
init|=
name|docIDs
index|[
name|mid
index|]
operator|-
name|target
decl_stmt|;
comment|//System.out.println("    bsearch low=" + low + " high=" + high+ ": docIDs[" + mid + "]=" + docIDs[mid]);
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// Found target
name|upto
operator|=
name|mid
expr_stmt|;
comment|//System.out.println("    break: match");
break|break;
block|}
block|}
comment|//System.out.println("    end upto=" + upto + " docID=" + (upto>= docIDs.length ? NO_MORE_DOCS : docIDs[upto]));
if|if
condition|(
name|liveDocs
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
name|upto
operator|<
name|docIDs
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|liveDocs
operator|.
name|get
argument_list|(
name|docIDs
index|[
name|upto
index|]
argument_list|)
condition|)
block|{
break|break;
block|}
name|upto
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|upto
operator|==
name|docIDs
operator|.
name|length
condition|)
block|{
comment|//System.out.println("    return END");
return|return
name|docID
operator|=
name|NO_MORE_DOCS
return|;
block|}
else|else
block|{
comment|//System.out.println("    return docID=" + docIDs[upto] + " upto=" + upto);
return|return
name|docID
operator|=
name|docIDs
index|[
name|upto
index|]
return|;
block|}
block|}
block|}
comment|// TODO: specialize offsets and not
DECL|class|HighFreqDocsAndPositionsEnum
specifier|private
specifier|final
specifier|static
class|class
name|HighFreqDocsAndPositionsEnum
extends|extends
name|DocsAndPositionsEnum
block|{
DECL|field|docIDs
specifier|private
name|int
index|[]
name|docIDs
decl_stmt|;
DECL|field|freqs
specifier|private
name|int
index|[]
name|freqs
decl_stmt|;
DECL|field|positions
specifier|private
name|int
index|[]
index|[]
name|positions
decl_stmt|;
DECL|field|payloads
specifier|private
name|byte
index|[]
index|[]
index|[]
name|payloads
decl_stmt|;
DECL|field|liveDocs
specifier|private
specifier|final
name|Bits
name|liveDocs
decl_stmt|;
DECL|field|hasOffsets
specifier|private
specifier|final
name|boolean
name|hasOffsets
decl_stmt|;
DECL|field|posJump
specifier|private
specifier|final
name|int
name|posJump
decl_stmt|;
DECL|field|upto
specifier|private
name|int
name|upto
decl_stmt|;
DECL|field|docID
specifier|private
name|int
name|docID
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|posUpto
specifier|private
name|int
name|posUpto
decl_stmt|;
DECL|field|curPositions
specifier|private
name|int
index|[]
name|curPositions
decl_stmt|;
DECL|method|HighFreqDocsAndPositionsEnum
specifier|public
name|HighFreqDocsAndPositionsEnum
parameter_list|(
name|Bits
name|liveDocs
parameter_list|,
name|boolean
name|hasOffsets
parameter_list|)
block|{
name|this
operator|.
name|liveDocs
operator|=
name|liveDocs
expr_stmt|;
name|this
operator|.
name|hasOffsets
operator|=
name|hasOffsets
expr_stmt|;
name|posJump
operator|=
name|hasOffsets
condition|?
literal|3
else|:
literal|1
expr_stmt|;
block|}
DECL|method|getDocIDs
specifier|public
name|int
index|[]
name|getDocIDs
parameter_list|()
block|{
return|return
name|docIDs
return|;
block|}
DECL|method|getPositions
specifier|public
name|int
index|[]
index|[]
name|getPositions
parameter_list|()
block|{
return|return
name|positions
return|;
block|}
DECL|method|getPosJump
specifier|public
name|int
name|getPosJump
parameter_list|()
block|{
return|return
name|posJump
return|;
block|}
DECL|method|getLiveDocs
specifier|public
name|Bits
name|getLiveDocs
parameter_list|()
block|{
return|return
name|liveDocs
return|;
block|}
DECL|method|reset
specifier|public
name|DocsAndPositionsEnum
name|reset
parameter_list|(
name|int
index|[]
name|docIDs
parameter_list|,
name|int
index|[]
name|freqs
parameter_list|,
name|int
index|[]
index|[]
name|positions
parameter_list|,
name|byte
index|[]
index|[]
index|[]
name|payloads
parameter_list|)
block|{
name|this
operator|.
name|docIDs
operator|=
name|docIDs
expr_stmt|;
name|this
operator|.
name|freqs
operator|=
name|freqs
expr_stmt|;
name|this
operator|.
name|positions
operator|=
name|positions
expr_stmt|;
name|this
operator|.
name|payloads
operator|=
name|payloads
expr_stmt|;
name|upto
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|nextDoc
specifier|public
name|int
name|nextDoc
parameter_list|()
block|{
name|upto
operator|++
expr_stmt|;
if|if
condition|(
name|liveDocs
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|upto
operator|<
name|docIDs
operator|.
name|length
condition|)
block|{
name|posUpto
operator|=
operator|-
name|posJump
expr_stmt|;
name|curPositions
operator|=
name|positions
index|[
name|upto
index|]
expr_stmt|;
return|return
name|docID
operator|=
name|docIDs
index|[
name|upto
index|]
return|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|upto
operator|<
name|docIDs
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|liveDocs
operator|.
name|get
argument_list|(
name|docIDs
index|[
name|upto
index|]
argument_list|)
condition|)
block|{
name|posUpto
operator|=
operator|-
name|posJump
expr_stmt|;
name|curPositions
operator|=
name|positions
index|[
name|upto
index|]
expr_stmt|;
return|return
name|docID
operator|=
name|docIDs
index|[
name|upto
index|]
return|;
block|}
name|upto
operator|++
expr_stmt|;
block|}
block|}
return|return
name|docID
operator|=
name|NO_MORE_DOCS
return|;
block|}
annotation|@
name|Override
DECL|method|freq
specifier|public
name|int
name|freq
parameter_list|()
block|{
return|return
name|freqs
index|[
name|upto
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|docID
specifier|public
name|int
name|docID
parameter_list|()
block|{
return|return
name|docID
return|;
block|}
annotation|@
name|Override
DECL|method|nextPosition
specifier|public
name|int
name|nextPosition
parameter_list|()
block|{
name|posUpto
operator|+=
name|posJump
expr_stmt|;
return|return
name|curPositions
index|[
name|posUpto
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|startOffset
specifier|public
name|int
name|startOffset
parameter_list|()
block|{
if|if
condition|(
name|hasOffsets
condition|)
block|{
return|return
name|curPositions
index|[
name|posUpto
operator|+
literal|1
index|]
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|endOffset
specifier|public
name|int
name|endOffset
parameter_list|()
block|{
if|if
condition|(
name|hasOffsets
condition|)
block|{
return|return
name|curPositions
index|[
name|posUpto
operator|+
literal|2
index|]
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|advance
specifier|public
name|int
name|advance
parameter_list|(
name|int
name|target
parameter_list|)
block|{
comment|/*       upto++;       if (upto == docIDs.length) {         return NO_MORE_DOCS;       }       final int index = Arrays.binarySearch(docIDs, upto, docIDs.length, target);       if (index< 0) {         upto = -index - 1;       } else {         upto = index;       }       if (liveDocs != null) {         while (upto< docIDs.length) {           if (liveDocs.get(docIDs[upto])) {             break;           }           upto++;         }       }       posUpto = hasOffsets ? -3 : -1;       if (upto == docIDs.length) {         return NO_MORE_DOCS;       } else {         return docID();       }       */
comment|//System.out.println("  advance target=" + target + " cur=" + docID() + " upto=" + upto + " of " + docIDs.length);
comment|// if (DEBUG) {
comment|//   System.out.println("advance target=" + target + " len=" + docIDs.length);
comment|// }
name|upto
operator|++
expr_stmt|;
if|if
condition|(
name|upto
operator|==
name|docIDs
operator|.
name|length
condition|)
block|{
return|return
name|docID
operator|=
name|NO_MORE_DOCS
return|;
block|}
comment|// First "grow" outwards, since most advances are to
comment|// nearby docs:
name|int
name|inc
init|=
literal|10
decl_stmt|;
name|int
name|nextUpto
init|=
name|upto
operator|+
literal|10
decl_stmt|;
name|int
name|low
decl_stmt|;
name|int
name|high
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|//System.out.println("  grow nextUpto=" + nextUpto + " inc=" + inc);
if|if
condition|(
name|nextUpto
operator|>=
name|docIDs
operator|.
name|length
condition|)
block|{
name|low
operator|=
name|nextUpto
operator|-
name|inc
expr_stmt|;
name|high
operator|=
name|docIDs
operator|.
name|length
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|//System.out.println("    docID=" + docIDs[nextUpto]);
if|if
condition|(
name|target
operator|<=
name|docIDs
index|[
name|nextUpto
index|]
condition|)
block|{
name|low
operator|=
name|nextUpto
operator|-
name|inc
expr_stmt|;
name|high
operator|=
name|nextUpto
expr_stmt|;
break|break;
block|}
name|inc
operator|*=
literal|2
expr_stmt|;
name|nextUpto
operator|+=
name|inc
expr_stmt|;
block|}
comment|// Now do normal binary search
comment|//System.out.println("    after fwd: low=" + low + " high=" + high);
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|low
operator|>
name|high
condition|)
block|{
comment|// Not exactly found
comment|//System.out.println("    break: no match");
name|upto
operator|=
name|low
expr_stmt|;
break|break;
block|}
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|int
name|cmp
init|=
name|docIDs
index|[
name|mid
index|]
operator|-
name|target
decl_stmt|;
comment|//System.out.println("    bsearch low=" + low + " high=" + high+ ": docIDs[" + mid + "]=" + docIDs[mid]);
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// Found target
name|upto
operator|=
name|mid
expr_stmt|;
comment|//System.out.println("    break: match");
break|break;
block|}
block|}
comment|//System.out.println("    end upto=" + upto + " docID=" + (upto>= docIDs.length ? NO_MORE_DOCS : docIDs[upto]));
if|if
condition|(
name|liveDocs
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
name|upto
operator|<
name|docIDs
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|liveDocs
operator|.
name|get
argument_list|(
name|docIDs
index|[
name|upto
index|]
argument_list|)
condition|)
block|{
break|break;
block|}
name|upto
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|upto
operator|==
name|docIDs
operator|.
name|length
condition|)
block|{
comment|//System.out.println("    return END");
return|return
name|docID
operator|=
name|NO_MORE_DOCS
return|;
block|}
else|else
block|{
comment|//System.out.println("    return docID=" + docIDs[upto] + " upto=" + upto);
name|posUpto
operator|=
operator|-
name|posJump
expr_stmt|;
name|curPositions
operator|=
name|positions
index|[
name|upto
index|]
expr_stmt|;
return|return
name|docID
operator|=
name|docIDs
index|[
name|upto
index|]
return|;
block|}
block|}
DECL|field|payload
specifier|private
specifier|final
name|BytesRef
name|payload
init|=
operator|new
name|BytesRef
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getPayload
specifier|public
name|BytesRef
name|getPayload
parameter_list|()
block|{
if|if
condition|(
name|payloads
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
specifier|final
name|byte
index|[]
name|payloadBytes
init|=
name|payloads
index|[
name|upto
index|]
index|[
name|posUpto
operator|/
operator|(
name|hasOffsets
condition|?
literal|3
else|:
literal|1
operator|)
index|]
decl_stmt|;
if|if
condition|(
name|payloadBytes
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|payload
operator|.
name|bytes
operator|=
name|payloadBytes
expr_stmt|;
name|payload
operator|.
name|length
operator|=
name|payloadBytes
operator|.
name|length
expr_stmt|;
name|payload
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
return|return
name|payload
return|;
block|}
block|}
block|}
block|}
end_class
end_unit
